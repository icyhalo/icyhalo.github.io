<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Sping整合web</title>
      <link href="/2023/11/11/Sping%E9%AB%98%E7%BA%A7%E6%95%B4%E5%90%88web/"/>
      <url>/2023/11/11/Sping%E9%AB%98%E7%BA%A7%E6%95%B4%E5%90%88web/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring整合web环境"><a href="#Spring整合web环境" class="headerlink" title="Spring整合web环境"></a>Spring整合web环境</h1><h2 id="Javaweb三大组件及环境特点"><a href="#Javaweb三大组件及环境特点" class="headerlink" title="Javaweb三大组件及环境特点"></a>Javaweb三大组件及环境特点</h2><p>在Java语言范畴内，web层框架都是基于Javaweb基础组件完成的，所以有必要复习一下Javaweb组件的特点</p><table><thead><tr><th>组件</th><th>作用</th><th>特点</th></tr></thead><tbody><tr><td>Servlet</td><td>服务端小程序，负责接收客户端 请求并作出响应的</td><td><strong>单例对象，默认第一次访问创建</strong>，可以通过配置指定服务器启动就创建，Servlet创建完毕会执行初始化init方法。<br>每个Servlet有一个service方法，每次访问都会执行service方法，但是缺点是一个业务功能就需要配置一个Servlet</td></tr><tr><td>Filter</td><td>过滤器，负责对客户端请求进行过滤操作的</td><td><strong>单例对象，服务器启动时就创建</strong>，对象创建完毕执行init方法，对客户端的请求 进行过滤，符合要求的放行，不符合要求的直接响应客户端，执行过滤的核心 方法doFilter</td></tr><tr><td>Listener</td><td>监听器，负责对域对象的创建和属性变化进行监听的</td><td>根据类型和作用不同，又可分为监听域对象创建销毁和域对象属性内容变化的， 根据监听的域不同，又可以分为监听Request域的，监听Session域的，监听 ServletContext域的</td></tr></tbody></table><h3 id="三大组件"><a href="#三大组件" class="headerlink" title="三大组件"></a>三大组件</h3><p>Servlet</p><ul><li>服务端程序</li><li>功能:用于接受客户端请求并做出响应</li><li>作用范围:多例,每个请求都会实例化一个Servlet对象来处理。不同请求的Servlet实例是独立的，相互之间没有影响</li><li>创建时机:默认第一次访问时,Servlet创建，缓存到web容器当中，类似于延迟加载的bean对象，可以配置load-on-starup指定创建时机，Servlet创建时会执行init方法，每次访问Servlet时会执行service方法。</li></ul><p>Filter</p><ul><li>过滤器</li><li>功能:负责请求和响应进行过滤处理，放行或者拦截</li><li>作用范围:单例,一个Web应用通常只有一个过滤器实例</li><li>创建时机:服务器启动时就会创建,创建完毕时会执行init方法</li></ul><p>Listener</p><ul><li>监听器</li><li>功能:用于监听Web应用中的事件,主要监听域对象的创建与销毁，最常监听ServletContext域</li><li>作用范围:单例,监听器是单例的，一个Web应用通常只有一个监听器实例，它在整个应用的生命周期中起作用。</li><li>创建时机:服务器启动时就会创建</li></ul><p>在服务器启动时想执行一些逻辑代码可以选择：Servlet，filter的init方法，listener监听application域的监听代码中</p><h3 id="JSP中的四大域对象"><a href="#JSP中的四大域对象" class="headerlink" title="JSP中的四大域对象"></a>JSP中的四大域对象</h3><ul><li>page域对象（只在当前页面中有效）</li><li>request域对象（只在一次请求中有效，服务端跳转有效，客户端跳转无效）</li><li>session域对象（在一次会话中有效，服务端客户端跳转都有效）</li><li>application域对象（在整个应用程序中都有效）服务器启动时就会创建，就会有监听器监听application域的创建</li></ul><h2 id="Spring整合web环境的思路及实现"><a href="#Spring整合web环境的思路及实现" class="headerlink" title="Spring整合web环境的思路及实现"></a>Spring整合web环境的思路及实现</h2><p>在进行Java开发时要遵循三层架构+MVC</p><p>Spring操作最核心的就是Spring容器，web层需要注入Service， service层需要注入Dao（Mapper），web层使用Servlet技术充当的话，需要在Servlet中获得Spring容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(urlPatterns = &quot;/accountServlet&quot;)</span><br><span class="line">public class AccountServlet extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        //web层调用service层 获得AccountService 获得AccountService存在于spring容器总</span><br><span class="line">        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        AccountService bean = applicationContext.getBean(AccountService.class);</span><br><span class="line">        bean.transferMoney(&quot;luck&quot;,&quot;bad&quot;,100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在的问题：</p><ol><li>上述代码的耦合度过高</li><li>每一个Servlet的doget方法都需要创建一次容器，加载一个配置类，才获得bean对象。极大的影响开发性能</li></ol><p>改进：</p><ul><li><p>ApplicationContext创建一次，配置类加载一次，也就是容器只创建一次</p></li><li><p>最好在web服务器启动时就执行第一步操作，避免第一个访问等待时间过长，后续直接从容器中获取Bean即可</p><blockquote><p>Servlet，filter的init方法，listener监听等</p></blockquote></li><li><p>ApplicationContext的引用需要存在web层的任何位置都能获取到</p></li></ul><h2 id="模拟ContextLoaderListener"><a href="#模拟ContextLoaderListener" class="headerlink" title="模拟ContextLoaderListener"></a>模拟ContextLoaderListener</h2><p>思路：</p><ol><li><p>可以在Listener监听器中的contextInitialized方法中执行创建applicationContext代码。</p><p>或者在Servlet的init方法中执行applicationContext的创建</p></li><li><p>在web.xml中设置Servlet的load-on-starup属性值确保服务器启动时Servlet就创建执行init方法</p></li><li><p>将创建好的applicationContext存储到ServletContext中这样在整个web层都可以获取到</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ContextLoaderListener implements ServletContextListener &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void contextInitialized(ServletContextEvent sce) &#123;</span><br><span class="line">        System.out.println(&quot;ContextLoaderListener contextInitialized...&quot;);</span><br><span class="line">        </span><br><span class="line">        //1.创建Spring容器</span><br><span class="line">        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        </span><br><span class="line">        //2.将容器创建到ServletContext域中</span><br><span class="line">        sce.getServletContext().setAttribute(&quot;applicationContext&quot;,applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>contextInitialized这个方法只执行一次，故只创建一次spring容器</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span><br><span class="line">  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">  xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span><br><span class="line">  version=&quot;4.0&quot;&gt;</span><br><span class="line">  &lt;!--配置Listener--&gt;</span><br><span class="line">  &lt;listener&gt;</span><br><span class="line">    &lt;listener-class&gt;com.heima.listener.ContextLoaderListener&lt;/listener-class&gt;</span><br><span class="line">  &lt;/listener&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure><p>新的问题：耦合度过高，需要解决两个解耦问题</p><ol><li><p>在监听器listener中获取applicationContext时将配置文件名写死了，这就导致在开发过程中我们只能以这种命名方式，这是不被允许的，所以我们需要在web.xml文件中配置全局参数，将配置文件名从代码中解耦出来，之后只用在web.xml文件中进行修改即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ContextLoaderListener implements ServletContextListener &#123;</span><br><span class="line">    private String CONTEXT_CONFIG_LOCATION = &quot;contextConfigLocation&quot;;</span><br><span class="line">    @Override</span><br><span class="line">    public void contextInitialized(ServletContextEvent sce) &#123;</span><br><span class="line">        System.out.println(&quot;ContextLoaderListener contextInitialized...&quot;);</span><br><span class="line">        ServletContext servletContext = sce.getServletContext();</span><br><span class="line">        //获取ContextConfigLocation配置文件名称</span><br><span class="line">        String contextConfigLocation = servletContext.getInitParameter(CONTEXT_CONFIG_LOCATION);</span><br><span class="line">        //解析出配置文件名称</span><br><span class="line">        contextConfigLocation = contextConfigLocation.substring(&quot;classpath:&quot;.length());</span><br><span class="line">        //1.创建Spring容器</span><br><span class="line">        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(contextConfigLocation);</span><br><span class="line">        //2.将容器创建到ServletContext域中</span><br><span class="line">        servletContext.setAttribute(&quot;applicationContext&quot;,applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span><br><span class="line">         version=&quot;4.0&quot;&gt;</span><br><span class="line">    &lt;!--定义全局参数--&gt;</span><br><span class="line">    &lt;context-param&gt;</span><br><span class="line">        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">        &lt;!--类加载路径--&gt;</span><br><span class="line">        &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;</span><br><span class="line">    &lt;/context-param&gt;</span><br><span class="line">&lt;!--配置Listener--&gt;</span><br><span class="line">    &lt;listener&gt;</span><br><span class="line">        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;</span><br><span class="line">    &lt;/listener&gt;</span><br><span class="line"> </span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure></li><li><p>从ServletContext获取applicationContext时是通过字符串获取的，在自定义框架时尽可能不要有特殊字符串需要程序员自己去记，需要将耦合死的字符串隐藏一下，框架内部去消化，或者通过一个工具类直接获取进行解耦</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class WebApplicationContextUtils &#123;</span><br><span class="line">    public static ApplicationContext getWebApplicationContext(ServletContext servletContext)&#123;</span><br><span class="line">        return (ApplicationContext) servletContext.getAttribute(&quot;applicationContext&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@WebServlet(urlPatterns = &quot;/accountServlet&quot;)</span><br><span class="line">public class AccountServlet extends HttpServlet &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        //web层调用service层 获得AccountService 获得AccountService存在于spring容器总</span><br><span class="line">        ServletContext servletContext = request.getServletContext();</span><br><span class="line">        ApplicationContext applicationContext = WebApplicationContextUtils.getWebApplicationContext(servletContext);</span><br><span class="line">        AccountService bean = applicationContext.getBean(AccountService.class);</span><br><span class="line">        bean.transferMoney(&quot;luck&quot;,&quot;bad&quot;,100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Spring的web开发组件spring-web"><a href="#Spring的web开发组件spring-web" class="headerlink" title="Spring的web开发组件spring-web"></a>Spring的web开发组件spring-web</h2><p>pom.xml中直接导入spring-web的jar包，之后替换掉模拟的ContextLoaderListener和web.xml的全路径名</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring高级Aop 事务</title>
      <link href="/2023/11/11/Spring%E9%AB%98%E7%BA%A7Aop/"/>
      <url>/2023/11/11/Spring%E9%AB%98%E7%BA%A7Aop/</url>
      
        <content type="html"><![CDATA[<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>AOP，Aspect Oriented Programming，面向切面编程，是对面向对象编程OOP的升华。OOP是纵向对一个事物的抽象，一个对象包括静态的属性信息，包括动态的方法信息等。而AOP是横向的对不同事物的抽象，属性与属性、方法与方法、对象与对象都可以组成一个切面，而用这种思维去设计编程的方式叫做面向切面编程</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231111221215308.png" alt="image-20231111221215308"></p><h2 id="模拟AOP的基础代码"><a href="#模拟AOP的基础代码" class="headerlink" title="模拟AOP的基础代码"></a>模拟AOP的基础代码</h2><p>其实在之前学习BeanPostProcessor时，在BeanPostProcessor的after方法中使用动态代理对Bean进行了增 强，实际存储到单例池singleObjects中的不是当前目标对象本身，而是当前目标对象的代理对象Proxy，这样 在调用目标对象方法时，实际调用的是代理对象Proxy的同名方法，起到了目标方法前后都进行增强的功能， 对该方式进行一下优化，将增强的方法提取出去到一个增强类中，且只对com.itheima.service.impl包下的任 何类的任何方法进行增强</p><div class="tabs" id="1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#1-1">自定义增强类</button></li><li class="tab"><button type="button" data-href="#1-2">目标类</button></li><li class="tab"><button type="button" data-href="#1-3">实现类</button></li><li class="tab"><button type="button" data-href="#1-4">XML</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><p>增强类，内部提供增强方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//自定义增强类</span><br><span class="line">public class MyAdvice &#123;</span><br><span class="line">    //前置增强</span><br><span class="line">    public void beforeAdvice()&#123;</span><br><span class="line">        System.out.println(&quot;beforeAdvice ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //后置增强</span><br><span class="line">    public void afterAdvice()&#123;</span><br><span class="line">        System.out.println(&quot;afterAdvice ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//自定义增强类</span><br><span class="line">public class MyPropose &#123;</span><br><span class="line">    //前置增强</span><br><span class="line">    public void show1()&#123;</span><br><span class="line">        System.out.println(&quot;show1 ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //后置增强</span><br><span class="line">    public void show2()&#123;</span><br><span class="line">        System.out.println(&quot;show2 ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-3"><p>目的: UserServi ceImpl中的show1和show2方法进行增强，增强方法存在MyAdvice中</p><p>问题</p><ol><li><p>筛选service. impl包下的所有的类的所有方法都可以进行增强，MyAdvice怎样获取？</p><p>解决方案if- else</p></li><li><p>MyAdvice怎么获取到?</p><p>从Spring容器中获得MyAdvice</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class MockAopBeanPostProcessor implements BeanPostProcessor, ApplicationContextAware &#123;</span><br><span class="line">    private ApplicationContext applicationContext;//注入Spring容器对象</span><br><span class="line">    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">    </span><br><span class="line">        //获得Advice对象</span><br><span class="line">        MyAdvice myAdvice = applicationContext.getBean(MyAdvice.class);</span><br><span class="line">        String packageName = bean.getClass().getPackage().getName();</span><br><span class="line">        </span><br><span class="line">        if(&quot;com.itheima.service.impl&quot;.equals(packageName))&#123;</span><br><span class="line">        </span><br><span class="line">            //对Bean进行动态代理，返回的是Proxy代理对象</span><br><span class="line">            Object proxyBean = Proxy.newProxyInstance(</span><br><span class="line">                    bean.getClass().getClassLoader(),</span><br><span class="line">                    bean.getClass().getInterfaces(),</span><br><span class="line">                    (Object proxy, Method method, Object[] args) -&gt; &#123;</span><br><span class="line">                    </span><br><span class="line">                        //执行Advice的before方法</span><br><span class="line">                        myAdvice.beforeAdvice();</span><br><span class="line">                        </span><br><span class="line">                        //执行目标</span><br><span class="line">                        Object result = method.invoke(bean, args);</span><br><span class="line">                        </span><br><span class="line">                        //执行Advice的after方法</span><br><span class="line">                        myAdvice.afterAdvice();</span><br><span class="line">                        return result; &#125;);</span><br><span class="line">                        </span><br><span class="line">            //返回代理对象</span><br><span class="line">            return proxyBean; &#125;</span><br><span class="line">            </span><br><span class="line">        return bean; &#125;</span><br><span class="line">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class="line">        this.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-4"><p>配置目标类和增强类的bean</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id...&gt;</span><br><span class="line">&lt;bean id...&gt;</span><br></pre></td></tr></table></figure><p> 目前的学习中，几乎所有的bean都要注入到spring容器中，这样 才能参与spring的生命周期</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="AOP相关概念"><a href="#AOP相关概念" class="headerlink" title="AOP相关概念"></a>AOP相关概念</h2><p>动态代理技术，在运行期间，对目标对象的方法进行增强，代理对象同名方法内可以执行原有逻辑的同时嵌入执行其他增强逻辑或其他对象的方法</p><table><thead><tr><th>概念</th><th>单词</th><th>解释</th></tr></thead><tbody><tr><td>目标对象</td><td>Target</td><td>被增强的方法所在的对象</td></tr><tr><td>代理对象</td><td>Proxy</td><td>对目标对象进行增强后的对象，客户端实际调用的对象</td></tr><tr><td>连接点</td><td>Joinpoint</td><td>目标对象中可以被增强的方法</td></tr><tr><td>切入点</td><td>Pointcut</td><td>目标对象中实际被增强的方法</td></tr><tr><td>通知\增强</td><td>Advice</td><td>增强部分的代码逻辑</td></tr><tr><td>切面</td><td>Aspect</td><td>增强和切入点的组合</td></tr><tr><td>织入</td><td>Weaving</td><td>将通知和切入点组合动态组合的过程</td></tr></tbody></table><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231111222800685.png" alt="image-20231111222800685"></p><h2 id="基于xml配置的AOP"><a href="#基于xml配置的AOP" class="headerlink" title="基于xml配置的AOP"></a>基于xml配置的AOP</h2><h3 id="xml方式AOP快速入门"><a href="#xml方式AOP快速入门" class="headerlink" title="xml方式AOP快速入门"></a>xml方式AOP快速入门</h3><p>通过配置文件的方式去解决上述问题</p><ol><li>配置哪些包、哪些类、哪些方法需要被增强</li><li>配置目标方法要被哪些通知方法所增强，在目标方法执行之前还是之后执行增强</li></ol><p>配置方式的设计、配置文件（注解）的解析工作，Spring已经帮我们封装好了</p><p>步骤： </p><ol><li><p>导入AOP相关坐标</p><p>Spring-context坐标下已经包含spring-aop的包了，所以就不用额外导入了</p></li><li><p>准备目标类、准备增强类，并配置给Spring管理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface UserService &#123;</span><br><span class="line">void show1();</span><br><span class="line">void show2();</span><br><span class="line">&#125;</span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line">public void show1() &#123;</span><br><span class="line">System.out.println(&quot;show1...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void show2() &#123;</span><br><span class="line">System.out.println(&quot;show2...&quot;);</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MyAdvice &#123;</span><br><span class="line">public void beforeAdvice()&#123;</span><br><span class="line">System.out.println(&quot;beforeAdvice&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void afterAdvice()&#123;</span><br><span class="line">System.out.println(&quot;afterAdvice&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置目标类,内部的方法是连接点--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.UserServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置通知类,内部的方法是增强方法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">“myAdvice</span>&quot; <span class="attr">class</span>=<span class="string">&quot;com.itheima.advice.MyAdvice&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置切点表达式（哪些方法被增强）</p></li><li><p>配置织入（切点被哪些通知方法增强，是前置增强还是后置增强）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:config&gt;</span><br><span class="line">&lt;!--配置切点表达式,对哪些方法进行增强--&gt;</span><br><span class="line">&lt;aop:pointcut id=&quot;myPointcut&quot; expression=&quot;execution(void</span><br><span class="line">com.itheima.service.impl.UserServiceImpl.show1())&quot;/&gt;</span><br><span class="line">&lt;!--切面=切点+通知--&gt;</span><br><span class="line">&lt;aop:aspect ref=&quot;myAdvice&quot;&gt;</span><br><span class="line">&lt;!--指定前置通知方法是beforeAdvice--&gt;</span><br><span class="line">&lt;aop:before method=&quot;beforeAdvice&quot; pointcut-ref=&quot;myPointcut&quot;/&gt;</span><br><span class="line">&lt;!--指定后置通知方法是afterAdvice--&gt;</span><br><span class="line">&lt;aop:after-returning method=&quot;afterAdvice&quot; pointcut-ref=&quot;myPointcut&quot;/&gt;</span><br><span class="line">&lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="xml方式AOP配置详解"><a href="#xml方式AOP配置详解" class="headerlink" title="xml方式AOP配置详解"></a>xml方式AOP配置详解</h3><p>AOP详细配置的细节： </p><ol><li>切点表达式的配置方式 </li><li>切点表达式的配置语法 </li><li>通知的类型 </li><li>AOP的配置的两种方式</li></ol><h4 id="切点表达式的配置方式"><a href="#切点表达式的配置方式" class="headerlink" title="切点表达式的配置方式"></a>切点表达式的配置方式</h4><p>切点表达式的配置方式有两种，直接将切点表达式配置在通知上，也可以将切点表达式抽取到外面，在通知上进行引用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:config&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!--配置切点表达式,对哪些方法进行增强--&gt;</span><br><span class="line">  &lt;aop:pointcut id=&quot;myPointcut&quot; expression=&quot;execution(void com.itheima.service.impl.UserServiceImpl.show1())&quot;/&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;!--切面=切点+通知--&gt;</span><br><span class="line">  &lt;aop:aspect ref=&quot;myAdvice&quot;&gt;</span><br><span class="line">  </span><br><span class="line">    &lt;!--指定前置通知方法是beforeAdvice--&gt;</span><br><span class="line">    &lt;aop:before method=&quot;beforeAdvice&quot; pointcut-ref=&quot;myPointcut&quot;/&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!--指定后置通知方法是afterAdvice--&gt;</span><br><span class="line">    &lt;aop:after-returning method=&quot;afterAdvice&quot; pointcut=&quot;execution(void</span><br><span class="line">com.itheima.service.impl.UserServiceImpl.show1())&quot;/&gt;</span><br><span class="line">  &lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure><h4 id="切点表达式的语法"><a href="#切点表达式的语法" class="headerlink" title="切点表达式的语法"></a>切点表达式的语法</h4><p>切点表达式是配置要对哪些连接点（哪些类的哪些方法）进行通知的增强，语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution([访问修饰符]返回值类型 包名.类名.方法名(参数))</span><br></pre></td></tr></table></figure><ol><li>访问修饰符可以省略不写</li><li>返回值类型、某一级包名、类名、方法名 可以使用 * 表示任意</li><li>包名与类名之间使用单点 . 表示该包下的类，使用双点 .. 表示该包及其子包下的类</li><li>参数列表可以使用两个点 .. 表示任意参数。</li></ol><p>切点表达式举几个例子方便理解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//表示访问修饰符为public、无返回值、在com.itheima.aop包下的TargetImpl类的无参方法show</span><br><span class="line">execution(public void com.itheima.aop.TargetImpl.show())</span><br><span class="line">//表述com.itheima.aop包下的TargetImpl类的任意方法</span><br><span class="line">execution(* com.itheima.aop.TargetImpl.*(..))</span><br><span class="line">//表示com.itheima.aop包下的任意类的任意方法</span><br><span class="line">execution(* com.itheima.aop.*.*(..))</span><br><span class="line">//表示com.itheima.aop包及其子包下的任意类的任意方法</span><br><span class="line">execution(* com.itheima.aop..*.*(..))</span><br><span class="line">//表示任意包中的任意类的任意方法</span><br><span class="line">execution(* *..*.*(..))</span><br></pre></td></tr></table></figure><h4 id="通知的类型"><a href="#通知的类型" class="headerlink" title="通知的类型"></a>通知的类型</h4><table><thead><tr><th>通知名称</th><th>配置方式</th><th>执行时机</th></tr></thead><tbody><tr><td>前置通知</td><td>&lt; aop:before &gt;</td><td>目标方法执行之前执行</td></tr><tr><td>后置通知</td><td>&lt; aop:after-returning &gt;</td><td>目标方法执行之后执行，目标方法异常时，不在执行</td></tr><tr><td>环绕通知</td><td>&lt; aop:around &gt;</td><td>目标方法执行前后执行，目标方法异常时，环绕后方法不在执行</td></tr><tr><td>异常通知</td><td>&lt; aop:after-throwing &gt;</td><td>目标方法抛出异常时执行</td></tr><tr><td>最终通知</td><td>&lt; aop:after &gt;</td><td>不管目标方法是否有异常，最终都会执行</td></tr></tbody></table><ul><li><p>环绕通知（常用）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void around(ProceedingJoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">  //环绕前</span><br><span class="line">  System.out.println(&quot;环绕前通知&quot;);</span><br><span class="line">  //目标方法</span><br><span class="line">  joinPoint.proceed();</span><br><span class="line">  //环绕后</span><br><span class="line">  System.out.println(&quot;环绕后通知&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:around method=&quot;around&quot; pointcut-ref=&quot;myPointcut&quot;/&gt;</span><br></pre></td></tr></table></figure></li><li><p>异常通知</p><p>当目标方法抛出异常时，异常通知方法执行，且后置通知和环绕后通知不在执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void afterThrowing()&#123;</span><br><span class="line">  System.out.println(&quot;目标方法抛出异常了，后置通知和环绕后通知不在执行&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut-ref=&quot;myPointcut&quot;/&gt;</span><br></pre></td></tr></table></figure></li><li><p>异常通知</p><p>类似异常捕获中的finally，不管目标方法有没有异常，最终都会执行的通知</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void after()&#123;</span><br><span class="line">  System.out.println(&quot;不管目标方法有无异常，我都会执行&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;myPointcut&quot;/&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="通知方法传参"><a href="#通知方法传参" class="headerlink" title="通知方法传参"></a>通知方法传参</h4><p>通知方法在被调用时，Spring可以为其传递一些必要的参数</p><table><thead><tr><th>参数类型</th><th>作用</th></tr></thead><tbody><tr><td>JoinPoint</td><td>连接点对象，任何通知都可使用，可以获得当前目标对象、目标方法参数等信息</td></tr><tr><td>ProceedingJoinPoint</td><td>JoinPoint子类对象，主要是在环绕通知中执行proceed()，进而执行目标方法</td></tr><tr><td>Throwable</td><td>异常对象，使用在异常通知中，需要在配置文件中指出异常对象名称</td></tr></tbody></table><p>JoinPoint 对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void 通知方法名称(JoinPoint joinPoint)&#123;</span><br><span class="line">//获得目标方法的参数</span><br><span class="line">System.out.println(joinPoint.getArgs());</span><br><span class="line">//获得目标对象</span><br><span class="line">System.out.println(joinPoint.getTarget());</span><br><span class="line">//获得精确的切点表达式信息</span><br><span class="line">System.out.println(joinPoint.getStaticPart());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProceedingJoinPoint对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public Object around(ProceedingJoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">  System.out.println(joinPoint.getArgs());//获得目标方法的参数</span><br><span class="line">  System.out.println(joinPoint.getTarget());//获得目标对象</span><br><span class="line">  System.out.println(joinPoint.getStaticPart());//获得精确的切点表达式信息</span><br><span class="line">  Object result = joinPoint.proceed();//执行目标方法</span><br><span class="line">  return result;//返回目标方法返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Throwable对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void afterThrowing(JoinPoint joinPoint,Throwable th)&#123;</span><br><span class="line">  //获得异常信息</span><br><span class="line">  System.out.println(&quot;异常对象是：&quot;+th+&quot;异常信息是：&quot;+th.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut-ref=&quot;myPointcut&quot; throwing=&quot;th&quot;/&gt;</span><br></pre></td></tr></table></figure><h4 id="AOP的Advice方式"><a href="#AOP的Advice方式" class="headerlink" title="AOP的Advice方式"></a>AOP的Advice方式</h4><p>该方式需要通知类实现Advice的子功能接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public interface Advice &#123;&#125;</span><br></pre></td></tr></table></figure><p>Advice的子功能接口</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231111230428820.png" alt="image-20231111230428820"></p><p>通知类实现了前置通知和后置通知接口，通过实现不同的子接口，指明该类中的方法在哪里增强</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//实现子接口来实现通知</span><br><span class="line">public class Advices implements MethodBeforeAdvice, AfterReturningAdvice &#123;</span><br><span class="line">    public void before(Method method, Object[] objects, Object o) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;This is before Advice ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void afterReturning(Object o, Method method, Object[] objects, Object o1) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;This is afterReturn Advice ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切面使用advisor标签配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:config&gt;</span><br><span class="line">  &lt;!-- 将通知和切点进行结合 --&gt;</span><br><span class="line">  &lt;aop:advisor advice-ref=&quot;advices&quot; pointcut=&quot;execution(void</span><br><span class="line">com.itheima.aop.TargetImpl.show())&quot;/&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure><h5 id="aspect和advisor配置区别"><a href="#aspect和advisor配置区别" class="headerlink" title="aspect和advisor配置区别"></a>aspect和advisor配置区别</h5><ol><li><p>配置语法不同：</p><p>使用advisor配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:config&gt;</span><br><span class="line">  &lt;!-- advice-ref:通知Bean的id --&gt;</span><br><span class="line">  &lt;aop:advisor advice-ref=&quot;advices&quot; pointcut=&quot;execution(void com.itheima.aop.TargetImpl.show())&quot;/&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure><p>使用aspect配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:config&gt;</span><br><span class="line">  &lt;!-- ref:通知Bean的id --&gt;</span><br><span class="line">  &lt;aop:aspect ref=&quot;advices&quot;&gt;</span><br><span class="line">  &lt;aop:before method=&quot;before&quot; pointcut=&quot;execution(void</span><br><span class="line">com.itheima.aop.TargetImpl.show())&quot;/&gt;</span><br><span class="line">  &lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure></li><li><p>通知类的定义要求不同</p><p>advisor 需要的通知类需要实现Advice的子功能接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Advices implements MethodBeforeAdvice &#123;</span><br><span class="line">  public void before(Method method, Object[] objects, Object o) throws Throwable &#123;</span><br><span class="line">    System.out.println(&quot;This is before Advice ...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  public void afterReturning(Object o, Method method, Object[] objects, Object o1) throws Throwable &#123;</span><br><span class="line">    System.out.println(&quot;This is afterReturn Advice ...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>aspect 不需要通知类实现任何接口，在配置的时候指定哪些方法属于哪种通知类型即可，更加灵活方便：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Advices &#123;</span><br><span class="line">  public void before() &#123;</span><br><span class="line">    System.out.println(&quot;This is before Advice ...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  public void afterReturning() &#123;</span><br><span class="line">    System.out.println(&quot;This is afterReturn Advice ...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可配置的切面数量不同</p><p>一个advisor只能配置一个固定通知和一个切点表达式 </p><p>一个aspect可以配置多个通知和多个切点表达式任意组合，粒度更细。</p></li><li><p>使用场景不同</p><ul><li>如果通知类型多、允许随意搭配情况下可以使用aspect进行配置</li><li>如果通知类型单一、且通知类中通知方法一次性都会使用到的情况下可以使用advisor进行配置</li><li><strong>在通知类型已经固定，不用人为指定通知类型时，可以使用advisor进行配置，例如后面要学习的Spring事务控制的配置，等导入第三方配置</strong></li></ul></li></ol><blockquote><p>由于实际开发中，自定义aop功能的配置大多使用aspect的配置方式，所以我们后面主要讲解aspect的配置， advisor是为了后面Spring声明式事务控制做铺垫，此处大家了解即可。</p></blockquote><h3 id="xml方式AOP原理剖析"><a href="#xml方式AOP原理剖析" class="headerlink" title="xml方式AOP原理剖析"></a>xml方式AOP原理剖析</h3><p>通过xml方式配置AOP时，我们引入了AOP的命名空间，根据讲解的，要去找spring-aop包下的META-INF，在去 找spring.handlers文件，最终加载的是 AopNamespaceHandler，该Handler的init方法中注册了config标签对应的解析器</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231112115711785.png" alt="image-20231112115711785"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http\://www.springframework.org/schema/aop=org.springframework.aop.config.AopNamespaceHandler</span><br></pre></td></tr></table></figure><p>最终加载的是 AopNamespaceHandler，该Handler的init方法中注册了config标签对应的解析器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void init() &#123;</span><br><span class="line">   registerBeanDefinitionParser(&quot;config&quot;, new ConfigBeanDefinitionParser());</span><br><span class="line">   registerBeanDefinitionParser(&quot;aspectj-autoproxy&quot;, new AspectJAutoProxyBeanDefinitionParser());</span><br><span class="line">   registerBeanDefinitionDecorator(&quot;scoped-proxy&quot;, new copedProxyBeanDefinitionDecorator());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基于注解配置的AOP"><a href="#基于注解配置的AOP" class="headerlink" title="基于注解配置的AOP"></a>基于注解配置的AOP</h2><h3 id="注解方式AOP基本使用"><a href="#注解方式AOP基本使用" class="headerlink" title="注解方式AOP基本使用"></a>注解方式AOP基本使用</h3><p>xml配置AOP时，我们主要配置了三部分：</p><ol><li>目标类被Spring容器管理</li><li>通知类被Spring管理</li><li>通知与切点的织入（切面）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置目标--&gt;</span><br><span class="line">&lt;bean id=&quot;target&quot; class=&quot;com.itheima.aop.TargetImpl&quot;&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--配置通知--&gt;</span><br><span class="line">&lt;bean id=&quot;advices&quot; class=&quot;com.itheima.aop.Advices&quot;&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--配置aop--&gt;</span><br><span class="line">&lt;aop:config proxy-target-class=&quot;true&quot;&gt;</span><br><span class="line">  &lt;aop:aspect ref=&quot;advices&quot;&gt;</span><br><span class="line">    &lt;aop:around method=&quot;around&quot; pointcut=&quot;execution(* com.itheima.aop.*.*(..))&quot;/&gt;</span><br><span class="line">  &lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure><p>其中，<strong>目标类被Spring容器管理</strong>和<strong>通知类被Spring管理</strong>通过注解放入spring容器中就能完成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Component(&quot;target&quot;)</span><br><span class="line">public class TargetImpl implements Target&#123;</span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(&quot;show Target running...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@Component</span><br><span class="line">public class AnnoAdvice &#123;</span><br><span class="line">    public void around(ProceedingJoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;环绕前通知...&quot;);</span><br><span class="line">        joinPoint.proceed();</span><br><span class="line">        System.out.println(&quot;环绕后通知...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要修改的主要是第三部分，还是使用注解实现</p><ol start="0"><li>开启组件扫描</li><li>在类上加注解 </li><li>在方法上加注解</li><li>配置xml，告诉spring我们要使用注解，或者可以在核心配置类上加@EnableAspectJAutoProxy注解</li></ol><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231112122954205.png" alt="image-20231112122954205"></p><h3 id="注解方式AOP配置详解"><a href="#注解方式AOP配置详解" class="headerlink" title="注解方式AOP配置详解"></a>注解方式AOP配置详解</h3><h4 id="各种注解方式通知类型"><a href="#各种注解方式通知类型" class="headerlink" title="各种注解方式通知类型"></a>各种注解方式通知类型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//前置通知</span><br><span class="line">@Before(&quot;execution(* com.itheima.aop.*.*(..))&quot;)</span><br><span class="line">public void before(JoinPoint joinPoint)&#123;&#125;</span><br><span class="line"></span><br><span class="line">//后置通知</span><br><span class="line">@AfterReturning(&quot;execution(* com.itheima.aop.*.*(..))&quot;)</span><br><span class="line">public void AfterReturning(JoinPoint joinPoint)&#123;&#125;</span><br><span class="line"></span><br><span class="line">//环绕通知</span><br><span class="line">@Around(&quot;execution(* com.itheima.aop.*.*(..))&quot;)</span><br><span class="line">public void around(ProceedingJoinPoint joinPoint) throws Throwable &#123;&#125;</span><br><span class="line"></span><br><span class="line">//异常通知</span><br><span class="line">@AfterThrowing(&quot;execution(* com.itheima.aop.*.*(..))&quot;)</span><br><span class="line">public void AfterThrowing(JoinPoint joinPoint)&#123;&#125;</span><br><span class="line"></span><br><span class="line">//最终通知</span><br><span class="line">@After(&quot;execution(* com.itheima.aop.*.*(..))&quot;)</span><br><span class="line">public void After(JoinPoint joinPoint)&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="切点表达式的抽取"><a href="#切点表达式的抽取" class="headerlink" title="切点表达式的抽取"></a>切点表达式的抽取</h4><p>使用一个空方法，将切点表达式标注在空方法上，其他通知方法引用即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">public class AnnoAdvice &#123;</span><br><span class="line">    //切点表达式抽取</span><br><span class="line">    @Pointcut(&quot;execution(* com.itheima.aop.*.*(..))&quot;)</span><br><span class="line">    public void pointcut()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    //前置通知</span><br><span class="line">    @Before(&quot;pointcut()&quot;)</span><br><span class="line">    public void before(JoinPoint joinPoint)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    //后置通知</span><br><span class="line">    @AfterReturning(&quot;AnnoAdvice.pointcut()&quot;)</span><br><span class="line">    public void AfterReturning(JoinPoint joinPoint)&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注解方式AOP原理剖析"><a href="#注解方式AOP原理剖析" class="headerlink" title="注解方式AOP原理剖析"></a>注解方式AOP原理剖析</h3><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="Spring事务编程概述"><a href="#Spring事务编程概述" class="headerlink" title="Spring事务编程概述"></a>Spring事务编程概述</h2><p>事务是开发中必不可少的东西，使用JDBC开发时，我们使用connnection对事务进行控制，使用MyBatis时，我们 使用SqlSession对事务进行控制，缺点显而易见，当我们切换数据库访问技术时，事务控制的方式总会变化， Spring 就将这些技术基础上，提供了统一的控制事务的接口。</p><p>Spring的事务分为：</p><ol><li>编程式事务控制<ul><li>Spring提供了事务控制的类和方法，使用编码的方式对业务代码进行事务控制，事务控制代码和业务 操作代码耦合到了一起，开发中不使用</li></ul></li><li>声明式事务 控制<ul><li>Spring将事务控制的代码封装，对外提供了Xml和注解配置方式，通过配置的方式完成事务的控制， 可以达到事务控制与业务操作代码解耦合，开发中推荐使用</li></ul></li></ol><h3 id="事务编程"><a href="#事务编程" class="headerlink" title="事务编程"></a>事务编程</h3><p>相关的类主要有如下三个</p><ul><li>平台事务管理器PlatformTransactionManager<ul><li>是一个接口标准，实现类都具备事务提交、回滚和获得事务对象的功能，不同持 久层框架可能会有不同实现方案</li></ul></li><li>事务定义 TransactionDefinition <ul><li>封装事务的隔离级别、传播行为、过期时间等属性信息</li></ul></li><li>事务状态 TransactionStatus <ul><li>存储当前事务的状态信息，如果事务是否提交、是否回滚、是否有回滚点等</li></ul></li></ul><blockquote><p>虽然编程式事务控制不学习，但是编程式事务控制对应的这些类我们需要了解一下，因为我们在通过配置的方 式进行声明式事务控制时也会看到这些类的影子</p></blockquote><h2 id="搭建测试环境"><a href="#搭建测试环境" class="headerlink" title="搭建测试环境"></a>搭建测试环境</h2><p>搭建一个转账的环境，dao层一个转出钱的方法，一个转入钱的方法，service层一个转账业务方法，内部分别调 用dao层转出钱和转入钱的方法，准备工作如下：</p><ol><li>数据库准备一个账户表tb_account</li><li>dao层准备一个AccountMapper，包括incrMoney和decrMoney两个方法</li><li>service层准备一个transferMoney方法，分别调用incrMoney和decrMoney方法</li><li>在applicationContext文件中进行Bean的管理配置</li><li>测试正常转账与异常转账。</li></ol><h2 id="基于xml声明式事务控制"><a href="#基于xml声明式事务控制" class="headerlink" title="基于xml声明式事务控制"></a>基于xml声明式事务控制</h2><p>结合上面我们学习的AOP的技术，很容易就可以想到，可以使用AOP对Service的方法进行事务的增强</p><ul><li>目标类：AccountServiceImpl</li><li>切点：service业务类中的所有业务方法</li><li>通知类：Spring提供的，通知方法已经定义好，只需要配置即可</li></ul><p>目标类是我们自己定义的；通知类是Spring提供的事务增强，且内部的通知方法是固定的</p><ul><li>目标类：自定义的AccountServiceImpl，内部的方法是切点</li><li>通知类：Spring提供的，通知方法已经定义好，只需要配置即可</li></ul><p>步骤：</p><ol><li>通知类是Spring提供的，需要导入Spring事务的相关的坐标</li><li>配置目标类AccountServiceImpl</li><li>使用advisor标签配置切面。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring高级-IoC部分</title>
      <link href="/2023/11/06/Spring%E9%AB%98%E7%BA%A7IoC/"/>
      <url>/2023/11/06/Spring%E9%AB%98%E7%BA%A7IoC/</url>
      
        <content type="html"><![CDATA[<h1 id="IoC、DI和AOP思想提出"><a href="#IoC、DI和AOP思想提出" class="headerlink" title="IoC、DI和AOP思想提出"></a>IoC、DI和AOP思想提出</h1><p>传统开发2个问题</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109170011596.png" alt="image-20231109170011596"></p><div class="tabs" id="1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#1-1">IoC</button></li><li class="tab"><button type="button" data-href="#1-2">DI</button></li><li class="tab"><button type="button" data-href="#1-3">AOP</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><p>IoC思想： Inversion of Control，翻译为“控制反转”或“反转控制”，强调的是原来在程序中创建Bean的权利反转给第三方。</p><p>根据IoC思想的指导， 寻求一个第三方去创建UserServiceImpl对象和UserDaoImpl对象。这样程序与具体对象就失去的直接联系。</p><p>谁去充当第三方角色呢？ </p><ul><li>工厂设计模式，BeanFactory来充当第三方的角色，来产生Bean实例</li></ul><p>BeanFactory怎么知道产生哪些Bean实例呢？</p><ul><li>可以使用配置文件配置Bean的基本信息，BeanFactory根据配置文件来生产Bean实例</li></ul><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109165542356.png" alt="image-20231109165542356"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-2"><p>DI 依赖注入思想的提出</p><p>将 UserDao的创建权也反转给BeanFactory，与此同时UserService内部还需要用到UserDao实例对象，那应该怎 样操作呢？ </p><ol><li>在程序中，通过BeanFactory获得UserService</li><li>在程序中，通过BeanFactory获得UserDao</li><li>在程序中，将UserDao设置给UserService</li></ol><p>将UserDao在BeanFactory内部设置 给UserService的过程叫做“注入” ，而UserService需要依赖UserDao 的注入才能正常工作，这个过程叫做 “依赖注入”</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-3"><p>AOP思想：Aspect Oriented Programming，面向切面编程，是对面向对象编程OOP的升华。</p><p>OOP是纵向对一个 事物的抽象，一个对象包括静态的属性信息，包括动态的方法信息等。</p><p>AOP是横向的对不同事物的抽象，属 性与属性、方法与方法、对象与对象都可以组成一个切面，而用这种思维去设计编程的方式叫做面向切面编程</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>三种思想总结</p><ol><li>IoC控制反转，是将程序创建Bean的权利反转给第三方</li><li>DI依赖注入，某个完整Bean需要依赖于其他Bean（或属性）的注入</li><li>AOP面向切面编程，用横向抽取方法（属性、对象等）思想，组装成一个功能性切面</li></ol><p>面试题：IoC 和 DI 的关系？</p><ol><li>回答IoC和DI的是什么：<ul><li>IoC： Inversion of Control，控制反转，将Bean的创建权由原来程序反转给第三方 </li><li>DI：Dependency Injection，依赖注入，某个Bean的完整创建依赖于其他Bean（或普通参数）的注入</li></ul></li><li>回答IoC和DI的关系：<ul><li>第一种观点：IoC强调的是Bean创建权的反转，而DI强调的是Bean的依赖关系，认为不是一回事 </li><li>第二种观点：IoC强调的是Bean创建权的反转，而DI强调的是通过注入的方式反转Bean的创建权，认为DI是IoC的其中一种实现方式</li></ul></li></ol><h1 id="Spring框架的诞生"><a href="#Spring框架的诞生" class="headerlink" title="Spring框架的诞生"></a>Spring框架的诞生</h1><h2 id="Spring-Framework技术栈"><a href="#Spring-Framework技术栈" class="headerlink" title="Spring Framework技术栈"></a>Spring Framework技术栈</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231116092050110.png" alt="image-20231116092050110"></p><ul><li>Data Access: 数据访问</li><li>Data Integration: 数据集成</li><li>Web: Web开发</li><li>AOP: 面向切面编程</li><li>Aspects: AOP思想实现</li><li>Core Container:核心容器</li><li>Test: 单元测试与集成测试</li></ul><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231116092105753.png" alt="image-20231116092105753"></p><h2 id="Spring-的容器"><a href="#Spring-的容器" class="headerlink" title="Spring 的容器"></a>Spring 的容器</h2><p>主要有2个BeanFactory与ApplicationContext</p><ul><li>BeanFactory是Spring的早期接口，称为Spring的Bean工厂，ApplicationContext是后期更高级接口，称之为 Spring 容器；</li><li>ApplicationContext在BeanFactory基础上对功能进行了扩展，例如：监听功能、国际化功能等。BeanFactory的 API更偏向底层，ApplicationContext的API大多数是对这些底层API的封装；</li><li>Bean创建的主要逻辑和功能都被封装在BeanFactory中，ApplicationContext不仅继承了BeanFactory，而且 ApplicationContext内部还维护着BeanFactory的引用，所以，ApplicationContext与BeanFactory既有继承关系，又有融合关系</li><li>Bean的初始化时机不同，原始BeanFactory是在首次调用getBean时才进行Bean的创建，而ApplicationContext则是配置文件加载，容器一创建就将Bean都实例化并初始化好</li><li>ApplicationContext除了继承了BeanFactory外，还继承了ApplicationEventPublisher（事件发布器）、 ResouresPatternResolver（资源解析器）、MessageSource（消息资源）等。</li><li>但是ApplicationContext的核心功能还是BeanFactory。</li></ul><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109203334542.png" alt="image-20231109203334542"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109203343674.png" alt="image-20231109203343674"></p><h3 id="BeanFactory的继承体系"><a href="#BeanFactory的继承体系" class="headerlink" title="BeanFactory的继承体系"></a>BeanFactory的继承体系</h3><p>BeanFactory是核心接口，项目运行过程中肯定有具体实现参与，这个具体实现就是DefaultListableBeanFactory ，而ApplicationContext内部维护的Beanfactory的实现类也是它</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109203910999.png" alt="image-20231109203910999"></p><h3 id="ApplicationContext的继承体系"><a href="#ApplicationContext的继承体系" class="headerlink" title="ApplicationContext的继承体系"></a>ApplicationContext的继承体系</h3><p>只在Spring基础环境下，即只导入spring-context坐标时，此时ApplicationContext的继承体系</p><p>下图三个是常用的实现类，从上到下为：</p><ol><li>使用注解进行加载的实现类，<strong>注解的</strong></li><li>根据文件在电脑中的绝对位置进行加载的实现类，<strong>XML的</strong></li><li>根据文件在项目中的相对位置进行加载的实现类，<strong>XML的</strong></li></ol><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109203931158.png" alt="image-20231109203931158"></p><p>如果Spring基础环境中加入了其他组件解决方案，如web层解决方案，即导入spring-web坐标，此时 ApplicationContext的继承体系</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109204046565.png" alt="image-20231109204046565"></p><p>常用的几个ApplicationContext作用如下：</p><table><thead><tr><th>实现类</th><th>功能描述</th></tr></thead><tbody><tr><td>ClassPathXmlApplicationContext</td><td>加载类路径下的xml配置的ApplicationContext</td></tr><tr><td>FileSystemXmlApplicationContext</td><td>加载磁盘路径下的xml配置的ApplicationContext</td></tr><tr><td>AnnotationConfigApplicationContext</td><td>加载注解配置类的ApplicationContext</td></tr><tr><td>XmlWebApplicationContext</td><td>web环境下，加载类路径下的xml配置的ApplicationContext</td></tr><tr><td>AnnotationConfigWebApplicationContext</td><td>web环境下，加载磁盘路径下的xml配置的ApplicationContext</td></tr></tbody></table><h2 id="BeanFactory-快速入门"><a href="#BeanFactory-快速入门" class="headerlink" title="BeanFactory 快速入门"></a>BeanFactory 快速入门</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109165542356.png" alt="image-20231109165542356"></p><div class="tabs" id="2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2-1">IoC</button></li><li class="tab"><button type="button" data-href="#2-2">DI</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2-1"><ol><li><p>导入Spring的jar包或Maven坐标</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--Spring核心--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.3.7&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>定义UserService接口及其UserServiceImpl实现类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public interface UserService &#123;&#125;</span><br><span class="line">public class UserServiceImpl implements UserService &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建beans.xml配置文件，将UserServiceImpl的信息配置到该xml中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.impl.UserServiceImpl&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>id：bean的名字</p><p>class：bean的全路径，通过反射创建的bean对象</p></li><li><p>编写测试代码，创建BeanFactory，加载配置文件，获取UserService实例对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//创建BeanFactory</span><br><span class="line">DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();</span><br><span class="line"></span><br><span class="line">//创建读取器</span><br><span class="line">XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">//加载配置文件</span><br><span class="line">reader.loadBeanDefinitions(&quot;beans.xml&quot;);</span><br><span class="line"></span><br><span class="line">//获取Bean实例对象</span><br><span class="line">UserDao userService = (UserService) beanFactory.getBean(&quot;userService&quot;);</span><br></pre></td></tr></table></figure></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2-2"><ol><li><p>定义UserDao接口及其UserDaoImpl实现类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public interface UserDao &#123;&#125;</span><br><span class="line">public class UserDaoImpl implements UserDao &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改UserServiceImpl代码，添加一个setUserDao(UserDao userDao)用于接收注入的对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line">  public void setUserDao(UserDao userDao) &#123;</span><br><span class="line">    System.out.println(userDao);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义UserDao接口及其UserDaoImpl实现类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.impl.UserServiceImpl&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><blockquote><p>请回忆2个userDao的区别</p></blockquote></li><li><p>编写测试代码，创建BeanFactory，加载配置文件，获取UserService实例对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//创建BeanFactory</span><br><span class="line">DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();</span><br><span class="line"></span><br><span class="line">//创建读取器</span><br><span class="line">XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">//加载配置文件</span><br><span class="line">reader.loadBeanDefinitions(&quot;beans.xml&quot;);</span><br><span class="line"></span><br><span class="line">//获取Bean实例对象</span><br><span class="line">UserDao userService = (UserService) beanFactory.getBean(&quot;userService&quot;);</span><br></pre></td></tr></table></figure></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="ApplicationContext快速入门"><a href="#ApplicationContext快速入门" class="headerlink" title="ApplicationContext快速入门"></a>ApplicationContext快速入门</h2><p>ApplicationContext 称为Spring容器，内部封装了BeanFactory（本质还是用的BeanFactory），比BeanFactory功能更丰富更强大，使用 ApplicationContext 进行开发时，xml配置文件的名称习惯写成applicationContext.xml，但这个名字不是必须的。</p><p>其余配置过程和BeanFactory的一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//创建ApplicationContext,加载配置文件，实例化容器</span><br><span class="line">ApplicationContext applicationContext =</span><br><span class="line">new ClassPathxmlApplicationContext(“applicationContext.xml&quot;);</span><br><span class="line"></span><br><span class="line">//根据beanName获得容器中的Bean实例</span><br><span class="line">UserService userService = (UserService) applicationContext.getBean(&quot;userService&quot;);</span><br><span class="line">System.out.println(userService);</span><br></pre></td></tr></table></figure><h1 id="基于xml的Spring应用"><a href="#基于xml的Spring应用" class="headerlink" title="基于xml的Spring应用"></a>基于xml的Spring应用</h1><h2 id="Bean配置"><a href="#Bean配置" class="headerlink" title="Bean配置"></a>Bean配置</h2><p>Spring开发中主要是对Bean的配置，Bean的常用配置一览如下：</p><table><thead><tr><th>Xml配置方式</th><th>功能描述</th></tr></thead><tbody><tr><td>&lt; bean id&#x3D;”” class&#x3D;””&gt;</td><td>Bean的id和全限定类名配置</td></tr><tr><td>&lt; bean name&#x3D;””&gt;</td><td>通过name设置Bean的别名，通过别名也能直接获取到Bean实例</td></tr><tr><td>&lt; bean scope&#x3D;””&gt;</td><td>Bean的作用范围，BeanFactory作为容器时取值singleton和prototype</td></tr><tr><td>&lt; bean lazy-init&#x3D;””&gt;</td><td>Bean的实例化时机，是否延迟加载。BeanFactory作为容器时无效</td></tr><tr><td>&lt; bean init-method&#x3D;””&gt;</td><td>Bean实例化后自动执行的初始化方法，method指定方法名</td></tr><tr><td>&lt; bean destroy-method&#x3D;””&gt;</td><td>Bean实例销毁前的方法，method指定方法名</td></tr><tr><td>&lt; bean autowire&#x3D;”byType”&gt;</td><td>设置自动注入模式，常用的有按照类型byType，按照名字byName</td></tr><tr><td>&lt; bean factory-bean&#x3D;”” factory-method&#x3D;””&#x2F;&gt;</td><td>指定哪个工厂Bean的哪个方法完成Bean的创建</td></tr></tbody></table><ul><li><p>Bean的基础配置：id 和 class</p><p>id：bean的名字，但进后面的容器后 id 会转变为 name</p><p>class：bean的全路径，通过反射创建的bean对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;/&gt;</span><br><span class="line">applicationContext.getBean(&quot;userDao&quot;);</span><br></pre></td></tr></table></figure><p>此时存储到<strong>singleObjects单例池</strong>中的Bean的beanName是userDao，值是UserDaoImpl对象，可以根据beanName获取Bean实例，如果不配置id，则Spring会把当前Bean实例的全限定名作为beanName</p><p>debug中可以看见，key对应id，value对应值</p></li><li><p>Bean的别名配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;userDao&quot; name=&quot;aaa,bbb&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;/&gt;</span><br></pre></td></tr></table></figure><p>可以为当前Bean指定多个别名，根据别名也可以获得Bean对象，此时多个名称都可以获得UserDaoImpl实例对象，使用时优先id</p></li><li><p>Bean的范围配置：单例和非单例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//singleton</span><br><span class="line">&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot; scope=&quot;singleton&quot;/&gt;</span><br><span class="line">Object userDao = applicationContext.getBean(&quot;userDao&quot;);</span><br><span class="line">Object userDao2 = applicationContext.getBean(&quot;userDao&quot;);</span><br><span class="line">System.out.println(userDao); //com.itheima.dao.impl.UserDaoImpl@631330c</span><br><span class="line">System.out.println(userDao2); //com.itheima.dao.impl.UserDaoImpl@631330c</span><br><span class="line"></span><br><span class="line">//prototype</span><br><span class="line">&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot; scope=&quot;prototype&quot;/&gt;</span><br><span class="line">Object userDao = applicationContext.getBean(&quot;userDao&quot;);</span><br><span class="line">Object userDao2 = applicationContext.getBean(&quot;userDao&quot;);</span><br><span class="line">System.out.println(userDao); //com.itheima.dao.impl.UserDaoImpl@4d50efb8</span><br><span class="line">System.out.println(userDao2); //com.itheima.dao.impl.UserDaoImpl@7e2d773b</span><br></pre></td></tr></table></figure><p>singleton：默认值，Spring容器创建的时候，就会进行Bean的实例化，并存储到容器内部的单例池中 ，每次getBean时都是从单例池中获取相同的Bean实例；</p><p>prototype：Spring容器初始化时不会创建Bean实例，当调用getBean时才会实例化Bean，每次 getBean都会创建一个新的Bean实例，即用即创，用后回收</p></li><li><p>Bean的延迟加载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot; lazy-init=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure><p>当lazy-init设置为true时为延迟加载，也就是当Spring容器创建的时候，不会立即创建Bean实例，等待用到时在创建Bean实例并存储到单例池中去，后续在使用该Bean直接从单例池获取即可，本质上该Bean还是单例的</p></li><li><p>Bean的初始化和销毁方法配置</p><p>Bean在<strong>被实例化后</strong>，可以执行指定的初始化方法完成一些初始化的操作，Bean在销毁之前也可以执行指定的销毁方法完成一些操作，初始化方法名称和销毁方法名称通过 init-method 和 destroy-method 指明</p><p>后面的学习中会遇到其他的功能增强，不同增强发生的时机不同。初始化和销毁方法是比较靠后的增强</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot; init-method=&quot;init&quot;</span><br><span class="line">destroy-method=&quot;destroy&quot;/&gt;</span><br><span class="line"></span><br><span class="line">public class UserDaoImpl implements UserDao &#123;</span><br><span class="line">  public UserDaoImpl() &#123; System.out.println(&quot;UserDaoImpl创建了...&quot;); &#125;</span><br><span class="line">  public void init()&#123; System.out.println(&quot;初始化方法...&quot;); &#125;</span><br><span class="line">  public void destroy()&#123; System.out.println(&quot;销毁方法...&quot;); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是销毁方法不一定有机会使用，就像关电视一样，直接断电源是来不及调用方法的。</p></li><li><p>实现 InitializingBean 接口，完成一些Bean的初始化操作</p><p>InitializingBean是个规范，定义好了一堆抽象方法和他们的使用时机，我们使用的时候完成相应方法的功能即可，没有多余配置，执行时机早于init-method，在属性设置之后执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class UserDaoImpl implements UserDao, InitializingBean &#123;</span><br><span class="line">  public UserDaoImpl() &#123;System.out.println(&quot;UserDaoImpl创建了...&quot;);&#125;</span><br><span class="line">  public void init()&#123;System.out.println(&quot;初始化方法...&quot;);&#125;</span><br><span class="line">  public void destroy()&#123;System.out.println(&quot;销毁方法...&quot;);&#125;</span><br><span class="line">  </span><br><span class="line">  //执行时机早于init-method配置的方法</span><br><span class="line">  public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">    System.out.println(&quot;InitializingBean...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>import导入配置文件</p><p>用于导入其他配置文件，项目变大后，就会导致一个配置文件内容过多，可以将一个配置文件根 据业务某块进行拆分，拆分后，最终通过&lt; import&gt;标签导入到一个主配置文件中，项目加载主配置文件就连同 &lt; import&gt;导入的文件一并加载了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--导入用户模块配置文件--&gt;</span><br><span class="line">&lt;import resource=&quot;classpath:UserModuleApplicationContext.xml&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--导入商品模块配置文件--&gt;</span><br><span class="line">&lt;import resource=&quot;classpath:ProductModuleApplicationContext.xml&quot;/&gt;</span><br></pre></td></tr></table></figure></li><li><p>alias 标签是为某个Bean添加别名:</p><p>在beanFactory中维护着一个名为aliasMap的Map集合，存储别名和beanName 之间的映射关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置UserService--&gt;</span><br><span class="line">&lt;bean id=&quot;userService&quot; name=&quot;bbb&quot; class=&quot;com.itheima.service.impl.UserServiceImpl&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--指定别名--&gt;</span><br><span class="line">&lt;alias name=&quot;userService&quot; alias=&quot;xxx&quot;/&gt;</span><br><span class="line">&lt;alias name=&quot;userService&quot; alias=&quot;yyy&quot;/&gt;</span><br></pre></td></tr></table></figure></li><li><p>其他配置标签</p><p>Spring 的 xml 标签大体上分为两类，一种是默认标签，一种是自定义标签 </p><p>默认标签：就是不用额外导入其他命名空间约束的标签</p><p>Spring的默认标签用到的是Spring的默认命名空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>上述代码解读：</p><ol><li><p>xml第一行必须定义为文档声明</p><p>   version：版本号  </p><p>   encoding：编码方式，告知解析引擎当前文档使用的字符集</p></li><li><p>xml文档中有且仅有一个根标签</p><p>   根标签&lt; beans&gt;&lt; &#x2F;beans&gt;</p><p>   xsd文件的前面部分就是它的命名空间</p><p>   如spring-beans.xsd的命名空间就是：<code>http://www.springframework.org/schema/beans/spring-beans</code></p></li><li><p>属性值必须使用引号(单双都可)引起来</p></li><li><p>标签必须正确关闭</p></li><li><p>xml标签名称区分大小写</p></li></ol><p>该命名空间约束下的默认标签如下：</p><table><thead><tr><th>标签</th><th>作用</th></tr></thead><tbody><tr><td>&lt; beans&gt;</td><td>一般作为 xml 配置根标签，其他标签都是该标签的子标签<br>嵌套在根标签内，使用profile属性切换开发环境</td></tr><tr><td>&lt; bean&gt;</td><td>Bean的配置标签，上面已经详解了，此处不再阐述</td></tr><tr><td>&lt; import&gt;</td><td>外部资源导入标签</td></tr><tr><td>&lt; alias&gt;</td><td>指定Bean的别名标签，使用较少</td></tr></tbody></table><p>beans切换开发环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置测试环境下，需要加载的Bean实例 --&gt;</span><br><span class="line">&lt;beans profile=&quot;test&quot;&gt;&lt;/beans&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置开发环境下，需要加载的Bean实例 --&gt;</span><br><span class="line">&lt;beans profile=&quot;dev&quot;&gt;&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>可以使用以下两种方式指定被激活的环境：</p><ol><li>使用命令行动态参数，虚拟机参数位置加载 -Dspring.profiles.active&#x3D;test</li><li>使用代码的方式设置环境变量 System.setProperty(“spring.profiles.active”,”test”)</li></ol></li></ul><h2 id="自定义标签"><a href="#自定义标签" class="headerlink" title="自定义标签"></a>自定义标签</h2><p>schema引入</p><p>自定义标签：就是需要额外引入其他命名空间约束，并通过前缀引用的标签</p><p>在配置外部的命名空间时 需要提前在pom中导入对应的依赖</p><p>自定义标签的 xmlns和xsi:schemaLocation是成对配置的</p><ul><li><code>xmlns:别名</code>：用来声明引入某个jar包一类的，然后就能用&lt;别名 : 标签名&gt;使用对应的标签</li><li><code>xsi:schemaLocation</code>：后跟着的看着像一个网页地址，但实际上定位是我们引入的jar包地址</li></ul><p>需要的自定义标签可以去对应的官网找</p><h2 id="DI注入标签"><a href="#DI注入标签" class="headerlink" title="DI注入标签"></a>DI注入标签</h2><div class="tabs" id="di注入标签"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#di注入标签-1">constructor-arg</button></li><li class="tab"><button type="button" data-href="#di注入标签-2">property</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="di注入标签-1"><p>指定创建类对象时使用哪个构造函数，每一对或者每一个constructor-arg子标签配置一个参数列表中的参数值；如果不配置子标签，则默认使用无参构造方法实例化对象</p><p>属性：</p><ul><li>name属性：通过参数名找到参数列表中对应参数</li><li>index属性：通过参数在参数列表中的索引找到参数列表中对应参数，index从0开始：</li><li>type属性：通过参数数据类型找到参数列表中对应参数</li><li>value属性：设置参数列表参数对应的值，用于设定基本数据类型和String类型的数据</li><li>ref属性：如果参数值为非基本数据类型，则可通过ref为参数注入值，其值为另一个bean标签id或name属性的属性值</li></ul><p>子标签：</p><ul><li>ref子标签：对应ref属性，该标签name属性的属性值为另一个bean标签id或name属性的属性值；</li><li>value子标签：对应value属性,用于设置基本数据类型或String类型的参数值；</li><li>list子标签：为数组或List类型的参数赋值</li><li>set子标签：为Set集合类型参数赋值</li><li>map子标签：为Map集合类型参数赋值</li><li>props子标签：为Properties类型的参数赋值</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="di注入标签-2"><p>Bean定义可以具有零个或多个属性。属性元素对应于bean类公开的 JavaBean setter方法。 Spring支持原语，对相同或相关工厂中的其他bean的引用，列表，映射和属性</p><p>属性：</p><ul><li>name属性：通过参数名找到参数列表中对应参数</li><li>value子标签：对应value属性,用于设置基本数据类型或String类型的参数值</li><li>ref属性：如果参数值为非基本数据类型，则可通过ref为参数注入值，其值为另一个bean标签id或name属性的属性值</li></ul><p>子标签：</p><ul><li>ref子标签：对应ref属性，该标签name属性的属性值为另一个bean标签id或name属性的属性值；</li><li>value子标签：对应value属性,用于设置基本数据类型或String类型的参数值；</li><li>list子标签：为数组或List类型的参数赋值</li><li>set子标签：为Set集合类型参数赋值</li><li>map子标签：为Map集合类型参数赋值</li><li>props子标签：为Properties类型的参数赋值</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>constructor-arg和property的区别：</p><ul><li>constructor-arg：通过构造函数注入</li><li>property：通过setter对应的方法注入</li></ul><h3 id="Bean的依赖注入配置"><a href="#Bean的依赖注入配置" class="headerlink" title="Bean的依赖注入配置"></a>Bean的依赖注入配置</h3><div class="tabs" id="3"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#3-1">set方法注入</button></li><li class="tab"><button type="button" data-href="#3-2">构造方法进行注入</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="3-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean&gt;</span><br><span class="line">    &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;userDao&quot; value=&quot;haohao&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;name&quot; ref=&quot;userDao&quot;/&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;name&quot; value=&quot;haohao&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>ref 是 reference 的缩写，用于引用其他Bean的id。</p><p>value 用于注入普通 属性值。</p><p>依赖注入的数据类型有如下三种：</p><ol><li>普通数据类型，例如：String、int、boolean等，通过value属性指定</li><li>引用数据类型，例如：UserDaoImpl、DataSource等，通过ref属性指定</li><li>集合数据类型，例如：List、Map、Properties等，有单独的格式</li></ol><h3 id="自动装配方式"><a href="#自动装配方式" class="headerlink" title="自动装配方式"></a>自动装配方式</h3><p>如果被注入的属性类型是Bean引用的话，那么可以在 标签中使用 autowire 属性去配置自动注入方式，属 性值有两个：</p><ol><li>byName：通过属性名自动装配，即去匹配 setXxx 与 id&#x3D;”xxx”（name&#x3D;”xxx”）是否一致</li><li>byType：通过Bean的类型从容器中匹配，匹配出多个相同Bean类型时，报错</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.impl.UserServiceImpl&quot;</span><br><span class="line">autowire=&quot;byName&quot;&gt;</span><br><span class="line">&lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.impl.UserServiceImpl&quot;</span><br><span class="line">autowire=&quot;byType&quot;&gt;</span><br></pre></td></tr></table></figure><h2 id="getBean方法"><a href="#getBean方法" class="headerlink" title="getBean方法"></a>getBean方法</h2><table><thead><tr><th>方法定义</th><th>返回值和参数</th></tr></thead><tbody><tr><td>Object getBean (String beanName)</td><td>根据beanName从容器中获取Bean实例，要求容器中Bean唯一，返回值为Object，需要强转</td></tr><tr><td>T getBean (Class type)</td><td>根据Class类型从容器中获取Bean实例，要求容器中Bean类型唯一，返回值为Class类型实例， 无需强转</td></tr><tr><td>T getBean (String beanName，Class type)</td><td>根据beanName从容器中获得Bean实例，返回值为Class类型实例，无需强转</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//根据beanName获取容器中的Bean实例，需要手动强转</span><br><span class="line">UserService userService = (UserService) applicationContext.getBean(&quot;userService&quot;);</span><br><span class="line"></span><br><span class="line">//根据Bean类型去容器中匹配对应的Bean实例，如存在多个匹配Bean则报错</span><br><span class="line">UserService userService2 = applicationContext.getBean(UserService.class);</span><br><span class="line"></span><br><span class="line">//根据beanName获取容器中的Bean实例，指定Bean的Type类型</span><br><span class="line">UserService userService3 = applicationContext.getBean(&quot;userService&quot;,</span><br><span class="line">UserService.class);</span><br></pre></td></tr></table></figure><h2 id="Bean的实例化配置"><a href="#Bean的实例化配置" class="headerlink" title="Bean的实例化配置"></a>Bean的实例化配置</h2><p>Spring的实例化方式主要如下两种：</p><ul><li><p>构造方式实例化：底层通过构造方法对Bean进行实例化</p><p>构造方式实例化Bean又分为<strong>无参构造方法实例化</strong>和<strong>有参构造方法实例化</strong>，Spring中配置的几乎都是无参构造该方式</p><p>有参构造在实例化Bean时，需要参数的注入，通过标签，嵌入在标签内部提供构造参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt;</span><br><span class="line">  &lt;constructor-arg name=&quot;name&quot; value=&quot;haohao&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>工厂方式实例化：底层通过调用自定义的工厂方法对Bean进行实例化，具体有3个不同方式</p></li></ul><div class="tabs" id="5"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#5-1">静态工厂方法实例化Bean</button></li><li class="tab"><button type="button" data-href="#5-2">实例工厂方法实例化Bean</button></li><li class="tab"><button type="button" data-href="#5-3">实现FactoryBean规范延迟实例化Bean</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="5-1"><p>静态工厂方法实例化Bean</p><p>是定义一个工厂类，提供一个<strong>静态方法</strong>用于生产Bean实例，在将该工厂类及其 静态方法配置给Spring即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//工厂类</span><br><span class="line">public class UserDaoFactoryBean &#123;</span><br><span class="line">//非静态工厂方法</span><br><span class="line">  public static UserDao getUserDao(String name)&#123;</span><br><span class="line">    //可以在此编写一些其他逻辑代码</span><br><span class="line">    return new UserDaoImpl();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.factory.UserDaoFactoryBean&quot; factorymethod=&quot;getUserDao&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;name&quot; value=&quot;haohao&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>&lt; constructor-arg&gt;标签不仅仅是为构造方法传递参数，只要是为了实例化对象而传递的参数都可以通过&lt; constructor-arg&gt;标签完成</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5-2"><p>实例工厂方法实例化Bean</p><p>实例工厂方法，也就是非静态工厂方法产生Bean实例，与静态工厂方式比较，该方式需要<strong>先有工厂对象</strong>，在用工厂对象去调用<strong>成员方法</strong>，所以在进行配置时，要先配置工厂Bean，在配置目标Bean</p><p>这种方式常用来处理第三方bean</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//工厂类</span><br><span class="line">public class UserDaoFactoryBean2 &#123;</span><br><span class="line">  //非静态工厂方法</span><br><span class="line">  public UserDao getUserDao(String name)&#123;</span><br><span class="line">    //可以在此编写一些其他逻辑代码</span><br><span class="line">    return new UserDaoImpl();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置实例工厂Bean --&gt;</span><br><span class="line">&lt;bean id=&quot;userDaoFactoryBean2&quot; class=&quot;com.itheima.factory.UserDaoFactoryBean2&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置实例工厂Bean的哪个方法作为工厂方法 --&gt;</span><br><span class="line">&lt;bean id=&quot;userDao&quot; factory-bean=&quot;userDaoFactoryBean2&quot; factory-method=&quot;getUserDao&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;name&quot; value=&quot;haohao&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5-3"><p>底层用的多，开发中用的少</p><p>上面不管是静态工厂方式还是非静态工厂方式，都是自定义的工厂方法，Spring提供了FactoryBean的接口规范， FactoryBean接口定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface FactoryBean&lt;T&gt; &#123;</span><br><span class="line">  String OBJECT_TYPE_ATTRIBUTE = “factoryBeanObjectType”;</span><br><span class="line">  T getObject() throws Exception; //获得实例对象方法</span><br><span class="line">  Class&lt;?&gt; getObjectType(); //获得实例对象类型方法</span><br><span class="line">  default boolean isSingleton() &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义工厂实现FactoryBean</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class UserDaoFactoryBean3 implements FactoryBean&lt;UserDao&gt; &#123;</span><br><span class="line">  public UserDao getObject() throws Exception &#123;</span><br><span class="line">    return new UserDaoImpl();</span><br><span class="line">  &#125;</span><br><span class="line">  public Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">    return UserDao.class;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置FactoryBean交由Spring管理即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.factory.UserDaoFactoryBean3&quot;/&gt;</span><br></pre></td></tr></table></figure><p>通过Spring容器根据beanName可以正常获得UserDaoImpl</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext applicationContext = new ClassPathxmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">Object userDao = applicationContext.getBean(&quot;userDao&quot;);</span><br><span class="line">System.out.println(userDao);</span><br></pre></td></tr></table></figure><p>延迟解读：</p><p><code>ApplicationContext applicationContext = new ClassPathxmlApplicationContext(&quot;applicationContext.xml&quot;);</code><br><code>Object userDao = applicationContext.getBean(&quot;userDao&quot;);</code></p><ol><li>加载配置文件创建spring容器的时候，getBean方法没有执行，上述代码第一行</li><li>执行到getBean方法时，才运用这个方法，然后把对象存入factoryBeanObjectCache中。也就是说，真正要用的时候才创建bean</li></ol><p>好处：缓存需求，真正要用的时候才创建</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231116105646310.png" alt="image-20231116105646310"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="配置非自定义Bean"><a href="#配置非自定义Bean" class="headerlink" title="配置非自定义Bean"></a>配置非自定义Bean</h2><p>实际开发中有些 功能类并不是我们自己定义的，而是使用的第三方jar包中的，那么，这些Bean要想让Spring进行管理，也需要对 其进行配置</p><p>配置非自定义的Bean需要考虑如下两个问题：</p><ol><li>被配置的Bean的实例化方式是什么？无参构造、有参构造、静态工厂方式还是实例工厂方式</li><li>被配置的Bean是否需要注入必要属性</li></ol><div class="tabs" id="1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#1-1">德鲁伊</button></li><li class="tab"><button type="button" data-href="#1-2">Connection</button></li><li class="tab"><button type="button" data-href="#1-3">日期对象</button></li><li class="tab"><button type="button" data-href="#1-4">SqlSessionFactory</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><p>以德鲁伊为例</p><p>实例化方式：无参构造</p><p>必要属性：4个基本属性</p><ol start="0"><li><p>引入依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   </span><br></pre></td></tr></table></figure></li><li><p>加载启动，配置 Druid 数据源交由Spring管理，配置 DruidDataSource</p><p>查看源码，它有无参构造和有参构造，用无参构造的方法可以直接在XML中配置bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置 DruidDataSource数据源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置必要属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc://localhost:3306/mybatis&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-2"><p>配置Connection交由Spring管理</p><p>Connection 的产生是通过DriverManager的静态方法getConnection获取的，可以视为静态工厂方式配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;java.lang.Class&quot; factory-method=&quot;forName&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;className&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;connection&quot; class=&quot;java.sql.DriverManager&quot; factory-method=&quot;getConnection&quot;</span><br><span class="line">scope=&quot;prototype&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;url&quot; value=&quot;jdbc:mysql:///mybatis&quot;/&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;user&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;password&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>这只是用来理解配置第三方bean的，开发不可能用这个方式，connection是被封装好了的</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-3"><p>配置日期对象交由Spring管理</p><p>产生一个指定日期格式的对象，原始代码按如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String currentTimeStr = &quot;2023-08-27 07:20:00&quot;;</span><br><span class="line">SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">Date date = simpleDateFormat.parse(currentTimeStr);</span><br></pre></td></tr></table></figure><p>可以看成是实例工厂方式，使用Spring配置方式产生Date实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//先获得工厂对象的bean</span><br><span class="line">&lt;bean id=&quot;simpleDateFormat&quot; class=&quot;java.text.SimpleDateFormat&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;pattern&quot; value=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">//通过上面的工厂bean，调用工厂bean的方法创建时间对象</span><br><span class="line">&lt;bean id=&quot;date&quot; factory-bean=&quot;simpleDateFormat&quot; factory-method=&quot;parse&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;source&quot; value=&quot;2023-08-27 07:20:00&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-4"><ol><li><p>配置MyBatis的SqlSessionFactory交由Spring管理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--mybatis框架--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.5.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- mysql驱动 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.49&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>配置MyBatis的SqlSessionFactory交由Spring管理 MyBatis原始获得SqlSessionFactory的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//加载mybatis核心配置文件，使用Spring静态工厂方式</span><br><span class="line">InputStream in = Resources.getResourceAsStream(“mybatis-conifg.xml”);</span><br><span class="line"></span><br><span class="line">//创建SqlSessionFactoryBuilder对象，使用Spring无参构造方式</span><br><span class="line">SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();</span><br><span class="line"></span><br><span class="line">//调用SqlSessionFactoryBuilder的build方法，使用Spring实例工厂方式</span><br><span class="line">SqlSessionFactory sqlSessionFactory = builder.build(in);</span><br></pre></td></tr></table></figure><p>SqlSessionFactory交由Spring管理配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--静态工厂方式产生Bean实例--&gt;</span><br><span class="line">&lt;bean id=“inputStream” class=“org.apache.ibatis.io.Resources&quot; factorymethod=“getResourceAsStream”&gt;</span><br><span class="line">    &lt;constructor-arg name=“resource” value=“mybatis-config.xml/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--无参构造方式产生Bean实例--&gt;</span><br><span class="line">&lt;bean id=&quot;sqlSessionFactoryBuilder&quot; class=&quot;org.apache.ibatis.session.SqlSessionFactoryBuilder&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--实例工厂方式产生Bean实例--&gt;</span><br><span class="line">&lt;bean id=&quot;sqlSessionFactory&quot; factory-bean=&quot;sqlSessionFactoryBuilder&quot; factory-method=&quot;build&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;inputStream&quot; ref=&quot;inputStream&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="基于xml方式整合第三方框架"><a href="#基于xml方式整合第三方框架" class="headerlink" title="基于xml方式整合第三方框架"></a>基于xml方式整合第三方框架</h2><p>xml整合第三方框架有两种整合方案：</p><ol><li>不需要自定义名空间，不需要使用Spring的配置文件配置第三方框架本身内容，例如：MyBatis</li><li>需要引入第三方框架命名空间，需要使用Spring的配置文件配置第三方框架本身内容，例如：Dubbo</li></ol><h3 id="Spring整合MyBatis"><a href="#Spring整合MyBatis" class="headerlink" title="Spring整合MyBatis"></a>Spring整合MyBatis</h3><p>MyBatis提供了mybatis-spring.jar专门用于两大框架的整合</p><p>Spring整合MyBatis的步骤如下：</p><ol><li><p>导入MyBatis整合Spring的相关坐标，一共4个：mysql、mybatis、mybatis-spring、spring-jdbc</p></li><li><p>编写Mapper和Mapper.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface UserMapper &#123;</span><br><span class="line">    List&lt;User&gt; findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.itheima.dao.UserMapper&quot;&gt;</span><br><span class="line">    &lt;select id=&quot;findAll&quot; resultType=&quot;com.itheima.pojo.User&quot;&gt;</span><br><span class="line">        select * from tb_user</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></li><li><p>配置SqlSessionFactoryBean和MapperScannerConfigurer</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置数据源--&gt;</span><br><span class="line">&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--配置SqlSessionFactoryBean--&gt;</span><br><span class="line">&lt;bean class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--配置Mapper包扫描--&gt;</span><br><span class="line">&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;basePackage&quot; value=&quot;com.itheima.dao&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>编写测试代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassPathxmlApplicationContext applicationContext = new ClassPathxmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        UserMapper userMapper = applicationContext.getBean(UserMapper.class);</span><br><span class="line">        List&lt;User&gt; all = userMapper.findAll();</span><br><span class="line">        System.out.println(all);</span><br></pre></td></tr></table></figure></li></ol><h3 id="原理剖析"><a href="#原理剖析" class="headerlink" title="原理剖析"></a>原理剖析</h3><p>整合包里提供了一个SqlSessionFactoryBean和一个扫描Mapper的配置对象，SqlSessionFactoryBean一旦被实例化，就开始扫描Mapper并通过动态代理产生Mapper的实现类存储到Spring容器中</p><p>相关的有如下四个类： </p><ol><li>SqlSessionFactoryBean：需要进行配置，用于提供SqlSessionFactory</li><li>MapperScannerConfigurer：需要进行配置，用于扫描指定mapper注册BeanDefinition</li><li>MapperFactoryBean：Mapper的FactoryBean，获得指定Mapper时调用getObject方法</li><li>ClassPathMapperScanner：definition.setAutowireMode()修改了自动注入状态，所以MapperFactoryBean中的setSqlSessionFactory会自动注入进去。</li></ol><h4 id="SqlSessionFactoryBean"><a href="#SqlSessionFactoryBean" class="headerlink" title="SqlSessionFactoryBean"></a>SqlSessionFactoryBean</h4><p>配置SqlSessionFactoryBean作用是向容器中提供SqlSessionFactory，SqlSessionFactoryBean实现了 FactoryBean 和 InitializingBean 两个接口，所以能实现getObject() 和afterPropertiesSet()方法</p><p>getObject()用来提供bean，而它里面也确实有getObject()方法，在afterPropertiesSet()方法内部，反回来一个sqlSessionFactory对象</p><p>部分源码，这一段证明返回了SqlSessionFactory对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactoryBean implements FactoryBean&lt;SqlSessionFactory&gt;, InitializingBean&#123;</span><br><span class="line">public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">  //创建SqlSessionFactory对象</span><br><span class="line">        this.sqlSessionFactory = this.buildSqlSessionFactory();</span><br><span class="line">   &#125;</span><br><span class="line">   public SqlSessionFactory getObject() throws Exception &#123;</span><br><span class="line">        return this.sqlSessionFactory;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>FactoryBean、InitializingBean 眼不眼熟</p></blockquote><h4 id="MapperScannerConfigurer"><a href="#MapperScannerConfigurer" class="headerlink" title="MapperScannerConfigurer"></a>MapperScannerConfigurer</h4><p>记住这个名字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置Mapper包扫描--&gt;</span><br><span class="line">&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;basePackage&quot; value=&quot;com.itheima.dao&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>在配置这个扫描器的时候就把mapper注进去了</p><p>配置MapperScannerConfigurer作用是扫描Mapper，向容器中注册Mapper对应的MapperFactoryBean</p><p>MapperScannerConfigurer实现了BeanDefinitionRegistryPostProcessor和InitializingBean两个接口，会在postProcessBeanDefinitionRegistry方法中向容器中注册MapperFactoryBean</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class MapperScannerConfigurer implements BeanDefinitionRegistryPostProcessor, InitializingBean,ApplicationContextAware,BeanNameAware &#123;</span><br><span class="line">    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) &#123;</span><br><span class="line">        ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);</span><br><span class="line">        scanner.scan(StringUtils.tokenizeToStringArray(this.basePackage, &quot;,; \t\n&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>BeanDefinitionRegistryPostProcessor、InitializingBean、ApplicationContextAware、BeanNameAware 眼不眼熟</p><p>BeanDefinitionRegistryPostProcessor：内部有向BDMap注册BD的作用，最终作用是把UserMapper存储到spring容器中</p><p>InitializingBean：注入初始化方法</p><p>ApplicationContextAware：注入spring容器</p><p>BeanNameAware：注入BeanName</p></blockquote><p>由于有上述各后处理器等组件，所以注册完SqlSessionFactoryBean和MapperScannerConfigurer后，spring会自动把mapper实现类扔到容器里面</p><h4 id="加载外部properties"><a href="#加载外部properties" class="headerlink" title="加载外部properties"></a>加载外部properties</h4><p>Spring 整合其他组件时就不像MyBatis这么简单了，例如Dubbo框架在于Spring进行整合时，要使用Dubbo提供的命名空间的扩展方式，自定义了一些Dubbo标签，为了降低学习成本，不在引入Dubbo第三方框架了，以Spring的 context 命名空间去引入mybatis，加载外部properties文件，将键值对存储在Spring容器中</p><ol><li><p>编写properties文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jdbc.url=jdbc:mysql://localhost:3306/mybatis</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=root</span><br></pre></td></tr></table></figure></li><li><p>引入context命名空间，在使用context命名空间的标签，使用SpEL表达式在xml或注解中根据key获得value</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li><p>配置bean，引入spl表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="自定义命名空间使用"><a href="#自定义命名空间使用" class="headerlink" title="自定义命名空间使用"></a>自定义命名空间使用</h2><p>外部命名空间标签的执行流程</p><ul><li>将自定义标签的约束 与 物理约束文件与网络约束名称的约束 以键值对形式存储到一个spring.schemas文件里<br>，该文件存储在类加载路径的 META-INF里，Spring会自动加载到;</li><li>将自定义命名空间的名称 与 自定义命名空间的处理器映射关系 以键值对形式存在到一个叫spring.handlers文<br>件里，该文件存储在类加载路径的 META-INF里，Spring会自动加载到;</li><li>准备好NamespaceHandler，如果命名空间只有一个标签，那么直接在parse方法中进行解析即可，一般解析结果就是注册该标签对应的BeanDefinition。</li><li>如果命名空间里有多个标签，那么可以在init方法中为每个标签都注册一个BeanDefinitionParser，在执行NamespaceHandler的parse方法时在分流给不同的BeanDefinitionParser进行解析(重写doParse方法即可)</li></ul><h1 id="Bean的创建使用底层"><a href="#Bean的创建使用底层" class="headerlink" title="Bean的创建使用底层"></a>Bean的创建使用底层</h1><h2 id="实例化的基本流程"><a href="#实例化的基本流程" class="headerlink" title="实例化的基本流程"></a>实例化的基本流程</h2><p>Spring容器在进行初始化时，会将xml配置的的信息封装成一个<strong>BeanDefinition</strong>对象，所有的 BeanDefinition存储到一个名为<strong>beanDefinitionMap</strong>的Map集合中去，Spring框架在对该Map进行遍历，使用反射创建<strong>Bean实例对象</strong></p><p>创建好的Bean对象存储在一个名为<strong>singletonObjects（单例池）</strong>的Map集合中，当调用getBean方法 时则最终从该Map集合中取出Bean实例对象返回</p><p><strong>Bean</strong>对象：封装我们需要的对象</p><p><strong>BeanDefinition</strong>对象：封装bean的对象，每个bean都有一个BeanDefinition与之对应</p><p><strong>beanDefinitionMap</strong>：集中存储BeanDefinition对象的Map</p><p><strong>singletonObjects</strong>：集中存储完全体Bean对象的Map</p><p><strong>单例 Bean 实例化的基本流程</strong>：</p><ol><li>加载xml配置文件，解析获取配置中的每个的信息，封装成一个个的BeanDefinition对象</li><li>将BeanDefinition存储在一个名为beanDefinitionMap的Map中</li><li>ApplicationContext底层遍历beanDefinitionMap，创建Bean实例对象</li><li>创建好的Bean实例对象，被存储到一个名为singletonObjects的Map中</li><li>当执行applicationContext.getBean(beanName)时，从singletonObjects去匹配Bean实例返回</li></ol><p>DefaultListableBeanFactory对象内部维护着一个Map用于存储封装好的BeanDefinitionMap</p><blockquote><p>DefaultListableBeanFactory眼熟不，最开始提到的Bean工厂的实现类</p></blockquote><p>Spring框架会取出beanDefinitionMap中的每个BeanDefinition信息，反射构造方法或调用指定的工厂方法生成Bean实例对象，所以只要将BeanDefinition注册到beanDefinitionMap这个Map中，Spring就会进行对应的Bean的实例化操作</p><p>Bean实例及单例池singletonObjects， beanDefinitionMap中的BeanDefinition会被转化成对应的Bean实例对象 ，存储到单例池singletonObjects中去，在DefaultListableBeanFactory的上四级父类 DefaultSingletonBeanRegistry中，维护着singletonObjects，源码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultSingletonBeanRegistry extends ... implements ... &#123;</span><br><span class="line">  //存储Bean实例的单例池</span><br><span class="line">  //key:是Bean的beanName，value:是Bean的实例对象</span><br><span class="line">  private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap(256);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109190337461.png" alt="image-20231109190337461"></p><h3 id="debug查看"><a href="#debug查看" class="headerlink" title="debug查看"></a>debug查看</h3><p>可以对创建spring容器的那一步进行debug，查看内部存放内容</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231118143106703.png" alt="image-20231118143106703"></p><p>其中，存放的对象不是对象本身，是BeanDefinition，真正的对象在上面两行的singletonObjects里面</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231118143221334.png" alt="image-20231118143221334"></p><h2 id="后处理器"><a href="#后处理器" class="headerlink" title="后处理器"></a>后处理器</h2><p>（这里记的不是很清晰，建议网上另找文章）</p><p><a href="https://blog.csdn.net/qwer123451234123/article/details/124353567">https://blog.csdn.net/qwer123451234123/article/details/124353567</a></p><p><a href="https://zhuanlan.zhihu.com/p/623041363">https://zhuanlan.zhihu.com/p/623041363</a></p><p><a href="https://zhuanlan.zhihu.com/p/84413599">https://zhuanlan.zhihu.com/p/84413599</a></p><p>Spring的后处理器是Spring对外开发的重要扩展点，允许我们介入到Bean的整个实例化流程中来，以达到动态注册 BeanDefinition，动态修改BeanDefinition，以及动态修改Bean的作用。</p><p>Spring主要有三&#x3D;四种后处理器：</p><ol><li><strong>BeanDefinitionRegistryPostProcessor</strong>：beanDefinition后置处理器，可以动态注册自己的beanDefinition，可以加载classpath之外的bean</li><li><strong>BeanFactoryPostProcessor</strong>：Bean工厂后处理器，在BeanDefinitionMap填充完毕，Bean实例化之前执行，它修改的对象是BeanDefinition，可以认为是模具，后面所有的bean都会受影响</li><li><strong>BeanPostProcessor</strong>：Bean后处理器，一般在Bean实例化之后，填充到单例池singletonObjects之前执行。它修改的对象是单个Bean，只影响一个</li><li><strong>InitializingBean</strong>：</li></ol><blockquote><p>根据上面各个处理器的功能作用描述可以得到三个处理器的执行顺序：</p><p>BeanDefinitionRegistryPostProcessor → BeanFactoryPostProcessor → BeanPostProcessor</p></blockquote><div class="tabs" id="6"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#6-1">BeanFactoryPostProcessor</button></li><li class="tab"><button type="button" data-href="#6-2">BeanDefinitionRegistryPostProcessor</button></li><li class="tab"><button type="button" data-href="#6-3">BeanPostProcessor</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="6-1"><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109193430419.png" alt="image-20231109193430419"></p><p>BeanFactoryPostProcessor是一个接口规范，实现了该接口的类只要交由Spring容器管理的话，那么Spring就会回调该接口的方法，用于对BeanDefinition注册和修改的功能</p><p>postProcessBeanFactory 参数本质就是 DefaultListableBeanFactory，拿到BeanFactory的引用，自然就可对beanDefinitionMap中的BeanDefinition进行操作了</p><p>BeanFactoryPostProcessor接口定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanFactoryPostProcessor &#123;</span><br><span class="line">  void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟使用BeanFactoryPostProcessor：</p><ol><li><p>编写BeanFactoryPostProcessor实现类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException&#123;</span><br><span class="line">    System.out.println(&quot;MyBeanFactoryPostProcessor执行了...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里拿到了beanFactory，那自然可以对内部的Map进行处理，但是为了安全起见，它不让我们拿到整个Map，我们只能单个BD的拿（内部方法 <code>getBeanDefinition(beanName)</code>）</p><ul><li><p>比如对UserDaoImpl的BeanDefinition进行修改操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor &#123;</span><br><span class="line">  public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">    //获得UserDao定义对象</span><br><span class="line">    BeanDefinition userDaoBD = beanFactory.getBeanDefinition(“userDao”);</span><br><span class="line">    </span><br><span class="line">    //修改class</span><br><span class="line">    userDaoBD.setBeanClassName(&quot;com.itheima.dao.impl.UserDaoImpl2&quot;); </span><br><span class="line">    </span><br><span class="line">    //修改初始化方法</span><br><span class="line">    //userDaoBD.setInitMethodName(methodName); </span><br><span class="line">    </span><br><span class="line">    //修改是否懒加载</span><br><span class="line">    //userDaoBD.setLazyInit(true); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对BeanDefiition进行注册操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException &#123;</span><br><span class="line">  </span><br><span class="line">    //强转成子类DefaultListableBeanFactory，不然没有registerBeanDefinition方法</span><br><span class="line">    if(configurableListableBeanFactory instanceof DefaultListableBeanFactory)&#123;</span><br><span class="line">      DefaultListableBeanFactory beanFactory = (DefaultListableBeanFactory) configurableListableBeanFactory;</span><br><span class="line">      </span><br><span class="line">      //注册beanDefinition对象</span><br><span class="line">      BeanDefinition beanDefinition = new RootBeanDefinition();</span><br><span class="line">      </span><br><span class="line">      //获取bean对象信息</span><br><span class="line">      beanDefinition.setBeanClassName(&quot;com.itheima.dao.UserDaoImpl2&quot;);</span><br><span class="line">      </span><br><span class="line">      //进行注册操作</span><br><span class="line">      beanFactory.registerBeanDefinition(&quot;userDao2&quot;,beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>配置BeanFactoryPostProcessor</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;com.itheima.processor.MyBeanFactoryPostProcessor&quot;/&gt;</span><br></pre></td></tr></table></figure></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6-2"><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109193430419.png" alt="image-20231109193430419"></p><p>Spring 提供了一个BeanFactoryPostProcessor的子接口BeanDefinitionRegistryPostProcessor专门用于注册 BeanDefinition操作，想实现注册直接用这个子接口就行了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class MyBeanFactoryPostProcessor2 implements BeanDefinitionRegistryPostProcessor &#123;</span><br><span class="line">  @Override</span><br><span class="line">  //这个是父接口BeanFactoryPostProcessor的，所以一定要实现</span><br><span class="line">  public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  //这个是专门用来这次的方法</span><br><span class="line">  public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry beanDefinitionRegistry) throws BeansException &#123;</span><br><span class="line">    //注册beanDefinition对象</span><br><span class="line">    BeanDefinition beanDefinition = new RootBeanDefinition();</span><br><span class="line">    //获取bean对象信息</span><br><span class="line">    beanDefinition.setBeanClassName(&quot;com.itheima.dao.UserDaoImpl2&quot;);</span><br><span class="line">    //进行注册操作</span><br><span class="line">    beanDefinitionRegistry.registerBeanDefinition(&quot;userDao2&quot;,beanDefinition);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6-3"><p>Bean被实例化后，到最终缓存到名为singletonObjects单例池之前，中间会经过Bean的初始化过程</p><p>例如：属性的填充、初始方法init的执行等，其中有一个对外进行扩展的点BeanPostProcessor，我们称为Bean后处理。</p><p>跟上面的 Bean工厂后处理器相似，它也是一个接口，实现了该接口并被容器管理的BeanPostProcessor，会在流程节点上被 Spring自动调用。</p><p>BeanPostProcessor的接口定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanPostProcessor &#123;</span><br><span class="line"></span><br><span class="line">  @Nullable</span><br><span class="line">  //在属性注入完毕，初始化方法执行之前被回调</span><br><span class="line">  default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">    return bean;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Nullable</span><br><span class="line">  //在初始化方法执行之后，被添加到单例池singletonObjects之前被回调</span><br><span class="line">  default Object postProcessAfterInitialization(Object bean, String beanName) throws</span><br><span class="line">BeansException &#123;</span><br><span class="line">    return bean;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义MyBeanPostProcessor，完成快速入门测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class MyBeanPostProcessor implements BeanPostProcessor &#123;</span><br><span class="line"></span><br><span class="line">/* 参数： bean是当前被实例化的Bean，beanName是当前Bean实例在容器中的名称</span><br><span class="line">返回值：当前Bean实例对象 */</span><br><span class="line"></span><br><span class="line">  public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">    System.out.println(&quot;BeanPostProcessor的before方法...&quot;);</span><br><span class="line">    return bean;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">/* 参数： bean是当前被实例化的Bean，beanName是当前Bean实例在容器中的名称</span><br><span class="line">返回值：当前Bean实例对象 */</span><br><span class="line"></span><br><span class="line">  public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">    System.out.println(&quot;BeanPostProcessor的after方法...&quot;);</span><br><span class="line">    return bean;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置MyBeanPostProcessor</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;com.itheima.processors.MyBeanPostProcessor&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109193635396.png" alt="image-20231109193635396"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>proxy代理?</p><p>动态代理？</p><h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231116111100188.png" alt="image-20231116111100188"></p><p>Spring Bean的生命周期是从 Bean 实例化之后，即通过反射创建出对象之后，到Bean成为一个完整对象，最终存储到单例池中，这个过程被称为Spring Bean的生命周期。Spring Bean的生命周期大体上分为三个阶段：</p><ol><li><p>实例化阶段</p><p>Spring框架会取出BeanDefinition的信息进行判断当前Bean的范围是否是singleton的， 是否不是延迟加载的，是否不是FactoryBean等一系列的 if 判断，以及一些其他方法，最终将一个普通的singleton的Bean通过反射进行实例化</p></li><li><p>初始化阶段</p><p>Bean创建之后还仅仅是个”半成品”，还需要对Bean实例的属性进行填充、执行一些 Aware 接口方法、执行BeanPostProcessor方法、执行InitializingBean接口的初始化方法、执行自定义初始化init方法 等。</p><p>该阶段是Spring最具技术含量和复杂度的阶段，Aop增强功能，Spring的注解功能等都是通过这里实现的</p></li><li><p>完成阶段</p><p>经过初始化阶段，Bean就成为了一个完整的Spring Bean，被存储到单例池 singletonObjects中去了，即完成了Spring Bean的整个生命周期</p></li></ol><h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><p>Spring Bean的初始化过程涉及如下几个过程：</p><ul><li>Bean实例的属性填充</li><li>Aware接口属性注入</li><li>BeanPostProcessor 的 before() 方法回调 </li><li>InitializingBean 接口的初始化方法回调</li><li>自定义初始化方法init回调</li><li>BeanPostProcessor的after()方法回调</li></ul><h4 id="Bean实例的属性填充"><a href="#Bean实例的属性填充" class="headerlink" title="Bean实例的属性填充"></a>Bean实例的属性填充</h4><p>BeanDefinition 中有对当前Bean实体的注入信息通过属性propertyValues进行了存储，这些属性也被封装了</p><p>Spring容器中有一个BeanFactory，BeanFactory中有BeanDefinitionMap，BeanDefinitionMap中有propertyValues</p><p>例如UserService的属性信息如下</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109193947579.png" alt="image-20231109193947579"></p><p>Spring在进行属性注入时，会分为如下三种情况：</p><ul><li>注入普通属性，String、int或存储基本类型的集合时，直接通过set方法的反射设置进去</li><li>注入单向对象引用属性时，从容器中getBean获取后通过set方法反射设置进去，如果容器中没有，则先创建被注入对象Bean实例（完成整个生命周期）后，在进行注入操作</li><li>注入双向对象引用属性时，就比较复杂了，涉及了循环引用（循环依赖）问题</li></ul><h5 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h5><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109194114161.png" alt="image-20231109194114161"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109194313661.png" alt="image-20231109194313661"></p><p>Bean只需要其他的Bean完成自己的创建，但是不会去干涉其他Bean的创建，可以把半成品的Bean拿去先凑个数然后实现自己的创建（用结果当条件去证结果）</p><p>因为new以后地址不会变，所以能保证半成品和成品都在同一个位置，不影响使用</p><p>Spring提供了<strong>三级缓存</strong>，保存<strong>完整Bean对象</strong> 和 <strong>半成品Bean对象</strong> ，用于解决循环引用问题，在DefaultListableBeanFactory的上四级父类DefaultSingletonBeanRegistry中提供如下三个Map：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultSingletonBeanRegistry ... &#123;</span><br><span class="line">  //1、最终存储单例Bean成品的容器，即实例化和初始化都完成的Bean，称之为&quot;一级缓存&quot;</span><br><span class="line">  Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap(256);</span><br><span class="line">  //2、早期Bean单例池，缓存半成品对象，且当前对象已经被其他对象引用了，称之为&quot;二级缓存&quot;</span><br><span class="line">  Map&lt;String, Object&gt; earlySingletonObjects = new ConcurrentHashMap(16);</span><br><span class="line">  //3、单例Bean的工厂池，缓存半成品对象，对象未被引用，使用时在通过工厂创建Bean，称之为&quot;三级缓存&quot;</span><br><span class="line">  Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap(16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一级缓存：最终存储单例Bean成品的容器，即实例化和初始化都完成的Bean，容量256</li><li>二级缓存：早期Bean单例池，缓存半成品对象，且当前对象已经被其他对象引用了，容量16</li><li>三级缓存：单例Bean的工厂池，缓存半成品对象，对象未被引用，使用时在通过工厂创建Bean，容量16</li></ul><p>UserService和UserDao循环依赖的过程结合上述三级缓存描述一下：</p><ol><li>UserService 实例化对象，但尚未初始化，将UserService存储到三级缓存</li><li>UserService 属性注入，需要UserDao，从缓存中获取，没有UserDao</li><li>UserDao实例化对象，但尚未初始化，将UserDao存储到到三级缓存</li><li>UserDao属性注入，需要UserService，从三级缓存获取UserService，UserService从三级缓存移入二级缓存</li><li>UserDao执行其他生命周期过程，最终成为一个完成Bean，存储到一级缓存，删除二三级缓存</li><li>UserService 注入UserDao</li><li>UserService执行其他生命周期过程，最终成为一个完成Bean，存储到一级缓存，删除二三级缓存</li></ol><h4 id="Aware接口属性注入"><a href="#Aware接口属性注入" class="headerlink" title="Aware接口属性注入"></a>Aware接口属性注入</h4><p>Aware接口是一种框架辅助属性注入的一种思想，其他框架中也可以看到类似的接口。框架具备高度封装性，我们接触到的一般都是业务代码，一个底层功能API不能轻易的获取到，但是这不意味着永远用不到这些对象，如果用到了，就可以使用框架提供的类似Aware的接口，让框架给我们注入该对象</p><p>大致就是普通人（普通bean）想访问机密文件，本来应该是不允许的，但是这个普通人在这个时候有了权限（实现相关方法），就能访问机密文件</p><table><thead><tr><th>Aware接口</th><th>回调方法</th><th>作用</th></tr></thead><tbody><tr><td>ServletContextAware</td><td>setServletContext(ServletContext context)</td><td>Spring框架回调方法注入ServletContext对象，web环境下才生效</td></tr><tr><td>BeanFactoryAware</td><td>setBeanFactory(BeanFactory factory)</td><td>Spring框架回调方法注入beanFactory对象</td></tr><tr><td>BeanNameAware</td><td>setBeanName(String beanName)</td><td>Spring框架回调方法注入当前Bean在容器中的beanName</td></tr><tr><td>ApplicationContextAware</td><td>setApplicationContext(ApplicationContext applicationContext)</td><td>Spring框架回调方法注入applicationContext对象</td></tr></tbody></table><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231116111100188.png" alt="image-20231116111100188"></p><h2 id="Bean创建整体流程总结"><a href="#Bean创建整体流程总结" class="headerlink" title="Bean创建整体流程总结"></a>Bean创建整体流程总结</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109190337461.png" alt="image-20231109190337461"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109221132853.png" alt="image-20231109221132853"></p><p>功能增强都是基于这张图实现的，在相应的地方增强功能。</p><p>P56 回忆了bean创建的流程，忘记了回来看</p><h1 id="基于注解的Spring应用"><a href="#基于注解的Spring应用" class="headerlink" title="基于注解的Spring应用"></a>基于注解的Spring应用</h1><p>Spring除了xml配置文件进行配置之外，还可以使用注解方式进行配置，注解方式慢慢成为xml配置的替代方案</p><p>Spring提供的注解有三个版本：</p><ul><li>2.0时代，Spring开始出现注解</li><li>2.5时代，Spring的Bean配置可以使用注解完成</li><li>3.0时代，Spring其他配置也可以使用注解完成，我们进入全注解时代</li></ul><p>但是XML和他的原理是spring的根基，spring的很多强大功能都是<strong>基于XML</strong>，通过几个<strong>后处理器</strong>增强的</p><h2 id="Bean注解开发"><a href="#Bean注解开发" class="headerlink" title="Bean注解开发"></a>Bean注解开发</h2><p>Bean注解开发实质：</p><ol><li>用注解的方式替代原有的xml标签及其标签属性的配置</li><li>用核心配置类替换Xml文件</li></ol><h3 id="Bean标签替换"><a href="#Bean标签替换" class="headerlink" title="Bean标签替换"></a>Bean标签替换</h3><p>使用@Component 注解替代Bean标签，被该注解标识的类，会在指定扫描范围内被Spring加载并注册成Bean</p><p>XML中：</p><ul><li>id：Bean的名字</li><li>class：Bean对应的类的全类名，通过反射创建对象</li></ul><p>@Component：</p><ul><li><p>value属性指定当前Bean实例的beanName，也可以省略不写，不写的情况下为当前类名首字母小写</p><p><code>@Component(value=&quot;userDao&quot;)</code> <code>@Component(&quot;userDao&quot;)</code> <code>@Component()</code>都可以</p></li><li><p>@Component直接配置在相应类上，指出类的路径</p></li></ul><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><ol><li><p>用注解定义bean</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//获取方式：applicationContext.getBean(&quot;userDao&quot;);</span><br><span class="line">@Component(&quot;userDao&quot;)</span><br><span class="line">public class UserDaoImpl implements UserDao &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//获取方式：applicationContext.getBean(&quot;userDaoImpl&quot;);</span><br><span class="line">@Component</span><br><span class="line">public class UserDaoImpl implements UserDao &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置xml文件，声明要使用注解，并指出扫描的基本包和其子包，要配置组件扫描路径</p><p>这个也能被标签替代</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 告知Spring框架去itheima包及其子包下去扫描使用了注解的类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>底层是通过后处理器来实现扫包的效果</p></li></ol><h3 id="Bean其他属性"><a href="#Bean其他属性" class="headerlink" title="Bean其他属性"></a>Bean其他属性</h3><p>@Component就单纯一个value属性，这个属性配置了Bean的名字，其余属性也可以通过注解方式去配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;&quot; name=&quot;&quot; class=&quot;&quot; scope=&quot;&quot; lazy-init=&quot;&quot; init-method=&quot;&quot; destroy-method=&quot;&quot;</span><br><span class="line">abstract=&quot;&quot; autowire=&quot;&quot; factory-bean=&quot;&quot; factory-method=&quot;&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>xml配置</th><th>注解</th><th>描述</th></tr></thead><tbody><tr><td>&lt; bean scope&#x3D;””&gt;</td><td>@Scope</td><td>在类上或使用了@Bean标注的方法上，标注Bean的作用范围，取值为 singleton或prototype</td></tr><tr><td>&lt; bean lazy-init&#x3D;””&gt;</td><td>@Lazy</td><td>在类上或使用了@Bean标注的方法上，标注Bean是否延迟加载，取值为 true和false</td></tr><tr><td>&lt; bean init-method&#x3D;””&gt;</td><td>@PostConstruct</td><td>在方法上使用，标注Bean的实例化后执行的方法</td></tr><tr><td>&lt; bean destroy-method&#x3D;””&gt;</td><td>@PreDestroy</td><td>在方法上使用，标注Bean的销毁前执行方法</td></tr></tbody></table><p>使用上述注解完成UserDaoImpl的基本配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Component(&quot;userDao&quot;)</span><br><span class="line">@Scope(&quot;singleton&quot;)</span><br><span class="line">@Lazy(true)</span><br><span class="line">public class UserDaoImpl implements UserDao&#123;</span><br><span class="line"></span><br><span class="line">  @PostConstruct</span><br><span class="line">  public void init()&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  @PreDestroy</span><br><span class="line">  public void destroy()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分层设计"><a href="#分层设计" class="headerlink" title="分层设计"></a>分层设计</h3><p>由于JavaEE开发是分层的，为了每层Bean标识的注解语义化更加明确，@Component又衍生出如下三个注解</p><table><thead><tr><th>@Component衍生注解</th><th>描述</th></tr></thead><tbody><tr><td>@Repository</td><td>在Dao层类上使用</td></tr><tr><td>@Service</td><td>在Service层类上使用</td></tr><tr><td>@Controller</td><td>在Web层类上使用</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Repository(&quot;userDao&quot;)</span><br><span class="line">public class UserDaoImpl implements UserDao&#123;&#125;</span><br><span class="line"></span><br><span class="line">@Service(&quot;userService&quot;)</span><br><span class="line">public class UserServiceImpl implements UserService&#123;&#125;</span><br><span class="line"></span><br><span class="line">@Controller(&quot;userService&quot;)</span><br><span class="line">public class UserController &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="Bean依赖注入注解开发"><a href="#Bean依赖注入注解开发" class="headerlink" title="Bean依赖注入注解开发"></a>Bean依赖注入注解开发</h2><p>XML中，原来用&lt; porperty&gt; 给Bean配置，中间用value和ref属性来配置普通类型和引用对象</p><p>Spring主要提供如下注解，用于在Bean内部进行属性注入的</p><table><thead><tr><th>属性注入注解</th><th>描述</th></tr></thead><tbody><tr><td>@Value</td><td>使用在字段或方法上，用于注入普通数据</td></tr><tr><td>@Autowired</td><td>使用在字段或方法上，用于根据类型（byType）注入引用数据</td></tr><tr><td>@Qualifier</td><td>使用在字段或方法上，结合@Autowired，根据名称注入</td></tr><tr><td>@Resource</td><td>使用在字段或方法上，根据类型或名称进行注入</td></tr></tbody></table><ul><li><p>通过@Value 直接注入普通属性，通过反射暴力创建的对象，可以在属性或者方法上配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//属性上配置</span><br><span class="line">@Value(&quot;haohao&quot;)</span><br><span class="line">private String username;</span><br><span class="line"></span><br><span class="line">//方法上配置</span><br><span class="line">@Value(&quot;haohao&quot;)</span><br><span class="line">public void setUsername(String username)&#123;</span><br><span class="line">  System.out.println(username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样就写死了，没意义而且加大了复杂度，下面的使用有一定的意义</p></li><li><p>通过@Value 注入properties文件中的属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span><br><span class="line">private String username;</span><br><span class="line"></span><br><span class="line">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span><br><span class="line">public void setUsername(String username)&#123;</span><br><span class="line">  System.out.println(username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加载properties文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;</span><br></pre></td></tr></table></figure></li><li><p>@Autowired注解，用于根据类型进行注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//使用在属性上直接注入</span><br><span class="line">@Autowired</span><br><span class="line">private UserDao userDao;</span><br><span class="line"></span><br><span class="line">//使用在方法上直接注入</span><br><span class="line">@Autowired</span><br><span class="line">public void setUserDao(UserDao userDao)&#123;</span><br><span class="line">System.out.println(userDao);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当容器中同一类型的Bean实例有多个时，会尝试自动根据名字进行匹配，没有名字一样的就会报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//匹配当前Bean</span><br><span class="line">@Repository(&quot;userDao&quot;)</span><br><span class="line">public class UserDaoImpl implements UserDao&#123;&#125;</span><br><span class="line"></span><br><span class="line">@Repository(&quot;userDao2&quot;)</span><br><span class="line">public class UserDaoImpl2 implements UserDao&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>@Qualifier配合@Autowired可以完成根据名称注入Bean实例，使用@Qualifier指定名称</p><p>@Qualifier是可以单用的，只是这里联合使用了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">@Qualifier(&quot;userDao2&quot;)</span><br><span class="line">private UserDao userDao;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">@Qualifier(&quot;userDao2&quot;)</span><br><span class="line">public void setUserDao(UserDao userDao)&#123;</span><br><span class="line">  System.out.println(userDao);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@Resource注解既可以根据类型注入，也可以根据名称注入，无参就是根据类型注入，有参数就是根据名称注入，本来是Java的注解，但是被spring拿来用了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Resource</span><br><span class="line">private UserDao userDao;</span><br><span class="line"></span><br><span class="line">@Resource(name = &quot;userDao2&quot;)</span><br><span class="line">public void setUserDao(UserDao userDao)&#123;</span><br><span class="line">  System.out.println(userDao);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Resource注解存在与 javax.annotation 包中，Spring对其进行了解析</p></li></ul><h2 id="非自定义Bean注解开发"><a href="#非自定义Bean注解开发" class="headerlink" title="非自定义Bean注解开发"></a>非自定义Bean注解开发</h2><p>非自定义Bean一般存在于jar包中，不能像自定义Bean一样使用@Component进行管理，要使用@Bean通过工厂方式进行实例化，@Bean(“Bean的名字”)</p><p>@Bean的参数 &#x3D; 方法返回值的名字 &#x3D; Bean名字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//将方法返回值Bean实例以@Bean注解指定的名称存储到Spring容器中</span><br><span class="line">@Bean(&quot;dataSource&quot;)</span><br><span class="line">public DataSource dataSource()&#123;</span><br><span class="line">  DruidDataSource dataSource = new DruidDataSource();</span><br><span class="line">  dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">  dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/mybatis&quot;);</span><br><span class="line">  dataSource.setUsername(&quot;root&quot;);</span><br><span class="line">  dataSource.setPassword(&quot;root&quot;);</span><br><span class="line">  return dataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂方法所在类必须要被Spring管理</p><p>如果@Bean工厂方法需要参数的话，则有如下三种注入方式：</p><ol><li>使用@Autowired 根据类型自动进行Bean的匹配，@Autowired可以省略 </li><li>使用@Qualifier 根据名称进行Bean的匹配</li><li>使用@Value 根据名称进行普通数据类型匹配</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@Autowired //根据类型匹配参数</span><br><span class="line">public Object objectDemo01(UserDao userDao)&#123;</span><br><span class="line">  System.out.println(userDao);</span><br><span class="line">  return new Object();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public Object objectDemo02(@Qualifier(&quot;userDao&quot;) UserDao userDao,</span><br><span class="line">  @Value(&quot;$&#123;jdbc.username&#125;&quot;) String username)&#123;</span><br><span class="line">  System.out.println(userDao);</span><br><span class="line">  System.out.println(username);</span><br><span class="line">  return new Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>细节：</p><ol><li><p>不加名字行不行？</p><p>可以的，默认名字是方法的名字，注意，是<strong>方法的名字</strong></p></li><li><p>这是用工厂方法生产的，方法存在于对象中，所以，对象bean必须要能扫到</p></li><li><p>需要其他参数时候怎么办？</p><p>和前面给bean配置参数一样，前面怎么配置，这里怎么配置</p></li></ol><h2 id="Bean配置类"><a href="#Bean配置类" class="headerlink" title="Bean配置类"></a>Bean配置类</h2><p>@Component等注解替代了标签，但是像&lt; import&gt;、 &lt; context:componentScan&gt;等非标签怎 去使用注解替代呢？</p><p>定义一个配置类替代原有的xml配置文件，标签以外的标签，一般都是在配置类上使用注解完成的</p><div class="tabs" id=""><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#-1"><i class="Configuration" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#-2"><i class="ComponentScan" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#-3"><i class="PropertySource" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#-4"><i class="Import" style="text-align: center;"></i></button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="-1"><p>@Configuration：标识的类为配置类，替代原有xml配置文件，有2个作用</p><ol><li><p>标识该类是一个配置类</p></li><li><p>具备@Component作用，配置类也是一个组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ApplicationContextConfig &#123;&#125;</span><br></pre></td></tr></table></figure></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-2"><p>@ComponentScan：组件扫描配置，替代原有xml文件中的&lt;context:component-scan base-package&#x3D;””&#x2F;&gt;，指出扫描的基本类路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(base-package = &#123;&quot;com.itheima.service&quot;,&quot;com.itheima.dao&quot;&#125;)</span><br><span class="line">public class ApplicationContextConfig &#123;&#125;</span><br></pre></td></tr></table></figure><p>base-package的配置方式：</p><ol><li>指定一个或多个包名：扫描指定包及其子包下使用注解的类</li><li>不配置包名：扫描当前@componentScan注解配置类所在包及其子包下的类</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-3"><p>@PropertySource：用于加载外部properties资源配置，替代原有xml中的&lt;context:propertyplaceholder location&#x3D;“位置”&#x2F;&gt; 配置，指出去哪里找配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan</span><br><span class="line">@PropertySource(&#123;&quot;classpath:jdbc.properties&quot;,&quot;classpath:xxx.properties&quot;&#125;)</span><br><span class="line">public class ApplicationContextConfig &#123;&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-4"><p>@Import 用于加载其他配置类，替代原有xml中的&lt; import resource&#x3D;”classpath:beans.xml”&#x2F;&gt;配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan</span><br><span class="line">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span><br><span class="line">@Import(OtherConfig.class)</span><br><span class="line">public class ApplicationContextConfig &#123;&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="更换spring容器实现类"><a href="#更换spring容器实现类" class="headerlink" title="更换spring容器实现类"></a>更换spring容器实现类</h3><p>原先使用的是根据路径加载配置的spring容器实现类<code>ClassPathXmlApplicationContext</code> 和 <code>FileSystemXmlApplicationContext</code></p><p>现在配置文件都没了，更换为用注解加载配置的spring容器实现类<code>AnnotationConfigApplicationContext</code></p><h2 id="Spring-配置其他注解"><a href="#Spring-配置其他注解" class="headerlink" title="Spring 配置其他注解"></a>Spring 配置其他注解</h2><h3 id="Primary"><a href="#Primary" class="headerlink" title="@Primary"></a>@Primary</h3><p>@Primary注解用于标注相同类型的Bean优先被使用权</p><p>@Primary 是Spring3.0引入的，与@Component 和@Bean一起使用，标注该Bean的优先级更高，则在通过类型获取Bean或通过@Autowired根据类型进行注入时， 会选用优先级更高的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Repository(&quot;userDao&quot;)</span><br><span class="line">public class UserDaoImpl implements UserDao&#123;&#125;</span><br><span class="line">@Repository(&quot;userDao2&quot;)</span><br><span class="line">@Primary</span><br><span class="line">public class UserDaoImpl2 implements UserDao&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public UserDao userDao01()&#123;return new UserDaoImpl();&#125;</span><br><span class="line">@Bean</span><br><span class="line">@Primary</span><br><span class="line">public UserDao userDao02()&#123;return new UserDaoImpl2();&#125;</span><br></pre></td></tr></table></figure><h3 id="Profile"><a href="#Profile" class="headerlink" title="@Profile"></a>@Profile</h3><p>@Profile 注解的作用同于xml配置时学习profile属性，是进行环境切换使用的</p><p>注解 @Profile 标注在类或方法上，标注当前产生的Bean从属于哪个环境，只有激活了当前环境，被标注的Bean才能被注册到Spring容器里，不指定环境的Bean，即没有加这个注解的Bean，任何环境下都能注册到Spring容器里</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans profile=&quot;test&quot;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Repository(&quot;userDao&quot;)</span><br><span class="line">@Profile(&quot;test&quot;)</span><br><span class="line">public class UserDaoImpl implements UserDao&#123;&#125;</span><br><span class="line">@Repository(&quot;userDao2&quot;)</span><br><span class="line">public class UserDaoImpl2 implements UserDao&#123;&#125;</span><br></pre></td></tr></table></figure><p>可以使用以下两种方式指定被激活的环境：</p><ol><li>使用命令行动态参数，虚拟机参数位置加载 -Dspring.profiles.active&#x3D;test</li><li>使用代码的方式设置环境变量 System.setProperty(“spring.profiles.active”,”test”);</li></ol><h2 id="Spring注解的解析原理"><a href="#Spring注解的解析原理" class="headerlink" title="Spring注解的解析原理"></a>Spring注解的解析原理</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231110210128599.png" alt="image-20231110210128599"></p><p> 使用@Component等注解配置完毕后，要配置组件扫描才能使注解生效</p><ol><li><p>xml配置组件扫描</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:component-scan base-package=&quot;com.itheima&quot;/&gt;</span><br></pre></td></tr></table></figure></li><li><p>配置类配置组件扫描</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.itheima&quot;)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231119181600269.png" alt="image-20231119181600269"></p><h3 id="xml方式"><a href="#xml方式" class="headerlink" title="xml方式"></a>xml方式</h3><p><a href="https://www.cnblogs.com/question-sky/p/6953315.html%EF%BC%8C%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E8%AE%B2%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E7%9C%8B">https://www.cnblogs.com/question-sky/p/6953315.html，这篇文章讲相关内容，可以看看</a></p><p>component-scan是一个context命名空间下的自定义标签，最终对应他的命名空间处理器NamespaceHandler 和 解析器</p><p>查看spring-context包下的spring.handlers文件：ExtrrnalLibraries -&gt; Maven…:spring-context -&gt; META INF -&gt; spring.handlers</p><p>对应的是ComponentScanBeanDefinitionParser类，它内部的Parse方法会被解析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public BeanDefinition parse(Element element, ParserContext parserContext) &#123;</span><br><span class="line"></span><br><span class="line">//解析base-package属性值，扫描的包可以,;分隔</span><br><span class="line">String[] basePackages = StringUtils.tokenizeToStringArray(element.getAttribute(BASE_PACKAGE_ATTRIBUTE),ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);</span><br><span class="line"></span><br><span class="line">// Actually scan for bean definitions and register them.</span><br><span class="line">ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element);</span><br><span class="line"></span><br><span class="line">//通过ClassPathBeanDefinitionScanner扫描类来获取包名下的所有class并将他们注册到spring的bean工厂中</span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages);</span><br><span class="line"></span><br><span class="line">//注册其他注解组件</span><br><span class="line">registerComponents(parserContext.getReaderContext(), beanDefinitions, element);</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中doScan的源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123;</span><br><span class="line">//表明base-package属性是需要被指定的</span><br><span class="line">Assert.notEmpty(basePackages, &quot;At least one base package must be specified&quot;);</span><br><span class="line">Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet&lt;BeanDefinitionHolder&gt;();</span><br><span class="line">for (String basePackage : basePackages) &#123;</span><br><span class="line">//对每个基础包都进行扫描寻找并且对基础包下的所有class都注册为BeanDefinition</span><br><span class="line">                        /**</span><br><span class="line">                        **</span><br><span class="line">                        **并对得到的candidates集合进行过滤，此处便用到include-filters和exclude-filters</span><br><span class="line">                        */</span><br><span class="line">Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">for (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">//解析一个bean的scope属性，代表作用范围</span><br><span class="line">//prototype-&gt;每次请求都创建新的对象 singleton-&gt;单例模式，处理多请求</span><br><span class="line">ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">//使用beanName生成器生成</span><br><span class="line">String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);</span><br><span class="line">/**</span><br><span class="line">**对注册的bean进行另外的赋值处理，比如默认属性的配置</span><br><span class="line">*返回的candidate类型为ScannedGenericBeanDefinition，下面两者</span><br><span class="line">*条件满足</span><br><span class="line">*/</span><br><span class="line">if (candidate instanceof AbstractBeanDefinition) &#123;</span><br><span class="line">//设置lazy-init/autowire-code默认属性，从spring配置的&lt;beans&gt;节点属性读取</span><br><span class="line">postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">&#125;</span><br><span class="line">if (candidate instanceof AnnotatedBeanDefinition) &#123;</span><br><span class="line">//读取bean上的注解，比如`@Lazy`、`@Dependson`的值设置相应的属性</span><br><span class="line">AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">&#125;</span><br><span class="line">//查看是否已注册</span><br><span class="line">if (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">//默认采取cglib来做代理</span><br><span class="line">definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);</span><br><span class="line">beanDefinitions.add(definitionHolder);</span><br><span class="line">//**</span><br><span class="line">//注册bean信息到工厂中</span><br><span class="line">registerBeanDefinition(definitionHolder, this.registry);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return beanDefinitions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>源码用&#x2F;&#x2F;**标记，<code>registerBeanDefinition(definitionHolder, this.registry);</code>是真正实现注册的那一行</p><p>这个时候把注解标记内容加入BeanDefinitionMap，根据前面的后处理器和生命周期内容，我们可知，最总会产生相关的bean实例</p><h3 id="配置类方式"><a href="#配置类方式" class="headerlink" title="配置类方式"></a>配置类方式</h3><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109190337461.png" alt="image-20231109190337461"></p><p>AnnotationConfigApplicationContext容器在进行创建时，所有的有参构造方法第一步都是执行自己的无参构造方法</p><p>无参构造源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public AnnotationConfigApplicationContext() &#123;</span><br><span class="line">// 在执行此行代码之前, 先执行了父类的构造方法</span><br><span class="line">// 此段代码做的事情:</span><br><span class="line">// 1. 初始化bean工厂</span><br><span class="line">// 2. 初始化一个注解BeanDefinition读取器</span><br><span class="line">// 3. 将spring内置的6个类封装成RootBeanDefinition并注册到bean工厂, </span><br><span class="line">  this.reader = new AnnotatedBeanDefinitionReader(this);</span><br><span class="line"></span><br><span class="line">// 并没啥用, 虽然ClassPathBeanDefinitionScanner</span><br><span class="line">// 类的作用是扫描@ComponentScan注解提供的包路径。</span><br><span class="line">// 但实际上它并没有做扫描工作, spring内部扫描路径</span><br><span class="line">// 的时候, 是在内部新new了一个ClassPathBeanDefinitionScanner,</span><br><span class="line">// 这个属性目前没啥用, 当然我们可以获取这个对象</span><br><span class="line">// 调用它的scan方法, 但是没有必要! 因为</span><br><span class="line">// @ComponentScan可以支持多个扫描路径。 </span><br><span class="line">// 那这个类有什么用呢？跟刚刚的解释一样, </span><br><span class="line">// 我们可以自己new一个ClassPathBeanDefinitionScanner对象或者扩展他, </span><br><span class="line">// 利用它的扫描功能(因为它是使用ASM来扫描的)</span><br><span class="line">// Mybatis源码中就是自己扩展了</span><br><span class="line">// ClassPathBeanDefinitionScanner类</span><br><span class="line">  this.scanner = new ClassPathBeanDefinitionScanner(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="注解方式整合第三方框架"><a href="#注解方式整合第三方框架" class="headerlink" title="注解方式整合第三方框架"></a>注解方式整合第三方框架</h2><p>xml方式整合MyBatis，大致分为3步 3fenzhong</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置数据源--&gt;</span><br><span class="line">&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--配置SqlSessionFactoryBean--&gt;</span><br><span class="line">&lt;bean class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--配置Mapper包扫描--&gt;</span><br><span class="line">&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;basePackage&quot; value=&quot;com.itheima.dao&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>用配置方式替换</p><ol><li>使用@Bean将DataSource和SqlSessionFactoryBean存储到Spring容器中</li><li>MapperScannerConfigurer使用注解@MapperScan进行指明需要扫描的Mapper在哪个包下</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.itheima&quot;)</span><br><span class="line"></span><br><span class="line">//&lt;!--配置Mapper包扫描--&gt;</span><br><span class="line">@MapperScan(&quot;com.itheima.mapper&quot;)</span><br><span class="line">public class ApplicationContextConfig &#123;</span><br><span class="line"></span><br><span class="line">  //&lt;!--配置数据源--&gt;</span><br><span class="line">  @Bean</span><br><span class="line">  public DataSource dataSource()&#123;</span><br><span class="line">    DruidDataSource dataSource = new DruidDataSource();</span><br><span class="line">    //省略部分代码</span><br><span class="line">    return dataSource;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //&lt;!--配置SqlSessionFactoryBean--&gt;</span><br><span class="line">  @Bean</span><br><span class="line">  public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource)&#123;</span><br><span class="line">    SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();</span><br><span class="line">    sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">    return sqlSessionFactoryBean;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>yuanli 还没看</p><h2 id="Import整合三方框架"><a href="#Import整合三方框架" class="headerlink" title="@Import整合三方框架"></a>@Import整合三方框架</h2><p>@Import可以导入如下三种类：</p><ol><li>普通的配置类</li><li>实现ImportSelector接口的类</li><li>实现ImportBeanDefinitionRegistrar接口的类</li></ol>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC进程基础</title>
      <link href="/2023/11/04/JUC%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/11/04/JUC%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="进程与进程"><a href="#进程与进程" class="headerlink" title="进程与进程"></a>进程与进程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ul><li>程序由指令和数据组成，但是这些指令要运行， 数据要读写，就必须将指令加载到cpu，数据加载至内存。在指令运行过程中还需要用到磁盘，网络等设备，进程就是用来加载指令管理内存管理IO的</li><li>当一个指令被运行，从磁盘加载这个程序的代码到内存，这时候就开启了一个进程</li><li>进程就可以视为程序的一个实例，大部分程序都可以运行多个实例进程（例如记事本，浏览器等），部分只可以运行一个实例进程（例如360安全卫士）</li></ul><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul><li>一个进程之内可以分为一到多个线程。</li><li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行</li><li>Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作 为线程的容器（这里感觉要学了计算机组成原理之后会更有感觉吧！）</li></ul><h2 id="二者对比"><a href="#二者对比" class="headerlink" title="二者对比"></a>二者对比</h2><ul><li>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集</li><li>进程拥有共享的资源，如内存空间等，供其内部的线程共享</li><li>进程间通信较为复杂<ul><li>同一台计算机的进程通信称为 IPC（Inter-process communication）</li><li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP</li></ul></li><li>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量</li><li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</li></ul><h1 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h1><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>在单核 cpu 下，线程实际还是串行执行的。操作系统中有一个组件叫做任务调度器，将 cpu 的时间片（windows 下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于 cpu 在线程间（时间片很短）的切换非常快，人类感 觉是同时运行的 。一般会将这种线程轮流使用 CPU 的做法称为并发（concurrent）</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231104220315117.png" alt="image-20231104220315117"></p><h2 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h2><p>多核 cpu下，每个核（core） 都可以调度运行线程，这时候线程可以是并行的，不同的线程同时使用不同的cpu在执行。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231104220315117.png"></p><h2 id="二者对比-1"><a href="#二者对比-1" class="headerlink" title="二者对比"></a>二者对比</h2><p>引用 Rob Pike 的一段描述：并发（concurrent）是同一时间应对（dealing with）多件事情的能力，并行（parallel）是同一时间动手做（doing）多件事情的能力</p><ul><li>家庭主妇做饭、打扫卫生、给孩子喂奶，她一个人轮流交替做这多件事，这时就是并发</li><li>雇了3个保姆，一个专做饭、一个专打扫卫生、一个专喂奶，互不干扰，这时是并行</li><li>家庭主妇雇了个保姆，她们一起这些事，这时既有并发，也有并行（这时会产生竞争，例如锅只有一口，一 个人用锅时，另一个人就得等待）</li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="同步和异步的概念"><a href="#同步和异步的概念" class="headerlink" title="同步和异步的概念"></a>同步和异步的概念</h3><p>以调用方的角度讲，如果</p><ul><li>需要等待结果返回才能继续运行的话就是同步</li><li>不需要等待就是异步</li></ul><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>多线程可以使方法的执行变成异步的，比如说读取磁盘文件时，假设读取操作花费了5秒，如果没有线程的调度机制，这么cpu只能等5秒，啥都不能做。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程</li><li>tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞 tomcat 的工作线程</li><li>ui 程序中，开线程进行其他操作，避免阻塞 ui 线程</li></ul><h1 id="java线程"><a href="#java线程" class="headerlink" title="java线程"></a>java线程</h1><h2 id="创建和运行线程"><a href="#创建和运行线程" class="headerlink" title="创建和运行线程"></a>创建和运行线程</h2><div class="tabs" id="1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#1-1">Thread</button></li><li class="tab"><button type="button" data-href="#1-2">Runnable 配合 Thread</button></li><li class="tab"><button type="button" data-href="#1-3">FutureTask配合Thread</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 构造方法的参数是给线程指定名字，，推荐给线程起个名字</span><br><span class="line">Thread t1 = new Thread(&quot;t1&quot;) &#123;</span><br><span class="line"> @Override</span><br><span class="line"> // run 方法内实现了要执行的任务</span><br><span class="line"> public void run() &#123;</span><br><span class="line"> log.debug(&quot;hello&quot;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-2"><p>把线程和任务分开，Thread 代表线程，Runnable 可运行的任务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 创建任务对象</span><br><span class="line">Runnable task2 = new Runnable() &#123;</span><br><span class="line"> @Override</span><br><span class="line"> public void run() &#123;</span><br><span class="line"> log.debug(&quot;hello&quot;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 参数1 是任务对象; 参数2 是线程名字，推荐给线程起个名字</span><br><span class="line">Thread t2 = new Thread(task2, &quot;t2&quot;);</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure><p>把线程和任务分开了，用 Runnable 更容易与线程池等高级 API 配合，用 Runnable 让任务类脱离了 Thread 继承体系，更灵活。通过查看源码可以发现，方法二其实到底还是通过方法一执行的！</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-3"><p>FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况</p><pre><code>public static void main(String[] args) throws ExecutionException, InterruptedException {    // 实现多线程的第三种方法可以返回数据    FutureTask futureTask = new FutureTask&lt;&gt;(new Callable&lt;Integer&gt;() {        @Override        public Integer call() throws Exception {            log.debug(&quot;多线程任务&quot;);            Thread.sleep(100);            return 100;        }    });    // 主线程阻塞，同步等待 task 执行完毕的结果    new Thread(futureTask,&quot;我的名字&quot;).start();    log.debug(&quot;主线程&quot;);    log.debug(&quot;{}&quot;,futureTask.get());}</code></pre><p>Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface Future&lt;V&gt; &#123;</span><br><span class="line">    boolean cancel(boolean mayInterruptIfRunning);</span><br><span class="line">    boolean isCancelled();</span><br><span class="line">    boolean isDone();</span><br><span class="line">    V get() throws InterruptedException, ExecutionException;</span><br><span class="line">    V get(long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Future提供了三种功能：</p><ol><li>判断任务是否完成；</li><li>能够中断任务；</li><li>能够获取任务执行结果。</li></ol><p><a href="https://mp.weixin.qq.com/s/RX5rVuGr6Ab0SmKigmZEag">FutureTask是Future和Runable的实现</a></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="查看进程的方法"><a href="#查看进程的方法" class="headerlink" title="查看进程的方法"></a>查看进程的方法</h2><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><ul><li>任务管理器可以查看进程和线程数，也可以用来杀死进程</li><li>tasklist 查看进程</li><li>taskkill 杀死进程</li></ul><h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><ul><li>ps -fe 查看所有进程</li><li>ps -fT -p 查看某个进程（PID）的所有线程</li><li>kill 杀死进程</li><li>top 按大写 H 切换是否显示线程</li><li>top -H -p 查看某个进程（PID）的所有线程</li></ul><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><ul><li>ps 命令查看所有 Java 进程</li><li>jstack 查看某个 Java 进程（PID）的所有线程状态</li><li>jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</li></ul><h1 id="线程运行原理"><a href="#线程运行原理" class="headerlink" title="线程运行原理"></a>线程运行原理</h1><h2 id="虚拟机栈与栈帧"><a href="#虚拟机栈与栈帧" class="headerlink" title="虚拟机栈与栈帧"></a>虚拟机栈与栈帧</h2><p>虚拟机栈描述的是Java方法执行的内存模型.</p><p>每个方法被执行的时候都会同时创建一个栈帧(stack frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息，是属于线程的私有的。</p><p>当java中使用多线程时，每个线程都会维护它自己的栈帧！每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202311042044622.png"></p><h2 id="线程上下文切换（Thread-Context-Switch）"><a href="#线程上下文切换（Thread-Context-Switch）" class="headerlink" title="线程上下文切换（Thread Context Switch）"></a>线程上下文切换（Thread Context Switch）</h2><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p><ul><li>线程的 cpu 时间片用完(每个线程轮流执行，看前面并行的概念)</li><li>垃圾回收</li><li>有更高优先级的线程需要运行</li><li>线程自己调用了 <code>sleep</code>、<code>yield</code>、<code>wait</code>、<code>join</code>、<code>park</code>、<code>synchronized</code>、<code>lock</code> 等方法</li></ul><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念 就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</p><ul><li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li><li>Context Swich频繁发生会影响性能</li></ul><h1 id="Thread的常见方法"><a href="#Thread的常见方法" class="headerlink" title="Thread的常见方法"></a>Thread的常见方法</h1><table><thead><tr><th>方法名</th><th>static</th><th>功能说明</th></tr></thead><tbody><tr><td>start()</td><td>否</td><td>启动一个新线程，在新的线程运行run方法中的代码。<br>start方法只是让线程进入就绪，里面的代码不一定立刻运行（CUP的时间片还没有分给他）。每个线程对象的start方法只能调用一次，如果调用多次会出现illegalThreadStateException</td></tr><tr><td>run()</td><td>否</td><td>新线程启用后会调用的方法<br>如果在构造Thread对象时传递了Runnable参数，则线程启动后调用Runnable中的run方法，否则默认不执行任何操作。但可以穿件Thread的子类对象，来覆盖默认行为</td></tr><tr><td>join()</td><td>否</td><td>等待线程运行结束</td></tr><tr><td>join(long n)</td><td>否</td><td>等待线程运行结束，最多等待n毫秒</td></tr><tr><td>getId()</td><td>否</td><td>获取线程长整型的id。<br>id唯一</td></tr><tr><td>getName()</td><td>否</td><td>获取线程名</td></tr><tr><td>setName(String)</td><td>否</td><td>修改线程名</td></tr><tr><td>getPriority()</td><td>否</td><td>获取线程优先级</td></tr><tr><td>getPriority(int)</td><td>否</td><td>修改线程优先级<br>java中规定优先级是1~10的整数，比较大优先级能提高该线程被CPU调用的几率</td></tr><tr><td>getState()</td><td>否</td><td>获取线程状态<br> Java 中线程状态是用 6 个 enum 表示，分别为： NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED</td></tr><tr><td>isInterrupted()</td><td>否</td><td>判断是否被打断，不会清除 “打断标记”</td></tr><tr><td>isAlive()</td><td>否</td><td>线程是否存活 （还没有运行完 毕）</td></tr><tr><td>interrupt()</td><td>否</td><td>打断线程<br>如果被打断线程正在 sleep，wait，join 会导致被打断 的线程抛出 InterruptedException，并清除 打断标 记 ；如果打断的正在运行的线程，则会设置 打断标 记 ；park 的线程被打断，也会设置 打断标记</td></tr><tr><td>interrupted()</td><td>static</td><td>判断当前线程是 否被打断<br>会清除 打断标记</td></tr><tr><td>currentThread()</td><td>static</td><td>获取当前正在执 行的线程</td></tr><tr><td>sleep(long n)</td><td>static</td><td>让当前执行的线 程休眠n毫秒， 休眠时让出 cpu 的时间片给其它 线程</td></tr><tr><td>yield()</td><td>static</td><td>提示线程调度器 让出当前线程对 CPU的使用<br>主要是为了测试和调试</td></tr></tbody></table><h2 id="start-与-run"><a href="#start-与-run" class="headerlink" title="start 与 run"></a>start 与 run</h2><h4 id="调用start（能不能运行任务调度器说了算）"><a href="#调用start（能不能运行任务调度器说了算）" class="headerlink" title="调用start（能不能运行任务调度器说了算）"></a>调用start（能不能运行任务调度器说了算）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;我是一个新建的线程正在运行中&quot;</span>);</span><br><span class="line">            FileReader.read(fileName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    thread.setName(<span class="string">&quot;新建线程&quot;</span>);</span><br><span class="line">    thread.start();</span><br><span class="line">    log.debug(<span class="string">&quot;主线程&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：程序在 t1 线程运行， <code>run()</code>方法里面内容的调用是异步的 Test4.java</p><h4 id="调用run"><a href="#调用run" class="headerlink" title="调用run"></a>调用run</h4><p>将上面代码的<code>thread.start();</code>改为 <code>thread.run();</code>程序仍在 <strong>main 线程</strong>运行， <code>run()</code>方法里面内容的调用还是同步的</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>直接调用 <code>run()</code> 是在主线程中执行了 <code>run()</code>，没有启动新的线程 使用 <code>start()</code> 是启动新的线程，通过新的线程间接执行 <code>run()</code>方法 中的代码</p><p>当调用start方法后，线程状态会由“NEW”变为“RUNABLE”，此时再次调用start方法会报错 IllegalThreadStateException（非法的状态异常）</p><h2 id="sleep-与-yield"><a href="#sleep-与-yield" class="headerlink" title="sleep 与 yield"></a>sleep 与 yield</h2><h4 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h4><ol><li>调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞）</li><li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，那么被打断的线程这时就会抛出 <code>InterruptedException</code>异常【注意：这里打断的是正在休眠的线程，而不是其它状态的线程】</li><li>睡眠结束后的线程未必会立刻得到执行(需要分配到cpu时间片)</li><li>建议用 TimeUnit 的 <code>sleep()</code> 代替 Thread 的 <code>sleep()</code>来获得更好的可读性</li></ol><h4 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h4><ol><li>调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程</li><li>具体的实现依赖于操作系统的任务调度器(就是可能没有其它的线程正在执行，虽然调用了yield方法，但是也没有用)</li></ol><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>yield使cpu调用其它线程，但是cpu可能会再分配时间片给该线 ；而sleep需要等过了休眠时间之后才有可能被分配cpu时间片</p><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它 如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</p><h1 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h1><p>默认情况下，java进程需要等待所有的线程结束后才会停止，但是有一种特殊的线程，叫做守护线程，在其他线程全部结束的时候即使守护线程还未结束代码未执行完java进程也会停止。普通线程t1可以调用<code>t1.setDeamon(true);</code> 方法变成守护线程</p><blockquote><p>注意 垃圾回收器线程就是一种守护线程 Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等 待它们处理完当前请求</p></blockquote><h2 id="线程状态之五种状态"><a href="#线程状态之五种状态" class="headerlink" title="线程状态之五种状态"></a>线程状态之五种状态</h2><p>五种状态的划分主要是从操作系统的层面进行划分的</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202311042114047.png"></p><ol><li>初始状态，仅仅是在语言层面上创建了线程对象，即<code>Thead thread = new Thead();</code>，还未与操作系统线程关联</li><li>可运行状态，也称就绪状态，指该线程已经被创建，与操作系统相关联，等待cpu给它分配时间片就可运行</li><li>运行状态，指线程获取了CPU时间片，正在运行<ul><li>当CPU时间片用完，线程会转换至可运行状态，等待 CPU再次分配时间片，会导致我们前面讲到的上下文切换</li></ul></li><li>阻塞状态<ul><li>如果调用了阻塞API，如BIO读写文件，那么线程实际上不会用到CPU，不会分配CPU时间片，会导致上下文切换，进入阻塞状态</li><li>等待BIO操作完毕，会由操作系统唤醒阻塞的线程，转换至可运行状态</li><li>与可运行状态的区别是，只要操作系统一直不唤醒线程，调度器就一直不会考虑调度它们，CPU就一直不会分配时间片</li></ul></li><li>终止状态，表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</li></ol><h2 id="线程状态之六种状态"><a href="#线程状态之六种状态" class="headerlink" title="线程状态之六种状态"></a>线程状态之六种状态</h2><p>这是从 Java API 层面来描述的，这门课主要讲这种</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202311042116626.png"></p><ol><li>NEW 跟五种状态里的初始状态是一个意思</li><li>RUNNABLE 是当调用了 <code>start()</code> 方法之后的状态，注意，Java API 层面的 <code>RUNNABLE</code> 状态涵盖了操作系统层面的可运行状态、运行状态和io阻塞状态（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为是可运行）</li><li><code>BLOCKED</code> ， <code>WAITING</code> ， <code>TIMED_WAITING</code> 都是 Java API 层面对阻塞状态的细分</li><li>TERMINATED</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/2023/10/30/Linux%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/10/30/Linux%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Linux命令是一组用于在Linux操作系统上执行特定任务的命令。这些命令可以在终端窗口中使用，也可以通过脚本自动化执行。Linux命令可以用于管理文件和目录、安装和卸载软件、配置网络、查看系统状态等多种任务。在Linux中，命令通常由一个或多个单词组成，可以带有选项和参数，用于指定命令的行为和操作对象。Linux命令是Linux操作系统中的核心组件之一，掌握Linux命令可以帮助用户更好地管理和使用Linux系统。</p><h1 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h1><p><strong>基本介绍</strong></p><ol><li>man [命令|配置文件] ：获取该命令或配置文件的帮助信息，例如查看ls命令的帮助信息可以输入 man ls </li><li>help [命令]  ：获取Shell内置命令的帮助信息，例如 help cd 查看 cd 命令信息</li><li>–help ：一般所有的CLI程序都是命令和选项组成的，一般情况都有 –help 选项（有时候是 -h ），可以查看该命令及其选项将要说明</li></ol><div class="tabs" id="t1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#t1-1">man</button></li><li class="tab"><button type="button" data-href="#t1-2">help</button></li><li class="tab"><button type="button" data-href="#t1-3">--help</button></li><li class="tab"><button type="button" data-href="#t1-4">百度</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="t1-1"><p>man [命令|配置文件] ：获取该命令或配置文件的帮助信息，例如查看ls命令的帮助信息可以输入 man ls </p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="t1-2"><p>help [命令]  ：获取Shell内置命令的帮助信息，例如 help cd 查看 cd 命令信息</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="t1-3"><p> –help ：一般所有的CLI程序都是命令和选项组成的，一般情况都有 –help 选项（有时候是 -h ），可以查看该命令及其选项将要说明</p><blockquote><p>这个是后缀使用</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="t1-4"><p>面向百度编程</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="关机和重启"><a href="#关机和重启" class="headerlink" title="关机和重启"></a>关机和重启</h1><p><strong>基本介绍</strong></p><ol><li>shutdown -h now ：立刻关机</li><li>shutdown -h 数字n ：n分钟后关机</li><li>shutdown -r now ：立刻重启</li><li>shutdown -r 数字n ：n分钟后重启</li><li>halt ：关机，效果和 shutdown 一样，其实 -h 的 h 就是 halt</li><li>reboot ：立刻重启</li><li>sync ：将内存数据同步到磁盘</li></ol><p><strong>使用细节</strong></p><ol><li>不管关机还是重启，首先都应该运行 sync 命令，确保内存数据写入磁盘</li><li>目前的 shutdown | reboot | halt ，命令都已经在关机前进行了 sync ，但是以防万一，在生产环境建议至少手动执行一次 sync 。</li></ol><h1 id="用户登录和注销"><a href="#用户登录和注销" class="headerlink" title="用户登录和注销"></a>用户登录和注销</h1><p><strong>基本介绍</strong></p><ol><li>su - 用户名 ：切换用户，不填默认为切换root用户，等同于 su - root </li><li>logout ：注销用户</li></ol><p><strong>使用细节</strong></p><ol><li>logout 注销命令在图形运行级别无效（一般会提示 bash: logout: not login shell: use ‘exit’ ），在运行级别3（无界面终端）下有效</li><li>在Ubuntu中，第一次登录root用户时，可以使用 sudo su root ，输入用户密码切换到root用户，然后使用 passwd 修改密码，修改密码后面讲，这里有个坑</li><li>在一般情况下，我们登录时应该尽量不使用root（系统管理员）用户登录，因为其拥有最大权限，可能导致误操作。一般使用普通用户登录，需要时再使用 su root 切root用户</li></ol><h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><p>Linux系统是一个<strong>多用户多任务</strong>的操作系统，任何一个要使用系统资源的用户，都应该向系统管理员申请一个用户，然后使用该用户登录系统。下面我们会介绍一些系统管理员（root）用户用于管理用户的命令，这意味着这些命令有的必须拥有root用户权限才能执行</p><p>Root 只能有一个。</p><p>Root 用户能创建普通用户，每个用户创建的时候都有一个组，可以人为分配。默认是系统创建一个和他名字一样的组。<strong>每个用户都有自己的目录和权限</strong></p><h2 id="单用户"><a href="#单用户" class="headerlink" title="单用户"></a>单用户</h2><ul><li><p>添加用户</p><ol><li><p>useradd 新用户名 </p><p>创建用户，用户目录会自动创建在 &#x2F;home&#x2F;新用户名 </p></li><li><p>useradd -d 指定目录 新用户名</p></li></ol><p>   创建用户，用户目录会创建在 &#x2F;home&#x2F;指定目录 </p></li><li><p>修改密码</p><ol><li><p>passwd 用户名 </p><p>修改指定用户密码，如果不填用户名，会给当前用户设置密码。</p></li><li><p>passwd </p><p>改 Root 用户的密码，这就是前面的坑。别改错了</p></li></ol><blockquote><p>新密码是运行上面指令以后再输入</p></blockquote></li><li><p>删除用户</p><ol><li><p>userdel 用户名 </p><p>删除指定用户，但是保留其家目录（推荐）</p></li><li><p>userdel -r 用户名</p></li></ol><p>   删除指定用户及其用户目录（有风险）</p></li><li><p>切换用户</p><ol><li><p>su - 用户名</p><p>切用户</p><p>高权限切低权限不需要输密码，反过来需要。</p></li><li><p>exit&#x2F;logout</p><p>能切回高权限，切不用输密码</p><p>高权限切低权限后回来可以</p></li></ol></li><li><p>我是谁</p><ol><li>whoami</li></ol><p>   显示当前用户名</p><ol start="2"><li>who im i</li></ol><p>   显示当前终端的用户名、终端设备和登录时间等详细信息；</p></li></ul><p><strong>细节说明</strong></p><ol><li>passwd 修改密码命令，root用户在修改其他用户密码，如果忘记填写要修改的用户名，会修复当前root用户密码，这在生产环境中会导致很严重的后果</li><li>一般情况下，我们删除用户不会使用 userdel -r ，因为往往用户目录下仍有重要的数据，非必要应该保留该用户目录</li><li>root用户用 useradd 创建完用户后，系统会自动切换到新用户的目录；可以通过 su root 切换回root用户；root用户也可以使用 exit 或者 logout 切换回原用户</li><li>who am i 这条命令，本人实测必须在图形运行级别是无效的，假如你刚好和我一样使用的Ubuntu图形界面系统，可以使用 ctrl + alt + f5 进入运行级别3无界面终端进行测试。</li></ol><h2 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h2><ol><li>用户组概念说明：<ul><li>在Linux中，用户组是一组具有相同权限和访问权限的用户的集合。每个用户都必须属于至少一个用户组。</li><li>用户组可以用于管理文件和目录的访问权限，以及限制用户对系统资源的访问。</li><li>在Linux中，每个用户都有一个主组和多个附加组。用户的主组是在创建用户时指定的，而附加组是可以随时添加或删除的</li></ul></li><li>假如我们在创建用户时没有指定组，Linux会自动创建一个与用户名同名的组，然后将该用户指定到该同名组下</li></ol><ul><li><p>创建用户组：groupadd 组名</p></li><li><p>删除用户组：groupdel 用户组 </p></li><li><p>创建一个用户并指定用户组：useradd -g 用户组 新用户名 </p></li><li><p>修改用户的用户组：usermod -g 用户组 用户名 </p><blockquote><p>组就像户口，改了原来的就没了</p></blockquote></li></ul><p><strong>扩展</strong></p><p>用户和用户组相关文件：</p><ol><li><p>&#x2F;etc&#x2F;passwd</p><p>文件：</p><ul><li>解释：用户（user）的配置文件，记录用户的各种信息</li><li>内容： 用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录使用的Shell </li><li>示例： gallifrey:x:1000:1000:gallifrey display:&#x2F;home&#x2F;gallifrey:&#x2F;bin&#x2F;bash</li></ul></li><li><p>&#x2F;etc&#x2F;shadow</p><p>文件：</p><ul><li>解释：口令的配置文件</li><li>内容： 登录名:加密口令:最后修改时间:最小时间间隔:最大时间间隔:告警时间:不活动时间:失效时间:标志 </li><li>示例： mail:*:19411:0:99999:7:::</li></ul></li><li><p>&#x2F;etc&#x2F;group</p><p>文件：</p><ul><li>解释：组（group）的配置文件，</li><li>内容： 组名:口令:组标识号：组内用户列表 </li><li>示例： sambashare x:136:gallifrey</li></ul></li></ol><h1 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h1><p><strong>基本介绍</strong></p><p>运行级别的说明：</p><table><thead><tr><th>运行级别</th><th>使用频率</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>不常用</td><td>关机，系统停机状态，系统已关闭，没有任何服务或进程运行</td></tr><tr><td>1</td><td>不常用<br/>但是可用于找回丢失密码，后面示范</td><td>单用户模式，只有最基本的系统服务和进程运行，没有网络服务</td></tr><tr><td>2</td><td>不常用<br/>因为无网络服务</td><td>多用户模式，无网络服务</td></tr><tr><td>3</td><td>常用<br/>无图形界面节省资源，且多用户有网络服务，基本服务器都是该运行级别</td><td>多用户模式，有网络服务</td></tr><tr><td>4</td><td>不常用</td><td>保留级别，系统未使用</td></tr><tr><td>5</td><td>常用<br>个人使用的Linux系统，基本都会使用图形界面</td><td>图形用户界面，多用户模式，有网络服务</td></tr><tr><td>6</td><td>不常用</td><td>系统重启模式，用于重新启动系统。</td></tr></tbody></table><p>命令：</p><ol><li><p>init[0-6] ：切换运行级别0-6，例如 init 3 就是切换到运行级别3</p></li><li><p>who -r 或 runlevel ：可以查看当前的运行级别</p></li><li><p>systemctl get-default ：可以查看系统默认的运行级别</p></li></ol><p>   其中 multi-user.target 就是运行级别3</p><p>   graphical.target 就是运行级别5</p><ol start="4"><li>systemctl set-default [multi-user.target|graphical.target] ：设置运行级别3或5</li></ol><p><strong>细节说明</strong></p><ol><li><p>实际上CentOs7及之后的版本，采用了systemd作为系统初始化和管理的工具，对运行级别进行了简化。</p></li><li><p>systemd为了简化运行级别的管理，将所有的运行级别都映射到了不同的target中。</p><p> multi-user.target 代表的是文本模式下的多用户运行级别（运行级别3）</p><p>graphical.target 代表的是图形化界面下的多用户运行级别（运行级别5）</p></li><li><p>Ubuntu 15.04及更高版本已经使用了systemd来管理系统服务和运行级别。</p></li><li><p>在 &#x2F;lib&#x2F;systemd&#x2F;system 目录下可以看到可以指定运行级别的所有的target</p></li></ol><h2 id="找回密码示范"><a href="#找回密码示范" class="headerlink" title="找回密码示范"></a>找回密码示范</h2><h1 id="文件目录（最常用）"><a href="#文件目录（最常用）" class="headerlink" title="文件目录（最常用）"></a>文件目录（最常用）</h1><p><strong>基本介绍</strong></p><ol><li><p>pwd ：显示当前用户所在目录路径</p></li><li><p>cd 指定目录 ：切换到指定目录</p></li></ol><ul><li>cd ~ ：回到根目录，普通用户所在的用户目录，一般是 &#x2F;home&#x2F;用户名 ，root用户则是 &#x2F;root </li><li>cd .. ：返回上一级目录</li></ul><ol start="3"><li>ls 指定路径 ：列出指定路径目录的内容</li></ol><ul><li>ls -a ：列出当前目录的所有内容，包括以 . 开头的隐藏文件</li><li>ls -l ：列出当前目录的内容，单列输出详细内容</li><li>ls -al ：上面两个的组合</li><li>ls -h ：列出当前目录的内容，显示更符合人类习惯（文件大小显示从字节显示变为自适应单位）</li></ul><ol start="4"><li>mkdir 指定一级目录 ：创建一个一级目录，如 mkdir dog 在创建一个名为 dog 的目录</li></ol><ul><li>mkdir 指定路径指定目录 ：在指定路径创建一个目录，如 mkdir .&#x2F;dog 在当前目录创建 dog 目录， mkdir &#x2F;home&#x2F;用户目录&#x2F;dog 在用户目录下创建 dog 目录</li><li>mkdir -p 多级目录 ：创建多级目录，如 mkdir .&#x2F;animal&#x2F;dog 在当前目录创建 animal 目录，再在 animaml 目录下创建 dog 目录</li></ul><ol start="5"><li>rm 文件 ：删除文件</li></ol><ul><li>rmdir ：删除空目录</li></ul><pre><code> 注意：只能删除空目录，命令中间没有空格</code></pre><ul><li>rm -rf 目录 ：删除整个目录，</li></ul><pre><code> -f 是强制删除不提示 -r 是递归删除，就是强制递归删除所有文件</code></pre><ol start="6"><li><p>touch 文件名 ： 创建指定文件名的空文件，然后 touch &#x2F;home&#x2F;用户目录&#x2F;cat 就是在用户目录创建名为 cat 空文件</p></li><li><p>cp 原文件 目标路径 ：将原文件拷贝到目标路径下，例如 cp duck animal&#x2F; 就是将 duck 文件拷贝到 animal 目录下</p></li></ol><ul><li>cp -r 原目录 目标路径 ：将原目录递归拷贝到目标路径下，例如 cp -r animal zoo&#x2F; 就是将 animal 目录及其所有内容拷贝到 zoo 目录下</li><li>\cp -r 原目录 目标路径 ：将原目录递归拷贝到目标路径下，覆盖不提示</li></ul><ol start="8"><li>mv ：移动文件及重命名</li></ol><ul><li>mv 旧文件名 新文件名 ：在两个文件在同一个目录下执行 mv ，其实就是重命名文件，例如 mv anmail&#x2F;dog animal&#x2F;cat 就是把 animal 目录下 dog 文件重命名为 cat </li><li>mv 旧文件路径 新文件路径 ：当两个文件不在同一个路径下执行 mv ，可以移动文件（也可以重命名）例如 mv animal&#x2F;cat ctiy&#x2F;bat 将 animal 目录下的 cat 移动到 city 目录下并重命名为 bat</li></ul><ol start="9"><li>cat 文件名 ：查看文件内容</li></ol><ul><li>cat -n 文件名 ：查看文件内容，带上行号</li><li>cat 文件名 | more ：一般为了浏览方便，会加上 | more 使用 more  文本过滤器， | 是管道符号， more 的说明请看下面</li></ul><ol start="10"><li><pre><code>more</code></pre><p>：基于Vi编辑器的文本过滤器命令，可以以全屏的方式按页显示文本内容。</p><ul><li>除了常常和 cat 联用，也能直接 more 文件名 来查看文件</li><li>其内置了若干快捷键用于浏览操作，详情请看下表：</li></ul></li></ol><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>空格  Space</td><td>下翻一页</td></tr><tr><td>回车  Enter</td><td>下翻一行</td></tr><tr><td>q</td><td>退出</td></tr><tr><td>Ctrl + F</td><td>向下滚动一屏</td></tr><tr><td>Ctrl + B</td><td>向上滚动一屏</td></tr><tr><td>&#x3D;</td><td>输出当前行的行号</td></tr><tr><td>:f</td><td>输出文件名和当前行的行号</td></tr></tbody></table><ol><li>less ：文本查阅工具，功能与 more 类似，但是更加强大，支持各种显示终端，查找操作，而且是懒加载，大文件打开更快，效率更高。</li></ol><ul><li>使用方法 less 文件名 ，查看文件</li><li>其内置了若干快捷键用于浏览操作，详情请看下表：</li></ul><table><thead><tr><th align="left">操作</th><th>说明</th></tr></thead><tbody><tr><td align="left">空格  Space</td><td>下翻一页</td></tr><tr><td align="left">下箭头 pagedown</td><td>下翻一页</td></tr><tr><td align="left">上箭头 pageup</td><td>上翻一页</td></tr><tr><td align="left">&#x2F;字符串</td><td>搜索 字符串 ， n 上一个， N 下一个</td></tr><tr><td align="left">?字符串</td><td>搜索 字符串 ， n 上一个， N 下一个</td></tr><tr><td align="left">q</td><td>退出</td></tr></tbody></table><ol><li>echo ：输出命令</li></ol><ul><li>echo $PATH ：输出环境变量</li><li>echo hello world! ：输出 hello wrold！ 到控制台</li><li>echo hello world!&gt;&gt;learn.txt ：追加 hello world 文本到 learn.txt 文件中</li></ul><ol start="2"><li>head -n 数字x 文件名 ：查看指定文件头部x行数据，如果直接 head 文件名 ，会默认显示前面10行数据</li><li>tail -n 数字x 文件名 ：查看指定文件尾部x行数据，如果直接 tail 文件名 ，会默认显示最后10行数据</li></ol><ul><li>tail -f 文件名 ：实时监控文件尾部，如果有追加就会显示</li></ul><ol start="4"><li><blockquote><p>：输出重定向（覆盖写），示例如下</p></blockquote></li></ol><ul><li>ls -l &gt; nowdir.log ：将该目录下内容覆盖写入 nowdir.log 文件</li><li>cat pig.txt &gt; dog.txt ：将 pig.txt 文件内容覆盖写入 dog.txt 文件</li><li>如果重定向的文件不存在会自动创建再写入</li></ul><ol start="5"><li><blockquote><blockquote><p>：输出重定向（追加写），示例如下</p></blockquote></blockquote></li></ol><ul><li>cal &gt;&gt; today.log ：将当前日历信息追加写入 today.log 文件，注意： cal 是CentOs自带输出日历信息的命令，其他linux版本可能没有</li><li>cat pig.txt &gt;&gt; dog.txt ：将 pig.txt 文件内容追加写入 dog.txt 文件</li><li>如果重定向的文件不存在会自动创建再写入</li></ul><ol start="6"><li>ln ：软连接，相对于Windows中的快捷方式</li></ol><ul><li>ln -s &#x2F;root &#x2F;home&#x2F;myroot ：在 home 目录下创建 myroot 目录，进入该目录会进入 root 目录</li><li>删除软链接使用 rm 命令删除 软链接目录 就也可以了</li></ul><ol start="7"><li>history [数字n] ：查看最近执行过的n条命令（附带编号），不添加数字时，默认显示最近执行过的10条命令。</li><li>!数字n ：执行编号为 数字n 的命令，比如 history 1 查出来的最近执行过的1条命令记录是 383 ls -a ，此时输入 !383 就会执行 ls -a</li></ol><h1 id="时间日期"><a href="#时间日期" class="headerlink" title="时间日期"></a>时间日期</h1><h2 id="查看时间"><a href="#查看时间" class="headerlink" title="查看时间"></a>查看时间</h2><ol><li><p>date：显示当前时间</p></li><li><p>date “+指定时间格式” ：按指定时间格式显示日期，如 date “+%Y-%m-%d %H:%M:%S” ，会按照 年-月-日 时:分:秒 格式输出当前时间</p></li></ol><blockquote><p>年、月、日可以单独显现</p></blockquote><ol start="3"><li><p>cal ：显示当前月月历</p></li><li><p>cal 年份 ：显示指定年份所有月历</p></li></ol><h2 id="修改时间"><a href="#修改时间" class="headerlink" title="修改时间"></a>修改时间</h2><p>date -s “%Y-%m-%d %H:%M:%S” ：设置系统当前时间，如 date “2099-2-25 12:21:21” </p><blockquote><p>时间是字符串格式，即用””引用</p></blockquote><p><strong>细节说明</strong></p><ol><li>date “+指定时间格式” ，时间格式并不是一定要完整的，你可以指定任意格式的时间显示，如 date “+%Y %m” 只显示年份和月份， date “+%D—%D” 显示当前天数中间两次用 — 链接</li><li>cal 是CentOs自带输出日历信息的命令，其他linux版本可能没有，像Ubuntu默认没有 cal 命令</li></ol><h1 id="搜索查找"><a href="#搜索查找" class="headerlink" title="搜索查找"></a>搜索查找</h1><p><strong>基本介绍</strong></p><ol><li><p>find [搜索范围] [选项] 查询内容</p><p>搜索命令，可以按照文件名，用户，文件大小等条件搜索</p><ul><li>find [搜索范围] -n 文件名</li></ul><p>  按照文件名搜索文件，如 find &#x2F;home dog.txt 就是在 home 目录下搜索 dog.txt 文件</p><ul><li>find [搜索范围] -user 用户名</li></ul><p>  按照用户名搜索文件，如 find -user pig 就是搜索所有用户为 pig 的文件</p><ul><li>find [搜索范围] -size 数字n</li></ul><p>  搜索指定文件大小为 n 的文件，其中 +数字n 表示大于 n ， -数字n 表示小于 n ，单位有 k ， M ， G 。如 find &#x2F; -size +1G 就是搜索根目录下大于 1G 的文件</p></li><li><p>locate 文件名 ：快速定位文件路径</p></li></ol><p>   Linux中自己构建了数据库，帮助快速查找，但是这玩意不一定准</p><ol start="3"><li><p>updatedb ：更新locate数据库，root用户才有权限更新，保证上面那个</p></li><li><p>which 命令 ：用于查找命令的二进制文件位置，如 which ls 就是查找 ls 命令的程序位置</p></li><li><p>| ：管道符号，用于将前一个命令的结果传输给后面的命令处理，如上文中的 cat 文件名 | more </p></li><li><p>grep [选项] 查询内容 源文件</p><p>：过滤查找要压缩的文件[</p><ul><li>grep -n 查询内容 源文件 ：过滤查找，显示行号</li><li>grep -i 查询内容 源文件 ：过滤查找，忽略大小写</li><li>grep 常与 | 管道符号一起使用，查询文本内容，如 cat bird.txt | gerp -i “hello” ：查看 bird.txt 文本并查询 hello 忽略大小写</li></ul></li></ol><p><strong>细节说明</strong></p><ol><li>find 命令是递归搜索文件目录</li><li>locate 命令与 find 不同，它不会递归搜索文件目录， locate 命令利用建立好的locate数据库去搜索文件路径。locate数据库会保存系统所有的文件名称及其路径。因此第一次运行 locate 前得先执行 updatedb 命令</li><li>locate 因为查询数据库，所以比直接遍历文件系统快很多，但是为了保证数据准确性，root用户必须定期更新locate数据库</li><li>乌班图系统是默认没有 locate 命令的，可以使用 sudo apt install mlocate 来安装</li></ol><h2 id="压缩解压"><a href="#压缩解压" class="headerlink" title="压缩解压"></a>压缩解压</h2><p><strong>基本介绍</strong></p><ul><li>打包：是将多个文件和目录组合成一个单独的文件，以便于传输、备份或存档</li><li>压缩：是指通过使用特定的算法和技术，将文件或数据转换为较小的尺寸，以节省存储空间或减少数据传输所需的带宽</li></ul><p>生产压缩包其实包含了两个过程，将多个文件打包成一个包，然后再把包用压缩程序压缩成压缩包</p><p><strong>tar命令</strong></p><p> tar 是最常用的打包命令，使用  tar  程序打出来的包我们常称为 tar 包，tar 包文件的命令通常都是以  .tar 结尾的。生成 tar 包后，就可以用其它的程序来进行压缩了。常见的压缩程序有以下几种：</p><ol><li>gzip 是 GNU 组织开发的一个压缩程序， .gz  结尾的文件就是 gzip 压缩的结果。与 gzip 相对的解压程序是 gunzip。tar 中使用  -z  这个参数来调用gzip</li><li>bzip2 是一个压缩能力更强的压缩程序， .bz2  结尾的文件就是 bzip2 压缩的结果。与 bzip2 相对的解压程序是 bunzip2。tar 中使用 -j 这个参数来调用 bzip2。</li><li>compress 也是一个压缩程序，但是比较冷门。与 compress 相对的解压程序是 uncompress。 .Z  结尾的文件就是 bzip2 压缩的结果。tar 中使用 -Z  这个参数来调用 compress。</li></ol><p><strong>选项</strong></p><p> tar 常见选项如下</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-c</td><td>产生 .tar 打包文件</td></tr><tr><td>-x</td><td>解包 .tar 文件</td></tr><tr><td>-v</td><td>显示详细信息</td></tr><tr><td>-t</td><td>列出包中所有内容</td></tr><tr><td>-f</td><td>这个选项是必须的，指定操作涉及的文件名</td></tr><tr><td>-z</td><td>调用 giz，文件后缀是 .gz</td></tr><tr><td>-j</td><td>调用 bzip2，文件后缀是 .bz2</td></tr><tr><td>-Z</td><td>调用 compress，文件后缀是 .Z</td></tr></tbody></table><p><strong>示例</strong></p><p>其实选项顺序是没有固定写法的，但是如果你和我一样有选择困难症，可能参考将压缩程序的选项放在最前面的写法：</p><ol><li>tar -zcvf zoo.tar.gz dog bat pig ：打包 dog , bat , pig 文件并用gzip压缩，生产压缩包 zoo.tar ，显示详细信息</li><li>tar -zxvf zoo.tar.gz ：解压 zoo.tar.gz 压缩包并解包，显示详细信息</li><li>tar -cxf zoo.tar dog bat pig ：打包 dog , bat , pig 文件，生成tar包 zoo.tar </li><li>tar -xvf zoo.tar ：解包文件 zoo.tar</li></ol><p>举一反三就有 tar -jcvf ， tar -jxvf ， tar -Zcvf 和 tar -Zxvf 等等</p><p><strong>更多</strong></p><p>在Windows中，我们更多会使用 .rar 和 .zip 为后缀的压缩包，在Linux系统要生成或者解压这些压缩包，我们可以使用 zip 和 unzip ， rar 和 unrar 命令。但是zip和rar程序在不同Linux系统中不一定自带的，可能需要我们自行安装</p><p>另外 zip 和 unzip ， rar 和 unrar 直接执行是包括【打包】和【压缩】或者【解包】和【解压】两个动作的，一般用法如下：</p><ol><li>rar a jpg.rar *.jpg ：rar格式的压缩，需要先下载 rar for linux 压缩打包目录里所有jpg文件</li><li>zip jpg.zip *.jpg ：zip格式的压缩，需要先下载 zip for linux 压缩打包目录里所有jpg文件</li><li>unrar e a.rar ：解压 rar</li><li>unzip jpg.zip ：解压 zip</li></ol><p>更多使用方法，请自行 man 查阅帮助文档或 –help 查看选项简要说明</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java关键字</title>
      <link href="/2023/10/28/Java%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2023/10/28/Java%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p>java中共：</p><ul><li>48个关键字</li><li>2个保留字（现在没用以后可能用到作为关键字）：goto、const。</li><li>3个特殊直接量：true、false、null</li></ul><p>合53个</p><table><thead><tr><th align="left">分类</th><th>关键字</th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td align="left">访问控制</td><td>private</td><td>protected</td><td>public</td><td></td><td></td><td></td><td></td></tr><tr><td align="left">类，方法和变量修饰符</td><td>abstract</td><td>class</td><td>extends</td><td>final</td><td>implements</td><td>interface</td><td>native</td></tr><tr><td align="left"></td><td>new</td><td>static</td><td>strictfp</td><td>synchronized</td><td>transient</td><td>volatile</td><td>enum</td></tr><tr><td align="left">程序控制</td><td>break</td><td>continue</td><td>return</td><td>do</td><td>while</td><td>if</td><td>else</td></tr><tr><td align="left"></td><td>for</td><td>instanceof</td><td>switch</td><td>case</td><td>default</td><td>assert</td><td></td></tr><tr><td align="left">错误处理</td><td>try</td><td>catch</td><td>throw</td><td>throws</td><td>finally</td><td></td><td></td></tr><tr><td align="left">包相关</td><td>import</td><td>package</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td align="left">基本类型</td><td>boolean</td><td>byte</td><td>char</td><td>double</td><td>float</td><td>int</td><td>long</td></tr><tr><td align="left"></td><td>short</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td align="left">变量引用</td><td>super</td><td>this</td><td>void</td><td></td><td></td><td></td><td></td></tr><tr><td align="left">特殊直接量</td><td>true</td><td>false</td><td>null</td><td></td><td></td><td></td><td></td></tr><tr><td align="left">保留字</td><td>goto</td><td>const</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h1 id="访问权限控制（3个）"><a href="#访问权限控制（3个）" class="headerlink" title="访问权限控制（3个）"></a>访问权限控制（3个）</h1><p>访问修饰符的关键字共3个（或者4个），用于控制方法和属性（成员变量）的访问权限（范围）</p><ul><li>公开级别：<code>public</code>，对外公开。</li><li>受保护级别：<code>protected</code>，对 子类 和 同一个包中的类 公开。</li><li>默认级别：没有修饰符号，向 同一个包的类 公开。</li><li>私有级别：<code>private</code>，只有 自己 可以访问，不对外公开。</li></ul><table><thead><tr><th></th><th align="center">private</th><th align="center">默认（无修饰符）</th><th align="center">protected</th><th align="center">public</th></tr></thead><tbody><tr><td>本类</td><td align="center">可</td><td align="center">可</td><td align="center">可</td><td align="center">可</td></tr><tr><td>同包中的子类</td><td align="center">不可以</td><td align="center">可</td><td align="center">可</td><td align="center">可</td></tr><tr><td>同包的非子类</td><td align="center">不可以</td><td align="center">可</td><td align="center">可</td><td align="center">可</td></tr><tr><td>其他包的子类</td><td align="center">不可以</td><td align="center">不可以</td><td align="center">可</td><td align="center">可</td></tr><tr><td>其他包的非子类</td><td align="center">不可以</td><td align="center">不可以</td><td align="center">不可以</td><td align="center">可</td></tr></tbody></table><p>使用说明：</p><ol><li>修饰符可以修饰类中的 属性、成员方法 及 类</li><li>只有 默认 和 <code>public</code> 才能修饰 类，并遵循上述访问权限特点</li><li>成员方法 的访问规则和 属性 相同</li><li>private 修饰的变量可以被 任意本对象同类的对象访问</li></ol><h1 id="定义、实例化（6个）"><a href="#定义、实例化（6个）" class="headerlink" title="定义、实例化（6个）"></a>定义、实例化（6个）</h1><table><thead><tr><th>关键字</th><th>用途</th><th>备注，常用</th></tr></thead><tbody><tr><td>class</td><td>定义类</td><td>public class A(){ } <br>花括号里有已实现方法体，类名需要与文件名相同</td></tr><tr><td>interface</td><td>定义接口</td><td>public interface B(){ } <br/>花括号里有方法体，但没有实现，方法体句子后面是英文分号“:”结尾</td></tr><tr><td>abstract</td><td>声明抽象</td><td>public abstract class C(){} <br/>介于类与接口中间，可以有也可以没有已经实现的方法体</td></tr><tr><td>implements</td><td>实现</td><td>public class A interface B(){}<br/>用于类或接口实现接口</td></tr><tr><td>extends</td><td>继承</td><td>用于类继承类<br/> public class A extends D(){}</td></tr><tr><td>new</td><td>创建新对象</td><td>A a&#x3D;new A(); A表示一个类</td></tr><tr><td>enum</td><td>定义一个枚举类</td><td>定义一个枚举类<br>public enum SexEnum { <br>male, female;  <br/>}</td></tr></tbody></table><h1 id="包（2个）"><a href="#包（2个）" class="headerlink" title="包（2个）"></a>包（2个）</h1><table><thead><tr><th>关键字</th><th>用途</th><th>备注，常用</th></tr></thead><tbody><tr><td>import</td><td>引入包的关键字</td><td>当使用某个包的一些类时，仅需类名 然后使用ctrl+shift+o或者选定类名（类或属性或方法）按住ctrl+单击 即可自动插入类所在的包。<br>import javax.swing.JFrame;</td></tr><tr><td>package</td><td>定义包的关键字</td><td>将所有有关的类放在一个包类以便查找修改等。<br/>package javake.flycat.draw002;</td></tr></tbody></table><h1 id="数据类型（12个）"><a href="#数据类型（12个）" class="headerlink" title="数据类型（12个）"></a>数据类型（12个）</h1><table><thead><tr><th>关键字</th><th>用途</th><th>备注，常用</th></tr></thead><tbody><tr><td>byte</td><td>字节型</td><td>8bit</td></tr><tr><td>char</td><td>字符型</td><td>16bit</td></tr><tr><td>boolean</td><td>布尔型</td><td>理论上1bit就行，但按最小分配单位给，一般 8bit</td></tr><tr><td>short</td><td>短整型</td><td>16bit</td></tr><tr><td>int</td><td>整型</td><td>32bit</td></tr><tr><td>float</td><td>浮点型</td><td>32bit</td></tr><tr><td>long</td><td>长整型</td><td>64bit</td></tr><tr><td>double</td><td>双精度</td><td>64bit</td></tr><tr><td>void</td><td>无返回</td><td>public void A(){}  其他需要返回的经常与return连用</td></tr><tr><td>null</td><td>空值</td><td></td></tr><tr><td>true</td><td>真</td><td>java中不能用 1 表示真，但是底层还是用 1 实现的。。</td></tr><tr><td>false</td><td>假</td><td>java中不能用 0 表示假，但是底层还是用 0 实现的。。</td></tr></tbody></table><h1 id="流程控制（12个）"><a href="#流程控制（12个）" class="headerlink" title="流程控制（12个）"></a>流程控制（12个）</h1><table><thead><tr><th>关键字</th><th>意思</th><th>备注，常用</th></tr></thead><tbody><tr><td>if</td><td>如果</td><td>if(){} 如果小括号里面怎么怎么样 花括号就怎么怎么样</td></tr><tr><td>else</td><td>否则，或者</td><td>常与if连用，用法相同</td></tr><tr><td>while</td><td>当什么的时候</td><td>while 怎么样就do什么  while(){}</td></tr><tr><td>for</td><td>满足三个条件时</td><td>for ( 条件变量 ;循环参数 ;变量改变 ){}</td></tr><tr><td>switch</td><td>开关</td><td>switch(表达式)<br/>{<br/>case 常量表达式1:语句;<br/>break<br/>case 常量表达式2:语句;<br/>break<br/>default:语句;<br/>}<br/>default就是如果没有符合的case就执行它,default并不是必须的.<br/>case后的语句可以不用大括号.<br/>switch语句的判断条件可以接受int,byte,char,short,不能接受其他类型.</td></tr><tr><td>case</td><td>返回开关里的结果</td><td></td></tr><tr><td>default</td><td>默认</td><td></td></tr><tr><td>do</td><td>运行</td><td>常与while连用</td></tr><tr><td>break</td><td>跳出循环</td><td></td></tr><tr><td>continue</td><td>继续</td><td>中断本次循环，并并开始下一次</td></tr><tr><td>return</td><td>返回</td><td>return 一个返回值类型</td></tr><tr><td>instanceof</td><td>实例</td><td>一个二元操作符，和&#x3D;&#x3D;，&gt;，&lt;是同一类的。测试它左边的对象是否是它右边的类的实例，返回boolean类型的数据</td></tr></tbody></table><h1 id="修饰方法、类、属性和变量（9个）"><a href="#修饰方法、类、属性和变量（9个）" class="headerlink" title="修饰方法、类、属性和变量（9个）"></a>修饰方法、类、属性和变量（9个）</h1><table><thead><tr><th>关键字</th><th>意思</th><th>备注，常用</th></tr></thead><tbody><tr><td>static</td><td>静态的</td><td>属性和方法都可以用static修饰，直接使用类名.属性和方法名。 只有内部类可以使用static关键字修饰，调用直接使用类名.内部类类名进行调用。  static可以独立存在。静态块</td></tr><tr><td>final</td><td>最终的不可被改变的</td><td>方法和类都可以用final来修饰  final修饰的类是不能被继承的  final修饰的方法是不能被子类重写。常量的定义：final修饰的属性就是常量。</td></tr><tr><td>super</td><td>调用父类的方法</td><td>常见<strong>public</strong> <strong>void</strong> paint(Graphics g){<strong>super</strong>.paint(g); ··· }</td></tr><tr><td>this</td><td>当前类的父类的对象</td><td>调用当前类中的方法（表示调用这个方法的对象）this.addActionListener(al):等等</td></tr><tr><td>native</td><td>本地</td><td>声明本地方法（实现底层功能的方法）</td></tr><tr><td>strictfp</td><td>严格,精准</td><td></td></tr><tr><td>synchronized</td><td>线程,同步</td><td></td></tr><tr><td>transient</td><td>短暂</td><td></td></tr><tr><td>volatile</td><td>易失</td><td></td></tr></tbody></table><h1 id="异常处理（5个）"><a href="#异常处理（5个）" class="headerlink" title="异常处理（5个）"></a>异常处理（5个）</h1><table><thead><tr><th>关键字</th><th>意思</th><th>备注，常用</th></tr></thead><tbody><tr><td>try</td><td>捕获异常</td><td></td></tr><tr><td>catch</td><td>处理异常</td><td>1.try+catch<br/>程序的流程是：运行到try块中，如果有异常抛出，则转到catch块去处理。然后执行catch块后面的语句<br/><br/>2.try+catch+finally<br/>程序的流程是：运行到try块中，如果有异常抛出，则转到catch块,catch块执行完毕后，执行finally块的代码，再执行finally块后面的代码。<br/>如果没有异常抛出，执行完try块，也要去执行finally块的代码。然后执行finally块后面的语句<br/><br/>3.try+finally<br/>程序的流程是：运行到try块中,如果有异常抛出的话，程序转向执行finally块的代码。那末finally块后面的代码还会被执行吗？不会！因为你没有处理异常，所以遇到异常后，执行完finally后，方法就已抛出异常的方式退出了。<br/>这种方式中要注意的是，由于你没有捕获异常，所以要在方法后面声明抛出异常</td></tr><tr><td>finally</td><td>有没有异常都执行</td><td>除非线程、虚拟机、cpu出现问题，不然只要能跑代码，一定会执行</td></tr><tr><td>throw</td><td>抛出一个异常对象</td><td>一些可以导致程序出问题的因素,比如书写错误,逻辑错误或者是api的应用错误等等。为了防止程序的崩溃就要预先检测这些因素,所以java 使用了异常这个机制</td></tr><tr><td>throws</td><td>声明一个异常可能被抛出</td><td>把异常交给他的上级管理，自己不进行异常处理</td></tr></tbody></table><h1 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h1><p>学习过程中没学过，下面内容百度而来，<a href="https://blog.csdn.net/yangjiachang1203/article/details/52351880">原链接</a></p><p>Java2在1.4中新增了一个关键字：assert。在程序开发过程中使用它创建一个断言(assertion)。，它的语法形式有如下所示的两种形式：<br>1、assert condition;<br>    这里condition是一个必须为真(true)的表达式。如果表达式的结果为true，那么断言为真，并且无任何行动<br>如果表达式为false，则断言失败，则会抛出一个AssertionError对象。这个AssertionError继承于Error对象，<br>而Error继承于Throwable，Error是和Exception并列的一个错误对象，通常用于表达系统级运行错误。<br>2、asser condition:expr;<br>    这里condition是和上面一样的，这个冒号后跟的是一个表达式，通常用于断言失败后的提示信息，说白了，它是一个传到AssertionError构造函数的值，如果断言失败，该值被转化为它对应的字符串，并显示出来。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 关键字 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM字节码</title>
      <link href="/2023/10/27/JVM%E5%AD%97%E8%8A%82%E7%A0%81/"/>
      <url>/2023/10/27/JVM%E5%AD%97%E8%8A%82%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><div class="tabs" id="t1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#t1-1">.java文件</button></li><li class="tab"><button type="button" data-href="#t1-2">.class文件</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="t1-1"><p>我们写的文件</p><p>HelloWorld.java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;Hello, World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="t1-2"><p>经过javac 编译以后生成字节码文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09</span><br><span class="line">0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07</span><br><span class="line">0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29</span><br><span class="line">0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e</span><br><span class="line">0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63</span><br><span class="line">0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01</span><br><span class="line">0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63</span><br><span class="line">0000160 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f</span><br><span class="line">0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16</span><br><span class="line">0000220 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72</span><br><span class="line">0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13</span><br><span class="line">0000260 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69</span><br><span class="line">0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61</span><br><span class="line">0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46</span><br><span class="line">0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64</span><br><span class="line">0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e</span><br><span class="line">0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64</span><br><span class="line">0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74</span><br><span class="line">0000440 63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c</span><br><span class="line">0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61</span><br><span class="line">0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61</span><br><span class="line">0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f</span><br><span class="line">0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72</span><br><span class="line">0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76</span><br><span class="line">0000600 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d</span><br><span class="line">0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a</span><br><span class="line">0000640 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b</span><br><span class="line">0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01</span><br><span class="line">0000700 00 07 00 08 00 01 00 09 00 00 00 2f 00 01 00 01</span><br><span class="line">0000720 00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 0a 00</span><br><span class="line">0000740 00 00 06 00 01 00 00 00 04 00 0b 00 00 00 0c 00</span><br><span class="line">0000760 01 00 00 00 05 00 0c 00 0d 00 00 00 09 00 0e 00</span><br><span class="line">0001000 0f 00 02 00 09 00 00 00 37 00 02 00 01 00 00 00</span><br><span class="line">0001020 09 b2 00 02 12 03 b6 00 04 b1 00 00 00 02 00 0a</span><br><span class="line">0001040 00 00 00 0a 00 02 00 00 00 06 00 08 00 07 00 0b</span><br><span class="line">0001060 00 00 00 0c 00 01 00 00 00 09 00 10 00 11 00 00</span><br><span class="line">0001100 00 12 00 00 00 05 01 00 10 00 00 00 01 00 13 00</span><br><span class="line">0001120 00 00 02 00 14</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>根据JVM规范，类文件结构如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4 magic;                  // 魔数，用于标识文件类型</span><br><span class="line">    u2 minor_version;          // Java虚拟机的次版本号</span><br><span class="line">    u2 major_version;          // Java虚拟机的主版本号</span><br><span class="line">    u2 constant_pool_count;    // 常量池大小</span><br><span class="line">    cp_info constant_pool[constant_pool_count-1]; // 常量池数组</span><br><span class="line">    u2 access_flags;           // 访问标识符，用于表示类或接口的访问控制</span><br><span class="line">    u2 this_class;             // 当前类或接口的索引</span><br><span class="line">    u2 super_class;            // 当前类的超类(父类)索引</span><br><span class="line">    u2 interfaces_count;       // 接口数量</span><br><span class="line">    u2 interfaces[interfaces_count]; // 接口索引列表</span><br><span class="line">    u2 fields_count;           // 字段数量</span><br><span class="line">    field_info fields[fields_count]; // 字段信息数组</span><br><span class="line">    u2 methods_count;          // 方法数量</span><br><span class="line">    method_info methods[methods_count]; // 方法信息数组</span><br><span class="line">    u2 attributes_count;       // 类或接口的附加属性数量</span><br><span class="line">    attribute_info attributes[attributes_count]; // 类或接口的附加属性信息数组</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上面的字节码文件，按顺序逐个进行分析</p><h2 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h2><ul><li>0-3字节，表示它是否是class类型的文件<ul><li>0000000 <code>ca fe ba be</code> 00 00 00 34 00 22 0a 00 06 00 14 09</li></ul></li><li>在Java中，所有的.class文件都以魔数<code>ca fe ba be</code>开头，这个魔数的前4个字节用于识别该文件是否为Java类文件，如果这个魔数不匹配，那么Java虚拟机将无法加载该文件。</li></ul><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><ul><li>4-7字节，表示类的版本 <code>00 34(52)</code>对应十进制为52，表示的是<code>Java 8</code></li></ul><h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><table><thead><tr><th align="center">Constant Type</th><th align="center">Value</th></tr></thead><tbody><tr><td align="center">CONSTANT_Utf8</td><td align="center">1</td></tr><tr><td align="center">CONSTANT_Integer</td><td align="center">3</td></tr><tr><td align="center">CONSTANT_Float</td><td align="center">4</td></tr><tr><td align="center">CONSTANT_Long</td><td align="center">5</td></tr><tr><td align="center">CONSTANT_Double</td><td align="center">6</td></tr><tr><td align="center">CONSTANT_Class</td><td align="center">7</td></tr><tr><td align="center">CONSTANT_String</td><td align="center">8</td></tr><tr><td align="center">CONSTANT_Fieldref</td><td align="center">9</td></tr><tr><td align="center">CONSTANT_Methodref</td><td align="center">10</td></tr><tr><td align="center">CONSTANT_InterfaceMethodref</td><td align="center">11</td></tr><tr><td align="center">CONSTANT_NameAndType</td><td align="center">12</td></tr><tr><td align="center">CONSTANT_MethodHandle</td><td align="center">15</td></tr><tr><td align="center">CONSTANT_MethodType</td><td align="center">16</td></tr><tr><td align="center">CONSTANT_InvokeDynamic</td><td align="center">18</td></tr></tbody></table><ul><li>8-9字节，表示常量池长度<ul><li>0000000 ca fe ba be 00 00 00 34 <code>00 22</code> 0a 00 06 00 14 09</li><li><code>00 22(34)</code>，表示常量池有<code>#1-#33</code>项，注意#0项不计入，也没有值</li></ul></li></ul><ol><li><code>第#1项</code> 0a 表示一个 Method 信息，00 06 和 00 14（20） 表示它引用了常量池中 #6 和 #20 项来获得这个方法的<code>所属类</code>和<code>方法名</code><ul><li>0000000 ca fe ba be 00 00 00 34 00 22 <code>0a 00 06 00 14</code> 09</li></ul></li><li><code>第#2项</code> 09 表示一个 Field 信息，00 16（22）和 00 17（23） 表示它引用了常量池中 #22 和 ## 23 项来获得这个成员变量的<code>所属类</code>和<code>成员变量名</code><ul><li>0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 <code>09</code></li><li>0000020 <code>00 16 00 17</code> 08 00 18 0a 00 19 00 1a 07 00 1b 07</li></ul></li><li><code>第#3项</code> 08 表示一个字符串常量名称，00 18（24）表示它引用了常量池中 #24 项<ul><li>0000020 00 16 00 17 <code>08 00 18</code> 0a 00 19 00 1a 07 00 1b 07</li></ul></li><li><code>第#4项</code> 0a 表示一个 Method 信息，00 19（25） 和 00 1a（26） 表示它引用了常量池中 #25 和 #26项来获得这个方法的<code>所属类</code>和<code>方法名</code><ul><li>0000020 00 16 00 17 08 00 18 <code>0a 00 19 00 1a</code> 07 00 1b 07</li></ul></li><li><code>第#5项</code> 07 表示一个 Class 信息，00 1b（27） 表示它引用了常量池中 #27 项<ul><li>0000020 00 16 00 17 08 00 18 0a 00 19 00 1a <code>07 00 1b</code> 07</li></ul></li><li><code>第#6项</code> 07 表示一个 Class 信息，00 1c（28） 表示它引用了常量池中 #28 项<ul><li>0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b <code>07</code></li><li>0000040 <code>00 1c</code> 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29</li></ul></li><li><code>第#7项</code> 01 表示一个 utf8 串，00 06 表示长度，3c 69 6e 69 74 3e 是<code>&lt;init&gt;</code><ul><li>0000040 00 1c 01 <code>00 06 3c 69 6e 69 74 3e</code> 01 00 03 28 29</li></ul></li><li><code>第#8项</code> 01 表示一个 utf8 串，00 03 表示长度，28 29 56 是<code>()V</code>其实就是表示无参、无返回值<ul><li>0000040 00 1c 01 00 06 3c 69 6e 69 74 3e <code>01 00 03 28 29</code></li><li>0000060 <code>56</code> 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e</li></ul></li><li><code>第#9项</code> 01 表示一个 utf8 串，00 04 表示长度，43 6f 64 65 是<code>Code</code><ul><li>0000060 56 <code>01 00 04 43 6f 64 65</code> 01 00 0f 4c 69 6e 65 4e</li></ul></li><li><code>第#10项</code> 01 表示一个 utf8 串，00 0f（15） 表示长度，4c 69 6e 65 4e 75 6d 62 65 72 54 61 62 6c 65 是<code>LineNumberTable</code><ul><li>0000060 56 01 00 04 43 6f 64 <code>65 01 00 0f 4c 69 6e 65 4e</code></li><li>0000100 <code>75 6d 62 65 72 54 61 62 6c 65</code> 01 00 12 4c 6f 63</li></ul></li><li><code>第#11项</code> 01 表示一个 utf8 串，00 12（18） 表示长度，4c 6f 63 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65是<code>LocalVariableTable</code><ul><li>0000100 75 6d 62 65 72 54 61 62 6c 65 <code>01 00 12 4c 6f 63</code></li><li>0000120 <code>61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65</code> 01</li></ul></li><li><code>第#12项</code> 01 表示一个 utf8 串，00 04 表示长度，74 68 69 73 是<code>this</code><ul><li>0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 <code>01</code></li><li>0000140 <code>00 04 74 68 69 73</code> 01 00 1d 4c 63 6e 2f 69 74 63</li></ul></li><li><code>第#13项</code> 01 表示一个 utf8 串，00 1d（29） 表示长度，是<code>Lcn/itcast/jvm/t5/HelloWorld;</code><ul><li>0000140 00 04 74 68 69 73 <code>01 00 1d 4c 63 6e 2f 69 74 63</code></li><li>0000160 <code>61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f</code></li><li>0000200 <code>57 6f 72 6c 64 3b</code> 01 00 04 6d 61 69 6e 01 00 16</li></ul></li><li><code>第#14项</code> 01 表示一个 utf8 串，00 04 表示长度，74 68 69 73 是<code>main</code><ul><li>0000200 57 6f 72 6c 64 3b <code>01 00 04 6d 61 69 6e</code> 01 00 16</li></ul></li><li><code>第#15项</code> 01 表示一个 utf8 串，00 16（22） 表示长度，是<code>([Ljava/lang/String;)V</code>其实就是参数为字符串数组，无返回值<ul><li>0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e <code>01 00 16</code></li><li>0000220 <code>28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72</code></li><li>0000240 <code>69 6e 67 3b 29 56</code> 01 00 04 61 72 67 73 01 00 13</li></ul></li><li><code>第#16项</code> 01 表示一个 utf8 串，00 04 表示长度，是<code>args</code><ul><li>0000240 69 6e 67 3b 29 56 <code>01 00 04 61 72 67 73</code> 01 00 13</li></ul></li><li><code>第#17项</code> 01 表示一个 utf8 串，00 13（19） 表示长度，是<code>[Ljava/lang/String;</code><ul><li>0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 <code>01 00 13</code></li><li>0000260 <code>5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69</code></li><li>0000300 <code>6e 67 3b</code> 01 00 10 4d 65 74 68 6f 64 50 61 72 61</li></ul></li><li><code>第#18项</code> 01 表示一个 utf8 串，00 10（16） 表示长度，是<code>MethodParameters</code><ul><li>0000300 6e 67 3b <code>01 00 10 4d 65 74 68 6f 64 50 61 72 61</code></li><li>0000320 <code>6d 65 74 65 72 73</code> 01 00 0a 53 6f 75 72 63 65 46</li></ul></li><li><code>第#19项</code> 01 表示一个 utf8 串，00 0a（10） 表示长度，是<code>SourceFile</code><ul><li>0000320 6d 65 74 65 72 73 <code>01 00 0a 53 6f 75 72 63 65 46</code></li><li>0000340 <code>69 6c 65</code> 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64</li></ul></li><li><code>第#20项</code> 01 表示一个 utf8 串，00 0f（15） 表示长度，是<code>HelloWorld.java</code><ul><li>0000340 69 6c 65 <code>01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64</code></li><li>0000360 <code>2e 6a 61 76 61</code> 0c 00 07 00 08 07 00 1d 0c 00 1e</li></ul></li><li><code>第#21项</code> 0c 表示一个 <code>名+类型</code>，00 07 00 08 引用了常量池中 #7 #8 两项<ul><li>0000360 2e 6a 61 76 61 <code>0c 00 07 00 08</code> 07 00 1d 0c 00 1e</li></ul></li><li><code>第#22项</code> 07 表示一个 Class 信息，00 1d（29） 引用了常量池中 #29 项<ul><li>0000360 2e 6a 61 76 61 0c 00 07 00 08 <code>07 00 1d</code> 0c 00 1e</li></ul></li><li><code>第#23项</code> 0c 表示一个 <code>名+类型</code>，00 1e（30） 00 1f （31）引用了常量池中 #30 #31 两项<ul><li>0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d <code>0c 00 1e</code></li><li>0000400 <code>00 1f</code> 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64</li></ul></li><li><code>第#24项</code> 01 表示一个 utf8 串，00 0f（15） 表示长度，是<code>hello world</code><ul><li>0000400 00 1f <code>01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64</code></li></ul></li><li><code>第#25项</code> 07 表示一个 Class 信息，00 20（32） 引用了常量池中 #32 项<ul><li>0000420 <code>07 00 20</code> 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74</li></ul></li><li><code>第#26项</code> 0c 表示一个 <code>名+类型</code>，00 21（33） 00 22（34）引用了常量池中 #33 #34 两项<ul><li>0000420 07 00 20 <code>0c 00 21 00 22</code> 01 00 1b 63 6e 2f 69 74</li></ul></li><li><code>第#27项</code> 01 表示一个 utf8 串，00 1b（27） 表示长度，是<code>cn/itcast/jvm/t5/HelloWorld</code><ul><li>0000420 07 00 20 0c 00 21 00 22 01 <code>00 1b 63 6e 2f 69 74</code></li><li>0000440 <code>63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c</code></li><li>0000460 <code>6f 57 6f 72 6c 64</code> 01 00 10 6a 61 76 61 2f 6c 61</li></ul></li><li><code>第#28项</code> 01 表示一个 utf8 串，00 10（16） 表示长度，是<code>java/lang/Object</code><ul><li>0000460 6f 57 6f 72 6c 64 <code>01 00 10 6a 61 76 61 2f 6c 61</code></li><li>0000500 <code>6e 67 2f 4f 62 6a 65 63 74</code> 01 00 10 6a 61 76 61</li></ul></li><li><code>第#29项</code> 01 表示一个 utf8 串，00 10（16） 表示长度，是<code>java/lang/System</code><ul><li>0000500 6e 67 2f 4f 62 6a 65 63 74 <code>01 00 10 6a 61 76 61</code></li><li>0000520 <code>2f 6c 61 6e 67 2f 53 79 73 74 65 6d</code> 01 00 03 6f</li></ul></li><li><code>第#30项</code> 01 表示一个 utf8 串，00 03 表示长度，是<code>out</code><ul><li>0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d <code>01 00 03 6f</code></li><li>0000540 <code>75 74</code> 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72</li></ul></li><li><code>第#31项</code> 01 表示一个 utf8 串，00 15（21） 表示长度，是<code>Ljava/io/PrintStream;</code><ul><li>0000540 75 74 <code>01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72</code></li><li>0000560 <code>69 6e 74 53 74 72 65 61 6d 3b</code> 01 00 13 6a 61 76</li></ul></li><li><code>第#32项</code> 01 表示一个 utf8 串，00 13（19） 表示长度，是<code>java/io/PrintStream</code><ul><li>0000560 69 6e 74 53 74 72 65 61 6d 3b <code>01 00 13 6a 61 76</code></li><li>0000600 <code>61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d</code></li></ul></li><li><code>第#33项</code> 01 表示一个 utf8 串，00 07 表示长度，是<code>println</code><ul><li>0000620 <code>01 00 07 70 72 69 6e 74 6c 6e</code> 01 00 15 28 4c 6a</li></ul></li><li><code>第#34项</code> 01 表示一个 utf8 串，00 15（21） 表示长度，是<code>(Ljava/lang/String;)V</code><ul><li>0000620 01 00 07 70 72 69 6e 74 6c 6e <code>01 00 15 28 4c 6a</code></li><li>0000640 <code>61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b</code></li><li>0000660 <code>29 56</code> 00 21 00 05 00 06 00 00 00 00 00 02 00 01</li></ul></li></ol><h2 id="访问标识与继承信息"><a href="#访问标识与继承信息" class="headerlink" title="访问标识与继承信息"></a>访问标识与继承信息</h2><ul><li>访问标识符：21表示class是一个类，公共的<ul><li>0000660 29 56 <code>00 21</code> 00 05 00 06 00 00 00 00 00 02 00 01</li></ul></li><li>当前类或接口的索引：05表示根据常量池中的#5找到本类的全限定名<ul><li>0000660 29 56 00 21 <code>00 05</code> 00 06 00 00 00 00 00 02 00 01</li></ul></li><li>当前类的超类（父类）索引：06表示根据常量池中的#6找到父类全限定名<ul><li>0000660 29 56 00 21 00 05 <code>00 06</code> 00 00 00 00 00 02 00 01</li></ul></li><li>接口数量：本类为0<ul><li>0000660 29 56 00 21 00 05 00 06 <code>00 00</code> 00 00 00 02 00 01</li></ul></li></ul><table><thead><tr><th align="center">Flag Name</th><th align="center">Value</th><th>Interpretation</th></tr></thead><tbody><tr><td align="center">ACC_PUBLIC</td><td align="center">0x0001</td><td>Declared public; may be accessed from outside its package.</td></tr><tr><td align="center">ACC_FINAL</td><td align="center">0x0010</td><td>Declared final; no subclasses allowed.</td></tr><tr><td align="center">ACC_SUPER</td><td align="center">0x0020</td><td>Treat superclass methods specially when invoked by the invokespecial instruction.</td></tr><tr><td align="center">ACC_INTERFACE</td><td align="center">0x0200</td><td>Is an interface, not a class.</td></tr><tr><td align="center">ACC_ABSTRACT</td><td align="center">0x0400</td><td>Declared abstract; must not be instantiated.</td></tr><tr><td align="center">ACC_SYNTHETIC</td><td align="center">0x1000</td><td>Declared synthetic; not present in the source code.</td></tr><tr><td align="center">ACC_ANNOTATION</td><td align="center">0x2000</td><td>Declared as an annotation type.</td></tr><tr><td align="center">ACC_ENUM</td><td align="center">0x4000</td><td>Declared as an enum type.</td></tr></tbody></table><h2 id="Field信息"><a href="#Field信息" class="headerlink" title="Field信息"></a>Field信息</h2><ul><li>字段数量（成员变量数量），本类为0<ul><li>0000660 29 56 00 21 00 05 00 06 00 00 <code>00 00</code> 00 02 00 01</li></ul></li></ul><h2 id="Method信息"><a href="#Method信息" class="headerlink" title="Method信息"></a>Method信息</h2><ul><li>方法数量：本类为2，构造方法和main方法<ul><li>0000660 29 56 00 21 00 05 00 06 00 00 00 00 <code>00 02</code> 00 01</li></ul></li><li>一个方法由访问修饰符、名称、参数描述、方法苏属性数量、方法属性组成</li><li>00 01表示访问修饰符（本类中为public）<ul><li>0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 <code>00 01</code></li></ul></li><li>00 07表示引用了常量池中的#07项作为方法名称<ul><li>0000700 <code>00 07</code> 00 08 00 01 00 09 00 00 00 2f 00 01 00 01</li></ul></li><li>00 08表示引用了常量池中的#08项作为方法参数描述<ul><li>0000700 00 07 <code>00 08</code> 00 01 00 09 00 00 00 2f 00 01 00 01</li></ul></li><li>01表示引方法属性数量，本方法是1<ul><li>0000700 00 07 00 08 <code>00 01</code> 00 09 00 00 00 2f 00 01 00 01</li></ul></li><li>00 09表示引用常量池#09项，发现是<code>code</code>属性<ul><li>0000700 00 07 00 08 00 01 <code>00 09</code> 00 00 00 2f 00 01 00 01</li></ul></li><li>00 00 00 2f表示此属性的长度是47<ul><li>0000700 00 07 00 08 00 01 00 09 <code>00 00 00 2f</code> 00 01 00 01</li></ul></li><li>00 01表示操作数栈最大深度<ul><li>0000700 00 07 00 08 00 01 00 09 00 00 00 2f <code>00 01</code> 00 01</li></ul></li><li>00 01表示局部变量最大槽(slot)数<ul><li>0000700 00 07 00 08 00 01 00 09 00 00 00 2f 00 01 <code>00 01</code></li></ul></li><li>00 00 00 05表示字节码长度，本例为5<ul><li>0000720 <code>00 00 00 05</code> 2a b7 00 01 b1 00 00 00 02 00 0a 00</li></ul></li><li>2a b7 00 01 b1 是字节码指令<ul><li>0000720 00 00 00 05 <code>2a b7 00 01 b1</code> 00 00 00 02 00 0a 00</li></ul></li><li>00 00 00 02 表示方法细节属性数量，本例为2<ul><li>0000720 00 00 00 05 2a b7 00 01 b1 <code>00 00 00 02</code> 00 0a 00</li></ul></li><li>00 0a表示引用了常量池#10项，发现是LineNumberTable属性<ul><li>0000720 00 00 00 05 2a b7 00 01 b1 00 00 00 02 <code>00 0a</code> 00</li><li>00 00 00 06表示此属性的总长度，本例是6<ul><li>0000720 00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 0a <code>00</code></li><li>0000740 <code>00 00 06</code> 00 01 00 00 00 04 00 0b 00 00 00 0c 00</li></ul></li><li>00 01表示LineNumberTable长度<ul><li>0000740 00 00 06 <code>00 01</code> 00 00 00 04 00 0b 00 00 00 0c 00</li></ul></li><li>00 00 表示字节码行号<ul><li>0000740 00 00 06 00 01 <code>00 00</code> 00 04 00 0b 00 00 00 0c 00</li></ul></li><li>00 04表示Java源码行号<ul><li>0000740 00 00 06 00 01 00 00 <code>00 04</code> 00 0b 00 00 00 0c 00</li></ul></li></ul></li><li>00 0b表示引用了常量池#11项，发现是LocalVariableTable属性<ul><li>0000740 00 00 06 00 01 00 00 00 04 <code>00 0b</code> 00 00 00 0c 00</li><li>00 00 00 0c 表示此属性总长度，本例为12<ul><li>0000740 00 00 06 00 01 00 00 00 04 00 0b <code>00 00 00 0c</code> 00</li></ul></li><li>00 01 表示LocalVariableTable长度<ul><li>0000740 00 00 06 00 01 00 00 00 04 00 0b 00 00 00 0c <code>00</code></li><li>0000760 <code>01</code> 00 00 00 05 00 0c 00 0d 00 00 00 09 00 0e 00</li></ul></li><li>00 00 表示局部变量生命周期开始，相对于字节码的偏移量<ul><li>0000760 01 <code>00 00</code> 00 05 00 0c 00 0d 00 00 00 09 00 0e 00</li></ul></li><li>00 05 表示局部变量覆盖的范围长度<ul><li>0000760 01 00 00 <code>00 05</code> 00 0c 00 0d 00 00 00 09 00 0e 00</li></ul></li><li>00 0c 表示局部变量的名称，引用常量池#12项<ul><li>0000760 01 00 00 00 05 <code>00 0c</code> 00 0d 00 00 00 09 00 0e 00</li></ul></li><li>00 0d 表示局部变量的类型，本例引用了常量池 #13 项，是Lcn&#x2F;itcast&#x2F;jvm&#x2F;t5&#x2F;HelloWorld;<ul><li>0000760 01 00 00 00 05 00 0c <code>00 0d</code> 00 00 00 09 00 0e 00</li></ul></li><li>00 00 表述局部变量占有的槽位(slot)编号，本例是0<ul><li>0000760 01 00 00 00 05 00 0c 00 0d <code>00 00</code> 00 09 00 0e 00</li></ul></li></ul></li><li>00 09代表访问修饰符（本类中是 public static）</li><li>00 0e 代表引用了常量池 #14 项作为方法名称</li><li>00 0f 代表引用了常量池 #15 项作为方法参数描述</li><li>00 02 代表方法属性数量，本方法是 2</li><li>其余代表方法属性（属性1）<ul><li>00 09 表示引用了常量池 #09 项，发现是<code>Code</code>属性</li><li>00 00 00 37 表示此属性的长度是 55</li><li>00 02 表示<code>操作数栈</code>最大深度</li><li>00 01 表示<code>局部变量表</code>最大槽（slot）数</li><li>00 00 00 05 表示字节码长度，本例是 9</li><li>b2 00 02 12 03 b6 00 04 b1 是字节码指令</li><li>00 00 00 02 表示方法细节属性数量，本例是 2</li><li>00 0a 表示引用了常量池 #10 项，发现是LineNumberTable属性<ul><li>00 00 00 0a 表示此属性的总长度，本例是 10</li><li>00 02 表示<code>LineNumberTable</code>长度</li><li>00 00 表示<code>字节码</code>行号 00 06 表示<code>java 源码</code>行号</li><li>00 08 表示<code>字节码</code>行号 00 07 表示<code>java 源码</code>行号</li></ul></li></ul></li><li>00 0b 表示引用了常量池 #11 项，发现是<code>LocalVariableTable</code>属性<ul><li>00 00 00 0c 表示此属性的总长度，本例是 12</li><li>00 01 表示<code>LocalVariableTable</code>长度</li><li>00 00 表示局部变量生命周期开始，相对于字节码的偏移量</li><li>00 09 表示局部变量覆盖的范围长度</li><li>00 10 表示局部变量名称，本例引用了常量池 #16 项，是<code>args</code></li><li>00 11 表示局部变量的类型，本例引用了常量池 #17 项，是<code>[Ljava/lang/String;</code></li><li>00 00 表示局部变量占有的槽位（slot）编号，本例是 0</li></ul></li><li>0000760 01 00 00 00 05 00 0c 00 0d 00 00 <code>00 09 00 0e 00</code></li><li>0001000 <code>0f 00 02 00 09 00 00 00 37 00 02 00 01 00 00 00</code></li><li>0001020 <code>09 b2 00 02 12 03 b6 00 04 b1 00 00 00 02 00 0a</code></li><li>0001040 <code>00 00 00 0a 00 02 00 00 00 06 00 08 00 07 00 0b</code></li><li>0001060 <code>00 00 00 0c 00 01 00 00 00 09 00 10 00 11 00 00</code></li><li>红色代表方法属性（属性2）<ul><li>00 12 表示引用了常量池 #18 项，发现是<code>MethodParameters</code>属性</li><li>00 00 00 05 表示此属性的总长度，本例是 5</li><li>01 参数数量</li><li>00 10 表示引用了常量池 #16 项，是<code>args</code></li><li>00 00 访问修饰符</li><li>0001100 <code>00 12 00 00 00 05 01 00 10 00 00</code> 00 01 00 13 00</li></ul></li></ul><h2 id="附加属性"><a href="#附加属性" class="headerlink" title="附加属性"></a>附加属性</h2><ul><li>00 01 表示附加属性数量</li><li>00 13 表示引用了常量池 #19 项，即<code>SourceFile</code></li><li>00 00 00 02 表示此属性的长度</li><li>00 14 表示引用了常量池 #20 项，即HelloWorld.java<ul><li>0001100 00 12 00 00 00 05 01 00 10 00 00 <code>00 01 00 13 00</code></li><li>0001120 <code>00 00 02 00 14</code>分</li></ul></li></ul><h1 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h1><h2 id="javap工具"><a href="#javap工具" class="headerlink" title="javap工具"></a>javap工具</h2><ul><li><p>自己分析类文件结构太麻烦了，Oracle提供了javap工具来反编译class文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">$ javap -v HelloWorld.class</span><br><span class="line">Classfile /D:/Workspace/JVM/demo/target/classes/com/demo/HelloWorld.class</span><br><span class="line">  Last modified 2023-4-5; size 551 bytes</span><br><span class="line">  MD5 checksum 1389d939c65ba536eb81d1a5c61d99be</span><br><span class="line">  Compiled from &quot;HelloWorld.java&quot;              </span><br><span class="line">public class com.demo.HelloWorld               </span><br><span class="line">  minor version: 0                             </span><br><span class="line">  major version: 52                            </span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #6.#20         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #21.#22        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #3 = String             #23            // hello world</span><br><span class="line">   #4 = Methodref          #24.#25        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = Class              #26            // com/demo/HelloWorld</span><br><span class="line">   #6 = Class              #27            // java/lang/Object</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Lcom/demo/HelloWorld;</span><br><span class="line">  #14 = Utf8               main</span><br><span class="line">  #15 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #16 = Utf8               args</span><br><span class="line">  #17 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #18 = Utf8               SourceFile</span><br><span class="line">  #19 = Utf8               HelloWorld.java</span><br><span class="line">  #20 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #21 = Class              #28            // java/lang/System</span><br><span class="line">  #22 = NameAndType        #29:#30        // out:Ljava/io/PrintStream;</span><br><span class="line">  #23 = Utf8               hello world</span><br><span class="line">  #24 = Class              #31            // java/io/PrintStream</span><br><span class="line">  #25 = NameAndType        #32:#33        // println:(Ljava/lang/String;)V</span><br><span class="line">  #26 = Utf8               com/demo/HelloWorld</span><br><span class="line">  #27 = Utf8               java/lang/Object</span><br><span class="line">  #28 = Utf8               java/lang/System</span><br><span class="line">  #29 = Utf8               out</span><br><span class="line">  #30 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #31 = Utf8               java/io/PrintStream</span><br><span class="line">  #32 = Utf8               println</span><br><span class="line">  #33 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  public com.demo.HelloWorld();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3                  // String hello world</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 5: 0</span><br><span class="line">        line 6: 8</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       9     0  args   [Ljava/lang/String;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;HelloWorld.java&quot;</span><br></pre></td></tr></table></figure></li></ul><h2 id="图解方法执行流程"><a href="#图解方法执行流程" class="headerlink" title="图解方法执行流程"></a>图解方法执行流程</h2><ol><li><p>原始Java代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 演示 字节码指令 和 操作数栈、常量池的关系</span><br><span class="line"> */</span><br><span class="line">public class Demo_20 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a = 10;</span><br><span class="line">        int b = Short.MAX_VALUE + 1;</span><br><span class="line">        int c = a + b;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编译后的字节码文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">$ javap -v Demo_20.class</span><br><span class="line">Classfile /D:/Workspace/JVM/demo/target/classes/com/demo/Demo_20.class</span><br><span class="line">  Last modified 2023-4-7; size 601 bytes       </span><br><span class="line">  MD5 checksum 0f9e41fb2a7334a69c89d2661540f4f1</span><br><span class="line">  Compiled from &quot;Demo_20.java&quot;                 </span><br><span class="line">public class com.demo.Demo_20                  </span><br><span class="line">  minor version: 0                             </span><br><span class="line">  major version: 52                            </span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER                 </span><br><span class="line">Constant pool:                                 </span><br><span class="line">   #1 = Methodref          #7.#25         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V             </span><br><span class="line">   #2 = Class              #26            // java/lang/Short                           </span><br><span class="line">   #3 = Integer            32768                                                       </span><br><span class="line">   #4 = Fieldref           #27.#28        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #5 = Methodref          #29.#30        // java/io/PrintStream.println:(I)V</span><br><span class="line">   #6 = Class              #31            // com/demo/Demo_20</span><br><span class="line">   #7 = Class              #32            // java/lang/Object</span><br><span class="line">   #8 = Utf8               &lt;init&gt;</span><br><span class="line">   #9 = Utf8               ()V</span><br><span class="line">  #10 = Utf8               Code</span><br><span class="line">  #11 = Utf8               LineNumberTable</span><br><span class="line">  #12 = Utf8               LocalVariableTable</span><br><span class="line">  #13 = Utf8               this</span><br><span class="line">  #14 = Utf8               Lcom/demo/Demo_20;</span><br><span class="line">  #15 = Utf8               main</span><br><span class="line">  #16 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #17 = Utf8               args</span><br><span class="line">  #18 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #19 = Utf8               a</span><br><span class="line">  #20 = Utf8               I</span><br><span class="line">  #21 = Utf8               b</span><br><span class="line">  #22 = Utf8               c</span><br><span class="line">  #23 = Utf8               SourceFile</span><br><span class="line">  #24 = Utf8               Demo_20.java</span><br><span class="line">  #25 = NameAndType        #8:#9          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #26 = Utf8               java/lang/Short</span><br><span class="line">  #27 = Class              #33            // java/lang/System</span><br><span class="line">  #28 = NameAndType        #34:#35        // out:Ljava/io/PrintStream;</span><br><span class="line">  #29 = Class              #36            // java/io/PrintStream</span><br><span class="line">  #30 = NameAndType        #37:#38        // println:(I)V</span><br><span class="line">  #31 = Utf8               com/demo/Demo_20</span><br><span class="line">  #32 = Utf8               java/lang/Object</span><br><span class="line">  #33 = Utf8               java/lang/System</span><br><span class="line">  #34 = Utf8               out</span><br><span class="line">  #35 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #36 = Utf8               java/io/PrintStream</span><br><span class="line">  #37 = Utf8               println</span><br><span class="line">  #38 = Utf8               (I)V</span><br><span class="line">&#123;</span><br><span class="line">  public com.demo.Demo_20();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 6: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom/demo/Demo_20;</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=4, args_size=1</span><br><span class="line">         0: bipush        10</span><br><span class="line">         2: istore_1</span><br><span class="line">         3: ldc           #3                  // int 32768</span><br><span class="line">         5: istore_2</span><br><span class="line">         6: iload_1</span><br><span class="line">         7: iload_2</span><br><span class="line">         8: iadd</span><br><span class="line">         9: istore_3</span><br><span class="line">        10: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        13: iload_3</span><br><span class="line">        14: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        17: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 8: 0</span><br><span class="line">        line 9: 3</span><br><span class="line">        line 10: 6</span><br><span class="line">        line 11: 10</span><br><span class="line">        line 12: 17</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      18     0  args   [Ljava/lang/String;</span><br><span class="line">            3      15     1     a   I</span><br><span class="line">            6      12     2     b   I</span><br><span class="line">           10       8     3     c   I</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;Demo_20.java&quot;</span><br></pre></td></tr></table></figure></li><li><p>常量池载入运行时常量池</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310271921123.png"></p></li><li><p>方法字节码载入方法区</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310271921811.png"></p></li><li><p>main线程开始运行、分配栈帧内存</p><p>stack&#x3D;2, locals&#x3D;4</p><ul><li><p>操作数栈的深度为2，也就是说，在执行该方法时，最多可以将两个值压入栈中进行操作。</p></li><li><p>包含四个局部变量</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310271922837.png"></p></li></ul></li><li><p>执行引擎开始执行字节码</p></li></ol><blockquote><p>不知道这算不算汇编语言，但是跟我学过的汇编语言原理基本上一样</p></blockquote><div class="tabs" id="t2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#t2-1">bipush 10</button></li><li class="tab"><button type="button" data-href="#t2-2">istore_1</button></li><li class="tab"><button type="button" data-href="#t2-3">ldc #3</button></li><li class="tab"><button type="button" data-href="#t2-4">iload_1</button></li><li class="tab"><button type="button" data-href="#t2-5">iadd</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="t2-1"><ul><li>将一个byte压入操作数栈（其长度会补齐为4个字节），类似的指令还有</li><li>sipush：将一个short压入操作数栈（其长度会补齐为4个字节）</li><li>ldc：将一个int压入操作数栈</li><li>ldc2_w：将一个long压入操作数栈（分两次压入，因为long占8个字节）</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310271923333.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="t2-2"><p>将操作数栈顶数据弹出，存入局部变量表slot 1</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310271924884.png"> </p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="t2-3"><p>从常量池加载#3数据到操作数栈</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310271927272.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="t2-4"><p>将局部变量表slot 1的值加载到操作数栈中</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="t2-5"><p>从操作数栈顶部弹出两个int类型的数值，将这两个数值相加，并将其结果压入操作数栈顶部；</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310271929673.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="例子-分析-i"><a href="#例子-分析-i" class="headerlink" title="例子.分析 i++"></a>例子.分析 i++</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Demo_21 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a = 10;</span><br><span class="line">        int b = a++ + ++a + a--;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请问，b是多少，为什么。</p><p>主要部分字节码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> 0: bipush        10        // 将一个byte压入操作数栈，此时就是将10压入操作数栈</span><br><span class="line"> 2: istore_1                // 将操作数栈顶部数据弹出，存入局部变量表 slot 1</span><br><span class="line"> 3: iload_1                 // 将局部变量表slot 1的值加载到操作数栈中，也就是将10加载到栈中</span><br><span class="line"> 4: iinc          1, 1      // 在当前局部变量上进行运算，自增1，此时局部变量 a = 11   至此 a++ 执行完毕</span><br><span class="line"> 7: iinc          1, 1      // 在当前局部变量上进行运算，自增1，此时局部变量 a = 12</span><br><span class="line">10: iload_1                 // 将局部变量表slot 1的值加载到操作数栈中，也就是将12加载到栈中</span><br><span class="line">11: iadd                    // 将栈内两个元素相加，10 + 12 = 22，将结果22加载到栈中</span><br><span class="line">12: iload_1                 // 将局部变量表slot 1的值加载到操作数栈中，也就是将12加载到栈中</span><br><span class="line">13: iinc          1, -1     // 在当前局部变量上进行运算，自减1，此时局部变量 a = 11</span><br><span class="line">16: iadd                    // 将栈内两个元素相加，22 + 12 = 34，结果为34</span><br><span class="line">17: istore_2                // 将操作数栈顶部数据弹出，存入局部变量表slot 2</span><br><span class="line">18: getstatic     #2        // 下面就不分析了，就是输出a和b的值</span><br><span class="line">21: iload_1</span><br><span class="line">22: invokevirtual #3                  </span><br><span class="line">25: getstatic     #2                  </span><br><span class="line">28: iload_2</span><br><span class="line">29: invokevirtual #3                  </span><br><span class="line">32: return</span><br></pre></td></tr></table></figure><p><code>iinc</code>指令是直接在局部变量slot上进行运算</p><ul><li>那么最终的结果<code>a = 11</code>，<code>b = 34</code></li><li>注意a++和++a的区别为<ul><li><code>a++</code>是先执行<code>iload</code>，再执行<code>iinc</code></li><li><code>++a</code>是先执行<code>iinc</code>，再执行<code>iload</code></li></ul></li></ul><h2 id="条件判断指令"><a href="#条件判断指令" class="headerlink" title="条件判断指令"></a>条件判断指令</h2><table><thead><tr><th align="center">指令</th><th align="center">助记符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">0x99</td><td align="center">ifeq</td><td align="center">判断是否 &#x3D;&#x3D; 0</td></tr><tr><td align="center">0x9a</td><td align="center">ifne</td><td align="center">判断是否 !&#x3D; 0</td></tr><tr><td align="center">0x9b</td><td align="center">iflt</td><td align="center">判断是否 &lt; 0</td></tr><tr><td align="center">0x9c</td><td align="center">ifge</td><td align="center">判断是否 &gt;&#x3D; 0</td></tr><tr><td align="center">0x9d</td><td align="center">ifgt</td><td align="center">判断是否 &gt; 0</td></tr><tr><td align="center">0x9e</td><td align="center">ifle</td><td align="center">判断是否 &lt;&#x3D; 0</td></tr><tr><td align="center">0x9f</td><td align="center">if_icmpeq</td><td align="center">两个int是否 &#x3D;&#x3D;</td></tr><tr><td align="center">0xa0</td><td align="center">if_icmpne</td><td align="center">两个int是否 !&#x3D;</td></tr><tr><td align="center">0xa1</td><td align="center">if_icmplt</td><td align="center">两个int是否 &lt;</td></tr><tr><td align="center">0xa2</td><td align="center">if_icmpge</td><td align="center">两个int是否 &gt;&#x3D;</td></tr><tr><td align="center">0xa3</td><td align="center">if_icmpgt</td><td align="center">两个int是否 &gt;</td></tr><tr><td align="center">0xa4</td><td align="center">if_icmple</td><td align="center">两个int是否 &lt;&#x3D;</td></tr><tr><td align="center">0xa5</td><td align="center">if_acmpeq</td><td align="center">两个引用是否 &#x3D;&#x3D;</td></tr><tr><td align="center">0xa6</td><td align="center">if_acmpne</td><td align="center">两个引用是否 !&#x3D;</td></tr><tr><td align="center">0xc6</td><td align="center">ifnull</td><td align="center">判断是否 &#x3D;&#x3D; null</td></tr><tr><td align="center">0xc7</td><td align="center">ifnonnull</td><td align="center">判断是否 !&#x3D; null</td></tr></tbody></table><div class="tabs" id="3"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#3-1">条件判断</button></li><li class="tab"><button type="button" data-href="#3-2">循环控制</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="3-1"><ul><li>原始Java代码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">复制成功public class Demo_22 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a = 0;</span><br><span class="line">        if (a == 0) &#123;</span><br><span class="line">            a = 10;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            a = 20;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译后的字节码文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AWK</span><br><span class="line"> 0: iconst_0             // 将整数常量值0（int类型）压入操作数栈中。</span><br><span class="line"> 1: istore_1             // 将栈顶数据存入局部变量表 slot 1</span><br><span class="line"> 2: iload_1              // 将局部变量表slot 1的值压入操作数栈</span><br><span class="line"> 3: ifne           12    // 判断不等于0，成立跳转至12行，不成立则执行下一行</span><br><span class="line"> 6: bipush         10    // 将10压入操作数栈</span><br><span class="line"> 8: istore_1             // 将栈顶数据存入局部变量表 slot 1</span><br><span class="line"> 9: goto           15    // 跳转至第15行</span><br><span class="line">12: bipush        20     // 将20压入操作数栈，对应 a = 20</span><br><span class="line">14: istore_1             // 将栈顶数据存入局部变量表 slot 1</span><br><span class="line">15: return</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3-2"><ul><li>原始Java代码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class Demo_23 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a = 0;</span><br><span class="line">        while (a &lt; 10) &#123;</span><br><span class="line">            a++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译后的字节码文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AWK</span><br><span class="line"> 0: iconst_0                // 将整数常量值0（int类型）压入操作数栈中。</span><br><span class="line"> 1: istore_1                // 将栈顶数据存入局部变量表 slot 1</span><br><span class="line"> 2: iload_1                 // 将局部变量表slot 1的值压入操作数栈</span><br><span class="line"> 3: bipush        10        // 将10压入操作数栈</span><br><span class="line"> 5: if_icmpge     14        // 判断 i &gt;= 10 ，成立则跳转到14行，不成立则执行下一行</span><br><span class="line"> 8: iinc          1, 1      // i自增</span><br><span class="line">11: goto          2         // 跳转到第2行</span><br><span class="line">14: return</span><br></pre></td></tr></table></figure><ul><li>再比如<code>do while</code>循环</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class Demo_24 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        do &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; while (i &lt; 10);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译后的字节码文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AWK</span><br><span class="line"> 0: iconst_0                // 将整数常量值0（int类型）压入操作数栈中。</span><br><span class="line"> 1: istore_1                // 将栈顶数据存入局部变量表 slot 1</span><br><span class="line"> 2: iinc          1, 1      // i自增</span><br><span class="line"> 5: iload_1                 // 将局部变量表slot 1加载到操作数栈</span><br><span class="line"> 6: bipush        10        // 将10加载到操作数栈</span><br><span class="line"> 8: if_icmplt     2         // 判断 i &lt; 10，成立则跳转到第2行，不成立执行下一行</span><br><span class="line">11: return</span><br></pre></td></tr></table></figure><ul><li>最后再来看看for循环</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class Demo_25 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译后的字节码文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NESTEDTEXT</span><br><span class="line"> 0: iconst_0</span><br><span class="line"> 1: istore_1</span><br><span class="line"> 2: iload_1</span><br><span class="line"> 3: bipush        10</span><br><span class="line"> 5: if_icmpge     14</span><br><span class="line"> 8: iinc          1, 1</span><br><span class="line">11: goto          2</span><br><span class="line">14: return</span><br></pre></td></tr></table></figure><blockquote><p>注意到while和for的字节码，它们是一模一样的</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><div class="tabs" id="4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#4-1">< cinit >()V</button></li><li class="tab"><button type="button" data-href="#4-2">< init >()V</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="4-1"><ul><li>编译器会按照从上至下的顺序，收集所有的static静态代码块和静态成员赋值的代码，合并成一个特殊的方法<code>&lt;cinit&gt;()V</code></li><li><code>&lt;cinit&gt;()V</code>方法会在类加载的初始化阶段被调用</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="4-2"><ul><li>编译器会按照从上至下的顺序，收集所有代码块和所有成员变量赋值的代码，形成新的构造方法，但原始构造方法内的代码总是会在最后</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>看一下几种不同方法调用对应的字节码指令，私有方法，final方法，公共方法，静态方法</p><ul><li><p>其中静态方法包括对象调静态方法和类直接调静态方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Demo_29 &#123;</span><br><span class="line">    public Demo_29()&#123;&#125;</span><br><span class="line">    private void test1()&#123;&#125;</span><br><span class="line">    private final void test2()&#123;&#125;</span><br><span class="line">    public void test3()&#123;&#125;</span><br><span class="line">    public static void test4()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Demo_29 demo = new Demo_29();</span><br><span class="line">        demo.test1();</span><br><span class="line">        demo.test2();</span><br><span class="line">        demo.test3();</span><br><span class="line">        demo.test4();</span><br><span class="line">        Demo_29.test4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编译后的字节码文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> 0: new           #2                  // class com/demo/Demo_29</span><br><span class="line"> 3: dup</span><br><span class="line"> 4: invokespecial #3                  // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line"> 7: astore_1</span><br><span class="line"> 8: aload_1</span><br><span class="line"> 9: invokespecial #4                  // Method test1:()V</span><br><span class="line">12: aload_1</span><br><span class="line">13: invokespecial #5                  // Method test2:()V</span><br><span class="line">16: aload_1</span><br><span class="line">17: invokevirtual #6                  // Method test3:()V</span><br><span class="line">20: aload_1</span><br><span class="line">21: pop</span><br><span class="line">22: invokestatic  #7                  // Method test4:()V</span><br><span class="line">25: invokestatic  #7                  // Method test4:()V</span><br><span class="line">28: return</span><br></pre></td></tr></table></figure></li><li><p>new #2是创建Demo_29对象，给对象分配内存，执行成功会将<code>对象引用</code>压入操作数栈</p></li><li><p>dup是赋值操作数栈顶的内容，本例为对象引用。那为什么需要两份引用呢？</p><ul><li>一个是要配合<code>invokespecial</code>调用该对象的构造方法<code>&quot;&lt;init&gt;:()V&quot;</code>，会消耗掉栈顶一个引用</li><li>另一个要配合<code>astore_1</code>赋值给局部变量</li></ul></li><li><p>final方法、私有方法、构造方法，都是由invokespecial指令来调用，属于静态绑定</p></li><li><p>普通成员方法是由invokevirtual调用，属于动态绑定，即支持多态</p></li><li><p>成员方法与静态方法调用的另一个区别是，执行方法前是否需要<code>对象引用</code></p></li><li><p>比较有意思的是，执行demo.test4()时，是通过<code>对象引用</code>调用的静态方法，可以看到在调用前执行了pop指令，把对象引用从操作数栈弹掉了，因为静态方法不需要对象引用来掉，通过这种方式，反而会增加两步无用的字节码指令</p></li></ul><h2 id="多态的原理"><a href="#多态的原理" class="headerlink" title="多态的原理"></a>多态的原理</h2><p>原始Java代码</p><ul><li>定义了一个抽象类Animal，还有其两个子类Cat和Dog</li></ul><h1 id="编译期处理（语法糖）"><a href="#编译期处理（语法糖）" class="headerlink" title="编译期处理（语法糖）"></a>编译期处理（语法糖）</h1><ul><li>所谓<code>语法糖</code>，其实就是指Java编译器把<code>.java</code>编译为<code>.class</code>字节码的过程中，自动生成的和转换的一些代码，主要是为了减轻程序员的负担，算是Java编译器给我们的一个额外福利</li><li>下面的代码分析，借助了javap工具、idea的反编译功能、idea插件jclasslib等工具。另外，编译器转换的结果直接就是class字节码，只是为了便于阅读，给出了<code>几乎等价</code>的Java源码</li></ul><h2 id="默认构造器"><a href="#默认构造器" class="headerlink" title="默认构造器"></a>默认构造器</h2><p>如果一个类没有声明任何构造函数，Java 编译器会自动为该类生成一个无参构造函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Candy01 &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译成class后的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Candy1 &#123;</span><br><span class="line"></span><br><span class="line">    // 这个无参构造是编译器帮助我们加上的</span><br><span class="line">    public Candy1() &#123;</span><br><span class="line">        super(); // 即调用父类 Object 的无参构造方法，即调用 java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h2><p>这个特性是 <code>JDK 5</code> 开始加入的，<code>代码片段1：</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Candy02 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer x = 1;</span><br><span class="line">        int y = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这段代码在<code>JDK 5</code>之前是无法编译通过的，比如改写为如下形式，<code>代码片段2</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Candy02 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer x = Integer.valueOf(1);</span><br><span class="line">        int y = x.intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>显然之前版本的代码太麻烦了，需要在基本类型和包装类型之间相互转换（尤其是集合类中的操作都是包装类型），因此这些转换的事情在<code>JDK 5</code>以后都由编译器在编译阶段完成。即<code>代码片段1</code>都会在编译阶段转换成<code>代码片段2</code></p><h2 id="泛型集合取值"><a href="#泛型集合取值" class="headerlink" title="泛型集合取值"></a>泛型集合取值</h2><p>泛型也是<code>JDK 5</code>开始加入的特性，但Java在编译泛型后会执行<code>泛型擦除</code>的动作，即泛型信息在编译为字节码后就丢失了，实际的类型都当做Object类型来处理</p><blockquote><p>注意是编译后，编译前编译器帮你确保类型不会出问题才擦除的</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Candy03 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(10);               // 实际调用的是 List.add(Object e)</span><br><span class="line">        Integer x = list.get(0);    // 实际调用的是 Object obj = List.get(int index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>可变参数也是<code>JDK 5</code>开始加入的新特性，示例代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Candy04 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        foo(&quot;hello&quot;, &quot;world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void foo(String... args) &#123;</span><br><span class="line">        String[] array = args;</span><br><span class="line">        System.out.println(array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可变参数String… args 其实是一个String[] args，同样Java编译器会在编译期间将上述代码转换为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Candy04 &#123;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        foo(new String[]&#123;&quot;hello&quot;, &quot;world&quot;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void foo(String[] args) &#123;</span><br><span class="line">        String[] array = args;          // 直接赋值</span><br><span class="line">        System.out.println(array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意如果调用foo()时没有提供任何参数，那么则等价为foo(new String)，创建了一个空的数组，而不是传一个null进去</p></blockquote><h2 id="foreach循环"><a href="#foreach循环" class="headerlink" title="foreach循环"></a>foreach循环</h2><p>仍然是JDK 5开始引入的语法糖，数组的循环</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Candy05 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] array = &#123;1, 2, 3, 4, 5&#125;;      // 数组的赋初值的简化，也是语法糖 new int[]&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">        for (int a : array) &#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会被编译器转换为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Candy05 &#123;</span><br><span class="line">    public Candy05() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] array = new int[]&#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">        for(int i = 0; i &lt; array.length; ++i) &#123;</span><br><span class="line">            int e = array[i];</span><br><span class="line">            System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而集合的循环</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Candy06 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5);</span><br><span class="line">        for (Integer integer : list) &#123;</span><br><span class="line">            System.out.println(integer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上会被编译器转换为对迭代器的调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Candy06 &#123;</span><br><span class="line">    public Candy06() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5);</span><br><span class="line">        Iterator iterator = list.iterator();</span><br><span class="line">        while (iterator.hasNext())&#123;</span><br><span class="line">            Integer next = (Integer) iterator.next();</span><br><span class="line">            System.out.println(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>foreach循环写法，能够配合数组，以及所有实现了Iterable接口的集合类一起使用，其中Iterable用来获取集合的迭代器Iterator</p></blockquote><h2 id="switch字符串"><a href="#switch字符串" class="headerlink" title="switch字符串"></a>switch字符串</h2><p>从<code>JDK 7</code>开始，switch可以作用于字符串和枚举类，这个功能其实也是语法糖</p><div class="tabs" id="5"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#5-1">字符串</button></li><li class="tab"><button type="button" data-href="#5-2">枚举类</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="5-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Candy07 &#123;</span><br><span class="line">    public static void choose(String str) &#123;</span><br><span class="line">        switch (str) &#123;</span><br><span class="line">            case &quot;hello&quot;: &#123;</span><br><span class="line">                System.out.println(&quot;h&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case &quot;world&quot;: &#123;</span><br><span class="line">                System.out.println(&quot;w&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会被编译器转换为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Candy07 &#123;</span><br><span class="line">    public Candy07() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void choose(String str) &#123;</span><br><span class="line">        byte x = -1;</span><br><span class="line">        switch (str.hashCode()) &#123;</span><br><span class="line">            case 99162322:                  // hello 的 hashCode</span><br><span class="line">                if (str.equals(&quot;hello&quot;)) &#123;</span><br><span class="line">                    x = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case 113318802:                 // world 的 hashCode</span><br><span class="line">                if (str.equals(&quot;world&quot;)) &#123;</span><br><span class="line">                    x = 1;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        switch (x) &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                System.out.println(&quot;h&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case 1:</span><br><span class="line">                System.out.println(&quot;w&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看到，执行了两遍switch，第一遍是根据字符串的hashCode和queals将字符串转换为相应byte类型，第二遍才是利用byte进行比较</li><li>那为什么第一遍既要比较hashCode又利用equals比较呢？<ul><li>hashCode是为了提高效率，减少可能的比较</li><li>而equals是为了防止哈希冲突，例如<code>BM</code>和<code>C.</code>这两个字符串的hashCode值都是2123，例如下面的代码</li></ul></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">enum Sex &#123;</span><br><span class="line">    MALE, FEMALE</span><br><span class="line">&#125;</span><br><span class="line">public  static void foo(Sex sex)&#123;</span><br><span class="line">    switch (sex)&#123;</span><br><span class="line">        case MALE:</span><br><span class="line">            System.out.println(&quot;男&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case FEMALE:</span><br><span class="line">            System.out.println(&quot;女&quot;);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Candy08 &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 定义一个合成类（仅 jvm 使用，对我们不可见）</span><br><span class="line">     * 用来映射枚举的 ordinal 与数组元素的关系</span><br><span class="line">     * 枚举的 ordinal 表示枚举对象的序号，从 0 开始</span><br><span class="line">     * 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1</span><br><span class="line">     */</span><br><span class="line">    static class $MAP &#123;</span><br><span class="line">        // 数组大小即为枚举元素个数，里面存储case用来对比的数字</span><br><span class="line">        static int[] map = new int[2];</span><br><span class="line"></span><br><span class="line">        static &#123;</span><br><span class="line">            map[Sex.MALE.ordinal()] = 1;</span><br><span class="line">            map[Sex.FEMALE.ordinal()] = 2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void foo(Sex sex) &#123;</span><br><span class="line">        int x = $MAP.map[sex.ordinal()];</span><br><span class="line">        switch (x) &#123;</span><br><span class="line">            case 1:</span><br><span class="line">                System.out.println(&quot;男&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                System.out.println(&quot;女&quot;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>JDK 7 新增了枚举类，以前面的性别枚举为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum Sex &#123;</span><br><span class="line">    MALE, FEMALE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换后的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public final class Sex extends Enum&lt;Sex&gt; &#123;</span><br><span class="line">    public static final Sex MALE;</span><br><span class="line">    public static final Sex FEMALE;</span><br><span class="line">    private static final Sex[] $VALUES;</span><br><span class="line">    static &#123;</span><br><span class="line">        MALE = new Sex(&quot;MALE&quot;, 0);</span><br><span class="line">        FEMALE = new Sex(&quot;FEMALE&quot;, 1);</span><br><span class="line">        $VALUES = new Sex[]&#123;MALE, FEMALE&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Sole constructor. Programmers cannot invoke this constructor.</span><br><span class="line">     * It is for use by code emitted by the compiler in response to</span><br><span class="line">     * enum type declarations.</span><br><span class="line">     *</span><br><span class="line">     * @param name    - The name of this enum constant, which is the identifier</span><br><span class="line">     *                used to declare it.</span><br><span class="line">     * @param ordinal - The ordinal of this enumeration constant (its position</span><br><span class="line">     *                in the enum declaration, where the initial constant is</span><br><span class="line">     *                assigned</span><br><span class="line">     */</span><br><span class="line">    private Sex(String name, int ordinal) &#123;</span><br><span class="line">        super(name, ordinal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Sex[] values() &#123;</span><br><span class="line">        return $VALUES.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Sex valueOf(String name) &#123;</span><br><span class="line">        return Enum.valueOf(Sex.class, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Sex</code>被声明为一个<code>final</code>类，它继承了<code>Enum&lt;Sex&gt;</code>类，Enum是Java中定义枚举的抽象类。MALE和FEMALE是Sex类的两个枚举值，它们被定义为静态常量。</li><li>除此之外，还有一个私有的、<code>final</code>的<code>Sex</code>类型数组<code>$VALUES</code>，它用于存储Sex类的所有枚举值。在类的静态块中，<code>$VALUES</code>数组被初始化为一个包含<code>MALE</code>和<code>FEMALE</code>的数组。</li><li>构造函数<code>Sex(String name, int ordinal)</code>是私有的，这意味着无法在类的外部使用这个构造函数来创建<code>Sex</code>的实例。只有Java编译器生成的代码才能调用这个构造函数来创建Sex的实例。</li><li><code>values()</code>和<code>valueOf(String name)</code>是从Enum类继承的两个静态方法。<code>values()</code>方法返回一个包含Sex类所有枚举值的数组，<code>valueOf(String name)</code>方法返回指定名称的枚举值。</li><li>当我们使用MALE或者FEMALE时，其实底层调用的是<code>Enum.valueOf(Sex.class, &quot;MALE&quot;)</code>和<code>Enum.valueOf(Sex.class, &quot;FEMALE&quot;)</code></li></ul><h2 id="方法重写时的桥接方法"><a href="#方法重写时的桥接方法" class="headerlink" title="方法重写时的桥接方法"></a>方法重写时的桥接方法</h2><p>方法重写时，对返回值分两种情况</p><ol><li>父类与子类的返回值完全一致</li><li>子类返回值可以是父类返回值的子类（比较绕口，直接看下面的例子来理解）</li></ol><p>这也是为什么重写不能拓展父类方法的返回范围</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    public Number m() &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A &#123;</span><br><span class="line">    @Override</span><br><span class="line">    // 父类A方法的返回值是Number类型，子类B方法的返回值是Integer类型，Integer是Number的子类</span><br><span class="line">    public Integer m() &#123;</span><br><span class="line">        return 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>那么对于子类，编译器会做如下处理</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class B extends A &#123;</span><br><span class="line">    public Integer m() &#123;</span><br><span class="line">        return 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 此方法才是真正重写了父类 public Number m() 方法</span><br><span class="line">    public synthetic bridge Number m() &#123;</span><br><span class="line">        // 调用 public Integer m()</span><br><span class="line">        return m();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的桥接方法比较特殊，仅对Java虚拟机课件，并且与原来的public Integer m()没有命名冲突</p><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>原始Java代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Candy10 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Runnable runnable = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;ok&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换后代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 额外生成的类</span><br><span class="line">final class Candy10$1 implements Runnable &#123;</span><br><span class="line">    Candy10$1() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;ok&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Candy10 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Runnable runnable = new Candy10$1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于匿名内部类，它的底层实现是类似于普通内部类的，只不过没有命名而已。在生成匿名内部类的class文件时，Java编译器会自动为该类生成一个类名，在原始类名上加后缀<code>$1</code>，如果有多个匿名内部类，则<code>$2</code>、<code>$3</code>以此类推</p><p>引用局部变量的匿名内部类，原始Java代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Candy11 &#123;</span><br><span class="line">    public static void test(final  int x)&#123;</span><br><span class="line">        Runnable runnable = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;ok&quot; + x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换后代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 额外生成的类</span><br><span class="line">final class Candy11$1 implements Runnable &#123;</span><br><span class="line">    int val$x;</span><br><span class="line">    Candy11$1(int x) &#123;</span><br><span class="line">        this.val$x = x;</span><br><span class="line">    &#125;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;ok:&quot; + this.val$x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Candy11 &#123;</span><br><span class="line">    public static void test(final int x) &#123;</span><br><span class="line">        Runnable runnable = new Candy11$1(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：这也解释了为什么匿名内部类引用局部变量时，局部变量必须为final的</p><ul><li>因为在创建Candy$11对象时，将x的值赋给了val$x属性，所以x不应该再发生变化了</li><li>如果变化，那么$val$x属性没有机会再跟着一起变化</li></ul><h1 id="类加载阶段"><a href="#类加载阶段" class="headerlink" title="类加载阶段"></a>类加载阶段</h1><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>将类的字节码载入方法区中，内部采用C++的instanceKlass描述Java类，它的重要field有</p><ol><li>_java_mirror：Java的类镜像，例如对String来说，就是String.class，作用是把klass暴露给Java使用</li><li>_super：父类</li><li>_fields：成员变量</li><li>_methods：方法</li><li>_constants：常量池</li><li>_class_loader：类加载器</li><li>_vtable：需方发表</li><li>_itable：接口方法表</li></ol><p>如果这个类还有父类没有加载，先加载父类</p><p>加载和链接可能是交替运行的</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><ul><li>验证类是否符合JVM规范，安全性检查</li><li>使用支持二进制的编辑器修改HelloWorld.class的魔数<code>ca fe ba be</code>，在控制台运行后一定报错</li></ul><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>为static变量分配空间，设置默认值</p><ul><li>static变量在<code>JDK 7</code>之前存储于instanceKlass末尾，从<code>JDK 7</code>开始，存储于_java_mirror末尾</li><li>static变量分配空间和赋值是两个步骤，分配空间在准备阶段完成，赋值在初始化阶段完成</li><li>如果static遍历是final的基本类型以及字符串常量，那么编译阶段值就确定了，赋值在准备阶段完成</li><li>如果static遍历是final的，但属于引用类型，那么赋值也会在初始化阶段完成</li></ul><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>将常量池中的符号引用解析为直接引用</p><ul><li>默认情况下，类的加载都是懒惰式的，如果用到了类C，没有用到类D的话，那么类D是不会主动加载的</li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul><li>初始化即调用<code>&lt;cinit&gt;()V</code> 方法，虚拟机ui保证这个类的<code>构造方法</code>的线程安全</li></ul><p>发生的时机：总的来说，类的初始化是懒惰的</p><ol><li>main方法所在的类，总会被首先初始化</li><li>首次访问这个类的静态变量或静态方法时，会进行初始化</li><li>子类初始化，如果父类还没未初始化，则父类也会进行初始化</li><li>默认的Class.forName会导致初始化</li><li>new对象会导致初始化</li></ol><p>不会导致类初始化的情况</p><ol><li>访问类的 static final 静态常量（基本类型和字符串） 不会触发初始化</li><li>调用类对象.class不会触发初始化</li><li>类加载器的loadClass方法不会触发初始化</li><li>Class.forName的参数2为false时(initalize &#x3D; false)，不会触发初始化</li></ol><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><ul><li>以<code>JDK 8</code>为例</li></ul><table><thead><tr><th align="center">名称</th><th align="center">加载哪的类</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Bootstrap ClassLoader</td><td align="center">JAVA_HOME&#x2F;jre&#x2F;lib</td><td align="center">无法直接访问</td></tr><tr><td align="center">Extension ClassLoader</td><td align="center">JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext</td><td align="center">上级为 Bootstrap，显示为 null</td></tr><tr><td align="center">Application ClassLoader</td><td align="center">classpath</td><td align="center">上级为 Extension</td></tr><tr><td align="center">自定义类加载器</td><td align="center">自定义 上级为</td><td align="center">Application</td></tr></tbody></table><ul><li>当JVM需要加载一个类时，它会首先委托父类加载器去加载这个类，如果父类加载器无法加载这个类，就会由当前类加载器来加载。如果所有的父类加载器都无法加载这个类，那么就会抛出ClassNotFoundException异常。</li></ul><h2 id="引导类加载器"><a href="#引导类加载器" class="headerlink" title="引导类加载器"></a>引导类加载器</h2><ul><li><code>Bootstrap ClassLoader</code>是所有类加载器中最早的一个，负责加载JRE&#x2F;lib下的核心类库，如java.lang.Object、java.lang.String等。</li></ul><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><h3 id="双亲"><a href="#双亲" class="headerlink" title="双亲"></a>双亲</h3><ul><li>所谓双亲委派机制，就是指调用类加载器的loadClass方法时，查找类的规则</li><li>既然称为双亲委派机制，则双亲是必须存在的。ClassLoader类存在一个parent属性。因此可以配置双亲。这个双亲是指ExtClassLoader和AppClassLoader，在JDK中则是这样设置：</li><li>ExtClassLoader.parent&#x3D;null;</li><li>AppClassLoader.parent&#x3D;ExtClassLoader</li><li>XXXClassLoader.parent&#x3D;AppClassLoader</li><li>自定义的类加载器在构建时，如果未指定parent，则使用getSystemClassLoader()来获取父类加载器，而该方法默认获取的就是AppClassLoader。</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310272038937.png"></p><h3 id="委派"><a href="#委派" class="headerlink" title="委派"></a>委派</h3><p>委派过程也就是类文件加载过程，</p><p>加载类文件之前，先验证是否被加载过了，如果加载过就不再加载，防止被覆盖掉，也防止多次加载浪费资源。然后获取类加载器的parent</p><ul><li>如果parent不存在，则说明本身已经是ExtClassLoader了，则查询下类文件是否被Bootstrap ClassLoader加载过，找到就返回，否则返回null。</li><li>如果parent存在，则让父类加载器去加载类文件，这个过程是往上递推的，如 parent-&gt;parent-&gt;parent</li><li>以上流程处理完毕，如果发现返回的是null则说明已经递推到了Bootstrap ClassLoader且仍不能加载，则说明该类文件不符合所有的父类加载器的加载条件，于是便轮到自己来加载了。</li></ul><p>上面说明中往上递推的过程就是委派了，而递推的方式是parent，于是就称为双亲委派机制。当然通俗理解是父类加载器优先加载模式。</p><h2 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h2><p>我们在使用JDBC时，都需要加载Driver驱动，但是我们好像并没有显示的调用Class.forName来加载Driver类</p><p>追一下源码，这里只看最核心的部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class DriverManager &#123;</span><br><span class="line"></span><br><span class="line">    private final static CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    ···</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        loadInitialDrivers();</span><br><span class="line">        println(&quot;JDBC DriverManager initialized&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ···</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出一下DirverManager的类加载器是谁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(DriverManager.class.getClassLoader());</span><br></pre></td></tr></table></figure><ul><li>输出的结果是<code>null</code>，那么说明它是由<code>Bootstrap ClassLoader</code>加载的，那么按理说应该是去<code>JAVA_HOMT/jre/lib</code>下搜索驱动类。</li><li>但<code>JAVA_HOMT/jre/lib</code>显然没有mysql-connector-java-5.7.31.jar包，在DriverManager的静态代码块中，是如何正确加载<code>com.mysql.jdbc.Driver</code>的呢？</li><li>继续来看看loadInitialDrivers()方法的源码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">private static void loadInitialDrivers() &#123;</span><br><span class="line">    String drivers;</span><br><span class="line">    try &#123;</span><br><span class="line">        drivers = AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() &#123;</span><br><span class="line">            public String run() &#123;</span><br><span class="line">                return System.getProperty(&quot;jdbc.drivers&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; catch (Exception ex) &#123;</span><br><span class="line">        drivers = null;</span><br><span class="line">    &#125;</span><br><span class="line">    // If the driver is packaged as a Service Provider, load it.</span><br><span class="line">    // Get all the drivers through the classloader</span><br><span class="line">    // exposed as a java.sql.Driver.class service.</span><br><span class="line">    // ServiceLoader.load() replaces the sun.misc.Providers()</span><br><span class="line"></span><br><span class="line">    // 1. 使用 ServiceLoader 机制加载驱动，即 SPI</span><br><span class="line">    AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">        public Void run() &#123;</span><br><span class="line"></span><br><span class="line">            ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</span><br><span class="line">            Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span><br><span class="line"></span><br><span class="line">            /* Load these drivers, so that they can be instantiated.</span><br><span class="line">             * It may be the case that the driver class may not be there</span><br><span class="line">             * i.e. there may be a packaged driver with the service class</span><br><span class="line">             * as implementation of java.sql.Driver but the actual class</span><br><span class="line">             * may be missing. In that case a java.util.ServiceConfigurationError</span><br><span class="line">             * will be thrown at runtime by the VM trying to locate</span><br><span class="line">             * and load the service.</span><br><span class="line">             *</span><br><span class="line">             * Adding a try catch block to catch those runtime errors</span><br><span class="line">             * if driver not available in classpath but it&#x27;s</span><br><span class="line">             * packaged as service and that service is there in classpath.</span><br><span class="line">             */</span><br><span class="line">            try&#123;</span><br><span class="line">                while(driversIterator.hasNext()) &#123;</span><br><span class="line">                    driversIterator.next();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch(Throwable t) &#123;</span><br><span class="line">            // Do nothing</span><br><span class="line">            &#125;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    println(&quot;DriverManager.initialize: jdbc.drivers = &quot; + drivers);</span><br><span class="line"></span><br><span class="line">    // 2. 使用 jdbc.drivers 定义的驱动名加载驱动</span><br><span class="line">    if (drivers == null || drivers.equals(&quot;&quot;)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] driversList = drivers.split(&quot;:&quot;);</span><br><span class="line">    println(&quot;number of Drivers:&quot; + driversList.length);</span><br><span class="line">    for (String aDriver : driversList) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            println(&quot;DriverManager.Initialize: loading &quot; + aDriver);</span><br><span class="line">            Class.forName(aDriver, true,</span><br><span class="line">                    ClassLoader.getSystemClassLoader());</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            println(&quot;DriverManager.Initialize: load failed: &quot; + ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>先看2，它最后是使用的Class.forName完成类的加载和初始化，关联的是应用类加载器，因此可以顺利完成驱动类的加载</p></li><li><p>在看1，它就是大名鼎鼎的Service Provider Interface（SPI）</p><ul><li>约定如下，在jar包的META-INF&#x2F;services包下，以接口全限定名名为文件，文件内容是实现类名称</li><li>这样就可以使用如下代码遍历来得到实现类</li></ul></li><li><p>体现的是面向接口编程 + 解耦的思想，在下面的一些框架中都运用了此思想</p><ul><li>JDBC</li><li>Servlet初始化器</li><li>Spring容器</li><li>Dubbo（对SPI进行了扩展）</li></ul></li></ul><h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><p>先来思考一下：什么时候需要自定义类加载器</p><ol><li>自定义类加载器可用于加载非 Classpath 路径中的类文件，例如外部配置文件夹、网络资源或其他自定义路径。这种需求在一些动态扩展或插件化的场景中比较常见。</li><li>在应用程序中使用的类可以通过接口来使用，而不是直接引用类。这种做法可以减少应用程序之间的依赖，从而提高代码的灵活性和可维护性。同时，这种做法也使得框架的设计更加清晰和可扩展。</li><li>在Tomcat容器中，每个Web应用程序都使用自己的类加载器，从而避免了不同Web应用程序之间的类冲突问题。</li></ol><p>步骤</p><ol><li>继承ClassLoader类</li><li>遵从双亲委派机制，重写findClass方法<ul><li>注意不要重写loadClass方法，否则不会走双亲委派机制</li></ul></li><li>读取类文件的字节码</li><li>调用父类的defineClass方法来加载类</li><li>使用者调用类加载器的loadClass方法</li></ol><h1 id="运行期优化"><a href="#运行期优化" class="headerlink" title="运行期优化"></a>运行期优化</h1><h2 id="即时编译"><a href="#即时编译" class="headerlink" title="即时编译"></a>即时编译</h2><h3 id="分层编译（TieredComlilation）"><a href="#分层编译（TieredComlilation）" class="headerlink" title="分层编译（TieredComlilation）"></a>分层编译（TieredComlilation）</h3><p>JVM将执行状态分为5个层次</p><ul><li>0层：解释执行（Interpreter）<ul><li>在0层，JVM使用解释器来直接解释Java字节码，并执行程序。这种方式简单但效率较低，因为解释器需要逐条解释字节码指令，并执行它们，每次执行时都需要对字节码进行解析</li></ul></li></ul><ul><li>1层：使用C1即时编译器编译执行（不带profilling）<ul><li>在1层，JVM会使用即时编译器（JIT）将Java字节码编译成本地机器码，然后直接执行机器码。这种方式相比于解释器，可以提供更高的执行速度。C1即时编译器适合编译执行热点代码，即被频繁执行的代码</li></ul></li><li>2层：使用C1即时编译器编译执行（带基本的profilling）<ul><li>在2层，JVM会收集一些基本的执行状态数据，即profilling。例如方法的调用次数、循环的回边次数等，然后根据这些数据来决定哪些代码块需要被编译执行。这种方式可以更加精确地编译热点代码，从而提高程序的执行速度</li></ul></li><li>3层：使用C1即时编译器编译执行（带完全的profilling）<ul><li>在3层，JVM会收集更加详细的执行状态数据，例如内联调用的次数、方法的参数类型等，以便更好地优化代码。这种方式可以进一步提高程序的执行速度，但同时也会增加编译的开销</li></ul></li><li>4层：使用C2即时编译器编译执行<ul><li>在4层，JVM会使用更高级别的即时编译器（C2）来对代码进行优化，包括对循环、分支和递归等结构的优化。C2编译器的编译时间比C1场，但编译出来的代码执行速度更快。</li></ul></li></ul><h4 id="即时编译器（JIT）和解释器的区别"><a href="#即时编译器（JIT）和解释器的区别" class="headerlink" title="即时编译器（JIT）和解释器的区别"></a>即时编译器（JIT）和解释器的区别</h4><ul><li>解释器是将字节码解释为机器码，下次即使遇到相同的字节码，仍会执行重复的解释</li><li>JIT是将一些字节码编译为机器码，并存入<code>Code Cache</code>，下次遇到相同的代码，<code>直接执行</code>，无需再次编译</li><li>解释器是将字节码解释为针对所有平台都通用的机器码</li><li>JIT会根据平台类型，生成平台特定的机器码</li></ul><p>对于占据大部分的不常用的代码，我们无需耗费时间将其编译成<code>机器码</code>，而是采用<code>解释器执行</code>的方法运行；</p><p>另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成<code>机器码</code>，以达到理想的运行<code>速度</code>。</p><p>执行效率上简单比较一下：<code>Interceptor &lt; C1 &lt; C2</code></p><p>上面代码中最后的耗时都在300附近，这是C2即时编译器做了逃逸分析，因为上面的代码中，我们仅仅是创建了Object对象，而并没有使用它，也就是没有逃逸出当前作用域</p><ul><li>在进行逃逸分析时，JVM会分析对象是否可能被线程外的代码引用，如果对象不会逃逸出当前方法的作用域，那么JVM会将对象的分配<code>优化为栈上分配</code>，从而避免了堆内存的分配和垃圾回收的压力。</li></ul><p>将对象分配在栈上的优点是：</p><ol><li><code>快速分配和回收</code>：栈内存的分配和回收都非常快，比堆内存要快得多。如果对象可以在栈上分配，那么它的分配和回收都可以更快，从而提高程序的性能。</li><li><code>减少垃圾回收</code>：在Java中，对象的分配和回收是由垃圾回收器来完成的。如果对象可以在栈上分配，那么它就不会对堆内存的使用和垃圾回收产生影响，从而可以减少垃圾回收的频率和时间，提高程序的性能。</li></ol><h3 id="方法内联-Inlining"><a href="#方法内联-Inlining" class="headerlink" title="方法内联(Inlining)"></a>方法内联(Inlining)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static int square(int i) &#123;</span><br><span class="line">    return i * i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(square(9));</span><br></pre></td></tr></table></figure><ul><li>如果发现square是热点方法，且长度不太长时，会进行内联，所谓的内联就是把方法内代码拷贝，并粘贴到调用者的位置</li></ul><h2 id="反射优化"><a href="#反射优化" class="headerlink" title="反射优化"></a>反射优化</h2><ul><li><p>示例代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class Reflect1 &#123;</span><br><span class="line">    public static void foo() &#123;</span><br><span class="line">        System.out.println(&quot;foo...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Method foo = Reflect1.class.getMethod(&quot;foo&quot;);</span><br><span class="line">        for (int i = 0; i &lt;= 16; i++) &#123;</span><br><span class="line">            System.out.printf(&quot;%d\t&quot;, i);</span><br><span class="line">            foo.invoke(null);</span><br><span class="line">        &#125;</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>首先定义了一个名为<code>foo</code>的静态方法，该方法只是简单地输出一条字符串。</p></li><li><p>然后在main方法中，使用<code>Reflect1</code>类的<code>getMethod</code>方法获取名为<code>foo</code>的<code>Method</code>对象，以便之后进行反射调用。</p></li><li><p>接着使用循环调用反射方法，循环次数从0到16，每次循环都调用反射获取的Method对象的<code>invoke</code>方法，传入<code>null</code>作为静态方法的调用者。因为<code>foo</code>方法是静态方法，所以调用者可以为null。</p></li><li><p>最后使用<code>System.in.read()</code>方法暂停程序的运行，以便我们可以观察程序的输出结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package sun.reflect;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import sun.reflect.misc.ReflectUtil;</span><br><span class="line"></span><br><span class="line">class NativeMethodAccessorImpl extends MethodAccessorImpl &#123;</span><br><span class="line">    private final Method method;</span><br><span class="line">    private DelegatingMethodAccessorImpl parent;</span><br><span class="line">    private int numInvocations;</span><br><span class="line"></span><br><span class="line">    NativeMethodAccessorImpl(Method var1) &#123;</span><br><span class="line">        this.method = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object invoke(Object var1, Object[] var2) throws IllegalArgumentException, InvocationTargetException &#123;</span><br><span class="line">        if (++this.numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(this.method.getDeclaringClass())) &#123;</span><br><span class="line">            MethodAccessorImpl var3 = (MethodAccessorImpl)(new MethodAccessorGenerator()).generateMethod(this.method.getDeclaringClass(), this.method.getName(), this.method.getParameterTypes(), this.method.getReturnType(), this.method.getExceptionTypes(), this.method.getModifiers());</span><br><span class="line">            this.parent.setDelegate(var3);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return invoke0(this.method, var1, var2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void setParent(DelegatingMethodAccessorImpl var1) &#123;</span><br><span class="line">        this.parent = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static native Object invoke0(Method var0, Object var1, Object[] var2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>前15次调用使用的是NativeMethodAccessorImpl实现的MethodAccessor，该实现类使用JNI调用底层的C&#x2F;C++代码实现方法调用。由于NativeMethodAccessorImpl的实现开销较大，因此前15次的反射调用的性能相对较差。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static int inflationThreshold = 15;</span><br></pre></td></tr></table></figure></li><li><p>而第16次调用则采用了GeneratedMethodAccessor1实现的MethodAccessor，这个实现类通常是使用Java字节码动态生成的，因此方法调用的性能比NativeMethodAccessorImpl更好。这是因为在第15次调用时，生成了一个新的MethodAccessorImpl实现类（MethodAccessorGenerator），并在下一次方法调用时使用该实现类，即第16次调用。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 字节码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java抽象类和接口</title>
      <link href="/2023/10/27/Java%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/"/>
      <url>/2023/10/27/Java%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>关键字：abstract</p><p>当父类的某些方法需要声明，却不知道如何实现时，可以将其声明为抽象方法。那个场合，要将该类声明为 <code>abstract</code> 类。</p><p>抽象类的价值更多是用于设计。设计者设计好后，让子类继承并实现。也是考官爱问的考点。</p><p>定义抽象类：<code>访问修饰符 abstract 类名&#123;...&#125;</code></p><p>定义抽象方法：<code>访问修饰符 abstract 返回值 方法名(形参列表);</code></p><blockquote><p>无方法体，不写{ }</p></blockquote><h3 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h3><ol><li>抽象类不能被实例化</li><li>抽象类不一定包含抽象方法。也就是说，<strong>抽象类可以没有 <code>abstract</code>方法</strong></li><li><strong>一旦包含 abstract 方法，则该类一定要声明为 abstract</strong></li><li><code>abstract</code> <strong>只能修饰 类 和 方法</strong>，不能修饰其他。</li><li>抽象类可以有任意成员（非抽象方法、构造器、静态属性等）。即，<strong>抽象类本质还是类</strong>。</li><li>抽象方法不能有主体。即，抽象方法不能实现。</li><li>如果一个类继承了 <code>abstract</code> 类，则其必须实现所有 <code>abstract</code> 方法，除非其自己也是 <code>abstract</code> 类。</li><li>抽象方法不能用 <code>private</code> <code>final</code> <code>static</code> 来修饰。因为，这些关键词都和 重写 相违背。</li></ol><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>语法：<code>interface 接口名&#123;...&#125;</code></p><p>Java是单继承的，接口帮助增强了继承的性能。</p><p>接口就是给出一些没有实现的方法，封装到一起，到某个类要用的时候，再根据具体情况把这些方法写出来。在接口中，抽象方法可以省略 <code>abstract</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class 类名 implements 接口名&#123;...必须实现接口的抽象方法...&#125;</span><br></pre></td></tr></table></figure><blockquote><p>JDK 7.0 以前，接口中只能是抽象方法。而 JDK 8.0 后，接口可以有静态（<code>static</code>）方法、默认（<code>default</code>）方法。</p></blockquote><p>接口中可以存在：</p><ul><li>属性（只有静态 <code>static</code> 属性，可以不加 <code>static</code> 关键字）</li><li>方法（抽象 <code>abstract</code> 方法、默认 <code>default</code> 实现方法、静态 <code>static</code> 方法）</li></ul><h2 id="使用细节-1"><a href="#使用细节-1" class="headerlink" title="使用细节"></a>使用细节</h2><ol><li>接口 不能被实例化。</li><li>接口中所有方法都是 <code>public</code> 方法。接口中的 抽象方法 可以不用 <code>abstract</code> 修饰。</li><li>一个普通类实现接口，就必须把该接口所有方法都实现。（快捷键 <code>alt + enter</code>）</li><li>抽象类实现接口，可以不用实现接口的方法。</li><li>一个类可以同时实现多个接口。<code>class Name implements In1,In2&#123;...&#125;</code></li><li>接口中的属性只能是 <code>final</code> 的，并且是 <code>public static final</code> 修饰符。修饰符就算不写，还是这样。</li><li>接口中属性的访问形式：<code>接口名.属性名</code></li><li>接口不能 <strong>继承</strong> 其他的类，但可以 <strong>继承</strong> 多个别的接口。（不是也不能 实现 别的接口）</li><li>接口的修饰符只能是 <code>public</code> 和 默认。这点和类的修饰符相同</li></ol><h2 id="实现接口-vs-继承类"><a href="#实现接口-vs-继承类" class="headerlink" title="实现接口 vs 继承类"></a>实现接口 vs 继承类</h2><ol><li>当子类继承父类，就自动拥有父类的所有功能。如果需要扩展功能，可以通过接口方式扩展。</li><li>可以认为，接口 是对于 Java 单继承机制的补充。</li><li>继承的价值主要在于：解决代码的复用性和可维护性。</li><li>接口的价值主要在于：设计。设计好各种规范，让其他类去实现这些方法。</li><li>接口比继承更加灵活。继承需要满足 is - a 的关系，而接口只需要满足 like - a 关系。</li><li>接口在一定程度上实现代码解耦。（即：接口规范性 + 动态绑定机制）</li></ol><h2 id="接口的多态特性"><a href="#接口的多态特性" class="headerlink" title="接口的多态特性"></a>接口的多态特性</h2><ol><li><p>多态参数（接口的引用可以指向实现了接口的类的对象）</p><blockquote><p><code>viod work(Inerface01 i1)&#123;...&#125;</code> 参数可以传入任意实现该接口的类</p></blockquote></li><li><p>多态数组</p></li><li><p>接口存在多态传递现象</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 抽象类 </tag>
            
            <tag> 接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象特性</title>
      <link href="/2023/10/27/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%80%A7/"/>
      <url>/2023/10/27/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>包的作用：</p><ol><li>区分相同名字的类</li><li>当类很多时，便于管理 </li><li>控制访问范围</li></ol><p>语法：<code>package com.name</code> 其中 <code>com</code> <code>name</code> 分别是 一级 和 二级目录，用 <code>.</code> 分隔</p><p>包的本质：就是创建不同 文件夹&#x2F;目录 来保存 类 文件</p><p><strong>使用：</strong></p><ol><li><p>先引入包，之后创建对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import com.name.T;</span><br><span class="line">...</span><br><span class="line">T tools = new T();</span><br></pre></td></tr></table></figure></li><li><p>不引入包，而在创建对象时写全路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.name.T tools = new com.name.T();</span><br></pre></td></tr></table></figure></li></ol><p><strong>命名规则：</strong></p><ul><li>只能包含 数字 <code>1 2 3</code>、字母 <code>a b A b</code>、下划线 <code>_</code>、小圆点 <code>.</code></li><li>不能用 数字 开头。每级目录都不能。</li></ul><p><strong>命名规范：</strong></p><ul><li>全小写字母 + 小圆点</li><li><code>com.公司名.项目名.业务模块名</code></li></ul><p><strong>常用的包：</strong></p><p><code>java.lang</code>：基本包，默认引入，不需要再引入</p><p><code>java.util</code>：系统提供的工具包。工具类。</p><p><code>java.net</code>：网络包，网络开发。</p><p><code>java.awt</code>：Java 的界面开发，GUI。</p><p><strong>引入包：</strong></p><ul><li>只引入该包下的一个类：<code>import java.util.Scanner</code></li><li>引入该包的所有内容（不建议）：<code>import java.util.*</code></li></ul><p><strong>使用细节：</strong></p><ol><li><p><code>package</code> 的作用是声明当前类所在的包，要放在 类 的 最上面。一个 类 中最多有一句 <code>package</code></p></li><li><p><code>import</code> 放在 <code>package</code> 下面，类定义 前面。可以有多条语句，且没有顺序要求</p></li><li><p>编译器编译时 <strong>不会</strong> 检查目录结构。</p><p>即使一个包处于错误的目录下（只要其不依赖其他包）也可能通过编译。</p><p>但是，虚拟机会找不到该包，最终程序无法运行。</p></li><li><p>从 1.2 版本开始，用户不能再把包放在 java. 开头的目录下了。若如此做，这些包会被禁止加载</p></li></ol><p><strong>静态导入</strong>:</p><p>有一种 import 语句允许导入静态方法和字段，而不只是类</p><p>比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import static java.lang.Math.*;</span><br></pre></td></tr></table></figure><p>这个场合，使用 Math 包内的静态方法、字段时，不需要再添加类名前缀。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double n = pow(10, 5);//本来是 double n = Math.pow(10, 5);</span><br><span class="line">double pi = PI;//本来是 double pi = Math.PI;</span><br></pre></td></tr></table></figure><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><blockquote><p>封装（encapsulation）就是把抽象出的 数据[属性] 和对数据的 操作[方法] 封装在一起。数据 被保护在内部，程序的其他部分只有通过被授权的 操作[方法]，才能对数据进行操作。</p></blockquote><p>封装的好处：</p><ul><li>隐藏实现细节</li><li>可以对数据进行验证，保证安全合理</li></ul><p><strong>实现步骤：</strong></p><ol><li>将属性私有化 <code>private</code></li><li>提供一个公共的 <code>set</code> 方法，用于对属性判断并赋值</li><li>提供一个公共的 <code>get</code> 方法，用于获取属性的值</li></ol><blockquote><p>一般都快捷键生成</p></blockquote><p><strong>JAR 文件</strong>：</p><p>为了避免向用户提供包含大量类文件的复杂目录结构，可以将 Java 程序打包成 JAR （Java 归档）文件。</p><p>一个 JAR 文件既可以包含类文件，也可以包含诸如图像和声音等其他类型的文件。</p><p>JAR 文件是压缩的。其使用了 ZIP压缩格式。</p><blockquote><p>Maven里面就经常见到 jar 和 war</p></blockquote><p><strong>创建 JAR：</strong></p><p>使用 jar 工具以制作 JAR 文件。该工具在 jdk&#x2F;bin 目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar cvf 包名 文件名1 文件名2 ...</span><br></pre></td></tr></table></figure><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>关键字：extends</p><p>继承：能解决代码复用，让我们的编程更接近人类思维。当多个类存在相同的 属性（变量）和 方法 时，可以从这些类中抽象出 父类（基类&#x2F;超类）。在 父类 中定义这些属性·方法，所有的子类不需要重新定义这些属性和方法，只需要通过 extends 来声明继承父类即可。</p><p>通过继承的方法，代码的复用性提高了，代码的维护性和拓展性也提高了。</p><p>定义类时可以指明其父类，也能不指明。不指明的场合，默认继承 Object 类。</p><p>所有类有且只有一个父类。Object 是所有类的直接或间接父类。只有 Object 本身没有父类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Son extends Father &#123;&#125;;// Son 类继承了 Father 类</span><br></pre></td></tr></table></figure><h2 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h2><ol><li>子类 继承了所有属性和方法，但私有（<code>private</code>）的 属性·方法 不能在 子类 直接访问。要调用父类提供的 公共（<code>public</code>）等方法 访问。</li><li>子类 必须调用 父类 的 构造器，完成 父类 的 初始化。</li><li>当创建 子类对象 时，不管使用 子类的哪个构造器，默认情况下总会调用 父类的无参构造器。如果 父类 没有提供 无参构造器，则必须在 子类的构造器 中用 <code>super</code> 去指定使用 父类的哪个构造器 完成 对父类的初始化。否则编译不能通过。</li><li>如果希望指定调用 父类的某构造器，则显式地调用一下：<code>super(形参列表);</code></li><li><code>super</code> 在使用时，必须放在构造器第一行。<code>super</code> 只能在构造器中使用。</li><li>由于 <code>super</code> 与 <code>this</code> 都要求放在第一行，所以此两个方法不能同时存在于同一构造器。</li><li>Java 所有的类都是 <code>Object</code> 的子类。换言之，<code>Object</code> 是所有类的父类。</li><li>父类构造器的调用不限于直接父类，将持续向上直至追溯到顶级父类 <code>Object</code></li><li>子类 最多只能直接继承 一个 父类。即，Java 中是 单继承机制。</li><li>不能滥用继承。子类 和 父类 之间必须满足 is - a 的逻辑关系。</li></ol><h2 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h2><p>super 代表父类的引用。用于访问父类的 属性、方法、构造器。</p><p><strong>super 的使用：</strong></p><ul><li><code>super.属性名</code>：访问父类的属性。不能访问父类的私有（private）属性。</li><li><code>super.方法名(形参列表)</code>：访问父类的方法。不能访问父类的私有（private）方法。</li><li><code>super(参数列表);</code>：访问父类的构造器。此时，super 语句必须放在第一句。</li></ul><p><strong>使用细节：</strong></p><ol><li>调用父类构造器，好处是分工明确。父类属性由父类初始化，子类由子类初始化。</li><li>子类中由和父类中成员（属性和方法）重名时，要调用父类成员必须用 <code>super</code>。没有重名的场合，<code>super</code>、<code>this</code> 及直接调用的效果相同。</li><li><code>super</code> 的访问不限于直接父类。如果爷爷类和本类中都有同名成员也能使用。如果多个基类中都有同名成员，则遵循就近原则。</li></ol><h2 id="方法重写-x2F-覆盖"><a href="#方法重写-x2F-覆盖" class="headerlink" title="方法重写 &#x2F; 覆盖"></a>方法重写 &#x2F; 覆盖</h2><blockquote><p>方法重写&#x2F;覆盖（Override）：如若子类有一个方法，和父类的某方法的 <strong>名称</strong>、<strong>返回类型</strong>、<strong>参数</strong> 一样，那么我们就说该子类方法 覆盖 了那个父类方法。</p></blockquote><p><strong>使用细节：</strong></p><ol><li><p><strong>子类方法的参数，方法名称，要和父类方法完全一致。</strong></p></li><li><p>子类方法的返回类型需和父类方法 一致，或者是父类返回类型的子类。</p><p>根据相关语法糖，实际上生成了一个中间方法，这个方法的返回值是父类方法的返回值，根据多态，中间方法可以接受所有父类方法的返回值的子类</p></li><li><p>子类方法 <strong>不能缩小</strong> 父类方法的访问范围（访问修饰符）</p></li></ol><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态：方法 或 对象 有多种形态。多态 是面向对象的第三大特征，是建立在 封装 和 继承 的基础之上的</p><p>多态的前提：两个对象 &#x2F; 类存在继承关系。</p><h2 id="多态的体现"><a href="#多态的体现" class="headerlink" title="多态的体现"></a>多态的体现</h2><ol><li><p>方法的多态：重写 和 重载 体现了 方法的多态。</p></li><li><p><strong>对象的多态：</strong></p><p>一个对象的 编译类型 和 运行类型 可以不一致。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = new Dog();</span><br></pre></td></tr></table></figure><p>上例，编译类型是 <code>Animal</code>，运行类型是子类 <code>Dog</code></p></li><li><p>编译类型在定义对象时就确定了，不能改变。</p></li><li><p>运行类型是可以变化的。</p><p>上例中，再让 <code>animal = new Cat();</code>，这样，运行类型变为了 <code>Cat</code></p></li><li><p>编译类型看定义时 <code>=</code> 的左边，运行类型看 <code>=</code> 的右边</p></li><li><h2 id="多态的向下转型："><a href="#多态的向下转型：" class="headerlink" title="多态的向下转型："></a>多态的向下转型：</h2></li><li><p>属性没有重写一说。<strong>和 方法 不同，属性的值 看编译类型。</strong></p></li><li><p><code>instanceof</code> 比较操作符。用于判断对象类型是否是某类型或其子类型。此时判断的是 <strong>运行类型</strong>。</p></li></ol><h2 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h2><ul><li>本质：父类的引用指向了子类的对象。</li><li>语法：父类类型 引用名 &#x3D; new 子类类型(参数列表);</li><li>编译类型看左边，运行类型看右边。</li><li>可以调用父类中的所有成员，但不能调用子类特有的成员，而且需要遵守访问权限。因为在编译阶段，能调用哪些成员是由编译类型决定的。</li><li>最终的运行结果要看子类的具体实现。实际上先在运行类型（子类）中找相关的属性和方法，没有在调用编译类型（父类）的</li></ul><h2 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h2><ul><li><p>语法：<code>子类类型 引用名 = (子类类型)父类引用;</code></p><p>向下转型其实和 强制类型转换有点像。</p><p><code>Dog dog = (Dog)animal;</code></p></li><li><p>只能强转父类的引用，不能强转父类的对象。</p></li><li><p>要求父类的引用必须指向的是当前目标类型的对象。即上例中的 <code>animal</code> 运行类型需是 <code>Dog</code>，换成cat会报错</p></li><li><p>向下转型后，可以调用子类类型中的所有成员。</p></li></ul><h2 id="理解方法调用"><a href="#理解方法调用" class="headerlink" title="理解方法调用"></a>理解方法调用</h2><p>在对象上调用方法的过程如下：</p><ol><li><p>编译器查看对象的声明类型和方法名。该类和其父类中，所有同名方法（包括参数不同的方法）都被列举。</p><p>至此，编译器已经知道所有可能被调用的方法。</p></li><li><p>编译器确认方法调用中提供的参数类型。</p><p>那些列举方法中存在参数类型完全匹配的方法时，即调用该方法。</p><p>没有发现匹配方法，抑或是发现经过类型转换产生了多个匹配方法时，就会报错</p><p>至此，编译器已经知道要调用方法的名字和参数类型</p></li><li><p>如若是 private 方法、static 方法、final 方法、构造器，那么编译器将能准确知道要调用哪个方法。这称为 <strong>静态绑定</strong></p><p>与之相对的，如果调用方法依赖于隐式参数类型，那么必须在运行时 <strong>动态绑定</strong></p></li><li><p>程序运行并采取动态绑定方法时，JVM 将调用那个 <strong>实际类型</strong> 对应的方法。</p></li></ol><p>倘若每次调用方法都进行以上搜索，会造成庞大的时间开销。为此，JVM 预先为每个类计算了 <strong>方法表</strong>。</p><p>方法表中列举了所有方法的签名与实际调用的方法。如此，每次调用方法时，只需查找该表即可。</p><p>特别地，使用 super 关键字时，JVM 会查找其父类的方法表。</p><p><strong>动态绑定机制：</strong></p><ul><li>当调用对象方法的时候，该方法和该对象（隐式参数）的内存地址&#x2F;运行类型绑定。</li><li>当调用对象属性时，没有动态绑定机制。于是哪里声明，哪里调用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 封装 </tag>
            
            <tag> 继承 </tag>
            
            <tag> 多态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM垃圾回收</title>
      <link href="/2023/10/26/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
      <url>/2023/10/26/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="如何判断对象可以回收"><a href="#如何判断对象可以回收" class="headerlink" title="如何判断对象可以回收"></a>如何判断对象可以回收</h1><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><ul><li><p>当一个对象被引用是，就当引用对象的值<code>+1</code>，当引用对象的值为<code>0</code>时，则说明该对象没有被引用，那么就可以被垃圾回收器回收</p></li><li><p>这个引用计数法听起来很不错，而且实现起来也非常的简单，可是它有一个弊端，如下图所示，当两个对象循环引用时，两个对象的计数都未1，就导致这两个对象都无法被释放</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310261833901.png"></p></li></ul><h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>JVM垃圾回收机制的可达性分析算法，是一种基于引用的垃圾回收算法。其基本思想是通过一系列被称为”GC Roots”的根对象作为起点，寻找所有被根对象直接或间接引用的对象，将这些对象称为”可达对象”，而没有被找到的对象则被视为”不可达对象”，需要被回收。</p><blockquote><p>形象一点理解就是我有一串葡萄，我把这串葡萄拿起来，连在根上的葡萄就是好的(可达对象)，而掉在盘子里的葡萄就是坏的(不可达对象)，需要被回收</p></blockquote><p>在JVM中，有四种类型的GC Roots对象：</p><ol><li><code>虚拟机栈中引用的对象</code>：虚拟机栈是用于存储方法调用和执行的栈空间。当一个方法被调用时，会在栈中创建一个栈帧，用于存储该方法的局部变量、参数和返回值等信息。如果栈帧中包含对某个对象的引用，那么这个对象就被视为GC Roots对象。</li><li><code>方法区中类静态属性引用的对象</code>：方法区是用于存储类信息、常量池、静态变量等信息的内存区域。当一个类被加载到方法区时，其中的静态属性会被分配在方法区中，如果这些静态属性中包含对某个对象的引用，那么这个对象就被视为GC Roots对象。</li><li><code>方法区中常量引用的对象</code>：常量池是方法区的一部分，用于存储常量。如果常量池中包含对某个对象的引用，那么这个对象就被视为GC Roots对象。</li><li><code>本地方法栈中JNI引用的对象</code>：JNI是Java Native Interface的缩写，用于在Java程序中调用本地方法（即由C或C++等语言编写的方法）。当本地方法被调用时，会在本地方法栈中创建一个栈帧，如果该栈帧中包含对某个对象的引用，那么这个对象就被视为GC Roots对象。</li></ol><ul><li>可达性分析算法基于这些GC Roots对象，通过遍历所有的引用链，找到所有可达对象，将它们标记为存活对象，而没有被找到的对象则被视为不可达对象，需要被回收。</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>主要优点：可以处理复杂的引用结构，例如循环引用、交叉引用等情况，能够识别出所有可达对象，从而准确地进行垃圾回收。</li><li>缺点：例如需要耗费较多的时间进行垃圾回收、可能会出现漏标和误标等问题。为了解决这些问题，JVM中还采用了其他的垃圾回收算法，如标记-清除算法、复制算法、标记-整理算法等，以提高垃圾回收的效率和准确性。</li></ul><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><ul><li><p>在Java中，对象不仅可以被正常引用，还可以被特殊的引用类型引用。这些引用类型决定了垃圾回收器如何对对象进行回收。</p></li><li><p>JVM中共有五种引用类型，它们分别是</p><ol><li><p>强引用（Strong Reference）：</p><p>是最常见的引用类型，也是默认的引用类型。如果一个对象具有强引用，那么即使内存空间不足，垃圾回收器也不会回收它。只有当该对象的所有强引用都失效时，对象才会被回收</p></li><li><p>软引用（Soft Reference）：</p><p>是一种比强引用弱一些的引用类型。如果一个对象只具有软引用，那么当内存空间不足时，垃圾回收器可能会回收它。软引用通常用于实现内存敏感的缓存</p><p>可以配合引用队列来释放软引用自身</p></li><li><p>弱引用（Weak Reference）：</p><p>是一种比软引用更弱一些的引用类型。如果一个对象只具有</p><p>弱银用，那么垃圾回收器在下一次运行时，无论内存空间是否足够，都会回收该对象。若引用通常用于实现在对象可用时进行操作的场景</p><p>可以配合引用队列来释放软引用自身</p></li><li><p>虚引用（Phantom Reference）：</p><p>是最弱的一种引用类型。如果一个对象只具有虚引用，那么在任何时候都可能被垃圾回收器回收。虚引用通常用于追踪对象被垃圾回收的状态</p><p>必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存</p></li><li><p><code>终结器引用（Final Reference）：</code>是一种特殊的弱引用类型，它只在对象被回收时被添加到引用队列中。当垃圾回收器准备回收一个对象时，会先执行对象的finallize()方法，如果finalize()方法中没有重新让对象与其他对象建立联系，那么这个对象就会被回收，并且它的Final引用会被加入到引用队列中。Final引用通常用于对象回收后的清理工作</p></li></ol></li><li><p>软引用、弱引用和虚引用则是用于管理一些比较特殊的对象。使用引用队列可以方便地跟踪这些特殊对象的垃圾回收状态，帮助我们及时释放对象占用的资源。</p></li><li><p>使用引用队列来管理这些特殊对象的方式是，在创建这些对象时，同时指定一个引用队列。当垃圾回收器回收这些对象时，会自动将其添加到与之关联的引用队列中。我们可以在某个时刻检查引用队列中是否有特殊对象，并对其进行处理，比如将其从相应的数据结构中删除，以便释放特殊对象占用的资源。</p></li></ul><h2 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h2><h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><div class="tabs" id="1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#1-1">标记清除</button></li><li class="tab"><button type="button" data-href="#1-2">标记整理</button></li><li class="tab"><button type="button" data-href="#1-3">复制</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><ul><li>标记清除是一种常见的垃圾回收算法之一，其工作原理如下：<ol><li><code>标记阶段（Mark）</code>：从根对象开始遍历内存中的所有对象，将所有能够被访问到的对象做上标记，表示这些对象是活动的。</li><li><code>清除阶段（Sweep）</code>：遍历整个内存空间，将未被标记的对象视为垃圾，将其占用的内存资源进行回收。</li></ol></li><li>标记清除算法的优点在于它简单易用，可以快速地回收大量的垃圾对象。但是，它也存在一些缺点，例如在清除和压缩阶段中可能会产生较大的内存碎片，从而影响后续的内存分配效率。此外，标记清除算法无法处理循环引用的情况，需要借助其他算法来处理循环引用问题，例如标记-压缩算法和复制算法等。</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310261839933.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-2"><ul><li>在标记整理算法中，标记和清除阶段和标记清除算法是一样的，只有在内存整理阶段不同。在整理阶段，标记整理算法会将所有存活的对象向内存的一端移动，之后将移动后的内存末尾地址作为堆的新起始地址，之前的地址空间被标记为空闲，可以用来分配新的对象。</li><li>需要注意的是，标记整理算法的整理阶段可能会比较耗时，因为它需要移动对象，这也是它的一个缺点。但是，由于它可以消除内存碎片，提高内存利用率，所以在需要长时间运行的应用程序中，标记整理算法通常比标记清除算法更加适用。</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310261840029.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-3"><ul><li>复制算法是一种基于内存分区的垃圾回收算法，它将内存分成两个区域：From空间和To空间。在正常情况下，所有的对象都被分配在From空间中。当需要进行垃圾回收时，算法会扫描From空间中的所有对象，并将存活的对象复制到To空间中。复制完成后，From空间中的对象都可以被视为垃圾，并可以被回收。</li><li>接下来，详细介绍一下复制算法的工作原理：<ol><li><code>内存分配：</code>在程序运行过程中，对象的内存分配只在From空间中进行。当From空间快要用完时，算法会触发一次垃圾回收操作。</li><li><code>扫描存活对象：</code>在进行垃圾回收时，算法会遍历From空间中的所有对象，并标记存活的对象。为了标记存活对象，复制算法使用了一种叫做<code>可达性分析</code>的技术，这个技术可以判断一个对象是否是存活对象。与标记清除算法和标记整理算法不同的是，复制算法并不需要进行标记和清除的分离过程，因为复制算法是将存活对象复制到To空间中，所以只要扫描完From空间中的所有对象，并将存活对象复制到To空间中，就可以直接清除From空间了。</li><li><code>复制存活对象：</code>在扫描存活对象之后，算法会将所有存活对象从From空间复制到To空间。复制的过程是按照对象的存活顺序进行的，也就是说，如果对象A引用了对象B，那么对象B会被先复制到To空间中。复制完成后，To空间的使用量会变得很满，From空间的使用量则变得很少。</li><li><code>交换空间：</code>在复制完所有存活对象之后，From空间中剩余的对象都可以视为垃圾，并可以被回收。为了保证下一次的内存分配，To空间和From空间会进行交换，也就是说，To空间成为了新的From空间，From空间成为了新的To空间。这样一来，内存分配就可以在新的From空间中进行了。</li></ol></li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310261840582.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>总结一下这三种垃圾回收算法的优缺点</p><ol><li><code>标记清除：</code>速度较快，但会产生内存碎片</li><li><code>标记整理：</code>速度较慢，但是不会产生内存碎片</li><li><code>复制：</code>不会产生内存碎片，但是需要占用双倍内存空间</li></ol><h1 id="分代垃圾回收"><a href="#分代垃圾回收" class="headerlink" title="分代垃圾回收"></a>分代垃圾回收</h1><p>JVM（Java虚拟机）的分代垃圾回收是一种优化内存回收的技术。它利用对象的生命周期来将堆（heap）分为不同的区域，然后针对不同区域的特点采用不同的垃圾回收算法。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310261841314.png"></p><ol><li>对象首先分配在伊甸园区域</li><li>新生代空间不足时，触发<code>minor gc</code>，<code>伊甸园</code>和<code>from</code>存活的对象使用<code>copy</code>复制到<code>to</code>中，存活的对象年龄<code>+1</code>并且交换<code>from</code>和<code>to</code></li><li><code>minor gc</code>会引发<code>stop the world（砸瓦鲁多！！）</code>，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</li><li>当对象寿命超过阈值时，会晋升至老年代，最大寿命是15<ul><li>Java中的对象头中确实分配了一定的字节用来记录对象的年龄，而这个字节的位数是4，因此其二进制最大值为1111，即十进制的15</li></ul></li><li>当老年代空间不足，会先尝试触发<code>minor gc</code>，如果之后空间仍不足，那么触发<code>full gc</code>，STW的时间更长</li></ol><h2 id="相关VM参数"><a href="#相关VM参数" class="headerlink" title="相关VM参数"></a>相关VM参数</h2><table><thead><tr><th align="center">含义</th><th align="center">参数</th></tr></thead><tbody><tr><td align="center">堆初始大小</td><td align="center">-Xms</td></tr><tr><td align="center">堆最大大小</td><td align="center">-Xmx 或 -XX:MaxHeapSize&#x3D;size</td></tr><tr><td align="center">新生代大小</td><td align="center">-Xmn 或 (-XX:NewSize&#x3D;size + -XX:MaxNewSize&#x3D;size )</td></tr><tr><td align="center">幸存区比例（动态）</td><td align="center">-XX:InitialSurvivorRatio&#x3D;ratio 和 -XX:+UseAdaptiveSizePolicy</td></tr><tr><td align="center">幸存区比例</td><td align="center">-XX:SurvivorRatio&#x3D;ratio</td></tr><tr><td align="center">晋升阈值</td><td align="center">-XX:MaxTenuringThreshold&#x3D;threshold</td></tr><tr><td align="center">晋升详情</td><td align="center">-XX:+PrintTenuringDistribution</td></tr><tr><td align="center">GC 详情</td><td align="center">-XX:+PrintGCDetails -verbose:gc</td></tr><tr><td align="center">Full GC 前 Minor GC</td><td align="center">-XX:+ScavengeBeforeFullGC</td></tr></tbody></table><h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><h2 id="早期回收器"><a href="#早期回收器" class="headerlink" title="早期回收器"></a>早期回收器</h2><div class="tabs" id="2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2-1">串行收集器（Serial收集器）</button></li><li class="tab"><button type="button" data-href="#2-2">吞吐量优先收集器（Parallel收集器）</button></li><li class="tab"><button type="button" data-href="#2-3">CMS收集器（响应时间优先）</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2-1"><ul><li>这是最简单的垃圾回收器，它通过一个单线程进行垃圾回收，因此它的优点是简单高效，但缺点是在大型应用程序中可能会出现停顿时间过长的问题。</li><li>串行收集器的缺点主要是单线程执行垃圾回收操作，不能充分利用多核CPU的计算能力，同时垃圾回收操作会阻塞应用程序的运行，可能会导致长时间的停顿。因此，在大型的、多线程的应用程序中，通常不适合使用串行收集器进行垃圾回收。</li><li>对应的VM参数：<code>-XX:+UseSerialGC = Serial + SerialOld</code></li><li>下图中，其他CPU需要等待<code>CPU 2</code>执行完垃圾回收后，才能继续运行</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310261842860.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2-2"><ul><li><p>JDK 1.8 默认采用的就是这种垃圾回收器</p></li><li><p>它是一种基于多线程并行执行的垃圾回收器，它的主要目标是提高应用程序的吞吐量，即在单位时间内处理更多的请求。</p></li><li><p>相关VM参数</p><ol><li><pre><code>-XX:+UseParallelGC ~ -XX:+UseParallelOldGC：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   - 这两个参数分别用于开启并行垃圾回收器和并行老年代垃圾回收器。其中，-XX:+UseParallelGC用于开启并行垃圾回收器，-XX:+UseParallelOldGC用于开启并行老年代垃圾回收器。使用这两个参数可以开启Parallel收集器。</span><br><span class="line"></span><br><span class="line">2. ```</span><br><span class="line">   -XX:+UseAdaptiveSizePolicy：</span><br></pre></td></tr></table></figure>- 这个参数用于自适应地调整Java堆大小和垃圾收集器的参数，以达到更好的垃圾回收效果。当开启该参数时，JVM会自动调整Eden区、Survivor区、老年代的大小以及垃圾回收线程的数量等参数，以达到更高的垃圾回收效率。</code></pre></li><li><pre><code>-XX:GCTimeRatio=ratio：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   - 这个参数用于设置垃圾回收所占用CPU时间和应用程序运行时间的比率。默认值是99，表示垃圾回收时间最多可以占用1%的CPU时间，计算公式为`1/(1 + ratio)`</span><br><span class="line"></span><br><span class="line">4. ```</span><br><span class="line">   -XX:MaxGCPauseMillis=ms：</span><br></pre></td></tr></table></figure>- 这个参数用于设置最大垃圾回收暂停时间。默认值是200ms。如果设置该参数，JVM会尽可能地控制垃圾回收暂停的时间不超过该值。如果需要更短的垃圾回收暂停时间，则可以将该值设置为较小的数值。</code></pre></li><li><pre><code>-XX:ParallelGCThreads=n：</code></pre><ul><li>这个参数用于设置垃圾回收线程的数量。默认值是CPU核心数的1&#x2F;4。可以根据应用程序的需求和硬件环境来调整该参数的值，以达到更好的垃圾回收效果。</li></ul></li></ol></li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/pphfXnO.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2-3"><p>概述</p><ul><li>CMS（Concurrent Mark Sweep）是一种垃圾回收算法，它的设计目标是在最短的停顿时间内回收垃圾。它通过在一个线程中进行垃圾回收并在应用程序线程中同时运行，从而减少停顿时间。下面详细介绍CMS垃圾收集器的工作原理和优缺点。</li></ul><p>工作流程</p><ul><li>CMS垃圾收集器的工作可以分为以下几个阶段：<ol><li>初始标记阶段（Initial Marking）：在这个阶段中，CMS垃圾收集器会暂停所有应用程序线程，并且在内存中标记出所有被直接引用的对象。这个过程由一个线程来完成，因此它的停顿时间比较短。</li><li>并发标记阶段（Concurrent Marking）：在这个阶段中，CMS垃圾收集器会在应用程序线程运行的同时标记出所有被间接引用的对象。这个过程由多个线程并发执行，因此它的停顿时间比较短。</li><li>重新标记阶段（Remark）：在这个阶段中，CMS垃圾收集器会暂停所有应用程序线程，并且重新标记出在并发标记阶段中有变化的对象。这个过程由一个线程来完成，因此它的停顿时间比较短。</li><li>并发清除阶段（Concurrent Sweeping）：在这个阶段中，CMS垃圾收集器会在应用程序线程运行的同时清除所有标记为垃圾的对象。这个过程由多个线程并发执行，因此它的停顿时间比较短。</li><li>最终标记阶段（Final Remark）：在这个阶段中，CMS垃圾收集器会暂停所有应用程序线程，并且重新标记出在并发清除阶段中有变化的对象。这个过程由一个线程来完成，因此它的停顿时间比较短。</li></ol></li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310261843307.png"></p><ul><li>优点<ol><li>可以在最短的停顿时间内回收垃圾，不会出现长时间的停顿现象，因此适合响应时间比较敏感的应用程序。</li><li>采用并发的垃圾收集方式，能够与应用程序并发执行，不会阻塞应用程序的执行，因此对于需要保证应用程序响应性能的场景非常适用。</li></ol></li><li>缺点<ol><li>对 CPU 的使用比较敏感，在高负载情况下可能会影响应用程序的性能。</li><li>由于并发清除阶段无法整理内存，可能会出现内存碎片化的问题，导致后续垃圾回收过程需要更多的时间。</li><li>在处理大量的垃圾时可能会导致应用程序的性能下降，因为需要占用一定的 CPU 资源。</li></ol></li></ul><p>相关VM参数</p><ol><li>-XX:ParallelGCThreads&#x3D;n：<ul><li>指定并行垃圾回收器的线程数。默认值是处理器核心数。</li></ul></li><li>-XX:ConcGCThreads&#x3D;threads：<ul><li>指定并发垃圾回收器的线程数。默认值是处理器核心数的<code>1/4</code>。</li></ul></li><li>-XX:CMSInitiatingOccupancyFraction&#x3D;percent：<ul><li>指定 CMS 垃圾回收器开始执行垃圾回收的阈值。当老年代空间使用达到指定百分比时，CMS 垃圾回收器会开始执行垃圾回收。</li></ul></li><li>-XX:+CMSScavengeBeforeRemark：<ul><li>启用 CMS 垃圾回收器在进行重新标记之前执行新生代的垃圾回收。这可以减少重新标记的时间，从而减少应用程序暂停的时间。</li></ul></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li><p>G1（Garbage-First）是一种现代化的垃圾回收器，它在JDK 7中首次引入，并在JDK 9</p><p>中被标记为默认垃圾回收器。</p></li><li><p>与之前的垃圾回收器相比，G1的最大优势在于它可以更好地处理占据大量堆内存的Java应用程序，从而避免了传统垃圾回收器在大内存情况下可能出现的停顿</p></li></ul><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ul><li>G1采用了一种不同于传统垃圾回收器的回收方式，它将内存划分为大小相等的多个区域（Region），每个区域的大小通常为<code>1MB</code>到<code>32MB</code>。G1将这些区域分为新生代和老年代，其中新生代通常占整个堆内存的5%到10%，老年代则占90%到95%。</li><li>G1将堆内存划分为多个区域后，它就可以对每个区域分别进行垃圾回收，从而避免了FULL GC带来的长时间停顿。</li></ul><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ul><li>G1的垃圾回收流程如下<ol><li><code>初始标记（Initial Mark）：</code>G1在此阶段会扫描堆内存中的根对象，并标记所有的根对象，以便后续回收时可以快速定位到这些根对象</li><li><code>并发标记（Concurrent Mark）：</code>在此阶段，G1会与应用程序并发的执行，扫描堆内存中的所有存活对象，并标记这些对象。在整个过程中，应用程序可以继续执行，因此在这个阶段不会产生长时间的停顿</li><li><code>确定标记（Remark）：</code>在并发标记结束后，G1需要在一个短暂的停顿期间重新扫描堆内存，以便确定所有的存活对象已经被标记</li><li><code>清除（Cleanup）：</code>在确定标记阶段结束后，G1会对未标记的区域进行回收，并将回收得到的空闲区域加入到空闲列表中，以便下次回收内存时使用</li></ol></li></ul><h3 id="垃圾回收阶段"><a href="#垃圾回收阶段" class="headerlink" title="垃圾回收阶段"></a>垃圾回收阶段</h3><ul><li>在G1垃圾回收器中，垃圾回收的过程可以分为三种阶段：<code>Young Collection</code>、<code>Young Collection + Concurrent Mark</code>（简称Young Collection + CM）和<code>Mixed Collection</code>。</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310261845573.png"></p><h4 id="三种垃圾回收阶段"><a href="#三种垃圾回收阶段" class="headerlink" title="三种垃圾回收阶段"></a>三种垃圾回收阶段</h4><div class="tabs" id="3"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#3-1">Young Collection</button></li><li class="tab"><button type="button" data-href="#3-2">Young Collection + Concurrent Mark</button></li><li class="tab"><button type="button" data-href="#3-3">Mixed Collection</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="3-1"><p>Young Collection（年轻代垃圾回收）</p><ul><li>Young Collection是指对年轻代（Young Generation）的垃圾回收。在G1垃圾回收器中，年轻代通常是由几个连续的Region组成的。在年轻代垃圾回收期间，G1垃圾回收器会扫描年轻代内的所有对象，并标记那些被引用的对象。然后，它会将未被引用的对象回收掉，并将被引用的对象移动到下一个垃圾回收周期的存活区域（Survivor Region）中。</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310261847838.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3-2"><p>年轻代垃圾回收 + 并发标记</p><ul><li>Young Collection + CM是：指在Young GC 时会进行GC Root 的初始标记，当老年代占用堆空间比例达到阈值时，对整个堆内存进行并发标记。由下面的VM参数决定<ul><li>-XX:InitiatingHeapOccupancyPercent&#x3D;percent （默认45%）</li></ul></li><li>在并发标记过程中，G1垃圾回收器会扫描所有的可达对象，并标记它们。并发标记可以与应用程序并行进行，不会停顿应用程序的线程。当并发标记完成后，G1垃圾回收器就可以知道哪些对象是存活的，哪些对象是垃圾</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310261857656.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3-3"><p>Mixed Collection（混合垃圾回收）</p><p>Mixed Collection是指对整个堆内存进行垃圾回收，包括年轻代和老年代（Old Generation）的垃圾回收。在Mixed Collection期间，G1垃圾回收器会尽可能地回收那些垃圾占用空间较大的Region，并将它们标记为”空闲”状态，以便在以后的内存分配中使用。与Young Collection不同，Mixed Collection不仅回收年轻代的对象，还回收老年代的对象，因此它需要更长的停顿时间。同时，Mixed Collection也会和并发标记一起执行，以最小化应用程序的停顿时间。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310261857645.png"></p><ul><li>新生代内存不足发生的垃圾收集：minor gc</li><li>当G1垃圾回收器的回收速度跟不上Java应用程序产生垃圾的速度时，垃圾对象在堆内存中不断增加，导致堆内存空间的压力增大。当堆内存空间的压力达到G1垃圾回收器的阈值时，会触发FULL GC。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="跨代引用"><a href="#跨代引用" class="headerlink" title="跨代引用"></a>跨代引用</h3><ul><li>当进行新生代垃圾回收时，需要找到新生代对象的跟对象来确定哪些对象是存活的，那些对象需要被回收。然而根对象中可能有一部分存活在老年代中，如果每次都要遍历老年代来查找这些根对象，将会导致效率低下</li><li>为了解决这个问题，G1垃圾回收器采用了一种卡表技术，将老年代划分为多个区域，并将每个区域划分为一组成为<code>卡</code>的块。每个卡的大小约为512KB，如果老年代中的一个对象引用了新生代中的对象，那么该卡就被标记为脏卡</li><li>在新生代对象引用发生变化时，使用post-write barrier和dirty card queue技术来更新卡表，将引用变更信息添加到Remembered Set中，标记为脏卡</li><li>在进行新生代垃圾回收时，只需要扫描这些脏卡中的对象，即可找到所有的跨代引用对象，避免了对整个老年代进行遍历的开销，提高了垃圾回收的效率。</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310261858746.png"></p><h3 id="重新标记阶段"><a href="#重新标记阶段" class="headerlink" title="重新标记阶段"></a>重新标记阶段</h3><ul><li>在G1垃圾回收器的remark阶段中，它使用三色标记法来标记存活对象，并结合SATB和写屏障来跟踪对象的引用关系，以便在标记阶段中更准确地标记存活对象。</li><li>remark阶段开始时，G1垃圾回收器会将所有被标记为灰色的对象加入到处理队列中，然后开始遍历处理队列中的对象。对于每个灰色对象，G1垃圾回收器会扫描其所有引用域，并将任何未被标记为黑色的引用加入到SATB中，以便在后续标记阶段中更准确地跟踪引用关系。</li><li>同时，在遍历处理队列中的对象时，G1垃圾回收器会将灰色对象的引用对象标记为灰色，将灰色对象标记为黑色，并将其从处理队列中移除。这个过程会一直持续，直到处理队列中不再有灰色对象。</li><li>在remark阶段中，SATB写屏障起到了重要作用。当程序在运行时修改一个对象的引用时，SATB写屏障会记录这个修改，并将相关信息保存到一个记录缓存中。在remark阶段中，G1垃圾回收器会遍历记录缓存中所有被标记为脏的对象，并遍历这些对象的引用域，以确定它们所引用的对象是否需要被标记为灰色。</li><li>通过三色标记法、SATB和写屏障的结合使用，G1垃圾回收器可以更准确地标记存活对象，并且在标记阶段中只标记那些需要被标记的对象，从而提高垃圾回收器的性能和效率。</li></ul><h3 id="字符串去重"><a href="#字符串去重" class="headerlink" title="字符串去重"></a>字符串去重</h3><ul><li>当新生代中的对象被晋升到老年代时，如果这些对象是字符串类型，那么会将它们放入一个特殊的队列中，而不是直接将它们放入老年代中。这个队列称为String Deduplication Queue，可以理解为字符串去重队列。</li><li>G1垃圾回收器在remark阶段中会扫描String Deduplication Queue中的所有字符串，检查是否有重复的字符串。如果发现有重复的字符串，就会让它们引用同一个<code>char[]</code>，以达到字符串去重的目的。需要注意的是，这里去重的对象是<code>char[]</code>，而不是String对象本身，与<code>String.intern()</code>不同。</li><li>为了实现这一功能，G1垃圾回收器内部维护了一个字符串表，用来存储所有已经去重的<code>char[]</code>。当遍历String Deduplication Queue时，G1垃圾回收器会将每个字符串的<code>char[]</code>进行哈希，然后在字符串表中查找是否存在相同哈希值的<code>char[]</code>，如果存在，就会比较这两个<code>char[]</code>的内容是否相同，从而确定是否是同一个字符串。如果是同一个字符串，就将这个字符串对象的引用指向字符串表中的<code>char[]</code>，从而达到字符串去重的目的。</li><li>总之，G1垃圾回收器的字符串去重功能可以大幅度减少堆内存中的重复字符串，从而降低垃圾回收器的内存占用和垃圾回收的开销，提高程序的性能。<ul><li>优点：节省大量内存</li><li>缺点：稍微多占用了CPU时间，新生代回收时间略微增加</li></ul></li></ul><h3 id="类卸载"><a href="#类卸载" class="headerlink" title="类卸载"></a>类卸载</h3><ul><li>在 G1 垃圾回收器进行并发标记后，它可以识别出哪些类不再被使用。当一个类加载器的所有类都不再被使用时，就可以卸载该类加载器所加载的所有类。</li><li>G1 垃圾回收器默认开启了类卸载功能，可以通过 <code>JVM</code> 参数 <code>-XX:+ClassUnloadingWithConcurrentMark</code> 显式启用。</li></ul><h3 id="回收巨型对象"><a href="#回收巨型对象" class="headerlink" title="回收巨型对象"></a>回收巨型对象</h3><ul><li>对象大小超过了G1 Heap中的Region大小的一半时，被称为巨型对象（Huge Object）。</li><li>G1不会将巨型对象分配到Region中，而是直接分配在Humongous区域中。Humongous区域是一组连续的Region，大小为2的幂次方倍。如果一个巨型对象的大小超过了Humongous区域的大小，则会跨越多个Humongous区域。</li><li>在标记阶段，G1会优先处理巨型对象，以便在回收过程中更好地利用它们的空间。这样可以避免因巨型对象被其他对象占用而导致的内存浪费。</li><li>在G1中，老年代中所有的incoming引用会被跟踪，如果某个巨型对象的incoming引用计数为0，说明该对象不再被其他对象引用，可以直接被回收。这个过程发生在新生代回收之前，可以帮助释放空间。</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310261859672.png"></p><h3 id="动态调整阈值"><a href="#动态调整阈值" class="headerlink" title="动态调整阈值"></a>动态调整阈值</h3><ul><li>前面说如果G1垃圾回收器的回收速度跟不上Java应用程序产生垃圾的速度时，垃圾对象在堆内存中不断增加，导致堆内存空间的压力增大。当堆内存空间的压力达到G1垃圾回收器的阈值时，会触发<code>FULL GC</code>。</li><li>并发标记阶段是 G1 垃圾回收的一个重要阶段，需要在堆空间占满之前完成，否则就会退化为 FullGC。为了避免这种情况的发生，JDK 9 之前需要使用 <code>-XX:InitiatingHeapOccupancyPercent</code> 参数来手动设置并发标记的触发阈值（默认为45%），以确保在这个阈值之前就完成并发标记。而在 JDK 9 及以后的版本中，可以根据实际情况动态调整并发标记的触发阈值，以避免 <code>Full GC</code> 的发生。</li><li><code>-XX:InitiatingHeapOccupancyPercent</code> 参数用于设置并发标记的初始触发阈值，但是 G1 在进行并发标记时会进行数据采样，并根据采样数据动态调整并发标记的触发阈值，以确保并发标记可以在堆空间不被填满的情况下完成。同时，G1 还会在堆空间中留出一定的安全空档空间，以避免因为堆空间占满而触发 <code>Full GC</code>。</li></ul><h3 id="G1总结"><a href="#G1总结" class="headerlink" title="G1总结"></a>G1总结</h3><p>优点：</p><ol><li><code>分区回收：</code>G1将堆内存划分为多个区域，并对每个区域分别进行回收，从而避免<code>FULL GC</code>带来的长时间停顿</li><li><code>并发回收：</code>G1在标记和清除阶段都可以与应用程序并发执行，从而避免了长时间的停顿</li><li><code>预测性停顿：</code>G1可以根据应用程序的内存使用情况预测合适需要进行<code>FULL GC</code>，从而在垃圾回收过程中尽可能地减少停顿时间</li><li><code>空间整合：</code>G1可以在回收过程中对空间进行整合，从而可以更好的利用堆内存</li><li><code>可预测性：</code>G1可以设置预期的停顿时间，以便开发人员可以更好地控制应用程序的性能</li></ol><p>缺点</p><ol><li>初始标记和确定标记阶段需要短暂的停顿时间，虽然停顿时间短暂，但是仍然可能影响应用程序的性能</li><li>G1需要更多的CPU资源来完成垃圾回收，因为它需要同时处理多个分区</li><li>对于小型应用程序，G1可能会产生过多的内存分配和垃圾回收开销，从而导致应用程序性能下降</li></ol><h1 id="垃圾回收调优"><a href="#垃圾回收调优" class="headerlink" title="垃圾回收调优"></a>垃圾回收调优</h1><p>调优跟应用、环境有关，没有放之四海而皆准的法则，都是具体情况具体分析</p><h2 id="调优领域"><a href="#调优领域" class="headerlink" title="调优领域"></a>调优领域</h2><ul><li>JVM的GC调优是Java应用程序性能调优的一个重要方面。在进行GC调优之前，需要先确定应用程序的性能瓶颈，通常可以从内存、锁竞争、CPU占用和IO等方面入手进行调优。</li></ul><ol><li><code>内存调优</code><ul><li>内存调优主要是针对JVM的堆内存和非堆内存进行调优。在Java应用程序中，大部分的对象都是分配在堆内存中的。因此，对于堆内存的调优非常重要。</li><li>如果堆内存的大小设置过小，就会频繁地进行垃圾回收，导致应用程序的性能下降。如果堆内存的大小设置过大，就会浪费系统资源。</li><li>对于非堆内存，可以考虑调整JVM的元空间大小来减少元数据的内存占用。</li></ul></li><li><code>锁竞争调优</code><ul><li>Java中的锁机制是实现并发的重要手段，但是锁的竞争会导致应用程序的性能下降。因此，锁竞争调优是Java应用程序性能调优的一个重要方面。</li><li>可以通过使用synchronized关键字和Lock接口来进行锁竞争调优。synchronized关键字是Java中实现锁的一种简单方式，但是在高并发场景下，由于锁粒度较大，容易导致锁竞争。</li><li>因此，在高并发场景下，可以考虑使用Lock接口来实现锁。Lock接口支持更细粒度的锁，并且可以控制锁的获取和释放。</li></ul></li><li><code>CPU占用调优</code><ul><li>CPU占用调优是指通过优化代码来减少CPU的占用率，提高应用程序的性能。</li><li>可以通过以下方式来进行CPU占用调优：<ol><li><code>减少线程数：</code>线程数过多会导致CPU占用率上升，因此可以通过减少线程数来降低CPU占用率。</li><li><code>避免无用循环：</code>无用循环会导致CPU占用率上升，因此可以通过优化代码来减少无用循环的出现。</li><li><code>避免递归调用：</code>递归调用会导致CPU占用率上升，因此可以通过优化代码来避免递归调用的出现。</li></ol></li></ul></li><li><code>IO调优</code><ul><li>IO调优是指通过优化IO操作来提高应用程序的性能。</li><li>可以通过以下方式来进行IO调优：<ol><li><code>减少IO操作：</code>减少IO操作可以减少IO调用的次数，从而提高应用程序的性能。</li><li><code>使用缓存：</code>缓存可以减少IO调用的次数，从而提高应用程序的性能。</li><li><code>使用异步IO：</code>异步IO可以在IO操作期间释放CPU资源，从而提高应用程序的性能。</li></ol></li></ul></li></ol><h2 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a>确定目标</h2><p>我们首先要清楚我们的应用程序是干什么的，即确定一个垃圾回收的目标</p><ul><li>如果是做一些科学运算、批量处理，那么追求的就是高吞吐量，延长一点点响应时间对我们没有太大影响</li><li>如果是做一些互联网、金融、电子商务项目，那么响应时间就是一个非常重要的指标了，如果每次垃圾回收都延长了响应时间，就会给用户造成不好的体验</li></ul><p>确定了目标以后，我们再来选择合适的垃圾回收器</p><ul><li>对于高吞吐量的应用程序，通常可以选择 <code>Parallel GC</code> 等并行垃圾回收器来实现高效的垃圾回收。</li><li>而对于需要低延迟、高响应时间的应用程序，可以选择 <code>CMS</code>、<code>G1</code>、<code>ZGC</code>、<code>Zing</code> 等低延迟垃圾回收器来实现。</li></ul><h2 id="最快的GC"><a href="#最快的GC" class="headerlink" title="最快的GC"></a>最快的GC</h2><p>最快的GC是不发生GC，即尽可能减少内存分配和回收的次数。因此，建议在代码中尽量避免频繁地创建和销毁对象，或者使用不必要的大型数据结构。</p><h2 id="GC之前检查"><a href="#GC之前检查" class="headerlink" title="GC之前检查"></a>GC之前检查</h2><ol><li>数据是不是太多<ul><li>查询大表时，如果数据量太大，会占用大量的内存空间，导致频繁的GC，甚至可能直接内存溢出，建议在查询时加上限制条件（如limit）来减小数据量。</li></ul></li><li>数据表示是否太臃肿？<ul><li>如果数据结构过于庞大，例如包含大量不必要的字段或者对象引用，也会占用大量内存空间。</li><li>例如在Java中，Integer是一个对象，而int是一个基本数据类型。因此，当我们使用Integer时，实际上是创建了一个对象来存储整数值。相对地，使用int时，只需要直接在栈上分配一个内存空间来存储整数值，不需要再创建对象，因此内存占用更小。<ul><li>Integer对象占用的内存空间包含了对象头、对象的值等信息，一般需要占据16个字节</li><li>而int类型只需要占用4个字节的内存空间。</li></ul></li></ul></li><li>是否存在内存泄露？<ul><li>一直向静态Map中存储数据，会导致静态Map中的内存占用越来越大，可能导致频繁的GC和内存溢出。因为静态变量属于类，不会被垃圾回收器自动释放。这种情况可以使用软引用或弱引用来引用该对象，以便在内存不足时自动释放缓存数据。</li><li>但还是不建议使用Java来实现缓存，而是推荐使用第三方缓存实现，例如Redis等</li></ul></li></ol><h2 id="新生代调优"><a href="#新生代调优" class="headerlink" title="新生代调优"></a>新生代调优</h2><p>在新生代调优之前，我们先来回顾一下新生代的特点</p><ol><li>所有的new操作的内存分配都非常廉价，即分配速度很快。</li><li>死亡对象的回收：Java虚拟机有自动垃圾回收机制，用于回收不再被使用的对象。在新生代中，回收死亡对象的代价为零，因为它们可以很容易地被回收。</li><li>大部分对象用过即死：大部分对象的生命周期很短，使用一次就被丢弃了，这是因为Java中的对象通常用于执行一些特定的任务，而不是被持续使用。</li><li>Minor GC：Java虚拟机会周期性地进行垃圾回收操作，其中一种是Minor GC，用于回收新生代中的对象。由于新生代中的对象生命周期短，因此Minor GC的时间通常比Full GC（用于回收老年代中的对象）短很多。</li></ol><p>那么是设置的越大越好吗？不是的，官方文档中给出的解释如下：</p><ul><li><p>-Xmn</p><ul><li>Sets the initial and maximum size (in bytes) of the heap for the young generation (nursery). GC isperformed in this region more often than in other regions. If the size for the young generation is too small, then a lot of minor garbage collections are performed. If the size is too large, then only full garbage collections are performed, which can take a long time to complete. Oracle recommends that you keep the size for the young generation greater than 25% and less than 50% of the overall heap size.</li><li>设置新生代堆的初始大小和最大大小（以字节为单位）。垃圾回收在新生代中比其他区域更频繁地进行。如果新生代的大小过小，则会执行很多次<code>Minor GC</code>。如果大小过大，则只执行<code>FULL GC</code>，这可能需要很长时间才能完成。Oracle 建议您将新生代的大小保持在总堆大小的 25% 以上且低于 50%。</li></ul></li><li><p>新生代大小最好能容纳所有<code>并发量 * (请求-响应)</code>的数据</p><ul><li>例如一次请求响应需要<code>512KB</code>内存，并发量为<code>10000</code>，那么差不多就是<code>5GB</code></li></ul></li><li><p>幸存区要大到能够保留<code>当前活跃的对象 + 需要晋升的对象</code></p><ul><li>如果幸存区过小，JVM会灵活调整晋升的阈值，从而可能导致某些对象被提前晋升到老年代，从而将其从幸存区释放。当幸存区不足以容纳所有存活的对象时，垃圾回收器会选择将一部分对象直接晋升到老年代，而不是等待这些对象达到晋升的阈值再晋升。</li><li>这样做的问题在于，新生代中的对象通常比老年代中的对象生命周期短，如果过早地将这些对象晋升到老年代，可能会导致老年代中存在许多生命周期很短的对象，从而增加垃圾回收的压力，甚至导致堆内存溢出。</li><li>因此，为了变过早地将对象晋升到老年代，通常建议将幸存区设置的足够大，以便能够<code>容纳当前活跃对象与需要晋升对象的总和</code>。这也可以减少对象直接晋升到老年代的情况，提高了年轻代的空间利用率，并减轻垃圾回收的压力。</li></ul></li><li><p>调整晋升阈值是为了让存活时间较长的对象能尽早进入老年代，这样可以减少在幸存区进行复制操作的次数和数量。</p></li></ul><h2 id="老年代调优"><a href="#老年代调优" class="headerlink" title="老年代调优"></a>老年代调优</h2><p>以CMS为例</p><ul><li>CMS的老年代内存越大越好</li><li>先不进行调优，如果没有发生FULL GC，那么说明程序运行良好，应该先尝试新生代调优</li><li>观察发生FULL GC时老年代内存占用，将老年代内存预设增加 1&#x2F;4 ~ 1&#x2F;3。<ul><li>然后逐步调整-XX:CMSInitiatingOccupancyFraction参数的值，找到一个合适的设置值。</li><li>一般来说，可以将该参数设置在75% ~ 85%之间</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 垃圾回收 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM内存结构</title>
      <link href="/2023/10/25/JVM.%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
      <url>/2023/10/25/JVM.%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p>Java Virtual Machine ，Java 程序的<strong>运行环境</strong>（Java 二进制字节码的运行环境）</p><p>JVM好处</p><ul><li>一次编译，处处执行</li><li>自动的内存管理，垃圾回收机制</li><li>数组下标越界检查</li></ul><p>JVM、JRE、JDK 的关系如下图所示</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309122015679.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309122016720.png"></p><p>ClassLoader：Java 代码编译成二进制后，会经过类加载器，这样才能加载到 JVM 中运行。<br>Method Area：类是放在方法区中。<br>Heap：类的实例对象。<br>当类调用方法时，会用到 JVM Stack、PC Register、本地方法栈。<br>方法执行时的每行代码是有执行引擎中的解释器逐行执行，方法中的热点代码频繁调用的方法，由 JIT 编译器优化后执行，GC 会对堆中不用的对象进行回收。需要和操作系统打交道就需要使用到本地方法接口</p><h1 id="程序计数器（PC）"><a href="#程序计数器（PC）" class="headerlink" title="程序计数器（PC）"></a>程序计数器（PC）</h1><p>Program Counter Register 程序计数器（寄存器）</p><p>定义：</p><ul><li>JVM中的程序计数器(Program Counter Register)是一块较小的内存空间，它用来保存当前线程下一条要执行的指令的地址。每个线程都有自己独立的程序计数器，它是线程私有的，生命周期与线程相同。程序计数器是JVM中的一种轻量级的内存区域，因为它不会发生内存溢出（OutOfMemoryError）的情况。</li><li>程序计数器也是唯一一个在Java虚拟机规范中没有规定任何<code>OutOfMemoryError（内存溢出）</code>情况的区域。因为程序计数器是线程私有的，所以它所占用的内存空间非常小，一般不会导致内存溢出的问题。</li></ul><p>作用：</p><ul><li><p>是记录下一条 jvm 指令的执行地址行号。（下一条指令一定由PC指出）</p><blockquote><p>因为在Java虚拟机的多线程环境下，为了支持线程切换后能够恢复到正确的执行位置，每个线程都需要有一个独立的程序计数器，否则就会出现线程切换后执行位置混乱的问题。</p></blockquote></li></ul><p>特点：</p><ul><li><p>是线程私有的</p></li><li><p>不会存在内存溢出</p></li><li><p>Java源代码首先编译成二进制字节码，然后交由解释器解释成机器码，最终由CPU执行机器码</p><ul><li>程序计数器在其中的作用就是记住下一条JVM指令的执行地址，解释器从程序计数器取到下一条指令地址</li></ul></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>程序计数器</p><ul><li>作用：保存当前线程下一条要执行的指令的地址</li><li>特点：<ul><li>线程私有</li><li>不存在内存溢出</li></ul></li></ul><h1 id="虚拟机栈（Stack）"><a href="#虚拟机栈（Stack）" class="headerlink" title="虚拟机栈（Stack）"></a>虚拟机栈（Stack）</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>Java虚拟机栈（Java Virtual Machine Stacks）是Java虚拟机为每个线程分配的一块内存区域，用于存储线程的方法调用和局部变量等信息。</li><li>每个线程在运行时都有自己的Java虚拟机栈，线程开始时会创建一个新的栈帧（Stack Frame），用于存储该线程的方法调用信息。当方法调用完成后，该栈帧会被弹出，回到上一次方法调用的位置。每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法。</li></ul><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>Java虚拟机栈</p><ol><li>每个线程运行是所需的内存，就称为虚拟机栈</li><li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时占用的内存</li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li></ol><div class="tabs" id="问题1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#问题1-1">问题1</button></li><li class="tab"><button type="button" data-href="#问题1-2">问题2</button></li><li class="tab"><button type="button" data-href="#问题1-3">问题3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="问题1-1"><p>垃圾回收是否涉及栈内存？</p><p>垃圾回收通常不涉及栈内存。栈内存是在程序运行时自动分配和释放的，因此不需要垃圾回收来处理。相反，垃圾回收主要关注堆内存中的对象，以及这些对象是否还在被引用。垃圾回收器通常会扫描堆内存中的对象，并标记哪些对象仍然被引用，哪些对象可以被清理。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="问题1-2"><p>栈内存分配越大越好吗？</p><ul><li>栈内存的分配大小应该根据实际需要来确定。栈内存的分配是由操作系统负责的。栈内存划的越大，会让线程数变少，因为物理内存大小是一定的。栈内存划分大了，通常只是能够进行更多次的方法递归调用，而不会增强运行效率，反而会使线程数量变少，一般采用系统默认的栈内存就好</li></ul><ul><li>栈内存的分配大小应该根据实际需要来确定。栈内存的分配是由操作系统负责的<ul><li>Linux&#x2F;x64（64 位）：1024 KB</li><li>macOS（64 位）：1024 KB</li><li>Oracle Solaris&#x2F;x64（64 位）：1024 KB</li><li>Windows：默认值取决于虚拟内存</li></ul></li><li>当然我们也可以手动设置线程堆栈大小为1024kb</li></ul><blockquote><p>K M G T 在这里都是能直接用的</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Xss1m</span><br><span class="line">-Xss1024k</span><br><span class="line">-Xss1048576</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="问题1-3"><p>方法内的局部变量是否线程安全？</p><p>方法内的局部变量通常是线程安全的，因为它们只能在方法内部访问。每个线程都有自己的栈帧，栈帧包含方法的参数、局部变量和返回值等信息，因此不同的线程可以在不相互干扰的情况下同时访问相同的方法。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="栈内存溢出"><a href="#栈内存溢出" class="headerlink" title="栈内存溢出"></a>栈内存溢出</h2><p>栈内存溢出有两种情况</p><ol><li><p>栈帧过多导致栈内存溢出</p><ul><li>死循环递归</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    static int count = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            method();</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void method() &#123;</span><br><span class="line">        count++;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>栈帧过多导致栈内存溢出</p><ul><li>下面这个例子中，Emp中引入了Dept，而Dept中又引入了Emp，他们现在在循环引用，导致json解析时会出现StackOverFlow</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import com.fasterxml.jackson.annotation.JsonIgnore;</span><br><span class="line">import com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line">import com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Demo_03 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws JsonProcessingException &#123;</span><br><span class="line">        Dept d = new Dept();</span><br><span class="line">        d.setName(&quot;Market&quot;);</span><br><span class="line"></span><br><span class="line">        Emp e1 = new Emp();</span><br><span class="line">        e1.setName(&quot;zhang&quot;);</span><br><span class="line">        e1.setDept(d);</span><br><span class="line"></span><br><span class="line">        Emp e2 = new Emp();</span><br><span class="line">        e2.setName(&quot;li&quot;);</span><br><span class="line">        e2.setDept(d);</span><br><span class="line"></span><br><span class="line">        d.setEmps(Arrays.asList(e1, e2));</span><br><span class="line"></span><br><span class="line">        // &#123; name: &#x27;Market&#x27;, emps: [&#123; name:&#x27;zhang&#x27;, dept:&#123; name:&#x27;&#x27;, emps: [ &#123;&#125;]&#125; &#125;,] &#125;</span><br><span class="line">        ObjectMapper mapper = new ObjectMapper();</span><br><span class="line">        System.out.println(mapper.writeValueAsString(d));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Emp &#123;</span><br><span class="line">    private String name;</span><br><span class="line">//    @JsonIgnore</span><br><span class="line">    private Dept dept;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Dept getDept() &#123;</span><br><span class="line">        return dept;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDept(Dept dept) &#123;</span><br><span class="line">        this.dept = dept;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dept &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private List&lt;Emp&gt; emps;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;Emp&gt; getEmps() &#123;</span><br><span class="line">        return emps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setEmps(List&lt;Emp&gt; emps) &#123;</span><br><span class="line">        this.emps = emps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><ul><li>本地方法<ul><li><code>本地方法</code>是指由非Java语言编写的代码，如C或C++，并被编译为本地二进制代码。</li></ul></li><li>因为<code>JAVA</code>没法直接和操作系统底层交互，所以需要用到本地方法栈来调用本地的C或C++的方法</li><li>例如Object类的源码中就有本地方法，用<strong>native</strong>关键字修饰本地方法<ul><li>本地方法只有函数声明，没有函数体，因为函数体是C或C++写的，通常是通过JNI（Java Native Interface）技术来实现的。</li></ul></li></ul><h1 id="堆-heap"><a href="#堆-heap" class="headerlink" title="堆(heap)"></a>堆(heap)</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><ul><li>JVM的堆（Heap）是Java虚拟机（JVM）在内存中用来存放对象的区域，是Java程序中最大的一块内存区域。JVM的堆被所有线程共享，在JVM启动时就已经被创建，并且一直存在于JVM的整个生命周期中。</li><li>堆可以被分成两部分：新生代（Young Generation）和老年代（Old Generation）。新生代又被进一步分为Eden空间、幸存区From空间和幸存区To空间。</li><li>新生代是用来存放新创建的对象的，其中大部分对象都很快就会被垃圾回收掉。当堆空间不足时，JVM会触发垃圾回收机制（GC），对新生代的对象进行清理。清理过程一般是将存活的对象移到老年代或幸存区，而其余的对象则被回收。</li><li>老年代是用来存放生命周期较长的对象的，这些对象一般是从新生代晋升而来，或者是本身就比较大的对象。老年代的对象存活时间较长，因此垃圾回收的频率比新生代低得多。</li><li>JVM堆的大小可以通过启动JVM时的参数进行调整，如-Xms和-Xmx参数分别控制堆的初始大小和最大大小。如果应用程序需要创建大量的对象，而堆空间不足，则会抛出OutOfMemoryError异常。</li></ul><p>特点：</p><ul><li><p>通过new关键字创建的对象都会使用堆空间</p></li><li><p>它是线程共享的，堆空间内的对象都需要考虑线程安全的问题</p></li><li><p>有垃圾回收机制（GC Garbage Collection）</p></li></ul><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><ul><li>Heap堆<ul><li>通过new关键字创建的对象都会使用堆空间</li></ul></li><li>特点<ul><li>它是线程共享的，堆空间内的对象都需要考虑线程安全的问题</li><li>有垃圾回收机制</li></ul></li></ul><h2 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 演示堆内存溢出：java.lang.OutOfMemoryError: Java heap space</span><br><span class="line"> */</span><br><span class="line">public class Demo_04 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        try &#123;</span><br><span class="line">            ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); //Hello, HelloHello, HelloHelloHelloHello ···</span><br><span class="line">            String a = &quot;Hello&quot;;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                list.add(a);</span><br><span class="line">                a = a + a;  // HelloHelloHelloHello</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>list对象的作用域是在try块中，list对象是通过new出来的，所以占用的是堆空间。</li><li>由于a的字符串长度是指数增长的，所以堆空间很快就会不足，此时会触发垃圾回收机制，尝试清理新生代对象，但由于list对象一直处于存活状态，无法释放，最终导致堆内存溢出，最终我这里输出的i为<code>27</code></li><li>但是由于堆空间很大，所以有些堆内存溢出的情况可能不是很容易能诊断出来，所以我们可以通过添加JVM参数，将堆空间修改的小一些来进行测试，此时最终输出的i为<code>17</code></li></ul><h2 id="堆内存诊断"><a href="#堆内存诊断" class="headerlink" title="堆内存诊断"></a>堆内存诊断</h2><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">jps工具</button></li><li class="tab"><button type="button" data-href="#test1-2">jmap工具</button></li><li class="tab"><button type="button" data-href="#test1-3">jconsole工具</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p>查看当前系统中有哪些Java进程</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p>查看堆内存占用情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap 进程id ## 进程id就是jps查出来的进程</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p>图形化界面的多功能监测工具，可以连续监测</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309122058984.png"></p><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><ul><li>在JVM中，方法区是一块用于存储类信息、常量、静态变量、即时编译器编译后的代码等数据的内存区域，它是Java虚拟机规范中的一个概念。<code>Java SE 7</code>及之前版本中，方法区被称为<code>永久代</code>，但在<code>Java SE 8</code>之后的版本中，<code>永久代</code>被废弃了，被<code>元空间</code>所替代。</li><li>元空间是JVM在<code>Java SE 8</code>之后引入的一个新的概念，它与永久代类似，都是用于存储类信息、常量、静态变量、即时编译器编译后的代码等数据的内存区域，但元空间的实现方式与永久代有所不同。</li><li>与永久代不同的是，元空间使用的是<code>本地内存（Native Memory）</code>，而不是<code>虚拟机内存（堆内存）</code>，这样就避免了OutOfMemoryError错误，因为在使用本地内存时，可以动态地调整大小，而且可以使用操作系统的虚拟内存机制，使得Java应用程序不会被限制在固定的内存大小中。</li><li>此外，元空间还引入了一些新的概念和机制，例如MetaspaceSize、MaxMetaspaceSize、CompressedClassSpaceSize等，这些概念和机制都是为了更好地管理元空间的内存使用和性能。</li></ul><h3 id="方法区内存溢出"><a href="#方法区内存溢出" class="headerlink" title="方法区内存溢出"></a>方法区内存溢出</h3><p>1.8之后会导致源空间内存溢出，测试代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import jdk.internal.org.objectweb.asm.ClassWriter;</span><br><span class="line">import jdk.internal.org.objectweb.asm.Opcodes;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 演示元空间内存溢出 java.lang.OutOfMemoryError: Metaspace</span><br><span class="line"> * -XX:MaxMetaspaceSize=50m</span><br><span class="line"> */</span><br><span class="line">public class Demo_07 extends ClassLoader &#123; // 可以用来加载类的二进制字节码</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int j = 0;</span><br><span class="line">        try &#123;</span><br><span class="line">            Demo_07 test = new Demo_07();</span><br><span class="line">            for (int i = 0; i &lt; 100000; i++, j++) &#123;</span><br><span class="line">                // ClassWriter 作用是生成类的二进制字节码</span><br><span class="line">                ClassWriter cw = new ClassWriter(0);</span><br><span class="line">                // 版本号， public， 类名, 包名, 父类， 接口</span><br><span class="line">                cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, &quot;Class&quot; + i, null, &quot;java/lang/Object&quot;, null);</span><br><span class="line">                // 返回 byte[]</span><br><span class="line">                byte[] code = cw.toByteArray();</span><br><span class="line">                // 执行了类的加载</span><br><span class="line">                test.defineClass(&quot;Class&quot; + i, code, 0, code.length); // Class 对象</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加VM参数<code>-XX:MaxMetaspaceSize=50m</code>，然后运行上面的代码，结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">70801</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Metaspace</span><br><span class="line">at java.lang.ClassLoader.defineClass1(Native Method)</span><br><span class="line">at java.lang.ClassLoader.defineClass(ClassLoader.java:756)</span><br><span class="line">at java.lang.ClassLoader.defineClass(ClassLoader.java:635)</span><br><span class="line">at com.demo.Demo_07.main(Demo_07.java:23)</span><br></pre></td></tr></table></figure><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>常量池就是一行表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息</p><p>我们先来编写一个简单的HelloWorld类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;Hello, World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过命令将编译后的.class文件反汇编成可读的Java代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">$ javap -v D:/Workspace/JVM/demo/target/classes/com/demo/HelloWorld.class</span><br><span class="line">Classfile /D:/Workspace/JVM/demo/target/classes/com/demo/HelloWorld.class</span><br><span class="line">  Last modified 2023-3-30; size 553 bytes</span><br><span class="line">  MD5 checksum a920c142d5bb891e2b9fc1ff43b55128                                               </span><br><span class="line">  Compiled from &quot;HelloWorld.java&quot;                                                             </span><br><span class="line">public class com.demo.HelloWorld                                                              </span><br><span class="line">  minor version: 0                                                                            </span><br><span class="line">  major version: 52                                                                           </span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER                                                                </span><br><span class="line">Constant pool:                                                                                </span><br><span class="line">   #1 = Methodref          #6.#20         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V                    </span><br><span class="line">   #2 = Fieldref           #21.#22        // java/lang/System.out:Ljava/io/PrintStream;       </span><br><span class="line">   #3 = String             #23            // Hello, World!                                    </span><br><span class="line">   #4 = Methodref          #24.#25        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = Class              #26            // com/demo/HelloWorld                              </span><br><span class="line">   #6 = Class              #27            // java/lang/Object                                 </span><br><span class="line">   #7 = Utf8               &lt;init&gt;                                                             </span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Lcom/demo/HelloWorld;</span><br><span class="line">  #14 = Utf8               main</span><br><span class="line">  #15 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #16 = Utf8               args</span><br><span class="line">  #17 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #18 = Utf8               SourceFile</span><br><span class="line">  #19 = Utf8               HelloWorld.java</span><br><span class="line">  #20 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #21 = Class              #28            // java/lang/System</span><br><span class="line">  #22 = NameAndType        #29:#30        // out:Ljava/io/PrintStream;</span><br><span class="line">  #23 = Utf8               Hello, World!</span><br><span class="line">  #24 = Class              #31            // java/io/PrintStream</span><br><span class="line">  #25 = NameAndType        #32:#33        // println:(Ljava/lang/String;)V</span><br><span class="line">  #26 = Utf8               com/demo/HelloWorld</span><br><span class="line">  #27 = Utf8               java/lang/Object</span><br><span class="line">  #28 = Utf8               java/lang/System</span><br><span class="line">  #29 = Utf8               out</span><br><span class="line">  #30 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #31 = Utf8               java/io/PrintStream</span><br><span class="line">  #32 = Utf8               println</span><br><span class="line">  #33 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  public com.demo.HelloWorld();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom/demo/HelloWorld;</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3                  // String Hello, World!</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 5: 0</span><br><span class="line">        line 6: 8</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       9     0  args   [Ljava/lang/String;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;HelloWorld.java&quot;</span><br></pre></td></tr></table></figure><p>上面的结果中主要包含三部分</p><div class="tabs" id="test2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test2-1">类的基本信息</button></li><li class="tab"><button type="button" data-href="#test2-2">常量池</button></li><li class="tab"><button type="button" data-href="#test2-3">类的方法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test2-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Classfile /D:/Workspace/JVM/demo/target/classes/com/demo/HelloWorld.class</span><br><span class="line">  Last modified 2023-3-30; size 553 bytes</span><br><span class="line">  MD5 checksum a920c142d5bb891e2b9fc1ff43b55128                                               </span><br><span class="line">  Compiled from &quot;HelloWorld.java&quot;                                                             </span><br><span class="line">public class com.demo.HelloWorld                                                              </span><br><span class="line">  minor version: 0                                                                            </span><br><span class="line">  major version: 52                                                                           </span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER        </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:                                                                                </span><br><span class="line">   #1 = Methodref          #6.#20         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V                    </span><br><span class="line">   #2 = Fieldref           #21.#22        // java/lang/System.out:Ljava/io/PrintStream;       </span><br><span class="line">   #3 = String             #23            // Hello, World!                                    </span><br><span class="line">   #4 = Methodref          #24.#25        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = Class              #26            // com/demo/HelloWorld                              </span><br><span class="line">   #6 = Class              #27            // java/lang/Object                                 </span><br><span class="line">   #7 = Utf8               &lt;init&gt;                                                             </span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Lcom/demo/HelloWorld;</span><br><span class="line">  #14 = Utf8               main</span><br><span class="line">  #15 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #16 = Utf8               args</span><br><span class="line">  #17 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #18 = Utf8               SourceFile</span><br><span class="line">  #19 = Utf8               HelloWorld.java</span><br><span class="line">  #20 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #21 = Class              #28            // java/lang/System</span><br><span class="line">  #22 = NameAndType        #29:#30        // out:Ljava/io/PrintStream;</span><br><span class="line">  #23 = Utf8               Hello, World!</span><br><span class="line">  #24 = Class              #31            // java/io/PrintStream</span><br><span class="line">  #25 = NameAndType        #32:#33        // println:(Ljava/lang/String;)V</span><br><span class="line">  #26 = Utf8               com/demo/HelloWorld</span><br><span class="line">  #27 = Utf8               java/lang/Object</span><br><span class="line">  #28 = Utf8               java/lang/System</span><br><span class="line">  #29 = Utf8               out</span><br><span class="line">  #30 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #31 = Utf8               java/io/PrintStream</span><br><span class="line">  #32 = Utf8               println</span><br><span class="line">  #33 = Utf8               (Ljava/lang/String;)V</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-3"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:                                                                                </span><br><span class="line">   #1 = Methodref          #6.#20         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V                    </span><br><span class="line">   #2 = Fieldref           #21.#22        // java/lang/System.out:Ljava/io/PrintStream;       </span><br><span class="line">   #3 = String             #23            // Hello, World!                                    </span><br><span class="line">   #4 = Methodref          #24.#25        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = Class              #26            // com/demo/HelloWorld                              </span><br><span class="line">   #6 = Class              #27            // java/lang/Object                                 </span><br><span class="line">   #7 = Utf8               &lt;init&gt;                                                             </span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Lcom/demo/HelloWorld;</span><br><span class="line">  #14 = Utf8               main</span><br><span class="line">  #15 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #16 = Utf8               args</span><br><span class="line">  #17 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #18 = Utf8               SourceFile</span><br><span class="line">  #19 = Utf8               HelloWorld.java</span><br><span class="line">  #20 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #21 = Class              #28            // java/lang/System</span><br><span class="line">  #22 = NameAndType        #29:#30        // out:Ljava/io/PrintStream;</span><br><span class="line">  #23 = Utf8               Hello, World!</span><br><span class="line">  #24 = Class              #31            // java/io/PrintStream</span><br><span class="line">  #25 = NameAndType        #32:#33        // println:(Ljava/lang/String;)V</span><br><span class="line">  #26 = Utf8               com/demo/HelloWorld</span><br><span class="line">  #27 = Utf8               java/lang/Object</span><br><span class="line">  #28 = Utf8               java/lang/System</span><br><span class="line">  #29 = Utf8               out</span><br><span class="line">  #30 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #31 = Utf8               java/io/PrintStream</span><br><span class="line">  #32 = Utf8               println</span><br><span class="line">  #33 = Utf8               (Ljava/lang/String;)V</span><br></pre></td></tr></table></figure><p>其中如下内容就表示虚拟机的指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">复制成功0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">3: ldc           #3                  // String Hello, World!    </span><br><span class="line">5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">8: return                            </span><br></pre></td></tr></table></figure><p>解释器去翻译虚拟机指令的时候，看到的只有这些</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">getstatic     #2</span><br><span class="line">ldc           #3</span><br><span class="line">invokevirtual #4</span><br></pre></td></tr></table></figure><p>解释器在解释的时候，就是拿着#2、#3、#4去查表翻译，查的就是常量池中的内容</p><ul><li>用#2举例，查表内容如下</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">getstatic     #2                        // 获取静态变量System.out</span><br><span class="line">#2 = Fieldref            #21.#22        // java/lang/System.out:Ljava/io/PrintStream;     </span><br><span class="line">#21 = Class              #28            // java/lang/System</span><br><span class="line">#28 = Utf8               java/lang/System</span><br><span class="line">#22 = NameAndType        #29:#30        // out:Ljava/io/PrintStream;</span><br><span class="line">#29 = Utf8               out</span><br><span class="line">#30 = Utf8               Ljava/io/PrintStream;</span><br></pre></td></tr></table></figure><ul><li>用#3举例，查表内容如下</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">ldc           #3                        // 加载参数Hello, World!</span><br><span class="line">#3 = String              #23            // Hello, World!        </span><br><span class="line">#23 = Utf8               Hello, World!</span><br></pre></td></tr></table></figure><ul><li>用#4举例，查表内容如下</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">invokevirtual #4                        // 执行虚方法调用，调用println，输出Hello, World!</span><br><span class="line">#4 = Methodref           #24.#25        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">#24 = Class              #31            // java/io/PrintStream</span><br><span class="line">#31 = Utf8               java/io/PrintStream</span><br><span class="line">#25 = NameAndType        #32:#33        // println:(Ljava/lang/String;)V</span><br><span class="line">#32 = Utf8               println</span><br><span class="line">#33 = Utf8               (Ljava/lang/String;)V</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p><strong>常量池</strong>：<br>就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息<br><strong>运行时常量池</strong>：<br>常量池是 *.class 文件中的，当该类被加载以后，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</p><h2 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h2><ul><li>常量池中的字符串仅是符号，只有在被用到时才会转化为对象</li><li>利用串池的机制，来避免重复创建字符串对象</li><li>字符串变量拼接的原理是StringBuilder</li><li>字符串常量拼接的原理是编译器优化</li><li>可以使用intern方法，主动将串池中还没有的字符串对象放入串池中</li></ul><h3 id="intern方法"><a href="#intern方法" class="headerlink" title="intern方法"></a><strong>intern方法</strong></h3><p>调用字符串对象的 intern 方法，会将该字符串对象尝试放入到串池中</p><ul><li>如果串池中没有该字符串对象，则放入成功</li><li>如果有该字符串对象，则放入失败</li><li>无论放入是否成功，都会返回串池中的字符串对象</li></ul><p>注意：此时如果调用 intern 方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个对象</p><h3 id="StringTable-的位置"><a href="#StringTable-的位置" class="headerlink" title="StringTable 的位置"></a>StringTable 的位置</h3><ul><li>在 <code>JDK 1.6</code> 中，字符串常量池（也就是 StringTable）是位于<code>永久代</code>中的。而在 <code>JDK 1.8</code> 中，永久代已经被移除，取而代之的是元空间（Metaspace），而字符串常量池也随之移动到了<code>堆</code>中。这意味着在 JDK 1.8 中，字符串常量池中的字符串也可以被垃圾回收器回收，而在 JDK 1.6 中则不行。</li></ul><h3 id="StringTable-垃圾回收"><a href="#StringTable-垃圾回收" class="headerlink" title="StringTable 垃圾回收"></a>StringTable 垃圾回收</h3><ul><li><p>指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-Xmx10m 指定堆内存大小</span><br><span class="line">-XX:+PrintStringTableStatistics 打印字符串常量池信息</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-verbose:gc 打印 gc 的次数，耗费时间等信息</span><br></pre></td></tr></table></figure></li></ul><ul><li>在 Java 8 及更高版本中，字符串常量池位于堆中，而堆是 JVM 中的一部分，因此字符串常量池中的字符串可以被垃圾回收器回收。具体来说，只有当字符串没有被任何对象引用时，它才能被垃圾回收。当字符串被回收时，它的存储空间将被释放并可以被重新利用。</li></ul><h3 id="StringTable性能调优"><a href="#StringTable性能调优" class="headerlink" title="StringTable性能调优"></a>StringTable性能调优</h3><p>JVM内部，字符串常量池就是通过哈希表（数组 + 链表）实现的。</p><ul><li><p>添加VM参数-XX:StringTableSize&#x3D;1024，实际上设置的是哈希表的大小（数组的数量）。较小的哈希表意味着更多的哈希冲突。这会增加查找字符串的开销，因为需要在链表中进行顺序搜索才能找到一个字符串。因此，这将会导致字符串查找速度变慢。</p></li><li><p>如果应用需要存储大量字符串常量信息，而且这些字符串常量包含大量重复内容，可以使用Java中的字符串常量池机制，通过调用intern()方法将常量放入常量池中，以节省内存空间并提高性能。</p></li><li><p>实际应用：</p><ul><li>根据推特的工程师们所说，推特在存储用户地址信息时采用了字符串常量池的方法。推特上有大量的用户地址信息，而这些信息中有大量的重复内容，如街道名称、城市、州等。通过将这些常见的地址信息存储在字符串常量池中，推特可以节省大量的内存空间。</li><li>推特使用了Guava库中的Interners工具类来实现字符串常量池。该工具类提供了线程安全的字符串常量池实现，支持不同的策略和配置，例如并发级别、最大容量等。推特选择了使用一个全局的、不限容量的字符串常量池来存储用户地址信息。在存储用户信息时，推特使用了String.intern()方法来将地址信息存储在字符串常量池中，而不是直接使用新的字符串对象。这样，推特可以确保相同的地址信息只会在内存中存在一份拷贝，从而减少内存的占用。</li><li>通过这种方法，推特成功地实现了在存储大量用户信息时，有效地减少了内存占用。</li></ul></li></ul><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>如果我们需要存储大量字符串常量信息，而且这些字符串常量包含大量重复内容，可以使用Java中的字符串常量池机制，通过调用intern()方法将常量放入常量池中，以节省内存空间并提高性能。</p><h1 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h1><p><strong>定义：</strong></p><ul><li>JVM的直接内存是指JVM中的一个内存区域，也被称为NIO直接缓冲区。和Java堆不同，直接内存并不是由JVM自动管理的，而是由操作系统直接管理的。直接内存的访问速度比Java堆要快，因为它们可以利用操作系统提供的一些优化机制来提高I&#x2F;O的效率。</li><li>在Java程序中，可以通过ByteBuffer.allocateDirect()方法来创建直接缓冲区。当调用该方法创建直接缓冲区时，JVM会向操作系统申请一块直接内存，用于存储该缓冲区的数据。这个过程不会像在Java堆中创建对象一样，需要进行垃圾回收和堆内存分配的操作，因此创建直接缓冲区的效率要高于在Java堆中创建对象。</li><li>需要注意的是，直接内存是不受JVM的内存管理机制控制的，因此如果使用不当，可能会导致内存泄漏等问题。此外，因为直接内存的访问速度快，但申请和释放直接内存的开销较大，因此需要谨慎使用，避免频繁创建和销毁直接缓冲区。</li></ul><p>特点：</p><ol><li>常见于NIO操作时，用于数据缓冲区</li><li>分配回收成本较高，但读写性能高</li><li>不收JVM内存回收管理</li></ol><h2 id="为什么使用它"><a href="#为什么使用它" class="headerlink" title="为什么使用它"></a>为什么使用它</h2><p>使用直接内存比传统IO快</p><p>原因是直接内存使用的是操作系统的文件映射机制，而传统IO则需要将文件内容读取到内存中再进行操作。直接内存可以避免将文件数据复制到Java堆内存中的过程，减少了不必要的数据复制，从而提高了效率。</p><ul><li>传统IO，将文件读取到系统缓冲区中，但是Java代码不能直接读取系统缓冲区，所以需要在堆内存中分配一块Java缓冲区，将数据从系统缓冲区读取到Java缓冲区后，才能进行写操作</li><li>直接内存的Direct Memory对Java堆内存和系统内存是共享的一块内存区，那么磁盘文件就可以直接读取到Direct Memory，而Java堆内存也可以直接访问Direct Memory</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310252201792.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310252202817.png"></p><h2 id="直接内存溢出"><a href="#直接内存溢出" class="headerlink" title="直接内存溢出"></a>直接内存溢出</h2><ul><li>直接内存（Direct Memory）是一种Java NIO中用于高性能I&#x2F;O操作的内存分配方式，与Java虚拟机中的Java堆不同，它不会受到Java堆大小的限制。直接内存是通过操作系统的内存来分配和释放，因此它不会受到Java堆大小限制的影响，可以更加灵活地使用。</li><li>然而，如果过度使用直接内存，也可能会导致直接内存溢出。直接内存的使用需要手动进行管理，如果不注意及时释放已经使用的直接内存，或者申请过多的直接内存，就会导致直接内存溢出。</li><li>当直接内存溢出时，通常会抛出java.lang.OutOfMemoryError异常。为了避免直接内存溢出，建议在使用完直接内存后及时进行释放</li></ul><h2 id="分配和回收原理"><a href="#分配和回收原理" class="headerlink" title="分配和回收原理"></a>分配和回收原理</h2><p>直接内存不受JVM的管理，所以垃圾回收gc()对直接内存无效，那么直接内存是如何分配和回收的呢？</p><ul><li>Java里有一个非常底层的类<code>Unsafe</code>，它可以分配直接内存和释放直接内存，但是一般不建议我们直接使用Unsafe类，都是JDK内部自己去使用这个类的。</li></ul><ul><li><p>所以对于直接内存需要使用<code>Unsafe</code>对象完成直接内存的分配回收，并且回收需要主动调用<code>freeMemory</code>方法</p></li><li><p>ByteBuffer.allocateDirect()的底层实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Allocates a new direct byte buffer.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt; The new buffer&#x27;s position will be zero, its limit will be its</span><br><span class="line"> * capacity, its mark will be undefined, and each of its elements will be</span><br><span class="line"> * initialized to zero.  Whether or not it has a</span><br><span class="line"> * &#123;@link #hasArray backing array&#125; is unspecified.</span><br><span class="line"> *</span><br><span class="line"> * @param  capacity</span><br><span class="line"> *         The new buffer&#x27;s capacity, in bytes</span><br><span class="line"> *</span><br><span class="line"> * @return  The new byte buffer</span><br><span class="line"> *</span><br><span class="line"> * @throws  IllegalArgumentException</span><br><span class="line"> *          If the &lt;tt&gt;capacity&lt;/tt&gt; is a negative integer</span><br><span class="line"> */</span><br><span class="line">public static ByteBuffer allocateDirect(int capacity) &#123;</span><br><span class="line">    return new DirectByteBuffer(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>找到<code>DirectByteBuffer</code>对象的源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// Primary constructor</span><br><span class="line">//</span><br><span class="line">DirectByteBuffer(int cap) &#123;                   // package-private</span><br><span class="line">    super(-1, 0, cap, cap);</span><br><span class="line">    boolean pa = VM.isDirectMemoryPageAligned();</span><br><span class="line">    int ps = Bits.pageSize();</span><br><span class="line">    long size = Math.max(1L, (long)cap + (pa ? ps : 0));</span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">    long base = 0;</span><br><span class="line">    try &#123;</span><br><span class="line">        base = unsafe.allocateMemory(size);</span><br><span class="line">    &#125; catch (OutOfMemoryError x) &#123;</span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        throw x;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.setMemory(base, size, (byte) 0);</span><br><span class="line">    if (pa &amp;&amp; (base % ps != 0)) &#123;</span><br><span class="line">        // Round up to page boundary</span><br><span class="line">        address = base + ps - (base &amp; (ps - 1));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    cleaner = Cleaner.create(this, new Deallocator(base, size, cap));</span><br><span class="line">    att = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>从底层源码中我们可以看到，这里就是使用Unsafe对象对直接内存的分配，但是却没有看到回收方法<code>freeMemory</code></li></ul><ul><li><p>其实释放的方法是在Deallocator()这个回调方法中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private static class Deallocator</span><br><span class="line">    implements Runnable</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    private static Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line">    private long address;</span><br><span class="line">    private long size;</span><br><span class="line">    private int capacity;</span><br><span class="line"></span><br><span class="line">    private Deallocator(long address, long size, int capacity) &#123;</span><br><span class="line">        assert (address != 0);</span><br><span class="line">        this.address = address;</span><br><span class="line">        this.size = size;</span><br><span class="line">        this.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        if (address == 0) &#123;</span><br><span class="line">            // Paranoia</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        unsafe.freeMemory(address);</span><br><span class="line">        address = 0;</span><br><span class="line">        Bits.unreserveMemory(size, capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>而它是由Cleaner调用的， Cleaner（虚引用类型）是用来监测<code>ByteBuffer</code>对象的，一旦<code>ByteBuffer</code>对象被垃圾<code>回收</code>，那么就会由<code>ReferenceHandler</code>线程通过<code>Cleaner</code>的<code>clean</code>方法调用<code>freeMemory</code>来释放直接内存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void clean() &#123;</span><br><span class="line">    if (remove(this)) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            this.thunk.run();</span><br><span class="line">        &#125; catch (final Throwable var2) &#123;</span><br><span class="line">            AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                public Void run() &#123;</span><br><span class="line">                    if (System.err != null) &#123;</span><br><span class="line">                        (new Error(&quot;Cleaner terminated abnormally&quot;, var2)).printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.exit(1);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="禁用垃圾回收对直接内存的影响"><a href="#禁用垃圾回收对直接内存的影响" class="headerlink" title="禁用垃圾回收对直接内存的影响"></a>禁用垃圾回收对直接内存的影响</h2><ul><li>由于垃圾回收是一个相对昂贵的操作，需要消耗CPU时间和系统资源。频繁调用System.gc()可能会导致性能下降，并且在某些情况下可能会造成应用程序的不稳定性。</li><li>所以为了避免有些程序员老是手动调用垃圾回收，我们一般会进制显式手动垃圾回收，添加VM参数<code>-XX:+DisableExplicitGC</code>禁用显式的垃圾回收</li><li>那么加上这个参数以后，可能就会影响到我们的直接内存的回收机制，例如下面的代码中，执行完System.gc()后（被禁用，相当于没执行），由于内存很充裕，所以ByteBuffer对象并不会被回收，那么ByteBuffer对象对应的那块直接内存，也不会被回收</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Demo_16 &#123;</span><br><span class="line">    static int _1GB = 1024 * 1024 * 1024;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1GB);</span><br><span class="line">        System.out.println(&quot;分配完毕&quot;);</span><br><span class="line">        byteBuffer = null;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(&quot;释放完毕&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot</title>
      <link href="/2023/10/24/SpringBoot/"/>
      <url>/2023/10/24/SpringBoot/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot简介"><a href="#SpringBoot简介" class="headerlink" title="SpringBoot简介"></a>SpringBoot简介</h1><p>SpringBoot是由Pivotal团队提供的全新框架，其设计目的是用来 简化 Spring应用的 初始搭建 以及 开发过程 。<br>使用了Spring框架后已经简化了我们的开发，而SpringBoot又是对Spring开发进行简化的，可想而知SpringBoot使用的简单及广泛性。<br>既然SpringBoot是用来简化Spring开发的，那我们就先回顾一下，以SpringMVC开发为例</p><p>一共四步：加依赖、配置web、配置spring、编写controller</p><ol><li><p>创建一个maven工程，并在pom.xml中导入所需依赖的坐标</p><pre><code>&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;        &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;    &lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;    &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;    &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;    &lt;version&gt;3.5.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;    &lt;version&gt;1.3.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;5.1.46&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid&lt;/artifactId&gt;    &lt;version&gt;1.1.16&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;junit&lt;/groupId&gt;    &lt;artifactId&gt;junit&lt;/artifactId&gt;    &lt;version&gt;4.12&lt;/version&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;    &lt;version&gt;3.1.0&lt;/version&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;    &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;/dependencies&gt;</code></pre></li><li><p>编写web3.0的配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer &#123;</span><br><span class="line">    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        return new Class[]&#123;SpringConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        return new Class[]&#123;SpringMvcConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected String[] getServletMappings() &#123;</span><br><span class="line">        return new String[]&#123;&quot;/&quot;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Filter[] getServletFilters() &#123;</span><br><span class="line">        CharacterEncodingFilter filter = new CharacterEncodingFilter();</span><br><span class="line">        filter.setEncoding(&quot;utf-8&quot;);</span><br><span class="line">        return new Filter[]&#123;filter&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写SpringMvc配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.blog.controller&quot;)</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class SpringMvcConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写Controller类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/books&quot;)</span><br><span class="line">public class BookController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private BookService bookService;</span><br><span class="line"></span><br><span class="line">    @PostMapping</span><br><span class="line">    public boolean save(@RequestBody Book book) &#123;</span><br><span class="line">        return bookService.save(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PutMapping</span><br><span class="line">    public boolean update(@RequestBody Book book) &#123;</span><br><span class="line">        return bookService.update(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public boolean delete(@PathVariable Integer id) &#123;</span><br><span class="line">        return bookService.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public Book getById(@PathVariable Integer id) &#123;</span><br><span class="line">        return bookService.getById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping</span><br><span class="line">    public List&lt;Book&gt; getAll() &#123;</span><br><span class="line">        return bookService.getAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>从上面的 SpringMVC 程序开发可以看到，前三步都是在搭建环境，而且这三步基本都是固定的。SpringBoot 就是对这三步进行简化了。接下来我们通过一个入门案例来体现 SpingBoot 简化 Spring 开发。</p><h2 id="SpringBoot快速入门"><a href="#SpringBoot快速入门" class="headerlink" title="SpringBoot快速入门"></a>SpringBoot快速入门</h2><h3 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h3><p>SpringBoot 开发起来特别简单，分为如下几步：</p><ul><li>创建新模块，选择Spring初始化，并配置模块相关基础信息</li><li>选择当前模块需要使用的技术集</li><li>开发控制器类</li><li>运行自动生成的Application类<br>知道了 SpringBoot 的开发步骤后，下面我们进行具体的操作</li></ul><p>实现：</p><ul><li>步骤一： 创建新模块<br>  在IDEA下创建一个新模块，选择Spring Initializr，用来创建SpringBoot工程</li></ul><p>  选中 Web，然后勾选 Spring Web，由于我们需要开发一个  web  程序，使用到了  SpringMVC  技术，所以按照下图红框进行勾选</p><p>  最后点击创建，就大功告成了，经过以上步骤后就创建了如下结构的模块，它会帮我们自动生成一个 Application 类，而该类一会再启动服务器时会用到</p><p>  注意：</p><ol><li><strong>编写项目的时候不要配置Artifact，这里只需要group的名字</strong></li><li>在创建好的工程中不需要创建配置类</li><li>创建好的项目会自动生成其他的一些文件，而这些文件目前对我们来说没有任何作用，所以可以将这些文件删除。</li><li>可以删除的目录和文件如下：<ul><li>.mvn </li><li>.gitignore </li><li>HELP.md </li><li>mvnw </li><li>mvnw.cmd</li></ul></li></ol><ul><li>步骤二： 创建Controller（除了controller，其余配置都被简化了）<br>  在 com.blog.controller 包下创建BookController，代码如下</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/books&quot;)</span><br><span class="line">public class BookController &#123;</span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public String getById(@PathVariable Integer id) &#123;</span><br><span class="line">        System.out.println(&quot;get id ==&gt; &quot; + id);</span><br><span class="line">        return &quot;hello,spring boot!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>步骤三： 启动服务器<br>  运行  SpringBoot  工程不需要使用本地的  Tomcat  和 插件，只运行项目  com.blog  包下的  Application  类，我们就可以在控制台看出如下信息</li></ul><p>  springboot自带一个java类，这个类就是运行类</p><ul><li>步骤四： 进行测试<br>  依旧是使用PostMan来测试，发送GET请求访问 localhost:8080&#x2F;books&#x2F;9527<br>  可以看到响应回来的结果 hello,spring boot!<br>  同时控制台也输出了 get id &#x3D;&#x3D;&gt; 9527</li></ul><blockquote><p><strong>总结：springboot项目创建也是四步，但是只有controller需要自己实现，其余都自动实现了</strong></p></blockquote><p>通过上面的入门案例我们可以看到使用  SpringBoot  进行开发，使整个开发变得很简单，那它是如何做到的呢？</p><ul><li><p>要研究这个问题，我们需要看看  Application  类和  pom.xml  都书写了什么。先看看  Applicaion  类，该类内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类中的东西很简单，就在类上添加了一个  @SpringBootApplication  注解，而在主方法中就一行代码。我们在启动服务器时就是执行的该类中的主方法。</p></li><li><p>再看看  pom.xml  配置文件中的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;!--指定了一个父工程，父工程中的东西在该工程中可以继承过来使用--&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.7.3&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springboot_01_quickstart&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!--JDK 的版本--&gt;</span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--该依赖就是我们在创建 SpringBoot 工程勾选的那个 Spring Web 产生的--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--这个是单元测试的依赖，我们现在没有进行单元测试，所以这个依赖现在可以没有--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;!--这个插件是在打包时需要的，而这里暂时还没有用到--&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li></ul><p>我们代码之所以能简化，就是因为指定的父工程和  Spring Web  依赖实现的。具体的我们后面在聊。</p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>做完  SpringBoot  的入门案例后，接下来对比一下  Spring  程序和  SpringBoot  程序。</p><table><thead><tr><th align="center">类&#x2F;配置文件</th><th align="center">Spring</th><th align="center">SpringBoot</th></tr></thead><tbody><tr><td align="center">pom文件中的坐标</td><td align="center">手工添加</td><td align="center">勾选添加</td></tr><tr><td align="center">web3.e配置类</td><td align="center">手工制作</td><td align="center">无</td></tr><tr><td align="center">Spring&#x2F;SpringMVC配置类</td><td align="center">手工制作</td><td align="center">无</td></tr><tr><td align="center">控制器</td><td align="center">手工制作</td><td align="center">手工制作</td></tr></tbody></table><ul><li>坐标<br> Spring  程序中的坐标需要自己编写，而且坐标非常多<br> SpringBoot  程序中的坐标是我们在创建工程时进行勾选自动生成的</li><li>web3.0配置类<br> Spring  程序需要自己编写这个配置类。这个配置类我们之前编写过，肯定感觉很复杂<br> SpringBoot  程序不需要我们自己书写</li><li>配置类<br> Spring&#x2F;SpringMVC  程序的配置类需要自己书写。而  SpringBoot  程序则不需要书写。</li></ul><p>注意：基于Idea的  Spring Initializr  快速构建  SpringBoot  工程时需要联网。</p><h2 id="官网构建工程"><a href="#官网构建工程" class="headerlink" title="官网构建工程"></a>官网构建工程</h2><p>在入门案例中之所以能快速构建  SpringBoot  工程，是因为  Idea  使用了官网提供了快速构建  SpringBoot  工程的组件实现的。<br>首先进入SpringBoot官网 <a href="https://spring.io/projects/spring-boot">https://spring.io/projects/spring-boot</a> ，拉到页面最下方，会有一个 Quickstart your project<br>然后点击 Spring Initializr 超链接，就会跳转到如下页面，构建工程的步骤与我们在IDEA中几乎没什么区别</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310241216558.png"></p><p>点击 GENERATE ，就可以生成工程并下载到本地了，打开下载好的压缩包，可以看到工程的内容与IDEA生成的一模一样。<br>通过上面官网的操作，我们知道  Idea  中快速构建  SpringBoot  工程其实就是使用的官网的快速构建组件，那以后即使没有  Idea  也可以使用官网的方式构建  SpringBoot  工程。</p><h2 id="SpringBoot工程快速启动"><a href="#SpringBoot工程快速启动" class="headerlink" title="SpringBoot工程快速启动"></a>SpringBoot工程快速启动</h2><ul><li><p>问题引入<br>以后我们和前端开发人员协同开发，而前端开发人员需要测试前端程序就需要后端开启服务器，这就受制于后端开发人员。为了摆脱这个受制，前端开发人员尝试着在自己电脑上安装  Tomcat  和  Idea  ，在自己电脑上启动后端程序，这显然不现实。<br>我们后端可以将  SpringBoot  工程打成  jar  包，该  jar  包运行不依赖于  Tomcat  和  Idea  这些工具也可以正常运行，只是这个  jar  包在运行过程中连接和我们自己程序相同的  Mysql  数据库即可，这样就可以解决这个问题。</p></li><li><p>那现在问题就是如何打包<br>由于我们在构建  SpringBoot  工程时已经在  pom.xml  中配置了如下插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure></li></ul><p>所以我们只需要使用  Maven  的  package  指令打包就会在  target  目录下生成对应的  Jar  包。</p><blockquote><p>注意：该插件必须配置，不然打好的  jar  包也是有问题的。</p></blockquote><ul><li><p>快速启动<br>进入  jar  包所在位置，在  命令提示符  中输入如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar springboot_01_quickstart-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p>执行上述命令就可以看到  SpringBoot  运行的日志信息，同时使用PostMan发送GET请求访问 localhost:8080&#x2F;books&#x2F;9527 ，也可以正常输出get id &#x3D;&#x3D;&gt; 9527</p></li></ul><blockquote><p>pom中的那个插件就是用来实现快速启动的</p><p>快速打包需要用Maven的package指令进行打包</p><p>虽然能快速启动，但是数据库还是那个数据库，要连到固定数据库上</p></blockquote><h1 id="SpringBoot概述"><a href="#SpringBoot概述" class="headerlink" title="SpringBoot概述"></a>SpringBoot概述</h1><p> SpringBoot  是由Pivotal团队提供的全新框架，其设计目的是用来 简化 Spring应用的 初始搭建 以及 开发过程 。</p><p>原始  Spring  环境搭建和开发存在以下问题</p><ul><li>配置繁琐</li><li>依赖设置繁琐<br> SpringBoot  程序优点恰巧就是针对  Spring  的缺点</li><li>自动配置。这个是用来解决  Spring  程序配置繁琐的问题</li><li>起步依赖。这个是用来解决  Spring  程序依赖设置繁琐的问题</li><li>辅助功能（内置服务器，…）。我们在启动  SpringBoot  程序时既没有使用本地的  tomcat  也没有使用  tomcat  插件，而是使用  SpringBoot  内置的服务器。</li></ul><p>接下来我们来说一下  SpringBoot  的起步依赖</p><h2 id="起步依赖"><a href="#起步依赖" class="headerlink" title="起步依赖"></a>起步依赖</h2><p>我们使用  Spring Initializr  方式创建的  Maven  工程的的  pom.xml  配置文件中自动生成了很多包含  starter  的依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;!--                      ↓↓↓              --&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.7.3&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt; </span><br><span class="line">&lt;/parent&gt;</span><br><span class="line">&lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;springboot_01_quickstart&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;!--                      ↓↓↓              --&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;!--                      ↓↓↓              --&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h3 id="父工程"><a href="#父工程" class="headerlink" title="父工程"></a>父工程</h3><p>从上面的文件中可以看到指定了一个父工程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.7.3&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure><p>进入到父工程，发现父工程中又指定了一个父工程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.7.3&lt;/version&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure><p>进入到<strong>爷工程</strong>中，在该工程中我们可以看到配置内容结构如下</p><div class="tabs" id="1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#1-1">properties</button></li><li class="tab"><button type="button" data-href="#1-2">dependencyManagement</button></li><li class="tab"><button type="button" data-href="#1-3">plugin</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><p> properties  标签中定义了各个技术软件依赖的版本，避免了我们在使用不同软件技术时考虑版本的兼容问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;activemq.version&gt;5.16.5&lt;/activemq.version&gt;</span><br><span class="line">&lt;antlr2.version&gt;2.7.7&lt;/antlr2.version&gt;</span><br><span class="line">&lt;appengine-sdk.version&gt;1.9.98&lt;/appengine-sdk.version&gt;</span><br><span class="line">&lt;artemis.version&gt;2.19.1&lt;/artemis.version&gt;</span><br><span class="line">&lt;aspectj.version&gt;1.9.7&lt;/aspectj.version&gt;</span><br><span class="line">&lt;assertj.version&gt;3.22.0&lt;/assertj.version&gt;</span><br><span class="line">&lt;atomikos.version&gt;4.0.6&lt;/atomikos.version&gt;</span><br><span class="line">&lt;awaitility.version&gt;4.2.0&lt;/awaitility.version&gt;</span><br><span class="line">&lt;build-helper-maven-plugin.version&gt;3.3.0&lt;/build-helper-maven-plugin.version&gt;</span><br><span class="line">&lt;byte-buddy.version&gt;1.12.13&lt;/byte-buddy.version&gt;</span><br><span class="line"></span><br><span class="line">···</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-2"><p> dependencyManagement  标签是进行依赖版本锁定，但是并没有导入对应的依赖；如果我们工程需要那个依赖只需要引入依赖的  groupid  和  artifactId  不需要定义  version 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;activemq-amqp&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;activemq.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;activemq-blueprint&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;activemq.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;activemq-broker&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;activemq.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">···</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-3"><p>而  build  标签中也对插件的版本进行了锁定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;build-helper-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;build-helper-maven-plugin.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.flywaydb&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;flyway-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;flyway.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;pl.project13.maven&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;git-commit-id-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;git-commit-id-plugin.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line"></span><br><span class="line">···</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>父工程中指明版本</p><h3 id="starter起步依赖"><a href="#starter起步依赖" class="headerlink" title="starter起步依赖"></a>starter起步依赖</h3><p>工程中的pom.xml中配置了如下依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>进入到该依赖，查看pom.xml的依赖，会发现它引入了如下依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.7.3&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.3.22&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.3.22&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>里面的引入了  spring-web  和  spring-webmvc  的依赖，这就是为什么我们的工程中没有依赖这两个包还能正常使用  springMVC  中的注解的原因。<br>而依赖  spring-boot-starter-tomcat  ，从名字基本能确认内部依赖了  tomcat ，所以我们的工程才能正常启动。<br>结论：以后需要使用技术，只需要引入该技术对应的起步依赖即可</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>starter：</p><ul><li>SpringBoot  中常见项目名称，定义了当前项目使用的所有项目坐标，以达到减少依赖配置的目的</li></ul><p>parent：</p><ul><li>所有  SpringBoot  项目要继承的项目，定义了若干个坐标版本号（依赖管理，而非依赖），以达到减少依赖冲突的目的</li></ul><p>实际开发：</p><ul><li>使用任意坐标时，仅书写GAV中的G和A，V由SpringBoot提供<ul><li>G：groupid</li><li>A：artifactId</li><li>V：version</li></ul></li><li>如发生坐标错误，再指定version（要小心版本冲突）</li></ul><h2 id="程序启动"><a href="#程序启动" class="headerlink" title="程序启动"></a>程序启动</h2><p>创建的每一个  SpringBoot  程序时都包含一个类似于下面的类，我们将这个类称作引导类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class Springboot01QuickstartApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Springboot01QuickstartApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>SpringBoot  在创建项目时，采用jar的打包方式</li><li>SpringBoot  的引导类是项目的入口，运行  main  方法就可以启动项目<br>  因为我们在  pom.xml  中配置了  spring-boot-starter-web  依赖，而该依赖通过前面的学习知道它依赖  tomcat  ，所以运行  main  方法就可以使用  tomcat  启动咱们的工程。</li></ul><h2 id="切换web服务器"><a href="#切换web服务器" class="headerlink" title="切换web服务器"></a>切换web服务器</h2><p>现在我们启动工程使用的是  tomcat  服务器，那能不能不使用  tomcat  而使用  jetty  服务器。而要切换  web  服务器就需要将默认的  tomcat  服务器给排除掉，怎么排除呢？需要用到我们前面学的知识 排除依赖 ，使用  exclusion  标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>然后还要引入  jetty  服务器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;xxxxxxxxxx &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;&lt;/dependency&gt;XML</span><br></pre></td></tr></table></figure><p>接下来再次运行引导类，在日志信息中就可以看到使用的是jetty服务器</p><blockquote><p>通过切换服务器，我们不难发现在使用  SpringBoot  换技术时只需要导入该技术的 起步依赖 即可。</p></blockquote><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><h2 id="配置文件格式"><a href="#配置文件格式" class="headerlink" title="配置文件格式"></a>配置文件格式</h2><p> SpringBoot  提供了 3 种属性配置方式</p><p>注意： SpringBoot  程序的配置文件名必须是  application  ，只是后缀名不同而已。</p><div class="tabs" id="2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2-1">application.properties</button></li><li class="tab"><button type="button" data-href="#2-2">application.yml</button></li><li class="tab"><button type="button" data-href="#2-3">application.yaml</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2-1"><p>配置文件必须放在  resources  目录下，而该目录下有一个名为  application.properties  的配置文件（SpringBoot已经为我们提供好了），我们就可以在该配置文件中修改端口号，在该配置文件中书写  port  ， Idea  就会补全提示</p><p>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=80</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2-2"><p>在  resources  下（同级）创建一个名为  application.yml  的配置文件，在该文件中书写端口号的配置项，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 81</span><br></pre></td></tr></table></figure><p>注意： 在 : 后，数据前一定要加空格。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2-3"><p>然后在  resources  下创建名为  application.yaml  的配置文件，配置内容和后缀名为  yml  的配置文件中的内容相同，只是使用了不同的后缀名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 82</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>三种配合文件的优先级：</p><p>properties &gt; yml &gt; yaml</p><h2 id="yaml格式"><a href="#yaml格式" class="headerlink" title="yaml格式"></a>yaml格式</h2><p>YAML（YAML Ain’t Markup Language），一种数据序列化格式。这种格式的配置文件在近些年已经占有主导地位，那么这种配置文件和前期使用的配置文件是有一些优势的，我们先看之前使用的配置文件。</p><p>最开始我们使用的是  xml  ，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;enterprise&gt;</span><br><span class="line">    &lt;name&gt;Helsing&lt;/name&gt;</span><br><span class="line">    &lt;age&gt;16&lt;/age&gt;</span><br><span class="line">    &lt;tel&gt;400-957-241&lt;/tel&gt;</span><br><span class="line">&lt;/enterprise&gt;</span><br></pre></td></tr></table></figure><p>而  properties  类型的配置文件如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enterprise.name=Helsing</span><br><span class="line">enterprise.age=16</span><br><span class="line">enterprise.tel=400-957-241</span><br></pre></td></tr></table></figure><p>yaml 类型的配置文件内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enterprise:</span><br><span class="line">  name: Helsing</span><br><span class="line">  age: 16</span><br><span class="line">  tel: 400-957-241</span><br></pre></td></tr></table></figure><p>通过对比，我们得出yaml的优点有：</p><ul><li>容易阅读<ul><li>yaml  类型的配置文件比  xml  类型的配置文件更容易阅读，结构更加清晰</li></ul></li><li>容易与脚本语言交互（暂时还体会不到，后面会了解）</li><li>以数据为核心，重数据轻格式<ul><li>yaml  更注重数据，而  xml  更注重格式</li></ul></li></ul><p>YAML 文件扩展名：</p><ul><li>.yml  (主流)</li><li>.yaml</li></ul><p>上面两种后缀名都可以，以后使用更多的还是  yml  的。</p><h2 id="yml语法规则"><a href="#yml语法规则" class="headerlink" title="yml语法规则"></a>yml语法规则</h2><ul><li><p>大小写敏感</p></li><li><p>属性层级关系使用多行描述，每行结尾使用冒号结束</p></li><li><p>使用缩进表示层级关系，同层级左侧对齐，只允许使用空格（不允许使用Tab键）</p><ul><li>空格的个数并不重要，只要保证同层级的左侧对齐即可。</li></ul></li><li><p><strong>属性值前面添加空格</strong>（属性名与属性值之间使用冒号+空格作为分隔）</p></li><li><p>数组数据在数据书写位置的下方使用减号作为数据开始符号，每行书写一个数据，减号与数据间空格分隔</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enterprise:</span><br><span class="line">  name: Helsing</span><br><span class="line">  age: 16</span><br><span class="line">  tel: 400-957-241</span><br><span class="line">  subject:</span><br><span class="line">    - Java</span><br><span class="line">    - Python</span><br><span class="line">    - C#</span><br></pre></td></tr></table></figure></li></ul><h2 id="yaml配置文件数据读取"><a href="#yaml配置文件数据读取" class="headerlink" title="yaml配置文件数据读取"></a>yaml配置文件数据读取</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ul><li><p>修改 resource 目录下的 application.yml 配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">lesson: SpringBoot</span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line">  port: 80</span><br><span class="line"></span><br><span class="line">enterprise:</span><br><span class="line">  name: Helsing</span><br><span class="line">  age: 16</span><br><span class="line">  tel: 400-957-241</span><br><span class="line">  subject:</span><br><span class="line">    - Java</span><br><span class="line">    - Python</span><br><span class="line">    - C#</span><br></pre></td></tr></table></figure></li><li><p>在 com.blog.domain 包下新建一个Enterprise类，用来封装数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package com.blog.domain;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class Enterprise &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private String tel;</span><br><span class="line">    private String[] subject;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getTel() &#123;</span><br><span class="line">        return tel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTel(String tel) &#123;</span><br><span class="line">        this.tel = tel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String[] getSubject() &#123;</span><br><span class="line">        return subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSubject(String[] subject) &#123;</span><br><span class="line">        this.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Enterprise&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &quot;, tel=&#x27;&quot; + tel + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, subject=&quot; + Arrays.toString(subject) +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="读取配置文件"><a href="#读取配置文件" class="headerlink" title="读取配置文件"></a>读取配置文件</h3><div class="tabs" id="3"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#3-1"><i class="Value注解"></i>使用</button></li><li class="tab"><button type="button" data-href="#3-2">使用 Environment 对象</button></li><li class="tab"><button type="button" data-href="#3-3">使用自定义对象</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="3-1"><p>使用  @Value(“表达式”)  注解可以从配合文件中读取数据，注解中用于读取属性名引用方式是： ${一级属性名.二级属性名……} </p><p>我们可以在  BookController  中使用  @Value  注解读取配合文件数据，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/books&quot;)</span><br><span class="line">public class BookController &#123;</span><br><span class="line">    @Value(&quot;$&#123;lesson&#125;&quot;)</span><br><span class="line">    private String lesson;</span><br><span class="line">    @Value(&quot;$&#123;server.port&#125;&quot;)</span><br><span class="line">    private Integer port;</span><br><span class="line">    @Value(&quot;$&#123;enterprise.subject[0]&#125;&quot;)</span><br><span class="line">    private String subject_0;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public String getById(@PathVariable Integer id) &#123;</span><br><span class="line">        System.out.println(lesson);</span><br><span class="line">        System.out.println(port);</span><br><span class="line">        System.out.println(subject_0);</span><br><span class="line">        return &quot;hello , spring boot!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3-2"><p>上面方式读取到的数据特别零散， SpringBoot  还可以使用  @Autowired  注解注入  Environment  对象的方式读取数据。这种方式  SpringBoot  会将配置文件中所有的数据封装到  Environment  对象中，如果需要使用哪个数据只需要通过调用  Environment  对象的  getProperty(String name)  方法获取。具体代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/books&quot;)</span><br><span class="line">public class BookController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private Environment environment;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public String getById(@PathVariable Integer id) &#123;</span><br><span class="line">        System.out.println(environment.getProperty(&quot;lesson&quot;));</span><br><span class="line">        System.out.println(environment.getProperty(&quot;enterprise.name&quot;));</span><br><span class="line">        System.out.println(environment.getProperty(&quot;enterprise.subject[1]&quot;));</span><br><span class="line">        return &quot;hello , spring boot!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：这种方式在开发中很少用，因为框架内含大量数据</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3-3"><p>SpringBoot还提供了将配置文件中的数据封装到我们自定义的实体类对象中的方式。具体操作如下：</p><ul><li><p>将实体类bean的创建交给Spring管理。</p><ul><li>在类上添加  @Component  注解</li></ul></li><li><p>使用@ConfigurationProperties</p><p> 注解表示加载配置文件</p><ul><li>在该注解中也可以使用  prefix  属性指定只加载指定前缀的数据</li></ul></li><li><p>在  BookController  中进行注入</p></li></ul><p>Enterprise 实体类内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(prefix = &quot;enterprise&quot;)</span><br><span class="line">public class Enterprise &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private String tel;</span><br><span class="line">    private String[] subject;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getTel() &#123;</span><br><span class="line">        return tel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTel(String tel) &#123;</span><br><span class="line">        this.tel = tel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String[] getSubject() &#123;</span><br><span class="line">        return subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSubject(String[] subject) &#123;</span><br><span class="line">        this.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Enterprise&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &quot;, tel=&#x27;&quot; + tel + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, subject=&quot; + Arrays.toString(subject) +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BooKController内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/books&quot;)</span><br><span class="line">public class BookController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private Enterprise enterprise;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public String getById(@PathVariable Integer id) &#123;</span><br><span class="line">        System.out.println(enterprise);</span><br><span class="line">        System.out.println(enterprise.getAge());</span><br><span class="line">        System.out.println(enterprise.getName());</span><br><span class="line">        System.out.println(enterprise.getTel());</span><br><span class="line">        return &quot;hello , spring boot!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h1><p>后在工作中，对于开发环境、测试环境、生产环境的配置肯定都不相同，比如我们开发阶段会在自己的电脑上安装  mysql  ，连接自己电脑上的  mysql  即可，但是项目开发完毕后要上线就需要该配置，将环境的配置改为线上环境的。<br>来回的修改配置会很麻烦，而  SpringBoot  给开发者提供了多环境的快捷配置，需要切换环境时只需要改一个配置即可。不同类型的配置文件多环境开发的配置都不相同，接下来对不同类型的配置文件进行说明</p><h2 id="yaml文件"><a href="#yaml文件" class="headerlink" title="yaml文件"></a>yaml文件</h2><p>在  application.yml  中使用  —  来分割不同的配置，内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">## 开发环境</span><br><span class="line">spring:</span><br><span class="line">  profiles: dev ## 给开发环境取的名</span><br><span class="line">server:</span><br><span class="line">  port: 80</span><br><span class="line">---</span><br><span class="line">## 生产环境</span><br><span class="line">spring:</span><br><span class="line">  profiles: pro ## 给生产环境取的名</span><br><span class="line">server:</span><br><span class="line">  port: 81</span><br><span class="line">---</span><br><span class="line">## 测试环境</span><br><span class="line">spring:</span><br><span class="line">  profiles: test ## 给测试环境起的名</span><br><span class="line">server:</span><br><span class="line">  port: 82</span><br></pre></td></tr></table></figure><p>上面配置中  spring.profiles  是用来给不同的配置起名字的。而如何告知  SpringBoot  使用哪段配置呢？可以使用如下配置来启用都一段配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## 设置启用的环境</span><br><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev  ## 表示使用的是开发环境的配置</span><br></pre></td></tr></table></figure><p>整合：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br><span class="line">---</span><br><span class="line">## 开发环境</span><br><span class="line">spring:</span><br><span class="line">  profiles: dev ## 给开发环境取的名</span><br><span class="line">server:</span><br><span class="line">  port: 80</span><br><span class="line">---</span><br><span class="line">## 生产环境</span><br><span class="line">spring:</span><br><span class="line">  profiles: pro ## 给生产环境取的名</span><br><span class="line">server:</span><br><span class="line">  port: 81</span><br><span class="line">---</span><br><span class="line">## 测试环境</span><br><span class="line">spring:</span><br><span class="line">  profiles: test ## 给测试环境起的名</span><br><span class="line">server:</span><br><span class="line">  port: 82</span><br></pre></td></tr></table></figure><p>注意：在上面配置中给不同配置起名字的  spring.profiles  配置项已经过时，但是能用。最新用来起名字的配置项是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## 开发环境</span><br><span class="line">spring:</span><br><span class="line">  config:</span><br><span class="line">    activate:</span><br><span class="line">      on-profile: dev ## 给开发环境取的名</span><br></pre></td></tr></table></figure><h2 id="命令行启动参数设置"><a href="#命令行启动参数设置" class="headerlink" title="命令行启动参数设置"></a>命令行启动参数设置</h2><p>使用  SpringBoot  开发的程序以后都是打成  jar  包，通过  java -jar xxx.jar  的方式启动服务的。那么就存在一个问题，如何切换环境呢？因为配置文件打到的jar包中了。</p><p> SpringBoot  提供了在运行  jar  时设置开启指定的环境的方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">测试</span><br><span class="line">java -jar xxx.jar --spring.profiles.active=test</span><br><span class="line"></span><br><span class="line">临时修改端口号</span><br><span class="line">java -jar xxx.jar --server.port=9421</span><br><span class="line"></span><br><span class="line">指定启用哪个环境配置，又临时指定端口</span><br><span class="line">java -jar xxx.jar -server.port=9421 --spring.profiles.active=pro</span><br></pre></td></tr></table></figure><p>配置的优先级官网已经进行了说明。</p><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config">https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config</a></p><h1 id="配置文件分类"><a href="#配置文件分类" class="headerlink" title="配置文件分类"></a>配置文件分类</h1><p>有这样的场景，我们开发完毕后需要测试人员进行测试，由于测试环境和开发环境的很多配置都不相同，所以测试人员在运行我们的工程时需要临时修改很多配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java –jar springboot.jar –-spring.profiles.active=test --server.port=85 --server.servlet.context-path=/heima --server.tomcat.connection-timeout=-1 …… …… …… …… ……</span><br></pre></td></tr></table></figure><p>针对这种情况， SpringBoot  定义了配置文件不同的放置的位置；而放在不同位置的优先级时不同的。</p><p>SpringBoot中4级配置文件放置位置：</p><ul><li>1级：classpath：application.yml</li><li>2级：classpath：config&#x2F;application.yml</li></ul><p>分界线，以同级为界，上面两个在 jar 包里面，下面两个在 jar 包外</p><ul><li>3级：file ：application.yml</li><li>4级：file ：config&#x2F;application.yml</li></ul><p>说明：级别越高的优先级越高</p><h1 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h1><h2 id="整合Junit"><a href="#整合Junit" class="headerlink" title="整合Junit"></a>整合Junit</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310242218493.png"></p><p>使用  @RunWith  注解指定运行器，使用  @ContextConfiguration  注解来指定配置类或者配置文件。</p><p>而  SpringBoot  整合  junit  特别简单，分为以下三步完成</p><ul><li>在测试类上添加  SpringBootTest  注解</li><li>使用  @Autowired  注入要测试的资源</li><li>定义测试方法进行测试</li></ul><h3 id="SpringBoot整合"><a href="#SpringBoot整合" class="headerlink" title="SpringBoot整合"></a>SpringBoot整合</h3><h4 id="环境准备-1"><a href="#环境准备-1" class="headerlink" title="环境准备"></a>环境准备</h4><ul><li><p>创建一个新的SpringBoot工程</p></li><li><p>在com.blog.service包下创建BookService接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface BookService &#123;</span><br><span class="line">    void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在com.blog.service.impl包下创建BookService接口的实现类，并重写其方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class BookServiceImpl implements BookService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book service is running ..&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="编写测试类"><a href="#编写测试类" class="headerlink" title="编写测试类"></a>编写测试类</h4><p>在  test&#x2F;java  下创建  com.blog  包，在该包下创建测试类，将  BookService  注入到该测试类中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">class Springboot02JunitApplicationTests &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private BookService bookService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void contextLoads() &#123;</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试方法，控制台成功输出</p><p>注意：这里的引导类所在包必须是测试类所在包及其子包。</p><p>例如：</p><ul><li>引导类所在包是  com.blog </li><li>测试类所在包是  com.blog</li></ul><p>如果不满足这个要求的话，就需要在使用  @SpringBootTest  注解时，使用  classes  属性指定引导类的字节码对象。如  @SpringBootTest(classes &#x3D; XxxApplication.class) </p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310242222895.png"></p><h2 id="整合MyBatis"><a href="#整合MyBatis" class="headerlink" title="整合MyBatis"></a>整合MyBatis</h2><h3 id="回顾Spring整合MyBatis"><a href="#回顾Spring整合MyBatis" class="headerlink" title="回顾Spring整合MyBatis"></a>回顾Spring整合MyBatis</h3><p>之前Spring整合MyBatis时，需要定义很多配置类</p><ul><li>SpringConfig配置类</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.blog&quot;)</span><br><span class="line">@PropertySource(&quot;jdbc.properties&quot;)</span><br><span class="line">@Import(&#123;JdbcConfig.class, MyBatisConfig.class&#125;)</span><br><span class="line">public class SpringConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>导入JdbcConfig配置类</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class JdbcConfig &#123;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span><br><span class="line">    private String driver;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.url&#125;&quot;)</span><br><span class="line">    private String url;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.username&#125;&quot;)</span><br><span class="line">    private String username;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.password&#125;&quot;)</span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource() &#123;</span><br><span class="line">        DruidDataSource dataSource = new DruidDataSource();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        return dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>导入MyBatisConfig配置类<ul><li>定义  SqlSessionFactoryBean </li><li>定义映射配置</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class MyBatisConfig &#123;</span><br><span class="line"></span><br><span class="line">    //定义bean，SqlSessionFactoryBean，用于产生SqlSessionFactory对象</span><br><span class="line">    @Bean</span><br><span class="line">    public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource) &#123;</span><br><span class="line">        SqlSessionFactoryBean sqlSessionFactory = new SqlSessionFactoryBean();</span><br><span class="line">        //设置模型类的别名扫描</span><br><span class="line">        sqlSessionFactory.setTypeAliasesPackage(&quot;com.blog.domain&quot;);</span><br><span class="line">        //设置数据源</span><br><span class="line">        sqlSessionFactory.setDataSource(dataSource);</span><br><span class="line">        return sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    //定义bean，返回MapperScannerConfigurer对象</span><br><span class="line">    @Bean</span><br><span class="line">    public MapperScannerConfigurer mapperScannerConfigurer() &#123;</span><br><span class="line">        MapperScannerConfigurer msc = new MapperScannerConfigurer();</span><br><span class="line">        msc.setBasePackage(&quot;com.blog.dao&quot;);</span><br><span class="line">        return msc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringBoot整合MyBatis"><a href="#SpringBoot整合MyBatis" class="headerlink" title="SpringBoot整合MyBatis"></a>SpringBoot整合MyBatis</h3><ul><li><p>创建一个新的模块<br>注意选择技术集的时候，要勾选 MyBatis Framework 和 MySQL Driver </p></li><li><p>建库建表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE springboot_db;</span><br><span class="line">USE springboot_db;</span><br><span class="line"></span><br><span class="line">CREATE TABLE tbl_book</span><br><span class="line">(</span><br><span class="line">    id          INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    `type`      VARCHAR(20),</span><br><span class="line">    `name`      VARCHAR(50),</span><br><span class="line">    description VARCHAR(255)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO `tbl_book`(`id`, `type`, `name`, `description`)</span><br><span class="line">VALUES (1, &#x27;计算机理论&#x27;, &#x27;Spring实战 第五版&#x27;, &#x27;Spring入门经典教程，深入理解Spring原理技术内幕&#x27;),</span><br><span class="line">       (2, &#x27;计算机理论&#x27;, &#x27;Spring 5核心原理与30个类手写实践&#x27;, &#x27;十年沉淀之作，手写Spring精华思想&#x27;),</span><br><span class="line">       (3, &#x27;计算机理论&#x27;, &#x27;Spring 5设计模式&#x27;, &#x27;深入Spring源码刨析Spring源码中蕴含的10大设计模式&#x27;),</span><br><span class="line">       (4, &#x27;计算机理论&#x27;, &#x27;Spring MVC+Mybatis开发从入门到项目实战&#x27;,</span><br><span class="line">        &#x27;全方位解析面向Web应用的轻量级框架，带你成为Spring MVC开发高手&#x27;),</span><br><span class="line">       (5, &#x27;计算机理论&#x27;, &#x27;轻量级Java Web企业应用实战&#x27;, &#x27;源码级刨析Spring框架，适合已掌握Java基础的读者&#x27;),</span><br><span class="line">       (6, &#x27;计算机理论&#x27;, &#x27;Java核心技术 卷Ⅰ 基础知识(原书第11版)&#x27;,</span><br><span class="line">        &#x27;Core Java第11版，Jolt大奖获奖作品，针对Java SE9、10、11全面更新&#x27;),</span><br><span class="line">       (7, &#x27;计算机理论&#x27;, &#x27;深入理解Java虚拟机&#x27;, &#x27;5个纬度全面刨析JVM,大厂面试知识点全覆盖&#x27;),</span><br><span class="line">       (8, &#x27;计算机理论&#x27;, &#x27;Java编程思想(第4版)&#x27;, &#x27;Java学习必读经典，殿堂级著作！赢得了全球程序员的广泛赞誉&#x27;),</span><br><span class="line">       (9, &#x27;计算机理论&#x27;, &#x27;零基础学Java(全彩版)&#x27;, &#x27;零基础自学编程的入门图书，由浅入深，详解Java语言的编程思想和核心技术&#x27;),</span><br><span class="line">       (10, &#x27;市场营销&#x27;, &#x27;直播就这么做:主播高效沟通实战指南&#x27;, &#x27;李子柒、李佳奇、薇娅成长为网红的秘密都在书中&#x27;),</span><br><span class="line">       (11, &#x27;市场营销&#x27;, &#x27;直播销讲实战一本通&#x27;, &#x27;和秋叶一起学系列网络营销书籍&#x27;),</span><br><span class="line">       (12, &#x27;市场营销&#x27;, &#x27;直播带货:淘宝、天猫直播从新手到高手&#x27;, &#x27;一本教你如何玩转直播的书，10堂课轻松实现带货月入3W+&#x27;);</span><br></pre></td></tr></table></figure></li><li><p>定义实体类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class Book &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String type;</span><br><span class="line">    private String name;</span><br><span class="line">    private String description;</span><br><span class="line"></span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getType() &#123;</span><br><span class="line">        return type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setType(String type) &#123;</span><br><span class="line">        this.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDescription() &#123;</span><br><span class="line">        return description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDescription(String description) &#123;</span><br><span class="line">        this.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Book&#123;&quot; +</span><br><span class="line">                &quot;id=&quot; + id +</span><br><span class="line">                &quot;, type=&#x27;&quot; + type + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, description=&#x27;&quot; + description + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义dao接口<br>在com.blog.dao包下定义BookDao接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface BookDao &#123;</span><br><span class="line">    @Select(&quot;select * from tbl_book where id = #&#123;id&#125;&quot;)</span><br><span class="line">    Book getById(Integer id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义测试类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">class Springboot03MybatisApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void contextLoads() &#123;</span><br><span class="line">        Book book = bookDao.getById(1);</span><br><span class="line">        System.out.println(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://localhost:3306/springboot_db?serverTimezone=UTC</span><br><span class="line">    username: root</span><br><span class="line">    password: PASSWORD</span><br></pre></td></tr></table></figure></li><li><p>测试<br>运行测试方法，会报错 No qualifying bean of type ‘com.blog.dao.BookDao’ ，没有类型为“com.blog.dao.BookDao”的限定bean<br>为什么会出现这种情况呢？之前我们在配置MyBatis时，配置了如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public MapperScannerConfigurer mapperScannerConfigurer() &#123;</span><br><span class="line">    MapperScannerConfigurer msc = new MapperScannerConfigurer();</span><br><span class="line">    msc.setBasePackage(&quot;com.blog.dao&quot;);</span><br><span class="line">    return msc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> Mybatis  会扫描接口并创建接口的代码对象交给  Spring  管理，但是现在并没有告诉  Mybatis  哪个是  dao  接口。<br>而我们要解决这个问题需要在 BookDao  接口上使用  @Mapper  ， BookDao  接口修改为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface BookDao &#123;</span><br><span class="line">    @Select(&quot;select * from tbl_book where id = #&#123;id&#125;&quot;)</span><br><span class="line">    Book getById(Integer id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>注意：<br> SpringBoot  版本低于2.4.3(不含)，Mysql驱动版本大于8.0时，需要在url连接串中配置时区  jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;springboot_db?serverTimezone&#x3D;UTC ，或在MySQL数据库端配置时区解决此问题</p><h3 id="更改数据源"><a href="#更改数据源" class="headerlink" title="更改数据源"></a>更改数据源</h3><p>现在我们并没有指定数据源， SpringBoot  有默认的数据源，我们也可以指定使用  Druid  数据源，按照以下步骤实现</p><ul><li><p>导依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.12&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>修改配置文件配置</p><p>在  application.yml  可以通过  spring.datasource.type  来配置使用什么数据源。配置文件内容可以改进为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://localhost:3306/springboot_db?serverTimezone=UTC</span><br><span class="line">    username: root</span><br><span class="line">    password: PASSWORD.</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br></pre></td></tr></table></figure></li></ul><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310250916598.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310250916084.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310250917844.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310250917764.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310250917615.png"></p><h1 id="SSM整合案例"><a href="#SSM整合案例" class="headerlink" title="SSM整合案例"></a>SSM整合案例</h1><h3 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h3><p>创建一个新的SpringBoot工程，注意要勾选 Spring Web ， MyBatis Framework 和 MySQL Driver<br>由于我们工程中使用到了  Druid  ，所以需要导入  Druid  的坐标。druid在parent中没有，这个要加版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.12&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="代码拷贝"><a href="#代码拷贝" class="headerlink" title="代码拷贝"></a>代码拷贝</h3><p>将之前的ssm整合工程的代码拷贝过来，将 com.blog 包下的所有内容拷贝过来，放在对应的位置即可。项目结构如下</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310250932818.png"></p><ul><li>config：原有的配置文件，全被springboot整合简化</li><li>controller：相应web请求</li><li>dao：执行相应的SQL语句，需要添加 @mapper 注册</li><li>domain：定义实体类</li><li>exception：异常处理</li><li>service：添加功能接口和相关实现类</li></ul><p>需要修改的内容如下：</p><ul><li>config：直接删掉，SpringBoot并不需要这些配置类</li><li>dao：添加 @mapper 注册</li><li>将测试类也修改为SpringBoot的</li></ul><h3 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h3><p>把application. properties 改成 application.yml文件，把里面的配置改为 yml 格式</p><ul><li><p>服务的端口号（设为80，这样我们就不用写了）</p></li><li><p>连接数据库的信息（数据库连接四要素）</p></li><li><p>数据源（德鲁伊）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 80</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://localhost:3306/springboot_db?serverTimezone=UTC</span><br><span class="line">    username: root</span><br><span class="line">    password: PASSWORD.</span><br></pre></td></tr></table></figure></li></ul><h3 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h3><p>在  SpringBoot  程序中是没有  webapp  目录的，那么在  SpringBoot  程序中静态资源需要放在什么位置呢？<br>静态资源需要放在  resources  下的  static  下<br>那我们再配置一个默认页面，跳转到我们的增删改页面，新建 index.html ，写入以下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    document.location.href=&quot;/pages/books.html&quot;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这样当我们在浏览器输入localhost，然后直接按回车，就能直接跳转到增删改的页面了，如果以后我们需要频繁测试某一个页面，也可以将上述代码中的地址换为我们要测试的地址，这样就不用老手敲地址了</p><h1 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h1><h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><ol><li><p>创建工程</p><p>创建一个SpringBoot工程</p><p>需要勾选 Spring Web ， MyBatis Framework 和 MySQL Driver </p></li><li><p>SpringBoot整合</p><p>整合MyBatis</p><ul><li>添加Druid数据源依赖</li><li>编写数据库配置文件（application.yml），配置数据库连接四要素</li><li>对于Dao层的包扫描，使用 @Mapper 注解</li></ul><p>整合Junit</p><ul><li>使用 @SpringBootTest 注解</li></ul></li><li><p>功能模块</p><p>创建数据库和表</p><p>根据数据表来创建对应的模型类</p><p>通过 Dao 层完成数据库的增删改</p><p>编写 Service 层（Service接口+实现类）</p><p>编写Controller层</p><ul><li>接收请求  @RequestMapping 、 @GetMapping 、 @PostMapping 、 @PutMapping 、 @DeleteMapping </li><li>接收数据 简单类型、POJO类型、嵌套POJO类型、数组类型、JSON数据类型<ul><li>@RequestParam </li><li>@PathVariable </li><li>@RequestBody</li></ul></li><li>转发业务层<ul><li>使用 @Autowired 自动装配</li></ul></li><li>响应结果<ul><li>@ResponseBody</li></ul></li></ul></li></ol><h2 id="整合配置"><a href="#整合配置" class="headerlink" title="整合配置"></a>整合配置</h2><ul><li><p>步骤一： 创建一个SpringBoot工程<br>  注意要勾选 Spring Web ， MyBatis Framework 和 MySQL Driver </p></li><li><p>步骤二：</p><p>创建项目包结构</p><ul><li>com.blog.controller  编写Controller类</li><li>com.blog.dao  存放的是Dao层的接口，注意要使用 @Mapper 注解</li><li>com.blog.service  存放的是Service层接口，</li><li>com.blog.service.impl  存放的是Service的实现类</li><li>com.blog.domain  存放的是pojo类</li><li>resources&#x2F;static  存放静态资源HTML，CSS，JS等</li><li>test&#x2F;java  存放测试类</li></ul></li><li><p>步骤三： 编写application.yml<br>  导入Druid的坐标，并在配置文件中编写数据库连接四要素</p></li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 80</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://localhost:3306/springboot_db?serverTimezone=UTC</span><br><span class="line">    username: root</span><br><span class="line">    password: YOURPASSWORD.</span><br></pre></td></tr></table></figure><h2 id="功能模块开发"><a href="#功能模块开发" class="headerlink" title="功能模块开发"></a>功能模块开发</h2><ul><li>步骤一： 创建数据库和表</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">create database springboot_db;</span><br><span class="line">use springboot_db;</span><br><span class="line">create table tbl_book</span><br><span class="line">(</span><br><span class="line">    id          int primary key auto_increment,</span><br><span class="line">    type        varchar(20),</span><br><span class="line">    `name`      varchar(50),</span><br><span class="line">    description varchar(255)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">insert into `tbl_book`(`id`, `type`, `name`, `description`)</span><br><span class="line">values (1, &#x27;计算机理论&#x27;, &#x27;Spring实战 第五版&#x27;, &#x27;Spring入门经典教程，深入理解Spring原理技术内幕&#x27;),</span><br><span class="line">       (2, &#x27;计算机理论&#x27;, &#x27;Spring 5核心原理与30个类手写实践&#x27;, &#x27;十年沉淀之作，手写Spring精华思想&#x27;),</span><br><span class="line">       (3, &#x27;计算机理论&#x27;, &#x27;Spring 5设计模式&#x27;, &#x27;深入Spring源码刨析Spring源码中蕴含的10大设计模式&#x27;),</span><br><span class="line">       (4, &#x27;计算机理论&#x27;, &#x27;Spring MVC+Mybatis开发从入门到项目实战&#x27;,</span><br><span class="line">        &#x27;全方位解析面向Web应用的轻量级框架，带你成为Spring MVC开发高手&#x27;),</span><br><span class="line">       (5, &#x27;计算机理论&#x27;, &#x27;轻量级Java Web企业应用实战&#x27;, &#x27;源码级刨析Spring框架，适合已掌握Java基础的读者&#x27;),</span><br><span class="line">       (6, &#x27;计算机理论&#x27;, &#x27;Java核心技术 卷Ⅰ 基础知识(原书第11版)&#x27;,</span><br><span class="line">        &#x27;Core Java第11版，Jolt大奖获奖作品，针对Java SE9、10、11全面更新&#x27;),</span><br><span class="line">       (7, &#x27;计算机理论&#x27;, &#x27;深入理解Java虚拟机&#x27;, &#x27;5个纬度全面刨析JVM,大厂面试知识点全覆盖&#x27;),</span><br><span class="line">       (8, &#x27;计算机理论&#x27;, &#x27;Java编程思想(第4版)&#x27;, &#x27;Java学习必读经典，殿堂级著作！赢得了全球程序员的广泛赞誉&#x27;),</span><br><span class="line">       (9, &#x27;计算机理论&#x27;, &#x27;零基础学Java(全彩版)&#x27;, &#x27;零基础自学编程的入门图书，由浅入深，详解Java语言的编程思想和核心技术&#x27;),</span><br><span class="line">       (10, &#x27;市场营销&#x27;, &#x27;直播就这么做:主播高效沟通实战指南&#x27;, &#x27;李子柒、李佳奇、薇娅成长为网红的秘密都在书中&#x27;),</span><br><span class="line">       (11, &#x27;市场营销&#x27;, &#x27;直播销讲实战一本通&#x27;, &#x27;和秋叶一起学系列网络营销书籍&#x27;),</span><br><span class="line">       (12, &#x27;市场营销&#x27;, &#x27;直播带货:淘宝、天猫直播从新手到高手&#x27;, &#x27;一本教你如何玩转直播的书，10堂课轻松实现带货月入3W+&#x27;);</span><br></pre></td></tr></table></figure><ul><li>步骤二： 编写模型类</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class Book &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String type;</span><br><span class="line">    private String name;</span><br><span class="line">    private String description;</span><br><span class="line"></span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getType() &#123;</span><br><span class="line">        return type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setType(String type) &#123;</span><br><span class="line">        this.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDescription() &#123;</span><br><span class="line">        return description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDescription(String description) &#123;</span><br><span class="line">        this.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Book&#123;&quot; +</span><br><span class="line">                &quot;id=&quot; + id +</span><br><span class="line">                &quot;, type=&#x27;&quot; + type + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, description=&#x27;&quot; + description + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>步骤三： 编写dao接口<br>  注意使用 @Mapper 注解</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface BookDao &#123;</span><br><span class="line">    @Select(&quot;select * from tbl_book where id=#&#123;id&#125;&quot;)</span><br><span class="line">    Book getById(Integer id);</span><br><span class="line"></span><br><span class="line">    @Select(&quot;select * from tbl_book&quot;)</span><br><span class="line">    List&lt;Book&gt; getAll();</span><br><span class="line"></span><br><span class="line">    @Update(&quot;update tbl_book set type=#&#123;type&#125;, `name`=#&#123;name&#125;, `description`=#&#123;description&#125; where id=#&#123;id&#125;&quot;)</span><br><span class="line">    int update(Book book);</span><br><span class="line"></span><br><span class="line">    @Delete(&quot;delete from tbl_book where id=#&#123;id&#125;&quot;)</span><br><span class="line">    int delete(Integer id);</span><br><span class="line"></span><br><span class="line">    @Insert(&quot;insert into tbl_book values (null, #&#123;type&#125;, #&#123;name&#125;, #&#123;description&#125;)&quot;)</span><br><span class="line">    int save(Book book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>步骤四： 编写service接口及其实现类</li></ul><p>  接口：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface BookService &#123;</span><br><span class="line">    boolean save(Book book);</span><br><span class="line"></span><br><span class="line">    boolean update(Book book);</span><br><span class="line"></span><br><span class="line">    boolean delete(Integer id);</span><br><span class="line"></span><br><span class="line">    Book getById(Integer id);</span><br><span class="line"></span><br><span class="line">    List&lt;Book&gt; getAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  实现类：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class BookServiceImpl implements BookService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean save( Book book) &#123;</span><br><span class="line">        int cnt = bookDao.save(book);</span><br><span class="line">        return cnt &gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean update(Book book) &#123;</span><br><span class="line">        int cnt = bookDao.update(book);</span><br><span class="line">        return cnt&gt;0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean delete(Integer id) &#123;</span><br><span class="line">        return bookDao.delete(id) &gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Book getById(Integer id) &#123;</span><br><span class="line">        return bookDao.getById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;Book&gt; getAll() &#123;</span><br><span class="line">        return bookDao.getAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>步骤五： 编写Controller类<br>  注意响应pojo类型要加 @RequestBody 注解，某人忘加了，调试了半天</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/books&quot;)</span><br><span class="line">public class BookController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private BookService bookService;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public Book getById(@PathVariable Integer id) &#123;</span><br><span class="line">        return bookService.getById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping</span><br><span class="line">    public List&lt;Book&gt; getAll() &#123;</span><br><span class="line">        return bookService.getAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping</span><br><span class="line">    public boolean save(@RequestBody Book book) &#123;</span><br><span class="line">        return bookService.save(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PutMapping</span><br><span class="line">    public boolean update(@RequestBody Book book) &#123;</span><br><span class="line">        return bookService.update(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public boolean delete(@PathVariable Integer id) &#123;</span><br><span class="line">        return bookService.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>步骤六： 使用PostMan进行测试<br>  将增删改查全部测试完毕之后，就可以继续往下做了</li></ul><h2 id="统一结果封装"><a href="#统一结果封装" class="headerlink" title="统一结果封装"></a>统一结果封装</h2><ul><li><p>创建一个返回结果类<br>我这里暂时只需要返回的结果，状态码和异常信息，如果还有别的需求，可以自行删改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class Result &#123;</span><br><span class="line">    private Object data;</span><br><span class="line">    private Integer code;</span><br><span class="line">    private String msg;</span><br><span class="line"></span><br><span class="line">    public Object getData() &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Object data) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getCode() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCode(Integer code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getMsg() &#123;</span><br><span class="line">        return msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMsg(String msg) &#123;</span><br><span class="line">        this.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Result&#123;&quot; +</span><br><span class="line">                &quot;data=&quot; + data +</span><br><span class="line">                &quot;, code=&quot; + code +</span><br><span class="line">                &quot;, msg=&#x27;&quot; + msg + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义状态码Code类<br>状态码也可以根据自己的需求来自定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Code &#123;</span><br><span class="line">    public static final Integer SAVE_OK = 20011;</span><br><span class="line">    public static final Integer SAVE_ERR = 20010;</span><br><span class="line"></span><br><span class="line">    public static final Integer UPDATE_OK = 20021;</span><br><span class="line">    public static final Integer UPDATE_ERR = 20020;</span><br><span class="line"></span><br><span class="line">    public static final Integer DELETE_OK = 20031;</span><br><span class="line">    public static final Integer DELETE_ERR = 20030;</span><br><span class="line"></span><br><span class="line">    public static final Integer GET_OK = 20041;</span><br><span class="line">    public static final Integer GET_ERR = 20040;</span><br><span class="line"></span><br><span class="line">    public static final Integer SYSTEM_ERR = 50001;</span><br><span class="line">    public static final Integer SYSTEM_TIMEOUT_ERR = 50002;</span><br><span class="line">    public static final Integer SYSTEM_UNKNOW_ERR = 59999;</span><br><span class="line"></span><br><span class="line">    public static final Integer BUSINESS_ERR = 60001;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改Controller类的返回值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/books&quot;)</span><br><span class="line">public class BookController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private BookService bookService;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public Result getById(@PathVariable Integer id) &#123;</span><br><span class="line">        Book book = bookService.getById(id);</span><br><span class="line">        Integer code = book == null ? Code.GET_ERR : Code.GET_OK;</span><br><span class="line">        String msg = book == null ? &quot;数据查询失败，请重试！&quot; : &quot;&quot;;</span><br><span class="line">        return new Result(code, book, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping</span><br><span class="line">    public Result getAll() &#123;</span><br><span class="line">        List&lt;Book&gt; books = bookService.getAll();</span><br><span class="line">        Integer code = books == null ? Code.GET_ERR : Code.GET_OK;</span><br><span class="line">        String msg = books == null ? &quot;数据查询失败，请重试！&quot; : &quot;&quot;;</span><br><span class="line">        return new Result(code, books, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping</span><br><span class="line">    public Result save(@RequestBody Book book) &#123;</span><br><span class="line">        boolean flag = bookService.save(book);</span><br><span class="line">        return new Result(flag ? Code.SAVE_OK : Code.SAVE_ERR, flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PutMapping</span><br><span class="line">    public Result update(@RequestBody Book book) &#123;</span><br><span class="line">        boolean flag = bookService.update(book);</span><br><span class="line">        return new Result(flag ? Code.UPDATE_OK : Code.UPDATE_ERR, flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public Result delete(@PathVariable Integer id) &#123;</span><br><span class="line">        boolean flag = bookService.delete(id);</span><br><span class="line">        return new Result(flag ? Code.DELETE_OK : Code.DELETE_ERR, flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h2><ul><li><p>将异常进行分类<br>这里只将其划分为了业务异常和系统异常<br>在com.blog.exception包下新建两个异常类</p><p>BusinessException：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class BusinessException extends RuntimeException &#123;</span><br><span class="line">    private Integer code;</span><br><span class="line"></span><br><span class="line">    public Integer getCode() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCode(Integer code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BusinessException(Integer code) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BusinessException(Integer code, String message) &#123;</span><br><span class="line">        super(message);</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BusinessException(Integer code, String message, Throwable cause) &#123;</span><br><span class="line">        super(message, cause);</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SystemException：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class SystemException extends RuntimeException &#123;</span><br><span class="line">    private Integer code;</span><br><span class="line"></span><br><span class="line">    public Integer getCode() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCode(Integer code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SystemException(Integer code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SystemException(Integer code, String message) &#123;</span><br><span class="line">        super(message);</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SystemException(Integer code, String message, Throwable cause) &#123;</span><br><span class="line">        super(message, cause);</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>同时再增加几个状态码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static final Integer SYSTEM_ERR = 50001;</span><br><span class="line">public static final Integer SYSTEM_TIMEOUT_ERR = 50002;</span><br><span class="line">public static final Integer SYSTEM_UNKNOW_ERR = 59999;</span><br><span class="line">public static final Integer BUSINESS_ERR = 60001;</span><br></pre></td></tr></table></figure></li><li><p>编写自定义异常处理类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@RestControllerAdvice</span><br><span class="line">public class ProjectExceptionAdvice &#123;</span><br><span class="line"></span><br><span class="line">    //处理系统异常</span><br><span class="line">    @ExceptionHandler(SystemException.class)</span><br><span class="line">    public Result doSystemException(SystemException exception)&#123;</span><br><span class="line">        return new Result(exception.getCode(),null,exception.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //处理业务异常</span><br><span class="line">    @ExceptionHandler(BusinessException.class)</span><br><span class="line">    public Result doBusinessException(BusinessException exception)&#123;</span><br><span class="line">        return new Result(exception.getCode(),null,exception.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //处理未知异常</span><br><span class="line">    @ExceptionHandler(Exception.class)</span><br><span class="line">    public Result doException(Exception exception)&#123;</span><br><span class="line">        return new Result(Code.SYSTEM_UNKNOW_ERR,null,&quot;系统繁忙，请稍后再试&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试异常<br>可以getById方法中来进行测试，当id为1时，错误码为 BUSINESS_ERR ，错误信息为 不让你瞅 ，当查询其他id时，均为 SYSTEM_UNKNOW_ERR ，错误提示信息为 服务器访问超时，请稍后再试 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class BookServiceImpl implements BookService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean save(Book book) &#123;</span><br><span class="line">        int cnt = bookDao.save(book);</span><br><span class="line">        return cnt &gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean update(Book book) &#123;</span><br><span class="line">        int cnt = bookDao.update(book);</span><br><span class="line">        return cnt &gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean delete(Integer id) &#123;</span><br><span class="line">        return bookDao.delete(id) &gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Book getById(Integer id) &#123;</span><br><span class="line">        if (id == 1)&#123;</span><br><span class="line">            throw new BusinessException(Code.BUSINESS_ERR,&quot;不让你瞅&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            int a = 1 / 0;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new SystemException(Code.SYSTEM_UNKNOW_ERR, &quot;服务器访问超时，请稍后再试&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return bookDao.getById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;Book&gt; getAll() &#123;</span><br><span class="line">        return bookDao.getAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux磁盘调度和网络配置</title>
      <link href="/2023/10/20/Linux%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/"/>
      <url>/2023/10/20/Linux%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="分盘原理"><a href="#分盘原理" class="headerlink" title="分盘原理"></a>分盘原理</h1><p>Linux来说无论有几个分区，分给哪一目录使用 ,它归根结底就只有一个根目录， -个独立且唯-的文件结构, Linux中每个分区都是用来组成整个文件系统的一部分。<br>Linux采用了一种叫<strong>载入</strong>的处理方法，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202311012120168.png"></p><h1 id="Linux分区"><a href="#Linux分区" class="headerlink" title="Linux分区"></a>Linux分区</h1><h2 id="硬盘说明"><a href="#硬盘说明" class="headerlink" title="硬盘说明"></a>硬盘说明</h2><ol><li>Linux硬盘分IDE硬盘和SCSI硬盘，目前基本上是SCSI硬盘</li><li>对于IDE硬盘,驱动器标识符为**hdx~**其中”hd”表明分区所在设备的类型,这里是指IDE硬盘<br>了。”x”为盘号( a为基本盘, b为基本从属盘, c为辅助主盘，d为辅助从属盘)，”心”代表分区，<br>前四个分区用数字1到4表示，它们是主分区或扩展分区,从5开始就是逻辑分区。例，hda3表示为<br>第一个IDE硬盘上的第三个主分区或扩展分区,hdb2表示为第二个IDE硬盘上的第二个主分区或扩展<br>分区。</li><li>对于SCSI硬盘则标识为”sdx~” ， SCSI硬盘是用”sd” 来表示分区所在设备的类型的，其余则和<br>IDE硬盘的表示方法样。</li></ol><h2 id="查看所有设备挂载情况"><a href="#查看所有设备挂载情况" class="headerlink" title="查看所有设备挂载情况"></a>查看所有设备挂载情况</h2><p> Isblk或者Isblk -f</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h2 id="磁盘情况查询"><a href="#磁盘情况查询" class="headerlink" title="磁盘情况查询"></a>磁盘情况查询</h2><p>查询指定目录的磁盘占用情况<br>1基本语法<br>du-h &#x2F;目录<br>查询指定目录的磁盘占用情况，默认为当前目录<br>-S指定目录占用大小汇总<br>-h带计量单位<br>-a含文件<br>–max- depth&#x3D;1子目录深度<br>-C列出明细的同时,增加汇总值<br>V应用实例<br>查询&#x2F;opt目录的磁盘占用情况,深度为1</p><h1 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h1><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202311012141932.png"></p><p>设置IP地址方式：</p><ol><li><p>自动获取:<br>登陆后，通过界面的来设置自动获取ip，特点: linux启动后会自动获取IP缺点是每次自动获取的<br>ip地址可能不一样。</p></li><li><p>指定ip<br>直接修改配置文件来指定IP并可以连接到外网(程序员推荐)</p><p>编辑vi &#x2F;etc&#x2F;sysconfig&#x2F;network scripts&#x2F;ifcfg-ens33</p><p>要求:将ip地址配置的静态的,比如: ip地址为192.168.200.130</p></li></ol><h2 id="设置主机名和hosts映射"><a href="#设置主机名和hosts映射" class="headerlink" title="设置主机名和hosts映射"></a>设置主机名和hosts映射</h2><p>设置主机名</p><ol><li>为了方便记忆,可以给linux系统设置主机名，也可以根据需要修改主机名</li><li>指令hostname :查看主机名</li><li>修改文件在&#x2F;etc&#x2F;hostname指定</li><li>修改后，重启生效</li></ol><p>设置hosts映射</p><ul><li><p>windows</p><p>在C:\Windows\System32\drivers\etc\hosts文件指定即可</p><p>案例: 192.168.200.130 名字</p></li><li><p>linux</p><p>在&#x2F;etc&#x2F;hosts文件指定1</p><p>案例: 192.168.200.1 名字</p></li></ul><h2 id="主机名解析过程分析-Hosts、DNS"><a href="#主机名解析过程分析-Hosts、DNS" class="headerlink" title="主机名解析过程分析(Hosts、DNS)"></a>主机名解析过程分析(Hosts、DNS)</h2><p>Hosts：一个文本文件，用来记录IP和Hostname(主机名)的映射关系<br>DNS是什么：</p><ol><li>DNS ,就是Domain Name System的缩写,翻译过来就是域名系统</li><li>是互联网上作为域名和IP地址相互映射的一一个分布式数据库</li></ol><h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><p>用户在浏览器输入了<a href="http://www.baidu.com/">www.baidu.com</a></p><ol><li><p>浏览器先检查浏览器缓存中有没有该域名解析IP地址 ，有就先调用这个IP完成解析;如果没有,就检查DNS解析器缓存,如果有直接返回IP完成解析。这两个缓存，可以理解为本地解析器缓存</p></li><li><p>一般来说，当电脑第次成功访问某网站后，在一 定时间内，浏览器或操作系统会缓存他的IP地址( DNS解析记录) .如在cmd窗口中输入<br>ipconfig &#x2F;displaydns  &#x2F;&#x2F;DNS域名解析缓存<br>ipconfig &#x2F;flushdns     &#x2F;&#x2F;手动清理dns缓存</p></li><li><p>如果本地解板 温缓存没有找到对应映射,检查系统中hosts文件中有没有配置对应的域名IP映射，如果有，则完成解析并返回。</p></li><li><p>如果 本地DNS解析器缓存和hosts文件中均没有找到对应的IP，则到域名服务DNS进行解析域</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Maven高级</title>
      <link href="/2023/10/20/Maven%E9%AB%98%E7%BA%A7/"/>
      <url>/2023/10/20/Maven%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="分模块开发"><a href="#分模块开发" class="headerlink" title="分模块开发"></a>分模块开发</h1><h2 id="分模块开发设计"><a href="#分模块开发设计" class="headerlink" title="分模块开发设计"></a>分模块开发设计</h2><ol><li>按照功能拆分<ul><li>我们之前的项目都是在一个模块中，比如上篇文章的SSM整合，虽然这样做，功能也都实现了，但是也存在一些问题，我们拿银行的项目举例，来聊聊这件事<ul><li>网络没有那么发达的时候，我们需要到银行柜台或者取款机进行业务操作</li><li>随着互联网的发展，我们有了电脑之后，就可以在网页上登录银行网站使用U盾进行业务操作</li><li>再来就是随着智能手机的普及，我们只需要用手机登录App就可以进行业务操作</li></ul></li><li>上面三个场景出现的时间轴是不同的，如果非要把三个场景的模块代码放到同一个项目，那么当其中某一个模块代码出现问题，就会导致整个项目都无法正常启动，从而导致银行的多个业务都无法正常办理，所以我们会<code>按照功能</code>将项目进行炒粉</li></ul></li><li>按照模块拆分<ul><li>比如电商项目中，有订单和商品两个模块，订单中需要包含商品的详细信息，所以需要商品的模型类，商品模块也会用到商品的模型类，这个时候如果两个模块中都写模型类，就会出现重复代码，后期维护的成本就比较高。我们就想能不能把它们公共的部分抽取成一个独立的模块，其他模块想要使用就可以像<code>导入第三方依赖的坐标</code>一样来使用我们自己抽取的模块，这样就解决了代码重复的问题，这种拆分方式就是我们所说的<code>按照模块</code>拆分</li></ul></li></ol><p>之前的项目包结构如下：</p><ul><li><code>com.blog.config</code>目录存放的是相关的配置类</li><li><code>com.blog.controller</code>编写的是Controller类</li><li><code>com.blog.dao</code>存放的是Dao接口，因为使用的是Mapper接口代理方式，所以没有实现类包</li><li><code>com.blog.service</code>存的是Service接口，<code>com.blog.service.impl</code>存放的是Service实现类</li></ul><p>那我们现在就可以把这些包按照功能拆分成若干个子模块，方便模块之间的相互调用，接口供销，这样的话，项目中的每一层都可以单独维护，也可以很方便的被别人使用。</p><p>那么关于分模块开发的意义，我们就讲完了，说了这么多好处，那么该如何实现呢?</p><h2 id="分模块开发实现"><a href="#分模块开发实现" class="headerlink" title="分模块开发实现"></a>分模块开发实现</h2><p>前面我们已经完成了SSM整合，接下来，我们就基于SSM整合的项目来实现对项目的拆分。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>复制一份之前的ssm项目</p><h3 id="抽取domain层"><a href="#抽取domain层" class="headerlink" title="抽取domain层"></a>抽取domain层</h3><ul><li><p>步骤一：</p><p>创建新模块：</p><ul><li>创建一个名为<code>maven_02_pojo</code>的maven项目</li></ul></li><li><p>步骤二：</p><p>项目中创建domain包：</p><ul><li>在<code>maven_02_pojo</code>中创建<code>com.blog.domain</code>包，并将<code>maven_01_ssm</code>的Book类拷贝到该包中</li></ul></li><li><p>步骤三：</p><p>删除原项目中的domain包：</p><ul><li>删除后，<code>maven_01_ssm</code>项目中用到<code>Book</code>的类中都会爆红</li><li>要想解决上述问题，我们需要在<code>maven_01_ssm</code>中添加<code>maven_02_pojo</code>的依赖。</li></ul></li><li><p>步骤四：</p><p>在<code>maven_01_ssm</code>项目的pom.xml添加<code>maven_02_pojo</code>的依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven_02_pojo&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>因为添加了依赖，所以在<code>maven_01_ssm</code>中就已经能找到Book类，所以刚才的爆红提示就会消失。</p></li></ul><ul><li><p>步骤五：编译maven_01_ssm项目</p><p>控制台会报错，意思就是找不到maven_02_pojo这个jar包</p><p>为啥找不到呢？</p><ul><li>原因是Maven会从本地仓库找对应的jar包，但是本地仓库又不存在该jar包所以会报错。</li><li>在IDEA中是有<code>maven_02_pojo</code>这个项目，所以我们只需要将<code>maven_02_pojo</code>项目安装到本地仓库即可。</li></ul></li><li><p>步骤六：将项目安装本地仓库</p><p>将需要被依赖的项目<code>maven_02_pojo</code>，使用maven的<code>install</code>命令，把其安装到Maven的本地仓库中</p><p>之后再次执行<code>maven_01_ssm</code>的<code>compile</code>的命令后，就已经能够成功编译。</p></li></ul><h3 id="抽取dao层"><a href="#抽取dao层" class="headerlink" title="抽取dao层"></a>抽取dao层</h3><ul><li><p><code>步骤一：</code>创建新模块</p><ul><li>创建一个名为<code>maven_03_dao</code>的maven项目</li></ul></li><li><p><code>步骤二：</code>项目中创建<code>dao</code>包</p><ul><li><p>在<code>maven_03_dao</code>项目中创建<code>com.blog.dao</code>包，并将<code>maven_01_ssm</code>中BookDao类拷贝到该包中</p></li><li><p>在maven_03_dao中会有如下几个问题需要解决下</p><p>项目maven_03_dao的BookDao接口中Book类找不到报错</p><p>解决方案在<code>maven_03_dao</code>项目的pom.xml中添加<code>maven_02_pojo</code>项目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven_02_pojo&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>项目<code>maven_03_dao</code>的BookDao接口中，Mybatis的增删改查注解报错</p><p>解决方案在<code>maven_03_dao</code>项目的pom.xml中添加<code>mybatis</code>的相关依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.5.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.46&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>最后记得使用maven的<code>install</code>命令，把其安装到Maven的本地仓库中</p></li></ul></li><li><p><code>步骤三：</code>删除原项目中的<code>dao</code>包</p><ul><li><p>删除Dao包以后，因为<code>maven_01_ssm</code>中的BookServiceImpl类中有使用到Dao的内容，所以需要在<code>maven_01_ssm</code>的pom.xml添加<code>maven_03_dao</code>的依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven_03_dao&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>步骤四：</code>运行测试</p><ul><li>启动Tomcat服务器，访问<code>http://localhost:8080/pages/books.html</code></li><li>将抽取后的项目进行运行，测试之前的增删改查功能依然能够使用。</li></ul></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>对于项目的拆分，大致会有如下几个步骤</p><ol><li>创建Maven模块</li><li>书写模块代码<ul><li>分模块开发需要先针对模块功能进行设计，再进行编码。不会先将工程开发完毕，然后进行拆分。拆分方式可以按照功能拆也可以按照模块拆。</li></ul></li><li>通过maven指令安装模块到本地仓库(install 指令)<ul><li>由于maven指令只能安装到自己电脑的仓库里，那么团队内部开发需要发布模块功能，需要到团队内部可共享的仓库中(私服)，私服我们后面会讲解。</li></ul></li></ol><h1 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h1><p>我们现在已经能把项目拆分成一个个独立的模块，当在其他项目中想要使用独立出来的这些模块，只需要在其pom.xml使用<code>&lt;dependency&gt;</code>标签来进行jar包的引入即可。<br><code>&lt;dependency&gt;</code>其实就是依赖，关于依赖管理里面涉及的内容有：</p><ul><li>依赖传递</li><li>可选依赖</li><li>排除依赖</li></ul><p>依赖:</p><ul><li><p>依赖指当前项目运行所需的jar一个项目可以设置多个依赖。</p></li><li><p>格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--设置当前项目所依赖的所有jar--&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!--设置具体的依赖--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;!--依赖所属群组id--&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;!--依赖所属项目id--&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">        &lt;!--依赖版本号--&gt;</span><br><span class="line">        &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="依赖传递与冲突问题"><a href="#依赖传递与冲突问题" class="headerlink" title="依赖传递与冲突问题"></a>依赖传递与冲突问题</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310241026863.png"></p><p>依赖是具有传递性的</p><p>A代表自己的项目；B，C，D，E，F，G代表的是项目所依赖的jar包；D1和D2、E1和E2代表是相同jar包的不同版本</p><ol><li>A依赖了B和C，B和C有分别依赖了其他jar包，所以在A项目中就可以使用上面所有jar包，这就是所说的依赖传递</li><li>依赖传递有直接依赖和间接依赖<ul><li>相对于A来说，A直接依赖B和C，间接依赖了D1，E1，G，F，D2和E2</li><li>相对于B来说，B直接依赖了D1和E1，间接依赖了G</li><li>直接依赖和间接依赖是一个相对的概念</li></ul></li><li>因为有依赖传递的存在，就会导致jar包在依赖的过程中出现冲突问题，具体什么是冲突？Maven是如何解决冲突的？</li></ol><p>这里所说的<code>依赖冲突</code>是指项目依赖的某一个jar包，有多个不同的版本，因而造成类包版本冲突。</p><ul><li><p>情况一：在maven_01_ssm的pom.xml中添加两个不同版本的Junit依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">      &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;4.11&lt;/version&gt;</span><br><span class="line">      &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>调换位置，刷新maven面板，我们会发现，maven的dependencies面板上总是显示使用的是后加载的jar包<br>于是我们得出一个结论：</p><ul><li>特殊优先：当同级配置了相同资源的不同版本，后配置的覆盖先配置的。</li></ul></li><li><p>情况二：路径优先：当依赖中出现相同的资源时，层级越深，优先级越低，层级越浅，优先级越高</p><ul><li>A通过B间接依赖到E1</li><li>A通过C间接依赖到E2</li><li>A就会间接依赖到E1和E2，Maven会按照层级来选择，E1是2度，E2是3度，所以最终会选择E1</li></ul></li><li><p>情况三：声明优先：当资源在相同层级被依赖时，配置顺序靠前的覆盖配置顺序靠后的</p><ul><li>A通过B间接依赖到D1</li><li>A通过C间接依赖到D2</li><li>D1和D2都是两度，这个时候就不能按照层级来选择，需要按照声明来，谁先声明用谁，也就是说B在C之前声明，这个时候使用的是D1，反之则为D2</li></ul><p>但是对于上面的结果，我们也不用刻意去记，一切以maven的dependencies面板上显示的为准</p></li></ul><h2 id="可选依赖和排除依赖"><a href="#可选依赖和排除依赖" class="headerlink" title="可选依赖和排除依赖"></a>可选依赖和排除依赖</h2><p>依赖传递介绍完以后，我们来思考一个问题，假如</p><ul><li><code>maven_01_ssm</code> 依赖了 <code>maven_03_dao</code></li><li><code>maven_03_dao</code> 依赖了 <code>maven_02_pojo</code></li><li>因为现在有依赖传递，所以<code>maven_01_ssm</code>能够使用到<code>maven_02_pojo</code>的内容</li><li>如果说现在不想让<code>maven_01_ssm</code>依赖到<code>maven_02_pojo</code>，有哪些解决方案?</li></ul><p><code>方案一：</code>可选依赖</p><ul><li><p>可选依赖指对外隐藏当前所依赖的资源—<code>不透明</code></p></li><li><p>在<code>maven_03_dao</code>的pom.xml，在引入<code>maven_02_pojo</code>的时候，添加<code>optional</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven_02_pojo&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;!--可选依赖是隐藏当前工程所依赖的资源，隐藏后对应资源将不具有依赖传递--&gt;</span><br><span class="line">    &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ul><p><code>方案二：</code>排除依赖</p><ul><li><p>排除依赖指主动断开依赖的资源，被排除的资源无需指定版本—<code>不需要</code></p></li><li><p>前面我们已经通过可选依赖实现了阻断<code>maven_02_pojo</code>的依赖传递，对于排除依赖，则指的是已经有依赖的事实，也就是说<code>maven_01_ssm</code>项目中已经通过依赖传递用到了<code>maven_02_pojo</code>，此时我们需要做的是将其进行排除，所以接下来需要修改<code>maven_01_ssm</code>的pom.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven_03_dao&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;!--排除依赖是隐藏当前资源对应的依赖关系--&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;!--这里可以排除多个依赖，只要你有需求--&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven_02_pojo&lt;/artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ul><p>介绍完这两种方式后，简单来梳理下，就是</p><ul><li><code>A依赖B，B依赖C</code>，<code>C</code>通过依赖传递会被<code>A</code>使用到，现在要想办法让<code>A</code>不去依赖<code>C</code></li><li>可选依赖是在B上设置<code>&lt;optional&gt;</code>，<code>A</code>不知道有<code>C</code>的存在，</li><li>排除依赖是在A上设置<code>&lt;exclusions&gt;</code>，<code>A</code>知道有<code>C</code>的存在，主动将其排除掉。</li></ul><blockquote><p>可选依赖就像抄答案，我抄完了不像让别人抄</p><p>排除依赖就像有答案，但我是个好学生，主动不抄</p></blockquote><h1 id="聚合与继承"><a href="#聚合与继承" class="headerlink" title="聚合与继承"></a>聚合与继承</h1><p>我们的项目已经从以前的单模块，变成了现在的多模块开发。项目一旦变成了多模块开发以后，就会引发一些问题，在这一节中我们主要会学习两个内容<code>聚合</code>和<code>继承</code>，用这两个知识来解决下分模块后的一些问题。</p><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310241039145.png"></p><ul><li>分模块开发后，需要将这四个项目都安装到本地仓库，目前我们只能通过项目Maven面板的install来安装，并且需要安装四个，如果我们的项目足够多，那一个个install也挺麻烦的</li><li>如果四个项目都已经安装成功，当ssm_pojo发生变化后，我们就得将ssm_pojo重新安装到maven仓库，但是为了确保我们对ssm_pojo的修改不会影响到其他模块（比如我们将pojo类中的一个属性删除，如果其他模块调用了这个属性，那必然报错），我们需要对所有模块重新编译，看看有没有问题。然后还需要将所有模块再install一遍</li></ul><p>项目少的话还好，但是如果项目多的话，一个个操作项目就容易出现漏掉或重复操作的问题，所以我们就像能不能抽取一个项目，把所有的项目管理起来，以后再想操作这些项目，做需要操作我们抽取的这个项目，这样就省事儿多了</p><p>这就要用到我们接下来讲的<code>聚合</code>了</p><ul><li>所谓聚合：将多个模块组织成一个整体，同时进行项目构建的过程称为聚合</li><li>聚合工程：通常是一个不具有业务功能的<code>空</code>工程</li><li>作用：使用聚合工程可以将多个工程编组，通过对聚合工程的构建，实现对所包含的所有模块进行同步构建<ul><li>当工程中某个模块发生更新后，必须保障工程中与更新模块关联的模块同步更新，此时就可以使用聚合工程来解决批量模块同步构建的问题</li></ul></li></ul><p>具体实现步骤如下：</p><ul><li><p><code>步骤一：</code>创建一个空的maven项目</p></li><li><p><code>步骤二：</code>将项目打包方式改为<code>pom</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven_00_parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;!--设置打包方式--&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li></ul><p>说明：项目的打包方式，我们接触到的有三种，分别是</p><ol><li>jar:默认情况，说明该项目为java项目</li><li>war:说明该项目为web项目</li><li>pom:说明该项目为聚合或继承(后面会讲)项目</li></ol><ul><li><p><code>步骤三：</code>pom.xml添加所要管理的项目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven_00_parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;!--设置打包方式--&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--设置管理的项目名称--&gt;</span><br><span class="line">    &lt;modules&gt;</span><br><span class="line">        &lt;module&gt;../maven_01_ssm&lt;/module&gt;</span><br><span class="line">        &lt;module&gt;../maven_02_pojo&lt;/module&gt;</span><br><span class="line">        &lt;module&gt;../maven_03_dao&lt;/module&gt;</span><br><span class="line">    &lt;/modules&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>步骤四：</code>使用聚合统一管理项目<br>在maven面板上点击compile，会发现所有受管理的项目都会被执行编译，这就是聚合工程的作用</p></li></ul><p>说明：聚合工程管理的项目在进行运行的时候，会按照项目与项目之间的依赖关系来自动决定执行的顺序和配置的顺序无关。虽然我们配置的顺序是<code>123</code>，但是执行的时候按照依赖关系编译是<code>231</code>。</p><blockquote><p>将每个项目当做资源，没有前置资源的最优先，然后是当前资源能够满足的项目，直到完成</p></blockquote><p>最后总结一句话就是，<strong>聚合工程主要是用来管理项目</strong>。</p><blockquote><p>超市买东西，最后再<strong>买</strong>个袋子打包</p></blockquote><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>我们已经完成了使用聚合工程去管理项目，聚合工程进行某一个构建操作，其他被其管理的项目也会执行相同的构建操作。那么接下来，我们再来分析下，多模块开发存在的另外一个问题，<code>重复配置</code>的问题，我们先来看张图:</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310241043314.png"></p><ul><li><code>spring-webmvc</code>、<code>spring-jdbc</code>在三个项目模块中都有出现，这样就出现了重复的内容</li><li><code>spring-test</code>只在ssm_crm和ssm_goods中出现，而在ssm_order中没有，这里是部分重复的内容</li><li>我们使用的spring版本目前是<code>5.2.10.RELEASE</code>，假如后期要想升级spring版本，所有跟Spring相关jar包都得被修改，涉及到的项目越多，维护成本越高</li></ul><p>面对上面这些问题，我们就得用到接下来要学习的<code>继承</code>（类似 java 语言中的继承）</p><ul><li>所谓继承：描述的是两个工程间的关系，与java中的继承类似，子工程可以继承父工程中的配置信息，常见于依赖关系的继承</li><li>作用：<ul><li>简化配置</li><li>减少版本冲突</li></ul></li></ul><p>实现步骤：</p><ul><li><p><code>步骤一：</code>创建一个空的Maven项目并将其打包方式设置为pom</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven_00_parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;!--设置打包方式--&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>步骤二：</code>在子工程中设置其父工程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置当前工程继承自parent工程--&gt;</span><br><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;artifactId&gt;maven_00_parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;!--配置父项目的pom.xml路径--&gt;</span><br><span class="line">    &lt;relativePath&gt;../maven_00_parent/pom.xml&lt;/relativePath&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>步骤三：</code>优化子项目共有依赖导入问题</p><ol><li><p>将子项目共同使用的jar包都抽取出来，维护在父项目的pom.xml中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">        xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven_00_parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;!--设置打包方式--&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--设置管理的项目名称--&gt;</span><br><span class="line">    &lt;modules&gt;</span><br><span class="line">        &lt;module&gt;../maven_01_ssm&lt;/module&gt;</span><br><span class="line">        &lt;module&gt;../maven_02_pojo&lt;/module&gt;</span><br><span class="line">        &lt;module&gt;../maven_03_dao&lt;/module&gt;</span><br><span class="line">    &lt;/modules&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.5.6&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.3.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.46&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.16&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.9.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li><li><p>删除子项目中已经被抽取到父项目的pom.xml中的jar包</p><ul><li>删除完后，你会发现父项目中有依赖对应的jar包，子项目虽然已经将重复的依赖删除掉了，但是刷新的时候，子项目中所需要的jar包依然存在。</li><li>当项目的<code>&lt;parent&gt;</code>标签被移除掉，会发现多出来的jar包依赖也会随之消失。</li></ul></li><li><p>在父项目中修改jar包的版本，刷新后，子项目中的jar包版本也随之变化</p><p>那么现在我们就可以解决了刚才提到的第一个问题，将子项目中的公共jar包抽取到父工程中进行统一添加依赖，这样做的可以简化配置，并且当父工程中所依赖的jar包版本发生变化，所有子项目中对应的jar包版本也会跟着更新。</p></li></ol></li></ul><ul><li><p><code>步骤四：</code>优化子项目依赖版本问题</p><p>如果把所有用到的jar包都管理在父项目的pom.xml，看上去更简单些，但是这样就会导致有很多项目引入了过多自己不需要的jar包。如上面看到的这张图:</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310241051435.png"></p><p>如果把所有的依赖都放在了父工程中进行统一维护，就会导致ssm_order项目中多引入了<code>spring-test</code>的jar包，如果这样的jar包过多的话，对于ssm_order来说也是一种”负担”。</p></li></ul><p>那针对于这种部分项目有的jar包，我们该如何管理优化呢?</p><ol><li><p>那针对于这种部分项目有的jar包，我们该如何管理优化呢?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--定义依赖管理--&gt;</span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure></li><li><p>将maven_01_ssm的pom.xml中的junit依赖删除掉，刷新Maven<br>刷新后，在maven_01_ssm项目中找不到junit依赖，所以我们得出一个结论<br><code>&lt;dependencyManagement&gt;</code>标签不真正引入jar包，而是配置可供子项目选择的jar包依赖<br>子项目要想使用它所提供的这些jar包，需要自己添加依赖，并且不需要指定<code>&lt;version&gt;</code></p></li><li><p>在在maven_01_ssm的pom.xml添加junit的依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里就不需要添加版本了，这样做的好处就是当父工程<code>dependencyManagement</code>标签中的版本发生变化后，子项目中的依赖版本也会跟着发生变化</p></blockquote></li><li><p>在maven_03_dao的pom.xml添加junit的依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>这个时候，maven_01_ssm和maven_03_dao这两个项目中的junit版本就会跟随着父项目中的标签<code>dependencyManagement</code>中junit的版本发生变化而变化。不需要junit的项目就不需要添加对应的依赖即可（maven_02_pojo中就没添加）</p><p>至此继承就已经学习完了，总结来说，继承可以帮助做两件事</p><ul><li><p>将所有项目公共的jar包依赖提取到父工程的pom.xml中，子项目就可以不用重复编写，简化开发</p></li><li><p>将所有项目的jar包配置到父工程的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dependencyManagement</span><br></pre></td></tr></table></figure><p>标签下，实现版本管理，方便维护</p><ul><li><code>dependencyManagement</code>标签不真正引入jar包，只是管理jar包的版本</li><li>子项目在引入的时候，只需要指定groupId和artifactId，不需要加version</li><li>当<code>dependencyManagement</code>标签中jar包版本发生变化，所有子项目中有用到该jar包的地方对应的版本会自动随之更新</li></ul></li></ul><p>最后总结一句话就是，<code>父工程主要是用来快速配置依赖jar包和管理项目中所使用的资源</code>。</p></li></ol><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>继承的实现步骤:</p><ul><li><p>创建Maven模块，设置打包类型为pom</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;packaging&gt;pom&lt;/packaging&gt;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>在父工程的pom文件中配置依赖关系(子工程将沿用父工程中的依赖关系),一般只抽取子项目中公有的jar包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></li><li><p>在父工程中配置子工程中可选的依赖关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.16&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>在子工程中配置当前工程所继承的父工程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--定义该工程的父工程--&gt;</span><br><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven_01_parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;!--填写父工程的pom文件,可以不写--&gt;</span><br><span class="line">    &lt;relativePath&gt;../maven_01_parent/pom.xml&lt;/relativePath&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure></li><li><p>在子工程中配置使用父工程中可选依赖的坐标</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></li></ul><p>注意事项:</p><ol><li>子工程中使用父工程中的可选依赖时，<strong>仅需要提供群组id和项目id，无需提供版本</strong>，版本由父工程统一提供，避免版本冲突</li><li>子工程中还可以定义父工程中没有定义的依赖关系，只不过不能被父工程进行版本统一管理。</li></ol><h2 id="聚合与继承的区别"><a href="#聚合与继承的区别" class="headerlink" title="聚合与继承的区别"></a>聚合与继承的区别</h2><p>聚合与继承分别的作用:</p><ul><li>聚合用于快速构建项目，对项目进行管理</li><li>继承用于快速配置和管理子项目中所使用jar包的版本</li></ul><p>聚合和继承的相同点:</p><ul><li>聚合与继承的pom.xml文件打包方式均为pom，可以将两种关系制作到同一个pom文件中</li><li>聚合与继承均属于设计型模块，并无实际的模块内容</li></ul><p>聚合和继承的不同点:</p><ul><li>聚合是在当前模块中配置关系，聚合可以感知到参与聚合的模块有哪些</li><li>继承是在子模块中配置关系，父模块无法感知哪些子模块继承了自己</li></ul><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p>属性中会继续解决分模块开发项目存在的问题，版本管理主要是认识下当前主流的版本定义方式。</p><h2 id="属性引入"><a href="#属性引入" class="headerlink" title="属性引入"></a>属性引入</h2><p>问题分析：</p><p>前面我们已经在父工程中的dependencyManagement标签中对项目中所使用的jar包版本进行了统一的管理，但是如果在标签中有如下的内容:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.5.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>如果我们现在想更新Spring的版本，就会发现我们依然需要更新多个jar包的版本，这样的话还是有可能出现漏改导致程序出问题，而且改起来也是比较麻烦。<br>问题清楚后，我们需要解决的话，就可以参考咱们java基础所学习的变量，声明一个变量，在其他地方使用该变量，当变量的值发生变化后，所有使用变量的地方也会跟着变化<br>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String spring_version = &quot;5.2.10.RELEASE&quot;;</span><br></pre></td></tr></table></figure><p>然后将依赖的版本号替换成<code>spring_version</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;spring_version&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>解决步骤</p><ul><li><p><code>步骤一：</code>父工程中定义属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">        &lt;spring.version&gt;5.2.10.RELEASE&lt;/spring.version&gt;</span><br><span class="line">        &lt;mybatis.version&gt;3.5.6&lt;/mybatis.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>步骤二：</code>修改依赖的version</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>此时，我们只需要更新父工程中properties标签中所维护的jar包版本，所有子项目中的版本也就跟着更新。当然除了将spring相关版本进行维护，我们可以将其他的jar包版本也进行抽取，这样就可以对项目中所有jar包的版本进行统一维护</p></li></ul><p>说明：</p><p>使用<code>properties</code>标签来定义属性，在<code>properties</code>标签内自定义标签名当做属性名，自定义标签内的值即为属性值<br>例如：</p><p><code>&lt;spring.version&gt;5.2.10.RELEASE&lt;/spring.version&gt;</code>，属性名为<code>spring.version</code>，属性值为<code>5.2.10.RELEASE</code>，在其他地方引用变量时用<code>$&#123;变量名&#125;</code></p><h2 id="配置文件加载属性"><a href="#配置文件加载属性" class="headerlink" title="配置文件加载属性"></a>配置文件加载属性</h2><p>Maven中的属性我们已经介绍过了，现在也已经能够通过Maven来集中管理Maven中依赖jar包的版本。但是又有新的需求，就是想让Maven对于属性的管理范围能更大些，比如我们之前项目中的<code>jdbc.properties</code>，这个配置文件中的属性，能不能也来让Maven进行管理呢?</p><p>答案是肯定的，具体的实现步骤如下</p><ul><li><p><code>步骤一：</code>父工程定义属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;spring.version&gt;5.2.10.RELEASE&lt;/spring.version&gt;</span><br><span class="line">    &lt;mybatis.version&gt;3.5.6&lt;/mybatis.version&gt;</span><br><span class="line">    &lt;jdbc.driver&gt;com.mysql.jdbc.Driver&lt;/jdbc.driver&gt;</span><br><span class="line">    &lt;jdbc.url&gt;jdbc:mysql://localhost:13306/ssm_db?useSSL=false&lt;/jdbc.url&gt;</span><br><span class="line">    &lt;jdbc.username&gt;root&lt;/jdbc.username&gt;</span><br><span class="line">    &lt;jdbc.password&gt;PASSWORD&lt;/jdbc.password&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>步骤二：</code>jdbc.properties文件中引用属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driver=$&#123;jdbc.driver&#125;</span><br><span class="line">jdbc.url=$&#123;jdbc.url&#125;</span><br><span class="line">jdbc.username=$&#123;jdbc.username&#125;</span><br><span class="line">jdbc.password=$&#123;jdbc.password&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>步骤三：</code>设置maven过滤文件范围<br>直接在properties中引用属性，看起来怪怪的，properties怎么能直接用到maven中配置的属性呢？<br>所以我们还需要来配置一下，让<code>maven_01_ssm/src/main/resources</code>目录下的<code>jdbc.properties</code>文件可以解析<code>$&#123;&#125;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;resources&gt;</span><br><span class="line">        &lt;!--设置资源目录--&gt;</span><br><span class="line">        &lt;resource&gt;</span><br><span class="line">            &lt;directory&gt;../maven_01_ssm/src/main/resources&lt;/directory&gt;</span><br><span class="line">            &lt;!--设置能够解析$&#123;&#125;，默认是false --&gt;</span><br><span class="line">            &lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">        &lt;/resource&gt;</span><br><span class="line">    &lt;/resources&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>步骤四：</code>测试是否生效<br>测试的时候，只需要将maven_01_ssm项目进行打包，然后在本地仓库观察打包结果中最终生成的内容是否为Maven中配置的内容。</p></li><li><p><code>存在的问题</code><br>如果不只是<code>maven_01_ssm</code>项目需要有属性被父工程管理，如果还有多个项目需要配置，该如何实现呢?</p><ul><li><p><code>方式一</code>：可以一个一个配，但是项目足够多的话，这样还是比较繁琐的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;resources&gt;</span><br><span class="line">        &lt;!--设置资源目录，并设置能够解析$&#123;&#125;--&gt;</span><br><span class="line">        &lt;resource&gt;</span><br><span class="line">            &lt;directory&gt;../maven_01_ssm/src/main/resources&lt;/directory&gt;</span><br><span class="line">            &lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">        &lt;/resource&gt;</span><br><span class="line">        &lt;resource&gt;</span><br><span class="line">            &lt;directory&gt;../maven_02_pojo/src/main/resources&lt;/directory&gt;</span><br><span class="line">            &lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">        &lt;/resource&gt;</span><br><span class="line">        ...</span><br><span class="line">    &lt;/resources&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>方式二：</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;resources&gt;</span><br><span class="line">        &lt;!--</span><br><span class="line">            $&#123;project.basedir&#125;: 当前项目所在目录,子项目继承了父项目，</span><br><span class="line">            相当于所有的子项目都添加了资源目录的过滤</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;resource&gt;</span><br><span class="line">            &lt;directory&gt;$&#123;project.basedir&#125;/src/main/resources&lt;/directory&gt;</span><br><span class="line">            &lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">        &lt;/resource&gt;</span><br><span class="line">    &lt;/resources&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>说明：如果打包过程中出现错误<code>Error assembling WAR: webxml attribute is required</code><br>原因就是Maven发现你的项目为web项目，就会去找web项目的入口web.xml(配置文件配置的方式)，发现没有找到，就会报错。</p><ul><li><p><code>解决方案1：</code>在maven_02_ssm项目的<code>src\main\webapp\WEB-INF\</code>添加一个web.xml文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;</span><br><span class="line">         version=&quot;3.1&quot;&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>解决方案2:</code> 配置maven打包war时，忽略web.xml检查</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.2.3&lt;/version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure></li></ul><p>上面我们所使用的都是Maven的自定义属性，除了<code>$&#123;project.basedir&#125;</code>,它属于Maven的内置系统属性。</p><p>在Maven中的属性分为:</p><ul><li>自定义属性（常用）</li><li>内置属性</li><li>Setting属性</li><li>Java系统属性</li><li>环境变量属性</li></ul><table><thead><tr><th align="center">属性分类</th><th align="center">引用格式</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">自定义属性</td><td align="center">${自定义属性名}</td><td align="center">${spring.vension}</td></tr><tr><td align="center">内置属性</td><td align="center">${内置属性名}</td><td align="center">${basedir}、${version}</td></tr><tr><td align="center">setting属性</td><td align="center">${setting.属性名}</td><td align="center">${settings.localRepository}</td></tr><tr><td align="center">ava系统属性</td><td align="center">${系统属性分类.系统属性名}</td><td align="center">${user.home}</td></tr><tr><td align="center">环境变量属性</td><td align="center">${env.环境变量属性名}</td><td align="center">${env.JAVA_HOME}</td></tr></tbody></table><h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><p>关于这个版本管理解决的问题是，在Maven创建项目和引用别人项目的时候，我们都看到过如下内容:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;maven_00_parent&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br></pre></td></tr></table></figure><p>这里面有两个单词，SNAPSHOT和RELEASE，它们所代表的含义是什么呢?</p><ul><li>SNAPSHOT（快照版本）<ul><li>项目开发过程中临时输出的版本，称为快照版本</li><li>快照版本会随着开发的进展不断更新</li></ul></li><li>RELEASE（发布版本）<ul><li>项目开发到一定阶段里程碑后，向团队外部发布较为稳定的版本，这种版本所对应的构件文件是稳定的</li><li>即便进行功能的后续开发，也不会改变当前发布版本内容，这种版本称为发布版本</li></ul></li></ul><p>除了上面的工程版本，我们还经常能看到一些发布版本：</p><ul><li>alpha版：内测版，bug多不稳定内部版本不断添加新功能</li><li>beta版：公测版，不稳定(比alpha稳定些)，bug相对较多不断添加新功能，相信你更新QQ的时候，一定见过QQ的beta测试版</li><li>纯数字版</li></ul><h1 id="多环境配置与应用"><a href="#多环境配置与应用" class="headerlink" title="多环境配置与应用"></a>多环境配置与应用</h1><h2 id="多环境开发"><a href="#多环境开发" class="headerlink" title="多环境开发"></a>多环境开发</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310241117970.png"></p><p>我们平常都是在自己的开发环境进行开发</p><p>当开发完成后，需要把开发的功能部署到测试环境供测试人员进行测试使用</p><p>等测试人员测试通过后，我们会将项目部署到生成环境上线使用。</p><p>这个时候就有一个问题是，不同环境的配置是不相同的，如不可能让三个环境都用一个数据库，所以就会有三个数据库的url配置，</p><p>我们在项目中如何配置?</p><p>要想实现不同环境之间的配置切换又该如何来实现呢?</p><p>maven提供配置多种环境的设定，帮助开发者在使用过程中快速切换环境。具体实现步骤如下</p><ul><li><p><code>步骤一：</code>父工程配置多个环境，并指定默认激活环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;profiles&gt;</span><br><span class="line">    &lt;!--开发环境--&gt;</span><br><span class="line">    &lt;profile&gt;</span><br><span class="line">        &lt;id&gt;env_dep&lt;/id&gt;</span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">            &lt;jdbc.url&gt;jdbc:mysql://127.1.1.1:3306/ssm_db&lt;/jdbc.url&gt;</span><br><span class="line">        &lt;/properties&gt;</span><br><span class="line">        &lt;!--设定是否为默认环境--&gt;</span><br><span class="line">        &lt;activation&gt;</span><br><span class="line">            &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;</span><br><span class="line">        &lt;/activation&gt;</span><br><span class="line">    &lt;/profile&gt;</span><br><span class="line">    &lt;!--生产环境--&gt;</span><br><span class="line">    &lt;profile&gt;</span><br><span class="line">        &lt;id&gt;env_pro&lt;/id&gt;</span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">            &lt;jdbc.url&gt;jdbc:mysql://127.2.2.2:3306/ssm_db&lt;/jdbc.url&gt;</span><br><span class="line">        &lt;/properties&gt;</span><br><span class="line">    &lt;/profile&gt;</span><br><span class="line">    &lt;!--测试环境--&gt;</span><br><span class="line">    &lt;profile&gt;</span><br><span class="line">        &lt;id&gt;env_test&lt;/id&gt;</span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">            &lt;jdbc.url&gt;jdbc:mysql://127.3.3.3:3306/ssm_db&lt;/jdbc.url&gt;</span><br><span class="line">        &lt;/properties&gt;</span><br><span class="line">    &lt;/profile&gt;</span><br><span class="line">&lt;/profiles&gt;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>步骤二：</code>执行install查看env_dep环境是否生效<br>在你本地仓库找到打包的war包，看看jdbc.properties配置文件中的url是否为<code>jdbc:mysql://127.1.1.1:3306/ssm_db</code></p></li><li><p><code>步骤三：</code>切换默认环境为生产环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;profiles&gt;</span><br><span class="line">    &lt;!--开发环境--&gt;</span><br><span class="line">    &lt;profile&gt;</span><br><span class="line">        &lt;id&gt;env_dep&lt;/id&gt;</span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">            &lt;jdbc.url&gt;jdbc:mysql://127.1.1.1:3306/ssm_db&lt;/jdbc.url&gt;</span><br><span class="line">        &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/profile&gt;</span><br><span class="line">    &lt;!--生产环境--&gt;</span><br><span class="line">    &lt;profile&gt;</span><br><span class="line">        &lt;id&gt;env_pro&lt;/id&gt;</span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">            &lt;jdbc.url&gt;jdbc:mysql://127.2.2.2:3306/ssm_db&lt;/jdbc.url&gt;</span><br><span class="line">        &lt;/properties&gt;</span><br><span class="line">        &lt;!--设定是否为默认环境--&gt;</span><br><span class="line">        &lt;activation&gt;</span><br><span class="line">            &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;</span><br><span class="line">        &lt;/activation&gt;</span><br><span class="line">    &lt;/profile&gt;</span><br><span class="line">    &lt;!--测试环境--&gt;</span><br><span class="line">    &lt;profile&gt;</span><br><span class="line">        &lt;id&gt;env_test&lt;/id&gt;</span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">            &lt;jdbc.url&gt;jdbc:mysql://127.3.3.3:3306/ssm_db&lt;/jdbc.url&gt;</span><br><span class="line">        &lt;/properties&gt;</span><br><span class="line">    &lt;/profile&gt;</span><br><span class="line">&lt;/profiles&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>步骤四：</code>执行install并查看env_pro环境是否生效<br>查看到的结果为<code>jdbc:mysql://127.2.2.2:3306/ssm_db</code><br>虽然已经能够实现不同环境的切换，但是每次切换都是需要手动修改，如何来实现在不改变代码的前提下完成环境的切换呢?</p></li><li><p><code>步骤无：</code>命令行实现环境切换<br>在命令后加上环境id<code>mvn install -P env_test</code></p></li><li><p><code>步骤六：</code>执行安装并查看env_test环境是否生效<br>查看到的结果为<code>jdbc:mysql://127.3.3.3:3306/ssm_db</code></p></li></ul><p>所以总结来说，对于多环境切换只需要两步即可:</p><ul><li><p>父工程中定义多环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;profiles&gt;</span><br><span class="line">&lt;profile&gt;</span><br><span class="line">    &lt;id&gt;环境名称&lt;/id&gt;</span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">        &lt;key&gt;value&lt;/key&gt;</span><br><span class="line">        &lt;/properties&gt;</span><br><span class="line">        &lt;activation&gt;</span><br><span class="line">        &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;</span><br><span class="line">        &lt;/activation&gt;</span><br><span class="line">    &lt;/profile&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/profiles&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用多环境(构建过程)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn 指令 -P 环境定义ID</span><br></pre></td></tr></table></figure></li></ul><h2 id="跳过测试"><a href="#跳过测试" class="headerlink" title="跳过测试"></a>跳过测试</h2><p>前面在执行<code>install</code>指令的时候，Maven都会按照顺序从上往下依次执行，每次都会执行<code>test</code>,</p><p>对于<code>test</code>来说有它存在的意义，</p><ul><li>可以确保每次打包或者安装的时候，程序的正确性，假如测试已经通过在我们没有修改程序的前提下再次执行打包或安装命令，由于顺序执行，测试会被再次执行，就有点耗费时间了。</li><li>功能开发过程中有部分模块还没有开发完毕，测试无法通过，但是想要把其中某一部分进行快速打包，此时由于测试环境失败就会导致打包失败。</li></ul><p>遇到上面这些情况的时候，我们就想跳过测试执行下面的构建命令，具体实现方式有很多：</p><ul><li><p><code>方式一：</code>IDEA工具实现跳过测试<br>IDEA的maven面板上有一个按钮，点击之后可以跳过测试，不过此种方式会跳过所有的测试，如果我们想更精细的控制哪些跳过，哪些不跳过，那么就需要使用配置插件的方式来完成了</p></li><li><p><code>方式二：</code>配置插件实现跳过测试<br>在父工程中的pom.xml中添加测试插件配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.12.4&lt;/version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;skipTests&gt;false&lt;/skipTests&gt;</span><br><span class="line">                &lt;!--排除掉不参与测试的内容--&gt;</span><br><span class="line">                &lt;excludes&gt;</span><br><span class="line">                    &lt;exclude&gt;**/BookServiceTest.java&lt;/exclude&gt;</span><br><span class="line">                &lt;/excludes&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p><code>skipTests：</code>如果为true，则跳过所有测试，如果为false，则不跳过测试<br><code>excludes：</code>哪些测试类不参与测试，即排除，针对skipTests为false来设置的<br><code>includes：</code>哪些测试类要参与测试，即包含,针对skipTests为true来设置的</p></li><li><p><code>方式三：</code>命令行跳过测试<br>使用Maven的命令行，<code>mvn 指令 -D skipTests</code></p></li></ul><p>注意事项:</p><ul><li>执行的项目构建指令必须包含测试生命周期，否则无效果。例如执行compile生命周期，不经过test生命周期。</li><li>该命令可以不借助IDEA，直接使用cmd命令行进行跳过测试，需要注意的是cmd要在pom.xml所在目录下进行执行。</li></ul><h1 id="私服"><a href="#私服" class="headerlink" title="私服"></a>私服</h1><h2 id="私服简介"><a href="#私服简介" class="headerlink" title="私服简介"></a>私服简介</h2><p>团队开发现状分析</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310241126067.png"></p><ol><li>张三负责ssm_crm的开发，自己写了一个ssm_pojo模块，要想使用直接将ssm_pojo安装到本地仓库即可</li><li>李四负责ssm_order的开发，需要用到张三所写的ssm_pojo模块，这个时候如何将张三写的ssm_pojo模块交给李四呢?</li><li>如果直接拷贝，那么团队之间的jar包管理会非常混乱而且容器出错，这个时候我们就想能不能将写好的项目上传到中央仓库，谁想用就直接联网下载即可</li><li>Maven的中央仓库不允许私人上传自己的jar包,那么我们就得换种思路，自己搭建一个类似于中央仓库的东西，把自己的内容上传上去，其他人就可以从上面下载jar包使用</li><li>这个类似于中央仓库的东西就是我们接下来要学习的私服</li></ol><p>所以到这就有两个概念，一个是私服，一个是中央仓库</p><ul><li><code>私服:</code>公司内部搭建的用于存储Maven资源的服务器</li><li><code>远程仓库:</code>Maven开发团队维护的用于存储Maven资源的服务器</li></ul><p>结论：私服是一台独立的服务器，用于解决团队内部的资源共享与资源同步问题</p><h2 id="私服仓库分类"><a href="#私服仓库分类" class="headerlink" title="私服仓库分类"></a>私服仓库分类</h2><p>私服资源操作流程分析：</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310241127829.png"></p><ol><li>在没有私服的情况下，我们自己创建的服务都是安装在Maven的本地仓库中</li><li>私服中也有仓库，我们要把自己的资源上传到私服，最终也是放在私服的仓库中</li><li>其他人要想使用你所上传的资源，就需要从私服的仓库中获取</li><li>当我们要使用的资源不是自己写的，是远程中央仓库有的第三方jar包，这个时候就需要从远程中央仓库下载，每个开发者都去远程中央仓库下速度比较慢(中央仓库服务器在国外)</li><li>私服就再准备一个仓库，用来专门存储从远程中央仓库下载的第三方jar包，第一次访问没有就会去远程中央仓库下载，下次再访问就直接走私服下载</li><li>前面在介绍版本管理的时候提到过有<code>SNAPSHOT</code>和<code>RELEASE</code>，如果把这两类的都放到同一个仓库，比较混乱，所以私服就把这两个种jar包放入不同的仓库</li><li>上面我们已经介绍了有三种仓库，一种是存放<code>SNAPSHOT</code>的，一种是存放<code>RELEASE</code>还有一种是存放从远程仓库下载的第三方jar包，那么我们在获取资源的时候要从哪个仓库种获取呢?</li><li>为了方便获取，我们将所有的仓库编成一个组，我们只需要访问仓库组去获取资源。</li></ol><p>所有私服仓库总共分为三大类:</p><ol><li>宿主仓库hosted<ul><li>保存无法从中央仓库获取的资源</li><li>自主研发</li><li>第三方非开源项目,比如Oracle,因为是付费产品，所以中央仓库没有</li></ul></li><li>代理仓库proxy<ul><li>代理远程仓库，通过nexus访问其他公共仓库，例如中央仓库</li></ul></li><li>仓库组group<ul><li>将若干个仓库组成一个群组，简化配置</li><li>仓库组不能保存资源，属于设计型仓库</li></ul></li></ol><table><thead><tr><th align="center">仓库类别</th><th align="center">英文名称</th><th align="center">功能</th><th align="center">关联操作</th></tr></thead><tbody><tr><td align="center">宿主仓库</td><td align="center">hosted</td><td align="center">保存自主研发+第三方资源</td><td align="center">上传</td></tr><tr><td align="center">代理仓库</td><td align="center">proxy</td><td align="center">代理连接中央仓库</td><td align="center">下载</td></tr><tr><td align="center">仓库组</td><td align="center">group</td><td align="center">为仓库编组简化下载操作</td><td align="center">下载</td></tr></tbody></table><h2 id="本地仓库访问私服配置"><a href="#本地仓库访问私服配置" class="headerlink" title="本地仓库访问私服配置"></a>本地仓库访问私服配置</h2><ul><li>我们通过IDEA将开发的模块上传到私服，中间是要经过本地Maven的</li><li>本地Maven需要知道私服的访问地址以及私服访问的用户名和密码</li><li>私服中的仓库很多，Maven最终要把资源上传到哪个仓库?</li><li>Maven下载的时候，又需要携带用户名和密码到私服上找对应的仓库组进行下载，然后再给IDEA</li><li>上面所说的这些内容，我们需要在本地Maven的配置文件<code>settings.xml</code>中进行配置。</li></ul><p>实现：</p><ul><li><p><code>步骤一：</code>私服上配置仓库<br>新建两个仓库，type选hosted，version policy 一个选release，一个选snapshot</p></li><li><p><code>步骤二：</code>配置本地Maven对私服的访问权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;server&gt;</span><br><span class="line">    &lt;!--id就是刚刚创建的仓库名--&gt;</span><br><span class="line">    &lt;id&gt;blog-snapshot&lt;/id&gt;</span><br><span class="line">    &lt;username&gt;admin&lt;/username&gt;</span><br><span class="line">    &lt;password&gt;7d1f6527-cf26-4be3-974a-de177d75cb87&lt;/password&gt;</span><br><span class="line">&lt;/server&gt;</span><br><span class="line">&lt;server&gt;</span><br><span class="line">    &lt;id&gt;blog-release&lt;/id&gt;</span><br><span class="line">    &lt;username&gt;admin&lt;/username&gt;</span><br><span class="line">    &lt;password&gt;7d1f6527-cf26-4be3-974a-de177d75cb87&lt;/password&gt;</span><br><span class="line">&lt;/server&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>步骤三：</code>配置私服的访问路径</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;mirror&gt;</span><br><span class="line">    &lt;!--配置仓库组的ID--&gt;</span><br><span class="line">    &lt;id&gt;maven-public&lt;/id&gt;</span><br><span class="line">    &lt;!--*代表所有内容都从私服获取--&gt;</span><br><span class="line">    &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;</span><br><span class="line">    &lt;!--私服仓库组maven-public的访问路径--&gt;</span><br><span class="line">    &lt;url&gt;http://localhost:8081/repository/maven-public/&lt;/url&gt;</span><br><span class="line">&lt;/mirror&gt;</span><br></pre></td></tr></table></figure><p>最后记得将新创建的两个仓库加入到maven-public的成员中，至此本地仓库就能与私服进行交互了</p><h2 id="私服资源的下载和上传"><a href="#私服资源的下载和上传" class="headerlink" title="私服资源的下载和上传"></a>私服资源的下载和上传</h2><p>本地仓库与私服已经建立了连接，接下来我们就需要往私服上上传资源和下载资源，具体的实现步骤如下</p><ul><li><p><code>步骤一：</code>配置工程上传私服的具体位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;distributionManagement&gt;</span><br><span class="line">    &lt;repository&gt;</span><br><span class="line">        &lt;id&gt;blog-release&lt;/id&gt;</span><br><span class="line">        &lt;url&gt;http://localhost:8081/repository/blog-release/&lt;/url&gt;</span><br><span class="line">    &lt;/repository&gt;</span><br><span class="line">    &lt;snapshotRepository&gt;</span><br><span class="line">        &lt;id&gt;blog-snapshot&lt;/id&gt;</span><br><span class="line">        &lt;url&gt;http://localhost:8081/repository/blog-snapshot/&lt;/url&gt;</span><br><span class="line">    &lt;/snapshotRepository&gt;</span><br><span class="line">&lt;/distributionManagement&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>步骤二：</code>发布资源到私服<br>maven面板中运行<code>deploy</code>，或者执行maven命令<code>mvn deploy</code></p><p>发布成功，在私服中就能看到了</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310241138794.png"></p><p>现在发布是在blog-snapshot仓库中，如果想发布到blog-release仓库中就需要将项目pom.xml中的version修改成RELEASE即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;maven_00_parent&lt;/artifactId&gt;</span><br><span class="line">&lt;!--&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;--&gt;</span><br><span class="line">&lt;version&gt;1.0-RELEASE&lt;/version&gt;</span><br></pre></td></tr></table></figure><p>如果私服中没有对应的jar，会去中央仓库下载，速度很慢。可以配置让私服去阿里云中下载依赖。<br>修改maven-central的Remote storage为<code>http://maven.aliyun.com/nexus/content/groups/public</code></p><p>至此私服的搭建就已经完成，相对来说有点麻烦，但是步骤都比较固定，后期忘了就常回来看</p><p>注意:</p><ul><li>要发布的项目都需要配置<code>distributionManagement</code>标签，要么在自己的pom.xml中配置，要么在其父项目中配置，然后子项目中继承父项目即可。</li><li>如果报401错误，尝试将maven的setting.xml文件复制到<code>C:\Users\username\.m2</code>目录下，然后在重新进行deploy</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM整合+拦截器</title>
      <link href="/2023/10/18/SSM%E6%95%B4%E5%90%88/"/>
      <url>/2023/10/18/SSM%E6%95%B4%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a>SSM整合</h1><h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><ol><li>创建工程<ul><li>创建一个Maven的web工程</li><li>pom.xml添加SSM需要的依赖jar包</li><li>编写Web项目的入口配置类，实现AbstractAnnotationConfigDispatcherServletInitializer重写以下方法<ul><li><code>getRootConfigClasses()</code> ：返回Spring的配置类 –&gt; 需要<code>SpringConfig</code>配置类</li><li><code>getServletConfigClasses()</code> ：返回SpringMVC的配置类 –&gt; 需要<code>SpringMvcConfig</code>配置类</li><li><code>getServletMappings()</code> : 设置SpringMVC请求拦截路径规则</li><li><code>getServletFilters()</code> ：设置过滤器，解决POST请求中文乱码问题</li></ul></li></ul></li><li>SSM整合(重点是各个配置的编写)<ul><li>SpringConfig<ul><li>标识该类为配置类，使用<code>@Configuration</code></li><li>扫描<code>Service</code>所在的包，使用<code>@ComponentScan</code></li><li>在<code>Service</code>层要管理事务，使用<code>@EnableTransactionManagement</code></li><li>读取外部的<code>properties</code>配置文件，使用<code>@PropertySource</code></li><li>整合Mybatis需要引入Mybatis相关配置类，使用@Import<ul><li>第三方数据源配置类 <code>JdbcConfig</code></li><li>构建DataSource数据源，DruidDataSouroce，需要注入数据库连接四要素，使用<code> @Bean</code>、<code>@Value</code></li><li>构建平台事务管理器，DataSourceTransactionManager，使用<code>@Bean</code></li><li>Mybatis配置类 <code>MybatisConfig</code></li><li>构建<code>SqlSessionFactoryBean</code>并设置别名扫描与数据源，使用<code>@Bean</code></li><li>构建<code>MapperScannerConfigurer</code>并设置DAO层的包扫描</li></ul></li></ul></li><li>SpringMvcConfig<ul><li>标识该类为配置类，使用<code>@Configuratio</code></li><li>扫描<code>Controller</code>所在的包，使用<code>@ComponentScan</code></li><li>开启SpringMVC注解支持，使用<code>@EnableWebMvc</code></li></ul></li></ul></li><li>功能模块(与具体的业务模块有关)<ul><li>创建数据库表</li><li>根据数据库表创建对应的模型类</li><li>通过Dao层完成数据库表的增删改查(接口+自动代理)</li><li>编写Service层(Service接口+实现类)<ul><li><code>@Service</code></li><li><code>@Transactional</code></li><li>整合Junit对业务层进行单元测试<ul><li><code>@RunWith</code></li><li><code>@ContextConfiguration</code></li><li><code>@Test</code></li></ul></li></ul></li><li>编写Controller层<ul><li>接收请求 <code>@RequestMapping</code>、<code>@GetMapping</code>、<code>@PostMapping</code>、<code>@PutMapping</code>、<code>@DeleteMapping</code></li><li>接收数据 简单、POJO、嵌套POJO、集合、数组、JSON数据类型<ul><li><code>@RequestParam</code></li><li><code>@PathVariable</code></li><li><code>@RequestBody</code></li></ul></li><li>转发业务层<ul><li><code>@Autowired</code></li></ul></li><li>响应结果<ul><li><code>@ResponseBody</code></li></ul></li></ul></li></ul></li></ol><h2 id="整合配置"><a href="#整合配置" class="headerlink" title="整合配置"></a>整合配置</h2><ol><li><p>创建Maven的web项目</p></li><li><p>导入坐标，配置依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.5.6&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.3.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.1.46&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.1.16&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">        &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.9.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></li><li><p>创建项目包结构</p><ul><li><code>com.blog.config</code>目录存放的是相关的配置类</li><li><code>com.blog.controller</code>编写的是Controller类</li><li><code>com.blog.dao</code>存放的是Dao接口，因为使用的是Mapper接口代理方式，所以没有实现类包</li><li><code>com.blog.service</code>存的是Service接口，<code>com.blog.service.impl</code>存放的是Service实现类</li><li><code>resources</code>:存入的是配置文件，如Jdbc.properties</li><li><code>webapp</code>:目录可以存放静态资源</li><li><code>test/java</code>:存放的是测试类</li></ul></li><li><p>创建jdbc.properties（注意版本差异）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql://localhost:13306/test</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=PASSWORD.</span><br></pre></td></tr></table></figure></li><li><p>创建JdbcConfig配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class JdbcConfig &#123;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span><br><span class="line">    private String driver;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.url&#125;&quot;)</span><br><span class="line">    private String url;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.username&#125;&quot;)</span><br><span class="line">    private String username;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.password&#125;&quot;)</span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource() &#123;</span><br><span class="line">        DruidDataSource dataSource = new DruidDataSource();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        return dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public PlatformTransactionManager platformTransactionManager(DataSource dataSource)&#123;</span><br><span class="line">        DataSourceTransactionManager ds = new DataSourceTransactionManager();</span><br><span class="line">        ds.setDataSource(dataSource);</span><br><span class="line">        return ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建MyBatisConfig配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class MyBatisConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource)&#123;</span><br><span class="line">        SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean();</span><br><span class="line">        factoryBean.setDataSource(dataSource);</span><br><span class="line">        factoryBean.setTypeAliasesPackage(&quot;com.blog.domain&quot;);</span><br><span class="line">        return factoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MapperScannerConfigurer mapperScannerConfigurer()&#123;</span><br><span class="line">        MapperScannerConfigurer msc = new MapperScannerConfigurer();</span><br><span class="line">        msc.setBasePackage(&quot;com.blog.dao&quot;);</span><br><span class="line">        return msc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建SpringConfig配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.blog.service&quot;)</span><br><span class="line">@PropertySource(&quot;jdbc.properties&quot;)</span><br><span class="line">@EnableTransactionManagement</span><br><span class="line">@Import(&#123;JdbcConfig.class, MyBatisConfig.class&#125;)</span><br><span class="line">public class SpringConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建SpringMvcConfig配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.blog.controller&quot;)</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class SpringMvcConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建ServletContainersInitConfig配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer &#123;</span><br><span class="line">    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        return new Class[]&#123;SpringConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        return new Class[]&#123;SpringMvcConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected String[] getServletMappings() &#123;</span><br><span class="line">        return new String[]&#123;&quot;/&quot;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Filter[] getServletFilters() &#123;</span><br><span class="line">        CharacterEncodingFilter filter = new CharacterEncodingFilter();</span><br><span class="line">        filter.setEncoding(&quot;utf-8&quot;);</span><br><span class="line">        return new Filter[]&#123;filter&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="功能模块开发"><a href="#功能模块开发" class="headerlink" title="功能模块开发"></a>功能模块开发</h2><p>需求：对表t_book进行新增、修改、删除、根据ID查询和查询所有</p><ol><li><p>创建数据库及表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">create database ssm_db;</span><br><span class="line">use ssm_db;</span><br><span class="line">create table tbl_book</span><br><span class="line">(</span><br><span class="line">    id          int primary key auto_increment,</span><br><span class="line">    type        varchar(20),</span><br><span class="line">    `name`      varchar(50),</span><br><span class="line">    description varchar(255)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">insert into `tbl_book`(`id`, `type`, `name`, `description`)</span><br><span class="line">values (1, &#x27;计算机理论&#x27;, &#x27;Spring实战 第五版&#x27;, &#x27;Spring入门经典教程，深入理解Spring原理技术内幕&#x27;),</span><br><span class="line">       (2, &#x27;计算机理论&#x27;, &#x27;Spring 5核心原理与30个类手写实践&#x27;, &#x27;十年沉淀之作，手写Spring精华思想&#x27;),</span><br><span class="line">       (3, &#x27;计算机理论&#x27;, &#x27;Spring 5设计模式&#x27;, &#x27;深入Spring源码刨析Spring源码中蕴含的10大设计模式&#x27;),</span><br><span class="line">       (4, &#x27;计算机理论&#x27;, &#x27;Spring MVC+Mybatis开发从入门到项目实战&#x27;,</span><br><span class="line">        &#x27;全方位解析面向Web应用的轻量级框架，带你成为Spring MVC开发高手&#x27;),</span><br><span class="line">       (5, &#x27;计算机理论&#x27;, &#x27;轻量级Java Web企业应用实战&#x27;, &#x27;源码级刨析Spring框架，适合已掌握Java基础的读者&#x27;),</span><br><span class="line">       (6, &#x27;计算机理论&#x27;, &#x27;Java核心技术 卷Ⅰ 基础知识(原书第11版)&#x27;,</span><br><span class="line">        &#x27;Core Java第11版，Jolt大奖获奖作品，针对Java SE9、10、11全面更新&#x27;),</span><br><span class="line">       (7, &#x27;计算机理论&#x27;, &#x27;深入理解Java虚拟机&#x27;, &#x27;5个纬度全面刨析JVM,大厂面试知识点全覆盖&#x27;),</span><br><span class="line">       (8, &#x27;计算机理论&#x27;, &#x27;Java编程思想(第4版)&#x27;, &#x27;Java学习必读经典，殿堂级著作！赢得了全球程序员的广泛赞誉&#x27;),</span><br><span class="line">       (9, &#x27;计算机理论&#x27;, &#x27;零基础学Java(全彩版)&#x27;, &#x27;零基础自学编程的入门图书，由浅入深，详解Java语言的编程思想和核心技术&#x27;),</span><br><span class="line">       (10, &#x27;市场营销&#x27;, &#x27;直播就这么做:主播高效沟通实战指南&#x27;, &#x27;李子柒、李佳奇、薇娅成长为网红的秘密都在书中&#x27;),</span><br><span class="line">       (11, &#x27;市场营销&#x27;, &#x27;直播销讲实战一本通&#x27;, &#x27;和秋叶一起学系列网络营销书籍&#x27;),</span><br><span class="line">       (12, &#x27;市场营销&#x27;, &#x27;直播带货:淘宝、天猫直播从新手到高手&#x27;, &#x27;一本教你如何玩转直播的书，10堂课轻松实现带货月入3W+&#x27;);</span><br></pre></td></tr></table></figure></li><li><p>编写模型类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class Book &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String type;</span><br><span class="line">    private String name;</span><br><span class="line">    private String description;</span><br><span class="line">    </span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getType() &#123;</span><br><span class="line">        return type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setType(String type) &#123;</span><br><span class="line">        this.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDescription() &#123;</span><br><span class="line">        return description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDescription(String description) &#123;</span><br><span class="line">        this.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Book&#123;&quot; +</span><br><span class="line">                &quot;id=&quot; + id +</span><br><span class="line">                &quot;, type=&#x27;&quot; + type + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, description=&#x27;&quot; + description + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写Dao接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public interface BookDao &#123;</span><br><span class="line">    @Insert(&quot;insert into tbl_book values (null, #&#123;type&#125;, #&#123;name&#125;, #&#123;description&#125;)&quot;)</span><br><span class="line">    void save(Book book);</span><br><span class="line"></span><br><span class="line">    @Update(&quot;update tbl_book set type=#&#123;type&#125;, `name`=#&#123;name&#125;, `description`=#&#123;description&#125; where id=#&#123;id&#125;&quot;)</span><br><span class="line">    void update(Book book);</span><br><span class="line"></span><br><span class="line">    @Delete(&quot;delete from tbl_book where id=#&#123;id&#125;&quot;)</span><br><span class="line">    void delete(Integer id);</span><br><span class="line"></span><br><span class="line">    @Select(&quot;select * from tbl_book where id=#&#123;id&#125;&quot;)</span><br><span class="line">    void getById(Integer id);</span><br><span class="line"></span><br><span class="line">    @Select(&quot;select * from tbl_book&quot;)</span><br><span class="line">    void getAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写Service接口及其实现类</p><ul><li><p>Service接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">public interface BookService &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 保存</span><br><span class="line">     * @param book</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    boolean save(Book book);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 修改</span><br><span class="line">     * @param book</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    boolean update(Book book);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 按id删除</span><br><span class="line">     * @param id</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    boolean delete(Integer id);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 按id查询</span><br><span class="line">     * @param id</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    Book getById(Integer id);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查询所有</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    List&lt;Book&gt; getAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>BookServiceImpl 实现类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class BookServiceImpl implements BookService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    public boolean save(Book book) &#123;</span><br><span class="line">        bookDao.save(book);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean update(Book book) &#123;</span><br><span class="line">        bookDao.update(book);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean delete(@PathVariable Integer id) &#123;</span><br><span class="line">        bookDao.delete(id);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Book getById(Integer id) &#123;</span><br><span class="line">        return bookDao.getById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;Book&gt; getAll() &#123;</span><br><span class="line">        return bookDao.getAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>编写Controller类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/books&quot;)</span><br><span class="line">public class BookController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private BookService bookService;</span><br><span class="line"></span><br><span class="line">    @PostMapping</span><br><span class="line">    public boolean save(@RequestBody Book book) &#123;</span><br><span class="line">        return bookService.save(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PutMapping</span><br><span class="line">    public boolean update(@RequestBody Book book) &#123;</span><br><span class="line">        return bookService.update(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public boolean delete(@PathVariable Integer id) &#123;</span><br><span class="line">        return bookService.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public Book getById(@PathVariable Integer id) &#123;</span><br><span class="line">        return bookService.getById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping</span><br><span class="line">    public List&lt;Book&gt; getAll() &#123;</span><br><span class="line">        return bookService.getAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><ol><li><p>新建测试类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(classes = SpringConfig.class)</span><br><span class="line">public class BookServiceTest &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注入Service</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(classes = SpringConfig.class)</span><br><span class="line">public class BookServiceTest &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private BookService bookService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写测试方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(classes = SpringConfig.class)</span><br><span class="line">public class BookServiceTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private BookService bookService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testGetById() &#123;</span><br><span class="line">        Book book = bookService.getById(1);</span><br><span class="line">        System.out.println(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testGetAll() &#123;</span><br><span class="line">        for (Book book : bookService.getAll()) &#123;</span><br><span class="line">            System.out.println(book);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试方法，可以查询到对应的数据</p></li></ol><h1 id="统一结果封装"><a href="#统一结果封装" class="headerlink" title="统一结果封装"></a>统一结果封装</h1><h2 id="表现层与前端数据传输协议定义"><a href="#表现层与前端数据传输协议定义" class="headerlink" title="表现层与前端数据传输协议定义"></a>表现层与前端数据传输协议定义</h2><p>SSM整合以及功能模块开发完成后，接下来我们在上述案例的基础上，分析一下有哪些问题需要我们解决。</p><p>在Controller层增删改操作完成后，返回给前端的是boolean类型的数据：true</p><p>在Controller层查询单个，返回给前端的是对象</p><p>在Controller层查询所有，返回给前端的是集合对象</p><p>目前我们就已经有<code>三种数据类型</code>返回给前端了，随着业务的增长，我们需要返回的数据类型就会<code>越来越多</code>。那么前端开发人员在解析数据的时候就比较<code>凌乱</code>了，所以对于前端来说，如果后端能返回一个<code>统一的数据结果</code>，前端在解析的时候就可以按照一种方式进行解析，开发就会变得更加简单</p><p>所以现在我们需要解决的问题就是<code>如何将返回的结果数据进行统一</code>，具体如何来做，大体思路如下</p><ul><li><p>为了封装返回的结果数据：创建结果模型类，封装数据到data属性中</p><blockquote><p>我们可以设置data的数据类型为<code>Object</code>，这样data中就可以放任意的结果类型了，包括但不限于上面的<code>boolean</code>、<code>对象</code>、<code>集合对象</code></p></blockquote></li><li><p>为了封装返回的数据是何种操作，以及是否操作成功：封装操作结果到code属性中</p><blockquote><p>例如增删改操作返回的都是<code>true</code>，那我们怎么分辨这个<code>true</code>到底是<code>增</code>还是<code>删</code>还是<code>改</code>呢？我们就通过这个<code>code</code>来区分</p></blockquote><blockquote><p>操作失败后，需要封装返回错误信息提示给用户：封装特殊消息到message(msg)属性中</p></blockquote><p>例如查询或删除的目标不存在，会返回null，那么此时我们需要提示<code>查询/删除的目标不存在，请重试！</code></p></li></ul><p>那么之前的三种返回方式就可以变为如下形式</p><div class="tabs" id="1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#1-1">boolean</button></li><li class="tab"><button type="button" data-href="#1-2">对象</button></li><li class="tab"><button type="button" data-href="#1-3">集合</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><p>规则可以自己定<br>这里前三位是固定的<br>第四位表示不同的操作<br>末位表示成功&#x2F;失败，1成功，0失败</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="number">20011</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-2"><p>这里的末尾是0，表示失败操作<br>第四位是2，区别于上面的1，表示是不同的操作类型<br>msg给用户提示信息，不是必有项</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="number">20020</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span><span class="string">&quot;数据查询失败，请重试！&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-3"><p>这里末尾操作是1，表示成功操作<br>data中显示的是对象集合<br>没有msg</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="number">20031</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;计算机理论&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Spring实战 第5版&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;Spring入门经典教程&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;计算机理论&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Spring 5核心原理与30个类手写实战&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;十年沉淀之作&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>根据分析，我们可以设置统一数据返回结果类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span>&#123;</span><br><span class="line"><span class="keyword">private</span> Object data;</span><br><span class="line"><span class="keyword">private</span> Integer code;</span><br><span class="line"><span class="keyword">private</span> String msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：Result类名及类中的字段并不是固定的，可以根据需要自行增减提供若干个构造方法，方便操作。</p><h2 id="表现层与前端数据传输协议实现"><a href="#表现层与前端数据传输协议实现" class="headerlink" title="表现层与前端数据传输协议实现"></a>表现层与前端数据传输协议实现</h2><p>前面我们已经分析了如何封装返回结果数据，现在我们来具体实现一下</p><p>对于结果封装，我们应该是在表现层进行处理，所以我们把结果类放在controller包下，当然你也可以放在domain包，这个都是可以的，具体如何实现结果封装，具体的步骤如下</p><ol><li><p>创建Result类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public class Result &#123;</span><br><span class="line">    //描述统一格式中的编码，用于区分操作，可以简化配置0或1表示成功失败</span><br><span class="line">    private Integer code;</span><br><span class="line">    //描述统一格式中的数据</span><br><span class="line">    private Object data;</span><br><span class="line">    //描述统一格式中的消息，可选属性</span><br><span class="line">    private String msg;</span><br><span class="line"></span><br><span class="line">    public Result() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //构造器可以根据自己的需要来编写</span><br><span class="line">    public Result(Integer code, Object data) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Result(Integer code, Object data, String msg) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">        this.data = data;</span><br><span class="line">        this.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getCode() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCode(Integer code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object getData() &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Object data) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getMsg() &#123;</span><br><span class="line">        return msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMsg(String msg) &#123;</span><br><span class="line">        this.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Result&#123;&quot; +</span><br><span class="line">                &quot;code=&quot; + code +</span><br><span class="line">                &quot;, data=&quot; + data +</span><br><span class="line">                &quot;, msg=&#x27;&quot; + msg + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>定义返回码Code类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Code &#123;</span><br><span class="line">    public static final Integer SAVE_OK = 20011;</span><br><span class="line">    public static final Integer UPDATE_OK = 20021;</span><br><span class="line">    public static final Integer DELETE_OK = 20031;</span><br><span class="line">    public static final Integer GET_OK = 20041;</span><br><span class="line">    </span><br><span class="line">    public static final Integer SAVE_ERR = 20010;</span><br><span class="line">    public static final Integer UPDATE_ERR = 20020;</span><br><span class="line">    public static final Integer DELETE_ERR = 20030;</span><br><span class="line">    public static final Integer GET_ERR = 20040;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：code类中的常量设计也不是固定的，可以根据需要自行增减，例如将查询再进行细分为<code>GET_OK</code>，<code>GET_ALL_OK</code>，<code>GET_PAGE_OK</code>等。</p></li><li><p>修改Controller类的返回值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/books&quot;)</span><br><span class="line">public class BookController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private BookService bookService;</span><br><span class="line"></span><br><span class="line">    @PostMapping</span><br><span class="line">    public Result save(@RequestBody Book book) &#123;</span><br><span class="line">        boolean flag = bookService.save(book);</span><br><span class="line">        return new Result(flag ? Code.SAVE_OK : Code.SAVE_ERR, flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PutMapping</span><br><span class="line">    public Result update(@RequestBody Book book) &#123;</span><br><span class="line">        boolean flag = bookService.update(book);</span><br><span class="line">        return new Result(flag ? Code.UPDATE_OK : Code.UPDATE_ERR, flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public Result delete(@PathVariable Integer id) &#123;</span><br><span class="line">        boolean flag = bookService.delete(id);</span><br><span class="line">        return new Result(flag ? Code.DELETE_OK : Code.DELETE_ERR, flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public Result getById(@PathVariable Integer id) &#123;</span><br><span class="line">        Book book = bookService.getById(id);</span><br><span class="line">        Integer code = book == null ? Code.GET_ERR : Code.GET_OK;</span><br><span class="line">        String msg = book == null ? &quot;数据查询失败，请重试！&quot; : &quot;&quot;;</span><br><span class="line">        return new Result(code, book, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping</span><br><span class="line">    public Result getAll() &#123;</span><br><span class="line">        List&lt;Book&gt; bookList = bookService.getAll();</span><br><span class="line">        Integer code = bookList == null ? Code.GET_ERR : Code.GET_OK;</span><br><span class="line">        String msg = bookList == null ? &quot;数据查询失败，请重试！&quot; : &quot;&quot;;</span><br><span class="line">        return new Result(code, bookList, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动服务测试<br>五个方法的测试结果如下</p><div class="tabs" id="2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2-1">save</button></li><li class="tab"><button type="button" data-href="#2-2">update</button></li><li class="tab"><button type="button" data-href="#2-3">delete</button></li><li class="tab"><button type="button" data-href="#2-4">getById</button></li><li class="tab"><button type="button" data-href="#2-5">getAll</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 20011,</span><br><span class="line">    &quot;data&quot;: true,</span><br><span class="line">    &quot;msg&quot;: null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 20021,</span><br><span class="line">    &quot;data&quot;: true,</span><br><span class="line">    &quot;msg&quot;: null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2-3"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 20031,</span><br><span class="line">    &quot;data&quot;: true,</span><br><span class="line">    &quot;msg&quot;: null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2-4"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 20041,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;id&quot;: 1,</span><br><span class="line">        &quot;type&quot;: &quot;计算机理论&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;Spring实战 第五版&quot;,</span><br><span class="line">        &quot;description&quot;: &quot;Spring入门经典教程，深入理解Spring原理技术内幕&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;msg&quot;: &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2-5"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 20041,</span><br><span class="line">    &quot;data&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 1,</span><br><span class="line">            &quot;type&quot;: &quot;计算机理论&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;Spring实战 第五版&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;Spring入门经典教程，深入理解Spring原理技术内幕&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 2,</span><br><span class="line">            &quot;type&quot;: &quot;计算机理论&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;Spring 5核心原理与30个类手写实践&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;十年沉淀之作，手写Spring精华思想&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 3,</span><br><span class="line">            &quot;type&quot;: &quot;计算机理论&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;Spring 5设计模式&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;深入Spring源码刨析Spring源码中蕴含的10大设计模式&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 4,</span><br><span class="line">            &quot;type&quot;: &quot;计算机理论&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;Spring MVC+Mybatis开发从入门到项目实战&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;全方位解析面向Web应用的轻量级框架，带你成为Spring MVC开发高手&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 5,</span><br><span class="line">            &quot;type&quot;: &quot;计算机理论&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;轻量级Java Web企业应用实战&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;源码级刨析Spring框架，适合已掌握Java基础的读者&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 6,</span><br><span class="line">            &quot;type&quot;: &quot;计算机理论&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;Java核心技术 卷Ⅰ 基础知识(原书第11版)&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;Core Java第11版，Jolt大奖获奖作品，针对Java SE9、10、11全面更新&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 7,</span><br><span class="line">            &quot;type&quot;: &quot;计算机理论&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;深入理解Java虚拟机&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;5个纬度全面刨析JVM,大厂面试知识点全覆盖&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 8,</span><br><span class="line">            &quot;type&quot;: &quot;计算机理论&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;Java编程思想(第4版)&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;Java学习必读经典，殿堂级著作！赢得了全球程序员的广泛赞誉&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 9,</span><br><span class="line">            &quot;type&quot;: &quot;计算机理论&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;零基础学Java(全彩版)&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;零基础自学编程的入门图书，由浅入深，详解Java语言的编程思想和核心技术&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 10,</span><br><span class="line">            &quot;type&quot;: &quot;市场营销&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;直播就这么做:主播高效沟通实战指南&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;李子柒、李佳奇、薇娅成长为网红的秘密都在书中&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 11,</span><br><span class="line">            &quot;type&quot;: &quot;市场营销&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;直播销讲实战一本通&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;和秋叶一起学系列网络营销书籍&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 12,</span><br><span class="line">            &quot;type&quot;: &quot;市场营销&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;直播带货:淘宝、天猫直播从新手到高手&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;一本教你如何玩转直播的书，10堂课轻松实现带货月入3W+&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 14,</span><br><span class="line">            &quot;type&quot;: &quot;类别测试数据&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;书名测试数据9527&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;描述测试数据&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 15,</span><br><span class="line">            &quot;type&quot;: &quot;类别测试数据&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;书名测试数据&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;描述测试数据&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 16,</span><br><span class="line">            &quot;type&quot;: &quot;类别测试数据&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;书名测试数据&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;描述测试数据&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;msg&quot;: &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></li></ol><h1 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h1><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>先人为弄一个异常出来</p><p>修改<code>BookController</code>的<code>getById()</code>方法，手写一个异常</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">public Result getById(@PathVariable Integer id) &#123;</span><br><span class="line">    //当id为1的时候，手动添加了一个错误信息</span><br><span class="line">    if (id == 1)&#123;</span><br><span class="line">        int a = 1 / 0;</span><br><span class="line">    &#125;</span><br><span class="line">    Book book = bookService.getById(id);</span><br><span class="line">    Integer code = book == null ? Code.GET_ERR : Code.GET_OK;</span><br><span class="line">    String msg = book == null ? &quot;数据查询失败，请重试！&quot; : &quot;&quot;;</span><br><span class="line">    return new Result(code, book, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新启动服务器，使用<code>PostMan</code>发送请求，当传入的<code>id为1</code>时，会出现如下效果</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310201941126.png"></p><p>前端接收到这个信息后，和我们之前约定的格式不一致，怎么解决呢？</p><h2 id="异常的种类"><a href="#异常的种类" class="headerlink" title="异常的种类"></a>异常的种类</h2><p>在解决问题之前，我们先来看一下异常的种类，以及出现异常的原因：</p><ul><li>框架内部抛出的异常：因<code>使用不合规</code>导致</li><li>数据层抛出的异常：因使用<code>外部服务器故障</code>导致（例如：服务器访问超时）</li><li>业务层抛出的异常：因<code>业务逻辑书写错误</code>导致（例如：遍历业务书写操作，导致索引越界异常等）</li><li>表现层抛出的异常：因<code>数据收集</code>、<code>校验</code>等规则导致（例如：不匹配的数据类型间转换导致异常）</li><li>工具类抛出的异常：因工具类<code>书写不严谨</code>，<code>健壮性不足</code>导致（例如：必要时放的连接，长时间未释放等）</li></ul><p>了解完上面这些出现<code>异常的位置</code>，我们发现，在我们开发的<code>任何一个位置</code>都可能会出现异常，而且这些异常是<code>不能避免的</code>，所以我们就需要对这些异常来<code>进行处理</code>。</p><ol><li>各个层级均出现异常，那么异常处理代码要写在哪一层？<ul><li>所有的异常均抛出到表现层进行处理</li></ul></li><li>异常的种类很多，表现层如何将所有的异常都处理到呢？<ul><li>异常分类</li></ul></li><li>表现层处理异常，每个方法中单独书写，代码书写两巨大，且意义不强，如何解决呢？<ul><li>AOP</li></ul></li></ol><p>对于上面这些问题以及解决方案，SpringMVC已经为我们提供了一套了：<strong>异常处理器</strong></p><p>异常处理器：集中的、统一的处理项目中出现的异常</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RestControllerAdvice</span><br><span class="line">public class ProjectExceptionAdvice &#123;</span><br><span class="line">    @ExceptionHandler(Exception.class)</span><br><span class="line">    public Result doException(Exception ex) &#123;</span><br><span class="line">        return new Result(666, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常处理器的使用"><a href="#异常处理器的使用" class="headerlink" title="异常处理器的使用"></a>异常处理器的使用</h2><ol><li><p>创建异常处理器类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RestControllerAdvice</span><br><span class="line">public class ProjectExceptionAdvice &#123;</span><br><span class="line">    @ExceptionHandler(Exception.class)</span><br><span class="line">    public void doException(Exception ex) &#123;</span><br><span class="line">        System.out.println(&quot;嘿嘿，逮到一个异常~&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：要确保SpringMvcConfig能够扫描到异常处理器类，之前放controller包里面就顺带一起扫了</p></li><li><p>让程序抛出异常</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">public Result getById(@PathVariable Integer id) &#123;</span><br><span class="line">    //当id为1的时候，手动添加了一个错误信息</span><br><span class="line">    if (id == 1)&#123;</span><br><span class="line">        int a = 1 / 0;</span><br><span class="line">    &#125;</span><br><span class="line">    Book book = bookService.getById(id);</span><br><span class="line">    Integer code = book == null ? Code.GET_ERR : Code.GET_OK;</span><br><span class="line">    String msg = book == null ? &quot;数据查询失败，请重试！&quot; : &quot;&quot;;</span><br><span class="line">    return new Result(code, book, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>PostMan</code>发送<code>GET</code>请求访问<code>localhost:8080/books/1</code><br>控制台输出如下，说明异常已经被拦截，且执行了<code>doException()</code>方法</p><p>但是现在没有返回数据给前端，为了统一返回结果，我们继续修改异常处理器类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@RestControllerAdvice</span><br><span class="line">public class ProjectExceptionAdvice &#123;</span><br><span class="line">    @ExceptionHandler(Exception.class)</span><br><span class="line">    public Result doException(Exception ex) &#123;</span><br><span class="line">        System.out.println(&quot;有一个异常&quot;);</span><br><span class="line">        return new Result(666, null, &quot;有一个异常&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启服务器，使用PostMan发送请求，此时就能接收到结果了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 666,</span><br><span class="line">    &quot;data&quot;: null,</span><br><span class="line">    &quot;msg&quot;: &quot;有一个异常&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>知识点：<code>@RestControllerAdvice</code></p><p>说明：此注解自带<code>@ResponseBody</code>注解与<code>@Component</code>注解，具备对应的功能</p><table><thead><tr><th align="center">名称</th><th align="center">@RestControllerAdvice</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">类注解</td></tr><tr><td align="center">位置</td><td align="center">Rest风格开发的控制器增强类定义上方</td></tr><tr><td align="center">作用</td><td align="center">为Rest风格开发的控制器类做增强</td></tr></tbody></table><p>知识点：<code>@ExceptionHandler</code></p><p>说明：此类方法可以根据处理的异常不同，制作多个方法分别处理对应的异常</p><table><thead><tr><th align="center">名称</th><th align="center">@ExceptionHandler</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">方法注解</td></tr><tr><td align="center">位置</td><td align="center">专用于异常处理的控制器方法上方</td></tr><tr><td align="center">作用</td><td align="center">设置指定异常的处理方案，功能等同于控制器方法， 出现异常后终止原始控制器执行,并转入当前方法执行</td></tr></tbody></table><h2 id="项目异常处理方案"><a href="#项目异常处理方案" class="headerlink" title="项目异常处理方案"></a>项目异常处理方案</h2><p>异常处理器我们已经能够使用了，那么我们如何在项目中来处理异常呢?</p><h3 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h3><p>因为异常的种类有很多，如果每一个异常都对应一个<code>@ExceptionHandler</code>，那得写多少个方法来处理各自的异常，所以我们在处理异常之前，需要对异常进行一个分类:</p><p>将异常分类以后，针对不同类型的异常，要提供具体的解决方案</p><div class="tabs" id="3"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#3-1">业务异常</button></li><li class="tab"><button type="button" data-href="#3-2">业务异常</button></li><li class="tab"><button type="button" data-href="#3-3">其他异常</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="3-1"><p>规范的用户行为产生的异常</p><ul><li>用户在页面输入内容的时候未按照指定格式进行数据填写，如在年龄框输入的是字符串</li></ul><p>不规范的用户行为操作产生的异常</p><ul><li>如用户手改URL，故意传递错误数据<code>localhost:8080/books/略略略</code></li></ul><p>异常解决方案</p><ul><li>发送对应消息传递给用户，提醒规范操作<ul><li>大家常见的就是提示用户名已存在或密码格式不正确等</li></ul></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3-2"><p>项目运行过程中可预计，但无法避免的异常</p><ul><li>如服务器宕机</li></ul><p>异常解决方案</p><ul><li>发送固定消息传递给用户，安抚用户<ul><li>系统繁忙，请稍后再试</li><li>系统正在维护升级，请稍后再试</li><li>系统出问题，请联系系统管理员等</li></ul></li><li>发送特定消息给运维人员，提醒维护<ul><li>可以发送短信、邮箱或者是公司内部通信软件</li></ul></li><li>记录日志<ul><li>发消息给运维和记录日志对用户来说是不可见的，属于后台程序</li></ul></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3-3"><p>编程人员未预期到的异常</p><ul><li>如：系统找不到指定文件</li></ul><p>异常解决方案</p><ul><li>发送固定消息传递给用户，安抚用户</li><li>发送特定消息给编程人员，提醒维护（纳入预期范围内）<ul><li>一般是程序没有考虑全，比如未做非空校验等</li></ul></li><li>记录日志</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>思路:</p><ol><li>先通过自定义异常，完成BusinessException和SystemException的定义</li><li>将其他异常包装成自定义异常类型</li><li>在异常处理器类中对不同的异常进行处理</li></ol><p>实现：</p><ol><li><p>自定义异常类</p><div class="tabs" id="4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#4-1">SystemException</button></li><li class="tab"><button type="button" data-href="#4-2">BusinessException</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="4-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class SystemException extends RuntimeException &#123;</span><br><span class="line">    private Integer code;</span><br><span class="line"></span><br><span class="line">    public Integer getCode() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCode(Integer code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SystemException() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SystemException(Integer code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SystemException(Integer code, String message) &#123;</span><br><span class="line">        super(message);</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SystemException(Integer code, String message, Throwable cause) &#123;</span><br><span class="line">        super(message, cause);</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="4-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class BusinessException extends RuntimeException&#123;</span><br><span class="line">    private Integer code;</span><br><span class="line"></span><br><span class="line">    public Integer getCode() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCode(Integer code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BusinessException() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BusinessException(Integer code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BusinessException(Integer code, String message) &#123;</span><br><span class="line">        super(message);</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BusinessException(Integer code, String message, Throwable cause) &#123;</span><br><span class="line">        super(message, cause);</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>说明：</p><ul><li>让自定义异常类继承<code>RuntimeException</code>的好处是，后期在抛出这两个异常的时候，就不用在<code>try..catch..</code>或<code>throws</code>了</li><li>自定义异常类中添加<code>code</code>属性的原因是为了更好的区分异常是来自哪个业务的</li></ul></li><li><p>将其他异常包成自定义异常</p><p>假如在<code>BookServiceImpl</code>的<code>getById</code>方法抛异常了，该如何来包装呢?</p><p>具体的包装方式有：</p><ol><li><code>try&#123;&#125;catch()&#123;&#125;</code>在catch中重新throw我们自定义异常即可。</li><li>直接<code>throw</code>自定义异常即可</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public Book getById(Integer id) &#123;</span><br><span class="line">    //模拟业务异常，包装成自定义异常</span><br><span class="line">    if(id == 1)&#123;</span><br><span class="line">        throw new BusinessException(Code.BUSINESS_ERR,&quot;你别给我乱改URL噢&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //模拟系统异常，将可能出现的异常进行包装，转换成自定义异常</span><br><span class="line">    try&#123;</span><br><span class="line">        int i = 1/0;</span><br><span class="line">    &#125;catch (Exception e)&#123;</span><br><span class="line">        throw new SystemException(Code.SYSTEM_TIMEOUT_ERR,&quot;服务器访问超时，请重试!&quot;,e);</span><br><span class="line">    &#125;</span><br><span class="line">    return bookDao.getById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面为了使<code>code</code>看着更专业些，我们在Code类中再新增需要的属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Code &#123;</span><br><span class="line">    public static final Integer SAVE_OK = 20011;</span><br><span class="line">    public static final Integer UPDATE_OK = 20021;</span><br><span class="line">    public static final Integer DELETE_OK = 20031;</span><br><span class="line">    public static final Integer GET_OK = 20041;</span><br><span class="line"></span><br><span class="line">    public static final Integer SAVE_ERR = 20010;</span><br><span class="line">    public static final Integer UPDATE_ERR = 20020;</span><br><span class="line">    public static final Integer DELETE_ERR = 20030;</span><br><span class="line">    public static final Integer GET_ERR = 20040;</span><br><span class="line"></span><br><span class="line">    public static final Integer SYSTEM_ERR = 50001;</span><br><span class="line">    public static final Integer SYSTEM_TIMEOUT_ERR = 50002;</span><br><span class="line">    public static final Integer SYSTEM_UNKNOW_ERR = 59999;</span><br><span class="line"></span><br><span class="line">    public static final Integer BUSINESS_ERR = 60001;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>处理器类中处理自定义异常</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@RestControllerAdvice</span><br><span class="line">public class ProjectExceptionAdvice &#123;</span><br><span class="line">    @ExceptionHandler(SystemException.class)</span><br><span class="line">    public Result doSystemException(SystemException ex) &#123;</span><br><span class="line">        return new Result(ex.getCode(), null, ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ExceptionHandler(BusinessException.class)</span><br><span class="line">    public Result doBusinessException(BusinessException ex) &#123;</span><br><span class="line">        return new Result(ex.getCode(), null, ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ExceptionHandler(Exception.class)</span><br><span class="line">    public Result doException(Exception ex) &#123;</span><br><span class="line">        return new Result(Code.SYSTEM_UNKNOW_ERR, null, &quot;系统繁忙，请稍后再试！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行程序<br>根据ID查询，如果传入的参数为1，会报<code>BusinessException</code></p><p>如果传入的是其他参数，会报<code>SystemException</code>，错误信息应为<code>服务器访问超时，请重试!</code></p><p>那么对于异常我们就已经处理完成了，不管后台哪一层抛出异常，都会以我们与前端约定好的方式进行返回，前端只需要把信息获取到，根据返回的正确与否来展示不同的内容即可。</p></li></ol><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310202001983.png"></p><h1 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h1><h2 id="拦截器概念"><a href="#拦截器概念" class="headerlink" title="拦截器概念"></a>拦截器概念</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310202002007.png"></p><ol><li>浏览器发送一个请求，会先到Tomcat服务器的web服务器</li><li>Tomcat服务器接收到请求后，会先去判断请求的是<code>静态资源</code>还是<code>动态资源</code></li><li>如果是静态资源，会直接到Tomcat的项目部署目录下直接访问</li><li>如果是动态资源，就需要交给项目的后台代码进行处理</li><li>在找到具体的方法之前，我们可以去配置过滤器（可以配置多个），按照顺序进行执行（在这里就可以进行权限校验）</li><li>然后进入到中央处理器（SpringMVC中的内容），SpringMVC会根据配置的规则进行拦截</li><li>如果满足规则，则进行处理，找到其对应的<code>Controller</code>类中的方法进行之星，完成后返回结果</li><li>如果不满足规则，则不进行处理</li><li>这个时候，如果我们需要在每个Controller方法执行的前后添加业务，具体该如何来实现？<ul><li>这个就是拦截器要做的事</li></ul></li></ol><p>拦截器（Interceptor）是一种动态拦截方法调用的机制，在SpringMVC中动态拦截控制器方法的</p><ul><li><p>作用：</p><ul><li><p>在指定的方法调用前后执行预先设定的代码</p></li><li><p>阻止原始方法的执行</p></li><li><p><code>总结：</code>拦截器就是用来作增强</p></li></ul></li><li><p>但是这个拦截器貌似跟我们之前学的过滤器很像啊，不管是从作用上来看还是从执行顺序上来看</p><ul><li>那么拦截器和过滤器之间的区别是什么呢？<ul><li><code>归属不同：</code>Filter属于Servlet技术，而Interceptor属于SpringMVC技术</li><li><code>拦截内容不同：</code>Filter对所有访问进行增强，Interceptor仅对SpringMVC的访问进行增强</li></ul></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310202003631.png"></p><h2 id="拦截器入门案例"><a href="#拦截器入门案例" class="headerlink" title="拦截器入门案例"></a>拦截器入门案例</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ol><li><p>创建一个Web的Maven项目</p></li><li><p>导入坐标</p><p>SpringMvcConfig</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.blog.controller&quot;)</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class SpringMvcConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServletContainersInitConfig</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer &#123;</span><br><span class="line"></span><br><span class="line">    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        return new Class[0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        return new Class[]&#123;SpringMvcConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected String[] getServletMappings() &#123;</span><br><span class="line">        return new String[]&#123;&quot;/&quot;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Filter[] getServletFilters() &#123;</span><br><span class="line">        CharacterEncodingFilter filter = new CharacterEncodingFilter();</span><br><span class="line">        filter.setEncoding(&quot;utf-8&quot;);</span><br><span class="line">        return new Filter[]&#123;filter&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写Controller类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/books&quot;)</span><br><span class="line">public class BookController &#123;</span><br><span class="line"></span><br><span class="line">    @PostMapping</span><br><span class="line">    public String save(@RequestBody Book book)&#123;</span><br><span class="line">        System.out.println(&quot;book save ..&quot; + book);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;book save&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public String delete(@PathVariable Integer id)&#123;</span><br><span class="line">        System.out.println(&quot;book delete ..&quot; + id);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;book delete&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PutMapping</span><br><span class="line">    public String update(@RequestBody Book book)&#123;</span><br><span class="line">        System.out.println(&quot;book update ..&quot; + book);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;book update&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public String getById(@PathVariable Integer id)&#123;</span><br><span class="line">        System.out.println(&quot;book getById ..&quot; + id);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;book getById&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping</span><br><span class="line">    public String getAll()&#123;</span><br><span class="line">        System.out.println(&quot;book getAll ..&quot;);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;book getAll&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用PostMan测试，没有问题的话就可以继续往下看了</p></li></ol><h2 id="拦截器开发"><a href="#拦截器开发" class="headerlink" title="拦截器开发"></a>拦截器开发</h2><ol><li><p>创建拦截器类<br>在<code>com.blog.controller.interceptor</code>下创建<code>ProjectInterceptor</code>类，实现<code>HandlerInterceptor</code>接口，并重写其中的三个方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">//注意当前类必须受Spring容器控制</span><br><span class="line">public class ProjectInterceptor implements HandlerInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    //原始方法调用前执行的内容</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;preHandle&quot;);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //原始方法调用后执行的内容</span><br><span class="line">    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;postHandle&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //原始方法调用完成后执行的内容</span><br><span class="line">    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;afterCompletion&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置拦截器类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class SpringMvcSupport extends WebMvcConfigurationSupport &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ProjectInterceptor projectInterceptor;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">        registry.addResourceHandler(&quot;/pages/**&quot;).addResourceLocations(&quot;/pages/&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        //配置拦截器,拦截路径是/books，只会拦截/books，拦截不到/books/1</span><br><span class="line">        registry.addInterceptor(projectInterceptor).addPathPatterns(&quot;/books&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>SpringMvc添加SpringMvcSupport包扫描</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&#123;&quot;com.blog.controller&quot;, &quot;com.blog.config&quot;&#125;)</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class SpringMvcConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行程序测试</p><p>使用PostMan发送请求给<code>localhost:8080/books</code>，控制台输出如下，说明已经成功拦截</p><blockquote><p>preHandle<br>book update …Book{书名&#x3D;‘书名测试数据9527’, 价格&#x3D;0.0}<br>postHandle<br>afterCompletion</p></blockquote><p>使用PostMan发送请求给<code>localhost:8080/books/9527</code>，控制台输出如下，说明没有拦截，若想拦截，则继续修改拦截器的拦截规则</p><blockquote><p>book getById …9527</p></blockquote></li><li><p>修改拦截器拦截规则</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SpringMvcSupport extends WebMvcConfigurationSupport &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ProjectInterceptor projectInterceptor;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">        registry.addResourceHandler(&quot;/pages/**&quot;).addResourceLocations(&quot;/pages/&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        //配置拦截器，查看源码发现，参数是个可变形参，可以设置任意多个拦截路径</span><br><span class="line">        registry.addInterceptor(projectInterceptor).addPathPatterns(&quot;/books&quot;,&quot;/books/*&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们再次使用PostMan发送请求给<code>localhost:8080/books/9527</code>，控制台输出如下，说明已经成功拦截</p><blockquote><p>preHandle<br>book getById …9527<br>postHandle<br>afterCompletion</p></blockquote><p><strong>就是拦截器中的<code>preHandler</code>方法，如果返回true，则代表放行，会执行原始<code>Controller</code>类中要请求的方法，如果返回<code>false</code>，则代表拦截，后面的就不会再执行了。</strong> </p></li><li><p>简化SpringMvcSupport的编写</p><p>我们可以让<code>SpringMvcConfig</code>类实现<code>WebMvcConfigurer</code>接口，然后直接在<code>SpringMvcConfig</code>中写<code>SpringMvcSupport</code>的东西，这样我们就不用再写<code>SpringMvcSupport</code>类了，全都在<code>SpringMvcConfig</code>中写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.blog.controller&quot;)</span><br><span class="line">@EnableWebMvc</span><br><span class="line">//实现WebMvcConfigurer接口可以简化开发，但具有一定的侵入性</span><br><span class="line">public class SpringMvcConfig implements WebMvcConfigurer &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ProjectInterceptor projectInterceptor;</span><br><span class="line"></span><br><span class="line">    public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">        //对静态资源放行</span><br><span class="line">        registry.addResourceHandler(&quot;/pages/**&quot;).addResourceLocations(&quot;/pages/&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        //配置拦截器</span><br><span class="line">        registry.addInterceptor(projectInterceptor).addPathPatterns(&quot;/books&quot;, &quot;/books/*&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="拦截器的执行流程"><a href="#拦截器的执行流程" class="headerlink" title="拦截器的执行流程"></a>拦截器的执行流程</h3><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310202024542.png"></p><p>当有拦截器后，请求会先进入preHandle方法</p><ul><li>如果方法返回<code>true</code>，则放行继续执行后面的handle(Controller的方法)和后面的方法</li><li>如果返回<code>false</code>，则直接跳过后面方法的执行。</li></ul><h2 id="拦截器参数"><a href="#拦截器参数" class="headerlink" title="拦截器参数"></a>拦截器参数</h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>原始方法之前运行preHandle</p><div class="tabs" id="5"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#5-1">前置处理方法</button></li><li class="tab"><button type="button" data-href="#5-2">后置处理方法</button></li><li class="tab"><button type="button" data-href="#5-3">完成处理方法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="5-1"><p>原始方法之前运行preHandle</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">    System.out.println(&quot;preHandle&quot;);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>request:</code>请求对象</li><li><code>response:</code>响应对象</li><li><code>handler:</code>被调用的处理器对象，本质上是一个方法对象，对反射中的Method对象进行了再包装</li></ul><p>使用request对象可以获取请求数据中的内容，如获取请求头的<code>Content-Type</code>，成功输出了Content-Type<code>application/json</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">    String name = request.getHeader(&quot;Content-Type&quot;);</span><br><span class="line">    System.out.println(&quot;preHandle..&quot; + name);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用handler参数，可以获取方法的相关信息，成功输出了方法名<code>save</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">    HandlerMethod handlerMethod = (HandlerMethod) handler;</span><br><span class="line">    String methodName = handlerMethod.getMethod().getName();</span><br><span class="line">    System.out.println(&quot;preHandle..&quot; + methodName);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5-2"><p>原始方法运行后运行，如果原始方法被拦截，则不执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//原始方法调用后执行的内容</span><br><span class="line">public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;</span><br><span class="line">    System.out.println(&quot;postHandle&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前三个参数和上面的是一致的。<br><code>modelAndView:</code>如果处理器执行完成具有返回结果，可以读取到对应数据与页面信息，并进行调整<br>因为我们现在都是返回json数据，所以该参数的使用率不高。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5-3"><p>拦截器最后执行的方法，无论原始方法是否执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//原始方法调用完成后执行的内容</span><br><span class="line">public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;</span><br><span class="line">    System.out.println(&quot;afterCompletion&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前三个参数与上面的是一致的。但是有第四个参数ex</p><p>ex：如果处理器执行过程中出现异常对象，可以针对异常情况进行单独处理</p><p>因为我们现在已经有全局异常处理器类，所以该参数的使用率也不高。</p><p>这三个方法中，最常用的是<code>preHandle</code>，在这个方法中可以通过返回值来决定是否要进行放行，我们可以把业务逻辑放在该方法中，如果满足业务则返回<code>true</code>放行，不满足则返回<code>false</code>拦截。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="拦截器链配置"><a href="#拦截器链配置" class="headerlink" title="拦截器链配置"></a>拦截器链配置</h2><p>目前，我们在项目中只添加了一个拦截器，如果有多个，该如何配置?配置多个后，执行顺序是什么?</p><ul><li>当配置多个拦截器时，形成拦截器链</li><li>拦截器链的运行顺序参照拦截器添加顺序为准</li><li>当拦截器中出现对原始处理器的拦截，后面的拦截器均终止运行</li><li>当拦截器运行中断，仅运行配置在前面的拦截器的afterCompletion操作</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310202029609.png"></p><ul><li><code>preHandle：</code>与配置顺序相同，必定运行</li><li><code>postHandle:</code>与配置顺序相反，可能不运行</li><li><code>afterCompletion:</code>与配置顺序相反，可能不运行。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
            <tag> SSM整合 </tag>
            
            <tag> 拦截器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis</title>
      <link href="/2023/10/16/Mbatis/"/>
      <url>/2023/10/16/Mbatis/</url>
      
        <content type="html"><![CDATA[<h1 id="MyBatis简介"><a href="#MyBatis简介" class="headerlink" title="MyBatis简介"></a>MyBatis简介</h1><h2 id="MyBatis历史"><a href="#MyBatis历史" class="headerlink" title="MyBatis历史"></a>MyBatis历史</h2><p>MyBatis最初是Apache的一个开源项目iBatis, 2010年6月这个项目由Apache Software Foundation迁 移到了Google Code。随着开发团队转投Google Code旗下， iBatis3.x正式更名为MyBatis。代码于 2013年11月迁移到Github。<br>iBatis一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。 iBatis提供的持久层框架 包括SQL Maps和Data Access Objects(DAO)。</p><h2 id="MyBatis特性"><a href="#MyBatis特性" class="headerlink" title="MyBatis特性"></a>MyBatis特性</h2><p>MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架<br>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集<br>MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO(Plain Old Java Objects，普通的Java对象) 映射成数据库中的记录<br>MyBatis 是一个 半自动的ORM(Object Relation Mapping) 框架</p><h2 id="MyBatis下载"><a href="#MyBatis下载" class="headerlink" title="MyBatis下载"></a>MyBatis下载</h2><p>MyBatis下载地址: <a href="https://github.com/mybatis/mybatis-3">https://github.com/mybatis/mybatis-3</a></p><p>使用Maven创建工程可以不用下载jar包，在这里面选择下载全部资源然后找到里面的官方文档即可。不看官方文档的可以跳过这一步。</p><h2 id="和其它持久化层技术对比"><a href="#和其它持久化层技术对比" class="headerlink" title="和其它持久化层技术对比"></a>和其它持久化层技术对比</h2><p>JDBC：</p><ol><li>SQL 夹杂在Java代码中耦合度高，导致硬编码内伤</li><li>维护不易且实际开发需求中 SQL 有变化，频繁修改的情况多见</li><li>代码冗长，开发效率低</li></ol><p>Hibernate 和 JPA：</p><ol><li>操作简便，开发效率高</li><li>程序中的长难复杂 SQL 需要绕过框架</li><li>内部自动生产的 SQL，不容易做特殊优化</li><li>基于全映射的全自动框架，大量字段的POJO 进行部分映射时比较困难。</li><li>反射操作太多，导致数据库性能下降</li></ol><p>MyBatis：</p><ol><li>轻量级，性能出色 SQL 和 Java 编码分开，功能边界清晰。</li><li>Java代码专注业务、SQL语句专注数据</li><li>开发效率稍逊于Hibernate，但是完全能够接受</li></ol><h1 id="Mybatis入门案例"><a href="#Mybatis入门案例" class="headerlink" title="Mybatis入门案例"></a>Mybatis入门案例</h1><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>IDEL：idea 2022.3<br>构建工具：maven 3.6.3<br>MySQL版本：MySQL 8.0<br>MyBatis版本：MyBatis 3.5.13</p><h2 id="创建maven工程"><a href="#创建maven工程" class="headerlink" title="创建maven工程"></a>创建maven工程</h2><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">创建 maven 项目</button></li><li class="tab"><button type="button" data-href="#test1-2">配置 pom.xml</button></li><li class="tab"><button type="button" data-href="#test1-3">建立sql表单</button></li><li class="tab"><button type="button" data-href="#test1-4">创建 MyBatis核心配置文件</button></li><li class="tab"><button type="button" data-href="#test1-5">创建Mapper接口</button></li><li class="tab"><button type="button" data-href="#test1-6">创建MyBatis的映射文件</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p>创建一个普通Java项目，然后在其中新建一个maven工程，名称为mybatis_demo1。项目SDK选择Java 1.8。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p> 配置maven打包方式为jar</p><p>引入mybatis、junit、mysql依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;groupId&gt;com.atguigu.mybatis&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;MB-1&lt;/artifactId&gt;</span><br><span class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!-- Mybatis核心 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.5.13&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- junit测试 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.10&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- MySQL驱动 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;8.0.15&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p>创建一个名称为 user 的table，并设置属性：id(主键、非空、自增)、username等</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310161827564.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><p>习惯上命名为mybatis-config.xml，这个文件名仅仅只是建议，并非强制要求。将来整合Spring之后，这个配置文件可以省略，所以大家操作时可以直接复制、粘贴。</p><p>核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息。<br>核心配置文件存放的位置是src&#x2F;main&#x2F;resources目录下。</p><p>新建一个<code>mybatis-config.xml</code>文件，将以下内容粘贴进去：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;!--设置连接数据库的环境--&gt;</span><br><span class="line">&lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">    &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">        &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class="line">        &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;url&quot;</span><br><span class="line">                      value=&quot;jdbc:mysql://localhost:3306/test?serverTimezone=UTC&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt;</span><br><span class="line">            &lt;!--注意：如果在建sql表单的时候选了字符集（如utf8），</span><br><span class="line">            这里的value要改成：value=&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf8&quot;--&gt;</span><br><span class="line">            &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;password&quot; value=&quot;161519&quot;/&gt;</span><br><span class="line">        &lt;/dataSource&gt;</span><br><span class="line">    &lt;/environment&gt;</span><br><span class="line">&lt;/environments&gt;</span><br><span class="line">    &lt;!--引入映射文件--&gt; &lt;mappers&gt;</span><br><span class="line">    &lt;mapper resource=&quot;mappers/UserMapper.xml&quot;/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-5"><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310161835568.png">MyBatis中的mapper接口相当于以前的dao。<br>区别在于：mapper仅仅是接口，我们不需要提供实现类。</p><p>创建实体类，对应表单 </p><ol><li><p>创建User类pojo，对应表单 user</p><p>User类中，包括private类型的对应字段、一个有参构造器、一个无参构造器、所有字段的getter和setter</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String username;</span><br><span class="line">    private String password;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private String gender;</span><br><span class="line">    private  String email;</span><br><span class="line"></span><br><span class="line">    public User() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public User(Integer id, String username, String password, Integer age, String gender, String email) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.username = username;</span><br><span class="line">        this.password = password;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.gender = gender;</span><br><span class="line">        this.email = email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123;&quot; +</span><br><span class="line">                &quot;id=&quot; + id +</span><br><span class="line">                &quot;, username=&#x27;&quot; + username + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, password=&#x27;&quot; + password + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &quot;, gender=&#x27;&quot; + gender + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, email=&#x27;&quot; + email + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUsername(String username) &#123;</span><br><span class="line">        this.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getPassword() &#123;</span><br><span class="line">        return password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPassword(String password) &#123;</span><br><span class="line">        this.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(Integer age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getGender() &#123;</span><br><span class="line">        return gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setGender(String gender) &#123;</span><br><span class="line">        this.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getEmail() &#123;</span><br><span class="line">        return email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setEmail(String email) &#123;</span><br><span class="line">        this.email = email;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>创建UserMapper接口</p><p>MyBatis面向接口编程的两个一致：</p><ol><li>映射文件namespace和Mapper接口的全类名一致（第一个一致）</li><li>映射文件中sql语句的id和mapper接口中的方法一致（第二个一致）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface UserMapper &#123;</span><br><span class="line">    int insertUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>映射路径：</p><ol><li><p>在UserMapper.xml中，namespace为 ”com.atguigu.mybatis.mapper.UserMapper” ，定位到这个com.atguigu.mybatis.mapper.UserMapper类。</p></li><li><p>根据元素id，例如 insert id&#x3D;”insertUser”，找到UserMapper.insertUser()。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public interface UserMapper &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 添加用户信息</span><br><span class="line">     * sql写在映射文件中</span><br><span class="line">     */</span><br><span class="line">    int insertUser();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 修改用户信息</span><br><span class="line">     */</span><br><span class="line">    void updateUser();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除用户信息</span><br><span class="line">     */</span><br><span class="line">    void deleteUser();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据id查询用户信息</span><br><span class="line">     */</span><br><span class="line">    User getUserById();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查询所有的用户信息</span><br><span class="line">     */</span><br><span class="line">    List&lt;User&gt; getAllUser();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-6"><p>相关概念：<strong>ORM(Object Relationship Mapping)对象关系映射</strong>。</p><ul><li>对象：Java的实体类对象</li><li>关系：关系型数据库</li><li>映射：二者之间的对应关系</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310161837207.png"></p><p>映射文件的命名规则:</p><p>表所对应的实体类的类名+Mapper.xml</p><blockquote><p>例如:表user，映射的实体类为User，所对应的映射文件为UserMapper.xml (一张表一个映射文件)<br>因此一个映射文件对应一个实体类，对应一张表的操作<br>MyBatis映射文件用于编写SQL，访问以及操作表中的数据 MyBatis映射文件存放的位置是src&#x2F;main&#x2F;resources&#x2F;mappers目录下</p></blockquote><p>MyBatis中可以面向接口操作数据，<strong>要保证两个一致:</strong></p><ol><li>mapper接口的全类名和映射文件的命名空间(namespace)保持一致</li><li>mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致</li></ol><p>在src&#x2F;main&#x2F;resources下，创建UserMapper.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.atguigu.mybatis.mapper.UserMapper&quot;&gt;</span><br><span class="line">    &lt;!--int insertUser();--&gt;</span><br><span class="line">    &lt;insert id=&quot;insertUser&quot;&gt;</span><br><span class="line">        insert into t_user values(null, &quot;marina&quot;, &quot;456&quot;,23,&#x27;f&#x27;,&quot;153456@qq.com&quot;)</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--void updateUser();--&gt;</span><br><span class="line">    &lt;update id=&quot;updateUser&quot;&gt;</span><br><span class="line">        update t_user set username = &quot;RUOYI&quot; where id = 4</span><br><span class="line">    &lt;/update&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--void deleteUser();--&gt;</span><br><span class="line">    &lt;delete id=&quot;deleteUser&quot;&gt;</span><br><span class="line">        delete from t_user where id = 5</span><br><span class="line">    &lt;/delete&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--User getUserById();--&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">        查询功能的标签必须设置resultType或者resultMap</span><br><span class="line">        resultType：设置默认的映射关系</span><br><span class="line">        resultMap：设置自定义的映射关系（字段名和表头不一样）</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;select id=&quot;getUserById&quot; resultType=&quot;com.atguigu.mybatis.pojo.User&quot;&gt;</span><br><span class="line">        select * from t_user where id = 4</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--List&lt;User&gt; getAllUser();--&gt;</span><br><span class="line">    &lt;select id=&quot;getAllUser&quot; resultType=&quot;com.atguigu.mybatis.pojo.User&quot;&gt;</span><br><span class="line">        select * from t_user</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;/mapper&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="通过junit进行测试"><a href="#通过junit进行测试" class="headerlink" title="通过junit进行测试"></a>通过junit进行测试</h3><p>在src&#x2F;test下建立com.atguigu.mybatis.test包，创建MyBatisTest测试类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">public class MyBatisTest &#123;</span><br><span class="line">    /**</span><br><span class="line">     * sqlsession默认不自动提交事务，如果需要自动提交事务，可以使用SqlSessionFactory.openSession(true);</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testInsertUser() throws IOException &#123;</span><br><span class="line">        //加载核心配置文件</span><br><span class="line">        InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">        //获取sqlsessionfactorybuilder</span><br><span class="line">        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();</span><br><span class="line">        //获取factory</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);</span><br><span class="line">        //获取sqlsession</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession(true);</span><br><span class="line">        //获取mapper接口对象</span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper.class); //代理模式</span><br><span class="line"></span><br><span class="line">        //测试功能</span><br><span class="line">        int result = mapper.insertUser();</span><br><span class="line"></span><br><span class="line">        //提交事务（写的type是JDBC）</span><br><span class="line">//        sqlSession.commit();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;result: &quot; + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testUpdateUser() throws IOException &#123;</span><br><span class="line">        InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession(true);</span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">        mapper.updateUser();</span><br><span class="line">        System.out.println(&quot;updating...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testDeleteUser() throws IOException &#123;</span><br><span class="line">        InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession(true);</span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">        mapper.deleteUser();</span><br><span class="line">        System.out.println(&quot;deleteUser-...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testSelectUser() throws IOException &#123;</span><br><span class="line">        InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession(true);</span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 如果不在UserMapper.xml中配置：</span><br><span class="line">         * &lt;select id=&quot;getAllUser&quot; resultType=&quot;com.atguigu.mybatis.pojo.User&quot;&gt;</span><br><span class="line">         * </span><br><span class="line">         * 会报错：A query was run and no Result Maps were found</span><br><span class="line">         *           for the Mapped Statement &#x27;com.atguigu.mybatis.mapper.UserMapper.getUserById&#x27;</span><br><span class="line">         *          It&#x27;s likely that neither a Result Type nor a Result Map was specified.</span><br><span class="line">         *</span><br><span class="line">         * com.atguigu.mybatis.mapper.UserMapper.getUserById： 命名空间.方法名</span><br><span class="line">         *</span><br><span class="line">         * 因此，要设置一个a Result Type nor a Result Map，这个type就是返回来的对应的类（要写全类名）</span><br><span class="line">         *</span><br><span class="line">         * 在UserMapper里进行设置</span><br><span class="line">         */</span><br><span class="line">        User user = mapper.getUserById();</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; allUser = mapper.getAllUser();</span><br><span class="line">        allUser.forEach(user1 -&gt; System.out.println(user1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="MyBatis-中的事务"><a href="#MyBatis-中的事务" class="headerlink" title="MyBatis 中的事务"></a>MyBatis 中的事务</h4><p>这里用的 JDBC 默认是不开启自动提交的，需要人为执行 commit 方法，但是上面的 openSession 方法中，默认值是 false，改为 true 后会自动提交。</p><h3 id="加入log4j日志功能"><a href="#加入log4j日志功能" class="headerlink" title="加入log4j日志功能"></a>加入log4j日志功能</h3><p>日志功能可以记录测试的sql语句、参数、结果，如：</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310161944281.png"></p><p><strong>引入依赖</strong></p><ol><li><p>在pom.xml中加入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- log4j日志 --&gt; </span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>加入log4j的配置文件<br>在src&#x2F;main&#x2F;resources目录下，创建log4j.xml文件，加入配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE log4j:configuration SYSTEM &quot;log4j.dtd&quot;&gt;</span><br><span class="line">&lt;log4j:configuration xmlns:log4j=&quot;http://jakarta.apache.org/log4j/&quot;&gt;</span><br><span class="line">    &lt;appender name=&quot;STDOUT&quot; class=&quot;org.apache.log4j.ConsoleAppender&quot;&gt;</span><br><span class="line">        &lt;param name=&quot;Encoding&quot; value=&quot;UTF-8&quot; /&gt;</span><br><span class="line">        &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt;</span><br><span class="line">            &lt;param name=&quot;ConversionPattern&quot; value=&quot;%-5p %d&#123;MM-dd HH:mm:ss,SSS&#125;</span><br><span class="line">%m  (%F:%L) \n&quot; /&gt;</span><br><span class="line">        &lt;/layout&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line">    &lt;logger name=&quot;java.sql&quot;&gt;</span><br><span class="line">        &lt;level value=&quot;debug&quot; /&gt;</span><br><span class="line">    &lt;/logger&gt;</span><br><span class="line">    &lt;logger name=&quot;org.apache.ibatis&quot;&gt;</span><br><span class="line">        &lt;level value=&quot;info&quot; /&gt;</span><br><span class="line">    &lt;/logger&gt;</span><br><span class="line">    &lt;root&gt;</span><br><span class="line">        &lt;level value=&quot;debug&quot; /&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;STDOUT&quot; /&gt;</span><br><span class="line">    &lt;/root&gt;</span><br><span class="line">&lt;/log4j:configuration&gt;</span><br></pre></td></tr></table></figure></li></ol><p>日志的级别：<br>FATAL(致命)&gt;ERROR(错误)&gt;WARN(警告)&gt;INFO(信息)&gt;DEBUG(调试)<br>从左到右打印的内容越来越详细，即，如果选择DEBUG级别，一定会打印出前面几种级别的信息。</p><h2 id="MyBatis的增删改查"><a href="#MyBatis的增删改查" class="headerlink" title="MyBatis的增删改查"></a>MyBatis的增删改查</h2><p>注意：</p><ol><li>查询的标签select必须设置属性resultType或resultMap，用于设置实体类和数据库表的映射关系<br>resultType：自动映射，用于属性名和表中字段名一致的情况<br>resultMap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况</li><li>当查询的数据为多条时，不能使用实体类作为返回值，只能使用集合，否则会抛出异常TooManyResultsException；但是若查询的数据只有一条，可以使用实体类或集合作为返回值</li></ol><p>增删改的返回值：受影响的行数，类型固定</p><p>查的返回值：查到的结果，根据不同结果用不同的东西接受</p><div class="tabs" id="test2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test2-1">增</button></li><li class="tab"><button type="button" data-href="#test2-2">删</button></li><li class="tab"><button type="button" data-href="#test2-3">改</button></li><li class="tab"><button type="button" data-href="#test2-4">查</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test2-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--int insertUser();--&gt;</span><br><span class="line">&lt;insert id=&quot;insertUser&quot;&gt;</span><br><span class="line">insert into t_user values(null,&#x27;admin&#x27;,&#x27;123456&#x27;,23,&#x27;男&#x27;,&#x27;12345@qq.com&#x27;)</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--int deleteUser();--&gt;</span><br><span class="line">&lt;delete id=&quot;deleteUser&quot;&gt;</span><br><span class="line">    delete from t_user where id = 6</span><br><span class="line">&lt;/delete&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-3"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--int updateUser();--&gt;</span><br><span class="line">&lt;update id=&quot;updateUser&quot;&gt;</span><br><span class="line">    update t_user set username = &#x27;张三&#x27; where id = 5</span><br><span class="line">&lt;/update&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-4"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">查询一个实体类对象</span><br><span class="line">&lt;!--User getUserById();--&gt;  </span><br><span class="line">&lt;select id=&quot;getUserById&quot; resultType=&quot;com.atguigu.mybatis.bean.User&quot;&gt;  </span><br><span class="line">select * from t_user where id = 2  </span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line">查询集合</span><br><span class="line">&lt;!--List&lt;User&gt; getUserList();--&gt;</span><br><span class="line">&lt;select id=&quot;getUserList&quot; resultType=&quot;com.atguigu.mybatis.bean.User&quot;&gt;</span><br><span class="line">select * from t_user</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="核心配置文件"><a href="#核心配置文件" class="headerlink" title="核心配置文件"></a>核心配置文件</h1><blockquote><p>mybatis中有2中配置文件，一个是<strong>核心配置文件</strong>，另一个是<strong>映射文件</strong></p></blockquote><p>核心配置文件没有固定的名字，但是默认都叫<strong>mybatis-config</strong></p><p>核心配置文件中的标签必须按照固定的顺序(有的标签可以不写，但顺序一定不能乱)：</p><ol><li>properties</li><li>settings</li><li>typeAliases</li><li>typeHandlers</li><li>objectFactory</li><li>objectWrapperFactory</li><li>reflectorFactory</li><li>plugins</li><li>environments</li><li>databaseIdProvider</li><li>mappers</li></ol><blockquote><p>没写的不管，写了的一定要按顺序，不然会报错</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;!--    MyBatis核心配置文件，标签的顺序</span><br><span class="line">        properties?,settings?,typeAliases?,typeHandlers?,</span><br><span class="line">        objectFactory?,objectWrapperFactory?,reflectorFactory?,</span><br><span class="line">        plugins?,environments?,databaseIdProvider?,mappers?--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties resource=&quot;jdbc.properties&quot;&gt;&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--    设置类型别名，大小写不敏感。</span><br><span class="line">        如果不设置alias，则默认为类名（大小写不敏感）--&gt;</span><br><span class="line">        </span><br><span class="line">    &lt;typeAliases&gt;</span><br><span class="line">        &lt;!--</span><br><span class="line">            typeAlias: 设置某个类型的别名</span><br><span class="line">            属性：</span><br><span class="line">                type 设置需要设置别名的类型</span><br><span class="line">                alias 设置某个类型的别名，如果不设置该属性，那么该类型拥有默认的类名，且不区分大小写</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;typeAlias type=&quot;com.atguigu.mybatis.pojo.User&quot; alias=&quot;User&quot;&gt;&lt;/typeAlias&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--        以包为单位，将包下所有的类型设置默认的类型别名且不区分大小写--&gt;</span><br><span class="line">        &lt;package name=&quot;com.atguigu.mybatis.pojo&quot;/&gt;</span><br><span class="line">    &lt;/typeAliases&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!--设置连接数据库的环境--&gt; </span><br><span class="line">&lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">    &lt;!--每一个environment都是具体连接数据库的环境--&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">        一个项目中只会用一个环境，default用于使用默认使用的环境：</span><br><span class="line">        id：表示连接数据库的环境的唯一标识 不能重复</span><br><span class="line"></span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">        transactionmanager:设置事务管理方式</span><br><span class="line">        属性：</span><br><span class="line">            type=&quot;JDBC/MANAGED&quot;</span><br><span class="line">            JDBC: 在当前环境中，执行sql时，使用的时jdbc原声的事务管理方式，需要手动的提交和回滚事务</span><br><span class="line">            MANAGED：被管理，例如Spring</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--        dataSource：配置数据源</span><br><span class="line">            属性&quot;</span><br><span class="line">                type：设置数据源的类型</span><br><span class="line">                type=&quot;&quot;</span><br><span class="line">                POOLED:表示使用数据库连接池缓存数据库连接</span><br><span class="line">                UNPOOLED：表示不实用数据库连接池</span><br><span class="line">                JNDI：表示使用上下文中的数据源</span><br><span class="line">--&gt;</span><br><span class="line">        &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">            &lt;!--设置连接数据库的驱动--&gt;</span><br><span class="line">            &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;</span><br><span class="line">            &lt;!--设置连接地址--&gt;</span><br><span class="line">            &lt;property name=&quot;url&quot;</span><br><span class="line">                      value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;</span><br><span class="line">            &lt;!--用户名和密码--&gt;</span><br><span class="line">            &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;</span><br><span class="line">        &lt;/dataSource&gt;</span><br><span class="line">    &lt;/environment&gt;</span><br><span class="line">&lt;/environments&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!--引入映射文件--&gt; </span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">&lt;!--        &lt;mapper resource=&quot;mappers/UserMapper.xml&quot;/&gt;--&gt;</span><br><span class="line">&lt;!--        BindingException: Type interface com.atguigu.mybatis.mapper.UserMapper is not known to the MapperRegistry.</span><br><span class="line">            没有成功建立映射关系</span><br><span class="line">            以包为单位引入映射文件，要求：</span><br><span class="line">                1。 mapper接口所在的包要和映射文件所在的包一致</span><br><span class="line">                2。 mapper接口要和映射文件的名字一致--&gt;</span><br><span class="line">&lt;!--        com.atguigu.mybatis.mapper创建包时要用/分隔，这样才是目录，否则这整一个就只是文件夹名字而已--&gt;</span><br><span class="line">        &lt;package name=&quot;com.atguigu.mybatis.mapper&quot;/&gt;</span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><h2 id="environments"><a href="#environments" class="headerlink" title="environments"></a>environments</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">        &lt;!--</span><br><span class="line">        environment：设置具体的连接数据库的环境信息</span><br><span class="line">        属性：</span><br><span class="line">    id：设置环境的唯一标识，可通过environments标签中的default设置某一个环境的id，表示默认使用的环境</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">            &lt;!--</span><br><span class="line">            transactionManager：设置事务管理方式</span><br><span class="line">            属性：</span><br><span class="line">            type：设置事务管理方式，type=&quot;JDBC|MANAGED&quot;</span><br><span class="line">            type=&quot;JDBC&quot;：设置当前环境的事务管理都必须手动处理</span><br><span class="line">            type=&quot;MANAGED&quot;：设置事务被管理，例如spring中的AOP</span><br><span class="line">            --&gt;</span><br><span class="line">            &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class="line">            &lt;!--</span><br><span class="line">            dataSource：设置数据源</span><br><span class="line">            属性：</span><br><span class="line">            type：设置数据源的类型，type=&quot;POOLED|UNPOOLED|JNDI&quot;</span><br><span class="line">            type=&quot;POOLED&quot;：使用数据库连接池，即会将创建的连接进行缓存，下次使用可以从缓存中直接获取，不需要重新创建</span><br><span class="line">            type=&quot;UNPOOLED&quot;：不使用数据库连接池，即每次使用连接都需要重新创建</span><br><span class="line">            type=&quot;JNDI&quot;：调用上下文中的数据源</span><br><span class="line">            --&gt;</span><br><span class="line">            &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">                &lt;!--设置驱动类的全类名--&gt;</span><br><span class="line">                &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;</span><br><span class="line">                &lt;!--设置连接数据库的连接地址--&gt;</span><br><span class="line">                &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;</span><br><span class="line">                &lt;!--设置连接数据库的用户名--&gt;</span><br><span class="line">                &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;</span><br><span class="line">                &lt;!--设置连接数据库的密码--&gt;</span><br><span class="line">                &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br></pre></td></tr></table></figure><h3 id="environment：设置数据库环境"><a href="#environment：设置数据库环境" class="headerlink" title="environment：设置数据库环境"></a>environment：设置数据库环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  &lt;!--设置连接数据库的环境--&gt; </span><br><span class="line">&lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">  &lt;!--每一个environment都是具体连接数据库的环境--&gt;</span><br><span class="line">  &lt;!--</span><br><span class="line">      一个项目中只会用一个环境，default用于使用默认使用的环境：</span><br><span class="line">      id：表示连接数据库的环境的唯一标识 不能重复</span><br><span class="line">  --&gt;</span><br><span class="line">  &lt;environment id=&quot;development&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="transactionManager：设置事务管理方式"><a href="#transactionManager：设置事务管理方式" class="headerlink" title="transactionManager：设置事务管理方式"></a>transactionManager：设置事务管理方式</h3><p><strong>属性：type&#x3D;”JDBC&#x2F;MANAGED”</strong></p><ul><li>JDBC: 在当前环境中，执行sql时，使用的是jdbc原生的事务管理方式，需要手动的提交和回滚事务</li><li>MANAGED：被管理，例如Spring</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br></pre></td></tr></table></figure><h3 id="properties：动态写入信息"><a href="#properties：动态写入信息" class="headerlink" title="${} + properties：动态写入信息"></a>${} + properties：动态写入信息</h3><p>如果想动态地写数据库驱动的信息，可以新建一个配置文件（jdbc.properties），文件类型为resource bundle。</p><ol><li><p>在jdbc.properties文件中，以字符串形式定义各个属性。<br>每个属性最好以有意义的标识作前缀，如jdbc.xxx。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driver=com.mysql.cj.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql://localhost:3306/test?serverTimezone=UTC&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=</span><br></pre></td></tr></table></figure></li><li><p>在<code>mybatis-config.xml</code>文件中，添加<code>&lt;properties&gt;</code>元素，将资源文件引入配置文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties resource=&quot;jdbc.properties&quot;&gt;&lt;/properties&gt;</span><br></pre></td></tr></table></figure></li><li><p>在dataSource中，使用<code>$&#123;xxx&#125;</code>格式，引入对应的属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--        dataSource：配置数据源</span><br><span class="line">            属性&quot;</span><br><span class="line">                type：设置数据源的类型</span><br><span class="line">                type=&quot;POOLED/UNPOOLED/JNDI&quot;</span><br><span class="line">                POOLED:表示使用数据库连接池缓存数据库连接</span><br><span class="line">                UNPOOLED：表示不实用数据库连接池</span><br><span class="line">                JNDI：表示使用上下文中的数据源</span><br><span class="line">--&gt;</span><br><span class="line">        &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">            &lt;!--设置连接数据库的驱动--&gt;</span><br><span class="line">            &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;</span><br><span class="line">            &lt;!--设置连接地址--&gt;</span><br><span class="line">            &lt;property name=&quot;url&quot;</span><br><span class="line">                      value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;</span><br><span class="line">            &lt;!--用户名和密码--&gt;</span><br><span class="line">            &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;</span><br><span class="line">        &lt;/dataSource&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="typeAlias-x2F-package：设置某个类型的别名"><a href="#typeAlias-x2F-package：设置某个类型的别名" class="headerlink" title="typeAlias&#x2F;package：设置某个类型的别名"></a>typeAlias&#x2F;package：设置某个类型的别名</h3><p><strong>typeAlias属性：</strong></p><ul><li><p>type: 设置需要设置别名的类型</p></li><li><p>alias: 设置某个类型的别名，如果不设置该属性，那么该类型拥有默认的类名，且不区分大小写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;typeAliases&gt;</span><br><span class="line">        &lt;typeAlias type=&quot;com.atguigu.mybatis.pojo.User&quot; alias=&quot;User&quot;&gt;&lt;/typeAlias&gt;</span><br><span class="line">&lt;/typeAliases&gt;</span><br></pre></td></tr></table></figure></li></ul><p>即，使用<code>User</code>作为<code>com.atguigu.mybatis.pojo.User</code>的别名，可以在mapper的配置文件中直接使用User来代表这个类。</p><p>也可以使用<code>&lt;package&gt;</code>来表示，以该包为单位，将包下所有的类型设置默认的类型别名且不区分大小写。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;typeAliases&gt;</span><br><span class="line">&lt;!--        以包为单位，将包下所有的类型设置默认的类型别名且不区分大小写--&gt;</span><br><span class="line">        &lt;package name=&quot;com.atguigu.mybatis.pojo&quot;/&gt;</span><br><span class="line">&lt;/typeAliases&gt;</span><br></pre></td></tr></table></figure><h1 id="mappers：引入映射文件"><a href="#mappers：引入映射文件" class="headerlink" title="mappers：引入映射文件"></a>mappers：引入映射文件</h1><p>以包为单位引入映射文件，要求：</p><ol><li>mapper接口所在的包要和映射文件所在的包一致</li><li>mapper接口要和映射文件的名字一致</li></ol><p>XXXMapper接口：里面存放各种抽象方法</p><p>XXXMapper.Xml：里面存放抽象方法的具体实现SQL语句</p><blockquote><p>com.atguigu.mybatis.mapper创建包时要用&#x2F;分隔（new package时，名称要写成com&#x2F;atguigu&#x2F;mybatis&#x2F;mapper），这样才是目录，否则这整一个就只是文件夹名字而已，就不能正确映射，会报错：BindingException: Type interface com.atguigu.mybatis.mapper.UserMapper is not known to the MapperRegistry。</p></blockquote><p>我就有一次mapper和mappers没区分报错..</p><h1 id="MyBatis获取参数值"><a href="#MyBatis获取参数值" class="headerlink" title="MyBatis获取参数值"></a>MyBatis获取参数值</h1><h2 id="设置配置文件模板"><a href="#设置配置文件模板" class="headerlink" title="设置配置文件模板"></a>设置配置文件模板</h2><h3 id="设置mybatis-config-xml配置文件模版"><a href="#设置mybatis-config-xml配置文件模版" class="headerlink" title="设置mybatis-config.xml配置文件模版"></a>设置mybatis-config.xml配置文件模版</h3><div class="tabs" id="test3"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test3-1">模板内容</button></li><li class="tab"><button type="button" data-href="#test3-2">添加模版步骤</button></li><li class="tab"><button type="button" data-href="#test3-3">创建模版</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test3-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties resource=&quot;jdbc.properties&quot;&gt;&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;typeAliases&gt;</span><br><span class="line">        &lt;package name=&quot;&quot;&gt;&lt;/package&gt;</span><br><span class="line">    &lt;/typeAliases&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--设置连接数据库的环境--&gt;</span><br><span class="line">    &lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">        &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">            &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class="line">            &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">                &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;url&quot;</span><br><span class="line">                          value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br><span class="line">    &lt;!--引入映射文件--&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;package name=&quot;&quot;/&gt;</span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-2"><p><strong><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310171510113.png"></strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-3"><p>完成后就可以直接new一个<code>mybatis-config</code>模版啦。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310171512633.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="设置xxxMapper-xml配置文件模版"><a href="#设置xxxMapper-xml配置文件模版" class="headerlink" title="设置xxxMapper.xml配置文件模版"></a>设置xxxMapper.xml配置文件模版</h3><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">模板内容</button></li><li class="tab"><button type="button" data-href="#test4-2">添加模版步骤</button></li><li class="tab"><button type="button" data-href="#test4-3">创建模版</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><p>过程与config模版相同。图我就用上一张了</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310171510113.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-3"><p>完成后就可以直接new一个模版啦。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310171512633.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="封装SqlSessionUtils-工具类并测试功能"><a href="#封装SqlSessionUtils-工具类并测试功能" class="headerlink" title="封装SqlSessionUtils. 工具类并测试功能"></a>封装SqlSessionUtils. 工具类并测试功能</h2><p>原来的测试里面每一个测试都有共同的加载部分，抽出来，封装成方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testSelectUser() throws IOException &#123;</span><br><span class="line">        //加载核心配置文件</span><br><span class="line">        InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">        //获取sqlsessionfactorybuilder</span><br><span class="line">        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();</span><br><span class="line">        //获取factory</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);</span><br><span class="line">        //获取sqlsession</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession(true);</span><br><span class="line">        //获取mapper接口对象</span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper.class); //代理模式</span><br><span class="line"></span><br><span class="line">        //测试功能</span><br><span class="line">        int result = mapper.updateUser();</span><br><span class="line"></span><br><span class="line">        //提交事务（写的type是JDBC）</span><br><span class="line">//        sqlSession.commit();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;result: &quot; + result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li><p>创建SqlSessionUtils工具类</p><p>具体功能就是加载核心配置文件直到获取sqlsession</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class SqlSessionUtils &#123;</span><br><span class="line">    public static SqlSession getSqlSession() throws IOException &#123;</span><br><span class="line">        InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">        SqlSession sqlSession = null;</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);</span><br><span class="line">        sqlSession = sqlSessionFactory.openSession(true);</span><br><span class="line">        return sqlSession;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取mapper</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void testGetAllUser() throws IOException &#123;</span><br><span class="line">    SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">    ParaMeterMapper mapper = sqlSession.getMapper(ParaMeterMapper.class);</span><br><span class="line">    List&lt;User&gt; list = mapper.getAllUser();</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="MyBatis获取参数值的两种方式（重点）"><a href="#MyBatis获取参数值的两种方式（重点）" class="headerlink" title="MyBatis获取参数值的两种方式（重点）"></a>MyBatis获取参数值的两种方式（重点）</h2><p>这里的参数不一定得是类的属性，是根据get&#x2F;set方法获取的，以后可能遇到没有这个属性却有get&#x2F;set方法的情况</p><h3 id="JDBC原生的获取参数值的方式"><a href="#JDBC原生的获取参数值的方式" class="headerlink" title="JDBC原生的获取参数值的方式"></a>JDBC原生的获取参数值的方式</h3><ul><li>字符串拼接 （Statement ，${}）：需要自己补充 ‘’</li><li>占位符拼接 （PreparedStatement，#{}）：系统提供 ‘’</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testJDBC() throws SQLException, ClassNotFoundException &#123;</span><br><span class="line">    String username = &quot;cherry&quot;;</span><br><span class="line">    Class.forName(&quot;&quot;);</span><br><span class="line">    Connection connection = DriverManager.getConnection(&quot;&quot;, &quot;&quot;, &quot;&quot;);</span><br><span class="line">    // 1. 字符串拼接 -&gt;获得预编译对象 -》sql注入问题</span><br><span class="line">    PreparedStatement preparedStatement = connection.prepareStatement(&quot;select * from t_user where username = &#x27;&quot; + username + &quot;&#x27;&quot;);</span><br><span class="line"></span><br><span class="line">    // 2. 占位符</span><br><span class="line">    PreparedStatement ps2 = connection.prepareStatement(&quot;select * from t_user where username = ?&quot;);</span><br><span class="line">    ps2.setString(1, username);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="MyBatis获取参数值的两种方式：-和"><a href="#MyBatis获取参数值的两种方式：-和" class="headerlink" title="MyBatis获取参数值的两种方式：${}和#{}"></a>MyBatis获取参数值的两种方式：${}和#{}</h3><ol><li><p>${}的本质就是字符串拼接</p><p>${}使用字符串拼接的方式拼接sql，若为字符串类型或日期类型的字段进行赋值时，需要手动加单引号，不推荐，但是有必须用的时候</p></li><li><p>#{}的本质就是占位符赋值</p><p>#{}使用占位符赋值的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时，可以自动添加单引号</p></li></ol><h2 id="MyBatis获取参数值的五种情况"><a href="#MyBatis获取参数值的五种情况" class="headerlink" title="MyBatis获取参数值的五种情况"></a>MyBatis获取参数值的五种情况</h2><p>以后取参数只有2种方法</p><ol><li>实体类对像</li><li>用Param取别名</li></ol><h3 id="情况1-单个字面量类型的参数"><a href="#情况1-单个字面量类型的参数" class="headerlink" title="情况1: 单个字面量类型的参数"></a>情况1: 单个字面量类型的参数</h3><p>若mapper接口中的方法参数为单个的字面量类型<br>此时可以使用 ${} 和 #{} 以任意的名称获取参数的值，注意 ${} 需要手动加单引号</p><p>ParameterMapper接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface ParameterMapper &#123;</span><br><span class="line">    /**</span><br><span class="line">      单个的字面量类型:</span><br><span class="line">      根据用户名查询用户信息</span><br><span class="line">    */</span><br><span class="line">         User getUserByUserName(String username);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>对应在ParameterMapper.xml中配置。</p><p>方式一：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--    User getUserByUserName(String username);--&gt;</span><br><span class="line">&lt;!--    使用#&#123;&#125;，里面内容可以随便写，都是传进来的username的值--&gt;</span><br><span class="line">    &lt;select id=&quot;getUserByUserName&quot; resultType=&quot;User&quot;&gt;</span><br><span class="line">       select * from t_user where username = #&#123;username&#125;</span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure><p>方式二：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--    User getUserByUserName(String username);--&gt;</span><br><span class="line">    &lt;select id=&quot;getUserByUserName&quot; resultType=&quot;User&quot;&gt;</span><br><span class="line">        &lt;!-- </span><br><span class="line">       select * from t_user where username = $&#123;username&#125;</span><br><span class="line">          如果使用这种方式，得到的sql语句是：</span><br><span class="line">          Preparing: select * from t_user where username = RUOYI</span><br><span class="line">          而其中username的值‘RUOYI’没有单引号，语句不正确，会报错。</span><br><span class="line">          因此要手动添加单引号</span><br><span class="line">       --&gt;</span><br><span class="line">        select * from t_user where username = &#x27;$&#123;username&#125;&#x27;</span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure><p>测试类：</p><pre><code>/** * MyBatis获取参数值的各种情况： * 情况1： mapper接口方法的参数为单个字面量的参数 * 可以通过$&#123;&#125; #&#123;&#125;以任意的字符串获得参数值，但需要注意$&#123;&#125;的单引号问题 */@Testpublic void testgetUserByUserName()&#123;    SqlSession sqlSession = SqlSessionUtils.getSqlSession();    ParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class);    User user = mapper.getUserByUserName(&quot;RUOYI&quot;);    System.out.println(user);&#125;</code></pre><h3 id="情况2：多个字面量类型的参数"><a href="#情况2：多个字面量类型的参数" class="headerlink" title="情况2：多个字面量类型的参数"></a>情况2：多个字面量类型的参数</h3><p>若mapper接口中的方法参数为多个时,此时MyBatis会自动将这些参数放在一个map集合中。</p><ul><li><p>以[arg0，arg1…]，以参数为值;</p></li><li><p>以[param1，param2…]，以参数为值;</p></li></ul><blockquote><p>注意2个集合的开始序列，另外这俩不同名字的东西其实可以混用</p></blockquote><p>因此只需要通过 ${} 和 #{} 访问 map 集合就可以获取相对应的值，<strong>注意 ${} 需要手动加单引号</strong></p><p>ParameterMapper接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface ParaMeterMapper &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 验证登录</span><br><span class="line">     */</span><br><span class="line">    User checkLogin(String username, String password);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对应在ParameterMapper.xml中配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--    User checkLogin(String username, String password);--&gt;</span><br><span class="line">    &lt;select id=&quot;checkLogin&quot; resultType=&quot;User&quot;&gt;</span><br><span class="line">        &lt;!--</span><br><span class="line">        写：select * from t_user where username = #&#123;username&#125; and password = #&#123;password&#125;</span><br><span class="line">        会报错：Parameter &#x27;username&#x27; not found. Available parameters are [arg1, arg0, param1, param2]</span><br><span class="line">        因为sql语句没有解析成功--&gt;</span><br><span class="line">            &lt;!--以map集合形式存储，arg0-&gt;param1, arg1-&gt;param2，这时直接用键arg访问就好了，用param访问也行。</span><br><span class="line"></span><br><span class="line">以下两种方式选一个：--&gt;</span><br><span class="line">    select * from t_user where username = #&#123;arg0&#125; and password = #&#123;arg1&#125;</span><br><span class="line">    select * from t_user where username = &#x27;#&#123;param1&#125;&#x27; and password = &#x27;#&#123;param2&#125;&#x27;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>测试类：</p><pre><code>/** * 情况2：mapper接口方法的参数为多个时 * 此时MyBatis会将这些参数放在一个map集合中，以两种方式进行存储 * a》以arg0，arg1。。为键，参数为值 * b》以param0，param1。。为键，参数位置 * 因此只需要通过#&#123;&#125;和$&#123;&#125;以键的方式访问值即可，但需要注意$&#123;&#125;的单引号问题 */@Testpublic void testCheckLogin()&#123;    SqlSession sqlSession = SqlSessionUtils.getSqlSession();    ParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class);    User user = mapper.checkLogin(&quot;RUOYI&quot;,&quot;123456&quot;);    System.out.println(user);&#125;</code></pre><h3 id="情况3：map集合类型的参数"><a href="#情况3：map集合类型的参数" class="headerlink" title="情况3：map集合类型的参数"></a>情况3：map集合类型的参数</h3><p>若mapper接口中的方法需要的参数为多个时，此时可以<strong>手动创建map集合</strong>，将这些数据放在map中，只需要通过<code>$&#123;&#125;和#&#123;&#125;</code>访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号</p><blockquote><p>这次由我们创建 map 集合，map叫什么由我们来决定了</p></blockquote><p>ParameterMapper接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface ParameterMapper &#123;</span><br><span class="line">/**</span><br><span class="line">     * 验证登录</span><br><span class="line">     */</span><br><span class="line">    User checkLoginByMap(Map&lt;String, Object&gt; map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应在ParameterMapper.xml中配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--    User checkLoginByMap(Map&lt;String, Object&gt; map);--&gt;</span><br><span class="line">    &lt;select id=&quot;checkLoginByMap&quot; resultType=&quot;User&quot;&gt;</span><br><span class="line">        select * from t_user where username = #&#123;username&#125; and password = #&#123;password&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 情况3：若mapper接口方法的参数有多个时，可以手动将这些参数放在一个map中存储</span><br><span class="line"> * 只需要通过#&#123;&#125; $&#123;&#125;以键的方式访问值即可，但是需要注意$&#123;&#125;的单引号问题</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void testCheckLoginByMap()&#123;</span><br><span class="line">    SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">    ParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class);</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    map.put(&quot;username&quot;,&quot;RUOYI&quot;);</span><br><span class="line">    map.put(&quot;password&quot;,&quot;123456&quot;);</span><br><span class="line"></span><br><span class="line">    User user = mapper.checkLoginByMap(map);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="情况4-mapper接口方法的参数是实体类类型的参数"><a href="#情况4-mapper接口方法的参数是实体类类型的参数" class="headerlink" title="情况4:mapper接口方法的参数是实体类类型的参数"></a>情况4:mapper接口方法的参数是实体类类型的参数</h3><p>直接用类的对象来接受</p><p>ParameterMapper接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface ParameterMapper &#123;</span><br><span class="line">    /**</span><br><span class="line">    *</span><br><span class="line">    * 添加用户信息</span><br><span class="line">     /</span><br><span class="line">         int insertUser(User user);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>对应在ParameterMapper.xml中配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--        int insertUser(User user);--&gt;</span><br><span class="line">&lt;!--    找到相对应的get方法，如username-&gt;找getUsername()，看get/set方法--&gt;</span><br><span class="line">    &lt;insert id=&quot;insertUser&quot;&gt;</span><br><span class="line">        insert into t_user values(null, #&#123;username&#125;, #&#123;password&#125;, #&#123;age&#125;, #&#123;gender&#125;, #&#123;email&#125;)</span><br><span class="line">    &lt;/insert&gt;</span><br></pre></td></tr></table></figure><p>测试类：</p><pre><code>/** * 情况4：mapper接口方法的参数是实体类类型的参数（web从control层传过来的） * 只需要通过#&#123;&#125; $&#123;&#125;以属性的方式访问属性值即可，但是需要注意$&#123;&#125;的单引号问题 */@Testpublic void testInsertUser()&#123;    SqlSession sqlSession = SqlSessionUtils.getSqlSession();    ParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class);    User user = new User(null, &quot;Pandora&quot;, &quot;4444&quot;, 66, &quot;m&quot;, &quot;1111@gmail.com&quot;);    mapper.insertUser(user);&#125;</code></pre><h3 id="情况5-使用-Param标识参数"><a href="#情况5-使用-Param标识参数" class="headerlink" title="情况5: 使用@Param标识参数"></a>情况5: 使用@Param标识参数</h3><p>可以通过@Param注解标识mapper接口中的方法参数，此时，会将这些参数放在map集合中</p><ol><li>以@Param注解的 value 属性值为键，以参数为值；</li><li>以 param1，param2 … 为键，以参数为值</li></ol><p>只需要通过${}和#{}访问map集合的键就可以获取相对应的值， <strong>注意${}需要手动加单引号</strong><br>ParameterMapper接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface ParameterMapper &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 验证登录 （使用@Param）</span><br><span class="line">     */</span><br><span class="line">    User checkLoginByParam(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应在ParameterMapper.xml中配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--    以@Param的值为键，参数为值; 或以&quot;param1&quot;/&quot;param2&quot;为键，参数为值--&gt;</span><br><span class="line">&lt;!--    User checkLoginByParam(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password);--&gt;</span><br><span class="line">    &lt;select id=&quot;checkLoginByParam&quot; resultType=&quot;User&quot;&gt;</span><br><span class="line">        select * from t_user where username = #&#123;username&#125; and password = #&#123;password&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 情况5：使用@Param注解来命名参数</span><br><span class="line"> * 此时MyBatis会将这些参数放在一个map集合中，以两种方式进行存储</span><br><span class="line"> * a》以@Param的值为键，参数为值; @Param(value = &quot;xxx&quot;)</span><br><span class="line"> * b》以param0，param1...为键，参数为值</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void testCheckLoginByParam()&#123;</span><br><span class="line">    SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">    ParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class);</span><br><span class="line">    User user = mapper.checkLoginByParam(&quot;RUOYI&quot;,&quot;123456&quot;);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Param源码分析"><a href="#Param源码分析" class="headerlink" title="@Param源码分析"></a>@Param源码分析</h3><h1 id="MyBatis的各种查询功能"><a href="#MyBatis的各种查询功能" class="headerlink" title="MyBatis的各种查询功能"></a>MyBatis的各种查询功能</h1><p>MyBatis的各种查询功能: </p><ul><li><p>若查询出的数据只有一条，可以通过</p><ol><li>实体类对象接收</li><li>List集合接收</li><li>Map集合接收，结果<code>&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;</code></li></ol></li><li><p>若查询出的数据有多条，一定不能通过实体类对象接收，此时会抛异常TooManyResul tsException。</p><ol><li><p>实体类类型的LIst集合接收</p></li><li><p>Map类型的LIst集合接收</p></li><li><p>在mapper接口的方法上添加@MapKey注解</p><blockquote><p>@MapKey：声明Map，把原有的Map记录作为一个键，用来封装多条数据</p></blockquote></li></ol></li></ul><p><strong>接口类综合代码：</strong></p><p>public interface SelectMapper {<br>    &#x2F;**<br>     * 根据id查询用户信息<br>          *&#x2F;<br>        User getUserById(@Param(“id”) Integer id);</p><pre><code>/** * 查询所有用户信息 */List&lt;User&gt; getAllUser();/** * 查询用户信息的总记录数 */Integer getCount();/** * 根据id查询用户信息为一个map集合 */Map&lt;String, Object&gt; getUserByIdToMap(Integer id);/** * 查询所有用户信息为map集合 *///  List&lt;Map&lt;String, Object&gt;&gt; getAllUserToMap();    @MapKey(&quot;id&quot;)    Map&lt;String, Object&gt; getAllUserToMap();&#125; </code></pre><div class="tabs" id="test5"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test5-1">查询一个实体类对象</button></li><li class="tab"><button type="button" data-href="#test5-2">查询一个list集合</button></li><li class="tab"><button type="button" data-href="#test5-3">查询单个数据</button></li><li class="tab"><button type="button" data-href="#test5-4">查询一条数据为map集合</button></li><li class="tab"><button type="button" data-href="#test5-5">查询多条数据为map集合</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test5-1"><p>SelectMapper接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface SelectMapper &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 根据id查询用户信息</span><br><span class="line">     */</span><br><span class="line">    User getUserById(@Param(&quot;id&quot;) Integer id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--    User getUserById(@Param(&quot;id&quot;) Integer id);--&gt;</span><br><span class="line">    &lt;select id=&quot;getUserById&quot; resultType=&quot;User&quot;&gt;</span><br><span class="line">        select * from t_user where id = #&#123;id&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * MyBatis的各种查询功能：</span><br><span class="line"> * 1。 若查询出的数据只有一条，可以通过实体类对象 / list集合 / map集合 来接收</span><br><span class="line"> * 2。 若查询处的数据有多条，一定不能通过实体类对象来接收，此时会抛出TooManyResultsException</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void testGetUserById()&#123;</span><br><span class="line">    SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">    SelectMapper mapper = sqlSession.getMapper(SelectMapper.class);</span><br><span class="line">    User userById = mapper.getUserById(4);</span><br><span class="line">    System.out.println(userById);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test5-2"><p>SelectMapper接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SelectMapper</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有用户信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">getAllUser</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    List&lt;User&gt; getAllUser();--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        select * from t_user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试类：</p><pre><code>/** * MyBatis的各种查询功能： * 1。 若查询出的数据只有一条，可以通过实体类对象 / list集合 / map集合 来接收 * 2。 若查询处的数据有多条，一定不能通过实体类对象来接收，此时会抛出TooManyResultsException */@Testpublic void testGetUserById(){    SqlSession sqlSession = SqlSessionUtils.getSqlSession();    SelectMapper mapper = sqlSession.getMapper(SelectMapper.class);    List&lt;User&gt; allUser = mapper.getAllUser();    allUser.forEach(user -&gt; System.out.println(user));}</code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test5-3"><p>SelectMapper接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SelectMapper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询用户信息的总记录数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Integer <span class="title function_">getCount</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--    Integer getCount();--&gt;</span><br><span class="line">&lt;!--    integer写大小写都可以，写 Integer/integer/_int/_integer  都可以，都是java.lang.Integer的别名--&gt;</span><br><span class="line">    &lt;select id=&quot;getCount&quot; resultType=&quot;java.lang.Integer&quot;&gt;</span><br><span class="line">        select count(*) from t_user</span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure><p>测试类：</p><pre><code>/** * 获取记录数 * * MyBatis中设置了默认的类型别名 * Java.lang.Integer -&gt; int, integer * int -&gt; _int, _integer * Map -&gt; map * List -&gt; list */@Testpublic void testGetCount(){    SqlSession sqlSession = SqlSessionUtils.getSqlSession();    SelectMapper mapper = sqlSession.getMapper(SelectMapper.class);    System.out.println(mapper.getCount());}</code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test5-4"><p>SelectMapper接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface SelectMapper &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 根据id查询用户信息为一个map集合</span><br><span class="line">     */</span><br><span class="line">    Map&lt;String, Object&gt; getUserByIdToMap(Integer id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--        Map&lt;String, Object&gt; getUserByIdToMap(Integer id);--&gt;</span><br><span class="line">&lt;select id=&quot;getUserByIdToMap&quot; resultType=&quot;map&quot;&gt;</span><br><span class="line">    select * from t_user where id = #&#123;id&#125;</span><br><span class="line">&lt;/select&gt;  </span><br></pre></td></tr></table></figure><p>测试类：</p><pre><code>/** * 如果没有实体类对象，就把它映射成map集合 * 从数据库中查询数据，将其映射为map集合 * 例如把它传到网页端，就映射成json对象，所以转成map很常用 * * 以字段为键 */@Testpublic void testgetUserByIdToMap(){    SqlSession sqlSession = SqlSessionUtils.getSqlSession();    SelectMapper mapper = sqlSession.getMapper(SelectMapper.class);    System.out.println(mapper.getUserByIdToMap(4));}</code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test5-5"><p>SelectMapper接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface SelectMapper &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 查询所有用户信息为map集合，每一条记录是一个map</span><br><span class="line">     */</span><br><span class="line">     //方式一：</span><br><span class="line">//    List&lt;Map&lt;String, Object&gt;&gt; getAllUserToMap();</span><br><span class="line"></span><br><span class="line">//方式二：</span><br><span class="line">    @MapKey(&quot;id&quot;)</span><br><span class="line">    Map&lt;String, Object&gt; getAllUserToMap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--        Map&lt;String, Object&gt; getAllUserToMap();--&gt;</span><br><span class="line">    &lt;select id=&quot;getAllUserToMap&quot; resultType=&quot;map&quot;&gt;</span><br><span class="line">        select * from t_user</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testgetAllUser()&#123;</span><br><span class="line">    SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">    SelectMapper mapper = sqlSession.getMapper(SelectMapper.class);</span><br><span class="line">    System.out.println(mapper.getAllUserToMap());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="常用类型别名"><a href="#常用类型别名" class="headerlink" title="常用类型别名"></a>常用类型别名</h2><p>别名不区分大小写</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310191546383.png"></p><h1 id="自定义映射resultMap"><a href="#自定义映射resultMap" class="headerlink" title="自定义映射resultMap"></a>自定义映射resultMap</h1><p>默认映射：名字一样就映射上</p><h2 id="字段和属性的映射关系"><a href="#字段和属性的映射关系" class="headerlink" title="字段和属性的映射关系"></a>字段和属性的映射关系</h2><p>字段名和实体类中的属性名可能不一致，二者命名规则不同</p><ol><li>字段名符合数据库的规则(使用_)</li><li>实体类中的属性名符合Java的规则(使用驼峰)</li></ol><blockquote><p>此时大概率不会报错，但是找不到的添null，找得到的添加匹配值</p></blockquote><p>有三中解决方式：</p><ol><li><p>可以通过为字段起别名的方式（sql 起别名），保证和实体类中的属性名保持一致</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;getAllEmp&quot; resultType=&quot;Emp&quot;&gt;</span><br><span class="line">        select eid, emp_name empName, age, sex, email from t_emp</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>可以在MyBatis的<strong>核心配置文件</strong>中设置一个全局配置信息mapUnderscoreToCamelCase，可 以在查询表中数据时，自动将 _ 类型的字段名转换为驼峰，日志输出的时候也会转换</p><p>注意核心配置文件中的顺序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--    设置MyBatis的全剧配置--&gt;</span><br><span class="line">    &lt;settings&gt;</span><br><span class="line">&lt;!--        将下划线自动映射成驼峰，比如emp_name -&gt; empName --&gt;</span><br><span class="line">        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;/settings&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>例.字段名user_name，设置了mapUnderscoreToCamelCase，此时字段名就会转换为 userName</p></blockquote></li><li><p>逐一设置resultMap映射关系</p><p>在resultMap中，一一对应地设置属性名 字段名，再在 select标签中添加 resultMap&#x3D;”对应resultMap的id”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">        resultMap设置自定义映射关系</span><br><span class="line">        id      唯一标识</span><br><span class="line">        type    映射的实体类型</span><br><span class="line"></span><br><span class="line">        子标签：id 设置主键的映射关系， result设置其他的映射关系</span><br><span class="line">            property    设置映射关系中的属性名，必须是type属性所设置的实体类类型的属性名</span><br><span class="line">            column      设置映射关系中的字段名，必须是sql语句查询出来的字段名</span><br><span class="line"></span><br><span class="line">        如果使用resultMap，就所有属性都需要设置</span><br><span class="line">--&gt;</span><br><span class="line">    &lt;resultMap id=&quot;empResultMap&quot; type=&quot;Emp&quot;&gt;</span><br><span class="line">        &lt;id property=&quot;eid&quot; column=&quot;eid&quot;&gt;&lt;/id&gt;</span><br><span class="line">        &lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=&quot;age&quot; column=&quot;age&quot;&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=&quot;email&quot; column=&quot;email&quot;&gt;&lt;/result&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=&quot;getAllEmp&quot; resultMap=&quot;empResultMap&quot;&gt;</span><br><span class="line">        select * from t_emp</span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="多对一的映射"><a href="#多对一的映射" class="headerlink" title="多对一的映射"></a>多对一的映射</h2><p>需要查询一对多、多对一的关系，需要在“一”的pojo中加入List&lt;多&gt;属性，在“多”的pojo中加入“一”。<br>也就是说，在Dept类中，要加入private List&lt; Emp &gt; emps；在Emp类中，要加入private Dept dept;。然后给他们各自添加get、set方法，重写构造器和toString()</p><ol><li><p>级联方式处理映射关系</p><p>EmpMapper.xml中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--    多对一映射关系，方式一：级联属性赋值--&gt;</span><br><span class="line">    &lt;resultMap id=&quot;getEmpAndDeptResultMapOne&quot; type=&quot;Emp&quot;&gt;</span><br><span class="line">        &lt;id property=&quot;eid&quot; column=&quot;eid&quot;&gt;&lt;/id&gt;</span><br><span class="line">        &lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=&quot;age&quot; column=&quot;age&quot;&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=&quot;email&quot; column=&quot;email&quot;&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=&quot;dept.did&quot; column=&quot;did&quot;&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=&quot;dept.deptName&quot; column=&quot;dept_name&quot;&gt;&lt;/result&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--        Emp getEmpAndDept(@Param(&quot;eid&quot;) Integer eid);--&gt;</span><br><span class="line">    &lt;select id=&quot;getEmpAndDept&quot; resultMap=&quot;getEmpAndDeptResultMapOne&quot;&gt;</span><br><span class="line">        select * from t_emp left join t_dept</span><br><span class="line">            on t_emp.eid = t_dept.did WHERE t_emp.eid = #&#123;eid&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>EmpMapper类中:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface EmpMapper &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 查询员工及其所对应的部门信息</span><br><span class="line">     */</span><br><span class="line">    Emp getEmpAndDept(@Param(&quot;eid&quot;) Integer eid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 处理多对一的映射关系</span><br><span class="line"> * a&gt; 级联属性赋值</span><br><span class="line"> * b&gt; association</span><br><span class="line"> * c&gt; 分步查询</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void testGetEmpAndDept()&#123;</span><br><span class="line">    SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">    EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);</span><br><span class="line">    Emp empAndDept = mapper.getEmpAndDept(3);</span><br><span class="line">    System.out.println(empAndDept);</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure></li><li><p>使用association处理映射关系</p><p>EmpMapper.xml:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap id=&quot;empDeptMap&quot; type=&quot;Emp&quot;&gt;</span><br><span class="line">    &lt;id column=&quot;eid&quot; property=&quot;eid&quot;&gt;&lt;/id&gt;</span><br><span class="line">    &lt;result column=&quot;ename&quot; property=&quot;ename&quot;&gt;&lt;/result&gt;</span><br><span class="line">    &lt;result column=&quot;age&quot; property=&quot;age&quot;&gt;&lt;/result&gt;</span><br><span class="line">    &lt;result column=&quot;sex&quot; property=&quot;sex&quot;&gt;&lt;/result&gt;</span><br><span class="line">    &lt;association property=&quot;dept&quot; javaType=&quot;Dept&quot;&gt;</span><br><span class="line">        &lt;id column=&quot;did&quot; property=&quot;did&quot;&gt;&lt;/id&gt;</span><br><span class="line">        &lt;result column=&quot;dname&quot; property=&quot;dname&quot;&gt;&lt;/result&gt;</span><br><span class="line">    &lt;/association&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line">&lt;!--Emp getEmpAndDeptByEid(@Param(&quot;eid&quot;) int eid);--&gt;</span><br><span class="line">&lt;select id=&quot;getEmpAndDeptByEid&quot; resultMap=&quot;empDeptMap&quot;&gt;</span><br><span class="line">    select emp.*,dept.* from t_emp emp left join t_dept dept on emp.did =</span><br><span class="line">dept.did where emp.eid = #&#123;eid&#125;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>分步查询</p><p>查询员工信息</p><p>EmpMapper类中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface EmpMapper &#123;</span><br><span class="line">/**</span><br><span class="line">* 通过分步查询查询员工信息 * @param eid</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">Emp getEmpByStep(@Param(&quot;eid&quot;) int eid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>EmpMapper.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--    com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo是这条sql语句的全类名--&gt;</span><br><span class="line">    &lt;resultMap id=&quot;getEmpAndDeptByStepResultMap&quot; type=&quot;Emp&quot;&gt;</span><br><span class="line">        &lt;id property=&quot;eid&quot; column=&quot;eid&quot;&gt;&lt;/id&gt;</span><br><span class="line">        &lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=&quot;age&quot; column=&quot;age&quot;&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=&quot;email&quot; column=&quot;email&quot;&gt;&lt;/result&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">        select: 设置分步查询的sql的唯一标识（namespace.SQLId或mapper接口的全类名.方法名）</span><br><span class="line">        column：分步查询的条件</span><br><span class="line">        fetchType: 当开启了全局的延迟记载后，可通过此属性手动控制延迟加载的效果</span><br><span class="line">        fetchType：&quot;lazy/eager&quot; lazy表示延迟加载，eager表示立即加载</span><br><span class="line">--&gt;</span><br><span class="line">        &lt;association property=&quot;dept&quot;</span><br><span class="line">                     select=&quot;com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo&quot;</span><br><span class="line">                     column=&quot;did&quot;</span><br><span class="line">                     fetchType=&quot;eager&quot;&gt;</span><br><span class="line">        &lt;/association&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line">    </span><br><span class="line">&lt;!--    Emp getEmpAndDeptByStepOne(@Param(&quot;eid&quot;) Integer eid);--&gt;</span><br><span class="line">    &lt;select id=&quot;getEmpAndDeptByStepOne&quot; resultMap=&quot;getEmpAndDeptByStepResultMap&quot;&gt;</span><br><span class="line">        select * from t_emp where eid = #&#123;eid&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 根据员工所对应的部门id查询部门信息</p><p>DeptMapper接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface DeptMapper &#123;</span><br><span class="line">/**</span><br><span class="line">* 分步查询的第二步:根据员工所对应的did查询部门信息</span><br><span class="line">*/</span><br><span class="line">Dept getEmpDeptByStep(@Param(&quot;did&quot;) int did);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>DeptMapper.xml:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--        Dept getEmpAndDeptByStepTwo(Integer did);--&gt;</span><br><span class="line">&lt;!--    分步查询可以实现懒加载--&gt;</span><br><span class="line">    &lt;select id=&quot;getEmpAndDeptByStepTwo&quot; resultType=&quot;Dept&quot;&gt;</span><br><span class="line">        select * from t_dept where did = #&#123;did&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h3><p>分步查询的优点:可以实现延迟加载，但是必须在核心配置文件中设置全局配置信息:</p><p>lazyLoadingEnabled：延迟加载的全局开关。当开启时，所有关联对象都会延迟加载<br>aggressiveLazyLoading:当开启时，任何方法的调用都会加载该对象的所有属性。 否则，每个属性会按需加载。此时就可以实现按需加载，获取的数据是什么，就只会执行相应的sql。此时可通过association和 collection中的fetchType属性设置当前的分步查询是否使用延迟加载，fetchType&#x3D;“lazy(延迟加 载)|eager(立即加载)”</p><h2 id="一对多的映射"><a href="#一对多的映射" class="headerlink" title="一对多的映射"></a>一对多的映射</h2><p> 需要查询一对多、多对一的关系，需要在“一”的pojo中加入List&lt;多&gt;属性，在“多”的pojo中加入“一”。</p><p>也就是说，在Dept类中，要加入<code>private List&lt;Emp&gt; emps;</code>；在Emp类中，要加入<code>private Dept dept;</code>。然后给他们各自添加get、set方法，重写构造器和toString()</p><h3 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h3><p>DeptMapper接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DeptMapper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取部门以及部门中所有的员工信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Dept <span class="title function_">getDeptAndEmp</span><span class="params">(<span class="meta">@Param(&quot;did&quot;)</span> Integer did)</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>DeptMapper.xml</p><pre><code>    &lt;resultMap id=&quot;deptAndEmpResultMap&quot; type=&quot;Dept&quot;&gt;        &lt;id property=&quot;did&quot; column=&quot;did&quot;&gt;&lt;/id&gt;        &lt;result property=&quot;deptName&quot; column=&quot;dept_name&quot;&gt;&lt;/result&gt;&lt;!--            collection：处理一对多的映射关系            ofType：表示该属性对应的集合中存储数据的类型--&gt;        &lt;collection property=&quot;emps&quot; ofType=&quot;Emp&quot;&gt;            &lt;id property=&quot;eid&quot; column=&quot;eid&quot;&gt;&lt;/id&gt;            &lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;&gt;&lt;/result&gt;            &lt;result property=&quot;age&quot; column=&quot;age&quot;&gt;&lt;/result&gt;            &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt;            &lt;result property=&quot;email&quot; column=&quot;email&quot;&gt;&lt;/result&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;&lt;!--        Dept getDeptAndEmp(@Param(&quot;did&quot;) Integer did);--&gt;    &lt;select id=&quot;getDeptAndEmp&quot; resultMap=&quot;deptAndEmpResultMap&quot;&gt;        select * from t_dept left join t_emp on t_dept.did = t_emp.did where t_dept.did = #&#123;did&#125;    &lt;/select&gt;</code></pre><p>测试类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testGetDeptAndEmp()&#123;</span><br><span class="line">        SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">        DeptMapper mapper = sqlSession.getMapper(DeptMapper.class);</span><br><span class="line">        Dept dept = mapper.getDeptAndEmp(1);</span><br><span class="line">        System.out.println(dept);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="分步查询"><a href="#分步查询" class="headerlink" title="分步查询"></a>分步查询</h3><ol><li><p>查询部门信息</p><p>DeptMapper接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface DeptMapper &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 分步查询 查询部门及其所有的员工信息</span><br><span class="line">     * 第一步  查询部门信息</span><br><span class="line">     */</span><br><span class="line">    Dept getDeptAndEmoByStepOne(@Param(&quot;did&quot;) Integer did);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>DeptMapper.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--    分步查询--&gt;</span><br><span class="line">    &lt;resultMap id=&quot;deptAndEmoByStepOneMap&quot; type=&quot;Dept&quot;&gt;</span><br><span class="line">        &lt;id property=&quot;did&quot; column=&quot;did&quot;&gt;&lt;/id&gt;</span><br><span class="line">        &lt;result property=&quot;deptName&quot; column=&quot;dept_name&quot;&gt;&lt;/result&gt;</span><br><span class="line">        &lt;collection property=&quot;emps&quot;</span><br><span class="line">                    select=&quot;com.atguigu.mybatis.mapper.EmpMapper.getDeptAndEmpByStepTwo&quot;</span><br><span class="line">                    column=&quot;did&quot;&gt;</span><br><span class="line">        &lt;/collection&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line">&lt;!--        Dept getDeptAndEmoByStepOne(@Param(&quot;did&quot;) Integer did);--&gt;</span><br><span class="line">    &lt;select id=&quot;getDeptAndEmoByStepOne&quot; resultMap=&quot;deptAndEmoByStepOneMap&quot;&gt;</span><br><span class="line">        select * from t_dept where did = #&#123;did&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>根据部门id查询部门中的所有员工</p><p>EmpMapper</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface EmpMapper &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 分步查询 查询部门及其所有的员工信息</span><br><span class="line">     * 第一步  查询部门信息</span><br><span class="line">     * 第二步  根据查询员工信息</span><br><span class="line">     */</span><br><span class="line">    List&lt;Emp&gt; getDeptAndEmpByStepTwo(@Param(&quot;did&quot;) Integer did);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>EmpMapper.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--    分步查询--&gt;</span><br><span class="line">&lt;!--    List&lt;Emp&gt; getDeptAndEmpByStepTwo(@Param(&quot;did&quot;) Integer did);--&gt;</span><br><span class="line">    &lt;select id=&quot;getDeptAndEmpByStepTwo&quot; resultType=&quot;Emp&quot;&gt;</span><br><span class="line">        select * from t_emp where did = #&#123;did&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>测试类</p></li></ol>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testGetDeptAndEmpBySteps()&#123;</span><br><span class="line">    SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">    DeptMapper mapper = sqlSession.getMapper(DeptMapper.class);</span><br><span class="line">    Dept dept = mapper.getDeptAndEmoByStepOne(2);</span><br><span class="line">    System.out.println(dept.getDeptName());</span><br><span class="line">    System.out.println(&quot;-----****************======分割线=======-----****************&quot;);</span><br><span class="line">    System.out.println(dept);</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure><h1 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h1><p>动态SQL技术是一种根据特定条件动态拼装SQL语句的功能，它存在的意义是为了<strong>解决拼接SQL语句字符串时的痛点问题。</strong></p><p>如：第一个属性为空，但是后面有值，就会在where 后面直接跟着一个 and，sql语句会报错</p><h2 id="if标签"><a href="#if标签" class="headerlink" title="if标签"></a>if标签</h2><p>if标签可通过test属性的表达式进行判断，若表达式的结果为true，则标签中的内容会执行；反之标签中的内容不会执行</p><p>DynamicSqlMapper接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface DynamicSQLMapper &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 多条件查询</span><br><span class="line">     */</span><br><span class="line">    List&lt;Emp&gt; getEmpByCondition(Emp emp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>DynamicSqlMapper.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--        List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;</span><br><span class="line">&lt;!--    加上1=1使得：即使emp_name为空，也不会导致sql语句变成：where and xxx--&gt;</span><br><span class="line">    &lt;select id=&quot;getEmpByCondition&quot; resultType=&quot;Emp&quot;&gt;</span><br><span class="line">        select * from t_emp where 1=1</span><br><span class="line">        &lt;if test=&quot;empName != null and empName != &#x27;&#x27;&quot;&gt;</span><br><span class="line">            and emp_name = #&#123;empName&#125;</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">        &lt;if test=&quot;age != null and age != &#x27;&#x27;&quot;&gt;</span><br><span class="line">            and age = #&#123;age&#125;</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">        &lt;if test=&quot;email != null and email != &#x27;&#x27;&quot;&gt;</span><br><span class="line">            and email = #&#123;email&#125;</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">        &lt;if test=&quot;sex != null and sex != &#x27;&#x27;&quot;&gt;</span><br><span class="line">            and sex = #&#123;sex&#125;</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 动态sql</span><br><span class="line"> * 1： if： 根据标签中test属性所对应的内容决定标签中的内容是否拼接在sql语句中</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void testGetEmpByCondition()&#123;</span><br><span class="line">    SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">    DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);</span><br><span class="line">    // 各信息都不为null/空字符串</span><br><span class="line">    List&lt;Emp&gt; emp1 = mapper.getEmpByCondition(new Emp(null, &quot;Apple&quot;, 22, &quot;女&quot;, &quot;123@gmail.com&quot;));</span><br><span class="line">    // 中间存在查询出来是空，可能导致&quot;select * from t_emp where emp_name= ? and and sex = ?...&quot;的and和and在一起的情况</span><br><span class="line">    List&lt;Emp&gt; emp2 = mapper.getEmpByCondition(new Emp(null, &quot;Apple&quot;, null, &quot;女&quot;, &quot;123@gmail.com&quot;));</span><br><span class="line">    // 第一个查询条件为空字符串，可能导致&quot;select * from t_emp where and age = ? and ...&quot;的where和and在一起的情况</span><br><span class="line">    List&lt;Emp&gt; emp3 = mapper.getEmpByCondition(new Emp(null, null, null, &quot;女&quot;, &quot;123@gmail.com&quot;));        System.out.println(emp1);</span><br><span class="line">    System.out.println(emp1);</span><br><span class="line">    System.out.println(emp2);</span><br><span class="line">    System.out.println(emp3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if拼接就会出现上面例子中的情况，可以用类似sql注入的方法加一个 1and 1，解决这个问题，但是这个方法本来就是有问题的</p><h2 id="where"><a href="#where" class="headerlink" title="where"></a>where</h2><p>应用场景：多条件查询</p><p>DynamicSqlMapper接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface DynamicSQLMapper &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 多条件查询</span><br><span class="line">     */</span><br><span class="line">    List&lt;Emp&gt; getEmpByCondition(Emp emp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>DynamicSqlMapper.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--    where标签中，如果有内容，则添加关键字，如果没有内容，则把and/or去掉--&gt;</span><br><span class="line">    &lt;select id=&quot;getEmpByCondition&quot; resultType=&quot;Emp&quot;&gt;</span><br><span class="line">        select * from t_emp</span><br><span class="line">        &lt;where&gt;</span><br><span class="line">            &lt;if test=&quot;empName != null and empName != &#x27;&#x27;&quot;&gt;</span><br><span class="line">                and emp_name = #&#123;empName&#125;</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">            &lt;if test=&quot;age != null and age != &#x27;&#x27;&quot;&gt;</span><br><span class="line">                and age = #&#123;age&#125;</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">            &lt;if test=&quot;email != null and email != &#x27;&#x27;&quot;&gt;</span><br><span class="line">                and email = #&#123;email&#125;</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">            &lt;if test=&quot;sex != null and sex != &#x27;&#x27;&quot;&gt;</span><br><span class="line">                and sex = #&#123;sex&#125;</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">        &lt;/where&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 2、where：</span><br><span class="line"> *      当where标签中有内容时，会自动生成where关键字，并将内容前多余的and或or去掉</span><br><span class="line"> *      当where标签中没有内容时，此时where标签没有任何效果</span><br><span class="line"> *          注意：where标签不能将其中内容后面多余的and或or去掉</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void testGetEmpByCondition2()&#123;</span><br><span class="line">    SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">    DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);</span><br><span class="line">    // 各信息都不为null/空字符串</span><br><span class="line">    List&lt;Emp&gt; emp1 = mapper.getEmpByCondition(new Emp(null, &quot;Apple&quot;, 22, &quot;女&quot;, &quot;123@gmail.com&quot;));</span><br><span class="line">    // 中间存在查询出来是空，可能导致&quot;select * from t_emp where emp_name= ? and and sex = ?...&quot;的and和and在一起的情况</span><br><span class="line">    List&lt;Emp&gt; emp2 = mapper.getEmpByCondition(new Emp(null, &quot;Apple&quot;, null, &quot;女&quot;, &quot;123@gmail.com&quot;));</span><br><span class="line">    // 第一个查询条件为空字符串，可能导致&quot;select * from t_emp where and age = ? and ...&quot;的where和and在一起的情况</span><br><span class="line">    List&lt;Emp&gt; emp3 = mapper.getEmpByCondition(new Emp(null, null, null, &quot;女&quot;, &quot;123@gmail.com&quot;));        System.out.println(emp1);</span><br><span class="line">    System.out.println(emp1);</span><br><span class="line">    System.out.println(emp2);</span><br><span class="line">    System.out.println(emp3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h2><p>应用场景：多条件查询</p><p>DynamicSqlMapper接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface DynamicSQLMapper &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 多条件查询</span><br><span class="line">     */</span><br><span class="line">    List&lt;Emp&gt; getEmpByCondition(Emp emp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>DynamicSqlMapper.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;getEmpByCondition&quot; resultType=&quot;Emp&quot;&gt;</span><br><span class="line">    select * from t_emp</span><br><span class="line">    &lt;trim prefix=&quot;where&quot; suffixOverrides=&quot;and|or&quot;&gt;</span><br><span class="line">        &lt;if test=&quot;empName != null and empName != &#x27;&#x27;&quot;&gt;</span><br><span class="line">            emp_name = #&#123;empName&#125; and</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">        &lt;if test=&quot;age != null and age != &#x27;&#x27;&quot;&gt;</span><br><span class="line">            age = #&#123;age&#125; or</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">        &lt;if test=&quot;email != null and email != &#x27;&#x27;&quot;&gt;</span><br><span class="line">            email = #&#123;email&#125; and</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">        &lt;if test=&quot;sex != null and sex != &#x27;&#x27;&quot;&gt;</span><br><span class="line">            sex = #&#123;sex&#125;</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">    &lt;/trim&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 3、trim</span><br><span class="line"> *      若标签中有内容时：</span><br><span class="line"> *          prefix/suffix   在trim标签中内容前面或后面 去添加指定内容</span><br><span class="line"> *          prefixOverrides/suffixOverrides   在trim标签中内容前面或后面 去删掉指定内容</span><br><span class="line"> *      若标签中没有内容时：trim标签也没有任何效果</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void testGetEmpByCondition3()&#123;</span><br><span class="line">    SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">    DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);</span><br><span class="line">    // 各信息都不为null/空字符串</span><br><span class="line">    List&lt;Emp&gt; emp1 = mapper.getEmpByCondition(new Emp(null, &quot;Apple&quot;, 22, &quot;女&quot;, &quot;123@gmail.com&quot;));</span><br><span class="line">    // 中间存在查询出来是空，可能导致&quot;select * from t_emp where emp_name= ? and and sex = ?...&quot;的and和and在一起的情况</span><br><span class="line">    List&lt;Emp&gt; emp2 = mapper.getEmpByCondition(new Emp(null, &quot;Apple&quot;, null, &quot;女&quot;, &quot;123@gmail.com&quot;));</span><br><span class="line">    // 第一个查询条件为空字符串，可能导致&quot;select * from t_emp where and age = ? and ...&quot;的where和and在一起的情况</span><br><span class="line">    List&lt;Emp&gt; emp3 = mapper.getEmpByCondition(new Emp(null, null, null, &quot;女&quot;, &quot;123@gmail.com&quot;));</span><br><span class="line">    System.out.println(emp1);</span><br><span class="line">    System.out.println(emp2);</span><br><span class="line">    System.out.println(emp3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="choose-when-otherwise"><a href="#choose-when-otherwise" class="headerlink" title="choose-when-otherwise"></a>choose-when-otherwise</h2><p><strong>choose、when、otherwise相当于if…else if…else</strong></p><p>DynamicSqlMapper接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface DynamicSQLMapper &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 测试choose when otherwise</span><br><span class="line">     */</span><br><span class="line">    List&lt;Emp&gt; getEmpByChoose(Emp emp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>DynamicSqlMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--        List&lt;Emp&gt; getEmpByChoose(Emp emp);--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByChoose&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">        select * from t_emp</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;empName != null and empName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">                    emp_name = #&#123;empName&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">                    age = #&#123;age&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;sex != null and sex != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">                    sex = #&#123;sex&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;email != null and email != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">                    email = #&#123;email&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">                    did = 2</span><br><span class="line">                <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 4、choose/when/otherwise: 相当于if..else if..else</span><br><span class="line"> *  when至少要有一个， otherwise最有只能有一个</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void testGetEmpByChoose()&#123;</span><br><span class="line">    SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">    DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);</span><br><span class="line">    // 各信息都不为null/空字符串</span><br><span class="line">    List&lt;Emp&gt; emp1 = mapper.getEmpByChoose(new Emp(null, &quot;Apple&quot;, 22, &quot;女&quot;, &quot;123@gmail.com&quot;));</span><br><span class="line">    // 中间存在查询出来是空，可能导致&quot;select * from t_emp where emp_name= ? and and sex = ?...&quot;的and和and在一起的情况</span><br><span class="line">    List&lt;Emp&gt; emp2 = mapper.getEmpByChoose(new Emp(null, &quot;Apple&quot;, null, &quot;女&quot;, &quot;123@gmail.com&quot;));</span><br><span class="line">    // 第一个查询条件为空字符串，可能导致&quot;select * from t_emp where and age = ? and ...&quot;的where和and在一起的情况</span><br><span class="line">    List&lt;Emp&gt; emp3 = mapper.getEmpByChoose(new Emp(null, null, null, &quot;&quot;, &quot;&quot;));</span><br><span class="line">    System.out.println(emp1);</span><br><span class="line">    System.out.println(emp2);</span><br><span class="line">    System.out.println(emp3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><p><strong>应用场景1：</strong> 通过数组实现批量删除</p><p>DynamicSqlMapper接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface DynamicSQLMapper &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 通过数组实现批量删除</span><br><span class="line">     */</span><br><span class="line">    int deleteMoreByArray(@Param(&quot;eids&quot;) Integer[] eids);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>DynamicSqlMapper.xml<br>方法一：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--        int deleteMoreByArray(Integer[] eids);--&gt;</span><br><span class="line">&lt;!--    没加@Param时，</span><br><span class="line">        报错：Parameter &#x27;eids&#x27; not found. Available parameters are [array, arg0]</span><br><span class="line">        因此最好都加上@Param--&gt;</span><br><span class="line">&lt;!--        int deleteMoreByArray(@Param(&quot;eids&quot;) Integer[] eids);--&gt;</span><br><span class="line">    &lt;delete id=&quot;deleteMoreByArray&quot;&gt;</span><br><span class="line">        delete from t_emp where eid in</span><br><span class="line">            &lt;foreach collection=&quot;eids&quot; item=&quot;eid&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt;</span><br><span class="line">                #&#123;eid&#125;</span><br><span class="line">    &lt;/foreach&gt;</span><br><span class="line">    &lt;/delete&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--        int deleteMoreByArray(Integer[] eids);--&gt;</span><br><span class="line">    &lt;delete id=&quot;deleteMoreByArray&quot;&gt;</span><br><span class="line">    &lt;!--方法2：--&gt;</span><br><span class="line">        delete from t_emp where</span><br><span class="line">        &lt;foreach collection=&quot;eids&quot;  item=&quot;eid&quot; separator=&quot;or&quot;&gt;</span><br><span class="line">            eid = #&#123;eid&#125;</span><br><span class="line">        &lt;/foreach&gt;</span><br><span class="line">    &lt;/delete&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 5、foreach</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void testDeleteMoreByArray()&#123;</span><br><span class="line">    SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">    DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);</span><br><span class="line">    int result = mapper.deleteMoreByArray(new Integer[]&#123;7, 8, 9&#125;);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>应用场景2：</strong> 通过list集合实现批量添加</p><p>DynamicSqlMapper接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface DynamicSQLMapper &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 通过list集合实现批量添加</span><br><span class="line">     */</span><br><span class="line">    int insertMoreByList(@Param(&quot;emps&quot;) List&lt;Emp&gt; emps);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>DynamicSqlMapper.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--        int insertMoreByList(List&lt;Emp&gt; emps);--&gt;</span><br><span class="line">&lt;!--    不加注解会报错：Parameter &#x27;emps&#x27; not found. Available parameters are [arg0, collection, list]--&gt;</span><br><span class="line">&lt;!--    int insertMoreByList(@Param(&quot;emps&quot;) List&lt;Emp&gt; emps);--&gt;</span><br><span class="line">    &lt;insert id=&quot;insertMoreByList&quot;&gt;</span><br><span class="line">        insert into t_emp values</span><br><span class="line">        &lt;foreach collection=&quot;emps&quot; item=&quot;emp&quot; separator=&quot;,&quot;&gt;</span><br><span class="line">            (null, #&#123;emp.empName&#125;, #&#123;emp.age&#125;, #&#123;emp.sex&#125;, #&#123;emp.email&#125;, null)</span><br><span class="line">        &lt;/foreach&gt;</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 5、foreach</span><br><span class="line"> *      collection  需要循环的数组或集合</span><br><span class="line"> *      item        表示数组或集合中的每一个数据</span><br><span class="line"> *      separator   循环体之间的分隔符</span><br><span class="line"> *      open        foreach标签所循环的所有内容的开始符</span><br><span class="line"> *      close       foreach标签所循环的所有内容的结束符</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void testInsertMoreByList()&#123;</span><br><span class="line">    SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">    DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);</span><br><span class="line">    Emp emp1 = new Emp(null, &quot;Mary&quot;, 23, &quot;女&quot;, &quot;11111@qq.com&quot;);</span><br><span class="line">    Emp emp2 = new Emp(null, &quot;Linda&quot;, 23, &quot;女&quot;, &quot;1144111@qq.com&quot;);</span><br><span class="line">    Emp emp3 = new Emp(null, &quot;Jackoline&quot;, 23, &quot;女&quot;, &quot;1122111@qq.com&quot;);</span><br><span class="line">    List&lt;Emp&gt; emps = Arrays.asList(emp1, emp2, emp3);</span><br><span class="line">    System.out.println(mapper.insertMoreByList(emps));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="sql片段-include"><a href="#sql片段-include" class="headerlink" title="sql片段 include"></a>sql片段 include</h2><p>应用场景：获取所有员工的某些信息</p><p>DynamicSqlMapper接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface DynamicSQLMapper &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 获取所有员工的某些信息</span><br><span class="line">     */</span><br><span class="line">    List&lt;Emp&gt; getAllEmpNameAndAge();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>DynamicSqlMapper.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--    sql片段--&gt;</span><br><span class="line">&lt;!--        List&lt;Emp&gt; getAllEmpNameAndAge();--&gt;</span><br><span class="line">    &lt;sql id=&quot;empColumns&quot;&gt;emp_name, age&lt;/sql&gt;</span><br><span class="line">    &lt;select id=&quot;getAllEmpNameAndAge&quot; resultType=&quot;Emp&quot;&gt;</span><br><span class="line">        select &lt;include refid=&quot;empColumns&quot;&gt;&lt;/include&gt; from t_emp</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 6、sql片段</span><br><span class="line"> *   设置：</span><br><span class="line"> *   &lt;sql id=&quot;empColumns&quot;&gt;emp_name, age&lt;/sql&gt;</span><br><span class="line"> *   使用：</span><br><span class="line"> *   select &lt;include refid=&quot;empColumns&quot;&gt;&lt;/include&gt; from t_emp</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void testGetAllEmp()&#123;</span><br><span class="line">    SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">    DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);</span><br><span class="line">    System.out.println(mapper.getAllEmpNameAndAge());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Mybatis的缓存"><a href="#Mybatis的缓存" class="headerlink" title="Mybatis的缓存"></a>Mybatis的缓存</h1><h2 id="MyBatis的一级缓存"><a href="#MyBatis的一级缓存" class="headerlink" title="MyBatis的一级缓存"></a>MyBatis的一级缓存</h2><p>一级缓存是SqlSession级别的，通过<strong>同一个SqlSession 对象</strong>查询的数据会被缓存，下次查询<strong>相同的数据</strong>，就 会从缓存中直接获取，不会从数据库重新访问。一级缓存默认开启</p><p>使一级缓存失效的四种情况:</p><ol><li><p>不同的SqlSession对应不同的一级缓存</p><blockquote><p>一级缓存的范围是SqlSession，不同的SqlSession对应不同的一级缓存</p></blockquote></li><li><p>同一个SqlSession但是查询条件不同</p></li><li><p>同一个SqlSession两次查询期间执行了任何一次增删改操作</p><blockquote><p>为了确保数据的正确，只要一改就会清空，后面二级缓存也一样</p></blockquote></li><li><p>同一个SqlSession两次查询期间手动清空了缓存</p></li></ol><p>不同的SqlSession对应不同的一级缓存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testCache()&#123;</span><br><span class="line">    SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">    CacheMapper mapper = sqlSession.getMapper(CacheMapper.class);</span><br><span class="line">    Emp emp1 = mapper.getEmpById(3);</span><br><span class="line">    System.out.println(emp1);</span><br><span class="line">    System.out.println(&quot;========第二次调用========从缓存中取数据&quot;);</span><br><span class="line">    Emp emp2 = mapper.getEmpById(3);</span><br><span class="line">    System.out.println(emp2);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;\n========即使用的不是同一个Mapper，也同样从缓存中取(同一个sqlsession)========&quot;);</span><br><span class="line">    CacheMapper mapper2 = sqlSession.getMapper(CacheMapper.class);</span><br><span class="line">    Emp empByMapper2 = mapper2.getEmpById(3);</span><br><span class="line">    System.out.println(empByMapper2);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;\n========一级缓存的范围在sqlsession中，换一个新的sqlsession就会再次用sql读取数据========&quot;);</span><br><span class="line">    SqlSession sqlSession2 = SqlSessionUtils.getSqlSession();</span><br><span class="line">    CacheMapper mapper2BySqlSession2 = sqlSession2.getMapper(CacheMapper.class);</span><br><span class="line">    System.out.println(mapper2BySqlSession2.getEmpById(3));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310191104641.png"></p><p>同一个SqlSession但是查询条件不同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testCache3()&#123;</span><br><span class="line">    SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">    CacheMapper mapper = sqlSession.getMapper(CacheMapper.class);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;=====第一次获取数据=====&quot;);</span><br><span class="line">    Emp emp1 = mapper.getEmpById(3);</span><br><span class="line">    System.out.println(emp1);</span><br><span class="line">    </span><br><span class="line">    System.out.println(&quot;\n=====查询条件不同=====&quot;);</span><br><span class="line">    Emp emp2 = mapper.getEmpById(5);</span><br><span class="line">    System.out.println(emp2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310191104217.png"></p><p>同一个SqlSession两次查询期间执行了任何一次增删改操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testCache2()&#123;</span><br><span class="line">    SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">    CacheMapper mapper = sqlSession.getMapper(CacheMapper.class);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;=====第一次获取数据=====&quot;);</span><br><span class="line">    Emp emp1 = mapper.getEmpById(3);</span><br><span class="line">    System.out.println(emp1);</span><br><span class="line">    Emp emp2 = mapper.getEmpById(3);</span><br><span class="line">    System.out.println(emp2);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;\n=====进行增删改操作=====&quot;);</span><br><span class="line">    mapper.insetEmp(new Emp(null, &quot;Joey&quot;, 44, &quot;男&quot;, &quot;8888@gmai.com&quot;));</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;\n=====同一个sqlsession，再获取数据=====&quot;);</span><br><span class="line">    Emp emp3 = mapper.getEmpById(3);</span><br><span class="line">    System.out.println(emp3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310191104525.png"></p><p>同一个SqlSession两次查询期间手动清空了（一级）缓存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testCache4()&#123;</span><br><span class="line">    SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">    CacheMapper mapper = sqlSession.getMapper(CacheMapper.class);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;=====第一次获取数据=====&quot;);</span><br><span class="line">    Emp emp1 = mapper.getEmpById(3);</span><br><span class="line">    System.out.println(emp1);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;\n=====两次查询期间手动清空缓存=====&quot;);</span><br><span class="line">    sqlSession.clearCache();</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;\n=====再次查询id=3的emp=====&quot;);</span><br><span class="line">    Emp emp2 = mapper.getEmpById(3);</span><br><span class="line">    System.out.println(emp2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310191105166.png"></p><h2 id="MyBatis的二级缓存"><a href="#MyBatis的二级缓存" class="headerlink" title="MyBatis的二级缓存"></a>MyBatis的二级缓存</h2><p>二级缓存是SqlSessionFactory级别，范围比一级缓存大，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取</p><p>二级缓存开启的条件：</p><ol><li>在核心配置文件中，设置全局配置属性cacheEnabled&#x3D;“true”，默认为true，不需要设置</li><li>在映射文件中设置标签&lt; cache &#x2F;&gt;</li><li>二级缓存必须在SqlSession关闭或提交之后有效</li><li>查询的数据所转换的实体类类型必须实现序列化的接口</li></ol><p>使二级缓存失效的情况：</p><ol><li><p><strong>两次查询之间执行了任意的增删改</strong>，会使一级和二级缓存同时失效</p></li><li><p>没有提交sqlsession时，数据会保存在一级缓存中，提交后，会保存在二级缓存中。</p></li></ol><p>缓存有个属性是命中率，值有2中情况</p><ol><li>值为0：缓存中没有需要的结果</li><li>值非0：缓存中有需要的结果</li></ol><p>测试</p><ol><li>要把Emp Class加上<code>implements Serializable</code></li></ol>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    @Test</span><br><span class="line">    public void testCacheTwo()&#123;</span><br><span class="line">        //这里不能用工具类了，因为每次都会创建新的sqlsessionfactory</span><br><span class="line">//        SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">//        CacheMapper mapper = sqlSession.getMapper(CacheMapper.class);</span><br><span class="line"></span><br><span class="line">        //只要是同一个sqlsessionfactory获得的sqlsession就可以</span><br><span class="line">        try &#123;</span><br><span class="line">            InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">            SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);</span><br><span class="line">            SqlSession sqlSession1 = sqlSessionFactory.openSession(true);</span><br><span class="line">            CacheMapper mapper1 = sqlSession1.getMapper(CacheMapper.class);</span><br><span class="line">            System.out.println(mapper1.getEmpById(1));</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;Cache Hit Ratio：缓存命中率，指的是在缓存中有没有这条数据&quot;);</span><br><span class="line">            System.out.println(&quot;=====二级缓存未打开，没从缓存中获取数据=====&quot;);</span><br><span class="line">            SqlSession sqlSession2 = sqlSessionFactory.openSession(true);</span><br><span class="line">            CacheMapper mapper2 = sqlSession2.getMapper(CacheMapper.class);</span><br><span class="line">            System.out.println(mapper2.getEmpById(1));</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>   <img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310191107676.png"></p><ol start="2"><li><p>关闭sqlSession，再看是用sql从数据库读取数据还是从缓存中取数据：</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310191108932.png"></p></li></ol><h3 id="二级缓存的相关配置"><a href="#二级缓存的相关配置" class="headerlink" title="二级缓存的相关配置"></a>二级缓存的相关配置</h3><p>在mapper配置文件中添加的cache标签可以设置一些属性:</p><ol><li>eviction属性：缓存回收策略<br>LRU(Least Recently Used) ：最近最少使用的:移除最长时间不被使用的对象。<br>FIFO(First in First out)：先进先出:按对象进入缓存的顺序来移除它们。<br>SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。<br>WEAK –弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。<br>默认的是 LRU。</li><li>flushInterval属性：刷新间隔，单位毫秒<br>默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句（增删改） 时刷新</li><li>size属性：引用数目，正整数<br>代表缓存最多可以存储多少个对象，太大容易导致内存溢出</li><li>readOnly属性：只读，true&#x2F;false<br>true：只读缓存; 会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。【性能好】<br>false：读写缓存; 会返回缓存对象的拷贝(通过序列化)。这会慢一些，但是安全，因此默认是 false。【安全】</li></ol><h2 id="MyBatis缓存查询的顺序"><a href="#MyBatis缓存查询的顺序" class="headerlink" title="MyBatis缓存查询的顺序"></a>MyBatis缓存查询的顺序</h2><p>先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用。<br>如果二级缓存没有命中，再查询一级缓存<br>如果一级缓存也没有命中，则查询数据库<br>SqlSession关闭之后，一级缓存中的数据会写入二级缓存。</p><h1 id="MyBatis逆向工程"><a href="#MyBatis逆向工程" class="headerlink" title="MyBatis逆向工程"></a>MyBatis逆向工程</h1><p>MBG ：MyBatis Generator<br>MyBatis逆向工程指的是根据一张sql表单，借助Maven和MBG直接创建pojo、mapper接口（xxxMapper）、映射文件（xxxMapper.xml）。就不需要我们自己一个一个创建文件去配置</p><h2 id="创建逆向工程的步骤"><a href="#创建逆向工程的步骤" class="headerlink" title="创建逆向工程的步骤"></a>创建逆向工程的步骤</h2><ol><li><p>添加依赖和插件</p><p>在pom.xml中添加依赖和插件，更新maven。在插件 build 里面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;org.example&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;MyBatis_MBG&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 依赖MyBatis核心包 --&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.5.7&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- junit测试 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- MySQL驱动 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.3&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- log4j日志 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;RELEASE&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">    &lt;!-- 控制Maven在构建过程中相关配置 --&gt;</span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;!-- 构建过程中用到的插件 --&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 --&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;1.3.0&lt;/version&gt;</span><br><span class="line">                &lt;!-- 插件的依赖 --&gt;</span><br><span class="line">                &lt;dependencies&gt;</span><br><span class="line">                    &lt;!-- 逆向工程的核心依赖 --&gt;</span><br><span class="line">                    &lt;dependency&gt;</span><br><span class="line">                        &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;</span><br><span class="line">                        &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;</span><br><span class="line">                        &lt;version&gt;1.3.2&lt;/version&gt;</span><br><span class="line">                    &lt;/dependency&gt;</span><br><span class="line">                    &lt;!-- 数据库连接池 --&gt;</span><br><span class="line">                    &lt;dependency&gt;</span><br><span class="line">                        &lt;groupId&gt;com.mchange&lt;/groupId&gt;</span><br><span class="line">                        &lt;artifactId&gt;c3p0&lt;/artifactId&gt;</span><br><span class="line">                        &lt;version&gt;0.9.2&lt;/version&gt;</span><br><span class="line">                    &lt;/dependency&gt;</span><br><span class="line">                    &lt;!-- MySQL驱动 --&gt;</span><br><span class="line">                    &lt;dependency&gt;</span><br><span class="line">                        &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">                        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">                        &lt;version&gt;5.1.8&lt;/version&gt;</span><br><span class="line">                    &lt;/dependency&gt;</span><br><span class="line">                &lt;/dependencies&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>创建MyBatis的核心配置文件</p><p>在src&#x2F;main&#x2F;resources下创建mybatis-config.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties resource=&quot;jdbc.properties&quot;&gt;&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--设置连接数据库的环境--&gt;</span><br><span class="line">    &lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">        &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">            &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class="line">            &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">                &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;url&quot;</span><br><span class="line">                          value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br><span class="line"></span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建jdbc.properties文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf8</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=写你的数据库密码</span><br></pre></td></tr></table></figure><p>创建log4j.xml文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE log4j:configuration SYSTEM &quot;log4j.dtd&quot;&gt;</span><br><span class="line">&lt;log4j:configuration xmlns:log4j=&quot;http://jakarta.apache.org/log4j/&quot;</span><br><span class="line">                     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">                     xsi:schemaLocation=&quot;http://jakarta.apache.org/log4j/ &quot;&gt;</span><br><span class="line">    &lt;appender name=&quot;STDOUT&quot; class=&quot;org.apache.log4j.ConsoleAppender&quot;&gt;</span><br><span class="line">        &lt;param name=&quot;Encoding&quot; value=&quot;UTF-8&quot;/&gt;</span><br><span class="line">        &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt;</span><br><span class="line">            &lt;param name=&quot;ConversionPattern&quot; value=&quot;%-5p %d&#123;MM-dd HH:mm:ss,SSS&#125;</span><br><span class="line">%m  (%F:%L) \n&quot;/&gt;</span><br><span class="line">        &lt;/layout&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line">    &lt;logger name=&quot;java.sql&quot;&gt;</span><br><span class="line">        &lt;level value=&quot;debug&quot;/&gt;</span><br><span class="line">    &lt;/logger&gt;</span><br><span class="line">    &lt;logger name=&quot;org.apache.ibatis&quot;&gt;</span><br><span class="line">        &lt;level value=&quot;info&quot;/&gt;</span><br><span class="line">    &lt;/logger&gt;</span><br><span class="line">    &lt;root&gt;</span><br><span class="line">        &lt;level value=&quot;debug&quot;/&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;STDOUT&quot;/&gt;</span><br><span class="line">    &lt;/root&gt;</span><br><span class="line">&lt;/log4j:configuration&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>创建逆向工程的配置文件<br>文件名必须是：generatorConfig.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE generatorConfiguration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;</span><br><span class="line">&lt;generatorConfiguration&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!--</span><br><span class="line">    targetRuntime: 执行生成的逆向工程的版本</span><br><span class="line">        MyBatis3Simple: 生成基本的CRUD(清新简洁版)</span><br><span class="line">        MyBatis3: 生成带条件的CRUD(奢华尊享版)</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3Simple&quot;&gt; &lt;!-- 数据库的连接信息 --&gt;</span><br><span class="line">        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">                        connectionURL=&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span><br><span class="line">                        userId=&quot;root&quot;</span><br><span class="line">                        password=&quot;这里改成你自己的数据库密码&quot;&gt;</span><br><span class="line">        &lt;/jdbcConnection&gt;</span><br><span class="line">        &lt;!-- javaBean的生成策略--&gt;</span><br><span class="line">        &lt;javaModelGenerator targetPackage=&quot;com.atguigu.mybatis.pojo&quot;</span><br><span class="line">                            targetProject=&quot;.\src\main\java&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;/javaModelGenerator&gt;</span><br><span class="line">        &lt;!-- SQL映射文件的生成策略 --&gt;</span><br><span class="line">        &lt;sqlMapGenerator targetPackage=&quot;com.atguigu.mybatis.mapper&quot;</span><br><span class="line">                         targetProject=&quot;.\src\main\resources&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;/sqlMapGenerator&gt;</span><br><span class="line">        &lt;!-- Mapper接口的生成策略 --&gt;</span><br><span class="line">        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot;</span><br><span class="line">                             targetPackage=&quot;com.atguigu.mybatis.mapper&quot; targetProject=&quot;.\src\main\java&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;/javaClientGenerator&gt;</span><br><span class="line">        &lt;!-- 逆向分析的表 --&gt;</span><br><span class="line">        &lt;!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName --&gt; &lt;!-- domainObjectName属性指定生成出来的实体类的类名 --&gt;</span><br><span class="line">        &lt;table tableName=&quot;t_emp&quot; domainObjectName=&quot;Emp&quot;/&gt;</span><br><span class="line">        &lt;table tableName=&quot;t_dept&quot; domainObjectName=&quot;Dept&quot;/&gt;</span><br><span class="line">    &lt;/context&gt;</span><br><span class="line">&lt;/generatorConfiguration&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>执行MBG插件的generate目标</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310191509238.png"></p><div class="tabs" id="test6"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test6-1">操作前</button></li><li class="tab"><button type="button" data-href="#test6-2">操作后</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test6-1"><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310191511746.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test6-2"><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310191511567.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="tabs" id="test7"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test7-1">简易自动生成</button></li><li class="tab"><button type="button" data-href="#test7-2">更改参数为MyBatis3: 生成带条件的CRUD</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test7-1"><p>pojo中自动生成属性和get&#x2F;set方法</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310191514697.png"></p><p>Mapper接口中自动生成基础增删改查功能</p><p>此时逆向工程的配置文件<code>generatorConfig.xml</code>中：<code>targetRuntime=“MyBatis3Simple&quot;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface EmpMapper &#123;</span><br><span class="line">    int deleteByPrimaryKey(Integer eid);</span><br><span class="line">    </span><br><span class="line">    int insert(Emp record);</span><br><span class="line">    </span><br><span class="line">    Emp selectByPrimaryKey(Integer eid);</span><br><span class="line">    </span><br><span class="line">    List&lt;Emp&gt; selectAll();</span><br><span class="line">    </span><br><span class="line">    int updateByPrimaryKey(Emp record);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Mapper映射文件中自动生成相对应方法的配置信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.atguigu.mybatis.mapper.EmpMapper&quot; &gt;</span><br><span class="line">  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.atguigu.mybatis.pojo.Emp&quot; &gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">      WARNING - @mbggenerated</span><br><span class="line">      This element is automatically generated by MyBatis Generator, do not modify.</span><br><span class="line">      This element was generated on Wed Mar 02 16:05:18 CST 2022.</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;id column=&quot;eid&quot; property=&quot;eid&quot; jdbcType=&quot;INTEGER&quot; /&gt;</span><br><span class="line">    &lt;result column=&quot;emp_name&quot; property=&quot;empName&quot; jdbcType=&quot;VARCHAR&quot; /&gt;</span><br><span class="line">    &lt;result column=&quot;age&quot; property=&quot;age&quot; jdbcType=&quot;INTEGER&quot; /&gt;</span><br><span class="line">    &lt;result column=&quot;sex&quot; property=&quot;sex&quot; jdbcType=&quot;CHAR&quot; /&gt;</span><br><span class="line">    &lt;result column=&quot;email&quot; property=&quot;email&quot; jdbcType=&quot;VARCHAR&quot; /&gt;</span><br><span class="line">    &lt;result column=&quot;did&quot; property=&quot;did&quot; jdbcType=&quot;INTEGER&quot; /&gt;</span><br><span class="line">  &lt;/resultMap&gt;</span><br><span class="line">  &lt;delete id=&quot;deleteByPrimaryKey&quot; parameterType=&quot;java.lang.Integer&quot; &gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">      WARNING - @mbggenerated</span><br><span class="line">      This element is automatically generated by MyBatis Generator, do not modify.</span><br><span class="line">      This element was generated on Wed Mar 02 16:05:18 CST 2022.</span><br><span class="line">    --&gt;</span><br><span class="line">    delete from t_emp</span><br><span class="line">    where eid = #&#123;eid,jdbcType=INTEGER&#125;</span><br><span class="line">  &lt;/delete&gt;</span><br><span class="line">  &lt;insert id=&quot;insert&quot; parameterType=&quot;com.atguigu.mybatis.pojo.Emp&quot; &gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">      WARNING - @mbggenerated</span><br><span class="line">      This element is automatically generated by MyBatis Generator, do not modify.</span><br><span class="line">      This element was generated on Wed Mar 02 16:05:18 CST 2022.</span><br><span class="line">    --&gt;</span><br><span class="line">    insert into t_emp (eid, emp_name, age, </span><br><span class="line">      sex, email, did)</span><br><span class="line">    values (#&#123;eid,jdbcType=INTEGER&#125;, #&#123;empName,jdbcType=VARCHAR&#125;, #&#123;age,jdbcType=INTEGER&#125;, </span><br><span class="line">      #&#123;sex,jdbcType=CHAR&#125;, #&#123;email,jdbcType=VARCHAR&#125;, #&#123;did,jdbcType=INTEGER&#125;)</span><br><span class="line">  &lt;/insert&gt;</span><br><span class="line">  &lt;update id=&quot;updateByPrimaryKey&quot; parameterType=&quot;com.atguigu.mybatis.pojo.Emp&quot; &gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">      WARNING - @mbggenerated</span><br><span class="line">      This element is automatically generated by MyBatis Generator, do not modify.</span><br><span class="line">      This element was generated on Wed Mar 02 16:05:18 CST 2022.</span><br><span class="line">    --&gt;</span><br><span class="line">    update t_emp</span><br><span class="line">    set emp_name = #&#123;empName,jdbcType=VARCHAR&#125;,</span><br><span class="line">      age = #&#123;age,jdbcType=INTEGER&#125;,</span><br><span class="line">      sex = #&#123;sex,jdbcType=CHAR&#125;,</span><br><span class="line">      email = #&#123;email,jdbcType=VARCHAR&#125;,</span><br><span class="line">      did = #&#123;did,jdbcType=INTEGER&#125;</span><br><span class="line">    where eid = #&#123;eid,jdbcType=INTEGER&#125;</span><br><span class="line">  &lt;/update&gt;</span><br><span class="line">  &lt;select id=&quot;selectByPrimaryKey&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;java.lang.Integer&quot; &gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">      WARNING - @mbggenerated</span><br><span class="line">      This element is automatically generated by MyBatis Generator, do not modify.</span><br><span class="line">      This element was generated on Wed Mar 02 16:05:18 CST 2022.</span><br><span class="line">    --&gt;</span><br><span class="line">    select eid, emp_name, age, sex, email, did</span><br><span class="line">    from t_emp</span><br><span class="line">    where eid = #&#123;eid,jdbcType=INTEGER&#125;</span><br><span class="line">  &lt;/select&gt;</span><br><span class="line">  &lt;select id=&quot;selectAll&quot; resultMap=&quot;BaseResultMap&quot; &gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">      WARNING - @mbggenerated</span><br><span class="line">      This element is automatically generated by MyBatis Generator, do not modify.</span><br><span class="line">      This element was generated on Wed Mar 02 16:05:18 CST 2022.</span><br><span class="line">    --&gt;</span><br><span class="line">    select eid, emp_name, age, sex, email, did</span><br><span class="line">    from t_emp</span><br><span class="line">  &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test7-2"><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310191520688.png"></p><p>自动生成的Mapper接口中的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public interface EmpMapper &#123;</span><br><span class="line">// 根据条件计数</span><br><span class="line">    int countByExample(EmpExample example);</span><br><span class="line"></span><br><span class="line">//根据条件删除</span><br><span class="line">    int deleteByExample(EmpExample example);</span><br><span class="line">//根据主键删除</span><br><span class="line">    int deleteByPrimaryKey(Integer eid);</span><br><span class="line"></span><br><span class="line">//普通插入</span><br><span class="line">    int insert(Emp record);</span><br><span class="line">//选择性插入：没写的就是null</span><br><span class="line">    int insertSelective(Emp record);</span><br><span class="line"></span><br><span class="line">//根据条件查询</span><br><span class="line">    List&lt;Emp&gt; selectByExample(EmpExample example);</span><br><span class="line">//根据主键查询</span><br><span class="line">    Emp selectByPrimaryKey(Integer eid);</span><br><span class="line"></span><br><span class="line">//根据条件选择性修改：</span><br><span class="line">    int updateByExampleSelective(@Param(&quot;record&quot;) Emp record, @Param(&quot;example&quot;) EmpExample example);</span><br><span class="line">    //根据条件修改</span><br><span class="line">    int updateByExample(@Param(&quot;record&quot;) Emp record, @Param(&quot;example&quot;) EmpExample example);</span><br><span class="line">//根据主键选择性修改</span><br><span class="line">    int updateByPrimaryKeySelective(Emp record);</span><br><span class="line">//根据主键修改</span><br><span class="line">    int updateByPrimaryKey(Emp record);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Mapper映射文件中自动生成相对应方法的配置信息：</p><p>这次的Mapper映射文件很复杂很全面，提供了大量的功能</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></li></ol><blockquote><p>pom.xml里有两个配置sql的地方，一个是给项目加的，一个是给插件加的。2个sql依赖</p></blockquote><h1 id="分页插件的配置及使用"><a href="#分页插件的配置及使用" class="headerlink" title="分页插件的配置及使用"></a>分页插件的配置及使用</h1><h2 id="分页插件配置"><a href="#分页插件配置" class="headerlink" title="分页插件配置"></a>分页插件配置</h2><ol><li><p>添加依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.2.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>配置分页插件</p><p>在MyBatis的核心配置文件中配置插件，注意顺序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">&lt;!--设置分页插件--&gt;</span><br><span class="line">    &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt;&lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="分页插件的使用"><a href="#分页插件的使用" class="headerlink" title="分页插件的使用"></a>分页插件的使用</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310191527610.png"></p><ol><li><p>在查询功能之前使用 PageHelper.startPage(int pageNum, int pageSize) 开启分页功能</p><ul><li>pageNum:当前页的页码</li><li>pageSize:每页显示的条数</li></ul></li><li><p>在查询获取list集合之后，使用PageInfo pageInfo &#x3D; new PageInfo&lt;&gt;(List list, int navigatePages)获取分页相关数据</p><ul><li>list:分页之后的数据</li><li>navigatePages:导航分页的页码数</li></ul></li><li><p>分页相关数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PageInfo&#123;</span><br><span class="line">pageNum=8, pageSize=4, size=2, startRow=29, endRow=30, total=30, pages=8,</span><br><span class="line">list=Page&#123;count=true, pageNum=8, pageSize=4, startRow=28, endRow=32, total=30, pages=8, reasonable=false, pageSizeZero=false&#125;,</span><br><span class="line">prePage=7, nextPage=0, isFirstPage=false, isLastPage=true, hasPreviousPage=true, hasNextPage=false, navigatePages=5, navigateFirstPage4, navigateLastPage8, navigatepageNums=[4, 5, 6, 7, 8]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>pageNum:当前页的页码</li><li>pageSize:每页显示的条数</li><li>size:当前页显示的真实条数</li><li>total:总记录数</li><li>pages:总页数</li><li>prePage:上一页的页码</li><li>nextPage:下一页的页码</li><li>isFirstPage&#x2F;isLastPage:是否为第一页&#x2F;最后一页</li><li>hasPreviousPage&#x2F;hasNextPage:是否存在上一页&#x2F;下一页</li><li>navigatePages:导航分页的页码数</li><li>navigatepageNums:导航分页的页码，[1,2,3,4,5]</li></ul></li></ol><p>测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * limit    index，pagesize</span><br><span class="line"> * index    当前页的起始索引</span><br><span class="line"> * pageSize 每页显示的条数</span><br><span class="line"> * pageNum  当前页的页码</span><br><span class="line"> * 当前页的起始索引 = 每页条数 * 页码 - 1</span><br><span class="line"> * index = pageNum * pageSize - 1</span><br><span class="line"> *</span><br><span class="line"> * 通过索引获得数据</span><br><span class="line"> *</span><br><span class="line"> * 使用MyBatis的分页插件，实现分页功能：</span><br><span class="line"> * 1。需要在查询功能之前开启分页</span><br><span class="line"> * PageHelper.startPage(2, 4);</span><br><span class="line"> * </span><br><span class="line"> * 2。在查询功能之后获取分页相关信息</span><br><span class="line"> *   PageInfo&lt;Emp&gt; pages = new PageInfo&lt;&gt;(emps, 5); 5表示导航分页的数量</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void test2()&#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;\n查询功能前开启分页&quot;);</span><br><span class="line">        PageHelper.startPage(2, 4);</span><br><span class="line">        List&lt;Emp&gt; emps = mapper.selectByExample(null);</span><br><span class="line">        emps.forEach(emp -&gt; System.out.println(emp));</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;\n&quot;);</span><br><span class="line">        PageInfo&lt;Emp&gt; pages = new PageInfo&lt;&gt;(emps, 5);</span><br><span class="line">        System.out.println(&quot;PageInfo-----&gt;&quot;+pages);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 框架 </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC</title>
      <link href="/2023/10/08/SSM-SpringMVC/"/>
      <url>/2023/10/08/SSM-SpringMVC/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><p>SpringMVC是隶属于Spring框架的一部分，主要是用来进行Web开发，是对Servlet进行了封装。</p><p>SpringMVC是处于Web层的框架，所以其主要作用就是用来接收前段发过来的请求和数据，然后经过处理之后将处理结果响应给前端，所以如何处理情趣和响应是SpringMVC中非常重要的一块内容。</p><p>REST是一种软件架构风格，可以降低开发的复杂性，提高系统的可伸缩性，后期的应用也是非常广泛。</p><p>对于SpringMVC的学习，<code>最终要达成的目标：</code></p><ol><li>掌握基于SpringMVC获取请求参数和响应JSON数据操作</li><li>熟练应用基于REST风格的请求路径设置与参数传递</li><li>能根据实际业务建立前后端开发通信协议，并进行实现</li><li>基于SSM整合技术开发任意业务模块功能</li></ol><h2 id="SpringMVC概述"><a href="#SpringMVC概述" class="headerlink" title="SpringMVC概述"></a>SpringMVC概述</h2><p>随着互联网的发展，性能慢慢的跟不是需求，所以异步调用慢慢的走到了前台，是现在比较流行的一种处理方式。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310081415019.png"></p><ul><li>因为是异步调用，所以后端不需要返回View视图，将其去除</li><li>前端如果通过异步调用的方式进行交互，后端就需要将返回的数据转换成JSON格式进行返回</li><li>SpringMVC主要负责的就是<ul><li>controller如何接收请求和数据</li><li>如何将请求和数据转发给业务层</li><li>如何将响应数据转换成JSON发挥到前端</li></ul></li><li>SpringMVC是一种基于Java实现MVC模型的轻量级Web框架<ul><li>优点<ul><li>使用简单、开发快捷（相比较于Servlet）</li><li>灵活性强</li></ul></li></ul></li></ul><p>这里说的优点，我们通过下面的讲解与联系慢慢体会</p><h2 id="SpringMVC入门案例"><a href="#SpringMVC入门案例" class="headerlink" title="SpringMVC入门案例"></a>SpringMVC入门案例</h2><p>SpringMVC的制作过程和上述流程几乎是一致的，具体的实现流程是什么?</p><ol><li>创建web工程(Maven结构)</li><li>设置tomcat服务器，加载web工程(tomcat插件)</li><li>导入坐标(SpringMVC+Servlet)</li><li>定义处理请求的功能类(UserController)</li><li>设置请求映射(配置映射关系)</li><li>将SpringMVC设定加载到Tomcat容器中</li></ol><p>案例制作:</p><ol><li><p>创建Maven项目</p><p>这里不是空maven了，选用自带的webapp框架</p></li><li><p>导入所需坐标（SpringMVC+Servlet）和 tomcat 插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--servlet--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--springmvc--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">  &lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">      &lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1&lt;/version&gt;</span><br><span class="line">        &lt;configuration&gt;</span><br><span class="line">          &lt;port&gt;80&lt;/port&gt;</span><br><span class="line">          &lt;path&gt;/&lt;/path&gt;</span><br><span class="line">        &lt;/configuration&gt;</span><br><span class="line">      &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">  &lt;/build&gt;</span><br></pre></td></tr></table></figure></li><li><p>创建SpringMVC控制器类（等同于我们前面做的Servlet）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//定义Controller，使用@Controller定义Bean</span><br><span class="line">@Controller</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    //设置当前访问路径，使用@RequestMapping</span><br><span class="line">    @RequestMapping(&quot;/save&quot;)</span><br><span class="line">    //设置当前对象的返回值类型</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String save()&#123;</span><br><span class="line">        System.out.println(&quot;user save ...&quot;);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;SpringMVC&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>初始化SpringMVC环境（同Spring环境），设定SpringMVC加载对应的Bean</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//创建SpringMVC的配置文件，加载controller对应的bean</span><br><span class="line">@Configuration</span><br><span class="line">//</span><br><span class="line">@ComponentScan(&quot;com.blog.controller&quot;)</span><br><span class="line">public class SpringMvcConfig &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>初始化Servlet容器，加载SpringMVC环境，并设置SpringMVC技术处理的请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//定义一个servlet容器的配置类，在里面加载Spring的配置，继承AbstractDispatcherServletInitializer并重写其方法</span><br><span class="line">public class ServletContainerInitConfig extends AbstractDispatcherServletInitializer &#123;</span><br><span class="line">    //加载SpringMvc容器配置</span><br><span class="line">    protected WebApplicationContext createServletApplicationContext() &#123;</span><br><span class="line">        AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();</span><br><span class="line">        context.register(SpringMvcConfig.class);</span><br><span class="line">        return context;</span><br><span class="line">    &#125;</span><br><span class="line">    //设置哪些请求归SpringMvc处理</span><br><span class="line">    protected String[] getServletMappings() &#123;</span><br><span class="line">        //所有请求都交由SpringMVC处理</span><br><span class="line">        return new String[]&#123;&quot;/&quot;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //加载Spring容器配置</span><br><span class="line">    protected WebApplicationContext createRootApplicationContext() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>访问<code>http://localhost:8080/save</code></p></li></ol><p>注意事项</p><ul><li>SpringMVC是基于Spring的，在pom.xml只导入了<code>spring-webmvc</code>jar包的原因是它会自动依赖spring相关坐标</li><li><code>AbstractDispatcherServletInitializer</code>类是SpringMVC提供的快速初始化Web3.0容器的抽象类</li><li>AbstractDispatcherServletInitializer 提供了三个接口方法供用户实现<ul><li><code>createServletApplicationContext</code>方法，创建Servlet容器时，加载SpringMVC对应的bean并放入<code>WebApplicationContext</code>对象范围中，而<code>WebApplicationContext</code>的作用范围为<code>ServletContext</code>范围，即整个web容器范围</li><li><code>getServletMappings</code>方法，设定SpringMVC对应的请求映射路径，即SpringMVC拦截哪些请求</li><li><code>createRootApplicationContext</code>方法，如果创建Servlet容器时需要加载非SpringMVC对应的bean，使用当前方法进行，使用方式和<code>createServletApplicationContext</code>相同。</li></ul></li><li><code>createServletApplicationContext</code>用来加载SpringMVC环境</li><li><code>createRootApplicationContext</code>用来加载Spring环境</li></ul><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>知识点1：<code>@Controller</code></p><table><thead><tr><th align="center">名称</th><th align="center">@Controller</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">类注解</td></tr><tr><td align="center">位置</td><td align="center">SpringMVC控制器类定义上方</td></tr><tr><td align="center">作用</td><td align="center">设定SpringMVC的核心控制器bean</td></tr></tbody></table><p>知识点2：<code>@RequestMapping</code></p><table><thead><tr><th align="center">名称</th><th align="center">@RequestMapping</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">类注解或方法注解</td></tr><tr><td align="center">位置</td><td align="center">SpringMVC控制器类或方法定义上方</td></tr><tr><td align="center">作用</td><td align="center">设置当前控制器方法请求访问路径</td></tr><tr><td align="center">相关属性</td><td align="center">value(默认)，请求访问路径</td></tr></tbody></table><p>知识点3：<code>@ResponseBody</code></p><table><thead><tr><th align="center">名称</th><th align="center">@ResponseBody</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">类注解或方法注解</td></tr><tr><td align="center">位置</td><td align="center">SpringMVC控制器类或方法定义上方</td></tr><tr><td align="center">作用</td><td align="center">设置当前控制器方法响应内容为当前返回值，无需解析</td></tr></tbody></table><h3 id="入门案例小结"><a href="#入门案例小结" class="headerlink" title="入门案例小结"></a>入门案例小结</h3><ul><li>一次性工作<ul><li>创建工程，设置服务器，加载工程</li><li>导入坐标</li><li>创建web容器启动类，加载SpringMVC配置，并设置SpringMVC请求拦截路径</li><li>SpringMVC核心配置类（设置配置类，扫描controller包，加载Controller控制器bean）</li></ul></li><li>多次工作<ul><li>定义处理请求的控制器类</li><li>定义处理请求的控制器方法，并配置映射路径（@RequestMapping）与返回json数据（@ResponseBody）</li></ul></li></ul><h3 id="工作流程解析"><a href="#工作流程解析" class="headerlink" title="工作流程解析"></a>工作流程解析</h3><p>这里将SpringMVC分为两个阶段来分析，分别是<code>启动服务器初始化过程</code>和<code>单次请求过程</code></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310082230497.png"></p><h4 id="启动服务器初始化过程"><a href="#启动服务器初始化过程" class="headerlink" title="启动服务器初始化过程"></a>启动服务器初始化过程</h4><ol><li><p>服务器启动，执行ServletContainerInitConfig类，初始化web容器</p><p>功能类似于web.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ServletContainerInitConfig extends AbstractDispatcherServletInitializer &#123;</span><br><span class="line"></span><br><span class="line">    protected WebApplicationContext createServletApplicationContext() &#123;</span><br><span class="line">        AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();</span><br><span class="line">        context.register(SpringMvcConfig.class);</span><br><span class="line">        return context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected String[] getServletMappings() &#123;</span><br><span class="line">        return new String[]&#123;&quot;/&quot;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected WebApplicationContext createRootApplicationContext() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行createServletApplicationContext方法，创建了WebApplicationContext对象</p><p>该方法加载SpringMVC的配置类SpringMvcConfig来初始化SpringMVC的容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected WebApplicationContext createServletApplicationContext() &#123;</span><br><span class="line">    AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();</span><br><span class="line">    context.register(SpringMvcConfig.class);</span><br><span class="line">    return context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>加载SpringMvcConfig配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.blog.controller&quot;)</span><br><span class="line">public class SpringMvcConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行@ComponentScan加载对应的bean</p><p>扫描指定包及其子包下所有类上的注解，如Controller类上的<code>@Controller</code>注解</p></li><li><p>加载UserController，每个@RequestMapping的名称对应一个具体的方法</p><p>此时就建立了 <code>/save</code> 和 <code>save()</code>方法的对应关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    @RequestMapping(&quot;/save&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String save()&#123;</span><br><span class="line">        System.out.println(&quot;user save ...&quot;);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;SpringMVC&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行getServletMappings方法，设定SpringMVC拦截请求的路径规则</p><p><code>/</code>代表所拦截请求的路径规则，只有被拦截后才能交给SpringMVC来处理请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected String[] getServletMappings() &#123;</span><br><span class="line">    return new String[]&#123;&quot;/&quot;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="单次请求过程"><a href="#单次请求过程" class="headerlink" title="单次请求过程"></a>单次请求过程</h4><ol><li><p>发送请求<code>http://localhost:8080/save</code></p></li><li><p>web容器发现该请求满足SpringMVC拦截规则，将请求交给SpringMVC处理</p></li><li><p>解析请求路径&#x2F;save</p></li><li><p>由&#x2F;save匹配执行对应的方法save()</p><p>上面的第5步已经将请求路径和方法建立了对应关系，通过<code>/save</code>就能找到对应的<code>save()</code>方法</p></li><li><p>执行<code>save()</code></p></li><li><p>检测到有<code>@ResponseBody</code>直接将<code>save()</code>方法的返回值作为响应体返回给请求方</p></li></ol><h3 id="Bean加载控制"><a href="#Bean加载控制" class="headerlink" title="Bean加载控制"></a>Bean加载控制</h3><p>入门案例的内容已经做完了，在入门案例中我们创建过一个<code>SpringMvcConfig</code>的配置类，在之前学习Spring的时候也创建过一个配置类<code>SpringConfig</code>。这两个配置类都需要加载资源，那么它们分别都需要加载哪些内容?</p><p> 我们先来回顾一下项目结构<br><code>com.blog</code>下有<code>config</code>、<code>controller</code>、<code>service</code>、<code>dao</code>这四个包</p><p>config目录存入的是配置类，写过的配置类有:</p><ul><li>ServletContainersInitConfig</li><li>SpringConfig</li><li>SpringMvcConfig</li><li>JdbcConfig</li><li>MybatisConfig</li></ul><p>controller目录存放的是<code>SpringMVC</code>的<code>controller</code>类</p><p>service目录存放的是<code>service</code>接口和实现类</p><p>dao目录存放的是<code>dao/Mapper</code>接口</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310082239376.png"></p><p>controller、service和dao这些类都需要被容器管理成bean对象，那么到底是该让<code>SpringMVC</code>加载还是让<code>Spring</code>加载呢?</p><ul><li>SpringMVC控制的bean<ul><li>表现层bean,也就是<code>controller</code>包下的类</li></ul></li><li>Spring控制的bean<ul><li>业务bean(<code>Service</code>)</li><li>功能bean(<code>DataSource</code>,<code>SqlSessionFactoryBean</code>,<code>MapperScannerConfigurer</code>等)</li></ul></li></ul><p>分析清楚谁该管哪些bean以后，接下来要解决的问题是如何让<code>Spring</code>和<code>SpringMVC</code>分开加载各自的内容。</p><h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>对于上面的问题，解决方案也比较简单</p><ul><li>加载Spring控制的bean的时候，<code>排除掉</code>SpringMVC控制的bean</li></ul><p>那么具体该如何实现呢？</p><ul><li>方式一：Spring加载的bean设定扫描范围<code>com.blog</code>，排除掉<code>controller</code>包内的bean</li><li>方式二：Spring加载的bean设定扫描范围为精确扫描，具体到<code>service</code>包，<code>dao</code>包等</li><li>方式三：不区分Spring与SpringMVC的环境，加载到同一个环境中(<code>了解即可</code>)</li></ul><h4 id="设置bean加载控制"><a href="#设置bean加载控制" class="headerlink" title="设置bean加载控制"></a>设置bean加载控制</h4><p>运行App运行类，如果Spring配置类扫描到了UserController类，则会正常输出，否则将报错<br>当前配置环境下，将正常输出</p><p>方案一：修改Spring配置类，设定扫描范围为精准范围</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&#123;&quot;com.blog.dao&quot;,&quot;com.blog.service&quot;&#125;)</span><br><span class="line">public class SpringConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行App运行类，报错<code>NoSuchBeanDefinitionException</code>，说明Spring配置类没有扫描到UserController，目的达成</p><p>方案二：修改Spring配置类，设定扫描范围为com.blog，排除掉controller包中的bean</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">@Configuration</span><br><span class="line">@ComponentScan(value = &quot;com.blog&quot;,</span><br><span class="line">    excludeFilters = @ComponentScan.Filter(</span><br><span class="line">            type = FilterType.ANNOTATION,</span><br><span class="line">            classes = Controller.class</span><br><span class="line">    ))</span><br><span class="line">public class SpringConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>excludeFilters属性：设置扫描加载bean时，排除的过滤规则</li><li>type属性：设置排除规则，当前使用按照bean定义时的注解类型进行排除<ul><li>ANNOTATION：按照注解排除</li><li>ASSIGNABLE_TYPE:按照指定的类型过滤</li><li>ASPECTJ:按照Aspectj表达式排除，基本上不会用</li><li>REGEX:按照正则表达式排除</li><li>CUSTOM:按照自定义规则排除</li></ul></li><li>classes属性：设置排除的具体注解类，当前设置排除<code>@Controller</code>定义的bean</li></ul><p>运行程序之前，我们还需要把<code>SpringMvcConfig</code>配置类上的<code>@ComponentScan</code>注解注释掉，否则不会报错，将正常输出</p><ul><li>出现问题的原因是<ul><li>Spring配置类扫描的包是<code>com.blog</code></li><li>SpringMVC的配置类，<code>SpringMvcConfig</code>上有一个<code>@Configuration</code>注解，也会被Spring扫描到</li><li>SpringMvcConfig上又有一个<code>@ComponentScan</code>，把controller类又给扫描进来了</li><li>所以如果不把<code>@ComponentScan</code>注释掉，Spring配置类将Controller排除，但是因为扫描到SpringMVC的配置类，又将其加载回来，演示的效果就出不来</li><li>解决方案，也简单，把SpringMVC的配置类移出Spring配置类的扫描范围即可。</li></ul></li></ul><p>运行程序，同样报错<code>NoSuchBeanDefinitionException</code>，目的达成</p><p>最后一个问题，有了Spring的配置类，要想在tomcat服务器启动将其加载，我们需要修改ServletContainersInitConfig</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class ServletContainerInitConfig extends AbstractDispatcherServletInitializer &#123;</span><br><span class="line">    //加载SpringMvc配置</span><br><span class="line">    protected WebApplicationContext createServletApplicationContext() &#123;</span><br><span class="line">        AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();</span><br><span class="line">        context.register(SpringMvcConfig.class);</span><br><span class="line">        return context;</span><br><span class="line">    &#125;</span><br><span class="line">    //设置哪些请求归SpringMvc处理</span><br><span class="line">    protected String[] getServletMappings() &#123;</span><br><span class="line">        return new String[]&#123;&quot;/&quot;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //加载Spring容器配置</span><br><span class="line">    protected WebApplicationContext createRootApplicationContext() &#123;</span><br><span class="line">        AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();</span><br><span class="line">        context.register(SpringConfig.class);</span><br><span class="line">        return context;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面的<code>ServletContainerInitConfig</code>配置类，Spring还提供了一种更简单的配置方式，可以不用再去创建<code>AnnotationConfigWebApplicationContext</code>对象，不用手动<code>register</code>对应的配置类<br>我们改用继承它的子类<code>AbstractAnnotationConfigDispatcherServletInitializer</code>，然后重写三个方法即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ServletContainerInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer &#123;</span><br><span class="line"></span><br><span class="line">    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        return new Class[]&#123;SpringConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        return new Class[]&#123;SpringMvcConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected String[] getServletMappings() &#123;</span><br><span class="line">        return new String[]&#123;&quot;/&quot;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p>知识点：<code>@ComponentScan</code></p><table><thead><tr><th align="center">名称</th><th align="center">@ComponentScan</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">类注解</td></tr><tr><td align="center">位置</td><td align="center">类定义上方</td></tr><tr><td align="center">作用</td><td align="center">设置spring配置类扫描路径，用于加载使用注解格式定义的bean</td></tr><tr><td align="center">相关属性</td><td align="center">excludeFilters:排除扫描路径中加载的bean,需要指定类别(type)和具体项(classes) includeFilters:加载指定的bean，需要指定类别(type)和具体项(classes)</td></tr></tbody></table><h2 id="请求与响应"><a href="#请求与响应" class="headerlink" title="请求与响应"></a>请求与响应</h2><p>SpringMVC是web层的框架，主要的作用是接收请求、接收数据、响应结果。<br>所以这部分是学习SpringMVC的重点内容，这里主要会讲解四部分内容:</p><ul><li>请求映射路径</li><li>请求参数</li><li>日期类型参数传递</li><li>响应JSON数据</li></ul><h3 id="设置请求映射路径"><a href="#设置请求映射路径" class="headerlink" title="设置请求映射路径"></a>设置请求映射路径</h3><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><ol><li><p>创建一个Maven项目</p></li><li><p>导入坐标，这里暂时只导<code>servlet</code>和<code>springmvc</code>的就行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--servlet--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--springmvc--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>编写UserController和BookController</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/save&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String save()&#123;</span><br><span class="line">        System.out.println(&quot;user save ..&quot;);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;user save&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/delete&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String delete()&#123;</span><br><span class="line">        System.out.println(&quot;user delete ..&quot;);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;user delete&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class BookController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/save&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String save()&#123;</span><br><span class="line">        System.out.println(&quot;book save ..&quot;);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;book module&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建<code>SpringMvcConfig</code>配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.blog.controller&quot;)</span><br><span class="line">public class SpringMvcConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建<code>ServletContainersInitConfig</code>类，初始化web容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer &#123;</span><br><span class="line">    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        return new Class[0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        return new Class[]&#123;SpringMvcConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected String[] getServletMappings() &#123;</span><br><span class="line">        return new String[]&#123;&quot;/&quot;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>直接启动Tomcat服务器，会报错</p><blockquote><p>com.blog.controller.UserController#save()<br>to { &#x2F;save}: There is already ‘bookController’ bean method<br>com.blog.controller.BookController#save() mapped.</p></blockquote><p>从错误信息可以看出:</p><ul><li><code>UserController</code>有一个save方法，访问路径为<code>http://localhost/save</code></li><li><code>BookController</code>也有一个save方法，访问路径为<code>http://localhost/save</code></li><li>当访问<code>http://localhost/save</code>的时候，到底是访问<code>UserController</code>还是<code>BookController</code>?</li></ul></li></ol><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>团队多人开发，每人设置不同的请求路径，冲突问题该如何解决?</p><ul><li>解决思路:为不同模块设置模块名作为请求路径前置<ul><li>对于Book模块的save,将其访问路径设置<code>http://localhost/book/save</code></li><li>对于User模块的save,将其访问路径设置<code>http://localhost/user/save</code></li></ul></li></ul><p>这样在同一个模块中出现命名冲突的情况就比较少了。</p><h4 id="设置映射路径"><a href="#设置映射路径" class="headerlink" title="设置映射路径"></a>设置映射路径</h4><ol><li><p>修改Controller</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/user/save&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String save()&#123;</span><br><span class="line">        System.out.println(&quot;user save ..&quot;);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;user save&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/user/delete&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String delete()&#123;</span><br><span class="line">        System.out.println(&quot;user delete ..&quot;);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;user delete&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class BookController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/book/save&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String save()&#123;</span><br><span class="line">        System.out.println(&quot;book save ..&quot;);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;book module&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题是解决了，但是每个方法前面都需要进行修改，写起来比较麻烦而且还有很多重复代码，如果&#x2F;user后期发生变化，所有的方法都需要改，耦合度太高。</p></li><li><p>优化路径配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/user&quot;)</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/save&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String save()&#123;</span><br><span class="line">        System.out.println(&quot;user save ..&quot;);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;user save&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/delete&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String delete()&#123;</span><br><span class="line">        System.out.println(&quot;user delete ..&quot;);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;user delete&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/book&quot;)</span><br><span class="line">public class BookController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/save&quot;)s</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String save()&#123;</span><br><span class="line">        System.out.println(&quot;book save ..&quot;);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;book module&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:</p><ul><li>当类上和方法上都添加了<code>@RequestMapping</code>注解，前端发送请求的时候，要和两个注解的value值相加匹配才能访问到。</li><li><code>@RequestMapping</code>注解value属性前面加不加<code>/</code>都可以</li></ul></li></ol><h3 id="五种类型参数传递"><a href="#五种类型参数传递" class="headerlink" title="五种类型参数传递"></a>五种类型参数传递</h3><p>前面我们已经能够使用GET或POST来发送请求和数据，所携带的数据都是比较简单的数据，接下来在这个基础上，我们来研究一些比较复杂的参数传递，常见的参数种类有</p><ul><li>普通类型</li><li>POJO类型参数</li><li>嵌套POJO类型参数</li><li>数组类型参数</li><li>集合类型参数</li></ul><p>下面我们就来挨个学习这五种类型参数如何发送，后台如何接收</p><h4 id="普通类型"><a href="#普通类型" class="headerlink" title="普通类型"></a>普通类型</h4><p>普通参数：url地址传参，地址参数名与形参变量名相同，定义形参即可接收参数。</p><ul><li>发送请求与参数：<code>localhost:8080/user/commonParam?name=Helsing&amp;age=1024</code></li><li>后台接收参数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/user&quot;)</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/commonParam&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String commonParam(String name,int age)&#123;</span><br><span class="line">        System.out.println(&quot;普通参数传递name --&gt; &quot; + name);</span><br><span class="line">        System.out.println(&quot;普通参数传递age --&gt; &quot; + age);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;commonParam&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果形参与地址参数名不一致该如何解决?例如地址参数名为<code>username</code>，而形参变量名为<code>name</code>，因为前端给的是<code>username</code>，后台接收使用的是<code>name</code>,两个名称对不上，会导致接收数据失败</p><p>解决方案：使用@RequestParam注解</p><ul><li><p>发送请求与参数：<code>localhost:8080/user/commonParam?username=Helsing&amp;age=1024</code></p></li><li><p>后台接收参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/user&quot;)</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/commonParam&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String commonParam(@RequestParam(&quot;username&quot;) String name, int age)&#123;</span><br><span class="line">        System.out.println(&quot;普通参数传递name --&gt; &quot; + name);</span><br><span class="line">        System.out.println(&quot;普通参数传递age --&gt; &quot; + age);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;commonParam&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="POJO数据类型"><a href="#POJO数据类型" class="headerlink" title="POJO数据类型"></a>POJO数据类型</h4><p>“Plain Old Java Object”“简单java对象”。POJO的内在含义是指那些没有从任何类继承、也没有实现任何接口，更没有被其它框架侵入的java对象。</p><p>简单数据类型一般处理的是参数个数比较少的请求，如果参数比较多，那么后台接收参数的时候就比较复杂，这个时候我们可以考虑使用POJO数据类型。</p><ul><li>POJO参数：请求参数名与形参对象属性名相同，定义POJO类型形参即可接收参数</li></ul><p>此时需要使用前面准备好的两个POJO类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public User() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public User(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Address &#123;</span><br><span class="line">    private String province;</span><br><span class="line">    private String city;</span><br><span class="line"></span><br><span class="line">    public String getProvince() &#123;</span><br><span class="line">        return province;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setProvince(String province) &#123;</span><br><span class="line">        this.province = province;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getCity() &#123;</span><br><span class="line">        return city;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCity(String city) &#123;</span><br><span class="line">        this.city = city;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Address() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Address(String province, String city) &#123;</span><br><span class="line">        this.province = province;</span><br><span class="line">        this.city = city;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Address&#123;&quot; +</span><br><span class="line">                &quot;province=&#x27;&quot; + province + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, city=&#x27;&quot; + city + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送请求和参数：<code>localhost:8080/user/pojoParam?name=Helsing&amp;age=1024</code>。后台接收参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//POJO参数：请求参数与形参对象中的属性对应即可完成参数传递</span><br><span class="line">@RequestMapping(&quot;/pojoParam&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String pojoParam(User user)&#123;</span><br><span class="line">    System.out.println(&quot;POJO参数传递user --&gt; &quot; + user);</span><br><span class="line">    return &quot;&#123;&#x27;module&#x27;:&#x27;pojo param&#x27;&#125;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意:</p><ul><li>POJO参数接收，前端GET和POST发送请求数据的方式不变。</li><li>请求参数key的名称要和POJO中属性的名称一致，否则无法封装。</li></ul></blockquote><h4 id="嵌套POJO类型"><a href="#嵌套POJO类型" class="headerlink" title="嵌套POJO类型"></a>嵌套POJO类型</h4><p>我们先将之前写的Address类，嵌套在User类中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    private Address address;</span><br><span class="line"></span><br><span class="line">    public Address getAddress() &#123;</span><br><span class="line">        return address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAddress(Address address) &#123;</span><br><span class="line">        this.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public User() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public User(String name, int age, Address address) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &quot;, address=&quot; + address +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嵌套POJO参数：请求参数名与形参对象属性名相同，按照对象层次结构关系即可接收嵌套POJO属性参数</p><p>发送请求和参数：<code>localhost:8080/user/pojoParam?name=Helsing&amp;age=1024&amp;address.province=Beijing&amp;address.city=Beijing</code></p><p>后台接收参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/pojoParam&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String pojoParam(User user)&#123;</span><br><span class="line">    System.out.println(&quot;POJO参数传递user --&gt; &quot; + user);</span><br><span class="line">    return &quot;&#123;&#x27;module&#x27;:&#x27;pojo param&#x27;&#125;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h4><p>举个简单的例子，如果前端需要获取用户的爱好，爱好绝大多数情况下都是多选，如何发送请求数据和接收数据呢?</p><p>数组参数：请求参数名与形参对象属性名相同且请求参数为多个，定义数组类型即可接收参数</p><p>发送请求和参数：<code>localhost:8080/user/arrayParam?hobbies=sing&amp;hobbies=jump&amp;hobbies=rap&amp;hobbies=basketball</code></p><p>后台接收参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/arrayParam&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String arrayParam(String[] hobbies)&#123;</span><br><span class="line">    System.out.println(&quot;数组参数传递user --&gt; &quot; + Arrays.toString(hobbies));</span><br><span class="line">    return &quot;&#123;&#x27;module&#x27;:&#x27;array param&#x27;&#125;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h4><p>数组能接收多个值，那么集合是否也可以实现这个功能呢?</p><p>发送请求和参数：<code>localhost:8080/user/listParam?hobbies=sing&amp;hobbies=jump&amp;hobbies=rap&amp;hobbies=basketball</code></p><p>后台接收参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/listParam&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String listParam(List hobbies) &#123;</span><br><span class="line">    System.out.println(&quot;集合参数传递user --&gt; &quot; + hobbies);</span><br><span class="line">    return &quot;&#123;&#x27;module&#x27;:&#x27;list param&#x27;&#125;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalArgumentException: Cannot generate variable name for non-typed Collection parameter type</span><br></pre></td></tr></table></figure><p>错误原因：SpringMVC将List看做是一个POJO对象来处理，将其创建一个对象并准备把前端的数据封装到对象中，但是List是一个接口无法创建对象，所以报错。</p><p>解决方案是：使用<code>@RequestParam</code>注解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/listParam&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String listParam(@RequestParam List hobbies) &#123;</span><br><span class="line">    System.out.println(&quot;集合参数传递user --&gt; &quot; + hobbies);</span><br><span class="line">    return &quot;&#123;&#x27;module&#x27;:&#x27;list param&#x27;&#125;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解</p><p>@RequestParam</p><table><thead><tr><th align="center">名称</th><th align="center">@RequestParam</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">形参注解</td></tr><tr><td align="center">位置</td><td align="center">SpringMVC控制器方法形参定义前面</td></tr><tr><td align="center">作用</td><td align="center">绑定请求参数与处理器方法形参间的关系</td></tr><tr><td align="center">相关参数</td><td align="center">required：是否为必传参数 defaultValue：参数默认值</td></tr></tbody></table><h3 id="JSON数据传输参数"><a href="#JSON数据传输参数" class="headerlink" title="JSON数据传输参数"></a>JSON数据传输参数</h3><p>现在比较流行的开发方式为异步调用。前后台以异步方式进行交换，传输的数据使用的是JSON，所以前端如果发送的是JSON数据，后端该如何接收?</p><p>对于JSON数据类型，我们常见的有三种:</p><ul><li>json普通数组（[“value1”,“value2”,“value3”,…]）</li><li>json对象（{key1:value1,key2:value2,…}）</li><li>json对象数组（[{key1:value1,…},{key2:value2,…}]）</li></ul><p>下面我们就来学习以上三种数据类型，前端如何发送，后端如何接收</p><h4 id="JSON普通数组"><a href="#JSON普通数组" class="headerlink" title="JSON普通数组"></a>JSON普通数组</h4><ol><li><p>导入坐标</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>开启SpringMVC注解支持<br>使用<code>@EnableWebMvc</code>，在SpringMVC的配置类中开启SpringMVC的注解支持，这里面就包含了将JSON转换成对象的功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.blog.controller&quot;)</span><br><span class="line">//开启json数据类型自动转换</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class SpringMvcConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>PostMan发送JSON数据</p></li><li><p>后台接收参数，参数前添加<code>@RequestBody</code><br>使用<code>@RequestBody</code>注解将外部传递的json数组数据映射到形参的集合对象中作为数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/jsonArrayParam&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String jsonArrayParam(@RequestBody List&lt;String&gt; hobbies) &#123;</span><br><span class="line">    System.out.println(&quot;JSON数组参数传递hobbies --&gt; &quot; + hobbies);</span><br><span class="line">    return &quot;&#123;&#x27;module&#x27;:&#x27;json array param&#x27;&#125;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="JSON对象"><a href="#JSON对象" class="headerlink" title="JSON对象"></a>JSON对象</h4><p>请求和数据的发送:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;:&quot;菲茨罗伊&quot;,</span><br><span class="line">        &quot;age&quot;:&quot;27&quot;,</span><br><span class="line">        &quot;address&quot;:&#123;</span><br><span class="line">            &quot;city&quot;:&quot;萨尔沃&quot;,</span><br><span class="line">            &quot;province&quot;:&quot;外域&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;:&quot;地平线&quot;,</span><br><span class="line">        &quot;age&quot;:&quot;136&quot;,</span><br><span class="line">        &quot;address&quot;:&#123;</span><br><span class="line">            &quot;city&quot;:&quot;奥林匹斯&quot;,</span><br><span class="line">            &quot;province&quot;:&quot;外域&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>接收请求和参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/jsonPojoListParam&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String jsonPojoListParam(@RequestBody List&lt;User&gt; users) &#123;</span><br><span class="line">    System.out.println(&quot;JSON对象数组参数传递user --&gt; &quot; + users);</span><br><span class="line">    return &quot;&#123;&#x27;module&#x27;:&#x27;json pojo list param&#x27;&#125;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>SpringMVC接收JSON数据的实现步骤为:</p><ol><li>导入jackson包</li><li>开启SpringMVC注解驱动，在配置类上添加<code>@EnableWebMvc</code>注解</li><li>使用PostMan发送JSON数据</li><li>Controller方法的参数前添加<code>@RequestBody</code>注解</li></ol><h4 id="注解-1"><a href="#注解-1" class="headerlink" title="注解"></a>注解</h4><p>知识点1：<code>@EnableWebMvc</code></p><table><thead><tr><th align="center">名称</th><th align="center">@EnableWebMvc</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">配置类注解</td></tr><tr><td align="center">位置</td><td align="center">SpringMVC配置类定义上方</td></tr><tr><td align="center">作用</td><td align="center">开启SpringMVC多项辅助功能</td></tr></tbody></table><p>知识点2：<code>@RequestBody</code></p><table><thead><tr><th align="center">名称</th><th align="center">@RequestBody</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">形参注解</td></tr><tr><td align="center">位置</td><td align="center">SpringMVC控制器方法形参定义前面</td></tr><tr><td align="center">作用</td><td align="center">将请求中请求体所包含的数据传递给请求参数，此注解一个处理器方法只能使用一次</td></tr></tbody></table><p><code>@RequestBody</code>与<code>@RequestParam</code>区别</p><ul><li>区别<ul><li><code>@RequestParam</code>用于接收url地址传参，表单传参【application&#x2F;x-www-form-urlencoded】</li><li><code>@RequestBody</code>用于接收json数据【application&#x2F;json】</li></ul></li><li>应用<ul><li>后期开发中，发送json格式数据为主，<code>@RequestBody</code>应用较广</li><li>如果发送非json格式数据，选用<code>@RequestParam</code>接收请求参数</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
            <tag> MVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC中</title>
      <link href="/2023/10/02/JUC%E4%B8%AD%E7%AF%87/"/>
      <url>/2023/10/02/JUC%E4%B8%AD%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="共享模型之内存"><a href="#共享模型之内存" class="headerlink" title="共享模型之内存"></a>共享模型之内存</h1><p>上一章讲解的Monitor主要关注的是访问共享变量时，保证临界区代码的原子性</p><p>这一章我们进一步深入学习共享变量在多线程间的<strong>可见性</strong>问题与多条指令执行时的<strong>有序性</strong>问题</p><h2 id="Java-内存模型（JMM）"><a href="#Java-内存模型（JMM）" class="headerlink" title="Java 内存模型（JMM）"></a>Java 内存模型（JMM）</h2><p>JMM 即 Java Memory Model，它定义了主存（共享内存）、工作内存（线程私有）抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、 CPU 指令优化等。</p><ul><li>主内存：计算机的内存，也就是经常提到的 8G 内存，16G 内存，存储所有共享变量的值</li><li>工作内存：存储该线程使用到的共享变量在主内存的的值的副本拷贝</li></ul><blockquote><p><strong>JVM 和 JMM 之间的关系</strong>：JMM 中的主内存、工作内存与 JVM 中的 Java 堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的</p></blockquote><p>JMM 体现在以下几个方面</p><ul><li>原子性 - 保证指令不会受到线程上下文切换的影响</li><li>可见性 - 保证指令不会受 cpu 缓存的影响</li><li>有序性 - 保证指令不会受 cpu 指令并行优化的影响</li></ul><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><h4 id="退不出的循环"><a href="#退不出的循环" class="headerlink" title="退不出的循环"></a>退不出的循环</h4><p>首先看一段代码：</p><p>public static boolean run &#x3D; true;</p><pre><code>public static void main(String[] args) &#123;    Thread t1 = new Thread(() -&gt; &#123;        while(run) &#123;        &#125;    &#125;, &quot;t1&quot;);    t1.start();    try &#123;        Thread.sleep(1000);    &#125; catch (InterruptedException e) &#123;        e.printStackTrace();    &#125;    log.info(&quot;t1 Stop&quot;);    run = false;&#125;</code></pre><p>首先 t1 线程运行，然后过一秒，主线程设置 run 的值为 false，想让 t1 线程停止下来，但是 t1 线程并没有停，分析如下图：<img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20210202131314474.png"></p><ol><li>初始状态，t 线程刚开始从主内存读取了run的值到工作内存。</li><li>因为t线程要频繁从主内存中读取run的值，JIT 编译器会将run的值缓存至自己工作内存中的高速缓存中，减少对主存中run的访问，提高效率</li><li>1秒之后，main线程修改了run的值，并同步至主存，而t是从自己工作内存中的高速缓存中读取这个变<br>量的值，结果永远是B值</li></ol><blockquote></blockquote><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ul><li>使用 volatile （易变关键字）</li><li>volatile 可以用来修饰成员变量和静态成员变量（放在主存中的变量），他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存</li></ul><h3 id="可见性与原子性"><a href="#可见性与原子性" class="headerlink" title="可见性与原子性"></a>可见性与原子性</h3><p>上面例子体现的实际就是可见性，它保证的是在多个线程之间，一个线程对volatile 变量的修改对另一个线程可见， 不能保证原子性，仅用在一个写线程，多个读线程的情况。</p><p>字节码</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li><p>synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是synchronized 是属于重量级操作，性能相对更低。</p></li><li><p>如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到对 run 变量的修改了，想一想为什么？</p><p>因为 printIn() 方法使用了 synchronized 同步代码块，可以保证原子性与可见性，它是 PrintStream 类的方法。</p></li></ul><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><h4 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h4><p>首先看一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 可以重排的例子 </span><br><span class="line">int a = 10; </span><br><span class="line">int b = 20; </span><br><span class="line">System.out.println( a + b );</span><br><span class="line"></span><br><span class="line">// 不能重排的例子 </span><br><span class="line">int a = 10;</span><br><span class="line">int b = a - 5;</span><br></pre></td></tr></table></figure><p>指令重排简单来说可以，在程序结果不受影响的前提下，可以调整指令语句执行顺序。多线程下指令重排会影响正确性。</p><h4 id="多线程下指令重排问题"><a href="#多线程下指令重排问题" class="headerlink" title="多线程下指令重排问题"></a>多线程下指令重排问题</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int num = 0;</span><br><span class="line"></span><br><span class="line">// volatile 修饰的变量，可以禁用指令重排 volatile boolean ready = false; 可以防止变量之前的代码被重排序</span><br><span class="line">boolean ready = false; </span><br><span class="line">// 线程1 执行此方法</span><br><span class="line">public void actor1(I_Result r) &#123;</span><br><span class="line"> if(ready) &#123;</span><br><span class="line"> r.r1 = num + num;</span><br><span class="line"> &#125; </span><br><span class="line"> else &#123;</span><br><span class="line"> r.r1 = 1;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 线程2 执行此方法</span><br><span class="line">public void actor2(I_Result r) &#123;</span><br><span class="line"> num = 2;</span><br><span class="line"> ready = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在多线程环境下，以上的代码 r1 的值有三种情况：</p><ol><li>线程 2 先执行，然后线程 1 后执行，r1 的结果为 4</li><li>线程 1 先执行，然后线程 2 后执行，r1 的结果为 1</li><li>线程 2 先执行，但是发送了指令重排，num &#x3D; 2 与 ready &#x3D; true 这两行代码语序发生装换，然后执行 ready &#x3D; true 后，线程 1 运行了，那么 r1 的结果是为 0。</li></ol><blockquote><p>volatile 修饰的变量，可以禁用指令重排，禁止的是加 volatile 关键字变量<strong>之前的代码</strong>重排序</p></blockquote><h4 id="原理之-volatile"><a href="#原理之-volatile" class="headerlink" title="原理之 volatile"></a>原理之 volatile</h4><p>volatile 的底层实现原理是内存屏障，Memory Barrier（Memory Fence）</p><ul><li>对 volatile 变量的写指令后会加入写屏障</li><li>对 volatile 变量的读指令前会加入读屏障</li></ul><h5 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h5><ul><li><p>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void actor2(I_Result r) &#123;</span><br><span class="line">    num = 2;</span><br><span class="line">    ready = true; // ready 是 volatile 赋值带写屏障</span><br><span class="line">    // 写屏障</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void actor1(I_Result r) &#123;</span><br><span class="line">    // 读屏障</span><br><span class="line">    // ready 是 volatile 读取值带读屏障</span><br><span class="line">    if(ready) &#123;</span><br><span class="line">        r.r1 = num + num;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        r.r1 = 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231107101828845.png" alt="image-20231107101828845"></p><h5 id="如何保证有序性"><a href="#如何保证有序性" class="headerlink" title="如何保证有序性"></a>如何保证有序性</h5><ul><li><p>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void actor2(I_Result r) &#123;</span><br><span class="line">    num = 2;</span><br><span class="line">    ready = true; // ready 是 volatile 赋值带写屏障</span><br><span class="line">    // 写屏障</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void actor1(I_Result r) &#123;</span><br><span class="line">    // 读屏障</span><br><span class="line">    // ready 是 volatile 读取值带读屏障</span><br><span class="line">    if(ready) &#123;</span><br><span class="line">        r.r1 = num + num;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        r.r1 = 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JUC共享模型</title>
      <link href="/2023/10/02/JUC%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B/"/>
      <url>/2023/10/02/JUC%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="线程问题"><a href="#线程问题" class="headerlink" title="线程问题"></a>线程问题</h1><p>线程出现问题的根本原因是因为线程上下文切换，导致线程里的指令没有执行完就切换执行其它线程了，下面是一个经典例子</p><pre><code>static int count = 0;public static void main(String[] args) throws InterruptedException &#123;    Thread t1 = new Thread(()-&gt;&#123;        for (int i = 1;i&lt;5000;i++)&#123;            count++;        &#125;    &#125;);    Thread t2 =new Thread(()-&gt;&#123;        for (int i = 1;i&lt;5000;i++)&#123;            count--;        &#125;    &#125;);    t1.start();    t2.start();    t1.join();    t2.join();    log.debug(&quot;count的值是&#123;&#125;&quot;,count);&#125;</code></pre><p>++和– 的字节码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">getstatic i // 获取静态变量i的值</span><br><span class="line">iconst_1 // 准备常量1</span><br><span class="line">iadd // 自增</span><br><span class="line">putstatic i // 将修改后的值存入静态变量i</span><br><span class="line">    </span><br><span class="line">getstatic i // 获取静态变量i的值</span><br><span class="line">iconst_1 // 准备常量1</span><br><span class="line">isub // 自减</span><br><span class="line">putstatic i // 将修改后的值存入静态变量i</span><br></pre></td></tr></table></figure><p>可以看到<code>count++</code> 和 <code>count--</code> 操作实际都是需要这个4个指令完成的，那么这里问题就来了！Java 的内存模型如下，完成静态变量的自增，自减需要在主存和工作内存中进行数据交换，如果代码是正常按顺序运行的，那么count的值不会计算错</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202206261903116.png" alt="img"></p><div class="tabs" id="1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#1-1">正常顺序</button></li><li class="tab"><button type="button" data-href="#1-2">出现负数</button></li><li class="tab"><button type="button" data-href="#1-3">出现正数</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202206261903878.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-2"><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202206261903246.png" alt="1583569380639"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-3"><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202206261903410.png" alt="1583569416016"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="临界区和竞态条件"><a href="#临界区和竞态条件" class="headerlink" title="临界区和竞态条件"></a>临界区和竞态条件</h2><p>一个程序运行多线程本身是没有问题的问题出现在多个线程共享资源的时候</p><ol><li>多个线程同时对共享资源进行读操作本身也没有问题</li><li>问题出现在对共享资源同时进行读写操作时就有问题了</li></ol><p>临界区：一段代码内如果存在对共享资源的多线程读写操作，那么称这段代码为临界区</p><p>竞态条件：多个线程在临界区执行，那么由于代码指令的执行不确定而导致的结果问题，称为竞态条件</p><h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><p>为了避免临界区中的竞态条件发生，由多种手段可以达到，大致分2类</p><ol><li>阻塞式解决方案：synchronized ，Lock（都是互斥）</li><li>非阻塞式解决方案：原子变量</li></ol><p>现在讨论使用synchronized来进行解决，即俗称的<strong>对象锁</strong>，它采用互斥的方式让同一时刻至多只有一个线程持有对象锁，其他线程如果想获取这个锁就会阻塞住，这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换</p><blockquote><p>注意 虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的：</p><ul><li>互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区的代码</li><li>同步是由于线程执行的先后，顺序不同但是需要一个线程等待其它线程运行到某个点。</li></ul></blockquote><h2 id="synchronized语法"><a href="#synchronized语法" class="headerlink" title="synchronized语法"></a>synchronized语法</h2><ol><li><p>加在对象上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronized(对象) // 线程1获得锁， 那么线程2的状态是(blocked)</span><br><span class="line">&#123;</span><br><span class="line"> 临界区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>加在方法上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Test&#123;</span><br><span class="line">    public synchronized void test() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//等价于</span><br><span class="line">class Test&#123;</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> class Test&#123;</span><br><span class="line">     public synchronized static void test() &#123;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">// 等价于</span><br><span class="line"> class Test&#123;</span><br><span class="line">     public static void test() &#123;</span><br><span class="line">         synchronized(Test.class) &#123;</span><br><span class="line">    </span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ol><p>把上面的5000次++–上锁后，结果就一定正确了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static int counter = 0;</span><br><span class="line">static final Object room = new Object();</span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">     Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">         for (int i = 0; i &lt; 5000; i++) &#123;</span><br><span class="line">             synchronized (room) &#123;</span><br><span class="line">             counter++;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;, &quot;t1&quot;);</span><br><span class="line">     Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">         for (int i = 0; i &lt; 5000; i++) &#123;</span><br><span class="line">             synchronized (room) &#123;</span><br><span class="line">             counter--;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     &#125;, &quot;t2&quot;);</span><br><span class="line">     t1.start();</span><br><span class="line">     t2.start();</span><br><span class="line">     t1.join();</span><br><span class="line">     t2.join();</span><br><span class="line">     log.debug(&quot;&#123;&#125;&quot;,counter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上方代码，synchronized加在了循环体内，所以我们一共上了5000+5000次锁，但是加在循环外，就只上了2次锁</p><h2 id="synchronized原理"><a href="#synchronized原理" class="headerlink" title="synchronized原理"></a>synchronized原理</h2><p><strong>synchronized实际上利用对象保证了临界区代码的原子性，临界区内的代码在外界看来是不可分割的，不会被线程切换所打断</strong></p><p>你可以做这样的类比： </p><ul><li><code>synchronized(对象)</code> 中的对象，可以想象为一个房间（room），有唯一入口（门）房间只能一次进入一人进行计算，线程 t1，t2 想象成两个人 </li><li>当线程 t1 执行到 <code>synchronized(room)</code> 时就好比 t1 进入了这个房间，并锁住了门拿走了钥匙，在门内执行<code>count++</code> 代码 </li><li>这时候如果 t2 也运行到了 <code>synchronized(room)</code> 时，它发现门被锁住了，只能在门外等待，发生了上下文切换，阻塞住了 </li><li>这中间即使 t1 的 cpu 时间片不幸用完，被踢出了门外（不要错误理解为锁住了对象就能一直执行下去哦），这时门还是锁住的，t1 仍拿着钥匙，t2 线程还在阻塞状态进不来，只有下次轮到 t1 自己再次获得时间片时才能开门进入 </li><li>当 t1 执行完 <code>synchronized&#123;&#125;</code> 块内的代码，这时候才会从 obj 房间出来并解开门上的锁，唤醒 t2 线程把钥匙给他。t2 线程这时才可以进入 obj 房间，锁住了门拿上钥匙，执行它的 <code>count--</code> 代码.</li></ul><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202206261903104.png"></p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>synchronized 实际是用<strong>对象锁</strong>保证了<strong>临界区内代码的原子性</strong>，临界区内的代码对外是不可分割的，不会被线程切换所打断。 </p><p>为了加深理解，请思考下面的问题</p><ul><li>如果把 <code>synchronized(obj) </code>放在 for 循环的外面，如何理解？– 原子性 <ul><li>会对整个for循环进行加锁，只有当t2的for循环执行完成之后，t1才会继续执行</li></ul></li><li>如果 t1 <code>synchronized(obj1)</code> 而 t2 <code>synchronized(obj2)</code> 会怎样运作？– 锁对象 <ul><li>两个线程使用了不同的对象锁，仍然会出现被打断的现象</li></ul></li><li>如果 t1 <code>synchronized(obj)</code> 而 t2 没有加会怎么样？如何理解？– 锁对象<ul><li>和上面的问题类型，t1虽然能获得<strong>对象锁</strong>，但是t2执行时不会检测是否已经加锁，仍然会出现大段的现象</li></ul></li></ul><h2 id="线程八锁"><a href="#线程八锁" class="headerlink" title="线程八锁"></a>线程八锁</h2><p>线程八锁就是考察 synchronized 锁住的是哪个对象，直接百度搜索相关的实例</p><p>说明：主要关注锁住的对象是不是同一个</p><ul><li>锁住类对象，所有类的实例的方法都是安全的，类的所有实例都相当于同一把锁</li><li>锁住 this 对象，只有在当前实例对象的线程内是安全的，如果有多个实例就不安全</li></ul><ol><li><p>调用同一个对象，方法顺序随机</p><p>被synchronized修饰的方法，锁的对象是方法的调用者。因为两个方法的调用者是同一个，所以两个方法用的是同一个锁，先调用方法的先执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j(topic = &quot;c.Number&quot;)</span><br><span class="line">class Number&#123;</span><br><span class="line">    public synchronized void a() &#123;</span><br><span class="line">        log.debug(&quot;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized void b() &#123;</span><br><span class="line">        log.debug(&quot;2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Number n1 = new Number();</span><br><span class="line">    new Thread(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">    new Thread(()-&gt;&#123; n1.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用同一个对象，方法顺序随机</p><p>被synchronized修饰的方法，锁的对象是方法的调用者。因为两个方法的调用者是同一个，所以两个方法用的是同一个锁，先调用方法的先执行，第二个方法只有在第一个方法执行完释放锁之后才能执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j(topic = &quot;c.Number&quot;)</span><br><span class="line">class Number&#123;</span><br><span class="line">    public synchronized void a() &#123;</span><br><span class="line">        sleep(1);</span><br><span class="line">        log.debug(&quot;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized void b() &#123;</span><br><span class="line">        log.debug(&quot;2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Number n1 = new Number();</span><br><span class="line">    new Thread(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">    new Thread(()-&gt;&#123; n1.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>2个上锁，1个没有。没上的这个跟前面俩并发，上锁的两个并行</p><p>新增的方法没有被synchronized修饰，不是同步方法，不受锁的影响，所以不需要等待。其他线程共用了一把锁，所以还需要等待</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j(topic = &quot;c.Number&quot;)</span><br><span class="line">class Number&#123;</span><br><span class="line">    public synchronized void a() &#123;</span><br><span class="line">        sleep(1);</span><br><span class="line">        log.debug(&quot;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized void b() &#123;</span><br><span class="line">        log.debug(&quot;2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void c() &#123;</span><br><span class="line">        log.debug(&quot;3&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Number n1 = new Number();</span><br><span class="line">    new Thread(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">    new Thread(()-&gt;&#123; n1.b(); &#125;).start();</span><br><span class="line">    new Thread(()-&gt;&#123; n1.c(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建2个对象，但是这两个对象之间不互斥</p><p>被synchronized修饰的方法，锁的对象是方法的调用者。因为用了两个对象调用各自的方法，所以两个方法的调用者不是同一个，所以两个方法用的不是同一个锁，后调用的方法不需要等待先调用的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j(topic = &quot;c.Number&quot;)</span><br><span class="line">class Number&#123;</span><br><span class="line">    public synchronized void a() &#123;</span><br><span class="line">        sleep(1);</span><br><span class="line">        log.debug(&quot;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized void b() &#123;</span><br><span class="line">        log.debug(&quot;2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Number n1 = new Number();</span><br><span class="line">    Number n2 = new Number();</span><br><span class="line">    new Thread(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">    new Thread(()-&gt;&#123; n2.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>和4一样</p><p>被synchronized和static修饰的方法，锁的对象是类的class对象。仅仅被synchronized修饰的方法，锁的对象是方法的调用者。因为两个方法锁的对象不是同一个，所以两个方法用的不是同一个锁，后调用的方法不需要等待先调用的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j(topic = &quot;c.Number&quot;)</span><br><span class="line">class Number&#123;</span><br><span class="line">    public static synchronized void a() &#123;</span><br><span class="line">        sleep(1);</span><br><span class="line">        log.debug(&quot;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized void b() &#123;</span><br><span class="line">        log.debug(&quot;2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Number n1 = new Number();</span><br><span class="line">    new Thread(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">    new Thread(()-&gt;&#123; n1.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类方法上锁，实例化对象不重要</p><p>synchronized和static修饰的方法，锁的对象是类的class对象。因为两个同步方法都被static修饰了，所以两个方法用的是同一个锁，后调用的方法需要等待先调用的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j(topic = &quot;c.Number&quot;)</span><br><span class="line">class Number&#123;</span><br><span class="line">    public static synchronized void a() &#123;</span><br><span class="line">        sleep(1);</span><br><span class="line">        log.debug(&quot;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static synchronized void b() &#123;</span><br><span class="line">        log.debug(&quot;2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Number n1 = new Number();</span><br><span class="line">    new Thread(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">    new Thread(()-&gt;&#123; n1.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将两个方法中有Thread.sleep()的方法设置为static方法，另一个方法去掉static修饰，让两个线程用两个对象调用两个方法</p><p>被synchronized和static修饰的方法，锁的对象是类的class对象。仅仅被synchronized修饰的方法，锁的对象是方法的调用者。即便是用同一个对象调用两个方法，锁的对象也不是同一个，所以两个方法用的不是同一个锁，后调用的方法不需要等待先调用的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j(topic = &quot;c.Number&quot;)</span><br><span class="line">class Number&#123;</span><br><span class="line">    public static synchronized void a() &#123;</span><br><span class="line">        sleep(1);</span><br><span class="line">        log.debug(&quot;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized void b() &#123;</span><br><span class="line">        log.debug(&quot;2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Number n1 = new Number();</span><br><span class="line">    Number n2 = new Number();</span><br><span class="line">    new Thread(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">    new Thread(()-&gt;&#123; n2.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将两个方法均设置为static方法，并且让两个线程用同一个对象调用两个方法</p><p>被synchronized和static修饰的方法，锁的对象是类的class对象。因为两个同步方法都被static修饰了，即便用了两个不同的对象调用方法，两个方法用的还是同一个锁，后调用的方法需要等待先调用的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j(topic = &quot;c.Number&quot;)</span><br><span class="line">class Number&#123;</span><br><span class="line">    public static synchronized void a() &#123;</span><br><span class="line">        sleep(1);</span><br><span class="line">        log.debug(&quot;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static synchronized void b() &#123;</span><br><span class="line">        log.debug(&quot;2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Number n1 = new Number();</span><br><span class="line">    Number n2 = new Number();</span><br><span class="line">    new Thread(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">    new Thread(()-&gt;&#123; n2.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="线程安全分析"><a href="#线程安全分析" class="headerlink" title="线程安全分析"></a>线程安全分析</h1><h2 id="成员变量和静态变量的线程安全分析"><a href="#成员变量和静态变量的线程安全分析" class="headerlink" title="成员变量和静态变量的线程安全分析"></a>成员变量和静态变量的线程安全分析</h2><ul><li>如果没有变量没有在线程间共享，那么变量是安全的</li><li>如果变量在线程间共享<ul><li>如果只有读操作，则线程安全</li><li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li></ul></li></ul><h2 id="局部变量线程安全分析"><a href="#局部变量线程安全分析" class="headerlink" title="局部变量线程安全分析"></a>局部变量线程安全分析</h2><ul><li>基本数据类型的局部变量是安全的</li><li>局部变量引用的对象未必是安全的<ul><li>如果局部变量引用的对象没有引用线程共享的对象，那么是线程安全的</li><li>如果局部变量引用的对象引用了一个线程共享的对象，那么要考虑线程安全的</li></ul></li></ul><h2 id="线程安全的情况"><a href="#线程安全的情况" class="headerlink" title="线程安全的情况"></a>线程安全的情况</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void test1() &#123;</span><br><span class="line">     int i = 10;</span><br><span class="line">     i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个线程调用 test1() 方法时局部变量 i，会在每个线程的栈帧内存中被创建多份，因此不存在共享</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202206261903715.png" alt="1583587166210"></p><h2 id="线程不安全的情况"><a href="#线程不安全的情况" class="headerlink" title="线程不安全的情况"></a>线程不安全的情况</h2><p>如果局部变量引用的对象逃离方法的范围，那么要考虑线程安全的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Test15 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        UnsafeTest unsafeTest = new UnsafeTest();</span><br><span class="line">        for (int i =0;i&lt;100;i++)&#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                unsafeTest.method1();</span><br><span class="line">            &#125;,&quot;线程&quot;+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class UnsafeTest&#123;</span><br><span class="line">    ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;();</span><br><span class="line">    public void method1()&#123;</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            method2();</span><br><span class="line">            method3();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void method2() &#123;</span><br><span class="line">        arrayList.add(&quot;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private void method3() &#123;</span><br><span class="line">        arrayList.remove(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不安全原因分析：</p><p>上面案例中的ArrayList是非局部变量，无论哪个线程中的 method2 和method3 引用的都是同一个对象中的 list 成员变量：一个 ArrayList ，在添加一个元素的时候，它可能会有两步来完成：</p><ol><li>第一步，在 arrayList[Size] 的位置存放此元素； 第二步增大 Size 的值。</li><li>在<strong>单线程</strong>运行的情况下，如果 Size &#x3D; 0，添加一个元素后，此元素在位置 0，而且 Size&#x3D;1；</li><li>而如果是在<strong>多线程</strong>情下，比如有两个线程，线程 A 先将元素存放在位置 0。但是此时 CPU 调线程A暂停，线程 B 得到运行的机会。线程B也向此 ArrayList 添加元素，因为此时 Size 仍等于 0 （注意，假设的是添加一个元素是要两个步骤，而线程A仅仅完成了步骤1），所以线程B也将元素存放在位置0。然后线程A和线程B都继续运行，都增加 Size 的值。那好，现在我们来看看 ArrayList 的情况，元素实际上只有一个，存放在位置 0，而 Size 却等于 2。这就是<strong>线程不安全</strong></li></ol><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231105221111986.png" alt="image-20231105221111986"></p><p>解决方法：</p><p>可以将list修改成局部变量，这样每个线程都创建自己的 ArrayList，不会出现前面的情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class safeTest&#123;</span><br><span class="line">    public void method1()&#123;</span><br><span class="line">        ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">        method2(arrayList);</span><br><span class="line">        method3(arrayList);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void method2(ArrayList arrayList) &#123;</span><br><span class="line">        arrayList.add(&quot;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private void method3(ArrayList arrayList) &#123;</span><br><span class="line">        arrayList.remove(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="private-或-final的重要性"><a href="#private-或-final的重要性" class="headerlink" title="private 或 final的重要性"></a>private 或 final的重要性</h2><p>方法访问修饰符带来的思考，如果把 method2 和 method3 的方法修改为 public 会不会导致线程安全问题？</p><ol><li><p>有其它线程调用 method2 和 method3；</p></li><li><p>在1的基础上，为 ThreadSafe 类添加子类，子类覆盖 method2 或 method3 方法，即如下所示： 从这个例子可以看出 private 或 final 提供【安全】的意义所在，请体会开闭原则中的【闭】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class ThreadSafe &#123;</span><br><span class="line">    public final void method1(int loopNumber) &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            method2(list);</span><br><span class="line">            method3(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void method2(ArrayList&lt;String&gt; list) &#123;</span><br><span class="line">        list.add(&quot;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private void method3(ArrayList&lt;String&gt; list) &#123;</span><br><span class="line">        list.remove(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class ThreadSafeSubClass extends ThreadSafe&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void method3(ArrayList&lt;String&gt; list) &#123;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            list.remove(0);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h2><ol><li>String</li><li>Integer</li><li>StringBuffer</li><li>Random</li><li>Vector</li><li>Hashtable</li><li>java.util.concurrent 包下的类</li></ol><p>这里说它们是线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的。也可以理解为它们的每个方法是原子的。但它们多个方法的组合不是原子的</p><h1 id="锁原理"><a href="#锁原理" class="headerlink" title="锁原理"></a>锁原理</h1><h2 id="Java-对象头"><a href="#Java-对象头" class="headerlink" title="Java 对象头"></a>Java 对象头</h2><p>以 32 位虚拟机为例,普通对象的对象头结构如下，其中的Klass Word为指针，指向对应的Class对象；</p><p>普通对象<img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202206261904173.png" alt="1583651065372"></p><p>数组对象：主要是多了个长度的属性<img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202206261904688.png" alt="1583651088663"></p><p>Mark Word<img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202206261904643.png" alt="1583651590160"></p><p>一个对象的结构如下</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202206261904168.png" alt="1583678624634"></p><ul><li>Object Head：对象头</li><li>Mark Word：没有锁的时候是 normal，根据不同情况会和偏向锁、轻量级锁、重量级锁交换内容</li><li>Klass Word：一个指针，指向对应的Class对象</li><li>hashcode：该对象的哈希码</li><li>age：年龄，GC时使用</li><li>biased_lock：表明是否使用偏向锁，另外2个锁直接交换Mark Word</li></ul><blockquote><p>题外话，int的大小是4B，而Interger的实例化对象有8（对象头）+4（大小）&#x3D;12B，所以内存不够的时候别用Interger</p></blockquote><h2 id="Monitor-原理"><a href="#Monitor-原理" class="headerlink" title="Monitor 原理"></a>Monitor 原理</h2><p>Monitor被翻译为监视器或者说管程</p><p>OS提供的，不是java的，jdk1.6以前上锁默认这个，1.6时为了优化引入了轻量级锁和偏向锁</p><p>每个java对象都可以关联一个Monitor，如果使用<code>synchronized</code>给对象上锁（重量级），该对象头的Mark Word中就被设置为指向Monitor对象的指针</p><ul><li><p>Owner：哪个线程上的重量级锁，Owner就指向谁</p></li><li><p>EntryList：等待队列，对象已经上重量级锁后，再有线程要访问就放入等待队列，<strong>双向链表</strong></p></li><li><p>WaitSet ：当前线执行的执行的时候，遇到了wait方法，就会释放锁，进入阻塞状态，这个线程就会被放到waitset存起来，其实这个waitset是不存在的一个数据结构，只是方便理解，有些人就提出了这么个概念</p><p>wait set几点说明</p><ol><li>所有对象都会由有个wait set，用来存放该对象wait方法之后的进入block状态的线程</li><li>线程被notify之后，不一定立即执行，需要抢锁</li><li>线程从wait set被唤醒的顺序不一定是FIFO</li><li>线程被唤醒后，必须重新获取锁，但是并不是从获取锁的地方执行，而是从wait的地方开始执行，也就说jvm会记录每个线程wait的位置</li></ol></li></ul><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202206261904369.png" alt="1583652360228"></p><ul><li>刚开始时Monitor中的Owner为null，之后那个线程用到这个锁，Owner就指向那个线程</li><li>Monitor 是每个重量级锁有一个，但整个程序可有有多个</li><li>当Thread-2 执行synchronized(obj){}代码时就会将Monitor的所有者Owner 设置为 Thread-2，上锁成功，Monitor中同一时刻只能有一个Owner</li><li>当Thread-2 占据锁时，如果线程Thread-3，Thread-4也来执行synchronized(obj){}代码，就会进入EntryList（阻塞队列）中变成BLOCKED状态</li><li>Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争时是非公平的</li><li>图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程</li></ul><blockquote><p>注意：synchronized 必须是进入同一个对象的 monitor 才有上述的效果不加 synchronized 的对象不会关联监视器，不遵从以上规则</p></blockquote><h2 id="synchronized原理-1"><a href="#synchronized原理-1" class="headerlink" title="synchronized原理"></a>synchronized原理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static final Object lock=new Object();</span><br><span class="line">static int counter = 0;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    synchronized (lock) &#123;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后的部分字节码，方法级别的 synchronized 不会在字节码指令中有所体现。字节码中还有异常处理机制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> 0 getstatic #2 &lt;com/concurrent/test/Test17.lock&gt;</span><br><span class="line"> # 取得lock的引用（synchronized开始了）</span><br><span class="line"> 3 dup    </span><br><span class="line"> # 复制操作数栈栈顶的值放入栈顶，即复制了一份lock的引用</span><br><span class="line"> 4 astore_1</span><br><span class="line"> # 操作数栈栈顶的值弹出，即将lock的引用存到局部变量表中</span><br><span class="line"> 5 monitorenter</span><br><span class="line"> # 将lock对象的Mark Word置为指向Monitor指针</span><br><span class="line"> 6 getstatic #3 &lt;com/concurrent/test/Test17.counter&gt;</span><br><span class="line"> 9 iconst_1</span><br><span class="line">10 iadd</span><br><span class="line">11 putstatic #3 &lt;com/concurrent/test/Test17.counter&gt;</span><br><span class="line">14 aload_1</span><br><span class="line"># 从局部变量表中取得lock的引用，放入操作数栈栈顶</span><br><span class="line">15 monitorexit</span><br><span class="line"># 将lock对象的Mark Word重置，唤醒EntryList</span><br><span class="line">16 goto 24 (+8)</span><br><span class="line"># 下面是异常处理指令，可以看到，如果出现异常，也能自动地释放锁</span><br><span class="line">19 astore_2</span><br><span class="line">20 aload_1</span><br><span class="line">21 monitorexit</span><br><span class="line">22 aload_2</span><br><span class="line">23 athrow</span><br><span class="line">24 return</span><br></pre></td></tr></table></figure><h2 id="CAS机制（先了解）"><a href="#CAS机制（先了解）" class="headerlink" title="CAS机制（先了解）"></a>CAS机制（先了解）</h2><p>CAS算法的作用：解决多线程条件下使用锁造成性能损耗问题的算法，保证了原子性，这个原子操作是由CPU来完成的<br>CAS的原理：CAS算法有三个操作数，通过内存中的值（V）、预期原始值（A)、修改后的新值。</p><ol><li>如果内存中的值和预期原始值相等， 就将修改后的新值保存到内存中。</li><li>如果内存中的值和预期原始值不相等，说明共享数据已经被修改，放弃已经所做的操作，然后重新执行刚才的操作，直到重试成功。</li></ol><p>注意：</p><ol><li>预期原始值（A）是从偏移位置读取到三级缓存中让CPU处理的值，修改后的新值是预期原始值经CPU处理暂时存储在CPU的三级缓存中的值，而内存指定偏移位置中的原始值。</li><li>比较从指定偏移位置读取到缓存的值与指定内存偏移位置的值是否相等，如果相等则修改指定内存偏移位置的值，这个操作是操作系统底层汇编的一个原子指令实现的，保证了原子性</li></ol><h2 id="三类锁和锁膨胀"><a href="#三类锁和锁膨胀" class="headerlink" title="三类锁和锁膨胀"></a>三类锁和锁膨胀</h2><p>偏向级锁、轻量锁、重量级锁：<strong>这三种锁只针对synchronized</strong></p><p> Java中锁主要存在四种状态：<strong>无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态</strong>，随着竞争的激烈而逐渐升级。<strong>锁只能升级而不能降级</strong>，即一个锁从偏向级锁升级到轻量锁时，不能再重新回到偏向级锁。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁的使用场景是：如果一个对象虽然有多个线程要对它进行加锁，但是加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来进行优化。轻量级锁对使用者是透明的，即语法仍然是<code>synchronized</code>，假设有两个方法同步块，利用同一个对象加锁</p><p>CAS</p><ol><li><p>每次指向到synchronized代码块时，都会创建锁记录（Lock Record）对象，每个线程都会包括一个锁记录的结构，锁记录内部可以储存对象的Mark Word和对象引用reference<img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202206261904048.png" alt="1583755737580"></p></li><li><p>让锁记录中的Object reference指向对象，并且尝试用cas(compare and sweep)替换Object对象的Mark Word ，将Mark Word 的值存入锁记录中<img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202206261904627.png" alt="1583755888236"></p></li><li><p>如果cas替换成功，那么对象的对象头储存的就是锁记录的地址和状态00，如下所示</p><p><img src="https://piplong-img.oss-cn-hangzhou.aliyuncs.com/blog-img/202206261904394.png" alt="1583755964276"></p></li><li><p>如果cas失败，有两种情况</p><ol><li><p>如果是其它线程已经持有了该Object的轻量级锁，那么表示有竞争，将进入锁膨胀阶段</p></li><li><p>如果是自己的线程已经执行了synchronized进行加锁，那么那么再添加一条 Lock Record 作为重入的计数</p><p><img src="https://piplong-img.oss-cn-hangzhou.aliyuncs.com/blog-img/202206261904108.png" alt="1583756190177"></p></li></ol></li><li><p>当线程退出synchronized代码块的时候，</p><p>如果获取的是取值为 null 的锁记录 ，表示有重入，这时重置锁记录，表示重入计数减一</p><p><img src="https://piplong-img.oss-cn-hangzhou.aliyuncs.com/blog-img/202206261904255.png" alt="1583756357835"></p></li><li><p>当线程退出synchronized代码块的时候，如果获取的锁记录取值不为 null，那么使用cas将Mark Word的值恢复给对象</p><ol><li>成功则解锁成功</li><li>失败，则说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li></ol></li></ol><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>当多个线程竞争同一个锁时，会导致除锁的拥有者外，其余线程都会自旋，这将导致自旋次数过多，cpu效率下降，所以会将锁升级为重量级锁。</p><p>重量级锁需要操作系统的介入，依赖操作系统底层的Muptex Lock。JVM会创建一个monitor对象，把这个对象的地址更新到Mark Word中。</p><p>当一个线程获取了该锁后，其余线程想要获取锁，必须等到这个线程释放锁后才可能获取到，没有获取到锁的线程，就进入了阻塞状态。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>在轻量级的锁中，我们可以发现，如果同一个线程对同一个对象进行重入锁时，也需要执行CAS操作，这是有点耗时的，那么java6开始引入了偏向锁，只有第一次使用CAS时将对象的Mark Word头设置为入锁线程ID，<strong>之后这个入锁线程再进行重入锁时，发现线程ID是自己的，那么就不用再进行CAS了</strong></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202206261905552.png" alt="1583760728806"></p><h4 id="偏向状态"><a href="#偏向状态" class="headerlink" title="偏向状态"></a>偏向状态</h4><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202206261905389.png" alt="1583762169169"></p><p>一个对象的创建过程</p><ol><li>如果开启了偏向锁（默认是开启的），那么对象刚创建之后，Mark Word 最后三位的值101，并且这是它的Thread，epoch，age都是0，在加锁的时候进行设置这些的值.</li><li>偏向锁默认是延迟的，不会在程序启动的时候立刻生效，如果想避免延迟，可以添加虚拟机参数来禁用延迟：-<code>XX:BiasedLockingStartupDelay=0</code>来禁用延迟</li><li>注意：处于偏向锁的对象解锁后，线程 id 仍存储于对象头中</li><li>实验Test18.java，加上虚拟机参数-XX:BiasedLockingStartupDelay&#x3D;0进行测试</li></ol><h4 id="撤销偏向锁"><a href="#撤销偏向锁" class="headerlink" title="撤销偏向锁"></a>撤销偏向锁</h4><div class="tabs" id="2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2-1">hashcode方法</button></li><li class="tab"><button type="button" data-href="#2-2">其它线程使用对象</button></li><li class="tab"><button type="button" data-href="#2-3">调用 wait/notify</button></li><li class="tab"><button type="button" data-href="#2-4">批量重偏向</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2-1"><p>hashcode方法</p><p>调用对象的hashcode方法的时候就会撤销这个对象的偏向锁，因为使用偏向锁时没有位置存<code>hashcode</code>的值了</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2-2"><p>其它线程使用对象</p><p>这里我们演示的是偏向锁撤销变成轻量级锁的过程，那么就得满足轻量级锁的使用条件，就是没有线程对同一个对象进行锁竞争，我们使用<code>wait</code> 和 <code>notify</code> 来辅助实现</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2-3"><p>调用 wait&#x2F;notify</p><p>不管什么锁，只要调用 wait&#x2F;notify方法，就会使对象的锁变成重量级锁，因为wait&#x2F;notify方法之后重量级锁才支持</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2-4"><p>批量重偏向</p><p>如果对象被多个线程访问，但是没有竞争，这时候偏向了线程一的对象又有机会重新偏向线程二，即可以不用升级为轻量级锁，可这和我们之前做的实验矛盾了呀，其实要实现重新偏向是要有条件的：就是超过20对象对同一个线程如线程一撤销偏向时，那么第20个及以后的对象才可以将撤销对线程一的偏向这个动作变为将第20个及以后的对象偏向线程二</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h3><p>如果在尝试加轻量级锁的过程中，操作无法成功，这是有一种情况就是其它线程已经为这个对象加上了轻量级锁，这是就要进行锁膨胀，将轻量级锁变成重量级锁。</p><ol><li><p>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202206261904499.png" alt="1583757433691"></p></li><li><p>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程</p><p>即为对象申请Monitor锁，让Object指向重量级锁地址，然后自己进入Monitor 的EntryList 变成BLOCKED状态</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202206261904936.png" alt="1583757586447"></p></li><li><p>当Thread-0 推出synchronized同步块时，使用cas将Mark Word的值恢复给对象头，失败，那么会进入重量级锁的解锁过程，即按照Monitor的地址找到Monitor对象，将Owner设置为null，唤醒EntryList 中的Thread-1线程</p></li></ol><h3 id="自旋优化"><a href="#自旋优化" class="headerlink" title="自旋优化"></a>自旋优化</h3><p>简单类比，回家没带钥匙，敲门让里面的人开门。第一次没人开门，可能是还没反应过来。多敲几次还没开门我们就能假设没人，过一段时间再来。</p><p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功，即在自旋的期间，持锁的线程释放了锁，该对象现在空闲了，那么当前线程就可以不用进行上下文切换就使用这个对象，再上锁</p><ol><li><p>自旋重试成功的情况<img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202206261904963.png" alt="1583758113724"></p></li><li><p>自旋重试失败的情况，自旋了一定次数还是没有等到持锁的线程释放锁<img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202206261905380.png" alt="1583758136650"></p></li></ol><p>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。Java 7 之后不能控制是否开启自旋功能</p><h2 id="wait和notify"><a href="#wait和notify" class="headerlink" title="wait和notify"></a>wait和notify</h2><p>wait</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> 管型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 介绍及虚拟机配置</title>
      <link href="/2023/10/02/Linux%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/10/02/Linux%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux前置"><a href="#Linux前置" class="headerlink" title="Linux前置"></a>Linux前置</h1><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310312106430.png"></p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p><strong>服务器领域</strong></p><p>linux在服务器领域的应用是最强的。linux免费、稳定、高效等特点在这里得到了很好的体现，尤其在一些高端领域尤为广泛。</p><p>嵌入式领域<br>linux运行稳定、对网络的良好支持性、低成本，且可以根据需要进行软件裁剪，内核最小可以达到几百KB等特点，使其近些年来在嵌入式领域的应用得到非常大的提高</p><h2 id="Linux和Unix的关系"><a href="#Linux和Unix的关系" class="headerlink" title="Linux和Unix的关系"></a>Linux和Unix的关系</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310312109303.png"></p><h2 id="VM和Linux的安装"><a href="#VM和Linux的安装" class="headerlink" title="VM和Linux的安装"></a>VM和Linux的安装</h2><h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><p>Linux的文件系统是采用级层式的树状目录结构，在此结构中的最上层是根目录，然后在此目录下再创建其他的目录。</p><blockquote><p>在Linux世界里，一切皆文件。Linux系统会把硬件，网络，系统等各种东西映射成文件。</p></blockquote><p>因此与Windows不同，Linux中的目录结构是有规范的，不同的目录承载着不同的功能。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310312113041.png"></p><h2 id="具体的目录结构"><a href="#具体的目录结构" class="headerlink" title="具体的目录结构"></a>具体的目录结构</h2><table><thead><tr><th>目录</th><th>使用频率</th><th>说明</th></tr></thead><tbody><tr><td>&#x2F;bin</td><td>【常用】如 &#x2F;usr&#x2F;bin , &#x2F;usr&#x2F;local&#x2F;bin</td><td>Binary的简写，存放着最常用的程序（命令）</td></tr><tr><td>&#x2F;sbin</td><td>【常用】如 &#x2F;usr&#x2F;sbin , &#x2F;usr&#x2F;local&#x2F;sbin</td><td>Super User Binary的简写，存放系统管理员使用的系统管理程序（命令）</td></tr><tr><td>&#x2F;home</td><td>【常用】如 &#x2F;home&#x2F;UserName</td><td>在Linux中每一个普通用户都有一个自己的目录，一般以自己的用户名命名</td></tr><tr><td>&#x2F;root</td><td>【常用】</td><td>系统管理员的目录，也称为超级权限者的用户目录</td></tr><tr><td>&#x2F;lib</td><td>【不常用】</td><td>系统开机所需最基本的动态链接共享库，其作用类似于Windows里的DDL文件。几乎所有的应用程序都需要用到这些共享库</td></tr><tr><td>&#x2F;lost+found</td><td>【不常用】</td><td>一个隐藏目录，一般情况是空的，在系统非法关机后，会记录一些文件</td></tr><tr><td>&#x2F;etc</td><td>【常用】</td><td>存放所有的系统管理所需要的配置文件会子目录，如MySQL的 my.conf 配置文件</td></tr><tr><td>&#x2F;usr</td><td>【常用】</td><td>重要目录，存放用户很多的应用程序和文件，类型Windows下的program files目录</td></tr><tr><td>&#x2F;boot</td><td>【常用】</td><td>存放启动Linux时的一些核心文件，包括连接文件和镜像文件</td></tr><tr><td>&#x2F;proc</td><td>【不能动】</td><td>这是一个虚拟的目录，所系统内存的映射，访问这个目录可以获取系统信息</td></tr><tr><td>&#x2F;srv</td><td>【不能动】</td><td>service的简写，存放一些服务启动后需要提取的数据</td></tr><tr><td>&#x2F;sys</td><td>【不能动】</td><td>Linux内核2.6后的重大变化，目录下安装了2.6内核新出现的一个文件系统 sysfs</td></tr><tr><td>&#x2F;tmp</td><td>【不常用】</td><td>存放一些临时文件的目录</td></tr><tr><td>&#x2F;dev</td><td>【不常用】</td><td>类似Windows的设备管理器，存放所有硬件的文件映射</td></tr><tr><td>&#x2F;media</td><td>【常用】</td><td>Linux系统会把自动识别到的一些设备挂载到该目录下面，如U盘，光驱等等</td></tr><tr><td>&#x2F;mnt</td><td>【常用】</td><td>系统提供该目录给用户临时挂别的文件系统，可以把外部存储挂载到 &#x2F;mnt&#x2F; 上，然后在该目录查看内容。</td></tr><tr><td>&#x2F;opt</td><td>【不常用】</td><td>给主机额外安装软件的安装包所存放的目录，默认为空。</td></tr><tr><td>&#x2F;usr&#x2F;local</td><td>【常用】</td><td>给主机额外安装软件的目录。</td></tr><tr><td>&#x2F;var</td><td>【常用】</td><td>用于存放不断扩充（追加）的文件，例如日志文件</td></tr><tr><td>&#x2F;selinux</td><td>【不常用】</td><td>系统安全的目录</td></tr></tbody></table><h1 id="远程登录到Linux服务器"><a href="#远程登录到Linux服务器" class="headerlink" title="远程登录到Linux服务器"></a>远程登录到Linux服务器</h1><p>为什么需要远程登录Linux？<br>公司开发时候，具体的应用场景是这样的</p><ol><li>Linux服务器是开发小组共享</li><li>正式上线的项目是运行在公网</li><li>因此程序 员需要远程登录到Linux进行项目管理或者开发</li><li>画出简单的网络拓扑示意图(帮助理解)</li><li>远程登录客户端有Xshell6，Xftp6，我们学习使用Xshell 和Xftp6 ，其它的远程工具大同小异</li></ol><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310312119731.png"></p><h2 id="Xshell6"><a href="#Xshell6" class="headerlink" title="Xshell6"></a>Xshell6</h2><p>Xshell是目前最好的远程登录到Linux操作的软件，流畅的速度并且完美解决了中文乱码的问题，是目前程序员首选的软件。</p><p>Xshell是一个强大的安全终端模拟软件，它支持SSH1, SSH2,以及Microsoft Windows平台的TELNET协议。</p><p>Xshell可以在Windows界面下用来访问远端不同系统下的服务器，从而比较好的达到远程控制终端的目的</p><h1 id="Vi与Vim"><a href="#Vi与Vim" class="headerlink" title="Vi与Vim"></a>Vi与Vim</h1><p>Vi是Linux系统内置的文本编辑器</p><p>Vim可以看做Vi的升级版本，具有程序编辑功能，可以主动设置以字体的颜色辨别语法正确性，方便程序设计。拥有代码补全，编译错误跳转等方便编程的等丰富功能。</p><h2 id="三种模式"><a href="#三种模式" class="headerlink" title="三种模式"></a>三种模式</h2><p>Vi和Vim有三种常用模式</p><div class="tabs" id="t1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#t1-1">**正常模式**</button></li><li class="tab"><button type="button" data-href="#t1-2">**插入模式**</button></li><li class="tab"><button type="button" data-href="#t1-3">**命令行模式**</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="t1-1"><p>当我们用vim或者vi打开一个文档时，默认进入的模式。在这个模式下，我们可以用方向键移动光标，可用【删除字符】或者【删除整行】来处理档案内容，也可以用【复制】，【粘贴】来处理文件数据</p><p>快捷键：</p><ol><li>在正常模式下，输入数字n+ yy 可以复制光标往下n行数据，例如 5yy 就是复制光标向下5行数据，输入 p 就可以粘贴刚刚复制的内容</li><li>在正常模式下，输入数字n+ dd 可以删除光标往下n行数据，例如 5yy 就是删除光标向下5行数据</li><li>在正常模式下，输入 gg 可以到定位到文档首行，输入 G 可以定位到文档末行</li><li>在正常模式下，输入 u 可以执行撤销操作</li><li>在正常模式下，输入数字n，然后输入 shift + g 可以定位到第n行，例如：输入 5 ，然后输入 shift + g 就是定位到第5行数据</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="t1-2"><p>按下 i , I , o , O , a , A , r , R 任何一个键可以进入插入模式，一般来说按 i 就可以了</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="t1-3"><p>正常模式下输入 : 可以进入命令行模式。使用相关命令，可以完成【读取】，【存盘】，【替换】，【离开】，【显示行号】等操作。</p><p>快捷键：</p><ol><li>使用 &#x2F; 进入命令行模式后，输入任何你想查找的 单词或语句 后按下回车可以查找该 单词\语句 ，输入 n 可以查找下一个，输入 N 可以查找上一个。</li><li>使用 ： 进入命令行模式后，输入 set nu 可以设置行号，输入 set nonu 可以取消行号设置</li><li>使用 ： 进入命令行模式后，输入 set list 可以查看特殊字符，输入 set nolist 可以取消设置</li><li>使用 ： 进入命令行模式后，输入 h 可以查看帮助</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>更多内容可以查看：<a href="https://vimcdoc.sourceforge.net/doc/quickref.html">Vim官方文档</a></p><h2 id="模式切换"><a href="#模式切换" class="headerlink" title="模式切换"></a>模式切换</h2><ol><li>在终端下，我们可以使用 vi xxx  或 vim xxx 进入相应编辑器的正常模式浏览文件</li><li>在正常模式下，我们可以输入 i 或上面提到的任何一个字母进入插入模式进行文本编辑</li><li>在插入模式下，我们可以按 esc 键退出插入模式</li><li>在正常模式下，我们可以输入 <strong>:</strong> 或者 <strong>&#x2F;</strong> 进入命令行模式（注意 : 和 &#x2F; 功能不一样）</li><li>在命令行模式下，我们可以<ul><li>输入: wq 保存退出到终端 （write&amp;quit）</li><li>输入: q 直接退出到终端</li><li>输入: q！ 强制直接退出到终端</li><li>输入: wq！ 强制保存退出到终端</li></ul></li><li>在命令行模式下，我们可以按 esc 键退出命令行模式</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 虚拟机安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>定时任务</title>
      <link href="/2023/10/02/Linux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
      <url>/2023/10/02/Linux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Linux中的任务调度是指在特定的时间或条件下执行预定的任务。<code>crond</code>和<code>at</code>都是Linux中用于任务调度的工具。<code>crond</code>可以周期性地执行任务，而<code>at</code>则可以在指定的时间点执行任务。它们都可以帮助用户在特定的时间或条件下自动执行预定的任务，提高工作效率</p><h1 id="crond"><a href="#crond" class="headerlink" title="crond"></a>crond</h1><p><code>crond</code>是Linux系统中的一个守护进程，负责周期性地执行预定的任务。它根据预设的时间表（通常是<code>crontab</code>文件）来触发任务的执行。<code>crontab</code>文件包含了一系列的任务定义，每个任务定义包括了任务的执行时间、执行的命令或脚本等信息。<code>crond</code>会根据这些定义，按照设定的时间间隔周期性地执行任务。常见的时间间隔包括每分钟、每小时、每天、每周、每月等。</p><p>corntab [选项]</p><p>选项如下</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-e</code></td><td>编辑<code>corntab</code>文件</td></tr><tr><td><code>-l</code></td><td>查询<code>corntab</code>定时任务调度</td></tr><tr><td><code>-r</code></td><td>递归删除<code>corntab</code>定时任务调度</td></tr></tbody></table><p>编辑<code>crontab</code>文件的格式：<code>分 时 日 月 周 要执行的命令或脚本</code></p><h2 id="定时规则"><a href="#定时规则" class="headerlink" title="定时规则"></a>定时规则</h2><p>其中的<code>分 时 日 月 周</code>是<code>cron</code>的定时规则，也称为【cron表达式】，它还支持一些特殊字符和符号，例如通配符（*）、范围（-）、逗号（,）、间隔（&#x2F;）等，以提供更灵活的调度选项。</p><p><strong>示例</strong></p><ol><li><code>10 18 * * * ls /root/cat &gt;&gt; /home/user/watch.log</code>：每天18点10分执行<code>ls /root/cat &gt;&gt; /home/user/watch.log</code>命令</li><li><code>* 18 8 1 * ls /root/cat &gt;&gt; /home/user/watch.log</code>：每年1月8日的18点执行<code>ls /root/cat &gt;&gt; /home/user/watch.log</code>命令</li><li><code>0 9 * * 1-5 /home/myshell.sh</code>：每周一到周五的9点执行<code>/home/myshell.sh</code>脚本</li><li><code>0 9 * * 1,5 /home/myshell.sh</code>：每周一和每周五的9点执行<code>/home/myshell.sh</code>脚本</li><li><code>*/5 * * * * ls /root/cat &gt;&gt; /home/user/watch.log</code>：每隔5分钟执行<code>ls /root/cat &gt;&gt; /home/user/watch.log</code>命令</li></ol><h1 id="at"><a href="#at" class="headerlink" title="at"></a>at</h1><p><strong>简要介绍</strong></p><p><code>at</code>是另一个任务调度工具，它允许用户在指定的时间执行一次性的任务。与<code>crond</code>不同，<code>at</code>不会周期性地执行任务，而是在指定的时间点执行一次任务。用户可以使用<code>at</code>命令来创建任务，并指定任务的执行时间和要执行的命令或脚本。<code>at</code>命令可以接受多种时间格式，如绝对时间、相对时间等。</p><p><code>atd</code>（<code>at</code>守护进程）是一个后台进程，负责管理<code>at</code>命令提交的任务。<code>atd</code>进程会根据系统时间和任务的执行时间进行调度，并将任务分配给合适的执行环境。</p><p>默认情况下，<code>atd</code>守护进程每60秒检测作业队列，如果存在作业时间并且当前时间匹配，则运行</p><p><strong>基本语法</strong></p><p>在执行<code>at</code>命令前，我们得先确认<code>atd</code>守护进程是否在运行中：</p><ul><li><code>ps -ef | gerp atd</code>：查看活跃进程，后面接上管道命令过滤出<code>atd</code>线程</li></ul><p>确定<code>atd</code>线程开启后，我们可以使用<code>at</code>命令了，下面是<code>at</code>命令的说明</p><ul><li><code>at [选项] [时间]</code>：具体选项说明如下表</li></ul><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-m</code></td><td>指定任务执行完成后，通过邮件通知任务的所有者。</td></tr><tr><td><code>-l</code></td><td>列出待执行的任务列表。</td></tr><tr><td><code>-r</code></td><td>删除指定的任务。</td></tr><tr><td><code>-q 队列</code></td><td>指定任务队列的名称。</td></tr><tr><td><code>-t 时间</code></td><td>指定任务的执行时间。</td></tr><tr><td><code>-f 文件</code></td><td>指定要执行的命令或脚本文件。</td></tr><tr><td><code>-I</code></td><td>忽略任务执行时的标准输入。</td></tr><tr><td><code>-V</code></td><td>显示<code>at</code>命令的版本信息。</td></tr><tr><td><code>-c</code></td><td>显示任务的命令行内容。</td></tr></tbody></table><p>输入完<code>at</code>命令后就可以进入编辑状态，在此界面输入执行的命令或脚本，使用<code>Ctrl</code>+<code>D</code>退出</p><ul><li><code>atq</code>：可以查看队列中未执行的定时任务信息，包括任务编号</li><li><code>atrm 任务编号</code>：移除指定编号的定时任务</li></ul><h2 id="定时规则-1"><a href="#定时规则-1" class="headerlink" title="定时规则"></a>定时规则</h2><p>与<code>crontab</code>的定时规则不一样，<code>at</code>有很多种的定时规则：</p><table><thead><tr><th>时间规则</th><th>说明</th></tr></thead><tbody><tr><td>绝对时间</td><td>使用24小时制的绝对时间来指定任务的执行时间。例如，<code>at 12:30</code>表示任务将在当天的12:30执行。</td></tr><tr><td>相对时间</td><td>使用相对时间来指定任务的执行时间。相对时间可以是当前时间的偏移量。例如，<code>at now + 1 hour</code>表示任务将在当前时间的1小时后执行。时间单位还有：<code>days</code>，<code>minutes</code>，<code>weeks</code>。</td></tr><tr><td>特定日期和时间</td><td>指定具体的日期和时间来执行任务。例如，<code>at 2023-07-04 09:00</code>表示任务将在2023年7月4日的9:00执行。</td></tr><tr><td>关键字</td><td><code>at</code>指令支持一些关键字来指定特定的时间点，例如<code>midnight</code>（午夜）、<code>noon</code>（中午）和<code>teatime</code>（下午4点）。例如，<code>at midnight</code>表示任务将在每天的午夜执行。<code>today</code>,<code>tomorrow</code>也是可以的。</td></tr><tr><td>时间表达式</td><td>使用时间表达式来指定更复杂的时间规则。时间表达式使用特定的语法来描述任务的执行时间。例如，<code>at 10:00pm + 2 days</code>表示任务将在两天后的晚上10点执行。</td></tr></tbody></table><p><strong>示例</strong></p><ol><li><p>在晚上10点执行位于<code>/path/to/script.sh</code>的脚本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">$at 10:00 PM</span><br><span class="line">at&gt; /path/to/script.sh</span><br><span class="line">at&gt; Ctrl+D</span><br></pre></td></tr></table></figure></li><li><p>在当前时间的1小时后执行命令，将”Hello, world!”写入到<code>/path/to/output.txt</code>文件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">$at now + 1 hour</span><br><span class="line">at&gt; echo &quot;Hello, world!&quot; &gt; /path/to/output.txt</span><br><span class="line">at&gt; Ctrl+D</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux组和权限</title>
      <link href="/2023/10/02/Linux%E7%BB%84%E5%92%8C%E6%9D%83%E9%99%90/"/>
      <url>/2023/10/02/Linux%E7%BB%84%E5%92%8C%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<h1 id="组"><a href="#组" class="headerlink" title="组"></a>组</h1><p>Linux系统中的每个文件和目录都有一组权限，用于控制对它们的访问。</p><p>每个人都有自己的组</p><p>这些权限分为三个类别：</p><ul><li>所有者（Owner）：谁创建文件谁是所有者</li><li>所属组（Group）</li><li>其他人（Others）</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202311012024859.png"></p><h2 id="相关指令"><a href="#相关指令" class="headerlink" title="相关指令"></a>相关指令</h2><ul><li>查看文件的所有者：Is -ahl</li><li>修改文件所有者：chown 用户名 文件名</li><li>创建组：groupadd 名字</li><li></li></ul><h1 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h1><p>每个类别都有读（Read）、写（Write）和执行（Execute）权限。权限可以使用符号表示法来表示，其中每个类别都有一个字母表示权限：</p><ul><li><code>r</code>（读权限）：表示可以读取文件内容或查看目录中的文件列表。</li><li><code>w</code>（写权限）：表示可以修改文件内容，或在目录中创建、删除和重命名文件。</li><li><code>x</code>（执行权限）：对于文件，表示可以执行文件作为可执行程序；对于目录，表示可以进入目录。</li></ul><p>注意：如上面所说，如果你对一个文件拥有<code>w</code>权限，你可以修改这个文件，但是你并不能删除这个文件。删除这个文件的前提是你拥有文件所在目录的<code>w</code>权限</p><div class="tabs" id="1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#1-1">文件的权限效果</button></li><li class="tab"><button type="button" data-href="#1-2">目录的权限效果</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><p>r 代表可读(read):可以读取查看</p><p>w 代表可写(write):可以修改但是不代表可以删除该文件,删除一个文件的前提条件是对该又件所在的目录有写权限，才能删除该文件</p><p>x 代表可执行(execute):可以被执行</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-2"><p>rwx作用到目录</p><p>r 代表可读(read):可以读取, Is查看目录内容</p><p>w 代表可写(write):可以修改，对目录内创建+删除+重命名月录</p><p>x 代表可执行(execute):可以进入该目录</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="表示方法"><a href="#表示方法" class="headerlink" title="表示方法"></a>表示方法</h2><ol><li><p>符号表示法</p><p>权限符号表示法的格式为：<code>[所有者权限][所属组权限][其他人权限]</code>。</p></li><li><p>数字表示法</p><p>权限在数字表示法中使用三位二进制数表示每个权限组的权限。每个权限对应一个二进制位，其中1表示有权限，0表示没有权限。例如：如果一个权限组的权限是rwx（即读、写和执行权限都有），它的二进制表示为111，对应的数字表示为7。</p></li></ol><p>改权限的时候能用字母又能用数字，数字要合写。例如，<code>rw-r--r--</code>表示所有者具有读写权限，所属组和其他人只有读权限，数字表示法表示为<code>644</code>。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>drwxr-xr-x 2 root root 4096 2月 23 12:00 xml</p><p>drwxr-xr-x：表示类型和相关权限</p><p>0-9位说明：</p><ul><li><p>第0位确定文件类型(d,-,I,c, b)</p><p>-是普通文件，单纯的文件</p><p>I是链接，相当于windows的快捷方式</p><p>d是目录，相当于windows的文件夹</p><p>c是待设备文件，鼠标，键盘</p><p>b是块设备，比如硬盘</p></li><li><p>第1- 3位确定<strong>所有者</strong>（该文件的所有者）拥有该文件的权限。User</p></li><li><p>第4- 6位确定<strong>所属组</strong>（同用户组的）拥有该文件的权限。G roup</p></li><li><p>第7-9位确定<strong>其他用户</strong>拥有该文件的权限。Other</p><blockquote><p>写什么就有什么权限，没有的用 - 占位，如rwx，rw-，r–</p></blockquote></li></ul><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><p>因为Linux的权限与组密不可分，所以在讲述权限管理的命令之前，我们会先提及一些组管理的相关命令。</p><p>以下一些命令可能需要root用户权限</p><h2 id="组管理"><a href="#组管理" class="headerlink" title="组管理"></a>组管理</h2><p><strong>创建</strong></p><ol><li><code>groupadd 新组名</code>：创建一个组</li><li><code>useradd -g 用户组 新用户名</code>：创建一个用户并指定用户组</li></ol><p>当这个新创建的一个用户创建一个文件之后，文件的所有者就是该用户，所属组就是该用户所属的组</p><p>我们可以使用<code>ls -l 指定文件/目录</code>查看指定文件或目录的详细信息，其中就包括了权限信息，文件所有者和所属组信息。</p><p><strong>修改</strong></p><ol><li><p><code>chgrp 组名 文件名/目录名</code>：修改指定文件或目录所属组，加上选项<code>-R</code>可以递归修改。</p></li><li><p><code>usermod -g 组名 用户名</code>：修改用户所在的组</p></li><li><p><code>usermod -d 路径 用户名</code>：可以指定用户登录进入的初始化目录，其他是该用户拥有进入该目录的权限</p></li></ol><p><strong>查看</strong></p><ol><li><code>id 用户名</code>：可以查看用户ID信息，其中包括组ID</li><li>在<code>/etc/group</code>文件中，可以查看所有的组的信息（组名、组密码、组ID（GID）和组成员）</li></ol><p><strong>删除</strong></p><p><code>groupdel 用户组</code>：删除用户组</p><h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><p><strong>查看权限</strong></p><p>使用<code>ls -l</code>可以查看文件的详细信息，其中就包括了权限信息（权限信息为符号表示，如<code>rw-r--r--</code>），下面让我们看看具体示例</p><p>示例输出：<code>drwxr-xr-x 2 root root 4096 2月 23 12:00 xml</code>：</p><ol><li><code>d</code>：文件类型，<code>d</code>表示目录</li><li><code>rwxr-xr-x</code>：权限信息</li><li><code>2</code>：如果是目录显示子目录数（不包括文件，包括隐藏目录<code>.</code>和<code>..</code>，所以一个空目录该数值是<code>2</code>），如果是文件则显示硬链接数</li><li><code>root</code>：用户</li><li><code>root</code>：组</li><li><code>4096</code>：如果是目录则显示<code>4096</code>，如果是文件则显示文件大小（默认单位：字节）</li><li><code>2月 23 12:00</code>：最后修改时间</li></ol><p>扩展:在<code>ls -l</code>查看到详细信息，在权限信息前有一个别的字母（如<code>drwxr-xr-x</code>中的<code>d</code>），该字母表示文件的类型具体含义如下：</p><ul><li><code>l</code>：link 表示软链接，类似Windows的快捷方式</li><li><code>d</code>：directory 表示目录</li><li><code>c</code>：character device 字符设备，如鼠标，键盘</li><li><code>b</code>：block device 块设备，如硬盘</li><li><code>-</code>：普通文件</li><li><code>s</code>：socket 套接字，表示该文件是一个进程间通信的通道，</li></ul><p><strong>修改权限</strong></p><ol><li>chmod [u&#x2F;g&#x2F;o&#x2F;a] [+ &#x2F;-&#x2F;&#x3D;] [权限] 文件名或者目录：<ul><li><code>u</code>代表所有者，<code>g</code>代表所属组，<code>o</code>代表其他人，<code>a</code>代表所有人（前面三者的总和）</li><li><code>=</code>赋值，<code>+</code>增加，<code>-</code>减少</li><li>示例<code>chomd u=rwx,g=rx,o-x dog</code>：<code>dog</code>文件所有者权限修改为读写执行，所属组权限修改为读和执行，其他人减少执行权限</li></ul></li><li>chomd 数字表示法权限 文件：我们也可以使用数字表示法表示权限修改文件权限，让我们看看示例<ul><li><code>chomd 777 dog</code>：把<code>dog</code>文件的权限修改为<code>rwxrwxrwx</code>，<code>7</code>是二进制<code>111</code>的十进制表示，详情请看<a href="https://gallifrey.asia/posts/77d4628760e7/#%E6%A6%82%E5%BF%B5">概念</a></li><li><code>chomd 644 hello.txt</code>：把<code>hello.txt</code>文件的权限修改为<code>rw-r--r--</code>,<code>6</code>是二进制<code>110</code>的十进制表示</li></ul></li><li>chown：修改文件或目录的所有者（Owner，我其实觉得翻译为拥有者或者主人更合适）<ul><li><code>chown 用户名 文件或目录</code>：修改指定文件或者目录的所有者</li><li><code>chown 用户名:组名 文件或目录</code>：修改指定文件或者目录的所有者和组名</li><li><code>chown 用户名 -R 文件或目录</code>：递归修改修改指定文件或者目录的所有者，一般用于修改整个目录下所有文件的所有者</li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux进程</title>
      <link href="/2023/10/02/Linux%E8%BF%9B%E7%A8%8B/"/>
      <url>/2023/10/02/Linux%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><ol><li><p>在LINUX中 ，每个执行的程都称为个进程。每个进程都分配一个ID号(pid,进程号)。</p><p>windows 都一样 Linux</p></li><li><p>每个进程都可能以两种方式存在的：前台与后台</p><p>前台进程就是用户目前的屏幕上可以进行操作的。</p><p>后台进程则是实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行。</p></li><li><p>一般系统的服务都是以后台进程的方式存在,而且都会常驻在系统中。直到关机才才结束。</p></li></ol><h2 id="显示系统执行的进程"><a href="#显示系统执行的进程" class="headerlink" title="显示系统执行的进程"></a>显示系统执行的进程</h2><p>ps命令是用来查看目前系统中,有哪些正在执行,以及它们执行的状况。可以不加任何参数，</p><p>常用参数：</p><ul><li>-a:显示当前终端的所有进程信息</li><li>-u:以用户的格式显示进程信息</li><li>-x:显示后台进程运行的参数</li></ul><p>查询结果：</p><ul><li>System V展示风格</li><li>USER :用户名称</li><li>PID :进程号</li><li>%CPU :进程占用CPU的百分比</li><li>%MEM :进程占用物理内存的百分比</li><li>VSZ :进程占用的虚拟内存大小(单位: KB )</li><li>RSS ;进程占用的物理内存大小(单位; KB )</li><li>Tt :终端名称，缩写.</li><li>STAT :进程状态，其中S睡眠，s-表示该进程是会话的先导进程, N-表示进程拥有比普通优先级更低的优先级，R-正在运行，D-短期等待，Z-僵死进程, T-被跟踪或者被停止等等</li><li>STARTED :进程的启动时间</li><li>TIME : CPU时间，即进程使用CPU的总时间</li><li>COMMAND :启动进程所用的命令和参教如果过长会波裁斯显示</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java反射</title>
      <link href="/2023/09/30/Java%E5%8F%8D%E5%B0%84/"/>
      <url>/2023/09/30/Java%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="反射引出"><a href="#反射引出" class="headerlink" title="反射引出"></a>反射引出</h1><ol><li><p>根据配置文件re.properties指定信息，创建Cat对象并调用方法hi</p><p>classfullpath&#x3D; com.hspedu.Cat</p><p>method&#x3D; hi</p><p>使用现有技术，你能做的吗?</p></li><li><p>这样的需求在学习框架时特别多，即通过外部文件配置，在不修改源码情况下来控制程序，也符合设计模式的 ocp原则</p><p>开闭原则：不修改源码，扩容功能</p></li></ol><p>传统的方式 new 对象 -》 调用方法</p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">传统的方式</button></li><li class="tab"><button type="button" data-href="#test1-2">使用Properties 类</button></li><li class="tab"><button type="button" data-href="#test1-3">反射机制</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p>new对象调用方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cat cat = new Cat();</span><br><span class="line">cat.hi();   //cat.cry() 修改要修改源码，耦合度高</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p>使用Properties 类, 可以读写配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Properties properties = new Properties();</span><br><span class="line">properties.load(new FileInputStream(&quot;src\\re.properties&quot;));</span><br><span class="line">String classfullpath = properties.get(&quot;classfullpath&quot;).toString();//&quot;com.hspedu.Cat&quot;</span><br><span class="line">String methodName = properties.get(&quot;method&quot;).toString();//&quot;hi&quot;</span><br><span class="line">System.out.println(&quot;classfullpath=&quot; + classfullpath);</span><br><span class="line">System.out.println(&quot;method=&quot; + methodName);</span><br><span class="line"></span><br><span class="line">//2. 创建对象 , 传统的方法，行不通</span><br><span class="line">new classfullpath();  //虽然 classfullpath = com.hspedu.Cat，但是这东西不是类的构造方法，不能这么用</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//(1) 加载类, 返回Class类型的对象cls</span><br><span class="line">Class cls = Class.forName(classfullpath);</span><br><span class="line">//(2) 通过 cls 得到你加载的类 com.hspedu.Cat 的对象实例</span><br><span class="line">Object o = cls.newInstance();</span><br><span class="line">System.out.println(&quot;o的运行类型=&quot; + o.getClass()); //运行类型</span><br><span class="line">//(3) 通过 cls 得到你加载的类 com.hspedu.Cat 的 methodName&quot;hi&quot;  的方法对象</span><br><span class="line">//    即：在反射中，可以把方法视为对象（万物皆对象）</span><br><span class="line">Method method1 = cls.getMethod(methodName);</span><br><span class="line">//(4) 通过method1 调用方法： 即通过方法对象来实现调用方法</span><br><span class="line">System.out.println(&quot;=============================&quot;);</span><br><span class="line">method1.invoke(o); //传统方法 对象.方法() , 反射机制 方法.invoke(对象)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h1><ol><li>反射机制允许程序在执行期借助于 Reflection API 取得任何类的内部信息(比如成员变量，构造器，成员方法等等)，并能操作对象的属性及方法。反射在设计模式和框架底层都会用到</li><li>加载完类之后，在堆中就产生了一个 Class 类型的对象(一个类只有个 Class 对象) ，这个对象包含了类的完整结构信息。通过这个对象得到类的结构。这个对象就像一面镜子， 透过这个镜子看到类的结构，所以，形象的称之为：反射</li></ol><blockquote><p>Class类是一个特殊的类，反射相关的类都在 Java.lang.reflect 包中</p><p>除了Class，还有Method、Field、Constructor类</p></blockquote><h2 id="反射原理"><a href="#反射原理" class="headerlink" title="反射原理"></a>反射原理</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310151310761.png"></p><h2 id="反射功能"><a href="#反射功能" class="headerlink" title="反射功能"></a>反射功能</h2><ol><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时得到任意一个类所具有的成员变量和方法</li><li>在运行时调用任意一个对象的成员变量和方法</li><li>生成动态代理</li></ol><h2 id="反射相关类"><a href="#反射相关类" class="headerlink" title="反射相关类"></a>反射相关类</h2><ul><li><p>java.lang.Class：代表一个类。Class 对象表示某个类加载后在堆中的对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class cls = Class.forName(classFullPath);//1</span><br><span class="line">Object o = cls.newInstance();//2</span><br></pre></td></tr></table></figure><ol><li>通过完整类名得到一个类的 Class 对象</li><li>通过该 Class 对象创建一个该类的 对象实例</li></ol></li><li><p>java.lang.reflect.Method：代表类的方法。Method 对象表示某个类的某个方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method method = cls.getMethod(methodName);//[1]</span><br><span class="line">method.invoke(o);//[2]</span><br></pre></td></tr></table></figure><ol><li>通过该 Class 对象得到一个 方法对象</li><li>方法对象.invoke：调用该方法</li></ol></li><li><p>java.lang.reflect.Field：代表类的成员变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Field field = cls.getField(fieldName);</span><br></pre></td></tr></table></figure><ol><li>该方法只能得到非私有对象</li></ol></li><li><p>java.lang.reflect.Constructor：代表类的构造方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Constructor constructor = cls.getConstructor();         //[1]</span><br><span class="line">Constructor constructor2 = cls.getConstructor(String.class)  //[2]</span><br></pre></td></tr></table></figure><ol><li>得到一个无参构造器</li><li>得到一个形参是 (String str) 的构造器</li></ol></li></ul><h2 id="反射的优点和缺点"><a href="#反射的优点和缺点" class="headerlink" title="反射的优点和缺点"></a>反射的优点和缺点</h2><ul><li>优点：可以动态地创建和使用对象（也是框架底层核心），使用灵活。没有反射机制，框架技术就失去底层支撑</li><li>缺点：使用反射基本是解释执行。这对执行速度有影响。</li></ul><h3 id="反射调用优化"><a href="#反射调用优化" class="headerlink" title="反射调用优化"></a>反射调用优化</h3><ol><li>Method 和 Field、Constructor 对象都有 setAccessible() 方法</li><li>setAccessible() 作用是启动和禁用访问安全检查的开关</li><li>参数值为 true，表示反射对象在使用时取消访问检查，这样能提高反射效率。</li><li>参数值为 false 表示执行访问检查</li></ol><blockquote><p>后面的爆破也是这个方法</p></blockquote><h1 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h1><p><img src="/https%EF%BC%9A/raw.githubusercontent.com/icyhalo/picgo/main/202310311233755.png"></p><ol><li>Class 是一个特殊的类，在 java 中，任何类都至少有一个父类：Object</li><li>Class 类的对象不是 new 出来的，加载类的时候系统自动创建</li><li>对于某个类的Class类对象，在内存中只有一份， 因为类只加载一次</li><li>每个类的实例都会记得自己是由哪个Class实例所生成</li><li>通过Class对象可以完整地得到一个类的完整结构，通过一系列API</li><li>Class对象是存放在堆的</li><li>类的字节码二进制数据，是放在方法区的，有的地方称为类的元数据(包括 方法代码，变量名，方法名，访问权限等等)</li></ol><h2 id="Class-类的常用方法"><a href="#Class-类的常用方法" class="headerlink" title="Class 类的常用方法"></a>Class 类的常用方法</h2><p>首先要用 Class.forName() 获得类对象，不然一切免谈</p><ul><li><p>Class.forName(String)：返回指定类名的 Class 对象</p></li><li><p>newInstance()：返回一个无参构造器创建的实例</p></li><li><p>getName()：返回该 Class 对象表示的实体的全类名</p></li><li><p>getClass()：返回该 Class 对象的运行类型 java.lang.Class</p></li><li><p>getPackage()：返回该 Class 对象所在的包</p></li><li><p>getSuperClass()：返回该 Class 对象的父类 Class 对象</p></li><li><p>getInterface()：返回该 Class 对象的接口（数组）</p></li><li><p>getAnnotations()：返回注解信息（Annotation[]）</p></li><li><p>getClassLoader()：返回该 Class 对象的加载器（ClassLoader 类型）</p></li><li><p>getSuperclass()：返回该 Class 对象实体的超类的 Class</p></li><li><p>getConstructors()：返回本类所有包含 public 修饰的构造器的 Constructor 对象数组</p><p>该方法返回的构造器不含父类构造器！</p></li><li><p>getDeclaredConstructer()：返回本类所有构造器的 Constructor 对象数组</p></li><li><p>getFileds()：返回一个包含 public 修饰的属性的 Field 对象的数组</p><p>getFiled(String name)：返回指定的 Field</p></li><li><p>getDeclaredFields()：获取本类中所有属性</p></li><li><p>field.get(instance)：返回指定实例的指定属性</p></li><li><p>field.set(instance, ..)：给指定实例的指定属性赋值</p></li><li><p>getMethod()：获得所有 public 修饰的方法的 Method 对象</p></li><li><p>getMethod(String name, Class paramTypes, …)：返回一个 Method 对象，其形参类型为 paramType</p></li><li><p>getDeclaredMethod()：获取本类中所有方法</p></li></ul><div class="tabs" id="test2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test2-1">方法类</button></li><li class="tab"><button type="button" data-href="#test2-2">Car类</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test2-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Class02 &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchFieldException &#123;</span><br><span class="line">        String classAllPath = &quot;com.hspedu.Car&quot;;</span><br><span class="line">        //1 . 获取到Car类 对应的 Class对象</span><br><span class="line">        //&lt;?&gt; 表示不确定的Java类型</span><br><span class="line">        Class&lt;?&gt; cls = Class.forName(classAllPath);</span><br><span class="line">        //2. 输出cls</span><br><span class="line">        System.out.println(cls); //显示cls对象, 是哪个类的Class对象 com.hspedu.Car</span><br><span class="line">        System.out.println(cls.getClass());//输出cls运行类型 java.lang.Class</span><br><span class="line">        //3. 得到包名</span><br><span class="line">        System.out.println(cls.getPackage().getName());//包名</span><br><span class="line">        //4. 得到全类名</span><br><span class="line">        System.out.println(cls.getName());</span><br><span class="line">        //5. 通过cls创建对象实例</span><br><span class="line">        Car car = (Car) cls.newInstance();</span><br><span class="line">        System.out.println(car);//car.toString()</span><br><span class="line">        //6. 通过反射获取属性 brand</span><br><span class="line">        Field brand = cls.getField(&quot;brand&quot;);</span><br><span class="line">        System.out.println(brand.get(car));//宝马</span><br><span class="line">        //7. 通过反射给属性赋值</span><br><span class="line">        brand.set(car, &quot;奔驰&quot;);</span><br><span class="line">        System.out.println(brand.get(car));//奔驰</span><br><span class="line">        //8 我希望大家可以得到所有的属性(字段)</span><br><span class="line">        System.out.println(&quot;=======所有的字段属性====&quot;);</span><br><span class="line">        Field[] fields = cls.getFields();</span><br><span class="line">        for (Field f ： fields) &#123;</span><br><span class="line">            System.out.println(f.getName());//名称</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Car &#123;</span><br><span class="line">    public String brand = &quot;宝马&quot;;//品牌</span><br><span class="line">    public int price = 500000;</span><br><span class="line">    public String color = &quot;白色&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Car&#123;&quot; +</span><br><span class="line">                &quot;brand=&#x27;&quot; + brand + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, price=&quot; + price +</span><br><span class="line">                &quot;, color=&#x27;&quot; + color + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="获取-Class-类对象"><a href="#获取-Class-类对象" class="headerlink" title="获取 Class 类对象"></a>获取 Class 类对象</h2><p>总共有6种，但主要运用4种</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202311011028778.png"></p><ol><li><p>已知一一个类的全类名，且该类在类路径下，可通过Class类的静态方法 forName 获取，可能抛出ClassNotFoundException</p><p>应用场景：多用于配置文件，读取类全路径，加载类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//1. Class.forName</span><br><span class="line">String classAllPath = &quot;com.hspedu.Car&quot;; //通过读取配置文件获取</span><br><span class="line">Class&lt;?&gt; cls1 = Class.forName(classAllPath);</span><br><span class="line">System.out.println(cls1);</span><br></pre></td></tr></table></figure></li><li><p>若已知具体的类，通过类的class获取，该方式最为安全可靠，程序性能</p><p>最高实例：Class cls2 &#x3D; Cat.class; </p><p>应用场景：多用于参数传递，比如通过反射得到对应构造器对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//2. 类名.class , 应用场景： 用于参数传递</span><br><span class="line">Class cls2 = Car.class;</span><br><span class="line">System.out.println(cls2);</span><br></pre></td></tr></table></figure></li><li><p>已知某个类的实例，调用该实例的 getClass 方法获取Class对象</p><p>应用场景：通过创建好的对象，获取Class对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//3. 对象.getClass(), 应用场景，有对象实例</span><br><span class="line">Car car = new Car();</span><br><span class="line">Class cls3 = car.getClass();</span><br><span class="line">System.out.println(cls3);</span><br></pre></td></tr></table></figure></li><li><p>通过类加载器（4种）来获取到类的Class对象</p><ol><li>拿到类加载器</li><li>拿到Class对象</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//4. 通过类加载器【4种】来获取到类的Class对象</span><br><span class="line">//(1)先得到类加载器 car</span><br><span class="line">ClassLoader classLoader = car.getClass().getClassLoader();</span><br><span class="line">//(2)通过类加载器得到Class对象</span><br><span class="line">Class cls4 = classLoader.loadClass(classAllPath);</span><br><span class="line">System.out.println(cls4);</span><br></pre></td></tr></table></figure></li><li><p>基本数据 XXX.Class</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//5. 基本数据(int, char,boolean,float,double,byte,long,short) 按如下方式得到Class类对象</span><br><span class="line">Class&lt;Integer&gt; integerClass = int.class;</span><br><span class="line">Class&lt;Character&gt; characterClass = char.class;</span><br><span class="line">Class&lt;Boolean&gt; booleanClass = boolean.class;</span><br><span class="line">System.out.println(integerClass);//int</span><br></pre></td></tr></table></figure></li><li><p>包装类 XXX.TYPE</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//6. 基本数据类型对应的包装类，可以通过 .TYPE 得到Class类对象</span><br><span class="line">Class&lt;Integer&gt; type1 = Integer.TYPE;</span><br><span class="line">Class&lt;Character&gt; type2 = Character.TYPE; //其它包装类BOOLEAN, DOUBLE, LONG,BYTE等待</span><br><span class="line">System.out.println(type1);</span><br></pre></td></tr></table></figure></li></ol><h2 id="如下类型有Class对象"><a href="#如下类型有Class对象" class="headerlink" title="如下类型有Class对象"></a>如下类型有Class对象</h2><ol><li><p>外部类，成员内部类，静态内部类，局部内部类，匿名内部类</p></li><li><p>interface：接口</p></li><li><p>数组</p></li><li><p>enum：枚举</p></li><li><p>annotation：注解</p></li><li><p>基本数据类型</p></li><li><p>void</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class AllTypeClass &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;String&gt; cls1 = String.class;//外部类</span><br><span class="line">        Class&lt;Serializable&gt; cls2 = Serializable.class;//接口</span><br><span class="line">        Class&lt;Integer[]&gt; cls3 = Integer[].class;//数组</span><br><span class="line">        Class&lt;float[][]&gt; cls4 = float[][].class;//二维数组</span><br><span class="line">        Class&lt;Deprecated&gt; cls5 = Deprecated.class;//注解</span><br><span class="line">        //枚举</span><br><span class="line">        Class&lt;Thread.State&gt; cls6 = Thread.State.class;</span><br><span class="line">        Class&lt;Long&gt; cls7 = long.class;//基本数据类型</span><br><span class="line">        Class&lt;Void&gt; cls8 = void.class;//void数据类型</span><br><span class="line">        Class&lt;Class&gt; cls9 = Class.class;//</span><br><span class="line"></span><br><span class="line">        System.out.println(cls1);</span><br><span class="line">        System.out.println(cls2);</span><br><span class="line">        System.out.println(cls3);</span><br><span class="line">        System.out.println(cls4);</span><br><span class="line">        System.out.println(cls5);</span><br><span class="line">        System.out.println(cls6);</span><br><span class="line">        System.out.println(cls7);</span><br><span class="line">        System.out.println(cls8);</span><br><span class="line">        System.out.println(cls9);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><p>反射机制是java实现动态语言的关键，也就是通过反射实现类动态加载。</p><p>静态加载：编译时加载相关的类，如果没有则报错，依赖性太强</p><blockquote><p>现代编译器帮你排除静态加载的问题了，找不到连编译都不让你干</p></blockquote><p>动态加载：运行时加载需要的类，如果运行时不用该类，则不报错，降低了依赖性</p><p>类加载时机：</p><ol><li>当创建对象时(new)</li><li>当子类被加载时，自动加载父类</li><li>调用类中的静态成员时</li><li>通过反射（只有这个是动态加载，上面3个都是静态的）</li></ol><h2 id="类加载流程"><a href="#类加载流程" class="headerlink" title="类加载流程"></a>类加载流程</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202311011044511.png"></p><ul><li><p>加载</p><p>JVM在该阶段的主要目的是将字节码从不同的数据源(可能是class文件、也可能是jar包，甚至网络)转化为进制字节流加载到内存中，并生成一个代表该类的java.lang.Class对象</p><p>此过程由类加载器完成</p></li><li><p>连接</p><ol><li><p>验证</p><p>目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><p>包括：文件格式验证(是否以魔数oxcafebabe开头)、元数据验证、字节码验证和符号引用验证</p></li><li><p>准备</p><p>JVM会在该阶段对静态变量，分配内存并默认初始化（对应数据类型的默认初始值，如0、0L、null、 false等）这些变量所使用的内存都将在方法区中进行分配</p><blockquote><p>注意，静态常量这一步直接到位，因为常量赋值后不变</p></blockquote></li><li><p>解析</p><p>虚拟机将常量池内的符号引用替换为直接引用的过程。</p></li></ol></li><li><p>初始化</p><p>JVM负责对类进行初始化，这里主要是指静态成员<br>到初始化阶段，才真正开始执行类中定义的Java程序代码，此段是执行&lt; clinit&gt; 方法的过程。</p><blockquote><p>&lt;  clinit&gt; 方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中的所有静态变量的赋值动作和静态代码块中的语句，并进行合并，绝对按顺序执行赋值<br>虚拟机会保证一个类的&lt; clinit&gt; 方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类， 那么只会有一个线程去执行这个类的&lt; clinit&gt; 方法，其他线程都需要阻塞等待，直到活动线程执行<clinit> 0方法完毕</p></blockquote></li></ul><h2 id="获取类结构信息"><a href="#获取类结构信息" class="headerlink" title="获取类结构信息"></a>获取类结构信息</h2><ol><li><p>得到Class对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; personCls = Class.forName(&quot;com.hspedu.reflection.Person&quot;);</span><br></pre></td></tr></table></figure></li><li><p>获取全类名 getName</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(personCls.getName());</span><br></pre></td></tr></table></figure></li><li><p>获取简单类名 getSimpleName</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(personCls.getSimpleName());</span><br></pre></td></tr></table></figure></li><li><p>获取所有public修饰的属性，包含本类以及父类的 getFields</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Field[] fields = personCls.getFields();</span><br><span class="line">for (Field field ： fields) &#123;//增强for</span><br><span class="line">    System.out.println(&quot;本类以及父类的属性=&quot; + field.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取本类中所有属性（包括私有的）getDeclaredFields</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Field[] declaredFields = personCls.getDeclaredFields();</span><br><span class="line">for (Field declaredField ： declaredFields) &#123;</span><br><span class="line">    System.out.println(&quot;本类中所有属性=&quot; + declaredField.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取所有public修饰的方法，包含本类以及父类的 getMethods</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Method[] methods = personCls.getMethods();</span><br><span class="line">for (Method method ： methods) &#123;</span><br><span class="line">    System.out.println(&quot;本类以及父类的方法=&quot; + method.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取本类中所有方法 getDeclaredMethods</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Method[] declaredMethods = personCls.getDeclaredMethods();</span><br><span class="line">for (Method declaredMethod ： declaredMethods) &#123;</span><br><span class="line">    System.out.println(&quot;本类中所有方法=&quot; + declaredMethod.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取所有public修饰的构造器 getConstructors</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;?&gt;[] constructors = personCls.getConstructors();</span><br><span class="line">for (Constructor&lt;?&gt; constructor ： constructors) &#123;</span><br><span class="line">    System.out.println(&quot;本类的构造器=&quot; + constructor.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取本类中所有构造器 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;?&gt;[] declaredConstructors = personCls.getDeclaredConstructors();</span><br><span class="line">for (Constructor&lt;?&gt; declaredConstructor ： declaredConstructors) &#123;</span><br><span class="line">    System.out.println(&quot;本类中所有构造器=&quot; + declaredConstructor.getName());//这里只输出名为例</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>以Package形式返回包信息 getPackage</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(personCls.getPackage());</span><br></pre></td></tr></table></figure></li><li><p>以Class形式返回父类信息 getSuperClass</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; superclass = personCls.getSuperclass();</span><br><span class="line">System.out.println(&quot;父类的class对象=&quot; + superclass);</span><br></pre></td></tr></table></figure></li><li><p>以Class[]形式返回接口信息 getInterfaces</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt;[] interfaces = personCls.getInterfaces();</span><br><span class="line">for (Class&lt;?&gt; anInterface ： interfaces) &#123;</span><br><span class="line">    System.out.println(&quot;接口信息=&quot; + anInterface);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>以Annotation[] 形式返回注解信息 getAnnotations</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Annotation[] annotations = personCls.getAnnotations();</span><br><span class="line">for (Annotation annotation ： annotations) &#123;</span><br><span class="line">    System.out.println(&quot;注解信息=&quot; + annotation);//注解</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="java-lang-reflect-Field类"><a href="#java-lang-reflect-Field类" class="headerlink" title="java.lang.reflect.Field类"></a>java.lang.reflect.Field类</h3><ol><li><p>getModifiers：以int形式返回修饰符</p><p>默认修饰符是0 , public 是1 , private 是2，protected 是4,static是8 , final是16</p></li><li><p>getType：以Class形式返回类型</p></li><li><p>getName：返回属性名</p></li></ol><h1 id="爆破"><a href="#爆破" class="headerlink" title="爆破"></a>爆破</h1><p>通过反射创建对象方法</p><ul><li>方式一：调用类中的public修饰的无参构造器</li><li>方式二：调用类中的指定构造器</li></ul><p>Class类相关方法</p><ul><li>newInstance ：调用类中的无参构造器，获取对应类的对象（就是上面方法1）</li><li>getConstructor(as..clazz)：根据参数列表，获取对应的构造器对象（就是上面方法2）</li><li>getDecalaredConstructor(as..clazz)：根据参数列表，获取对应的构造器对象（就是上面方法2）</li></ul><p>Constructor类相关方法</p><ul><li>setAccessible：暴破</li><li>newlnstance(Objetc…obj)：调用构造器</li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>先获取到User类的Class对象</p><div class="tabs" id="test3"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test3-1">无参构造器</button></li><li class="tab"><button type="button" data-href="#test3-2">public有参构造器</button></li><li class="tab"><button type="button" data-href="#test3-3">private有参构造器</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test3-1"><p>通过public的无参构造器创建实例</p><p>Object o &#x3D; userClass.newInstance();</p><p>注意这个 o 后面用得到</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-2"><ol><li><p>先得到对应构造器</p><p>Constructor&lt;?&gt; constructor &#x3D; userClass.getConstructor(String.class);</p></li><li><p>创建实例，并传入实参</p><p>Object hsp &#x3D; constructor.newInstance(“hsp”);</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-3"><ol><li><p>得到private的构造器对象</p><p>Constructor&lt;?&gt; constructor1 &#x3D; userClass.getDeclaredConstructor(int.class, String.class);</p><p>因为是 private 的，所以要用 getDeclaredConstructor 方法</p></li><li><p>创建实例</p><p>这里用 3 中方法一定会报错，因为构造器是私有的，但是可以通过爆破强行使用</p><p> constructor1.setAccessible(true); &#x2F;&#x2F;这一句表示使用爆破<br> Object user2 &#x3D; constructor1.newInstance(100, “张三丰”); &#x2F;&#x2F;然后就能用了</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class ReflecCreateInstance &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line"></span><br><span class="line">        //1. 先获取到User类的Class对象</span><br><span class="line">        Class&lt;?&gt; userClass = Class.forName(&quot;com.hspedu.reflection.User&quot;);</span><br><span class="line">        //2. 通过public的无参构造器创建实例</span><br><span class="line">        Object o = userClass.newInstance();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">        //3. 通过public的有参构造器创建实例</span><br><span class="line">        /*</span><br><span class="line">            constructor 对象就是</span><br><span class="line">            public User(String name) &#123;//public的有参构造器</span><br><span class="line">                this.name = name;</span><br><span class="line">            &#125;</span><br><span class="line">         */</span><br><span class="line">         //3.1 先得到对应构造器</span><br><span class="line">         Constructor&lt;?&gt; constructor = userClass.getConstructor(String.class);</span><br><span class="line">         //3.2 创建实例，并传入实参</span><br><span class="line">         Object hsp = constructor.newInstance(&quot;hsp&quot;);</span><br><span class="line">         System.out.println(&quot;hsp=&quot; + hsp);</span><br><span class="line">        //4. 通过非public的有参构造器创建实例</span><br><span class="line">        //4.1 得到private的构造器对象</span><br><span class="line">        Constructor&lt;?&gt; constructor1 = userClass.getDeclaredConstructor(int.class, String.class);</span><br><span class="line">        //4.2 创建实例</span><br><span class="line">        //暴破，使用反射可以访问private构造器/方法/属性, 反射面前，都是纸老虎</span><br><span class="line">        constructor1.setAccessible(true);</span><br><span class="line">        Object user2 = constructor1.newInstance(100, &quot;张三丰&quot;);</span><br><span class="line">        System.out.println(&quot;user2=&quot; + user2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class User &#123; //User类</span><br><span class="line">    private int age = 10;</span><br><span class="line">    private String name = &quot;韩顺平教育&quot;;</span><br><span class="line"></span><br><span class="line">    public User() &#123;//无参 public</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public User(String name) &#123;//public的有参构造器</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private User(int age, String name) &#123;//private 有参构造器</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User [age=&quot; + age + &quot;, name=&quot; + name + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h2><ol><li><p>根据属性名获取Field对象<br>Field f &#x3D; clazz对象.getDeclaredField(属性名);</p><p>注意 f 是个 Field对象</p></li><li><p>暴破: f.setAccessible(true);   </p><p>f是上面那个对象</p><p>o 是更上面的那个 newInstance 的对象</p></li><li><p>访问<br>f.set(o,值);<br>syso(f.get(o));</p></li><li><p>如果是静态属性，则set和get中的参数o, 可以写成null</p><p>这里的 o 就是上面的对象，因为静态属性是类的，不需要对象</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//1. 得到Student类对应的 Class对象</span><br><span class="line">Class&lt;?&gt; stuClass = Class.forName(&quot;com.hspedu.reflection.Student&quot;);</span><br><span class="line"></span><br><span class="line">//2. 创建对象</span><br><span class="line">Object o = stuClass.newInstance();//o 的运行类型就是Student</span><br><span class="line">System.out.println(o.getClass());//Student</span><br><span class="line"></span><br><span class="line">//3. 使用反射得到age 属性对象</span><br><span class="line">Field age = stuClass.getField(&quot;age&quot;);</span><br><span class="line">age.set(o, 88);//通过反射来操作属性</span><br><span class="line">System.out.println(o);//</span><br><span class="line">System.out.println(age.get(o));//返回age属性的值</span><br><span class="line"></span><br><span class="line">//4. 使用反射操作name 属性</span><br><span class="line">Field name = stuClass.getDeclaredField(&quot;name&quot;);</span><br><span class="line">name.setAccessible(true);//对name 进行暴破, 可以操作private 属性</span><br><span class="line">name.set(null, &quot;老韩~&quot;);//因为name是static属性，因此 o 也可以写出null</span><br><span class="line">System.out.println(o);</span><br><span class="line">System.out.println(name.get(o)); //获取属性值</span><br><span class="line">System.out.println(name.get(null));//获取属性值, 要求name是static</span><br></pre></td></tr></table></figure><h2 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h2><ol><li>根据方法名和参数列表获取Method方法对象: Method m &#x3D;clazz.getDeclaredMethod(方法名，XX.class);</li><li>获取对象: Object o&#x3D;clazz.newlnstance();</li><li>暴破: m.setAccessible(true);</li><li>访问: Object returnValue &#x3D; m.invoke(o,实参列表);<br>如果是静态方法，则invoke的参数o,可以写成null!</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>丁奇MySql</title>
      <link href="/2023/09/28/%E4%B8%81%E5%A5%87MySql/"/>
      <url>/2023/09/28/%E4%B8%81%E5%A5%87MySql/</url>
      
        <content type="html"><![CDATA[<h1 id="Day1-讲基础架构：一条SQL查询语句是如何执行的"><a href="#Day1-讲基础架构：一条SQL查询语句是如何执行的" class="headerlink" title="Day1-讲基础架构：一条SQL查询语句是如何执行的"></a>Day1-讲基础架构：一条SQL查询语句是如何执行的</h1><p>平时我们使用数据库，看到的通常都是一个整体。比如，你有个最简单的表，表里只有一个ID字段，在执行下面这个查询语句时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from T where ID=10；</span><br></pre></td></tr></table></figure><p>我们看到的只是输入一条语句，返回一个结果，却不知道这条语句在MySQL内部的执行过程。</p><p>今天把MySQL拆解一下，看看里面都有哪些“零件”，</p><p>下面我给出的是MySQL的基本架构示意图，从中你可以清楚地看到SQL语句在MySQL的各个功能模块中的执行过程。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310081010377.png"></p><p>大体来说，MySQL可以分为<strong>Server层</strong>和<strong>存储引擎层</strong>两部分。</p><p>Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p><p>存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认存储引擎。</p><p>也就是说，你执行create table建表的时候，如果不指定引擎类型，默认使用的就是InnoDB。也可以通过指定存储引擎的类型来选择别的引擎，比如在create table语句中使用engine&#x3D;memory, 来指定使用内存引擎创建表。不同存储引擎的表数据存取方式不同，支持的功能也不同。</p><blockquote></blockquote><p>从图中不难看出，不同的存储引擎共用一个<strong>Server层</strong>，也就是从连接器到执行器的部分。</p><p>结合开头提到的那条SQL语句，走一遍整个执行流程，依次看下每个组件的作用。</p><h2 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h2><p>第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h$ip -P$port -u$user -p</span><br></pre></td></tr></table></figure><p>输完命令之后，你就需要在交互对话里面输入密码。虽然密码也可以直接跟在-p后面写在命令行中，但这样可能会导致你的密码泄露。如果你连的是生产服务器，强烈建议你不要这么做。</p><p>连接命令中的mysql是客户端工具，用来跟服务端建立连接。在完成经典的TCP握手后，连接器就要开始认证身份，这个时候用的就是你输入的用户名和密码。</p><ul><li>如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。</li><li>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</li></ul><p>这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限（当前链接）。修改完成后，只有再<strong>新建的连接</strong>才会使用新的权限设置。</p><p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在show processlist命令中看到它。文本中这个图是show processlist的结果，其中的Command列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310081037347.png"></p><p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数wait_timeout控制的，默认值是8小时。</p><p>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。</p><ul><li>长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。</li><li>短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</li></ul><p>建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。</p><p>但是全部使用长连接后，你可能会发现，有些时候MySQL占用内存涨得特别快，这是因为MySQL在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是MySQL异常重启了。</p><p>怎么解决这个问题呢？你可以考虑以下两种方案。</p><ol><li><p>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</p></li><li><p>如果你用的是MySQL 5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</p><p>造成影响如下：</p><ol><li>回滚活跃的事务并重新设置自动提交模式</li><li>释放所有表锁</li><li>关闭或删除所有的临时表</li><li>重新初始化会话的系统变量值</li><li>丢失用户定义的设置变量</li><li>释放prepare语句</li><li>关闭handler变量</li><li>将last_insert_id()值设置为0</li><li>释放get_lock（）获取的锁</li><li>清空通过mysql_bind_param()调用定义的当前查询属性</li></ol></li></ol><h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><blockquote><p>MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有这个功能了。</p></blockquote><p>连接建立完成后，你就可以执行select语句了。执行逻辑就会来到第二步：查询缓存。</p><p>MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端。（计网中也有类似的东西）</p><p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。</p><p><strong>但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。</strong></p><p>查询缓存的<strong>失效非常频繁</strong>，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。</p><p>很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。<strong>除非你的业务就是有一张静态表，很长时间才会更新一次</strong>。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p><p>好在MySQL也提供了这种“按需使用”的方式。你可以将参数query_cache_type设置成DEMAND，这样对于默认的SQL语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用SQL_CACHE显式指定，像下面这个语句一样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select SQL_CACHE * from T where ID=10；</span><br></pre></td></tr></table></figure><h2 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h2><p>如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL需要知道你要做什么，因此需要对SQL语句做解析。</p><p>分析器先会做“<strong>词法分析</strong>”。你输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么。</p><p>MySQL从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名T”，把字符串“ID”识别成“列ID”。</p><p>做完了这些识别以后，就要做“<strong>语法分析</strong>”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。</p><p>如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，比如下面这个语句select少打了开头的字母“s”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; elect * from t where ID=1;</span><br><span class="line"></span><br><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;elect * from t where ID=1&#x27; at line 1</span><br></pre></td></tr></table></figure><p>一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。</p><h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>经过了分析器，MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。</p><p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的join：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;</span><br></pre></td></tr></table></figure><ul><li>既可以先从表t1里面取出c&#x3D;10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。</li><li>也可以先从表t2里面取出d&#x3D;20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。</li></ul><p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</p><p>优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等等，后面的文章中单独展开说明优化器的内容。</p><h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。</p><p>开始执行的时候，要先判断一下你对这个表T有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示(在工程实现上，如果命中查询缓存，会在查询缓存放回结果的时候，做权限验证。查询也会在优化器之前调用precheck验证权限)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from T where ID=10;</span><br><span class="line"></span><br><span class="line">ERROR 1142 (42000): SELECT command denied to user &#x27;b&#x27;@&#x27;localhost&#x27; for table &#x27;T&#x27;</span><br></pre></td></tr></table></figure><p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</p><p>比如我们这个例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的：</p><ol><li>调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；</li><li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li><li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li></ol><p>至此，这个语句就执行完成了。</p><p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。</p><p>你会在数据库的慢查询日志中看到一个rows_examined的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。</p><p>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此<strong>引擎扫描行数跟rows_examined并不是完全相同的。</strong>我们后面会专门有一篇文章来讲存储引擎的内部机制，里面会有详细的说明。</p><h2 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h2><p>如果表T中没有字段k，而你执行了这个语句 select * from T where k&#x3D;1, 那肯定是会报“不存在这个列”的错误： “Unknown column ‘k’ in ‘where clause’”。你觉得这个错误是在我们上面提到的哪个阶段报出来的呢？</p><p>分析器</p><ol><li>MySQL的框架有几个组件, 各是什么作用?</li><li>Server层和存储引擎层各是什么作用?</li><li>you have an error in your SQL syntax 这个保存是在词法分析里还是在语法分析里报错?</li><li>对于表的操作权限验证在哪里进行?</li><li>执行器的执行查询语句的流程是什么样的?</li></ol><h1 id="D2-讲日志系统：一条SQL更新语句是如何执行的"><a href="#D2-讲日志系统：一条SQL更新语句是如何执行的" class="headerlink" title="D2-讲日志系统：一条SQL更新语句是如何执行的"></a>D2-讲日志系统：一条SQL更新语句是如何执行的</h1><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310081010377.png"></p><p>MySQL可以恢复到半个月内任意一秒的状态，这是怎样做到的呢？</p><p>我们还是从一个表的一条更新语句说起，下面是这个表的创建语句，这个表有一个主键ID和一个整型字段c：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T(ID int primary key, c int);</span><br></pre></td></tr></table></figure><p>如果要将ID&#x3D;2这一行的值加1，SQL语句就会这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update T set c=c+1 where ID=2;</span><br></pre></td></tr></table></figure><p>前面我有跟你介绍过SQL语句基本的执行链路，这里我再把那张图拿过来，你也可以先简单看看这个图回顾下。首先，可以确定的说，查询语句的那一套流程，更新语句也是同样会走一遍。</p><p>执行语句前要先连接数据库，这是连接器的工作。</p><p>前面我们说过，在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表T上所有缓存结果都清空。这也就是我们一般不建议使用查询缓存的原因。</p><p>接下来，分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用ID这个索引。然后，执行器负责具体执行，找到这一行，然后更新。</p><p>与查询流程不一样的是，更新流程还涉及两个重要的日志模块，它们正是我们今天要讨论的主角：redo log（重做日志）和 binlog（归档日志）。如果接触MySQL，那这两个词肯定是绕不过的，我后面的内容里也会不断地和你强调。不过话说回来，redo log和binlog在设计上有很多有意思的地方，这些设计思路也可以用到你自己的程序里。</p><h2 id="重要的日志模块：redo-log"><a href="#重要的日志模块：redo-log" class="headerlink" title="重要的日志模块：redo log"></a>重要的日志模块：redo log</h2><p>《孔乙己》这篇文章，酒店掌柜有一个粉板，专门用来记录客人的赊账记录。如果赊账的人不多，那么他可以把顾客名和账目写在板上。但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。</p><p>如果有人要赊账或者还账的话，掌柜一般有两种做法：</p><ul><li>一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉；</li><li>另一种做法是先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。</li></ul><p>在生意红火柜台很忙时，掌柜一定会选择后者，因为前者操作实在是太麻烦了。首先，你得找到这个人的赊账总额那条记录。你想想，密密麻麻几十页，掌柜要找到那个名字，可能还得带上老花镜慢慢找，找到之后再拿出算盘计算，最后再将结果写回到账本上。</p><p>这整个过程想想都麻烦。相比之下，还是先在粉板上记一下方便。你想想，如果掌柜没有粉板的帮助，每次记账都得翻账本，效率是不是低得让人难以忍受？</p><p>同样，在MySQL里也有这个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。为了解决这个问题，MySQL的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。</p><p>而粉板和账本配合的整个过程，其实就是MySQL里经常说到的WAL技术，WAL的全称是Write-Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。</p><p>具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。</p><p>InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么这块“粉板”总共就可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310081324101.png"></p><ul><li><p>write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p></li><li><p>write pos和checkpoint之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果write pos追上checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把checkpoint推进一下。</p></li></ul><p>有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<strong>crash-safe</strong>。</p><p>要理解crash-safe这个概念，可以想想我们前面赊账记录的例子。只要赊账记录记在了粉板上或写在了账本上，之后即使掌柜忘记了，比如突然停业几天，恢复生意后依然可以通过账本和粉板上的数据明确赊账账目。</p><h2 id="重要的日志模块：binlog"><a href="#重要的日志模块：binlog" class="headerlink" title="重要的日志模块：binlog"></a>重要的日志模块：binlog</h2><p>MySQL整体来看，其实就有两块：</p><ol><li>一块是Server层，它主要做的是MySQL功能层面的事情；</li><li>还有一块是引擎层，负责存储相关的具体事宜。</li></ol><p>上面我们聊到的粉板redo log是InnoDB引擎特有的日志，而Server层也有自己的日志，称为binlog（归档日志）。</p><p>我想你肯定会问，为什么会有两份日志呢？</p><p>因为最开始MySQL里并没有InnoDB引擎。MySQL自带的引擎是MyISAM，但是MyISAM没有crash-safe的能力，binlog日志只能用于归档。而InnoDB是另一个公司以插件形式引入MySQL的，既然只依靠binlog是没有crash-safe能力的，所以InnoDB使用另外一套日志系统——也就是redo log来实现crash-safe能力。</p><p>这两种日志有以下三点不同。</p><ol><li><p>redo log是InnoDB引擎特有的；</p><p>binlog是MySQL的Server层实现的，所有引擎都可以使用。</p></li><li><p>redo log是物理日志，记录的是“<strong>在某个数据页上做了什么修改</strong>”；</p><p>binlog是逻辑日志，记录的是这个<strong>语句的原始逻辑</strong>，比如“给ID&#x3D;2这一行的c字段加1 ”。</p></li><li><p>redo log是循环写的，空间固定会用完；</p><p>binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</p></li></ol><p>有了对这两个日志的概念性理解，我们再来看执行器和InnoDB引擎在执行这个简单的update语句时的内部流程。</p><ol><li>执行器先找引擎取 ID&#x3D;2 这一行。ID是主键，引擎直接用树搜索找到这一行。如果 ID&#x3D;2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li><li>执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li><li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。</li><li>执行器生成这个操作的binlog，并把binlog写入磁盘。</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。</li></ol><p>这里我给出这个update语句的执行流程图，图中浅色框表示是在InnoDB内部执行的，深色框表示是在执行器中执行的。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png"></p><p>你可能注意到了，最后三步看上去有点“绕”，将redo log的写入拆成了两个步骤：prepare和commit，这就是”两阶段提交”。</p><h2 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h2><p>为什么必须有“两阶段提交”呢？这是为了让两份日志之间的逻辑一致。要说明这个问题，我们得从文章开头的那个问题说起：<strong>怎样让数据库恢复到半个月内任意一秒的状态？</strong></p><p>binlog会记录所有的逻辑操作，并且是采用“追加写”的形式。如果你的DBA承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有binlog，同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。</p><p>当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做：</p><ul><li>首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库；</li><li>然后，从备份的时间点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时刻。</li></ul><p>这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去。</p><p>好了，说完了数据恢复过程，我们回来说说，为什么日志需要“两阶段提交”。这里不妨用反证法来进行解释。</p><p>由于redo log和binlog是两个独立的逻辑，如果不用两阶段提交，要么就是先写完redo log再写binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。</p><p>仍然用前面的update语句来做例子。假设当前ID&#x3D;2的行，字段c的值是0，再假设执行update语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了crash，会出现什么情况呢？</p><ol><li><strong>先写redo log后写binlog</strong>。假设在redo log写完，binlog还没有写完的时候，MySQL进程异常重启。由于我们前面说过的，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行c的值是1。<br>但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份日志的时候，存起来的binlog里面就没有这条语句。<br>然后你会发现，如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同。</li><li><strong>先写binlog后写redo log</strong>。如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日志。所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是1，与原库的值不同。</li></ol><p>可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。</p><p>你可能会说，这个概率是不是很低，平时也没有什么动不动就需要恢复临时库的场景呀？</p><p>其实不是的，不只是误操作后需要用这个过程来恢复数据。当你需要扩容的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用binlog来实现的，这个“不一致”就会导致你的线上出现主从数据库不一致的情况。</p><p>简单说，redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>今天，我介绍了MySQL里面最重要的两个日志，即物理日志redo log和逻辑日志binlog。</p><p>redo log用于保证crash-safe能力。innodb_flush_log_at_trx_commit这个参数设置成1的时候，表示每次事务的redo log都直接持久化到磁盘。这个参数我建议你设置成1，这样可以保证MySQL异常重启之后数据不丢失。</p><p>sync_binlog这个参数设置成1的时候，表示每次事务的binlog都持久化到磁盘。这个参数我也建议你设置成1，这样可以保证MySQL异常重启之后binlog不丢失。</p><p>我还跟你介绍了与MySQL日志系统密切相关的“两阶段提交”。两阶段提交是跨系统维持数据逻辑一致性时常用的一个方案，即使你不做数据库内核开发，日常开发中也有可能会用到。</p><p>文章的最后，我给你留一个思考题吧。前面我说到定期全量备份的周期“取决于系统重要性，有的是一天一备，有的是一周一备”。那么在什么场景下，一天一备会比一周一备更有优势呢？或者说，它影响了这个数据库系统的哪个指标？</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven基础</title>
      <link href="/2023/09/03/Maven%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/09/03/Maven%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Maven简介"><a href="#Maven简介" class="headerlink" title="Maven简介"></a>Maven简介</h1><h2 id="Maven是什么"><a href="#Maven是什么" class="headerlink" title="Maven是什么"></a>Maven是什么</h2><p>在Javaweb开发中，需要使用大量的jar包，我们手动去导入；如何能够让一个东西自动帮我导入和配置这个jar包。由此，Maven诞生了</p><ul><li>Maven的本质是一个项目管理工具，将项目开发和管理过程抽象成-一个项目对象模型(POM)</li><li>Maven是用Java语言编写的。他管理的东西统统以面向对象的形式进行设计，最终它把一个项目看成一个对象，而这个对象叫做<strong>POM</strong>(project object model)，即项目对象模型</li><li>POM (Project Object Model) :项目对象模型</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309091528718.png"></p><p>图中蓝色部分为核心，其余部分都是可以替换的。</p><p>Maven通过<strong>依赖管理</strong>进行项目资源管理的。这也是它的第二个核心！</p><ul><li>所谓依赖管理就是maven对项目所有依赖资源的一种管理，它和项目之间是一种双向关系，即当我们做项目的时候maven的依赖管理可以帮助你去管理你所需要的其他资源，当其他的项目需要依赖我们项目的时候，maven也会把我们的项目当作一种资源去进行管理，这就是一种双向关系。</li><li>那maven的依赖管理它管理的这些资源存在哪儿呢？主要有三个位置：本地仓库，私服，中央仓库</li><li>本地仓库顾名思义就是存储在本地的一种资源仓库，如果本地仓库中没有相关资源，可以去私服上获取，私服也是一个资源仓库，只不过不在本地，是一种远程仓库，如果私服上也没有相关资源，可以去中央仓库去获取，中央仓库也是一种远程仓库。</li><li>Maven除了帮我们管理项目资源之外还能帮助我们对项目进行构建，管理项目的整个生命周期，当然它的这些功能需要使用一些相关的插件来完成，当然整个生命周期过程中插件是需要配合使用的，单独一个无法完成完整的生命周期。</li></ul><h2 id="Maven的作用"><a href="#Maven的作用" class="headerlink" title="Maven的作用"></a>Maven的作用</h2><ul><li>项目构建:提供标准的、跨平台的自动化项目构建方式</li><li>依赖管理:方便快捷的管理项目依赖的资源(jar包) ， 避免资源间的版本冲突问题</li><li>统一开发结构:提供标准的、统-的项目结构</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309091536970.png"></p><p>各目录存放资源类型说明：</p><p>src&#x2F;main&#x2F;java：项目java源码</p><p>src&#x2F;main&#x2F;resources：项目的相关配置文件（比如mybatis配置，xml映射配置，自定义配置文件等）</p><p>src&#x2F;main&#x2F;webapp：web资源（比如html，css，js等）</p><p>src&#x2F;test&#x2F;java：测试代码</p><p>src&#x2F;test&#x2F;resources：测试相关配置文件</p><p>src&#x2F;pom.xml：项目pom文件</p><h1 id="Maven安装"><a href="#Maven安装" class="headerlink" title="Maven安装"></a>Maven安装</h1><p><a href="https://maven.apache.org/">官网</a></p><p>maven是一个绿色软件，解压即安装。</p><p>配置环境变量：</p><ul><li>依赖Java，需要配置JAVA_ HOME</li><li>设置MAVEN自身的运行环境，需要配置MAVEN_ HOME</li></ul><p>环境变量配置好之后需要测试环境配置结果，我们需要在DOS命令窗口下输入以下命令查看输出，如果能够看到输出的maven的版本信息代表配置成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn -v</span><br></pre></td></tr></table></figure><h1 id="Maven概念"><a href="#Maven概念" class="headerlink" title="Maven概念"></a>Maven概念</h1><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>用于存储资源，主要是各种jar包</p><p>关于仓库，有三种：本地仓库，私服，中央仓库，其中私服和中央仓库都属于远程仓库</p><p><strong>中央仓库</strong>：maven团队自身维护的仓库，属于开源的，包含几乎全部的jar包</p><p><strong>私服</strong>：各公司&#x2F;部门等小范围内存储资源的仓库，私服也可以从中央仓库获取资源，私服中有公司自己的未开源的jar包，也加快了速度</p><p><strong>本地仓库</strong>：开发者自己电脑上存储资源的仓库，也可从远程仓库获取资源</p><p><img src="C:\Users\CWL25\AppData\Roaming\Typora\typora-user-images\image-20230909154543369.png" alt="image-20230909154543369"></p><h2 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h2><p>maven中的坐标用于描述仓库中资源的位置</p><p>maven坐标的主要组成如下：</p><ul><li>groupId：定义当前资源隶属组织名称（通常是域名反写，如：org.mybatis；com.itheima）</li><li>artifactId：定义当前资源的名称（通常是项目或模块名称，如：crm，sms）</li><li>version：定义当前资源的版本号</li><li>packaging：定义资源的打包方式，取值一般有如下三种<ul><li>jar：该资源打成jar包，默认是jar java工程打包为jar</li><li>war：该资源打成war包 web工程打包为war</li><li>pom：该资源是一个父资源（表明使用maven分模块管理），打包时只生成一个pom.xml不生成jar或其他包结构</li></ul></li></ul><h1 id="Maven项目创建"><a href="#Maven项目创建" class="headerlink" title="Maven项目创建"></a>Maven项目创建</h1><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309121920416.png"></p><h1 id="Maven依赖管理"><a href="#Maven依赖管理" class="headerlink" title="Maven依赖管理"></a>Maven依赖管理</h1><h2 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a>依赖配置</h2><p>依赖是指在当前项目中运行所需的jar，依赖配置的格式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--设置当前项目所依赖的所有jar--&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!--设置具体的依赖--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;!--依赖所属群组id--&gt;</span><br><span class="line">        &lt;groupId&gt;Junit&lt;/groupId&gt;</span><br><span class="line">        &lt;!--依赖所属项目id--&gt;</span><br><span class="line">        &lt;artifactId&gt;Junit&lt;/artifactId&gt;</span><br><span class="line">        &lt;!--依赖版本号--&gt;</span><br><span class="line">        &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h2 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a><strong>依赖传递</strong></h2><p>依赖具有传递性，分两种</p><ol><li>直接依赖：在当前项目中通过依赖配置建立的依赖关系</li><li>间接依赖：被依赖的资源如果依赖其他资源，则表明当前项目间接依赖其他资源</li></ol><p>可选依赖：可选依赖指的是对外隐藏当前所依赖的资源（不让别人看）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;Junit&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;Junit&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">        &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><blockquote><p>加一个<code>&lt;optional&gt;</code> <strong>标签</strong></p></blockquote><h2 id="依赖传递冲突"><a href="#依赖传递冲突" class="headerlink" title="依赖传递冲突"></a>依赖传递冲突</h2><p>在依赖传递过程中产生了冲突，我们有三种优先法则</p><ol><li>路径优先：当依赖中出现相同资源时，层级越深，优先级越低，反之则越高</li><li>声明优先：当资源在相同层级被依赖时，配置顺序靠前的覆盖靠后的</li><li>特殊优先：当同级配置了相同资源的不同版本时，后配置的覆盖先配置的</li></ol><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309121927528.png"></p><p>以一个项目为根，直接依赖称为1度资源，直接依赖的直接依赖称为2度资源，直接依赖的直接依赖的直接依赖称为3度资源。</p><h2 id="排除依赖"><a href="#排除依赖" class="headerlink" title="排除依赖"></a>排除依赖</h2><p>排除依赖指主动断开依赖的资源，被排除的资源无需指定版本，使用一个大依赖，排除中间的一个小依赖。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;Junit&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;Junit&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">        &lt;exclusions&gt;</span><br><span class="line">            &lt;exclusion&gt;</span><br><span class="line">                &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">            &lt;/exclusion&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h2 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h2><p>依赖的jar默认情况可以在任何地方可用，可以通过scope标签设定其作用范围</p><p>这里的范围主要是指以下三种范围</p><ol><li>主程序范围有效（src&#x2F;main目录范围内）</li><li>测试程序范围内有效（src&#x2F;test目录范围内）</li><li>是否参与打包（package指令范围内）</li></ol><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309121932057.png"></p><h1 id="Maven生命周期与插件"><a href="#Maven生命周期与插件" class="headerlink" title="Maven生命周期与插件"></a>Maven生命周期与插件</h1><p>Maven对项目构建的生命周期划分为3套</p><ol><li>clear：清理工作</li><li>default：核心工作，例如编译、测试、打包、部署等</li><li>site：产生报告、发布站点等</li></ol><h2 id="clear生命周期"><a href="#clear生命周期" class="headerlink" title="clear生命周期"></a>clear生命周期</h2><p>clean：清理工作</p><ul><li>pre-clean：执行一些在clean之前的工作</li><li>clean：移除上一次构建产生的所有文件</li><li>post-clean：执行一些在clean之后立刻完成的工作</li></ul><h2 id="default生命周期"><a href="#default生命周期" class="headerlink" title="default生命周期"></a>default生命周期</h2><p>default：核心工作，例如编译，测试，打包，部署等</p><p><strong>对于default生命周期，每个事件在执行之前都会将之前的所有事件依次执行一遍</strong></p><p><img src="C:\Users\CWL25\AppData\Roaming\Typora\typora-user-images\image-20230912193439258.png" alt="image-20230912193439258"></p><h2 id="site生命周期"><a href="#site生命周期" class="headerlink" title="site生命周期"></a>site生命周期</h2><ul><li>site：产生报告，发布站点等</li><li>pre-site：执行一些在生成站点文档之前的工作</li><li>site：生成项目的站点文档</li><li>post-site：执行一些在生成站点文档之后完成的工作，为部署做准备</li><li>site-deploy：将生成的站点文档部署到特定的服务器上</li></ul><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><ul><li>插件与生命周期内的阶段绑定，在执行到对应生命周期时执行对应的插件</li><li>maven默认在各个生命周期上都绑定了预先设定的插件来完成相应功能</li><li>插件还可以完成一些自定义功能</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.2.1&lt;/version&gt;</span><br><span class="line">            &lt;executions&gt;</span><br><span class="line">                &lt;excution&gt;</span><br><span class="line">                    &lt;goals&gt;</span><br><span class="line">                        &lt;!--当goal属性的值为test-jar时，是对测试代码打包--&gt;</span><br><span class="line">                        &lt;goal&gt;jar&lt;/goal&gt;</span><br><span class="line">                    &lt;/goals&gt;</span><br><span class="line">                    &lt;phase&gt;generate-test-resources&lt;/phase&gt;</span><br><span class="line">                &lt;/excution&gt;</span><br><span class="line">            &lt;/executions&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p>如果配置成功，在IDEA右侧<code>maven-project</code>操作面板上可以看到</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309121941120.png"></p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
            <tag> 打包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringAOP</title>
      <link href="/2023/08/31/SSM-Spring03/"/>
      <url>/2023/08/31/SSM-Spring03/</url>
      
        <content type="html"><![CDATA[<h1 id="AOP概念"><a href="#AOP概念" class="headerlink" title="AOP概念"></a>AOP概念</h1><p>Spring有两个核心的概念，一个是<code>IOC/DI</code>，一个是<code>AOP</code>。</p><p>AOP(Aspect Oriented Programming)面向切面编程，是一种编程范式，指导开发者如何组织程序结构</p><p>作用：在不惊动原始设计的基础上为其进行功能增强</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Repository</span><br><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        //记录程序当前执行执行（开始时间）</span><br><span class="line">        Long startTime = System.currentTimeMillis();</span><br><span class="line">        //业务执行万次</span><br><span class="line">        for (int i = 0;i&lt;10000;i++) &#123;</span><br><span class="line">            System.out.println(&quot;book dao save ...&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //记录程序当前执行时间（结束时间）</span><br><span class="line">        Long endTime = System.currentTimeMillis();</span><br><span class="line">        //计算时间差</span><br><span class="line">        Long totalTime = endTime-startTime;</span><br><span class="line">        //输出信息</span><br><span class="line">        System.out.println(&quot;执行万次消耗时间：&quot; + totalTime + &quot;ms&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void update()&#123;</span><br><span class="line">        System.out.println(&quot;book dao update ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void delete()&#123;</span><br><span class="line">        System.out.println(&quot;book dao delete ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void select()&#123;</span><br><span class="line">        System.out.println(&quot;book dao select ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当在App类中从容器中获取bookDao对象后，分别执行其<code>save</code>,<code>delete</code>,<code>update</code>和<code>select</code>方法查看打印结果前三个都会计算运行时间</p><blockquote><p>疑问</p><ul><li>对于计算万次执行消耗的时间只有save方法有，为什么delete和update方法也会有呢?</li><li>delete和update方法有，那什么select方法为什么又没有呢?</li></ul></blockquote><p>这个案例中其实就使用了Spring的AOP，在不惊动原有设计的前提下，想给谁添加额外功能就给谁添加。这个也就是Spring的理念：无入侵式&#x2F;无侵入式</p><h2 id="AOP核心概念"><a href="#AOP核心概念" class="headerlink" title="AOP核心概念"></a>AOP核心概念</h2><ol><li>前面一直在强调，Spring的AOP是对一个类的方法在不进行任何修改的前提下实现增强。对于上面的案例中BookServiceImpl中有<code>save</code>,<code>update</code>,<code>delete</code>和<code>select</code>方法,这些方法我们给起了一个名字叫<code>连接点</code></li><li>在BookServiceImpl的四个方法中，<code>update</code>和<code>delete</code>只有打印没有计算万次执行消耗时间，但是在运行的时候已经有该功能，那也就是说<code>update</code>和<code>delete</code>方法都已经被增强，所以对于需要增强的方法我们给起了一个名字叫<code>切入点</code></li><li>执行BookServiceImpl的update和delete方法的时候都被添加了一个计算万次执行消耗时间的功能，将这个功能抽取到一个方法中，换句话说就是存放共性功能的方法，我们给起了个名字叫<code>通知</code></li><li>通知是要增强的内容，会有多个，切入点是需要被增强的方法，也会有多个，那哪个切入点需要添加哪个通知，就需要提前将它们之间的关系描述清楚，那么对于通知和切入点之间的关系描述，我们给起了个名字叫<code>切面</code></li><li>通知是一个方法，方法不能独立存在需要被写在一个类中，这个类我们也给起了个名字叫<code>通知类</code></li></ol><p>总结如下：</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310071525128.png"></p><ul><li>连接点(JoinPoint)：程序执行过程中的任意位置，粒度为执行方法、抛出异常、设置变量等<ul><li>在SpringAOP中，理解为方法的执行</li></ul></li><li>切入点(Pointcut):匹配连接点的式子<ul><li>在SpringAOP中，一个切入点可以描述一个具体方法，也可也匹配多个方法<ul><li>一个具体的方法：如com.blog.dao包下的BookDao接口中的无形参无返回值的save方法</li><li>匹配多个方法：所有的save方法&#x2F;所有的get开头的方法&#x2F;所有以Dao结尾的接口中的任意方法&#x2F;所有带有一个参数的方法</li></ul></li><li>连接点范围要比切入点范围大，是切入点的方法也一定是连接点，但是是连接点的方法就不一定要被增强，所以可能不是切入点。</li></ul></li><li>通知(Advice)：在切入点处执行的操作，也就是共性功能（加强的那部分功能）<ul><li>在SpringAOP中，功能最终以方法的形式呈现</li></ul></li><li>通知类：定义通知的类</li><li>切面(Aspect)：描述通知与切入点的对应关系。</li></ul><p>这部分需要掌握的内容是</p><ul><li>什么是AOP?</li><li>AOP的作用是什么?</li><li>AOP中核心概念分别指的是什么?<ul><li>连接点</li><li>切入点</li><li>通知</li><li>通知类</li><li>切面</li></ul></li></ul><h1 id="AOP入门案例"><a href="#AOP入门案例" class="headerlink" title="AOP入门案例"></a>AOP入门案例</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ol><li><p>创建一个Maven项目</p></li><li><p>pom.xml添加Spring依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>添加BookDao和BookDaoImpl类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface BookDao &#123;</span><br><span class="line">    public void save();</span><br><span class="line">    public void update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Repository</span><br><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void update() &#123;</span><br><span class="line">        System.out.println(&quot;book dao update ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Spring的配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.blog&quot;)</span><br><span class="line">public class SpringConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写App运行类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);</span><br><span class="line">        BookDao bookDao = context.getBean(BookDao.class);</span><br><span class="line">        bookDao.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>说明:</strong></p><ul><li>目前打印save方法的时候，因为方法中有打印系统时间，所以运行的时候是可以看到系统时间</li><li>对于update方法来说，就没有该功能</li><li>我们要使用SpringAOP的方式在不改变update方法的前提下让其具有打印系统时间的功能。</li></ul><h2 id="AOP实现步骤"><a href="#AOP实现步骤" class="headerlink" title="AOP实现步骤"></a>AOP实现步骤</h2><ol><li><p>添加依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.9.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>因为<code>spring-context</code>中已经导入了<code>spring-aop</code>,所以不需要再单独导入<code>spring-aop</code><br>导入AspectJ的jar包,AspectJ是AOP思想的一个具体实现，Spring有自己的AOP实现，但是相比于AspectJ来说比较麻烦，所以我们直接采用Spring整合ApsectJ的方式进行AOP开发。</p></li><li><p>定义接口和实现类<br>准备环境的时候我们已经完成了</p></li><li><p>定义通知类和通知<br>通知就是将共性功能抽取出来后形成的方法，共性功能指的就是当前系统时间的打印。<br>类名和方法名没有要求，可以任意。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class MyAdvice &#123;</span><br><span class="line">    public void method()&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义切入点<br>BookDaoImpl中有两个方法，分别是update()和save()，我们要增强的是update方法，那么该如何定义呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MyAdvice &#123;</span><br><span class="line">    @Pointcut(&quot;execution(void com.blog.dao.impl.BookDaoImpl.update())&quot;)</span><br><span class="line">    private void pt() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void method() &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>切入点定义依托一个不具有实际意义的方法进行，即无参数、无返回值、方法体无实际逻辑。</li><li>execution及后面编写的内容，之后我们会专门去学习。</li></ul></li><li><p>制作切面<br>切面是用来描述通知和切入点之间的关系，如何进行关系的绑定?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MyAdvice &#123;</span><br><span class="line"></span><br><span class="line">    @Pointcut(&quot;execution(void com.blog.dao.BookDao.update())&quot;)</span><br><span class="line">    private void pt()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    @Before(&quot;pt()&quot;)</span><br><span class="line">    public void method()&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绑定切入点与通知关系，并指定通知添加到原始连接点的具体执行<code>位置</code></p><p>说明：<code>@Before</code>翻译过来是之前，也就是说通知会在切入点方法执行之前执行，除此之前还有其他四种类型，后面会讲。<br>那这里就会在执行update()之前，来执行我们的method()，输出当前毫秒值</p></li><li><p>将通知类配给容器并标识其为切面类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">public class MyAdvice &#123;</span><br><span class="line"></span><br><span class="line">    @Pointcut(&quot;execution(void com.blog.dao.impl.BookDaoImpl.update())&quot;)</span><br><span class="line">    private void pt() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Before(&quot;pt()&quot;)</span><br><span class="line">    public void method() &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开启注解格式AOP功能<br>使用<code>@EnableAspectJAutoProxy</code>注解</p></li><li><p>运行程序</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310071549465.png"></p></li></ol><h2 id="注解讲解"><a href="#注解讲解" class="headerlink" title="注解讲解"></a>注解讲解</h2><p>知识点1：<code>@EnableAspectJAutoProxy</code></p><table><thead><tr><th align="center">名称</th><th align="center">@EnableAspectJAutoProxy</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">配置类注解</td></tr><tr><td align="center">位置</td><td align="center">配置类定义上方</td></tr><tr><td align="center">作用</td><td align="center">开启注解格式AOP功能</td></tr></tbody></table><p>知识点2：<code>@Aspect</code></p><table><thead><tr><th align="center">名称</th><th align="center">@Aspect</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">类注解</td></tr><tr><td align="center">位置</td><td align="center">切面类定义上方</td></tr><tr><td align="center">作用</td><td align="center">设置当前类为AOP切面类</td></tr></tbody></table><p>知识点3：<code>@Pointcut</code></p><table><thead><tr><th align="center">名称</th><th align="center">@Pointcut</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">方法注解</td></tr><tr><td align="center">位置</td><td align="center">切入点方法定义上方</td></tr><tr><td align="center">作用</td><td align="center">设置切入点方法</td></tr><tr><td align="center">属性</td><td align="center">value（默认）：切入点表达式</td></tr></tbody></table><p>知识点4：<code>@Before</code></p><table><thead><tr><th align="center">名称</th><th align="center">@Before</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">方法注解</td></tr><tr><td align="center">位置</td><td align="center">通知方法定义上方</td></tr><tr><td align="center">作用</td><td align="center">设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前运行</td></tr></tbody></table><h1 id="AOP工作流程"><a href="#AOP工作流程" class="headerlink" title="AOP工作流程"></a>AOP工作流程</h1><p>AOP的入门案例已经完成，对于刚才案例的执行过程，我们就得来分析分析，这一节我们主要讲解两个知识点:<code>AOP工作流程</code>和<code>AOP核心概念</code>。其中核心概念是对前面核心概念的补充。</p><h2 id="AOP工作流程-1"><a href="#AOP工作流程-1" class="headerlink" title="AOP工作流程"></a>AOP工作流程</h2><p>由于AOP是基于Spring容器管理的bean做的增强，所以整个工作过程需要从Spring加载bean说起</p><ol><li><p>Spring容器启动</p><ul><li>容器启动就需要去加载bean,哪些类需要被加载呢?</li><li>需要被增强的类，如:BookServiceImpl</li><li>通知类，如:MyAdvice</li><li>注意此时bean对象还没有创建成功</li></ul></li><li><p>读取所有切面配置中的切入点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">public class MyAdvice &#123;</span><br><span class="line">    @Pointcut(&quot;execution(void com.blog.dao.impl.BookDaoImpl.update())&quot;)</span><br><span class="line">    private void ptx() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Pointcut(&quot;execution(void com.blog.dao.impl.BookDaoImpl.update())&quot;)</span><br><span class="line">    private void pt() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Before(&quot;pt()&quot;)</span><br><span class="line">    public void method() &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个例子中有两个切入点的配置，但是第一个<code>ptx()</code>并没有被使用，所以不会被读取。</p></li><li><p>初始化bean，判定bean对应的类中的方法是否匹配到任意切入点</p><ul><li><p>注意第一步在容器启动的时候，bean对象还没有被创建成功。</p></li><li><p>要被实例化bean对象的类中的方法和切入点进行匹配</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310071607428.png"></p><p>匹配失败，创建原始对象，如<code>UserDao</code></p><ul><li>匹配失败说明不需要增强，直接调用原始对象的方法即可。</li></ul><p>匹配成功，创建原始对象（<code>目标对象</code>）的<code>代理</code>对象，如:<code>BookDao</code></p><ul><li>匹配成功说明需要对其进行增强</li><li>对哪个类做增强，这个类对应的对象就叫做目标对象</li><li>因为要对目标对象进行功能增强，而采用的技术是动态代理，所以会为其创建一个代理对象</li><li>最终运行的是代理对象的方法，在该方法中会对原始方法进行功能增强</li></ul></li></ul></li><li><p>获取bean执行方法</p><p>获取的bean是<strong>原始对象</strong>时，调用方法并执行，完成操作</p><p>获取的bean是<strong>代理对象</strong>时，根据代理对象的运行模式运行原始方法与增强的内容，完成操作</p></li></ol><h2 id="AOP核心概念-1"><a href="#AOP核心概念-1" class="headerlink" title="AOP核心概念"></a>AOP核心概念</h2><p>在上面介绍AOP的工作流程中，我们提到了两个核心概念，分别是:</p><ul><li>目标对象(Target)：原始功能去掉共性功能对应的类产生的对象，这种对象是无法直接完成最终工作的</li><li>代理(Proxy)：目标对象无法直接完成工作，需要对其进行功能回填，通过原始对象的代理对象实现</li></ul><p>上面这两个概念比较抽象，简单来说</p><p>目标对象就是要增强的类<code>如:BookServiceImpl类</code>对应的对象，也叫原始对象，不能说它不能运行，只能说它在运行的过程中对于要增强的内容是缺失的。</p><p>SpringAOP是在不改变原有设计(代码)的前提下对其进行增强的，它的底层采用的是代理模式实现的，所以要对原始对象进行增强，就需要对原始对象创建代理对象，在代理对象中的方法把通知<code>如:MyAdvice中的method方法</code>内容加进去，就实现了增强，这就是我们所说的代理(Proxy)。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>下面我们来验证一下容器中是否为代理对象</p><ul><li>如果目标对象中的方法<code>会被增强</code>，那么容器中将存入的是目标对象的<code>代理对象</code></li><li>如果目标对象中的方法<code>不被增强</code>，那么容器中将存入的是目标<code>对象本身</code></li></ul><ol><li><p>修改App运行类，获取类的类型并输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);</span><br><span class="line">        BookDao bookDao = context.getBean(BookDao.class);</span><br><span class="line">        System.out.println(bookDao);</span><br><span class="line">        System.out.println(bookDao.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改MyAdvice类，改为<strong>不增强</strong><br>将定义的切入点改为<code>updatexxx</code>，而BookDaoImpl类中不存在该方法，所以BookDao中的update方法在执行的时候，就不会被增强<br>所以此时容器中的对象应该是目标对象本身。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">public class MyAdvice &#123;</span><br><span class="line">    @Pointcut(&quot;execution(void com.blog.dao.impl.BookDaoImpl.updatexxx())&quot;)</span><br><span class="line">    private void pt() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Before(&quot;pt()&quot;)</span><br><span class="line">    public void method() &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行程序</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310071619767.png"></p></li><li><p>修改MyAdvice类，改为增强<br>将定义的切入点改为<code>update</code>，那么BookDao中的update方法在执行的时候，就会被增强<br>所以容器中的对象应该是目标对象的代理对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">public class MyAdvice &#123;</span><br><span class="line">    @Pointcut(&quot;execution(void com.blog.dao.impl.BookDaoImpl.update())&quot;)</span><br><span class="line">    private void pt() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Before(&quot;pt()&quot;)</span><br><span class="line">    public void method() &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行程序</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310071620875.png"></p></li></ol><p>至此对于刚才的结论，我们就得到了验证，这块我们需要注意的是:<br>不能直接打印对象，从上面两次结果中可以看出，直接打印对象走的是对象的toString方法，不管是不是代理对象，打印的结果都是一样的，原因是内部对toString方法进行了重写。</p><h1 id="AOP配置管理"><a href="#AOP配置管理" class="headerlink" title="AOP配置管理"></a>AOP配置管理</h1><h2 id="AOP切入点表达式（给谁加）"><a href="#AOP切入点表达式（给谁加）" class="headerlink" title="AOP切入点表达式（给谁加）"></a>AOP切入点表达式（给谁加）</h2><p>首先我们先要明确两个概念:</p><ul><li>切入点：要进行增强的方法</li><li>切入点表达式：要进行增强的方法的描述方式</li></ul><p>对于AOP中切入点表达式，我们总共会学习三个内容，分别是<code>语法格式</code>、<code>通配符</code>和<code>书写技巧</code>。</p><p>对于切入点的描述，我们其实是有两中方式的，先来看下前面的例子</p><p>由于BookDaoImpl类实现了BookDao接口，那么有如下两种方式来描述：</p><ol><li><p>执行com.blog.dao包下的BookDao<strong>接口</strong>中的无参数update方法</p></li><li><p>执行com.blog.dao.impl包下的BookDaoImpl<strong>实现类</strong>中的无参数update方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">execution(void com.blog.dao.BookDao.update())</span><br><span class="line">execution(void com.blog.dao.impl.BookDaoImpl.update())</span><br></pre></td></tr></table></figure><p>因为调用接口方法的时候最终运行的还是其实现类的方法，所以上面两种描述方式都是可以的。</p></li></ol><p>对于切入点表达式的语法为:</p><p>切入点表达式标准格式：动作关键字(访问修饰符 返回值 包名.类&#x2F;接口名.方法名(参数) 异常名）<br>对于这个格式，我们不需要硬记，通过一个例子，理解它:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(public User com.blog.service.UserService.findById(int))</span><br></pre></td></tr></table></figure><ul><li>execution：动作关键字，描述切入点的行为动作，例如execution表示执行到指定切入点</li><li>public:访问修饰符,还可以是public，private等，可以省略</li><li>User：返回值，写返回值类型</li><li>com.blog.service：包名，多级包使用点连接</li><li>UserService:类&#x2F;接口名称</li><li>findById：方法名</li><li>int:参数，直接写参数的类型，多个类型用逗号隔开</li><li>异常名：方法定义中抛出指定异常，可以省略</li></ul><p>切入点表达式就是要找到需要增强的方法，所以它就是对一个具体方法的描述，但是方法的定义会有很多，所以如果每一个方法对应一个切入点表达式，想想这块就会觉得将来编写起来会比较麻烦，有没有更简单的方式呢?</p><blockquote><p>使用通配符</p></blockquote><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><ol><li><p><code>*</code>:单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现<br>匹配com.blog包下的任意包中的UserService类或接口中所有find开头的带有一个参数的方法</p></li><li><p><code>..</code>：多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写<br>匹配com包下的任意包中的UserService类或接口中所有名称为findById的方法</p></li><li><p><code>+</code>：专用于匹配子类类型<br>这个使用率较低，描述子类的，<code>*Service+</code>，表示所有以Service结尾的接口的子类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">execution（public * com.blog.*.UserService.find*(*))</span><br><span class="line">execution（public User com..UserService.findById(..))</span><br><span class="line">execution(* *..*Service+.*(..))</span><br></pre></td></tr></table></figure></li></ol><p>例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">匹配接口，能匹配到</span><br><span class="line">execution(void com.blog.dao.BookDao.update())</span><br><span class="line"></span><br><span class="line">匹配实现类，能匹配到</span><br><span class="line">execution(void com.blog.dao.impl.BookDaoImpl.update())</span><br><span class="line"></span><br><span class="line">返回值任意，能匹配到</span><br><span class="line">execution(* com.blog.dao.impl.BookDaoImpl.update())</span><br><span class="line"></span><br><span class="line">返回值任意，但是update方法必须要有一个参数，无法匹配，要想匹配需要在update接口和实现类添加参数</span><br><span class="line">execution(* com.blog.dao.impl.BookDaoImpl.update(*))</span><br><span class="line"></span><br><span class="line">返回值为void,com包下的任意包三层包下的任意类的update方法，匹配到的是实现类，能匹配</span><br><span class="line">execution(void com.*.*.*.*.update())</span><br><span class="line"></span><br><span class="line">返回值为void,com包下的任意两层包下的任意类的update方法，匹配到的是接口，能匹配</span><br><span class="line">execution(void com.*.*.*.update())</span><br><span class="line"></span><br><span class="line">返回值为void，方法名是update的任意包下的任意类，能匹配</span><br><span class="line">execution(void *..update())</span><br><span class="line"></span><br><span class="line">匹配项目中任意类的任意方法，能匹配，但是不建议使用这种方式，影响范围广</span><br><span class="line">execution(* *..*(..))</span><br><span class="line"></span><br><span class="line">匹配项目中任意包任意类下只要以u开头的方法，update方法能满足，能匹配</span><br><span class="line">execution(* *..u*(..))</span><br><span class="line"></span><br><span class="line">匹配项目中任意包任意类下只要以e结尾的方法，update和save方法能满足，能匹配</span><br><span class="line">execution(* *..*e(..))</span><br><span class="line"></span><br><span class="line">返回值为void，com包下的任意包任意类任意方法，能匹配，*代表的是方法</span><br><span class="line">execution(void com..*())</span><br><span class="line"></span><br><span class="line">将项目中所有业务层方法的以find开头的方法匹配</span><br><span class="line">execution(* com.blog.*.*Service.find*(..))</span><br><span class="line"></span><br><span class="line">将项目中所有业务层方法的以save开头的方法匹配</span><br><span class="line">execution(* com.blog.*.*Service.save*(..))</span><br></pre></td></tr></table></figure><h3 id="书写技巧"><a href="#书写技巧" class="headerlink" title="书写技巧"></a>书写技巧</h3><p>对于切入点表达式的编写其实是很灵活的，那么在编写的时候，有没有什么好的技巧让我们用用:</p><ul><li>所有代码按照标准规范开发，否则以下技巧全部失效</li><li>描述切入点通常<code>描述接口</code>，而不描述实现类,如果描述到实现类，就出现紧耦合了</li><li>访问控制修饰符针对接口开发均采用public描述（<code>可省略访问控制修饰符描述</code>）</li><li>返回值类型对于增删改类使用精准类型加速匹配，对于查询类使用<code>*</code>通配快速描述</li><li><code>包名</code>书写尽量不使用<code>..</code>匹配，效率过低，常用<code>*</code>做单个包描述匹配，或精准匹配</li><li><code>接口名/类名</code>书写名称与模块相关的采用<code>*</code>匹配，例如UserService书写成<code>*Service</code>，绑定业务层接口名</li><li>方法名书写以<code>动词</code>进行<code>精准匹配</code>，名词采用<code>*</code>匹配，例如<code>getById</code>书写成<code>getBy*</code>，<code>selectAll</code>书写成<code>selectAll</code></li><li>参数规则较为复杂，根据业务方法灵活调整</li><li>通常<code>不使用异常</code>作为<code>匹配</code>规则</li></ul><h2 id="AOP通知类型（往哪加）"><a href="#AOP通知类型（往哪加）" class="headerlink" title="AOP通知类型（往哪加）"></a>AOP通知类型（往哪加）</h2><p>AOP通知:</p><p>AOP通知描述了抽取的共性功能，根据共性功能抽取的位置不同，最终运行代码时要将其加入到合理的位置</p><p>共提供了5种通知类型</p><ul><li>前置通知 before</li><li>后置通知 after</li><li><code>环绕通知(重点)</code> around</li><li>返回后通知(了解) </li><li>抛出异常后通知(了解)</li></ul><p>知识点1：<code>@After</code></p><table><thead><tr><th align="center">名称</th><th align="center">@After</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">方法注解</td></tr><tr><td align="center">位置</td><td align="center">通知方法定义上方</td></tr><tr><td align="center">作用</td><td align="center">设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法后运行</td></tr></tbody></table><p>知识点2：<code>@AfterReturning</code></p><table><thead><tr><th align="center">名称</th><th align="center">@AfterReturning</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">方法注解</td></tr><tr><td align="center">位置</td><td align="center">通知方法定义上方</td></tr><tr><td align="center">作用</td><td align="center">设置当前通知方法与切入点之间绑定关系，当前通知方法在原始切入点方法正常执行完毕后执行</td></tr></tbody></table><p>知识点3：<code>@AfterThrowing</code></p><table><thead><tr><th align="center">名称</th><th align="center">@AfterThrowing</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">方法注解</td></tr><tr><td align="center">位置</td><td align="center">通知方法定义上方</td></tr><tr><td align="center">作用</td><td align="center">设置当前通知方法与切入点之间绑定关系，当前通知方法在原始切入点方法运行抛出异常后执行</td></tr></tbody></table><p>知识点4：<code>@Around</code></p><table><thead><tr><th align="center">名称</th><th align="center">@Around</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">方法注解</td></tr><tr><td align="center">位置</td><td align="center">通知方法定义上方</td></tr><tr><td align="center">作用</td><td align="center">设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前后运行</td></tr></tbody></table><p>知识点5：<code>@Before</code></p><table><thead><tr><th align="center">名称</th><th align="center">@Before</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">方法注解</td></tr><tr><td align="center">位置</td><td align="center">通知方法定义上方</td></tr><tr><td align="center">作用</td><td align="center">设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前运行</td></tr></tbody></table><p>环绕通知注意事项</p><ol><li>环绕通知必须依赖形参ProceedingJoinPoint才能实现对原始方法的调用，进而实现原始方法调用前后同时添加通知</li><li>通知中如果未使用ProceedingJoinPoint对原始方法进行调用将跳过原始方法的执行</li><li>对原始方法的调用可以不接收返回值，通知方法设置成void即可，如果接收返回值，最好设定为Object类型</li><li>原始方法的返回值如果是void类型，通知方法的返回值类型可以设置成void,也可以设置成Object</li><li>由于无法预知原始方法运行后是否会抛出异常，因此环绕通知方法必须要处理Throwable异常</li></ol><h3 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h3><p>因为环绕通知需要在原始方法的前后进行增强，所以环绕通知就必须要能对原始操作进行调用，具体如何实现?</p><p>在方法参数中添加<code>ProceedingJoinPoint</code>，同时在需要的位置使用<code>proceed()</code>调用原始操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">public class MyAdvice &#123;</span><br><span class="line">    @Pointcut(&quot;execution(void com.blog.dao.BookDao.update())&quot;)</span><br><span class="line">    private void pt() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Around(&quot;pt()&quot;)</span><br><span class="line">    public void around(ProceedingJoinPoint pjp) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;around before advice ...&quot;);</span><br><span class="line">        //表示对原始操作的调用</span><br><span class="line">        pjp.proceed();</span><br><span class="line">        System.out.println(&quot;around after advice ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学习完这5种通知类型，我们来思考下环绕通知是如何实现其他通知类型的功能的?</p><p>因为环绕通知是可以控制原始方法执行的，所以我们把增强的代码写在调用原始方法的不同位置就可以实现不同的通知类型的功能，如</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310071701617.png"></p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
            <tag> Spring </tag>
            
            <tag> aop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring事务</title>
      <link href="/2023/08/31/SSM-Spring04/"/>
      <url>/2023/08/31/SSM-Spring04/</url>
      
        <content type="html"><![CDATA[<h1 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h1><p>事务作用：在数据层保障一系列的数据库操作同成功同失败</p><p>Spring事务作用：在数据层或业务层保障一系列的数据库操作同成功同失败</p><p>数据层有事务我们可以理解，为什么业务层也需要处理事务呢？举个简单的例子</p><ul><li>转账业务会有两次数据层的调用，一次是加钱一次是减钱</li><li>把事务放在数据层，加钱和减钱就有两个事务</li><li>没办法保证加钱和减钱同时成功或者同时失败</li><li>这个时候就需要将事务放在业务层进行处理。</li></ul><p>Spring为了管理事务，提供了一个平台事务管理器<code>PlatformTransactionManager</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface PlatformTransactionManager extends TransactionManager &#123;</span><br><span class="line">    TransactionStatus getTransaction(@Nullable TransactionDefinition var1) throws TransactionException;</span><br><span class="line"></span><br><span class="line">    void commit(TransactionStatus var1) throws TransactionException;</span><br><span class="line"></span><br><span class="line">    void rollback(TransactionStatus var1) throws TransactionException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>commit是用来提交事务，rollback是用来回滚事务。</p><p>PlatformTransactionManager只是一个接口，Spring还为其提供了一个具体的实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class DataSourceTransactionManager extends AbstractPlatformTransactionManager implements ResourceTransactionManager, InitializingBean &#123;</span><br><span class="line">    @Nullable</span><br><span class="line">    private DataSource dataSource;</span><br><span class="line">    private boolean enforceReadOnly;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从名称上可以看出，我们只需要给它一个DataSource对象，它就可以帮你去在业务层管理事务。其内部采用的是JDBC的事务。所以说如果你持久层采用的是JDBC相关的技术，就可以采用这个事务管理器来管理你的事务。而Mybatis内部采用的就是JDBC的事务，所以后期我们Spring整合Mybatis就采用的这个<code>DataSourceTransactionManager</code>事务管理器。</p><h2 id="转账案例–需求分析"><a href="#转账案例–需求分析" class="headerlink" title="转账案例–需求分析"></a>转账案例–需求分析</h2><p>接下来通过一个案例来学习下Spring是如何来管理事务的。</p><p>先来分析下需求:</p><ul><li>需求: 实现任意两个账户间转账操作</li><li>需求微缩: A账户减钱，B账户加钱</li></ul><p>为了实现上述的业务需求，我们可以按照下面步骤来实现下:</p><ol><li>数据层提供基础操作，指定账户减钱（outMoney），指定账户加钱（inMoney）</li><li>业务层提供转账操作（transfer），调用减钱与加钱的操作</li><li>提供2个账号和操作金额执行转账操作</li><li>基于Spring整合MyBatis环境搭建上述操作</li></ol><h3 id="转账案例–环境搭建"><a href="#转账案例–环境搭建" class="headerlink" title="转账案例–环境搭建"></a>转账案例–环境搭建</h3><ol><li><p>准备数据表<br>Tom和Jerry初始金额都是1000</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE spring_db CHARACTER SET utf8;</span><br><span class="line">USE spring_db;</span><br><span class="line">CREATE TABLE tbl_account(</span><br><span class="line">    id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    NAME VARCHAR(35),</span><br><span class="line">    money DOUBLE</span><br><span class="line">);</span><br><span class="line">INSERT INTO tbl_account(`name`,money) VALUES(&#x27;Tom&#x27;,1000),(&#x27;Jerry&#x27;,1000);</span><br></pre></td></tr></table></figure></li><li><p>创建项目导入jar包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.16&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.5.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.46&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>根据表创建模型类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class Account &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String name;</span><br><span class="line">    private Double money;</span><br><span class="line"></span><br><span class="line">    public Account() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Account(Integer id, String name, Double money) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Double getMoney() &#123;</span><br><span class="line">        return money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMoney(Double money) &#123;</span><br><span class="line">        this.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Account&#123;&quot; +</span><br><span class="line">                &quot;id=&quot; + id +</span><br><span class="line">                &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, money=&quot; + money +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Dao接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface AccountDao &#123;</span><br><span class="line"></span><br><span class="line">    @Update(&quot;update tbl_account set money = money + #&#123;money&#125; where name = #&#123;name&#125;&quot;)</span><br><span class="line">    void inMoney(@Param(&quot;name&quot;) String name,@Param(&quot;money&quot;) Double money);</span><br><span class="line"></span><br><span class="line">    @Update(&quot;update tbl_account set money = money - #&#123;money&#125; where name = #&#123;name&#125;&quot;)</span><br><span class="line">    void outMoney(@Param(&quot;name&quot;) String name, @Param(&quot;money&quot;) Double money);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Service接口和实现类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface AccountService &#123;    </span><br><span class="line">/**     </span><br><span class="line">* 转账操作     </span><br><span class="line">* @param out 转出方     </span><br><span class="line">* @param in 转入方     </span><br><span class="line">* @param money 金额     </span><br><span class="line">*/    </span><br><span class="line">public void transfer(String out,String in,Double money);&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class AccountServiceImpl implements AccountService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    protected AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    public void transfer(String out, String in, Double money) &#123;</span><br><span class="line">        accountDao.outMoney(out, money);</span><br><span class="line">        accountDao.inMoney(in, money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加jdbc.properties文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql://localhost:13306/spring_db?useSSL=false</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=poassword.</span><br></pre></td></tr></table></figure></li><li><p>创建JdbcConfig配置类</p></li></ol>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class JdbcConfig &#123;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span><br><span class="line">    private String driver;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.url&#125;&quot;)</span><br><span class="line">    private String url;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.username&#125;&quot;)</span><br><span class="line">    private String username;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.password&#125;&quot;)</span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource() &#123;</span><br><span class="line">        DruidDataSource dataSource = new DruidDataSource();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        return dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li><p>创建MybatisConfig配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class MyBatisConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource)&#123;</span><br><span class="line">        SqlSessionFactoryBean factory = new SqlSessionFactoryBean();</span><br><span class="line">        factory.setTypeAliasesPackage(&quot;com.blog.domain&quot;);</span><br><span class="line">        factory.setDataSource(dataSource);</span><br><span class="line">        return factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MapperScannerConfigurer mapperScannerConfigurer()&#123;</span><br><span class="line">        MapperScannerConfigurer msc = new MapperScannerConfigurer();</span><br><span class="line">        msc.setBasePackage(&quot;com.blog.dao&quot;);</span><br><span class="line">        return msc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建SpringConfig配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.blog&quot;)</span><br><span class="line">@PropertySource(&quot;jdbc.properties&quot;)</span><br><span class="line">@Import(&#123;JdbcConfig.class, MyBatisConfig.class&#125;)</span><br><span class="line">public class SpringConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写测试类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(classes = SpringConfig.class)</span><br><span class="line">public class AccountServiceTest &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private AccountService accountService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testTransfer() &#123;</span><br><span class="line">        accountService.transfer(&quot;Tom&quot;, &quot;Jerry&quot;, 100D);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="事务管理-1"><a href="#事务管理-1" class="headerlink" title="事务管理"></a>事务管理</h3><p>上述环境，运行单元测试类，会执行转账操作，<code>Tom</code>的账户会减少100，<code>Jerry</code>的账户会加100。</p><p>这是正常情况下的运行结果，但是如果在转账的过程中出现了异常，如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class AccountServiceImpl implements AccountService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    protected AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    public void transfer(String out, String in, Double money) &#123;</span><br><span class="line">        accountDao.outMoney(out, money);</span><br><span class="line">        int a = 1 / 0;</span><br><span class="line">        accountDao.inMoney(in, money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候就模拟了转账过程中出现异常的情况，此时进行转账，<code>Tom</code>的账户会减少100，而<code>Jerry</code>的账户却不会增加100<br>那我们来分析一下刚才的结果</p><ul><li>程序正常执行时，账户金额A减B加，没有问题</li><li>程序出现异常后，转账失败，但是异常之前操作成功，异常之后操作失败，整体业务失败</li></ul><p>当程序出问题后，我们需要让事务进行回滚，而且这个事务应该是加在业务层上，而Spring的事务管理就是用来解决这类问题的。</p><p>Spring事务管理具体的实现步骤如下：</p><ol><li><p>在需要被事务管理的方法上添加<code>@Transactional</code>注解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class AccountServiceImpl implements AccountService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    protected AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public void transfer(String out, String in, Double money) &#123;</span><br><span class="line">        accountDao.outMoney(out, money);</span><br><span class="line">        int a = 1 / 0;</span><br><span class="line">        accountDao.inMoney(in, money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意:<code>@Transactional</code>可以写在接口类上、接口方法上、实现类上和实现类方法上</p><ul><li>写在接口类上，该接口的所有实现类的所有方法都会有事务</li><li>写在接口方法上，该接口的所有实现类的该方法都会有事务</li><li>写在实现类上，该类中的所有方法都会有事务</li><li>写在实现类方法上，该方法上有事务</li><li><code>建议写在实现类或实现类的方法上</code></li></ul></blockquote></li><li><p>在JdbcConfig类中配置事务管理器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class JdbcConfig &#123;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span><br><span class="line">    private String driver;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.url&#125;&quot;)</span><br><span class="line">    private String url;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.username&#125;&quot;)</span><br><span class="line">    private String username;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.password&#125;&quot;)</span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource() &#123;</span><br><span class="line">        DruidDataSource dataSource = new DruidDataSource();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        return dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //配置事务管理器，mybatis使用的是jdbc事务</span><br><span class="line">    @Bean</span><br><span class="line">    public PlatformTransactionManager platformTransactionManager(DataSource dataSource)&#123;</span><br><span class="line">        DataSourceTransactionManager transactionManager = new DataSourceTransactionManager();</span><br><span class="line">        transactionManager.setDataSource(dataSource);</span><br><span class="line">        return transactionManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：事务管理器要根据使用技术进行选择，Mybatis框架使用的是JDBC事务，可以直接使用<code>DataSourceTransactionManager</code></p></blockquote></li><li><p>开启事务注解<code>@EnableTransactionManagement</code></p></li><li><p>运行测试类<br>运行程序之后，我们去数据库查看Tom和Jerry的金额，发现没有变化<br>那么说明在转换的业务出现错误后，事务就可以控制回滚，保证数据的正确性</p></li></ol><h3 id="注解介绍"><a href="#注解介绍" class="headerlink" title="注解介绍"></a>注解介绍</h3><p>知识点1：<code>@EnableTransactionManagement</code></p><table><thead><tr><th align="center">名称</th><th align="center">@EnableTransactionManagement</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">配置类注解</td></tr><tr><td align="center">位置</td><td align="center">配置类定义上方</td></tr><tr><td align="center">作用</td><td align="center">设置当前Spring环境中开启注解式事务支持</td></tr></tbody></table><p>知识点2：<code>@Transactional</code></p><table><thead><tr><th align="center">名称</th><th align="center">@Transactional</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">接口注解 类注解 方法注解</td></tr><tr><td align="center">位置</td><td align="center">业务层接口上方 业务层实现类上方 业务方法上方</td></tr><tr><td align="center">作用</td><td align="center">为当前业务层方法添加事务（如果设置在类或接口上方则类或接口中所有方法均添加事务）</td></tr></tbody></table><h2 id="Spring事务角色"><a href="#Spring事务角色" class="headerlink" title="Spring事务角色"></a>Spring事务角色</h2><p>这部分我们重点要理解两个概念，分别是<code>事务管理员</code>和<code>事务协调员</code>。</p><p>当未开启Spring事务之前</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310072142554.png"></p><p>AccountDao的outMoney因为是修改操作，会开启一个事务T1</p><p>AccountDao的inMoney因为是修改操作，会开启一个事务T2</p><p>AccountService的transfer没有事务，</p><ul><li>运行过程中如果没有抛出异常，则T1和T2都正常提交，数据正确</li><li>如果在两个方法中间抛出异常，T1因为执行成功提交事务，T2因为抛异常不会被执行</li><li>就会导致数据出现错误</li></ul><p>当开启Spring的事务管理后<br><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310072143681.png"></p><p>transfer上添加了@Transactional注解，在该方法上就会有一个事务T</p><p>AccountDao的outMoney方法的事务T1加入到transfer的事务T中</p><p>AccountDao的inMoney方法的事务T2加入到transfer的事务T中</p><p>这样就保证他们在同一个事务中，当业务层中出现异常，整个事务就会回滚，保证数据的准确性。</p><p>通过上面例子的分析，我们就可以得到如下概念:</p><ul><li>事务管理员：发起事务方，在Spring中通常指代业务层开启事务的方法</li><li>事务协调员：加入事务方，在Spring中通常指代数据层方法，也可以是业务层方法</li></ul><blockquote><p>注意：目前的事务管理是基于<code>DataSourceTransactionManager</code>和<code>SqlSessionFactoryBean</code>使用的是同一个数据源。</p></blockquote><h2 id="Spring事务属性"><a href="#Spring事务属性" class="headerlink" title="Spring事务属性"></a>Spring事务属性</h2><p>这部分我们主要学习三部分内容<code>事务配置</code>、<code>转账业务追加日志</code>、<code>事务传播行为</code>。</p><h3 id="事务配置"><a href="#事务配置" class="headerlink" title="事务配置"></a>事务配置</h3><table><thead><tr><th align="center">属性</th><th align="center">作用</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">readOnly</td><td align="center">设置是否为只读事务</td><td align="center">readOnly &#x3D; true 只读事务</td></tr><tr><td align="center">timeout</td><td align="center">设置事务超时时间</td><td align="center">timeout &#x3D; -1(永不超时)</td></tr><tr><td align="center">rollbackFor</td><td align="center">设置事务回滚异常(class)</td><td align="center">rollbackFor{NullPointException.class}</td></tr><tr><td align="center">rollbackForClassName</td><td align="center">设置事务回滚异常（String)</td><td align="center">同上格式为字符串</td></tr><tr><td align="center">noRollbackFor</td><td align="center">设置事务不回滚异常(class)</td><td align="center">noRollbackFor{NullPointExceptior.class}</td></tr><tr><td align="center">noRollbackForClassName</td><td align="center">设置事务不回滚异常(String)</td><td align="center">同上格式为字符串</td></tr><tr><td align="center">isolation</td><td align="center">设置事务隔离级别</td><td align="center">isolation &#x3D; Isolation. DEFAULT</td></tr><tr><td align="center">propagation</td><td align="center">设置事务传播行为</td><td align="center">…</td></tr></tbody></table><p>上面这些属性都可以在<code>@Transactional</code>注解的参数上进行设置。</p><ul><li><p>readOnly：true只读事务，false读写事务，增删改要设为false,查询设为true。</p></li><li><p>timeout:设置超时时间单位秒，在多长时间之内事务没有提交成功就自动回滚，-1表示不设置超时时间。</p></li><li><p>rollbackFor:当出现指定异常进行事务回滚</p></li><li><p>noRollbackFor:当出现指定异常不进行事务回滚</p><ul><li><p>思考:出现异常事务会自动回滚，这个是我们之前就已经知道的</p></li><li><p>noRollbackFor是设定对于指定的异常不回滚，这个好理解</p></li><li><p>rollbackFor是指定回滚异常，对于异常事务不应该都回滚么，为什么还要指定?</p><ul><li><p>事实上Spring的事务只会对<code>Error异常</code>和<code>RuntimeException异常</code>及其子类进行事务回顾，其他的异常类型是不会回滚的，如下面的代码就不会回滚</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class AccountServiceImpl implements AccountService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    protected AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public void transfer(String out, String in, Double money) throws IOException &#123;</span><br><span class="line">        accountDao.outMoney(out, money);</span><br><span class="line">        if (true) throw new IOException();</span><br><span class="line">        accountDao.inMoney(in, money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>有些异常它真不回滚</strong>，此时就可以使用rollbackFor属性来设置出现IOException异常不回滚</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class AccountServiceImpl implements AccountService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    protected AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    @Transactional(rollbackFor = &#123;IOException.class&#125;)</span><br><span class="line">    public void transfer(String out, String in, Double money) throws IOException &#123;</span><br><span class="line">        accountDao.outMoney(out, money);</span><br><span class="line">        if (true) throw new IOException();</span><br><span class="line">        accountDao.inMoney(in, money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>rollbackForClassName等同于rollbackFor,只不过属性为异常的类全名字符串</p></li><li><p>noRollbackForClassName等同于noRollbackFor，只不过属性为异常的类全名字符串</p></li><li><p>isolation设置事务的隔离级别</p><ul><li>DEFAULT :默认隔离级别, 会采用数据库的隔离级别</li><li>READ_UNCOMMITTED : 读未提交</li><li>READ_COMMITTED : 读已提交</li><li>REPEATABLE_READ : 重复读取</li><li>SERIALIZABLE: 串行化</li></ul></li></ul></li></ul></li></ul><p>介绍完上述属性后，还有最后一个事务的传播行为，为了讲解该属性的设置，我们需要完成下面的案例。</p><h3 id="转账业务追加日志案例"><a href="#转账业务追加日志案例" class="headerlink" title="转账业务追加日志案例"></a>转账业务追加日志案例</h3><p> 需求分析</p><ul><li><p>在前面的转账案例的基础上添加新的需求，完成转账后记录日志。</p><ul><li>需求：实现任意两个账户间转账操作，并对每次转账操作在数据库进行留痕</li><li>需求微缩：A账户减钱，B账户加钱，数据库记录日志</li></ul></li><li><p>基于上述的业务需求，我们来分析下该如何实现：</p><ol><li>基于转账操作案例添加日志模块，实现数据库中记录日志</li><li>业务层转账操作（transfer），调用减钱、加钱与记录日志功能</li></ol></li><li><p>需要注意一点就是，我们这个案例的预期效果为:</p><ul><li><strong><code>无论转账操作是否成功，均进行转账操作的日志留痕</code></strong></li></ul></li></ul><p>环境准备：</p><ol><li><p>创建日志表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table tbl_log(</span><br><span class="line">   id int primary key auto_increment,</span><br><span class="line">   info varchar(255),</span><br><span class="line">   createDate datetime</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>添加LogDao接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface LogDao &#123;</span><br><span class="line"></span><br><span class="line">    @Insert(&quot;insert into tbl_log(info, createDate) VALUES (#&#123;info&#125;,now())&quot;)</span><br><span class="line">    void log(String info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加LogService接口和实现类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface LogService &#123;</span><br><span class="line">    void log(String out, String in, Double money);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class LogServiceImpl implements LogService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private LogDao logDao;</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public void log(String out, String in, Double money) &#123;</span><br><span class="line">        logDao.log(out + &quot;向&quot; + in + &quot;转账&quot; + money + &quot;元&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在转账的业务中添加记录日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class AccountServiceImpl implements AccountService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    protected AccountDao accountDao;</span><br><span class="line">    @Autowired</span><br><span class="line">    protected LogService logService;</span><br><span class="line"></span><br><span class="line">    @Transactional(rollbackFor = &#123;IOException.class&#125;)</span><br><span class="line">    public void transfer(String out, String in, Double money) throws IOException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            accountDao.outMoney(out, money);</span><br><span class="line">            accountDao.inMoney(in, money);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            logService.log(out, in, money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行程序</p><ul><li>当程序正常运行，tbl_account表中转账成功，tbl_log表中日志记录成功</li><li>当转账业务之间出现异常(int i &#x3D;1 &#x2F; 0),转账失败，tbl_account成功回滚，但是tbl_log表未添加数据，说明也回滚了</li><li>这个结果和我们想要的不一样，什么原因?该如何解决?<ul><li>失败原因：日志的记录与转账操作隶属同一个事务，同成功同失败（同回滚）</li><li>解决方案：继续往下看</li><li>预期效果：无论转账操作是否成功，日志必须保留</li></ul></li></ul></li></ol><h3 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h3><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310072149242.png"></p><p>对于上述案例的分析:</p><ul><li>log方法、inMoney方法和outMoney方法都属于增删改，分别有事务T1,T2,T3</li><li>transfer因为加了<code>@Transactional</code>注解，也开启了事务T</li><li>前面我们讲过Spring事务会把T1,T2,T3都加入到事务T中</li><li>所以当转账失败后，<code>所有的事务都回滚</code>，导致日志没有记录下来</li><li>这和我们的需求不符，这个时候我们就想能不能让log方法单独是一个事务呢?</li></ul><p>要想解决这个问题，就需要用到事务传播行为，所谓的事务传播行为指的是:</p><ul><li><p>事务传播行为：事务协调员对事务管理员所携带事务的处理态度。</p><ul><li>具体如何解决，就需要用到之前我们没有说的<code>propagation属性</code>。</li></ul></li><li><p>修改logService改变事务的传播行为</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class LogServiceImpl implements LogService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private LogDao logDao;</span><br><span class="line"></span><br><span class="line">    @Transactional(propagation = Propagation.REQUIRES_NEW)</span><br><span class="line">    public void log(String out, String in, Double money) &#123;</span><br><span class="line">        logDao.log(out + &quot;向&quot; + in + &quot;转账&quot; + money + &quot;元&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后，就能实现我们想要的结果，不管转账是否成功，都会记录日志。</p><p>事务传播行为的可选值</p><table><thead><tr><th>传播属性</th><th>事务管理员</th><th>事务协调员</th></tr></thead><tbody><tr><td>REQUIRED(默认)</td><td>开启T</td><td>加入T</td></tr><tr><td>无</td><td>新建T2</td><td></td></tr><tr><td>REQUIRES_NEW</td><td>开启T</td><td>新建T2</td></tr><tr><td>无</td><td>新建T2</td><td></td></tr><tr><td>SUPPORTS</td><td>开启T</td><td>加入T</td></tr><tr><td>无</td><td>无</td><td></td></tr><tr><td>NOT_SUPPORTED</td><td>开启T</td><td>无</td></tr><tr><td>无</td><td>无</td><td></td></tr><tr><td>MANDTORY</td><td>开启T</td><td>加入T</td></tr><tr><td>无</td><td>ERROR</td><td></td></tr><tr><td>NEVER</td><td>开启T</td><td>ERROR</td></tr><tr><td>无</td><td>无</td><td></td></tr><tr><td>NESTED</td><td>设置savePoint,一旦事务回滚，事务将回滚到savePoint处，交由客户响应提交&#x2F;回滚</td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
            <tag> Spring </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring入门</title>
      <link href="/2023/08/30/Spring%E5%85%A5%E9%97%A8.1/"/>
      <url>/2023/08/30/Spring%E5%85%A5%E9%97%A8.1/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring相关概念"><a href="#Spring相关概念" class="headerlink" title="Spring相关概念"></a>Spring相关概念</h1><h2 id="Spring家族"><a href="#Spring家族" class="headerlink" title="Spring家族"></a>Spring家族</h2><p>官网：<a href="https://spring.io,/">https://spring.io，</a> 从官网我们可以大概了解到：</p><ul><li><p>Spring能做什么:用以开发web、微服务以及分布式系统等,光这三块就已经占了JavaEE开发的九成多。</p></li><li><p>Spring并不是单一的一个技术，而是一个大家族，可以从官网的<code>Projects</code>中查看其包含的所有技术。</p></li><li><p>Spring发展到今天已经形成了一种开发的生态圈,Spring提供了若干个项目,每个项目用于完成特定的功能。</p><ul><li>Spring已形成了完整的生态圈，也就是说我们可以完全使用Spring技术完成整个项目的构建、设计与开发。</li><li>Spring有若干个项目，可以根据需要自行选择，把这些个项目组合起来，起了一个名称叫Spring全家桶</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309122209999.png"></p><p>重点关注<code>Spring Framework</code>、<code>SpringBoot</code>和<code>SpringCloud</code></p><ul><li>Spring Framework：Spring框架，是Spring中最早最核心的技术，也是所有其他技术的基础。</li><li>SpringBoot：Spring是来简化开发，而SpringBoot是来帮助Spring在简化的基础上能更快速进行开发。</li><li>SpringCloud：这个是用来做分布式之微服务架构的相关开发。</li></ul><p>Spring Framework架构图以4的架构图</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309122211853.png"></p><ol><li>核心层<ul><li>Core Container：核心容器，这个模块是Spring最核心的模块，其他的都需要依赖该模块</li></ul></li><li>AOP层<ul><li>AOP(Aspect Oriented Programming)：面向切面编程，它依赖核心层容器，目的是在不改变原有代码的前提下对其进行功能增强</li><li>Aspects：AOP是思想，Aspects是对AOP思想的具体实现</li></ul></li><li>数据层<ul><li>Data Access：数据访问，Spring全家桶中有对数据访问的具体实现技术</li><li>Data Integration：数据集成，Spring支持整合其他的数据层解决方案，比如Mybatis</li><li>Transactions：事务，Spring中事务管理是Spring AOP的一个具体实现，也是后期学习的重点内容</li></ul></li><li>Web层<ul><li>这一层的内容将在SpringMVC框架具体学习</li></ul></li><li>Test层<ul><li>Spring主要整合了Junit来完成单元测试和集成测试</li></ul></li></ol><h2 id="Spring核心概念"><a href="#Spring核心概念" class="headerlink" title="Spring核心概念"></a>Spring核心概念</h2><p>在Spring核心概念这部分内容中主要包含<code>IOC/DI</code>、<code>IOC容器</code>和<code>Bean</code></p><h3 id="IOC-Inversion-of-Control-控制反转"><a href="#IOC-Inversion-of-Control-控制反转" class="headerlink" title="IOC(Inversion of Control)控制反转"></a>IOC(Inversion of Control)控制反转</h3><ul><li>什么是控制反转<ul><li>使用对象时，由主动new产生对象转换为由<code>外部</code>提供对象，此过程中对象创建控制权由程序转移到外部，此思想称为控制反转。</li><li>业务层要用数据层的类对象，以前是自己<code>new</code>的</li><li>现在自己不new了，交给<code>别人[外部]</code>来创建对象</li><li><code>别人[外部]</code>就反转控制了数据层对象的创建权</li><li>这种思想就是控制反转</li><li>别人[外部]指的是什么呢?继续往下看</li></ul></li><li>Spring和IOC之间的关系是什么呢?<ul><li>Spring技术对IOC思想进行了实现</li><li>Spring提供了一个容器，称为<code>IOC容器</code>，用来充当IOC思想中的”外部”</li><li>IOC思想中的<code>别人[外部]</code>指的就是Spring的IOC容器</li></ul></li><li>IOC容器的作用以及内部存放的是什么?<ul><li>IOC容器负责对象的创建、初始化等一系列工作，其中包含了数据层和业务层的类对象</li><li>被创建或被管理的对象在IOC容器中统称为Bean</li><li>IOC容器中放的就是一个个的Bean对象</li></ul></li><li>当IOC容器中创建好service和dao对象后，程序能正确执行么?<ul><li>不行，因为service运行需要依赖dao对象</li><li>IOC容器中虽然有service和dao对象</li><li>但是service对象和dao对象没有任何关系</li><li>需要把dao对象交给service,也就是说要绑定service和dao对象之间的关系</li><li>像这种在容器中建立对象与对象之间的绑定关系就要用到DI(Dependency Injection)依赖注入.</li></ul></li></ul><h3 id="DI-Dependency-Injection-依赖注入"><a href="#DI-Dependency-Injection-依赖注入" class="headerlink" title="DI(Dependency Injection)依赖注入"></a>DI(Dependency Injection)依赖注入</h3><ul><li>什么是依赖注入呢?<ul><li>在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入<ul><li>业务层要用数据层的类对象，以前是自己<code>new</code>的</li><li>现在自己不new了，靠<code>别人[外部其实指的就是IOC容器]</code>来给注入进来</li><li>这种思想就是依赖注入</li></ul></li></ul></li><li>IOC容器中哪些bean之间要建立依赖关系呢?<ul><li>这个需要程序员根据业务需求提前建立好关系，如业务层需要依赖数据层，service就要和dao建立依赖关系</li></ul></li><li>介绍完Spring的IOC和DI的概念后，我们会发现这两个概念的最终目标就是:充分解耦，具体实现靠:<ul><li>使用IOC容器管理bean（IOC)</li><li>在IOC容器内将有依赖关系的bean进行关系绑定（DI）</li><li>最终结果为:使用对象时不仅可以直接从IOC容器中获取，并且获取到的bean已经绑定了所有的依赖关系.</li></ul></li></ul><p><a href="https://zhuanlan.zhihu.com/p/33492169">理解文章</a></p><p>重点要理解<code>什么是IOC/DI思想</code>、<code>什么是IOC容器</code>和<code>什么是Bean</code>：</p><ol><li>什么IOC&#x2F;DI思想?<ul><li>IOC:控制反转，控制反转的是对象的创建权</li><li>DI:依赖注入，绑定对象与对象之间的依赖关系</li></ul></li><li>什么是IOC容器?<ul><li>Spring创建了一个容器用来存放所创建的对象，这个容器就叫IOC容器</li></ul></li><li>什么是Bean?<ul><li>容器中所存放的一个个对象就叫Bean或Bean对象</li></ul></li></ol><h1 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h1><h2 id="IOC入门案例"><a href="#IOC入门案例" class="headerlink" title="IOC入门案例"></a>IOC入门案例</h2><h3 id="入门案例思路分析"><a href="#入门案例思路分析" class="headerlink" title="入门案例思路分析"></a>入门案例思路分析</h3><ol><li>Spring是使用容器来管理bean对象的，那么管什么?<ul><li>主要管理项目中所使用到的类对象，比如(Service和Dao)</li></ul></li><li>如何将被管理的对象告知IOC容器?<ul><li>使用配置文件</li></ul></li><li>被管理的对象交给IOC容器，要想从容器中获取对象，就先得思考如何获取到IOC容器?<ul><li>Spring框架提供相应的接口</li></ul></li><li>IOC容器得到后，如何从容器中获取bean?<ul><li>调用Spring框架提供对应接口中的方法</li></ul></li><li>使用Spring导入哪些坐标?<ul><li>用别人的东西，就需要在pom.xml添加对应的依赖</li></ul></li></ol><h3 id="入门案例实现"><a href="#入门案例实现" class="headerlink" title="入门案例实现"></a>入门案例实现</h3><ul><li>需求分析:将BookServiceImpl和BookDaoImpl交给Spring管理，并从容器中获取对应的bean对象进行方法调用。</li></ul><ol><li><p>创建Maven的java项目</p></li><li><p>pom.xml添加Spring的依赖jar包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>创建BookDao，BookDaoImpl，BookService和BookServiceImpl四个类</p><ul><li>BookDao</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface BookDao &#123;</span><br><span class="line">    public void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>BookDaoImpl</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>BookService</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface BookService &#123;</span><br><span class="line">    public void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>BookServiceImpl</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class BookServiceImpl implements BookService &#123;</span><br><span class="line">    private BookDao bookDao = new BookDaoImpl();</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>resources下添加spring配置文件</p><p>右键 -&gt; 新建 -&gt; XML配置文件 -&gt; Spring配置</p></li><li><p>在配置文件中完成bean的配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">XML</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">      &lt;!--</span><br><span class="line">      bean标签标示配置bean</span><br><span class="line">      id属性标示给bean起名字</span><br><span class="line">      class属性表示给bean定义类型，</span><br><span class="line">      得是具体的实现类而不是接口，要靠这个造对象的</span><br><span class="line">      --&gt;</span><br><span class="line">    &lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;bookService&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>注意事项：bean定义时id属性在同一个上下文中(配置文件)不能重复</p></li><li><p>获取IOC容器<br>使用Spring提供的接口完成IOC容器的创建，创建App类，编写main方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>从容器中获取对象进行方法调用<br>使用getBean(String name)方法，其name参数就是我们在bean配置的id，通过这个id来造对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        BookService bookService = (BookService) context.getBean(&quot;bookService&quot;);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行程序</p></li></ol><h2 id="DI入门案例"><a href="#DI入门案例" class="headerlink" title="DI入门案例"></a>DI入门案例</h2><p>对于DI的入门案例，我们依然先<code>分析思路</code>然后再<code>代码实现</code></p><h3 id="入门案例思路分析-1"><a href="#入门案例思路分析-1" class="headerlink" title="入门案例思路分析"></a>入门案例思路分析</h3><ol><li>要想实现依赖注入，必须要基于IOC管理Bean<ul><li>DI的入门案例要依赖于前面的IOC入门案例</li></ul></li><li>Service中使用new形式创建的Dao对象是否保留？<ul><li>不保留，这样才能解耦合，最终要使用IOC容器中的bean对象</li></ul></li><li>Service中需要的Dao对象如何进入到Service中？<ul><li>在Service中提供一个方法（例如提供一个set方法），让Spring的IOC容器可以通过该方法传入bean对象，也就达到了不是自己new，而是外部提供</li></ul></li><li>Service与Dao之间的关系如何描述？<ul><li>使用配置文件</li></ul></li></ol><h3 id="入门案例实现-1"><a href="#入门案例实现-1" class="headerlink" title="入门案例实现"></a>入门案例实现</h3><p>需求：基于IOC入门案例，在BookServiceImpl类中删除new对象的方式，使用Spring的DI完成Dao层的注入</p><ol><li><p>删除业务层中使用new的方式创建的dao对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class BookServiceImpl implements BookService &#123;</span><br><span class="line">    //private BookDao bookDao = new BookDaoImpl();</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在业务层提供BookDao的setter方法</p><p>我们在set方法中加一条输出语句，看看是否被调用了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class BookServiceImpl implements BookService &#123;</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBookDao(BookDao bookDao) &#123;</span><br><span class="line">        this.bookDao = bookDao;</span><br><span class="line">        System.out.println(&quot;set方法被调用啦&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在配置文件中添加依赖注入的配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">XML</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">    &lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--主要变化在这里--&gt;</span><br><span class="line">    &lt;bean id=&quot;bookService&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot;&gt;</span><br><span class="line">        &lt;!--配置server与dao的关系--&gt;</span><br><span class="line">        &lt;!--</span><br><span class="line">            property标签表示配置当前bean的属性</span><br><span class="line">            name属性表示配置哪一个具体的属性(这里是配置bookService的bookDao属性)</span><br><span class="line">            ref属性表示参照哪一个bean(参照当前配置文件中的bookDao)</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>注意:配置中的两个bookDao的含义是不一样的</p><ul><li>name&#x3D;”bookDao”中<code>bookDao</code>的作用是让Spring的IOC容器在获取到名称后，将首字母大写，前面加set找对应的<code>setBookDao()</code>方法进行对象注入</li><li>ref&#x3D;”bookDao”中<code>bookDao</code>的作用是让Spring能在IOC容器中找到id为<code>bookDao</code>的Bean对象给<code>bookService</code>进行注入</li></ul></li></ol><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309122236452.png"></p><ol start="4"><li>运行程序调用方法</li></ol><h1 id="IOC相关内容"><a href="#IOC相关内容" class="headerlink" title="IOC相关内容"></a>IOC相关内容</h1><p>通过前面两个案例，已经学习了<code>bean如何定义配置</code>，<code>DI如何定义配置</code>以及<code>容器对象如何获取</code>的内容，接下来主要是把这三块内容展开进行详细的讲解，深入的学习下这三部分的内容，首先是bean基础配置。</p><h2 id="bean基础配置"><a href="#bean基础配置" class="headerlink" title="bean基础配置"></a>bean基础配置</h2><p>对于bean的配置中，主要会讲解<code>bean基础配置</code>,<code>bean的别名配置</code>,<code>bean的作用范围配置</code>(重点),这三部分内容</p><h3 id="id与class"><a href="#id与class" class="headerlink" title="id与class"></a>id与class</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;&quot; class=&quot;&quot;/&gt;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309122242661.png"></p><h3 id="name别名"><a href="#name别名" class="headerlink" title="name别名"></a>name别名</h3><p>在bean标签中配置name属性，来充当别名</p><p>注意事项：</p><ul><li>bean依赖注入的ref属性指定bean，必须在容器中存在，而ref的值也可以是name里的别名，不过还是建议用id值来注入</li><li>如果我们在调用getBean(String name)方法时，传入了一个不存在该名称的bean对象，则会报错<code>NoSuchBeanDefinitionException</code>，此时我们要检查一下是哪边写错了（例如bean的id和name都没有service100，而getBean的参数却写了service100）</li></ul><h3 id="scope作用范围"><a href="#scope作用范围" class="headerlink" title="scope作用范围"></a>scope作用范围</h3><p>关于bean的作用范围是bean属性配置的一个重点内容。<br>bean的scope有两个取值：</p><ul><li>singleton：单例（默认），对象都是同一个，节省内存空间和时间</li><li>prototype：非单例，对象都是新的</li></ul><h4 id="验证IOC容器中对象是否为单例"><a href="#验证IOC容器中对象是否为单例" class="headerlink" title="验证IOC容器中对象是否为单例"></a>验证IOC容器中对象是否为单例</h4><ul><li>验证思路：我们只需要对同一个bean创建两个对象，然后打印二者的地址值，看看是否一致</li></ul><p>如果我想创建出来非单例的bean对象，该如何实现呢</p><ul><li>配置bean的scope属性为prototype</li></ul><h3 id="介绍完scope属性以后，我们来思考几个问题"><a href="#介绍完scope属性以后，我们来思考几个问题" class="headerlink" title="介绍完scope属性以后，我们来思考几个问题:"></a>介绍完<code>scope</code>属性以后，我们来思考几个问题:</h3><ul><li>为什么bean默认为单例?<ul><li>bean为单例的意思是在Spring的IOC容器中只会有该类的一个对象</li><li>bean对象只有一个就避免了对象的频繁创建与销毁，达到了bean对象的复用，性能高</li></ul></li><li>bean在容器中是单例的，会不会产生线程安全问题?<ul><li>如果对象是有状态对象，即该对象有成员变量可以用来存储数据的，</li><li>因为所有请求线程共用一个bean对象，所以会存在线程安全问题。</li><li>如果对象是无状态对象，即该对象没有成员变量没有进行数据存储的，</li><li>因方法中的局部变量在方法调用完成后会被销毁，所以不会存在线程安全问题。</li></ul></li><li>哪些bean对象适合交给容器进行管理?<ul><li>表现层对象（controller）</li><li>业务层对象（service）</li><li>数据层对象（dao）</li><li>工具对象（util）</li></ul></li><li>哪些bean对象不适合交给容器进行管理?<ul><li>封装实例的域对象（domain，pojo），因为会引发线程安全问题，所以不适合。</li></ul></li></ul><h1 id="bean实例化"><a href="#bean实例化" class="headerlink" title="bean实例化"></a>bean实例化</h1><p>对象已经能交给Spring的IOC容器来创建了，但是容器是如何来创建对象的呢?</p><ul><li>就需要研究下bean的实例化过程，在这块内容中主要解决两部分内容，分别是<ul><li>bean是如何创建的</li><li>实例化bean的三种方式，<code>构造方法</code>,<code>静态工厂</code>和<code>实例工厂</code></li></ul></li></ul><p>在讲解这三种创建方式之前，我们需要先确认一件事:</p><ul><li>bean本质上就是对象，对象在new的时候会使用构造方法完成，那创建bean也是使用构造方法完成的。<ul><li>基于这个知识点出发，我们来验证spring中bean的三种创建方式，</li></ul></li></ul><p>构造方法实例化</p><ol><li><p>在之前的BookDaoImpl类中添加一个无参构造函数，并打印一句话，方便观察结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line"> public void save() &#123;</span><br><span class="line">     System.out.println(&quot;book dao save ...&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public BookDaoImpl() &#123;</span><br><span class="line">     System.out.println(&quot;book dao constructor is running ...&quot;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行程序</p></li><li><p>若将构造器私有化继续测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private BookDaoImpl() &#123;</span><br><span class="line">        System.out.println(&quot;book dao constructor is running ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行程序，能执行成功，说明内部走的依然是构造函数，能访问到类中的私有构造方法，显而易见Spring底层用的是反射</p></li><li><p>若将构造器添加参数继续测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BookDaoImpl(int i) &#123;</span><br><span class="line">        System.out.println(&quot;book dao constructor is running ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行程序，程序会报错<code>NoSuchMethodException</code>，说明Spring底层使用的是类的无参构造方法</p></li></ol><h3 id="静态工厂实例化"><a href="#静态工厂实例化" class="headerlink" title="静态工厂实例化"></a>静态工厂实例化</h3><ol><li><p>创建一个工厂类BookDaoFactory并提供一个静态方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//静态工厂创建对象</span><br><span class="line">public class BookDaoFactory &#123;</span><br><span class="line">    public static BookDao getBookDaoImpl()&#123;</span><br><span class="line">        return new BookDaoImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改App运行类，在类中通过工厂获取对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //通过静态工厂创建对象</span><br><span class="line">        BookDao bookDao = BookDaoFactory.getBookDaoImpl();</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行后，可以查看到结果</p></li></ol><ul><li>那我们如何将这种方式交给Spring来管理呢？</li><li>这就要用到Spring中的静态工厂实例化的知识了，具体实现步骤为:</li></ul><ol><li><p>在spring的配置文件application.properties修改bookDao的bean</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.factory.BookDaoFactory&quot; factory-method=&quot;getBookDaoImpl&quot;/&gt;</span><br></pre></td></tr></table></figure><p>class:工厂类的类全名</p><p>factory-mehod:具体工厂类中创建对象的方法名</p></li><li><p>在App运行类，使用从IOC容器中获取bean的方法进行运行测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        BookDao bookDao = (BookDao) context.getBean(&quot;bookDao&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行后，结果如下，与我们自己直接new对象没太大区别，而且还麻烦了，那这种方式的意义是什么呢</p></li><li><p>原因</p><p>在工厂的静态方法中，我们除了new对象还可以做其他的一些业务操作，而之前new对象的方式就无法添加其他的业务内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class BookDaoFactory &#123;</span><br><span class="line">    public static BookDao getBookDaoImpl() &#123;</span><br><span class="line">        System.out.println(&quot;book dao factory setup ...&quot;);//模拟必要的业务操作</span><br><span class="line">        //这里还可以加一大堆业务逻辑</span><br><span class="line">        return new BookDaoImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ol><p>介绍完静态工厂实例化后，这种方式一般是用来兼容早期的一些老系统，所以<code>了解为主</code></p><h3 id="实例工厂与FactoryBean"><a href="#实例工厂与FactoryBean" class="headerlink" title="实例工厂与FactoryBean"></a>实例工厂与FactoryBean</h3><ol><li><p>修改工厂类<code>BookDaoFactory</code>的get方法，注意此处和静态工厂的工厂类不一样的地方是方法<code>不是静态方法</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoFactory &#123;</span><br><span class="line">    //唯一的区别就是去掉的static</span><br><span class="line">    public BookDao getBookDaoImpl() &#123;</span><br><span class="line">        System.out.println(&quot;book dao factory setup ...&quot;);//模拟必要的业务操作</span><br><span class="line">        //这里还可以加一大堆业务逻辑</span><br><span class="line">        return new BookDaoImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改App运行类，在类中通过工厂获取对象，由于不是静态方法了，所以我们需要先创建实例工厂对象，然后再用实例工厂对象调用方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建实例工厂对象</span><br><span class="line">        BookDaoFactory bookDaoFactory = new BookDaoFactory();</span><br><span class="line">        //通过实例工厂对象创建对象</span><br><span class="line">        BookDao bookDao = bookDaoFactory.getBookDaoImpl();</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行结果</p></li></ol><ul><li>那么对于上面这种实例工厂的方式如何交给Spring管理呢?</li></ul><ol><li><p>在spring配置文件中修改bookDao的bean</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bookDaoFactory&quot; class=&quot;com.blog.factory.BookDaoFactory&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;bookDao&quot; factory-bean=&quot;bookDaoFactory&quot; factory-method=&quot;getBookDaoImpl&quot;/&gt;</span><br></pre></td></tr></table></figure><p>实例化工厂运行的顺序是:</p><ul><li>创建实例化工厂对象,对应的是第一行配置</li><li>调用对象中的方法来创建bean，对应的是第二行配置<ul><li>factory-bean:工厂的实例对象</li><li>factory-method:工厂对象中的具体创建对象的方法名</li></ul></li></ul></li><li><p>在App运行类，使用从IOC容器中获取bean的方法进行运行测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        BookDao bookDao = (BookDao) context.getBean(&quot;bookDao&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行</p></li></ol><p>实例工厂实例化的方式就配置的过程还是比较复杂，要写两行配置，而且这两行还是高耦合的，所以Spring为了简化这种配置方式就提供了一种叫<code>FactoryBean</code>的方式来简化开发</p><h4 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h4><ol><li><p>创建一个BookDaoFactoryBean类，实现FactoryBean接口，重写接口方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoFactoryBean implements FactoryBean&lt;BookDao&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public BookDao getObject() throws Exception &#123;</span><br><span class="line">        return new BookDaoImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        return BookDao.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在Spring的配置文件中修改bookDao的bean</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.factory.BookDaoFactoryBean&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>App运行类不用做任何修改，直接运行</p></li></ol><p>这种方式在Spring去整合其他框架的时候会被用到，所以这种方式需要我们理解掌握。</p><ul><li><p>查看源码会发现，FactoryBean接口其实会有三个方法，分别是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">T getObject() throws Exception;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; getObjectType();</span><br><span class="line"></span><br><span class="line">default boolean isSingleton() &#123;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法一:getObject()，被重写后，在方法中进行对象的创建并返回</p></li><li><p>方法二:getObjectType()，被重写后，主要返回的是被创建类的Class对象</p></li><li><p>方法三:没有被重写，因为它已经给了默认值，从方法名中可以看出其作用是设置对象是否为单例，默认true</p></li></ul><h3 id="bean实例化小结"><a href="#bean实例化小结" class="headerlink" title="bean实例化小结"></a>bean实例化小结</h3><ul><li><p>bean是如何创建的呢?</p><ul><li>通过构造方法</li></ul></li><li><p>Spring的IOC实例化对象的三种方式分别是:</p><ul><li><p>构造方法(常用)</p></li><li><p>静态工厂(了解)</p></li><li><p>实例工厂(了解)</p><ul><li><p>FactoryBean(实用)</p><p>这些方式中，重点掌握构造方法和FactoryBean即可。</p></li></ul></li></ul></li></ul><blockquote><p>需要注意的一点是，构造方法在类中默认会提供，但是如果重写了构造方法，默认的就会消失，在使用的过程中需要注意，如果需要重写构造方法，最好把默认的构造方法也重写下。</p></blockquote><h2 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h2><p>关于bean的相关知识还有最后一个是<code>bean的生命周期</code>，对于生命周期，我们主要围绕着<code>bean生命周期控制</code>来讲解</p><ul><li>首先理解下什么是生命周期?<ul><li>从创建到消亡的完整过程,例如人从出生到死亡的整个过程就是一个生命周期。</li></ul></li><li>bean生命周期是什么?<ul><li>bean对象从创建到销毁的整体过程。</li></ul></li><li>bean生命周期控制是什么?<ul><li>在bean创建后到销毁前做一些事情。</li></ul></li><li>现在我们面临的问题是如何在bean的创建之后和销毁之前把我们需要添加的内容添加进去。</li></ul><h3 id="生命周期设置"><a href="#生命周期设置" class="headerlink" title="生命周期设置"></a>生命周期设置</h3><p>具体的控制有两个阶段:</p><ul><li>bean创建之后，想要添加内容，比如用来初始化需要用到资源</li><li>bean销毁之前，想要添加内容，比如用来释放用到的资源</li></ul><ol><li><p>添加初始化和销毁方法<br>针对这两个阶段，我们在BookDaoImpl类中分别添加两个方法，方法名随便取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void init() &#123;</span><br><span class="line">        System.out.println(&quot;init ... &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">        System.out.println(&quot;destroy ... &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置生命周期，修改bookDao的配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>运行程序</p></li></ol><p>从结果中可以看出，init方法执行了，但是destroy方法却未执行，这是为什么呢?</p><ul><li>Spring的IOC容器是运行在JVM中</li><li>运行main方法后,JVM启动,Spring加载配置文件生成IOC容器,从容器获取bean对象，然后调方法执行</li><li>main方法执行完后，JVM退出，这个时候IOC容器中的bean还没有来得及销毁就已经结束了</li><li>所以没有调用对应的destroy方法</li></ul><h3 id="close关闭容器"><a href="#close关闭容器" class="headerlink" title="close关闭容器"></a>close关闭容器</h3><ul><li>ApplicationContext中没有close方法，它的子类中有close方法</li><li>所以需要将ApplicationContext更换成ClassPathXmlApplicationContext，然后调用close方法就好啦</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        BookDao bookDao = (BookDao) context.getBean(&quot;bookDao&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行程序，输出如下，可以看到destroy正常输出</li></ul><h3 id="注册钩子关闭容器"><a href="#注册钩子关闭容器" class="headerlink" title="注册钩子关闭容器"></a>注册钩子关闭容器</h3><ul><li><p>在容器未关闭之前，提前设置好回调函数，让JVM在退出之前回调此函数来关闭容器</p></li><li><p>调用context的registerShutdownHook()方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        BookDao bookDao = (BookDao) context.getBean(&quot;bookDao&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">        context.registerShutdownHook();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>那两种方式介绍完后，close和registerShutdownHook选哪个?</p><ul><li>相同点:这两种都能用来关闭容器</li><li>不同点:close()是在调用的时候关闭，registerShutdownHook()是在JVM退出前调用关闭。<ul><li>那么registerShutdownHook()方法可以在任意位置调用，下面的代码中将其放在了第二行，仍能正常输出，但要是将其换成close()方法，则会报错<code>BeanFactory not initialized or already closed</code>，这里就是already closed</li></ul></li></ul><p>开发中到底用哪个呢？</p><ul><li>答案是两个都不用</li><li>分析上面的实现过程，会发现添加初始化和销毁方法，即需要编码也需要配置，实现起来步骤比较多也比较乱。</li><li>Spring给我们提供了两个接口来完成生命周期的控制，好处是可以不用再进行配置<code>init-method</code>和<code>destroy-method</code></li></ul><p>接下来在BookServiceImpl完成这两个接口的使用</p><ul><li><p>修改BookServiceImpl类，添加两个接口<code>InitializingBean</code>， <code>DisposableBean</code>并实现接口中的两个方法<code>afterPropertiesSet</code>和<code>destroy</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class BookServiceImpl implements BookService, InitializingBean, DisposableBean &#123;</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBookDao(BookDao bookDao) &#123;</span><br><span class="line">        System.out.println(&quot;set ... &quot;);</span><br><span class="line">        this.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void destroy() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;service destroy ... &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;service init ... &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>BookServiceImpl的bean配置如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bookService&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>重新运行App类</p></li></ul><p>小细节</p><ul><li><p>对于InitializingBean接口中的afterPropertiesSet方法，翻译过来为<code>属性设置之后</code>。</p></li><li><p>对于BookServiceImpl来说，bookDao是它的一个属性</p></li><li><p>setBookDao方法是Spring的IOC容器为其注入属性的方法</p></li><li><p>思考:afterPropertiesSet和setBookDao谁先执行?</p><ul><li><p>从方法名分析，猜想应该是setBookDao方法先执行</p></li><li><p>验证思路，在setBookDao方法中添加一局输出语句，看看谁先输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void setBookDao(BookDao bookDao) &#123;</span><br><span class="line">    System.out.println(&quot;set ... &quot;);</span><br><span class="line">    this.bookDao = bookDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重新运行</p></li></ul></li></ul><h3 id="bean生命周期小结"><a href="#bean生命周期小结" class="headerlink" title="bean生命周期小结"></a>bean生命周期小结</h3><ol><li>关于Spring中对bean生命周期控制提供了两种方式:<ul><li>在配置文件中的bean标签中添加<code>init-method</code>和<code>destroy-method</code>属性</li><li>类实现<code>InitializingBean</code>与<code>DisposableBean</code>接口</li></ul></li><li>对于bean的生命周期控制在bean的整个生命周期中所处的位置如下<ul><li>初始化容器<ul><li>1.创建对象(内存分配)</li><li>2.执行构造方法</li><li>3.执行属性注入(set操作)（<code>set ...</code>）</li><li>4.执行bean初始化方法（<code>service init ...</code>）</li></ul></li><li>使用bean<ul><li>执行业务操作（<code>book dao save ...</code>）</li></ul></li><li>关闭&#x2F;销毁容器<ul><li>执行bean销毁方法（<code>service destroy ...</code>）</li></ul></li></ul></li><li>关闭容器的两种方式:<ul><li>ConfigurableApplicationContext是ApplicationContext的子类，子类才有下面两种方法<ul><li>close()方法</li><li>registerShutdownHook()方法</li></ul></li></ul></li></ol><h1 id="DI相关内容"><a href="#DI相关内容" class="headerlink" title="DI相关内容"></a>DI相关内容</h1><p>向一个类中传递数据的方式有几种?</p><ul><li>普通方法(set方法)</li><li>构造方法</li></ul><p>依赖注入描述了在容器中建立bean与bean之间的依赖关系的过程，如果bean运行需要的是数字或字符串呢?</p><ul><li>引用类型</li><li>简单类型(基本数据类型与String)</li></ul><p>Spring就是基于上面这些知识点，为我们提供了两种注入方式，分别是：</p><ul><li>&#96;&#96;&#96;<br>setter注入<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 简单类型</span><br><span class="line">  - 引用类型</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  构造器注入</span><br></pre></td></tr></table></figure><ul><li>简单类型</li><li>引用类型</li></ul></li></ul><h2 id="setter注入"><a href="#setter注入" class="headerlink" title="setter注入"></a>setter注入</h2><p>对于setter方式注入引用类型的方式之前已经学习过，快速回顾下：</p><ul><li><p>在bean中定义引用类型属性，并提供可访问的set方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class BookServiceImpl implements BookService &#123;</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line">    public void setBookDao(BookDao bookDao) &#123;</span><br><span class="line">        this.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置中使用property标签ref属性注入引用类型对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bookService&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>我们再来回顾一下配置中的两个bookDao的含义</p><p>配置中的两个bookDao的含义是不一样的</p><ul><li>name&#x3D;”bookDao”中bookDao的作用是让Spring的IOC容器在获取到名称后，将首字母大写，前面加set找对应的setBookDao()方法进行对象注入</li><li>ref&#x3D;”bookDao”中bookDao的作用是让Spring能在IOC容器中找到id为bookDao的Bean对象给bookService进行注入</li></ul></li></ul><h2 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ul><li><p>修改BookDao、BookDaoImpl、UserDao、UserDaoImpl、BookService和BookServiceImpl类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface BookDao &#123;</span><br><span class="line">    public void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    </span><br><span class="line">    private String databaseName;</span><br><span class="line">    private int connectionNum;</span><br><span class="line">    </span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface UserDao &#123;</span><br><span class="line">    public void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class UserDaoImpl implements UserDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;user dao save ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface BookService &#123;</span><br><span class="line">    public void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class BookServiceImpl implements BookService&#123;</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    public void setBookDao(BookDao bookDao) &#123;</span><br><span class="line">        this.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;bookService&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><ul><li>运行类</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main( String[] args ) &#123;</span><br><span class="line">        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        BookService bookService = (BookService) ctx.getBean(&quot;bookService&quot;);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="构造器注入引用数据类型"><a href="#构造器注入引用数据类型" class="headerlink" title="构造器注入引用数据类型"></a>构造器注入引用数据类型</h3><p>接下来，在上面这个环境中来完成构造器注入：</p><p>将BookServiceImpl类中的bookDao修改成使用构造器的方式注入。</p><ol><li>将bookDao的setter方法删除掉</li><li>添加带有bookDao参数的构造方法</li><li>在applicationContext.xml中配置</li></ol><ul><li><p><code>步骤一：</code>删除setter方法并提供构造方法<br>在BookServiceImpl类中将bookDao的setter方法删除掉,并添加带有bookDao参数的构造方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class BookServiceImpl implements BookService&#123;</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    public BookServiceImpl(BookDao bookDao) &#123;</span><br><span class="line">        this.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>步骤二：</code>配置文件中进行配置构造方式注入<br>在applicationContext.xml中配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;bookService&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot;&gt;</span><br><span class="line">        &lt;constructor-arg name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>说明：在标签<code>&lt;constructor-arg&gt;</code>中</p><ul><li>name属性对应的值为构造函数中方法<code>形参的参数名</code>，必须要保持一致。</li><li>ref属性指向的是spring的IOC容器中其他bean对象。</li></ul></li><li><p><code>步骤三：</code>运行程序</p></li></ul><h3 id="构造器注入多个引用数据类型"><a href="#构造器注入多个引用数据类型" class="headerlink" title="构造器注入多个引用数据类型"></a>构造器注入多个引用数据类型</h3><p>需求：在BookServiceImpl使用构造函数注入多个引用数据类型，比如userDao</p><ol><li>声明userDao属性</li><li>生成一个带有bookDao和userDao参数的构造函数</li><li>在applicationContext.xml中配置注入</li></ol><ul><li><p><code>步骤一：</code>提供多个属性的构造函数<br>在BookServiceImpl声明userDao并提供多个参数的构造函数，save方法中记得调用userDao.save()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class BookServiceImpl implements BookService &#123;</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line">    private UserDao userDao;</span><br><span class="line"></span><br><span class="line">    public BookServiceImpl(BookDao bookDao, UserDao userDao) &#123;</span><br><span class="line">        this.bookDao = bookDao;</span><br><span class="line">        this.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>步骤二：</code>在配置文件中配置多参数注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">XML</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;userDao&quot; class=&quot;com.blog.dao.impl.UserDaoImpl&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;bookService&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot;&gt;</span><br><span class="line">        &lt;constructor-arg name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;</span><br><span class="line">        &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>步骤三：</code>运行程序</p></li></ul><h3 id="构造器注入多个简单数据类型"><a href="#构造器注入多个简单数据类型" class="headerlink" title="构造器注入多个简单数据类型"></a>构造器注入多个简单数据类型</h3><p>需求：在BookDaoImpl中，使用构造函数注入databaseName和connectionNum两个参数。<br>参考引用数据类型的注入，我们可以推出具体的步骤为：</p><ol><li>提供一个包含这两个参数的构造方法</li><li>在applicationContext.xml中进行注入配置</li></ol><ul><li><p><code>步骤一：</code>添加多个简单属性并提供构造方法<br>修改BookDaoImpl类，添加构造方法，同时在save()方法中输出这两个属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line"></span><br><span class="line">    private String databaseName;</span><br><span class="line">    private int connectionNum;</span><br><span class="line"></span><br><span class="line">    public BookDaoImpl(String databaseName, int connectionNum) &#123;</span><br><span class="line">        this.databaseName = databaseName;</span><br><span class="line">        this.connectionNum = connectionNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot; + databaseName + &quot;,&quot; + connectionNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>步骤二：</code>配置完成多个属性构造器注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;userDao&quot; class=&quot;com.blog.dao.impl.UserDaoImpl&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;&gt;</span><br><span class="line">        &lt;constructor-arg name=&quot;databaseName&quot; value=&quot;mysql&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">        &lt;constructor-arg name=&quot;connectionNum&quot; value=&quot;100&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;bean id=&quot;bookService&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot;&gt;</span><br><span class="line">        &lt;constructor-arg name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;</span><br><span class="line">        &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>步骤三：</code>运行程序</p></li></ul><h3 id="目前存在的问题"><a href="#目前存在的问题" class="headerlink" title="目前存在的问题"></a>目前存在的问题</h3><ul><li><p><code>&lt;constructor-arg&gt;</code>标签内的name，必须与构造函数中的参数名一致，这两块存在紧耦合。</p></li><li><p>那么我们怎么解决这个问题呢？</p></li><li><p>在解决这个问题之前，需要提前说明的是，这个参数名发生变化的情况并不多，所以上面的还是比较主流的配置方式，下面介绍的，我们以了解为主。</p></li><li><p>方式一：删除name属性，添加type属性，按照类型注入</p><ul><li><p>这种方式可以解决构造函数形参名发生变化带来的耦合问题</p></li><li><p>但是如果构造方法参数中有类型相同的参数，这种方式就不太好实现了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;&gt;</span><br><span class="line">    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;mysql&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;constructor-arg type=&quot;int&quot; value=&quot;9421&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>方式二：删除type属性，添加index属性，按照索引下标注入，下标从0开始</p><ul><li><p>这种方式可以解决参数类型重复问题</p></li><li><p>但是如果构造方法参数顺序发生变化后，这种方式又带来了耦合问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;&gt;</span><br><span class="line">    &lt;constructor-arg index=&quot;0&quot; value=&quot;mysql&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;constructor-arg index=&quot;1&quot; value=&quot;9421&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>介绍完两种参数的注入方式，具体我们该如何选择呢?</p><ol><li>强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现<ul><li>强制依赖指对象在创建的过程中必须要注入指定的参数</li></ul></li><li>可选依赖使用setter注入进行，灵活性强<ul><li>可选依赖指对象在创建过程中注入的参数可有可无</li></ul></li><li>Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨</li><li>如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入</li><li>实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入</li><li>自己开发的模块推荐使用setter注入</li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这部分主要讲解的是Spring的依赖注入的实现方式:</p><ul><li><p>setter注入</p><ul><li><p>简单数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean ...&gt;</span><br><span class="line">    &lt;property name=&quot;&quot; value=&quot;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>引用数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean ...&gt;</span><br><span class="line">    &lt;property name=&quot;&quot; ref=&quot;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>构造器注入</p><ul><li><p>简单数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean ...&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;&quot; index=&quot;&quot; type=&quot;&quot; value=&quot;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>引用数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean ...&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;&quot; index=&quot;&quot; type=&quot;&quot; ref=&quot;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>依赖注入的方式选择上</p><ul><li>建议使用setter注入</li><li>第三方技术根据情况选择</li></ul></li></ul><h2 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h2><p>前面花了大量的时间把Spring的注入去学习了下，总结起来就两个字<code>麻烦</code>。</p><ul><li>问:麻烦在哪?<ul><li>答:配置文件的编写配置上。</li></ul></li><li>问:有更简单方式么?<ul><li>答:有，自动配置</li></ul></li></ul><p>所以什么是自动配置以及如何实现自动配置，就是接下来要学习的内容</p><h3 id="什么是依赖自动装配？"><a href="#什么是依赖自动装配？" class="headerlink" title="什么是依赖自动装配？"></a>什么是依赖自动装配？</h3><p>IOC容器根据bean所依赖的资源在容器中<code>自动查找并注入</code>到bean中的过程称为自动装配</p><h3 id="自动装配方式有哪些？"><a href="#自动装配方式有哪些？" class="headerlink" title="自动装配方式有哪些？"></a>自动装配方式有哪些？</h3><ul><li>按类型（常用）</li><li>按名称</li><li>按构造方法</li><li>不启用自动装配</li></ul><h3 id="完成自动装配的配置"><a href="#完成自动装配的配置" class="headerlink" title="完成自动装配的配置"></a>完成自动装配的配置</h3><p>自动装配只需要修改applicationContext.xml配置文件即可:</p><ol><li><p>将<code>&lt;property&gt;</code>标签删除</p></li><li><p>在<code>&lt;bean&gt;</code>标签中添加autowire属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--    &lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;/&gt;--&gt;</span><br><span class="line">&lt;!--    既然是按类型注入了，那么id写不写都无所谓了--&gt;</span><br><span class="line">    &lt;bean class=&quot;com.blog.dao.impl.BookDaoImpl&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;bookService&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot; autowire=&quot;byType&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></li></ol><p>注意事项：</p><ul><li>需要注入属性的类中对应属性的<code>setter</code>方法不能省略</li><li>被注入的对象必须要被Spring的IOC容器管理</li><li>按照类型在Spring的IOC容器中如果找到多个对象，会报<code>NoUniqueBeanDefinitionException</code></li></ul><p>当一个类型在IOC中有多个对象，还想要注入成功，这个时候就需要按照名称注入，配置方式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--这里就有两个同一类型的bean，但是id不一样--&gt;</span><br><span class="line">    &lt;bean id=&quot;bookDao1&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;bookDao2&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;/&gt;</span><br><span class="line">    &lt;bean class=&quot;com.blog.dao.impl.BookDaoImpl&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;bookService&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot; autowire=&quot;byName&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>同时修改BookServiceImpl类汇总的<code>setBookDao</code>方法，将其重命名为<code>setBookDao1</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao1</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>疑惑：为什么刚刚修改的是setBookDao的方法名，而不是将bookDao属性修改为bookDao1呢？按照名称注入中的名称指的是什么?</p></blockquote><blockquote><p>解惑：</p><ul><li>因为bookDao是private修饰的，外部类无法直接访问</li><li>所以外部类只能通过属性的set方法进行访问</li><li>对外部类来说，setBookDao方法名，去掉set后首字母小写是其属性名<ul><li>为什么是去掉set首字母小写?</li><li>这个规则是set方法生成的<code>默认规则</code>，set方法的生成是把属性名首字母大写前面加set形成的方法名</li></ul></li><li>所以按照名称注入，其实是和对应的set方法有关，但是如果按照标准起名称，属性名和set对应的名是一致的</li></ul></blockquote><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul><li>如果按照名称去找对应的bean对象，找不到则注入Null</li><li>当某一个类型在IOC容器中有多个对象，按照名称注入只找其指定名称对应的bean对象，不会报错</li><li>两种方式介绍完后，以后用的更多的是<code>按照类型</code>注入。</li><li>最后对于依赖注入，需要注意一些其他的配置特征:<ol><li>自动装配用于引用类型依赖注入，不能对简单类型进行操作</li><li>使用按类型装配时（byType）必须保障容器中相同类型的bean唯一，推荐使用</li><li>使用按名称装配时（byName）必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用</li><li>自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效</li></ol></li></ul><h2 id="集合注入"><a href="#集合注入" class="headerlink" title="集合注入"></a>集合注入</h2><p>前面我们已经能完成引入数据类型和简单数据类型的注入，但是还有一种数据类型<code>集合</code>，集合中既可以装简单数据类型也可以装引用数据类型，对于集合，在Spring中该如何注入呢?</p><p>先来回顾下，常见的集合类型有哪些?</p><ul><li>数组</li><li>List</li><li>Set</li><li>Map</li><li>Properties</li></ul><h3 id="注入数组类型"><a href="#注入数组类型" class="headerlink" title="注入数组类型"></a>注入数组类型</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;array&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>100<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>200<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>300<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="注入List类型"><a href="#注入List类型" class="headerlink" title="注入List类型"></a>注入List类型</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>ABC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>123<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="注入Set类型"><a href="#注入Set类型" class="headerlink" title="注入Set类型"></a>注入Set类型</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;set&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>100<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>200<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>ABC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>ABC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="注入Map类型"><a href="#注入Map类型" class="headerlink" title="注入Map类型"></a>注入Map类型</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;探路者&quot;</span> <span class="attr">value</span>=<span class="string">&quot;马文&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;次元游记兵&quot;</span> <span class="attr">value</span>=<span class="string">&quot;恶灵&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;易位窃贼&quot;</span> <span class="attr">value</span>=<span class="string">&quot;罗芭&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="注入Properties类型"><a href="#注入Properties类型" class="headerlink" title="注入Properties类型"></a>注入Properties类型</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;暴雷&quot;</span>&gt;</span>沃尔特·菲茨罗伊<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;寻血猎犬&quot;</span>&gt;</span>布洛特·亨德尔<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;命脉&quot;</span>&gt;</span>阿杰·切<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>property标签表示setter方式注入，构造方式注入constructor-arg标签内部也可以写<code>&lt;array&gt;</code>、<code>&lt;list&gt;</code>、<code>&lt;set&gt;</code>、<code>&lt;map&gt;</code>、<code>&lt;props&gt;</code>标签</li><li>List的底层也是通过数组实现的，所以<code>&lt;list&gt;</code>和<code>&lt;array&gt;</code>标签是可以混用</li><li>集合中要添加引用类型，只需要把<code>&lt;value&gt;</code>标签改成<code>&lt;ref&gt;</code>标签，这种方式用的比较少</li></ul><h1 id="核心容器"><a href="#核心容器" class="headerlink" title="核心容器"></a>核心容器</h1><p>前面已经完成bean与依赖注入的相关知识学习，接下来我们主要学习的是IOC容器中的<code>核心容器</code>。</p><p>这里所说的核心容器，我们可以把它简单的理解为<code>ApplicationContext</code>，前面虽然已经用到过，但是并没有系统的学习，接下来我们从以下几个问题入手来学习下容器的相关知识:</p><ul><li>如何创建容器?</li><li>创建好容器后，如何从容器中获取bean对象?</li><li>容器类的层次结构是什么?</li><li>BeanFactory是什么?</li></ul><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="容器的创建方式"><a href="#容器的创建方式" class="headerlink" title="容器的创建方式"></a>容器的创建方式</h3><ul><li>案例中创建<code>ApplicationContext</code>的方式如下</li><li>这种方式翻译为：类路径下的XML配置文件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>除了上面这种方式，Spring还提供了另外一种创建方式</li><li>这种方式翻译为：文件系统下的XML配置文件，路径需要写绝对路径</li><li>这种方式虽能实现，但是当项目的位置发生变化后，代码也需要跟着改，耦合度高，不推荐使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(<span class="string">&quot;D:\xxx/xxx\applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="获取bean的三种方式"><a href="#获取bean的三种方式" class="headerlink" title="获取bean的三种方式"></a>获取bean的三种方式</h3><ul><li><p>方式一，就是我们之前用的方式</p></li><li><p>这种方式存在的问题是每次获取的时候都需要进行类型转换，有没有更简单的方式呢?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>方式二<br>这种方式可以解决类型强转问题，但是参数又多加了一个，相对来说没有简化多少。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> ctx.getBean(<span class="string">&quot;bookDao&quot;</span>，BookDao.class);</span><br></pre></td></tr></table></figure></li><li><p>方式三</p></li><li><p>这种方式就类似我们之前所学习依赖注入中的按类型注入。必须要确保IOC容器中该类型对应的bean对象只能有一个。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BookDao bookDao = ctx.getBean(BookDao.class);</span><br></pre></td></tr></table></figure></li></ul><h3 id="BeanFactory的使用"><a href="#BeanFactory的使用" class="headerlink" title="BeanFactory的使用"></a>BeanFactory的使用</h3><p>容器的最上级的父接口为<code>BeanFactory</code>，使用<code>BeanFactory</code>也可以创建IOC容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForBeanFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Resource</span> <span class="variable">resources</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BeanFactory</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanFactory</span>(resources);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> bf.getBean(BookDao.class);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了更好的看出<code>BeanFactory</code>和<code>ApplicationContext</code>之间的区别，在BookDaoImpl添加如下构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookDaoImpl</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不去获取bean对象，打印会发现：</p><ul><li>BeanFactory是延迟加载，只有在获取bean对象的时候才会去创建</li><li>ApplicationContext是立即加载，容器加载的时候就会创建bean对象</li><li>ApplicationContext要想成为延迟加载，只需要将lazy-init设为true</li></ul><h2 id="核心容器总结"><a href="#核心容器总结" class="headerlink" title="核心容器总结"></a>核心容器总结</h2><h3 id="容器相关"><a href="#容器相关" class="headerlink" title="容器相关"></a>容器相关</h3><ul><li>BeanFactory是IoC容器的顶层接口，初始化BeanFactory对象时，加载的bean延迟加载</li><li>ApplicationContext接口是Spring容器的核心接口，初始化时bean立即加载</li><li>ApplicationContext接口提供基础的bean操作相关方法，通过其他接口扩展其功能</li><li>ApplicationContext接口常用初始化类<ul><li>ClassPathXmlApplicationContext(常用)</li><li>FileSystemXmlApplicationContext</li></ul></li></ul><h3 id="bean相关"><a href="#bean相关" class="headerlink" title="bean相关"></a>bean相关</h3><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/631070e616f2c2beb1536517.jpg"></p><h3 id="依赖注入相关"><a href="#依赖注入相关" class="headerlink" title="依赖注入相关"></a>依赖注入相关</h3><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/631070f716f2c2beb1536fa3.jpg"></p><h1 id="IOC-x2F-DI注解开发"><a href="#IOC-x2F-DI注解开发" class="headerlink" title="IOC&#x2F;DI注解开发"></a>IOC&#x2F;DI注解开发</h1><p>Spring的IOC&#x2F;DI对应的配置开发就已经讲解完成，但是使用起来相对来说还是比较复杂的，复杂的地方在<code>配置文件</code>。<br>Spring到底是如何简化代码开发的呢?<br>要想真正简化开发，就需要用到Spring的注解开发，Spring对注解支持的版本历程:</p><ul><li>2.0版开始支持注解</li><li>2.5版注解功能趋于完善</li><li>3.0版支持纯注解开发</li></ul><p>关于注解开发，这里会讲解两块内容<code>注解开发定义bean</code>和<code>纯注解开发</code>。<br>注解开发定义bean用的是2.5版提供的注解，纯注解开发用的是3.0版提供的注解。</p><p><code>步骤一：</code>删除原有的XML配置<br>将配置文件中的bean标签删除掉</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><code>步骤二：</code>在Dao上添加注解<br>在BookDaoImpl类上添加<code>@Component</code>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;bookDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：@Component注解不可以添加在接口上，因为接口是无法创建对象的。</p></blockquote><p><code>步骤三：</code>配置Spring的注解包扫描<br>为了让Spring框架能够扫描到写在类上的注解，需要在配置文件上进行包扫描</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        &quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.blog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>说明：component-scan<ul><li>component:组件,Spring将管理的bean视作自己的一个组件</li><li>scan:扫描<br>base-package指定Spring框架扫描的包路径，它会扫描指定包及其子包中的所有类上的注解。</li><li>包路径越多<code>如:com.blog.dao.impl</code>，扫描的范围越小速度越快</li><li>包路径越少<code>如:com.blog</code>,扫描的范围越大速度越慢</li><li>一般扫描到项目的组织名称即Maven的groupId下<code>如:com.blog</code>即可。</li></ul></li></ul><p><code>步骤四：</code>运行程序</p><p><code>步骤五：</code>Service上添加注解<br>在BookServiceImpl类上也添加<code>@Component</code>交给Spring框架管理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>步骤六：</code>运行程序<br>在App类中，从IOC容器中获取BookServiceImpl对应的bean对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//按照名称获取bean</span></span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) context.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        <span class="comment">//按照类型获取bean</span></span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> context.getBean(BookService.class);</span><br><span class="line">        bookDao.save();</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li><p>BookServiceImpl类没有起名称，所以在App中是按照类型来获取bean对象</p></li><li><p><code>@Component</code>注解如果不起名称，会有一个默认值就是<code>当前类名首字母小写</code>，所以也可以按照名称获取，如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BookService bookService = (BookService) context.getBean(&quot;bookServiceImpl&quot;);</span><br></pre></td></tr></table></figure></li></ul><p>对于@Component注解，还衍生出了其他三个注解<code>@Controller</code>、<code>@Service</code>、<code>@Repository</code><br>这三个注解和@Component注解的作用是一样的，这是方便我们后期在编写类的时候能很好的区分出这个类是属于<code>表现层</code>、<code>业务层</code>还是<code>数据层</code>的类。</p><h2 id="纯注解开发模式"><a href="#纯注解开发模式" class="headerlink" title="纯注解开发模式"></a>纯注解开发模式</h2><p>上面已经可以使用注解来配置bean,但是依然有用到配置文件，在配置文件中对包进行了扫描，Spring在3.0版已经支持纯注解开发，使用Java类替代配置文件</p><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>实现思路为：将配置文件applicationContext.xml删掉，用类来替换</p><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ul><li><p><code>步骤一：</code>创建配置类<br>创建一个配置类SpringConfig</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class SpringConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>步骤二：<code>标识该类为配置类  在配置类上面加一个</code>@Configuration<code>注解，将其标识为一个配置类，用于替换掉</code>applicationContext.XML</p></li></ul> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SpringConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>步骤三：<code>用注解替换包扫描配置 在配置类上添加包扫描注解</code>@ComponentScan<code>替换</code>&lt;context:component-scan base-package&#x3D;””&#x2F;&gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.blog&quot;)</span><br><span class="line">public class SpringConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>步骤四：<code>创建运行类并执行 创建一个新的运行类</code>AppForAnnotation</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  public class AppForAnnotation &#123;</span><br><span class="line">      public static void main(String[] args) &#123;</span><br><span class="line">          AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);</span><br><span class="line">          BookDao bookDao = (BookDao) context.getBean(&quot;bookDao&quot;);</span><br><span class="line">          bookDao.save();</span><br><span class="line">          BookService bookService = context.getBean(BookService.class);</span><br><span class="line">          bookService.save();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">运行AppForAnnotation,可以看到两个对象依然被获取成功</span><br><span class="line"></span><br><span class="line">至此，纯注解开发的方式就已经完成了，主要内容包括：</span><br><span class="line"></span><br><span class="line">- Java类替换Spring核心配置文件</span><br><span class="line"></span><br><span class="line">  - `@Configuration`注解用于设定当前类为配置类</span><br><span class="line"></span><br><span class="line">  - `@ComponentScan`注解用于设定扫描路径，此注解只能添加一次，多个数据请用数组格式</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  @ComponentScan({com.blog.service”,”com.blog.dao”})</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 读取Spring核心配置文件初始化容器对象切换为读取Java配置类初始化容器对象</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  AnnotationConfigApplicationContext context &#x3D; new AnnotationConfigApplicationContext(SpringConfig.class);<br>  &#96;&#96;&#96;</p></li></ul><ul><li>知识点：<code>@Configuration</code></li></ul><table><thead><tr><th align="center">名称</th><th align="center">@Configuration</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">类注解</td></tr><tr><td align="center">位置</td><td align="center">类定义上方</td></tr><tr><td align="center">作用</td><td align="center">设置该类为spring配置类</td></tr><tr><td align="center">属性</td><td align="center">value（默认）：定义bean的id</td></tr></tbody></table><ul><li>知识点：<code>@ComponentScan</code></li></ul><table><thead><tr><th align="center">名称</th><th align="center">@ComponentScan</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">类注解</td></tr><tr><td align="center">位置</td><td align="center">类定义上方</td></tr><tr><td align="center">作用</td><td align="center">设置spring配置类扫描路径，用于加载使用注解格式定义的bean</td></tr><tr><td align="center">属性</td><td align="center">value（默认）：扫描路径，此路径可以逐层向下扫描</td></tr></tbody></table><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>这部分要重点掌握的是使用注解完成Spring的bean管理，需要掌握的内容为:</p><ul><li>记住<code>@Component</code>、<code>@Controller</code>、<code>@Service</code>、<code>@Repository</code>这四个注解</li><li>applicationContext.xml中<code>&lt;context:component-san/&gt;</code>的作用是指定扫描包路径，注解为<code>@ComponentScan</code></li><li><code>@Configuration</code>标识该类为配置类，使用类替换<code>applicationContext.xml</code>文件</li><li><code>ClassPathXmlApplicationContext</code>是加载XML配置文件</li><li><code>AnnotationConfigApplicationContext</code>是加载配置类</li></ul><h2 id="注解开发bean的作用范围和生命周期"><a href="#注解开发bean的作用范围和生命周期" class="headerlink" title="注解开发bean的作用范围和生命周期"></a>注解开发bean的作用范围和生命周期</h2><p>使用注解已经完成了bean的管理，接下来按照前面所学习的内容，将通过配置实现的内容都换成对应的注解实现，包含两部分内容:<code>bean作用范围(scope)</code>和<code>bean生命周期(init和destroy)</code>。</p><h3 id="bean的作用范围"><a href="#bean的作用范围" class="headerlink" title="bean的作用范围"></a>bean的作用范围</h3>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring入门-相关概念</title>
      <link href="/2023/08/29/SSM-Spring01/"/>
      <url>/2023/08/29/SSM-Spring01/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring相关概念"><a href="#Spring相关概念" class="headerlink" title="Spring相关概念"></a>Spring相关概念</h1><h2 id="初识Spring"><a href="#初识Spring" class="headerlink" title="初识Spring"></a>初识Spring</h2><h3 id="Spring家族"><a href="#Spring家族" class="headerlink" title="Spring家族"></a>Spring家族</h3><ul><li><p>官网：<a href="https://spring.io/">https://spring.io</a>， 从官网我们可以大概了解到：</p><ul><li>Spring能做什么:用以开发web、微服务以及分布式系统等,光这三块就已经占了JavaEE开发的九成多。</li><li>Spring并不是单一的一个技术，而是一个大家族，可以从官网的<code>Projects</code>中查看其包含的所有技术。</li></ul></li><li><p>Spring发展到今天已经形成了一种开发的生态圈,Spring提供了若干个项目,每个项目用于完成特定的功能。</p><ul><li>Spring已形成了完整的生态圈，也就是说我们可以完全使用Spring技术完成整个项目的构建、设计与开发。</li><li>Spring有若干个项目，可以根据需要自行选择，把这些个项目组合起来，起了一个名称叫Spring全家桶，如下图所示</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051453970.png"></p></li></ul><p><strong>说明</strong>：</p><p>图中的图标都代表什么含义，可以进入 <a href="https://spring.io/projects">https://spring.io/projects</a> 网站进行对比查看。<br>这些技术并不是所有的都需要学习，额外需要重点关注<code>Spring Framework</code>、<code>SpringBoot</code>和<code>SpringCloud</code>:</p><ul><li>Spring Framework：Spring框架，是Spring中最早最核心的技术，也是所有其他技术的基础。</li><li>SpringBoot：Spring是来简化开发，而SpringBoot是来帮助Spring在简化的基础上能更快速进行开发。</li><li>SpringCloud：这个是用来做分布式之微服务架构的相关开发。</li></ul><p>除了上面的这三个技术外，还有很多其他的技术，也比较流行，如SpringData，SpringSecurity等，这些都可以被应用在我们的项目中。我们这里所学习的Spring其实指的是Spring Framework。</p><h2 id="Spring系统架构"><a href="#Spring系统架构" class="headerlink" title="Spring系统架构"></a>Spring系统架构</h2><h4 id="系统架构图"><a href="#系统架构图" class="headerlink" title="系统架构图"></a>系统架构图</h4><ul><li><p>Spring Framework是Spring生态圈中最基础的项目，是其他项目的根基。</p></li><li><p>Spring Framework的发展也经历了很多版本的变更，每个版本都有相应的调整</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051458839.png"></p></li><li><p>Spring Framework的5版本目前没有最新的架构图，而最新的是4版本，所以接下来主要研究的是4的架构图</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051459609.png"></p></li></ul><ol><li>核心层<ul><li>Core Container：核心容器，这个模块是Spring最核心的模块，其他的都需要依赖该模块</li></ul></li><li>AOP层<ul><li>AOP(Aspect Oriented Programming)：面向切面编程，它依赖核心层容器，目的是在不改变原有代码的前提下对其进行功能增强</li><li>Aspects：AOP是思想，Aspects是对AOP思想的具体实现</li></ul></li><li>数据层<ul><li>Data Access：数据访问，Spring全家桶中有对数据访问的具体实现技术</li><li>Data Integration：数据集成，Spring支持整合其他的数据层解决方案，比如Mybatis</li><li>Transactions：事务，Spring中事务管理是Spring AOP的一个具体实现，也是后期学习的重点内容</li></ul></li><li>Web层<ul><li>这一层的内容将在SpringMVC框架具体学习</li></ul></li><li>Test层<ul><li>Spring主要整合了Junit来完成单元测试和集成测试</li></ul></li></ol><h4 id="课程学习路线"><a href="#课程学习路线" class="headerlink" title="课程学习路线"></a>课程学习路线</h4><p>介绍完Spring的体系结构后，从中我们可以得出对于Spring的学习主要包含四部分内容，分别是:</p><ol><li>Spring的 IOC &#x2F; DI</li><li>Spring的 AOP</li><li>AOP的具体应用，事务管理</li><li>IOC &#x2F; DI的具体应用，整合 Mybatis</li></ol><h2 id="Spring核心概念"><a href="#Spring核心概念" class="headerlink" title="Spring核心概念"></a>Spring核心概念</h2><p>在Spring核心概念这部分内容中主要包含<code>IOC/DI</code>、<code>IOC容器</code>和<code>Bean</code>,那么问题就来了，这些都是什么呢?</p><h3 id="目前项目中的问题"><a href="#目前项目中的问题" class="headerlink" title="目前项目中的问题"></a>目前项目中的问题</h3><p>要想解答这个问题，就需要先分析下目前咱们代码在编写过程中遇到的问题</p><ol><li><p>业务层需要调用数据层的方法，就需要在业务层new数据层的对象</p></li><li><p>如果数据层的实现类发生变化，那么业务层的代码也需要跟着改变，发生变更后，都需要进行编译打包和重部署</p></li><li><p>所以，现在代码在编写的过程中存在的问题是：耦合度偏高</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051516237.png"></p></li></ol><p>我们就想，如果不new对象，只声明一下，不就可以降低依赖了吗，但是又会引入新的问题，去掉以后程序能运行吗?</p><ul><li><p>答案显然是不行的，因为bookDao没有赋值为Null，强行运行就会出空指针异常。<br>所以现在的问题就是，业务层不想new对象，运行的时候又需要这个对象，该咋办呢?</p></li><li><p>针对这个问题，Spring就提出了一个解决方案:</p><ul><li><p>使用对象时，在程序中不要主动使用new产生对象，转换为由外部提供对象</p></li><li><p>这种实现思就是Spring的一个核心概念</p></li></ul></li></ul><h3 id="IOC、IOC容器、Bean、DI"><a href="#IOC、IOC容器、Bean、DI" class="headerlink" title="IOC、IOC容器、Bean、DI"></a>IOC、IOC容器、Bean、DI</h3><p>IOC(Inversion of Control)控制反转</p><ul><li>那什么是控制反转呢？<ul><li>使用对象时，由主动new产生对象转换为由<code>外部</code>提供对象，此过程中对象创建控制权由程序转移到外部，此思想称为控制反转。</li><li>业务层要用数据层的类对象，以前是自己<code>new</code>的</li><li>现在自己不new了，交给<code>别人[外部]</code>来创建对象</li><li><code>别人[外部]</code>就反转控制了数据层对象的创建权</li><li>这种思想就是控制反转</li><li>别人[外部]指的是什么呢?继续往下看</li></ul></li><li>Spring和IOC之间的关系是什么呢?<ul><li>Spring技术对IOC思想进行了实现</li><li>Spring提供了一个容器，称为<code>IOC容器</code>，用来充当IOC思想中的”外部”</li><li>IOC思想中的<code>别人[外部]</code>指的就是Spring的IOC容器</li></ul></li><li>IOC容器的作用以及内部存放的是什么?<ul><li>IOC容器负责对象的创建、初始化等一系列工作，其中包含了数据层和业务层的类对象</li><li>被创建或被管理的对象在IOC容器中统称为Bean</li><li>IOC容器中放的就是一个个的Bean对象</li></ul></li><li>当IOC容器中创建好service和dao对象后，程序能正确执行么?<ul><li>不行，因为service运行需要依赖dao对象</li><li>IOC容器中虽然有service和dao对象</li><li>但是service对象和dao对象没有任何关系</li><li>需要把dao对象交给service,也就是说要绑定service和dao对象之间的关系</li><li>像这种在容器中建立对象与对象之间的绑定关系就要用到DI(Dependency Injection)依赖注入.</li></ul></li></ul><p>DI(Dependency Injection)依赖注入</p><ul><li>什么是依赖注入呢?<ul><li>在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入<ul><li>业务层要用数据层的类对象，以前是自己<code>new</code>的</li><li>现在自己不new了，靠<code>别人[外部其实指的就是IOC容器]</code>来给注入进来</li><li>这种思想就是依赖注入</li></ul></li></ul></li><li>IOC容器中哪些bean之间要建立依赖关系呢?<ul><li>这个需要程序员根据业务需求提前建立好关系，如业务层需要依赖数据层，service就要和dao建立依赖关系</li></ul></li><li>介绍完Spring的IOC和DI的概念后，我们会发现这两个概念的最终目标就是:充分解耦，具体实现靠:<ul><li>使用IOC容器管理bean（IOC)</li><li>在IOC容器内将有依赖关系的bean进行关系绑定（DI）</li><li>最终结果为:使用对象时不仅可以直接从IOC容器中获取，并且获取到的bean已经绑定了所有的依赖关系.</li></ul></li></ul><h3 id="核心概念小结"><a href="#核心概念小结" class="headerlink" title="核心概念小结"></a>核心概念小结</h3><p>重点要理解<code>什么是IOC/DI思想</code>、<code>什么是IOC容器</code>和<code>什么是Bean</code>：</p><ol><li>什么IOC&#x2F;DI思想?</li></ol><ul><li>IOC:控制反转，控制反转的是对象的创建权</li><li>DI:依赖注入，绑定对象与对象之间的依赖关系</li></ul><ol><li>什么是IOC容器?</li></ol><ul><li>Spring创建了一个容器用来存放所创建的对象，这个容器就叫IOC容器</li></ul><ol><li>什么是Bean?</li></ol><ul><li>容器中所存放的一个个对象就叫Bean或Bean对象</li></ul><p><a href="https://zhuanlan.zhihu.com/p/33492169">浅谈控制反转与依赖注入</a></p><p>从前有个人叫小明，小明有三大爱好，逛知乎，打游戏，抢红包，但是小明作为一个人类，无法仅靠自己就完成上述功能，他必须<code>依赖</code>一部手机，所以他买了一台iPhone6</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Ming extends Person</span><br><span class="line">&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    void read()&#123;</span><br><span class="line">        <span class="operator">/</span><span class="operator">/</span>逛知乎</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void play()&#123;</span><br><span class="line">        <span class="operator">/</span><span class="operator">/</span>打游戏</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void grab()&#123;</span><br><span class="line">        <span class="operator">/</span><span class="operator">/</span>抢红包</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class iPhone6 extends Iphone</span><br><span class="line">&#123;</span><br><span class="line">    void read(String name) &#123;</span><br><span class="line">        System.out.println(name <span class="operator">+</span> &quot;打开了知乎然后编了一个故事&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void play(String name) &#123;</span><br><span class="line">        System.out.println(name <span class="operator">+</span> &quot;打开了Apex并开始白给&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void grab(String name) &#123;</span><br><span class="line">        System.out.println(name <span class="operator">+</span> &quot;开始抢红包却只抢不发&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小明很珍惜自己买的新手机，每天把它牢牢控制在手心,于是小明变成了这样</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Ming extends Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    public Ming(String name, <span class="type">int</span> age) &#123;</span><br><span class="line">        this.name <span class="operator">=</span> name;</span><br><span class="line">        this.age <span class="operator">=</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void read() &#123;</span><br><span class="line">        <span class="operator">/</span><span class="operator">/</span>逛知乎</span><br><span class="line">        <span class="keyword">new</span> iPhone6().read(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void play() &#123;</span><br><span class="line">        <span class="operator">/</span><span class="operator">/</span>打游戏</span><br><span class="line">        <span class="keyword">new</span> iPhone6().play(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void grab() &#123;</span><br><span class="line">        <span class="operator">/</span><span class="operator">/</span>抢红包</span><br><span class="line">        <span class="keyword">new</span> iPhone6().grab(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>今天是周六，小明不用上班，于是他起床，并依次逛起了知乎，打起了游戏，并抢了个红包。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ming ming <span class="operator">=</span> <span class="keyword">new</span> Ming(&quot;小明&quot;, <span class="number">18</span>);  <span class="operator">/</span><span class="operator">/</span>小明起床</span><br><span class="line">ming.read();</span><br><span class="line">ming.play();</span><br><span class="line">ming.grab();</span><br></pre></td></tr></table></figure><p>这个时候，我们可以在命令行里看到输出如下</p><blockquote><p>小明打开了知乎然后编了一个故事<br>小明打开了Apex并开始白给<br>小明开始抢红包却只抢不发</p></blockquote><p>但随着时间的推移，手机越来越卡顿，电池寿命也越来越短，到了冬天还会冻关机了，小明很难过，他意识到他需要换一部手机了。</p><p>为了获得更好的使用体验，小明一咬牙一跺脚，买了一台iPhone14 Pro Max，但他现在遇到了一个问题，他之前太过依赖那台iPhone6了，他们已经深深的耦合在一起了，如果要换手机，他必须要拿螺丝刀改造自己，将自己体内所有方法中的iPhone6换成iPhone14。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Ming extends Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    public Ming(String name, <span class="type">int</span> age) &#123;</span><br><span class="line">        this.name <span class="operator">=</span> name;</span><br><span class="line">        this.age <span class="operator">=</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void read() &#123;</span><br><span class="line">        <span class="operator">/</span><span class="operator">/</span>逛知乎</span><br><span class="line">        <span class="keyword">new</span> iPhone14().read(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void play() &#123;</span><br><span class="line">        <span class="operator">/</span><span class="operator">/</span>打游戏</span><br><span class="line">        <span class="keyword">new</span> iPhone14().play(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void grab() &#123;</span><br><span class="line">        <span class="operator">/</span><span class="operator">/</span>抢红包</span><br><span class="line">        <span class="keyword">new</span> iPhone14().grab(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然过程很辛苦，但小明觉得自己是值得的。随后在晚高峰挤地铁的时候，小明的手机被偷了。为了应急，小明只好重新使用那部刚刚被遗弃的iphone6，但是一想到那漫长的改造过程，小明的心里就说不出的委屈</p><p>他觉得自己过于依赖手机了，为什么每次手机出什么问题他都要去改造他自己，这不仅仅是过度耦合，简直是本末倒置，他向天空大喊，我不要再控制我的手机了。</p><p>天空中的造物主，也就是作为程序员的我，听到了他的呐喊，我告诉他，你不用再控制你的手机了，交给我来管理，把控制权交给我。这就叫做控制反转。</p><p>小明听到了我的话，他既高兴，又有一点害怕，他跪下来磕了几个头，虔诚地说到：“原来您就是传说中的造物主。我听到您刚刚说了 <code>控制反转</code> 四个字，就是把手机的控制权从我的手里交给你，但这只是您的想法，是一种思想罢了，要用什么办法才能实现控制反转，又可以让我继续使用手机呢？”</p><p>“呵“，身为造物主的我在表现完不屑以后，扔下了四个大字，“依赖注入！”</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Ming extends Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private <span class="type">int</span> age;</span><br><span class="line">    private Phone phone;</span><br><span class="line"></span><br><span class="line">    public Ming(String name, <span class="type">int</span> age, Phone phone) &#123;</span><br><span class="line">        this.name <span class="operator">=</span> name;</span><br><span class="line">        this.age <span class="operator">=</span> age;</span><br><span class="line">        this.phone <span class="operator">=</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void read() &#123;</span><br><span class="line">        <span class="operator">/</span><span class="operator">/</span>逛知乎</span><br><span class="line">        this.phone.read(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void play() &#123;</span><br><span class="line">        <span class="operator">/</span><span class="operator">/</span>打游戏</span><br><span class="line">        this.phone.play(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void grab() &#123;</span><br><span class="line">        <span class="operator">/</span><span class="operator">/</span>抢红包</span><br><span class="line">        this.phone.grab(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后我们来模拟小明的一天</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Phont phone <span class="operator">=</span> <span class="keyword">new</span> Iphone14();   <span class="operator">/</span><span class="operator">/</span>创建一个iphone14的实例</span><br><span class="line">if(phone.isBroken() <span class="operator">=</span><span class="operator">=</span> <span class="literal">true</span>)&#123;   <span class="operator">/</span><span class="operator">/</span>如果iphone14不可用，则使用旧版手机</span><br><span class="line">    phone <span class="operator">=</span> <span class="keyword">new</span> Iphone6();</span><br><span class="line">&#125;</span><br><span class="line">Ming ming <span class="operator">=</span> <span class="keyword">new</span> Ming(&quot;小明&quot;,<span class="number">18</span>,phone);    <span class="operator">/</span><span class="operator">/</span>小明不用关心是什么手机，他只要玩就行了。</span><br><span class="line">ming.read();</span><br><span class="line">ming.play();</span><br><span class="line">ming.grab();</span><br></pre></td></tr></table></figure><p>我们先看一下iphone14 是否可以使用，如果不可以使用，则直接换成iphone6,然后唤醒小明，并把手机塞到他的手里，换句话说，把他所依赖的手机直接注入到他的身上，他不需要关心自己拿的是什么手机，他只要直接使用就可以了。</p><p>这就是<code>依赖注入</code>。</p><h1 id="IOC入门案例"><a href="#IOC入门案例" class="headerlink" title="IOC入门案例"></a>IOC入门案例</h1><h2 id="入门案例思路分析"><a href="#入门案例思路分析" class="headerlink" title="入门案例思路分析"></a>入门案例思路分析</h2><ol><li><p>Spring是使用容器来管理bean对象的，那么管什么?</p><p>主要管理项目中所使用到的类对象，比如(Service和Dao)</p></li><li><p>如何将被管理的对象告知IOC容器?</p><p>使用配置文件</p></li><li><p>被管理的对象交给IOC容器，要想从容器中获取对象，就先得思考如何获取到IOC容器?</p><p>Spring框架提供相应的接口</p></li><li><p>IOC容器得到后，如何从容器中获取bean?</p><p>调用Spring框架提供对应接口中的方法</p></li><li><p>使用Spring导入哪些坐标?</p><p>用别人的东西，就需要在pom.xml添加对应的依赖</p></li></ol><h2 id="入门案例代码实现"><a href="#入门案例代码实现" class="headerlink" title="入门案例代码实现"></a>入门案例代码实现</h2><p>需求分析:将BookServiceImpl和BookDaoImpl交给Spring管理，并从容器中获取对应的bean对象进行方法调用。</p><ol><li><p>创建Maven的java项目</p></li><li><p>pom.xml添加Spring的依赖jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051557093.png"></p></li><li><p>创建BookDao，BookDao，BookService和BookServiceImpl四个类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface BookDao &#123;</span><br><span class="line">    public void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface BookService &#123;</span><br><span class="line">    public void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   public class BookServiceImpl implements BookService &#123;</span><br><span class="line">       private BookDao bookDao = new BookDaoImpl();</span><br><span class="line">       public void save() &#123;</span><br><span class="line">           System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">           bookDao.save();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">4. 创建 **applicationContext.xml** 文件</span><br><span class="line"></span><br><span class="line">   &gt; 右键 -&gt; 新建 -&gt; XML配置文件 -&gt; Spring配置</span><br><span class="line"></span><br><span class="line">5. 在配置文件中完成bean的配置</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   &gt; 注意事项：bean定义时id属性在同一个上下文中(配置文件)不能重复</span><br><span class="line"></span><br><span class="line">6. 获取IOC容器</span><br><span class="line">   使用Spring提供的接口完成IOC容器的创建，创建App类，编写main方法</span><br><span class="line"></span><br><span class="line">   ```App</span><br><span class="line">   public class App &#123;</span><br><span class="line">       public static void main(String[] args) &#123;</span><br><span class="line">           ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">   </span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>从容器中获取对象进行方法调用<br>使用getBean(String name)方法，其name参数就是我们在bean配置的id，通过这个id来造对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //获取IOC容器</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        //获取bean</span><br><span class="line">        BookService bookService = (BookService) context.getBean(&quot;bookService&quot;);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行程序<br>测试结果如下</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051614881.png"></p></li></ol><p>至此，Spring的IOC入门案例已经完成，但是在<code>BookServiceImpl</code>的类中依然存在<code>BookDaoImpl</code>对象的new操作，它们之间的耦合度还是比较高，这块该如何解决，就需要用到下面的<code>DI(依赖注入)</code>。</p><h1 id="DI入门案例"><a href="#DI入门案例" class="headerlink" title="DI入门案例"></a>DI入门案例</h1><h2 id="入门案例思路分析-1"><a href="#入门案例思路分析-1" class="headerlink" title="入门案例思路分析"></a>入门案例思路分析</h2><ol><li><p>要想实现依赖注入，必须要基于IOC管理Bean</p><p>DI的入门案例要依赖于前面的IOC入门案例</p></li><li><p>Service中使用new形式创建的Dao对象是否保留？</p><p>不保留，这样才能解耦合，最终要使用IOC容器中的bean对象</p></li><li><p>Service中需要的Dao对象如何进入到Service中？</p><p>在Service中提供一个方法（例如提供一个set方法），让Spring的IOC容器可以通过该方法传入bean对象，也就达到了不是自己new，而是外部提供</p></li><li><p>Service与Dao之间的关系如何描述？</p><p>使用配置文件</p></li></ol><h2 id="入门案例代码实现-1"><a href="#入门案例代码实现-1" class="headerlink" title="入门案例代码实现"></a>入门案例代码实现</h2><p>需求：基于IOC入门案例，在BookServiceImpl类中删除new对象的方式，使用Spring的DI完成Dao层的注入</p><ol><li><p>删除业务层中使用new的方式创建的dao对象</p></li><li><p>在业务层提供BookDao的setter方法<br>我们在set方法中加一条输出语句，看看是否被调用了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//private BookDao bookDao = new BookDaoImpl();</span><br><span class="line">private BookDao bookDao;</span><br><span class="line">public void setBookDao(BookDao bookDao) &#123;</span><br><span class="line">    this.bookDao = bookDao;</span><br><span class="line">    System.out.println(&quot;set方法被调用啦&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void save() &#123;</span><br><span class="line">    System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">    bookDao.save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在配置文件中添加依赖注入的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--主要变化在这里--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置server与dao的关系--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            property标签表示配置当前bean的属性</span></span><br><span class="line"><span class="comment">            name属性表示配置哪一个具体的属性(这里是配置bookService的bookDao属性)</span></span><br><span class="line"><span class="comment">            ref属性表示参照哪一个bean(参照当前配置文件中的bookDao)</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意:配置中的两个bookDao的含义是不一样的</p><ul><li>name&#x3D;”bookDao”中<code>bookDao</code>的作用是让Spring的IOC容器在获取到名称后，将首字母大写，前面加set找对应的<code>setBookDao()</code>方法进行对象注入</li><li>ref&#x3D;”bookDao”中<code>bookDao</code>的作用是让Spring能在IOC容器中找到id为<code>bookDao</code>的Bean对象给<code>bookService</code>进行注入</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051625296.png"></p></li><li><p>运行程序调用方法<br>测试结果如下</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051626803.png"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-Ioc</title>
      <link href="/2023/08/29/SSM-Spring02/"/>
      <url>/2023/08/29/SSM-Spring02/</url>
      
        <content type="html"><![CDATA[<h1 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h1><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><h3 id="bean基础配置"><a href="#bean基础配置" class="headerlink" title="bean基础配置"></a>bean基础配置</h3><p>对于bean的配置中，主要会讲解<code>bean基础配置</code>,<code>bean的别名配置</code>,<code>bean的作用范围配置</code>(重点),这三部分内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>其中，bean标签的功能、使用方式以及id和class属性的作用，我们通过一张图来描述下</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051633132.png"></p><h3 id="bean的name属性"><a href="#bean的name属性" class="headerlink" title="bean的name属性"></a>bean的name属性</h3><p>我们可以在bean标签中配置name属性，来充当别名，下面我们来演示</p><ol><li><p>配置别名<br>打开spring的配置文件<code>applicationContext.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--name:为bean指定别名，别名可以有多个，使用逗号，分号，空格进行分隔--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">name</span>=<span class="string">&quot;service1 service2 service3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>根据名称容器中获取bean对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        //此处根据bean标签的id属性和name属性的任意一个值来获取bean对象</span><br><span class="line">        BookService bookService = (BookService) context.getBean(&quot;service2&quot;);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>注意事项：</p><ul><li>bean依赖注入的ref属性指定bean，必须在容器中存在，而ref的值也可以是name里的别名，不过还是建议用id值来注入</li><li>如果我们在调用getBean(String name)方法时，传入了一个不存在该名称的bean对象，则会报错<code>NoSuchBeanDefinitionException</code>，此时我们要检查一下是哪边写错了（例如bean的id和name都没有service100，而getBean的参数却写了service100）</li></ul><h3 id="bean作用范围"><a href="#bean作用范围" class="headerlink" title="bean作用范围"></a>bean作用范围</h3><p>关于bean的作用范围是bean属性配置的一个重点内容。<br>bean的scope有两个取值：</p><ul><li>singleton：单例（默认）</li><li>prototype：非单例</li></ul><p>验证IOC容器中对象是否为单例：</p><ul><li><p>验证思路：我们只需要对同一个bean创建两个对象，然后打印二者的地址值，看看是否一致</p></li><li><p>代码实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        //我这里使用了别名，其实还是同一个bean</span><br><span class="line">        BookService bookService2 = (BookService) context.getBean(&quot;service2&quot;);</span><br><span class="line">        BookService bookService3 = (BookService) context.getBean(&quot;service3&quot;);</span><br><span class="line">        System.out.println(bookService2);</span><br><span class="line">        System.out.println(bookService3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>那如果我想创建出来非单例的bean对象，该如何实现呢?</p><p>在Spring的配置文件中，修改<code>&lt;bean&gt;</code>的scope属性为prototype</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bookService&quot; name=&quot;service1 service2 service3&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot; scope=&quot;prototype&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>介绍完<code>scope</code>属性以后，我们来思考几个问题:</p><ol><li><p>为什么bean默认为单例?</p><ul><li>bean为单例的意思是在Spring的IOC容器中只会有该类的一个对象</li><li>bean对象只有一个就避免了对象的频繁创建与销毁，达到了bean对象的复用，性能高</li></ul></li><li><p>bean在容器中是单例的，会不会产生线程安全问题?</p><ul><li>如果对象是有状态对象，即该对象有成员变量可以用来存储数据的，</li><li>因为所有请求线程共用一个bean对象，所以会存在线程安全问题。</li><li>如果对象是无状态对象，即该对象没有成员变量没有进行数据存储的，</li><li>因方法中的局部变量在方法调用完成后会被销毁，所以不会存在线程安全问题。</li></ul></li><li><p>哪些bean对象适合交给容器进行管理?</p><ul><li>表现层对象（controller）</li><li>业务层对象（service）</li><li>数据层对象（dao）</li><li>工具对象（util）</li></ul></li><li><p>哪些bean对象不适合交给容器进行管理?</p><p>封装实例的域对象（domain，pojo），因为会引发线程安全问题，所以不适合。</p></li></ol><h2 id="bean实例化"><a href="#bean实例化" class="headerlink" title="bean实例化"></a>bean实例化</h2><p>对象已经能交给Spring的IOC容器来创建了，但是容器是如何来创建对象的呢?</p><ul><li>就需要研究下bean的实例化过程，在这块内容中主要解决两部分内容，分别是<ul><li>bean是如何创建的</li><li>实例化bean的三种方式，<code>构造方法</code>,<code>静态工厂</code>和<code>实例工厂</code></li></ul></li></ul><p>在讲解这三种创建方式之前，我们需要先确认一件事:</p><ul><li>bean本质上就是对象，对象在new的时候会使用构造方法完成，那创建bean也是使用构造方法完成的。<ul><li>基于这个知识点出发，我们来验证spring中bean的三种创建方式，</li></ul></li></ul><h3 id="构造方法实例化（常用）"><a href="#构造方法实例化（常用）" class="headerlink" title="构造方法实例化（常用）"></a>构造方法实例化（常用）</h3><ul><li>在之前的BookDaoImpl类中添加一个无参构造函数，并打印一句话，方便观察结果。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BookDaoImpl() &#123;</span><br><span class="line">        System.out.println(&quot;book dao constructor is running ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，结果如下：</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051848892.png"></p><blockquote><p>特别的，将构造器私有化继续测试，结果仍然如上图，说明内部走的依然是构造函数，能访问到类中的私有构造方法，显而易见Spring底层用的是反射</p></blockquote><p>但是，在构造函数中添加一个参数试试，运行程序，程序会报错<code>NoSuchMethodException</code>，说明Spring底层使用的是类的无参构造方法。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051852774.png"></p><h3 id="静态工厂实例化（了解）"><a href="#静态工厂实例化（了解）" class="headerlink" title="静态工厂实例化（了解）"></a>静态工厂实例化（了解）</h3><p>创建一个工厂类BookDaoFactory并提供一个静态方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//静态工厂创建对象</span><br><span class="line">public class BookDaoFactory &#123;</span><br><span class="line">    public static BookDao getBookDaoImpl()&#123;</span><br><span class="line">        return new BookDaoImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改App运行类，在类中通过工厂获取对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //通过静态工厂创建对象</span><br><span class="line">        BookDao bookDao = BookDaoFactory.getBookDaoImpl();</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后，可以查看到结果</p><p>那我们如何将这种方式交给Spring来管理呢？</p><p>这就要用到Spring中的静态工厂实例化的知识了，具体实现步骤为：</p><ol><li><p>在spring的配置文件<code>application.properties</code>修改bookDao的bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.factory.BookDaoFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getBookDaoImpl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>class：工厂类的类全名<br>factory-mehod：具体工厂类中创建对象的方法名</p></li><li><p>在App运行类，使用从IOC容器中获取bean的方法进行运行测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        BookDao bookDao = (BookDao) context.getBean(&quot;bookDao&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行后，结果如下</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051904580.png"></p><p>与我们自己直接new对象没太大区别，而且还麻烦了，那这种方式的意义是什么呢？</p><p>在工厂的静态方法中，我们除了new对象还可以做其他的一些业务操作，而之前new对象的方式就无法添加其他的业务内容</p><blockquote><p>介绍完静态工厂实例化后，这种方式一般是用来兼容早期的一些老系统，所以<code>了解为主</code>。</p></blockquote></li></ol><h3 id="实例工厂实例化Bean（了解）"><a href="#实例工厂实例化Bean（了解）" class="headerlink" title="实例工厂实例化Bean（了解）"></a>实例工厂实例化Bean（了解）</h3><ol><li><p>在spring配置文件中修改bookDao的bean</p><p>先引入工厂的bean，再引入对象的bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDaoFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.factory.BookDaoFactory&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;bookDaoFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getBookDaoImpl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改工厂和运行类的方法</p><p>改工厂类<code>BookDaoFactory</code>的get方法，注意此处和静态工厂的工厂类不一样的地方是方法<code>不是静态方法</code></p><blockquote><p>因为不是静态方法，所以要有工厂的对象才能使用工厂的方法，所以引入了工厂的bean</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoFactory &#123;</span><br><span class="line">    //唯一的区别就是去掉的static</span><br><span class="line">    public BookDao getBookDaoImpl() &#123;</span><br><span class="line">        System.out.println(&quot;book dao factory setup ...&quot;);//模拟必要的业务操作</span><br><span class="line">        //这里还可以加一大堆业务逻辑</span><br><span class="line">        return new BookDaoImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改App运行类，在类中通过工厂获取对象，由于不是静态方法了，所以我们需要先创建实例工厂对象，然后再用实例工厂对象调用方法</p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建实例工厂对象</span><br><span class="line">        BookDaoFactory bookDaoFactory = new BookDaoFactory();</span><br><span class="line">        //通过实例工厂对象创建对象</span><br><span class="line">        BookDao bookDao = bookDaoFactory.getBookDaoImpl();</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051925495.png"></p><p>实例化工厂运行的顺序是:</p><ul><li>创建实例化工厂对象,对应的是第一行配置</li><li>调用对象中的方法来创建bean，对应的是第二行配置<ul><li>factory-bean:工厂的实例对象</li><li>factory-method:工厂对象中的具体创建对象的方法名</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051926795.png"></p><h3 id="FactoryBean（实用）"><a href="#FactoryBean（实用）" class="headerlink" title="FactoryBean（实用）"></a>FactoryBean（实用）</h3><ol><li>创建一个<code>BookDaoFactoryBean</code>类，实现<code>FactoryBean</code>接口，重写接口方法</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoFactoryBean implements FactoryBean&lt;BookDao&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public BookDao getObject() throws Exception &#123;</span><br><span class="line">        return new BookDaoImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        return BookDao.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>在Spring的配置文件中修改bookDao的bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.factory.BookDaoFactoryBean&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>App运行类不用做任何修改，直接运行</p></li></ol><blockquote><p>这种方式在Spring去整合其他框架的时候会被用到，所以这种方式需要我们理解掌握。</p></blockquote><p>查看源码会发现，FactoryBean接口其实会有三个方法，分别是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">T getObject() throws Exception;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; getObjectType();</span><br><span class="line"></span><br><span class="line">default boolean isSingleton() &#123;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法一：getObject()，被重写后，在方法中进行对象的创建并返回</p><p>方法二：getObjectType(),被重写后，主要返回的是被创建类的Class对象</p><p>方法三：没有被重写，因为它已经给了默认值，从方法名中可以看出其作用是设置对象是否为单例，默认true，这里就不加以验证了</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>于bean的相关知识还有最后一个是<code>bean的生命周期</code>，对于生命周期，我们主要围绕着<code>bean生命周期控制</code>来讲解</p><p>首先理解下什么是生命周期?</p><ul><li>从创建到消亡的完整过程,例如人从出生到死亡的整个过程就是一个生命周期。</li></ul><p>bean生命周期是什么?</p><ul><li>bean对象从创建到销毁的整体过程。</li></ul><p>bean生命周期控制是什么?</p><ul><li>在bean创建后到销毁前做一些事情。</li></ul><p>现在我们面临的问题是如何在bean的创建之后和销毁之前把我们需要添加的内容添加进去。</p><h3 id="生命周期设置"><a href="#生命周期设置" class="headerlink" title="生命周期设置"></a>生命周期设置</h3><p>具体的控制有两个阶段:</p><ul><li>bean创建之后，想要添加内容，比如用来初始化需要用到资源</li><li>bean销毁之前，想要添加内容，比如用来释放用到的资源</li></ul><ol><li><p>添加初始化和销毁方法<br>针对这两个阶段，我们在BookDaoImpl类中分别添加两个方法，方法名随便取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void init() &#123;</span><br><span class="line">        System.out.println(&quot;init ... &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">        System.out.println(&quot;destroy ... &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置生命周期<br>修改bookDao的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.dao.impl.BookDaoImpl&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>结果如下</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310060953310.png"></p></li></ol><p>从结果中可以看出，init方法执行了，但是destroy方法却未执行，这是为什么呢?</p><ul><li>Spring的IOC容器是运行在JVM中</li><li>运行main方法后,JVM启动,Spring加载配置文件生成IOC容器,从容器获取bean对象，然后调方法执行</li><li>main方法执行完后，JVM退出，这个时候IOC容器中的bean还没有来得及销毁就已经结束了</li><li>所以没有调用对应的destroy方法</li></ul><h4 id="close关闭容器"><a href="#close关闭容器" class="headerlink" title="close关闭容器"></a>close关闭容器</h4><ul><li><p>ApplicationContext中没有close方法，它的子类中有close方法</p></li><li><p>所以需要将ApplicationContext更换成ClassPathXmlApplicationContext，然后调用close方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        BookDao bookDao = (BookDao) context.getBean(&quot;bookDao&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310060956723.png"></p></li></ul><h4 id="注册钩子关闭容器"><a href="#注册钩子关闭容器" class="headerlink" title="注册钩子关闭容器"></a>注册钩子关闭容器</h4><ul><li><p>在容器未关闭之前，提前设置好回调函数，让JVM在退出之前回调此函数来关闭容器</p></li><li><p>调用context的registerShutdownHook()方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        BookDao bookDao = (BookDao) context.getBean(&quot;bookDao&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">        context.registerShutdownHook();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：registerShutdownHook在ApplicationContext中也没有，还是要用其子类</p></blockquote><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310060958804.png"></p></li></ul><p>那两种方式介绍完后，close和registerShutdownHook选哪个?</p><p>相同点：这两种都能用来关闭容器</p><p>不同点：close()是在调用的时候关闭，registerShutdownHook()是在JVM退出前调用关闭。</p><ul><li>那么registerShutdownHook()方法可以在任意位置调用，下面的代码中将其放在了第二行，仍能正常输出，但要是将其换成close()方法，则会报错<code>BeanFactory not initialized or already closed</code>，这里就是already closed</li></ul><p>开发中到底用哪个呢？</p><ul><li>答案是两个都不用</li><li>分析上面的实现过程，会发现添加初始化和销毁方法，即需要编码也需要配置，实现起来步骤比较多也比较乱。</li><li>Spring给我们提供了两个接口来完成生命周期的控制，好处是可以不用再进行配置<code>init-method</code>和<code>destroy-method</code></li></ul><p>接下来在BookServiceImpl完成这两个接口的使用</p><ol><li><p>修改BookServiceImpl类，添加两个接口<code>InitializingBean</code>， <code>DisposableBean</code>并实现接口中的两个方法<code>afterPropertiesSet</code>和<code>destroy</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class BookServiceImpl implements BookService, InitializingBean, DisposableBean &#123;</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBookDao(BookDao bookDao) &#123;</span><br><span class="line">        System.out.println(&quot;set ... &quot;);</span><br><span class="line">        this.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void destroy() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;service destroy ... &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;service init ... &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>BookServiceImpl的bean配置如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bookService&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310061003388.png"></p></li></ol><h3 id="bean生命周期小结"><a href="#bean生命周期小结" class="headerlink" title="bean生命周期小结"></a>bean生命周期小结</h3><ol><li>关于Spring中对bean生命周期控制提供了两种方式:</li></ol><ul><li>在配置文件中的bean标签中添加<code>init-method</code>和<code>destroy-method</code>属性</li><li>类实现<code>InitializingBean</code>与<code>DisposableBean</code>接口</li></ul><ol><li>对于bean的生命周期控制在bean的整个生命周期中所处的位置如下</li></ol><ul><li>初始化容器<ul><li>1.创建对象(内存分配)</li><li>2.执行构造方法</li><li>3.执行属性注入(set操作)（<code>set ...</code>）</li><li>4.执行bean初始化方法（<code>service init ...</code>）</li></ul></li><li>使用bean<ul><li>执行业务操作（<code>book dao save ...</code>）</li></ul></li><li>关闭&#x2F;销毁容器<ul><li>执行bean销毁方法（<code>service destroy ...</code>）</li></ul></li></ul><ol><li>关闭容器的两种方式:</li></ol><ul><li>ConfigurableApplicationContext是ApplicationContext的子类，子类才有下面两种方法<ul><li>close()方法</li><li>registerShutdownHook()方法</li></ul></li></ul><h1 id="DI依赖注入"><a href="#DI依赖注入" class="headerlink" title="DI依赖注入"></a>DI依赖注入</h1><ol><li><p>向一个类中传递数据的方式有几种?</p><ul><li>普通方法(set方法)</li><li>构造方法</li></ul></li><li><p>依赖注入描述了在容器中建立bean与bean之间的依赖关系的过程，如果bean运行需要的是数字或字符串呢?</p><ul><li>引用类型</li><li>简单类型(基本数据类型与String)</li></ul></li></ol><p>Spring就是基于上面这些知识点，为我们提供了两种注入方式，分别是:</p><ol><li><p>setter注入</p><ul><li>简单类型</li><li>引用类型</li></ul></li><li><p>构造器注入</p><ul><li>简单类型</li><li>引用类型</li></ul></li></ol><h2 id="setter注入"><a href="#setter注入" class="headerlink" title="setter注入"></a>setter注入</h2><p>对于setter方式注入引用类型的方式之前已经学习过，快速回顾下:</p><ol><li>在bean中定义引用类型属性，并提供可访问的set方法</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class BookServiceImpl implements BookService &#123;</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line">    public void setBookDao(BookDao bookDao) &#123;</span><br><span class="line">        this.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>配置中使用property标签ref属性注入引用类型对象</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bookService&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>我们再来回顾一下配置中的两个bookDao的含义：</p><p>配置中的两个bookDao的含义是不一样的</p><ul><li>name&#x3D;”bookDao” 中bookDao的作用是让Spring的IOC容器在获取到名称后，将首字母大写，前面加set找对应的setBookDao()方法进行对象注入</li><li>ref&#x3D;”bookDao” 中bookDao的作用是让Spring能在IOC容器中找到id为bookDao的Bean对象给bookService进行注入</li></ul><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ol><li><p>在dao包下新建一个UserDao接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface UserDao &#123;</span><br><span class="line">    public void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后新建一个UserDaoImpl类实现UserDao接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class UserDaoImpl implements UserDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;user dao save ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后修改我们之前的BookDao等类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface BookDao &#123;</span><br><span class="line">    public void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface BookService &#123;</span><br><span class="line">    public void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class BookServiceImpl implements BookService &#123;</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    public void setBookDao(BookDao bookDao) &#123;</span><br><span class="line">        this.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置文件如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.dao.impl.BookDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改App运行类，加载Spring的IOC容器，并从中获取对应的bean对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        BookService bookService = (BookService) context.getBean(&quot;bookService&quot;);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="注入引用数据类型"><a href="#注入引用数据类型" class="headerlink" title="注入引用数据类型"></a>注入引用数据类型</h3><blockquote><p>需求:在bookServiceImpl对象中注入userDao</p><ol><li>在BookServiceImpl中声明userDao属性</li><li>为userDao属性提供setter方法</li><li>在配置文件中使用property标签注入</li></ol></blockquote><ol><li><p>声明userDao属性并提供setter方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class BookServiceImpl implements BookService &#123;</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line">    //声明属性</span><br><span class="line">    private UserDao userDao;</span><br><span class="line">    //提供setter</span><br><span class="line">    public void setUserDao(UserDao userDao) &#123;</span><br><span class="line">        this.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBookDao(BookDao bookDao) &#123;</span><br><span class="line">        this.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在配置文件中注入配置<br>在applicationContext.xml配置文件中使用property标签注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;&gt;&lt;/bean&gt;</span><br><span class="line">    &lt;bean id=&quot;userDao&quot; class=&quot;com.blog.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;bookService&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></li><li><p>运行程序，结果如下，userDao已经成功注入。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310061451595.png"></p></li></ol><h3 id="注入简单数据类型"><a href="#注入简单数据类型" class="headerlink" title="注入简单数据类型"></a>注入简单数据类型</h3><blockquote><p>需求：给BookDaoImpl注入一些简单数据类型的数据<br>参考引用数据类型的注入，我们可以推出具体的步骤为：</p><ol><li>在BookDaoImpl类中声明对应的简单数据类型的属性</li><li>为这些属性提供对应的setter方法</li><li>在applicationContext.xml中配置</li></ol></blockquote><p><strong>思考:</strong></p><ul><li>引用类型使用的是<code>&lt;property name=&quot;&quot; ref=&quot;&quot;/&gt;</code>,简单数据类型还是使用ref吗?</li><li>ref是指向Spring的IOC容器中的另一个bean对象的，对于简单数据类型，没有对应的bean对象，该如何配置呢?使用value来配置<code>&lt;property name=&quot;&quot; value=&quot;&quot;/&gt;</code></li></ul><ol><li><p>声明属性并提供setter方法<br>这里举例就用<code>String dataBaseName</code>和<code>int connectionCount</code>这两个属性，同时在save()方法的输出语句中加上这两个属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    private String dataBaseName;</span><br><span class="line">    private int connectionCount;</span><br><span class="line"></span><br><span class="line">    public void setDataBaseName(String dataBaseName) &#123;</span><br><span class="line">        this.dataBaseName = dataBaseName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setConnectionCount(int connectionCount) &#123;</span><br><span class="line">        this.connectionCount = connectionCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot; + dataBaseName + &quot;,&quot; + connectionCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在配置文件中进行注入配置<br>在applicationContext.xml配置文件中使用property标签注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataBaseName&quot; value=&quot;mysql&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;connectionCount&quot; value=&quot;100&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;bean id=&quot;userDao&quot; class=&quot;com.blog.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;bookService&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>value：后面跟的是简单数据类型，对于参数类型，Spring在注入的时候会自动转换，但是不能写一个错误的类型，例如<code>connectionCount</code>是<code>int</code>类型，你却给他传一个<code>abc</code>，这样的话，spring在将<code>abc</code>转换成int类型的时候就会报错。</p></li><li><p>运行程序，查看输出，两个简单数据类型也成功注入</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310061457970.png"></p></li></ol><h2 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h2><h3 id="环境准备-1"><a href="#环境准备-1" class="headerlink" title="环境准备"></a>环境准备</h3><ol><li><p>修改BookDao、BookDaoImpl、UserDao、UserDaoImpl、BookService和BookServiceImpl类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface BookDao &#123;</span><br><span class="line">    public void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    </span><br><span class="line">    private String databaseName;</span><br><span class="line">    private int connectionNum;</span><br><span class="line">    </span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface UserDao &#123;</span><br><span class="line">    public void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class UserDaoImpl implements UserDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;user dao save ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface BookService &#123;</span><br><span class="line">    public void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class BookServiceImpl implements BookService&#123;</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    public void setBookDao(BookDao bookDao) &#123;</span><br><span class="line">        this.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;bookService&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="构造器注入引用数据类型"><a href="#构造器注入引用数据类型" class="headerlink" title="构造器注入引用数据类型"></a>构造器注入引用数据类型</h3><blockquote><p>需求：将BookServiceImpl类中的bookDao修改成使用构造器的方式注入。</p><ol><li>将bookDao的setter方法删除掉</li><li>添加带有bookDao参数的构造方法</li><li>在applicationContext.xml中配置</li></ol></blockquote><ol><li><p>删除setter方法并提供构造方法</p><p>在BookServiceImpl类中将bookDao的setter方法删除掉,并添加带有bookDao参数的构造方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class BookServiceImpl implements BookService&#123;</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    public BookServiceImpl(BookDao bookDao) &#123;</span><br><span class="line">        this.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置文件中进行配置构造方式注入<br>在applicationContext.xml中配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;bookService&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot;&gt;</span><br><span class="line">        &lt;constructor-arg name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>说明：在标签<code>&lt;constructor-arg&gt;</code>中</p><ul><li>name属性对应的值为构造函数中方法<code>形参的参数名</code>，必须要保持一致。</li><li>ref属性指向的是spring的IOC容器中其他bean对象。</li></ul></li><li><p>运行程序</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310061510539.png"></p></li></ol><h3 id="构造器注入多个引用数据类型"><a href="#构造器注入多个引用数据类型" class="headerlink" title="构造器注入多个引用数据类型"></a>构造器注入多个引用数据类型</h3><blockquote><p>需求：在BookServiceImpl使用构造函数注入多个引用数据类型，比如userDao</p><ol><li>声明userDao属性</li><li>生成一个带有bookDao和userDao参数的构造函数</li><li>在applicationContext.xml中配置注入</li></ol></blockquote><ol><li><p>提供多个属性的构造函数<br>在BookServiceImpl声明userDao并提供多个参数的构造函数，save方法中记得调用userDao.save()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class BookServiceImpl implements BookService &#123;</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line">    private UserDao userDao;</span><br><span class="line"></span><br><span class="line">    public BookServiceImpl(BookDao bookDao, UserDao userDao) &#123;</span><br><span class="line">        this.bookDao = bookDao;</span><br><span class="line">        this.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在配置文件中配置多参数注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;userDao&quot; class=&quot;com.blog.dao.impl.UserDaoImpl&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;bookService&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="构造器注入多个简单数据类型"><a href="#构造器注入多个简单数据类型" class="headerlink" title="构造器注入多个简单数据类型"></a>构造器注入多个简单数据类型</h3><blockquote><p>需求:在BookDaoImpl中，使用构造函数注入databaseName和connectionNum两个参数。<br>参考引用数据类型的注入，我们可以推出具体的步骤为:</p><ol><li>提供一个包含这两个参数的构造方法</li><li>在applicationContext.xml中进行注入配置</li></ol></blockquote><ol><li><p>添加多个简单属性并提供构造方法<br>修改BookDaoImpl类，添加构造方法，同时在save()方法中输出这两个属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line"></span><br><span class="line">    private String databaseName;</span><br><span class="line">    private int connectionNum;</span><br><span class="line"></span><br><span class="line">    public BookDaoImpl(String databaseName, int connectionNum) &#123;</span><br><span class="line">        this.databaseName = databaseName;</span><br><span class="line">        this.connectionNum = connectionNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot; + databaseName + &quot;,&quot; + connectionNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置完成多个属性构造器注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;userDao&quot; class=&quot;com.blog.dao.impl.UserDaoImpl&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;databaseName&quot; value=&quot;mysql&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;connectionNum&quot; value=&quot;100&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;bookService&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><blockquote><p>也是用 VALUE 属性</p></blockquote></li></ol><h3 id="目前存在的问题"><a href="#目前存在的问题" class="headerlink" title="目前存在的问题"></a>目前存在的问题</h3><p><code>&lt;constructor-arg&gt;</code>标签内的name，必须与构造函数中的参数名一致，这两块存在紧耦合。</p><p>那么我们怎么解决这个问题呢？</p><p>在解决这个问题之前，需要提前说明的是，这个参数名发生变化的情况并不多，所以上面的还是比较主流的配置方式，下面介绍的，我们以了解为主。</p><p>方式一：删除name属性，添加type属性，按照类型注入</p><ul><li><p>这种方式可以解决构造函数形参名发生变化带来的耦合问题</p></li><li><p>但是如果构造方法参数中有类型相同的参数，这种方式就不太好实现了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;&gt;</span><br><span class="line">    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;mysql&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;constructor-arg type=&quot;int&quot; value=&quot;9421&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ul><p>方式二：删除type属性，添加index属性，按照索引下标注入，下标从0开始</p><ul><li><p>这种方式可以解决参数类型重复问题</p></li><li><p>但是如果构造方法参数顺序发生变化后，这种方式又带来了耦合问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;&gt;</span><br><span class="line">    &lt;constructor-arg index=&quot;0&quot; value=&quot;mysql&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;constructor-arg index=&quot;1&quot; value=&quot;9421&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ul><p>介绍完两种参数的注入方式，具体我们该如何选择呢?</p><ol><li>强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现<ul><li>强制依赖指对象在创建的过程中必须要注入指定的参数</li></ul></li><li>可选依赖使用setter注入进行，灵活性强<ul><li>可选依赖指对象在创建过程中注入的参数可有可无</li></ul></li><li>Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨</li><li>如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入</li><li>实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入</li><li>自己开发的模块推荐使用setter注入</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这部分主要讲解的是Spring的依赖注入的实现方式:</p><p>setter注入</p><ul><li><p>简单数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">XML</span><br><span class="line">&lt;bean ...&gt;</span><br><span class="line">    &lt;property name=&quot;&quot; value=&quot;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>引用数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">XML</span><br><span class="line">&lt;bean ...&gt;</span><br><span class="line">    &lt;property name=&quot;&quot; ref=&quot;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ul><p>构造器注入</p><ul><li><p>简单数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">XML</span><br><span class="line">&lt;bean ...&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;&quot; index=&quot;&quot; type=&quot;&quot; value=&quot;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>引用数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">XML</span><br><span class="line">&lt;bean ...&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;&quot; index=&quot;&quot; type=&quot;&quot; ref=&quot;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ul><p>依赖注入的方式选择上</p><ul><li>建议使用setter注入</li><li>第三方技术根据情况选择</li></ul><h2 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h2><p>前面花了大量的时间把Spring的注入去学习了下，总结起来就两个字<code>麻烦</code>。</p><ul><li>问:麻烦在哪?<ul><li>答:配置文件的编写配置上。</li></ul></li><li>问:有更简单方式么?<ul><li>答:有，自动配置</li></ul></li></ul><p>什么是依赖自动装配？</p><p>IOC容器根据bean所依赖的资源在容器中<code>自动查找并注入</code>到bean中的过程称为自动装配</p><h3 id="自动装配方式有哪些？"><a href="#自动装配方式有哪些？" class="headerlink" title="自动装配方式有哪些？"></a>自动装配方式有哪些？</h3><ul><li>按类型（常用）</li><li>按名称</li><li>按构造方法</li><li>不启用自动装配</li></ul><h3 id="环境准备-2"><a href="#环境准备-2" class="headerlink" title="环境准备"></a>环境准备</h3><ol><li><p>修改BookDao、BookDaoImpl、UserDao、UserDaoImpl、BookService和BookServiceImpl类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface BookDao &#123;</span><br><span class="line">    public void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    </span><br><span class="line">    private String databaseName;</span><br><span class="line">    private int connectionNum;</span><br><span class="line">    </span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface UserDao &#123;</span><br><span class="line">    public void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class UserDaoImpl implements UserDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;user dao save ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface BookService &#123;</span><br><span class="line">    public void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class BookServiceImpl implements BookService&#123;</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    public void setBookDao(BookDao bookDao) &#123;</span><br><span class="line">        this.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;bookService&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="自动装配实现"><a href="#自动装配实现" class="headerlink" title="自动装配实现"></a>自动装配实现</h3><p>自动装配只需要修改applicationContext.xml配置文件即可:</p><ol><li><p>将<code>&lt;property&gt;</code>标签删除</p></li><li><p>在<code>&lt;bean&gt;</code>标签中添加autowire属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bookService&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot; autowire=&quot;byType&quot;/&gt;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>注意事项：</p><ul><li>需要注入属性的类中对应属性的<code>setter</code>方法不能省略</li><li>被注入的对象必须要被Spring的IOC容器管理</li><li>按照类型在Spring的IOC容器中如果找到多个对象，会报<code>NoUniqueBeanDefinitionException</code></li></ul></blockquote><p>当一个类型在IOC中有多个对象，还想要注入成功，这个时候就需要按照名称注入，配置方式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--这里就有两个同一类型的bean，但是id不一样--&gt;</span><br><span class="line">    &lt;bean id=&quot;bookDao1&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;bookDao2&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;/&gt;</span><br><span class="line">    &lt;bean class=&quot;com.blog.dao.impl.BookDaoImpl&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;bookService&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot; autowire=&quot;byName&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>同时修改BookServiceImpl类汇总的<code>setBookDao</code>方法，将其重命名为<code>setBookDao1</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class BookServiceImpl implements BookService&#123;</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    public void setBookDao1(BookDao bookDao) &#123;</span><br><span class="line">        this.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么刚刚修改的是setBookDao的方法名，而不是将bookDao属性修改为bookDao1呢？按照名称注入中的名称指的是什么?</p><ul><li>因为bookDao是private修饰的，外部类无法直接访问</li><li>所以外部类只能通过属性的set方法进行访问</li><li>对外部类来说，setBookDao方法名，去掉set后首字母小写是其属性名<ul><li>为什么是去掉set首字母小写?</li><li>这个规则是set方法生成的<code>默认规则</code>，set方法的生成是把属性名首字母大写前面加set形成的方法名</li></ul></li><li>所以按照名称注入，其实是和对应的set方法有关，但是如果按照标准起名称，属性名和set对应的名是一致的</li></ul><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul><li>如果按照名称去找对应的bean对象，找不到则注入Null（空指针）</li><li>当某一个类型在IOC容器中有多个对象，按照名称注入只找其指定名称对应的bean对象，不会报错</li><li>两种方式介绍完后，以后用的更多的是<code>按照类型</code>注入。</li><li>最后对于依赖注入，需要注意一些其他的配置特征:<ol><li>自动装配用于引用类型依赖注入，不能对简单类型进行操作</li><li>使用按类型装配时（byType）必须保障容器中相同类型的bean唯一，推荐使用</li><li>使用按名称装配时（byName）必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用</li><li>自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效</li></ol></li></ul><h2 id="集合注入"><a href="#集合注入" class="headerlink" title="集合注入"></a>集合注入</h2><p>前面我们已经能完成引入数据类型和简单数据类型的注入，但是还有一种数据类型<code>集合</code>，集合中既可以装简单数据类型也可以装引用数据类型，对于集合，在Spring中该如何注入呢?</p><p>先来回顾下，常见的集合类型有哪些?</p><ul><li>数组</li><li>List</li><li>Set</li><li>Map</li><li>Properties</li></ul><p>针对不同的集合类型，实现注入</p><h4 id="注入数组类型"><a href="#注入数组类型" class="headerlink" title="注入数组类型"></a>注入数组类型</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;array&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>100<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>200<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>300<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="注入List类型"><a href="#注入List类型" class="headerlink" title="注入List类型"></a>注入List类型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;list&quot;&gt;</span><br><span class="line">    &lt;list&gt;</span><br><span class="line">        &lt;value&gt;张三&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;ABC&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;123&lt;/value&gt;</span><br><span class="line">    &lt;/list&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><h4 id="注入Set类型"><a href="#注入Set类型" class="headerlink" title="注入Set类型"></a>注入Set类型</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;set&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>100<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>200<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>ABC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>ABC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="注入Map类型"><a href="#注入Map类型" class="headerlink" title="注入Map类型"></a>注入Map类型</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;探路者&quot;</span> <span class="attr">value</span>=<span class="string">&quot;马文&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;次元游记兵&quot;</span> <span class="attr">value</span>=<span class="string">&quot;恶灵&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;易位窃贼&quot;</span> <span class="attr">value</span>=<span class="string">&quot;罗芭&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="注入Properties类型"><a href="#注入Properties类型" class="headerlink" title="注入Properties类型"></a>注入Properties类型</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;暴雷&quot;</span>&gt;</span>沃尔特·菲茨罗伊<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;寻血猎犬&quot;</span>&gt;</span>布洛特·亨德尔<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;命脉&quot;</span>&gt;</span>阿杰·切<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>property标签表示setter方式注入，构造方式注入constructor-arg标签内部也可以写<code>&lt;array&gt;</code>、<code>&lt;list&gt;</code>、<code>&lt;set&gt;</code>、<code>&lt;map&gt;</code>、<code>&lt;props&gt;</code>标签</li><li>List的底层也是通过数组实现的，所以<code>&lt;list&gt;</code>和<code>&lt;array&gt;</code>标签是可以混用</li><li>集合中要添加引用类型，只需要把<code>&lt;value&gt;</code>标签改成<code>&lt;ref&gt;</code>标签，这种方式用的比较少</li></ul><h2 id="IOC-x2F-DI配置管理第三方bean"><a href="#IOC-x2F-DI配置管理第三方bean" class="headerlink" title="IOC&#x2F;DI配置管理第三方bean"></a>IOC&#x2F;DI配置管理第三方bean</h2><p>前面所讲的知识点都是基于我们自己写的类，现在如果有需求让我们去管理第三方jar包中的类，该如何管理?</p><h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><p>前面已经完成bean与依赖注入的相关知识学习，接下来我们主要学习的是IOC容器中的<code>核心容器</code>。</p><p>这里所说的核心容器，我们可以把它简单的理解为<code>ApplicationContext</code>，前面虽然已经用到过，但是并没有系统的学习，接下来我们从以下几个问题入手来学习下容器的相关知识:</p><ul><li>如何创建容器?</li><li>创建好容器后，如何从容器中获取bean对象?</li><li>容器类的层次结构是什么?</li><li>BeanFactory是什么?</li></ul><h2 id="环境准备-3"><a href="#环境准备-3" class="headerlink" title="环境准备"></a>环境准备</h2><p>创建一个Maven项目</p><p>pom.xml添加Spring的依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">XML</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>resources下添加applicationContext.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">XML</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;</span><br><span class="line">            http://www.springframework.org/schema/beans</span><br><span class="line">            http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        &quot;&gt;</span><br><span class="line">    &lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>添加BookDao和BookDaoImpl类</p><ul><li>BookDao</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public interface BookDao &#123;</span><br><span class="line">    public void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>BookDaoImpl</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot; );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建运行类App</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        BookDao bookDao = (BookDao) ctx.getBean(&quot;bookDao&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="容器的创建方式"><a href="#容器的创建方式" class="headerlink" title="容器的创建方式"></a>容器的创建方式</h2><p>案例中创建<code>ApplicationContext</code>的方式如下</p><p>这种方式翻译为：类路径下的XML配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br></pre></td></tr></table></figure><p>除了上面这种方式，Spring还提供了另外一种创建方式</p><p>这种方式翻译为：文件系统下的XML配置文件，路径需要写绝对路径</p><p>这种方式虽能实现，但是当项目的位置发生变化后，代码也需要跟着改，耦合度高，不推荐使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = new FileSystemXmlApplicationContext(&quot;D:\xxx/xxx\applicationContext.xml&quot;);</span><br></pre></td></tr></table></figure><h3 id="获取bean的三种方式"><a href="#获取bean的三种方式" class="headerlink" title="获取bean的三种方式"></a>获取bean的三种方式</h3><p>方式一，就是我们之前用的方式</p><ul><li>这种方式存在的问题是每次获取的时候都需要进行类型转换，有没有更简单的方式呢?</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BookDao bookDao = (BookDao) ctx.getBean(&quot;bookDao&quot;);</span><br></pre></td></tr></table></figure><p>方式二</p><ul><li>这种方式可以解决类型强转问题，但是参数又多加了一个，相对来说没有简化多少。</li><li>前面是名称，后面是类型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BookDao bookDao = ctx.getBean(&quot;bookDao&quot;，BookDao.class);</span><br></pre></td></tr></table></figure><p>方式三</p><ul><li>这种方式就类似我们之前所学习依赖注入中的按类型注入。必须要确保IOC容器中该类型对应的bean对象只能有一个。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BookDao bookDao = ctx.getBean(BookDao.class);</span><br></pre></td></tr></table></figure><h3 id="BeanFactory的使用"><a href="#BeanFactory的使用" class="headerlink" title="BeanFactory的使用"></a>BeanFactory的使用</h3><p>容器的最上级的父接口为<code>BeanFactory</code>，使用<code>BeanFactory</code>也可以创建IOC容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class AppForBeanFactory &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Resource resources = new ClassPathResource(&quot;applicationContext.xml&quot;);</span><br><span class="line">        BeanFactory bf = new XmlBeanFactory(resources);</span><br><span class="line">        BookDao bookDao = bf.getBean(BookDao.class);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了更好的看出<code>BeanFactory</code>和<code>ApplicationContext</code>之间的区别，在BookDaoImpl添加如下构造函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    public BookDaoImpl() &#123;</span><br><span class="line">        System.out.println(&quot;constructor&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot; );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不去获取bean对象，打印会发现：</p><ul><li>BeanFactory是延迟加载，只有在获取bean对象的时候才会去创建</li><li>ApplicationContext是立即加载，容器加载的时候就会创建bean对象</li><li>ApplicationContext要想成为延迟加载，只需要将lazy-init设为true</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;</span><br><span class="line">            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">    &lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;  lazy-init=&quot;true&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h3 id="核心容器总结"><a href="#核心容器总结" class="headerlink" title="核心容器总结"></a>核心容器总结</h3><h4 id="容器相关"><a href="#容器相关" class="headerlink" title="容器相关"></a>容器相关</h4><p>BeanFactory是IoC容器的顶层接口，初始化BeanFactory对象时，加载的bean延迟加载</p><p>ApplicationContext接口是Spring容器的核心接口，初始化时bean立即加载</p><p>ApplicationContext接口提供基础的bean操作相关方法，通过其他接口扩展其功能</p><p>ApplicationContext接口常用初始化类</p><ul><li>ClassPathXmlApplicationContext(常用)</li><li>FileSystemXmlApplicationContext</li></ul><h4 id="bean相关"><a href="#bean相关" class="headerlink" title="bean相关"></a>bean相关</h4><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310061634303.png"></p><h4 id="依赖注入相关"><a href="#依赖注入相关" class="headerlink" title="依赖注入相关"></a>依赖注入相关</h4><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310061634580.png"></p><h1 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h1><p>Spring的IOC&#x2F;DI对应的配置开发就已经讲解完成，但是使用起来相对来说还是比较复杂的，复杂的地方在<code>配置文件</code>。<br>Spring到底是如何简化代码开发的呢?<br>要想真正简化开发，就需要用到Spring的注解开发，Spring对注解支持的版本历程:</p><ul><li>2.0版开始支持注解</li><li>2.5版注解功能趋于完善</li><li>3.0版支持纯注解开发</li></ul><p>关于注解开发，这里会讲解两块内容<code>注解开发定义bean</code>和<code>纯注解开发</code>。<br>注解开发定义bean用的是2.5版提供的注解，纯注解开发用的是3.0版提供的注解。</p><blockquote><p><strong>项目环境和依赖注入处相同</strong></p></blockquote><h2 id="注解开发定义bean"><a href="#注解开发定义bean" class="headerlink" title="注解开发定义bean"></a>注解开发定义bean</h2><ol><li><p>删除原有的XML配置<br>将配置文件中的bean标签删除掉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;/&gt;</span><br></pre></td></tr></table></figure></li><li><p>在Dao上添加注解<br>在BookDaoImpl类上添加<code>@Component</code>注解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Component(&quot;bookDao&quot;)</span><br><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：@Component注解不可以添加在接口上，因为接口是无法创建对象的。</p></blockquote><p>Service上添加注解<br>在BookServiceImpl类上也添加<code>@Component</code>交给Spring框架管理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class BookServiceImpl implements BookService &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置Spring的注解包扫描<br>为了让Spring框架能够扫描到写在类上的注解，需要在配置文件上进行包扫描</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;</span><br><span class="line">            http://www.springframework.org/schema/beans</span><br><span class="line">            http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">            http://www.springframework.org/schema/context</span><br><span class="line">            http://www.springframework.org/schema/context/spring-context.xsd</span><br><span class="line">        &quot;&gt;</span><br><span class="line">    &lt;context:component-scan base-package=&quot;com.blog&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>说明：component-scan</p><ul><li>component:组件,Spring将管理的bean视作自己的一个组件</li><li>scan:扫描<br>base-package指定Spring框架扫描的包路径，它会扫描指定包及其子包中的所有类上的注解。</li><li>包路径越多<code>如:com.blog.dao.impl</code>，扫描的范围越小速度越快</li><li>包路径越少<code>如:com.blog</code>,扫描的范围越大速度越慢</li><li>一般扫描到项目的组织名称即Maven的groupId下<code>如:com.blog</code>即可</li></ul></li><li><p>运行程序</p><p>在App类中，从IOC容器中获取对应的bean对象</p><p>因为注解的不同，获取方式也不同，分为<strong>名称</strong>和<strong>类型</strong></p><ul><li>BookServiceImpl类没有起名称，所以在App中是按照类型来获取bean对象</li><li><code>@Component</code>注解如果不起名称，会有一个默认值就是<code>当前类名首字母小写</code>，所以也可以按照名称获取</li></ul><p>对于@Component注解，还衍生出了其他三个注解<code>@Controller</code>、<code>@Service</code>、<code>@Repository</code><br>通过查看源码会发现：这三个注解和@Component注解的作用是一样的，为什么要衍生出这三个呢?<br>这是方便我们后期在编写类的时候能很好的区分出这个类是属于<code>表现层</code>、<code>业务层</code>还是<code>数据层</code>的类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        //按照名称获取bean</span><br><span class="line">        BookDao bookDao = (BookDao) context.getBean(&quot;bookDao&quot;);</span><br><span class="line">        //按照类型获取bean</span><br><span class="line">        BookService bookService = context.getBean(BookService.class);</span><br><span class="line">        bookDao.save();</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310061642263.png"></p></li></ol><h2 id="纯注解开发模式"><a href="#纯注解开发模式" class="headerlink" title="纯注解开发模式"></a>纯注解开发模式</h2><p>上面已经可以使用注解来配置bean,但是依然有用到配置文件，在配置文件中对包进行了扫描，Spring在3.0版已经支持纯注解开发，使用Java类替代配置文件，开启了Spring快速开发赛道，那么具体如何实现?</p><p>实现思路为：将配置文件applicationContext.xml删掉，用类来替换</p><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol><li><p>创建配置类<br>创建一个配置类SpringConfig，标识该类为配置类</p></li><li><p>在配置类上面加一个<code>@Configuration</code>注解，将其标识为一个配置类，用于替换掉<code>applicationContext.XML</code></p></li><li><p>用注解替换包扫描配置<br>在配置类上添加包扫描注解<code>@ComponentScan</code>替换<code>&lt;context:component-scan base-package=&quot;&quot;/&gt;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.blog&quot;)</span><br><span class="line">public class SpringConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建运行类并执行<br>创建一个新的运行类<code>AppForAnnotation</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class AppForAnnotation &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);</span><br><span class="line">        BookDao bookDao = (BookDao) context.getBean(&quot;bookDao&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">        BookService bookService = context.getBean(BookService.class);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行AppForAnnotation，可以看到两个对象依然被获取成功</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310061714330.png"></p></li></ol><p>至此，纯注解开发的方式就已经完成了，主要内容包括：</p><ul><li><p>Java类替换Spring核心配置文件</p><ul><li><code>@Configuration</code>注解用于设定当前类为配置类</li><li><code>@ComponentScan</code>注解用于设定扫描路径，此注解只能添加一次，多个数据请用数组格式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@ComponentScan(&#123;com.blog.service&quot;,&quot;com.blog.dao&quot;&#125;)</span><br></pre></td></tr></table></figure></li><li><p>读取Spring核心配置文件初始化容器对象切换为读取Java配置类初始化容器对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310061715496.png"></p><p>知识点：<code>@Configuration</code></p><table><thead><tr><th align="center">名称</th><th align="center">@Configuration</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">类注解</td></tr><tr><td align="center">位置</td><td align="center">类定义上方</td></tr><tr><td align="center">作用</td><td align="center">设置该类为spring配置类</td></tr><tr><td align="center">属性</td><td align="center">value（默认）：定义bean的id</td></tr></tbody></table><p>知识点：<code>@ComponentScan</code></p><table><thead><tr><th align="center">名称</th><th align="center">@ComponentScan</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">类注解</td></tr><tr><td align="center">位置</td><td align="center">类定义上方</td></tr><tr><td align="center">作用</td><td align="center">设置spring配置类扫描路径，用于加载使用注解格式定义的bean</td></tr><tr><td align="center">属性</td><td align="center">value（默认）：扫描路径，此路径可以逐层向下扫描</td></tr></tbody></table><h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>这部分要重点掌握的是使用注解完成Spring的bean管理，需要掌握的内容为:</p><ul><li>记住<code>@Component</code>、<code>@Controller</code>、<code>@Service</code>、<code>@Repository</code>这四个注解</li><li>applicationContext.xml中<code>&lt;context:component-san/&gt;</code>的作用是指定扫描包路径，注解为<code>@ComponentScan</code></li><li><code>@Configuration</code>标识该类为配置类，使用类替换<code>applicationContext.xml</code>文件</li><li><code>ClassPathXmlApplicationContext</code>是加载XML配置文件</li><li><code>AnnotationConfigApplicationContext</code>是加载配置类</li></ul><h2 id="注解开发bean的作用范围和生命周期"><a href="#注解开发bean的作用范围和生命周期" class="headerlink" title="注解开发bean的作用范围和生命周期"></a>注解开发bean的作用范围和生命周期</h2><p>使用注解已经完成了bean的管理，接下来按照前面所学习的内容，将通过配置实现的内容都换成对应的注解实现，包含两部分内容:<code>bean作用范围(scope)</code>和<code>bean生命周期(init和destroy)</code>。</p><h3 id="bean的作用范围"><a href="#bean的作用范围" class="headerlink" title="bean的作用范围"></a>bean的作用范围</h3><p>修改<code>AppForAnnotation</code>类，并运行查看结果</p><ul><li><p>默认情况下bean是单例</p></li><li><p>要想将BookDaoImpl变成非单例，只需要在其类上添加<code>@scope</code>注解</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class AppForAnnotation &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);</span><br><span class="line">        BookDao bookDao1 = (BookDao) context.getBean(&quot;bookDao&quot;);</span><br><span class="line">        BookDao bookDao2 = (BookDao) context.getBean(&quot;bookDao&quot;);</span><br><span class="line">        System.out.println(bookDao1);</span><br><span class="line">        System.out.println(bookDao2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Component(&quot;bookDao&quot;)</span><br><span class="line">@Scope(&quot;prototype&quot;)</span><br><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知识点：<code>@scope</code></p><table><thead><tr><th align="center">名称</th><th align="center">@Scope</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">类注解</td></tr><tr><td align="center">位置</td><td align="center">类定义上方</td></tr><tr><td align="center">作用</td><td align="center">设置该类创建对象的作用范围，可用于设置创建出的bean是否为单例对象</td></tr><tr><td align="center">属性</td><td align="center">value（默认）：定义bean作用范围，默认值singleton（单例），可选值prototype（非单例）</td></tr></tbody></table><h3 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h3><p>在BookDaoImpl中添加两个方法，<code>init</code>和<code>destroy</code>，方法名可以任意，再添加一个构造方法</p><ul><li><p>如何对方法进行标识，哪个是初始化方法，哪个是销毁方法?<br>只需要在对应的方法上添加<code>@PostConstruct</code>和<code>@PreDestroy</code>注解即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Component(&quot;bookDao&quot;)</span><br><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line"></span><br><span class="line">    public BookDaoImpl() &#123;</span><br><span class="line">        System.out.println(&quot;construct ... &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostConstruct  // 在构造方法之后执行，替换 init-method</span><br><span class="line">    public void init() &#123;</span><br><span class="line">        System.out.println(&quot;init ... &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PreDestroy // 在销毁方法之前执行,替换 destroy-method</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">        System.out.println(&quot;destroy ... &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>要想看到两个方法执行，需要注意的是<code>destroy</code>只有在容器关闭的时候，才会执行，所以需要修改App的类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class AppForAnnotation &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);</span><br><span class="line">        BookDao bookDao = (BookDao) context.getBean(&quot;bookDao&quot;);</span><br><span class="line">        System.out.println(bookDao);</span><br><span class="line">        context.registerShutdownHook();//关闭容器</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意：JDK8版本以上，如果找不到<code>@PostConstruct</code>和<code>@PreDestroy</code>注解，需要导入下面的jar包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">XML</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;javax.annotation&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.3.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>找不到的原因是，从JDK9以后jdk中的javax.annotation包被移除了，这两个注解刚好就在这个包中。</p></blockquote><p>知识点<code>@PostConstruct</code></p><table><thead><tr><th align="center">名称</th><th align="center">@PostConstruct</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">方法注解</td></tr><tr><td align="center">位置</td><td align="center">方法上</td></tr><tr><td align="center">作用</td><td align="center">设置该方法为初始化方法</td></tr><tr><td align="center">属性</td><td align="center">无</td></tr></tbody></table><p>知识点<code>PreDestroy</code></p><table><thead><tr><th align="center">名称</th><th align="center">@PreDestroy</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">方法注解</td></tr><tr><td align="center">位置</td><td align="center">方法上</td></tr><tr><td align="center">作用</td><td align="center">设置该方法为销毁方法</td></tr><tr><td align="center">属性</td><td align="center">无</td></tr></tbody></table><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>配置文件中的bean标签中的<br><code>id</code>对应<code>@Component(&quot;&quot;)</code>，<code>@Controller(&quot;&quot;)</code>，<code>@Service(&quot;&quot;)</code>，<code>@Repository(&quot;&quot;)</code><br><code>scope</code>对应<code>@scope()</code><br><code>init-method</code>对应<code>@PostConstruct</code><br><code>destroy-method</code>对应<code>@PreDestroy</code></p><h2 id="注解开发依赖注入"><a href="#注解开发依赖注入" class="headerlink" title="注解开发依赖注入"></a>注解开发依赖注入</h2><p>Spring为了使用注解简化开发，并没有提供<code>构造函数注入</code>、<code>setter注入</code>对应的注解，只提供了自动装配的注解实现。</p><h3 id="环境准备-4"><a href="#环境准备-4" class="headerlink" title="环境准备"></a>环境准备</h3><ol><li>创建一个Maven项目</li><li>pom.xml添加Spring的依赖</li><li>添加一个配置类<code>SpringConfig</code></li><li>添加BookDao、BookDaoImpl、BookService、BookServiceImpl类</li><li>创建运行类AppForAnnotation</li><li>环境准备好后，直接运行App类会有问题，因为还没有提供配置注入BookDao的，所以bookDao对象为Null,调用其save方法就会报<code>控指针异常</code>。</li></ol><h3 id="注解实现按照类型注入"><a href="#注解实现按照类型注入" class="headerlink" title="注解实现按照类型注入"></a>注解实现按照类型注入</h3><p>在BookServiceImpl类的bookDao属性上添加<code>@Autowired</code>注解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">@Service</span><br><span class="line">public class BookServiceImpl implements BookService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line"></span><br><span class="line">//    public void setBookDao(BookDao bookDao) &#123;</span><br><span class="line">//        this.bookDao = bookDao;</span><br><span class="line">//    &#125;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li><p><code>@Autowired</code>可以写在属性上，也可也写在setter方法上，最简单的处理方式是<code>写在属性上并将setter方法删除掉</code></p></li><li><p><code>@Autowired</code>是按照类型注入，那么对应BookDao接口如果有多个实现类，比如添加BookDaoImpl2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Repository</span><br><span class="line">public class BookDaoImpl2 implements BookDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候再次运行App，就会报错<code>NoUniqueBeanDefinitionException</code><br>此时，按照类型注入就无法区分到底注入哪个对象，解决方案:<code>按照名称注入</code></p><ul><li><p>先给两个Dao类分别起个名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Repository(&quot;bookDao&quot;)</span><br><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot; );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@Repository(&quot;bookDao2&quot;)</span><br><span class="line">public class BookDaoImpl2 implements BookDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...2&quot; );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>此时就可以注入成功，但是得思考个问题:</p><ul><li>@Autowired是按照类型注入的，给BookDao的两个实现起了名称，它还是有两个bean对象，为什么不报错?</li><li>@Autowired默认按照类型自动装配，如果IOC容器中同类的Bean找到多个，就按照变量名和Bean的名称匹配。因为变量名叫<code>bookDao</code>而容器中也有一个<code>booDao</code>，所以可以成功注入。</li></ul></li><li><p>为什么setter方法可以删除呢?</p><ul><li>自动装配基于反射设计创建对象并通过<code>暴力反射</code>为私有属性进行设值</li><li>普通反射只能获取public修饰的内容</li><li>暴力反射除了获取public修饰的内容还可以获取private修改的内容</li><li>所以此处无需提供setter方法</li></ul></li></ul><h3 id="注解实现按照名称注入"><a href="#注解实现按照名称注入" class="headerlink" title="注解实现按照名称注入"></a>注解实现按照名称注入</h3><p>当根据类型在容器中找到多个bean，注入参数的属性名又和容器中bean的名称不一致，这个时候该如何解决，就需要使用到<code>@Qualifier</code>来指定注入哪个名称的bean对象。<code>@Qualifier</code>注解后的值就是需要注入的bean的名称。</p><p>当根据类型在容器中找到多个bean,注入参数的属性名又和容器中bean的名称不一致，这个时候该如何解决，就需要使用到<code>@Qualifier</code>来指定注入哪个名称的bean对象。<code>@Qualifier</code>注解后的值就是需要注入的bean的名称。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class BookServiceImpl implements BookService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    @Qualifier(&quot;bookDao1&quot;)</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line">    </span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@Qualifier不能独立使用，必须和@Autowired一起使用</p></blockquote><h3 id="简单数据类型注入"><a href="#简单数据类型注入" class="headerlink" title="简单数据类型注入"></a>简单数据类型注入</h3><p>引用类型看完，简单类型注入就比较容易懂了。简单类型注入的是基本数据类型或者字符串类型，下面在<code>BookDaoImpl</code>类中添加一个<code>name</code>属性，用其进行简单类型注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Repository</span><br><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot; + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据类型换了，对应的注解也要跟着换，这次使用<code>@Value</code>注解，将值写入注解的参数中就行了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Repository</span><br><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    @Value(&quot;Stephen&quot;)</span><br><span class="line">    private String name;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot; + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意数据格式要匹配，如将”abc”注入给int值，这样程序就会报错。</p></blockquote><p>介绍完后，会有一种感觉就是这个注解好像没什么用，跟直接赋值是一个效果，还没有直接赋值简单，所以这个注解存在的意义是什么?继续往下看</p><h3 id="注解读取properties配置文件"><a href="#注解读取properties配置文件" class="headerlink" title="注解读取properties配置文件"></a>注解读取properties配置文件</h3><p><code>@Value</code>一般会被用在从properties配置文件中读取内容进行使用，具体如何实现?</p><ol><li><p>在resource下准备一个properties文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=Stephen</span><br></pre></td></tr></table></figure></li><li><p>使用注解加载properties配置文件，在配置类上添加<code>@PropertySource</code>注解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.blog&quot;)</span><br><span class="line">@PropertySource(&quot;jdbc.properties&quot;)</span><br><span class="line">public class SpringConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用@Value读取配置文件中的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Repository</span><br><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    @Value(&quot;$&#123;name&#125;&quot;)</span><br><span class="line">    private String name;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot; + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行程序</p></li></ol><p><strong>注意:</strong></p><ul><li>如果读取的properties配置文件有多个，可以使用<code>@PropertySource</code>的属性来指定多个</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@PropertySource(&#123;&quot;jdbc.properties&quot;,&quot;xxx.properties&quot;&#125;)</span><br></pre></td></tr></table></figure><ul><li><code>@PropertySource</code>注解属性中不支持使用通配符<code>*</code>,运行会报错</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@PropertySource(&#123;&quot;*.properties&quot;&#125;)</span><br></pre></td></tr></table></figure><ul><li><code>@PropertySource</code>注解属性中可以把<code>classpath:</code>加上,代表从当前项目的根路径找文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@PropertySource(&#123;&quot;classpath:jdbc.properties&quot;&#125;)</span><br></pre></td></tr></table></figure><p>知识点1：<code>@Autowired</code></p><table><thead><tr><th align="center">名称</th><th align="center">@Autowired</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">属性注解 或 方法注解（了解） 或 方法形参注解（了解）</td></tr><tr><td align="center">位置</td><td align="center">属性定义上方 或 标准set方法上方 或 类set方法上方 或 方法形参前面</td></tr><tr><td align="center">作用</td><td align="center">为引用类型属性设置值</td></tr><tr><td align="center">属性</td><td align="center">required：true&#x2F;false，定义该属性是否允许为null</td></tr></tbody></table><p>知识点2：<code>@Qualifier</code></p><table><thead><tr><th align="center">名称</th><th align="center">@Qualifier</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">属性注解 或 方法注解（了解）</td></tr><tr><td align="center">位置</td><td align="center">属性定义上方 或 标准set方法上方 或 类set方法上方</td></tr><tr><td align="center">作用</td><td align="center">为引用类型属性指定注入的beanId</td></tr><tr><td align="center">属性</td><td align="center">value（默认）：设置注入的beanId</td></tr></tbody></table><p>知识点3：<code>@Value</code></p><table><thead><tr><th align="center">名称</th><th align="center">@Value</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">属性注解 或 方法注解（了解）</td></tr><tr><td align="center">位置</td><td align="center">属性定义上方 或 标准set方法上方 或 类set方法上方</td></tr><tr><td align="center">作用</td><td align="center">为 基本数据类型 或 字符串类型 属性设置值</td></tr><tr><td align="center">属性</td><td align="center">value（默认）：要注入的属性值</td></tr></tbody></table><p>知识点4：<code>@PropertySource</code></p><table><thead><tr><th align="center">名称</th><th align="center">@PropertySource</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">类注解</td></tr><tr><td align="center">位置</td><td align="center">类定义上方</td></tr><tr><td align="center">作用</td><td align="center">加载properties文件中的属性值</td></tr><tr><td align="center">属性</td><td align="center">value（默认）：设置加载的properties文件对应的文件名或文件名组成的数组</td></tr></tbody></table><h2 id="注解开发总结"><a href="#注解开发总结" class="headerlink" title="注解开发总结"></a>注解开发总结</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310061950274.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java-JDBC</title>
      <link href="/2023/06/15/JavaJDBC/"/>
      <url>/2023/06/15/JavaJDBC/</url>
      
        <content type="html"><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><p>JDBC：Java 提供的一套用于操作数据库的接口 API。Java 程序员只需要面向该接口即可连接任何提供了 JDBC 驱动程序的数据库，完成对数据库的各种操作。不同的数据库厂商，需要针对这套接口提供不同的实现。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310160829019.png"></p><p><strong>JDBC 程序编写步骤（示范）：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/* [1] 注册驱动 */</span><br><span class="line">Driver driver = new com.mysql.cj.jdbc.Driver();</span><br><span class="line"></span><br><span class="line">/* [2] 获取连接 */</span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/melody&quot;;</span><br><span class="line">Properties properties = new Properties();</span><br><span class="line">properties.setProperty(&quot;user&quot;, &quot;root&quot;);</span><br><span class="line">properties.setProperty(&quot;password&quot;, &quot;******&quot;);</span><br><span class="line">Connection connect = driver.connect(url, properties);</span><br><span class="line"></span><br><span class="line">/* [3] 执行语句 */</span><br><span class="line">String sql = &quot;insert into customer (customer_id,name,card_id) values(0004,&#x27;赫尔&#x27;,&#x27;00000000000000000O&#x27;)&quot;;</span><br><span class="line">Statement statement = connect.createStatement();</span><br><span class="line">int rows = statement.executeUpdate(sql);</span><br><span class="line">System.out.println(rows);</span><br><span class="line"></span><br><span class="line">/* [4] 释放资源 */</span><br><span class="line">statement.close();</span><br><span class="line">connect.close();</span><br></pre></td></tr></table></figure><ul><li><p>前置操作：将 <code>mysql-connector-java-8.0.27.jar</code> 该文件拷贝到项目目录下，选中后右键选择 <code>Add as library</code></p></li><li><p>注册驱动：加载 <code>Driver</code> 类</p><p>这里我导入了 <code>com.mysql.cj.jdbc.Driver</code>。根据前面的 <code>jar</code> 包的版本不同，应该导入的路径也会不同。</p><p>旧版本的 <code>jar</code> 包可能应该导入 <code>com.mysql.jdbc.Driver</code> 这个包。</p></li><li><p>获取连接：得到 <code>Connection</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String url = &quot;jdbc:mysql://localhost:3306/test&quot;;</span><br></pre></td></tr></table></figure><p>这里表示进入 <code>test</code> 这个数据库。</p></li><li><p>执行语句：发送 SQL 命令给 MySQL 执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int rows = statement.executeUpdate(sql);</span><br></pre></td></tr></table></figure><p>如果是 dml 语句，这里返回的 rows 是影响的行数。返回 0 表示失败。</p></li><li><p>释放资源：关闭相关连接</p></li></ul><h2 id="连接数据库的-5-种方式"><a href="#连接数据库的-5-种方式" class="headerlink" title="连接数据库的 5 种方式"></a>连接数据库的 5 种方式</h2><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">方法1</button></li><li class="tab"><button type="button" data-href="#test1-2">方法2</button></li><li class="tab"><button type="button" data-href="#test1-3">方法3</button></li><li class="tab"><button type="button" data-href="#test1-4">方法4</button></li><li class="tab"><button type="button" data-href="#test1-5">方法5（推荐）</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p>直接创建 <code>Driver</code>，调用 <code>driver.connet(url, properties);</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Driver driver = new com.mysql.cj.jdbc.Driver();</span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/test&quot;;</span><br><span class="line">Properties properties = new Properties();</span><br><span class="line">properties.setProperty(&quot;user&quot;, &quot;root&quot;);</span><br><span class="line">properties.setProperty(&quot;password&quot;, &quot;111111&quot;);</span><br><span class="line">Connection connect = driver.connect(url, properties);</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p>使用反射加载 <code>Driver</code> 类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; aClass = Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">Driver driver = (Driver) aClass.newInstance();</span><br><span class="line">Properties properties = new Properties();</span><br><span class="line">properties.setProperty(&quot;user&quot;, &quot;root&quot;);</span><br><span class="line">properties.setProperty(&quot;password&quot;, &quot;******&quot;);</span><br><span class="line">Connection connect = driver.connect(url, properties);</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p>使用 <code>DriverManager</code> 替代 <code>Driver</code> 进行统一管理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; aClass = Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">Driver driver = (Driver) aClass.newInstance();</span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/melody&quot;;</span><br><span class="line">String name = &quot;root&quot;;</span><br><span class="line">String password = &quot;******&quot;;</span><br><span class="line">DriverManager.registerDriver(driver);</span><br><span class="line">Connection connection = DriverManager.getConnection(url, name, password);</span><br></pre></td></tr></table></figure><p>这里，<code>DriverManager.getConnetion()</code> 有三种方法。分别是：</p><ul><li><code>getConnetion(url);</code></li><li><code>getConnetion(url, properties);</code></li><li><code>getConnetion(url, name, password);</code></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><p>使用 <code>Class.forName()</code> 自动完成注册驱动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; aClass = Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/melody&quot;;</span><br><span class="line">String name = &quot;root&quot;;</span><br><span class="line">String password = &quot;******&quot;;</span><br><span class="line">Connection connection = DriverManager.getConnection(url, name, password);</span><br></pre></td></tr></table></figure><p><code>Class.forName()</code> 在加载 <code>Driver</code> 类时，会自动完成注册，原理是加载类的时候调用静态代码块</p><p>原理：</p><p><code>Driver</code> 类的源码中有这样一段，这个静态代码块在类加载时会被执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">         DriverManager.registerDriver(new Driver());</span><br><span class="line">     &#125; catch (SQLException var1) &#123;</span><br><span class="line">         throw new RuntimeException(&quot;Can&#x27;t register driver!&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，其实不执行 <code>Class.forName(...);</code> 语句的场合，也能正确获取 <code>Connection</code>。</p><p>这是因为 JDK 1.5 以后使用了 jdbc4。这个场合，系统会自动调用 jar 包下 <code>META-INF\services\java.sql.Driver</code> 这个文件中的类名称去注册。</p><p>打开上述文件看看，里面赫然写着：<code>com.mysql.cj.jdbc.Driver</code></p><blockquote><p>即使如此，还是建议写上 <code>Class.forName(...)</code> 语句！</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-5"><p>在方式 4 的基础上，使用配置文件，连接数据库更灵活。</p><p>这种方式是实际开发最常用的方式。</p><ol><li><p>配置文件（创建 src\mysql.properties）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url=jdbc:mysql://localhost:3306/test</span><br><span class="line">user=root</span><br><span class="line">password=******</span><br><span class="line">driver=com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure></li><li><p>链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Properties pro = new Properties();</span><br><span class="line">pro.load(new FileInputStream(&quot;src\\mysql.properties&quot;))</span><br><span class="line">String url = pro.getProperties(&quot;url&quot;);</span><br><span class="line">String user = pro.getProperties(&quot;user&quot;);</span><br><span class="line">String password = pro.getProperties(&quot;password&quot;);</span><br><span class="line">String driver = pro.getProperties(&quot;driver&quot;);</span><br><span class="line">Class&lt;?&gt; aClass = Class.forName(driver);</span><br><span class="line">Connection connection = DriverManager.getConnection(url, user, password);</span><br></pre></td></tr></table></figure></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="ReaultSet-结果集"><a href="#ReaultSet-结果集" class="headerlink" title="ReaultSet 结果集"></a>ReaultSet 结果集</h2><p>ResultSet：表示数据库结果集的数据表。通常通过执行查询数据库的语句生成。</p><p>ResultSet 对象保持一个光标指向其当前的数据行。该光标的初始位置在第一行之前。调用 next 方法将光标下移，移动到末端的场合会返回 false。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310151520161.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        //通过Properties对象获取配置文件的信息</span><br><span class="line">        Properties properties = new Properties();</span><br><span class="line">        properties.load(new FileInputStream(&quot;src\\mysql.properties&quot;));</span><br><span class="line">        </span><br><span class="line">        //获取相关的值</span><br><span class="line">        String user = properties.getProperty(&quot;user&quot;);</span><br><span class="line">        String password = properties.getProperty(&quot;password&quot;);</span><br><span class="line">        String driver = properties.getProperty(&quot;driver&quot;);</span><br><span class="line">        String url = properties.getProperty(&quot;url&quot;);</span><br><span class="line"></span><br><span class="line">        //1. 注册驱动</span><br><span class="line">        Class.forName(driver);//建议写上</span><br><span class="line"></span><br><span class="line">        //2. 得到连接</span><br><span class="line">        Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">        //3. 得到Statement</span><br><span class="line">        Statement statement = connection.createStatement();</span><br><span class="line">        </span><br><span class="line">        //4. 组织SqL</span><br><span class="line">        String sql = &quot;select id, name , sex, borndate from actor&quot;;</span><br><span class="line">        ResultSet resultSet = statement.executeQuery(sql);</span><br><span class="line">        //执行给定的SQL语句，该语句返回单个 ResultSet对象</span><br><span class="line">        /*</span><br><span class="line">        +----+-----------+-----+---------------------+</span><br><span class="line">        | id | name      | sex | borndate            |</span><br><span class="line">        +----+-----------+-----+---------------------+-------+</span><br><span class="line">        |  4 | 刘德华    | 男  | 1970-12-12 00:00:00 |</span><br><span class="line">        |  5 | jack      | 男  | 1990-11-11 00:00:00 |</span><br><span class="line">        +----+-----------+-----+---------------------+-------+</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        //5. 使用while取出数据</span><br><span class="line">        while (resultSet.next()) &#123; // 让光标向后移动，如果没有更多行，则返回false</span><br><span class="line">            int id  = resultSet.getInt(1); //获取该行的第1列</span><br><span class="line">            //int id1 = resultSet.getInt(&quot;id&quot;); 通过列名来获取值, 推荐</span><br><span class="line">            String name = resultSet.getString(2);//获取该行的第2列</span><br><span class="line">            String sex = resultSet.getString(3);</span><br><span class="line">            Date date = resultSet.getDate(4);</span><br><span class="line"></span><br><span class="line">            System.out.println(id + &quot;\t&quot; + name + &quot;\t&quot; + sex + &quot;\t&quot; + date);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //6. 关闭连接</span><br><span class="line">        resultSet.close();</span><br><span class="line">        statement.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a><code>Statement</code></h2><p>Statement：是个接口，由数据库厂商完成功能的实现</p><p><code>Statment</code> 对象用于执行静态 SQL 语句，并返回其生成的结果的对象</p><p>在连接建立后，需要访问数据库、执行命名或 SQL 语句，有如下方式：</p><ul><li><code>Statment</code>（存在 SQL 注入问题，在实际开发中基本不使用）</li><li><code>PerparedStatement</code>（预处理，从Statement扩展而来）</li><li><code>CallableStatement</code>（存储过程）</li></ul><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310160834641.png"></p><p>SQL 注入：利用某些系统没有对用户输入的数据进行充分的检查，故意注入非法的 SQL 语句段或命令，恶意攻击数据库。使用 <code>PreparedStatement</code> 可以防范 SQL 注入</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310151533752.png"></p><h3 id="PerparedStatement"><a href="#PerparedStatement" class="headerlink" title="PerparedStatement"></a>PerparedStatement</h3><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310151535379.png"></p><ol><li><p><code>PreparedStatement</code> 执行的 SQL 语句的参数用 <code>?</code> 表示。</p><p>调用方法设置 SQL 语句中的参数，一堆set方法，都有2个参数，第一个是设置的参数的索引（位置），第二个是设置值（参数值）</p></li><li><p><code>executeQuery()</code> ：执行查询方法，返回 <code>ResultSet</code> 对象。</p></li><li><p>executeUpdate()：执行更新，包括增、删、修改</p></li></ol><blockquote><p>PerparedStatement 对SQL语句有一个预处理的过程</p></blockquote><p><strong>预处理的好处</strong></p><ol><li>不再使用拼接语句，增加代码可读性，减少语法错误</li><li>解决了 SQL 注入问题</li><li>大大减少了编译次数，效率提高（保留一个模版，每次传入不同参数执行不同SQL语句）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    //看 PreparedStatement类图</span><br><span class="line"></span><br><span class="line">    Scanner scanner = new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">    //让用户输入管理员名和密码</span><br><span class="line">    System.out.print(&quot;请输入管理员的名字: &quot;);  //next(): 当接收到 空格或者 &#x27;就是表示结束</span><br><span class="line">    String admin_name = scanner.nextLine(); // 老师说明，如果希望看到SQL注入，这里需要用nextLine</span><br><span class="line">    System.out.print(&quot;请输入管理员的密码: &quot;);</span><br><span class="line">    String admin_pwd = scanner.nextLine();</span><br><span class="line"></span><br><span class="line">    //通过Properties对象获取配置文件的信息</span><br><span class="line"></span><br><span class="line">    Properties properties = new Properties();</span><br><span class="line">    properties.load(new FileInputStream(&quot;src\\mysql.properties&quot;));</span><br><span class="line">    //获取相关的值</span><br><span class="line">    String user = properties.getProperty(&quot;user&quot;);</span><br><span class="line">    String password = properties.getProperty(&quot;password&quot;);</span><br><span class="line">    String driver = properties.getProperty(&quot;driver&quot;);</span><br><span class="line">    String url = properties.getProperty(&quot;url&quot;);</span><br><span class="line"></span><br><span class="line">    //1. 注册驱动</span><br><span class="line">    Class.forName(driver);//建议写上</span><br><span class="line"></span><br><span class="line">    //2. 得到连接</span><br><span class="line">    Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">    //3. 得到PreparedStatement</span><br><span class="line">    //3.1 组织SqL , Sql 语句的 ? 就相当于占位符</span><br><span class="line">    String sql = &quot;select name , pwd  from admin where name =? and pwd = ?&quot;;</span><br><span class="line">    //3.2 preparedStatement 对象实现了 PreparedStatement 接口的实现类的对象</span><br><span class="line">    PreparedStatement preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">    //3.3 给 ? 赋值</span><br><span class="line">    preparedStatement.setString(1, admin_name);</span><br><span class="line">    preparedStatement.setString(2, admin_pwd);</span><br><span class="line"></span><br><span class="line">    //4. 执行 select 语句使用  executeQuery</span><br><span class="line">    //   如果执行的是 dml(update, insert ,delete) executeUpdate()</span><br><span class="line">    //   这里执行 executeQuery ,不要在写 sql</span><br><span class="line"></span><br><span class="line">    ResultSet resultSet = preparedStatement.executeQuery(sql);</span><br><span class="line">    if (resultSet.next()) &#123; //如果查询到一条记录，则说明该管理存在</span><br><span class="line">        System.out.println(&quot;恭喜， 登录成功&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        System.out.println(&quot;对不起，登录失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //关闭连接</span><br><span class="line">    resultSet.close();</span><br><span class="line">    preparedStatement.close();</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//3. 得到PreparedStatement</span><br><span class="line">        //3.1 组织SqL , Sql 语句的 ? 就相当于占位符</span><br><span class="line">        String sql = &quot;select name , pwd  from admin where name =? and pwd = ?&quot;;</span><br><span class="line">        //3.2 preparedStatement 对象实现了 PreparedStatement 接口的实现类的对象</span><br><span class="line">        PreparedStatement preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">        //3.3 给 ? 赋值</span><br><span class="line">        preparedStatement.setString(1, admin_name);</span><br><span class="line">        preparedStatement.setString(2, admin_pwd);</span><br><span class="line">        </span><br><span class="line"> //4. 执行 select 语句使用  executeQuery</span><br><span class="line">        //   如果执行的是 dml(update, insert ,delete) executeUpdate()</span><br><span class="line">        //   这里执行 executeQuery ,不要在写 sql</span><br><span class="line">        ResultSet resultSet = preparedStatement.executeQuery(sql);</span><br><span class="line">        if (resultSet.next()) &#123; //如果查询到一条记录，则说明该管理存在</span><br><span class="line">            System.out.println(&quot;恭喜， 登录成功&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;对不起，登录失败&quot;);</span><br><span class="line">        &#125;        </span><br></pre></td></tr></table></figure><blockquote><p>注意，执行的时候不要再带参数了，不然就是执行模板了</p></blockquote><p>相关的类及方法：</p><table><thead><tr><th>类 &#x2F; 接口</th><th>方法</th></tr></thead><tbody><tr><td>DriverManager 驱动管理类</td><td>getConnection(url, user, pwd) 获取连接</td></tr><tr><td></td><td>createStatement() 创建 Statement 对象</td></tr><tr><td></td><td>preparedStatement(sql) 生成预处理 PreparedStatement 对象</td></tr><tr><td>Statement 接口</td><td>executeUpdate(sql) 执行 dml 语句，返回影响行数</td></tr><tr><td></td><td>executeQuery(sql) 执行查询语句，返回 ResultSet</td></tr><tr><td></td><td>execute(sql) 执行任意 SQL 语句，返回布尔值</td></tr><tr><td>PreparedStatement 接口</td><td>executeUpdate() 执行 dml 语句，返回影响行数</td></tr><tr><td></td><td>executeQuery() 执行查询语句，返回 ResultSet</td></tr><tr><td></td><td>execute() 执行任意 SQL 语句，返回布尔值</td></tr><tr><td></td><td>setXXX(int, xxx) 设置 SQL 语句中占位符的值</td></tr><tr><td></td><td>setObject(int, xxx) 设置 SQL 语句中占位符的值</td></tr><tr><td>ResultSet 结果集</td><td>next() 向下移动一行。没有下一行的场合返回 false</td></tr><tr><td></td><td>previous() 向上移动一行。没有上一行的场合返回 false</td></tr><tr><td></td><td>getXXX(int)、getXXX(name) 返回 int 列 &#x2F; name 列的值</td></tr><tr><td></td><td>getObject(int)、getObject(name) 返回 int 列 &#x2F; name 列的值</td></tr></tbody></table><h2 id="JDBC-API"><a href="#JDBC-API" class="headerlink" title="JDBC API"></a>JDBC API</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310151613022.png"></p><h2 id="JDBCUtils"><a href="#JDBCUtils" class="headerlink" title="JDBCUtils"></a>JDBCUtils</h2><p>JDBCUtils：JDBC 的工具类</p><p>实际操作中，获取连接 和 释放资源 操作经常使用。可以把这些操作封装成工具类 JDBCUtils</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310151637985.png"></p><h1 id="事务和批处理"><a href="#事务和批处理" class="headerlink" title="事务和批处理"></a>事务和批处理</h1><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务：JDBC 程序中，当一个 <code>Connection</code> 对象创建时，默认情况下会自动提交事务。为了让多个 SQL 语句一体执行，需要使用事务。</p><ol><li>JDBC程序中当一个Connection对象创建时，默认情况下是自动提交事务:每次执行一个SQL语句时，如果执行成功，就会向数据库自动提交，而不能回滚。</li><li>JDBC程序中为了让多个SQL语句作为一个整体执行，需要使用事务</li><li>调用 Connection 的 setAutoCommit ( false ) 可以取消自动提交事务</li><li>在所有的SQL语句都成功执行后，调用 Connection 的 commit() 方法提交事务</li><li>在其中某个操作失败或出现异常时，调用 rollback() 方法回滚事务</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Connection connection = null;</span><br><span class="line">try &#123;</span><br><span class="line">    connection = JDBCUtils.getConnection();</span><br><span class="line">    connection.setAutoCommit(false);//[1] 取消自动提交事务</span><br><span class="line">    String sql = &quot;insert into actor values(9, &#x27;赫尔萝茵&#x27;)&quot;;</span><br><span class="line">    PreparedStatement preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">    preparedStatement.executeUpdate();</span><br><span class="line">    sql = &quot;delete from actor where name = &#x27;萝茵&#x27; and id &gt; (select * from (select min(id) from actor where name = &#x27;萝茵&#x27;) a)&quot;;</span><br><span class="line">    //[2]</span><br><span class="line">    preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">    preparedStatement.executeUpdate();</span><br><span class="line">    connection.commit();//[3] 提交事务</span><br><span class="line">    System.out.println(&quot;complete&quot;);</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">    System.out.println(&quot;fail&quot;);</span><br><span class="line">    System.out.println(e);</span><br><span class="line">    connection.rollback();//[4] 回滚事务</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    connection.close();//[5] 关闭连接</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>取消自动提交事务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection.setAutoCommit(false);</span><br></pre></td></tr></table></figure></li><li><p>这是一个 SQL 语句。表示在 name &#x3D; 萝茵 的数据中只保留 id 最小的一条。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete from actor where name = &#x27;萝茵&#x27; and id &gt; (select * from (select min(id) from actor where name = &#x27;萝茵&#x27;) a)</span><br><span class="line">MYSQL</span><br></pre></td></tr></table></figure><p>正常写法会提示不能同表查询（在 MySQL 中，不能在同一语句中先 select 出同一表中的某些值，再 update 这个表）。使用一个额外的 select 过渡就解决了这个问题。特此记录。</p></li><li><p>提交事务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connection.commit();</span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure></li><li><p>回滚事务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connection.rollback();</span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure><p>写在 catch 里。这样，语句错误抛出异常的场合会执行到这句话。</p></li><li><p>关闭连接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connection.close();</span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure><p>写在 finally 里。这样，执行完语句总会关闭连接。这很好。</p></li></ol><h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><p>批处理：把多条语句一次性提交给数据库进行批量处理。这样做比单独提交更有效率。</p><p>基本介绍：</p><ol><li><p>当需要成批插入或者更新记录时。可以采用Java的批量更新机制，这一机制允</p></li><li><p>许多条语句次性提交给数据库批量处理。通常情况下比单独提交处理更有效率。</p></li><li><p>JDBC的批量处理语句包括下面方法:</p><p>addBatch(:添加需要批量处理的SQL语句或参数</p><p>executeBatch(:执行批量处理语句;</p><p>clearBatch():清空批处理包的语句</p></li><li><p>JDBC连接MySQL时，如果要使用批处理功能，请再url中加参数?rewriteBatchedStatements&#x3D; true</p></li><li><p>批处理往往和PreparedStatement-起搭配使用，可以既减少编译次数，又减少运行次数，效率大大提高</p></li></ol> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//[0] 事前准备</span><br><span class="line">Connection connection = JDBCUtils.getConnection();</span><br><span class="line">String sql = &quot;insert into test1 values(?)&quot;;</span><br><span class="line">PreparedStatement ps = connection.prepareStatement(sql);</span><br><span class="line">for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">ps.setInt(1,i);</span><br><span class="line">ps.addBatch();//[1]</span><br><span class="line">&#125;</span><br><span class="line">ps.executeBatch();//[2]</span><br><span class="line">JDBCUtils.close(connection, ps, null);JAVA</span><br></pre></td></tr></table></figure><ol><li><p>修改配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true</span><br><span class="line">...PROPERTIES</span><br></pre></td></tr></table></figure></li><li><p>添加需要批量处理的 SQL 语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">preparedStatement.addBatch();</span><br></pre></td></tr></table></figure></li><li><p>执行批量处理语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">preparedStatement.executeBatch();</span><br></pre></td></tr></table></figure></li><li><p>（前面的例子里没有这句）清空批处理包的语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">preparedStatement.clearBatch();</span><br></pre></td></tr></table></figure></li></ol><h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h1><p><strong>传统获取 Connection 方法的问题：</strong></p><ol><li>传统的 JDBC 数据库连接使用 DriverManager 获取，每次建立连接都会把 Connection 载入内存，再进行身份验证。每次连接都会重复验证请求，这样会占用过多系统资源，容易造成服务器崩溃。</li><li>每次连接，使用完毕后必须断开。如果不断开操作，会致使数据库内存泄漏，最终不得不重启数据库。</li><li>传统连接方式不能控制创建的连接数量。连接数量过多的场合，也可能导致内存泄漏，MySQL 崩溃</li></ol><p><strong>因此，需要使用连接池技术</strong></p><p>连接池基本介绍：</p><ol><li>预先在缓冲池放入一定数量的连接。需要建立数据库连接时，从缓冲池中取出一个连接。使用完后，把该连接放回缓冲池。</li><li>数据库连接池负责分配、管理和释放数据库连接。其允许应用程序重复使用一个现有的数据库连接，而非建立新的连接。</li><li>当请求连接的数量超过最大数量，这些连接请求会被加入等待队列。</li></ol><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310151731041.png"></p><p><strong>数据库连接池种类：</strong></p><p>JDBC 数据库连接池使用 javax.sql.DataSource 表示。DataSource 是一个接口，通常由第三方提供实现（提供 jar 包）</p><ul><li>C3P0：速度稍慢，稳定性好，但是速度再慢也不是传统 JDBC 能比得上的</li><li>DBCP：速度稍快，稳定性差</li><li>Proxool：可以监控连接池状态，稳定性稍差</li><li>BoneCP：速度快</li><li>Druid：阿里提供的数据库连接池，集 DBCP、C3P0、Proxool 优点于一身</li></ul><p>数据库连接池只是做了个包装，底层还是需要使用到 driver 驱动</p><h2 id="德鲁伊使用"><a href="#德鲁伊使用" class="headerlink" title="德鲁伊使用"></a>德鲁伊使用</h2><p><strong>使用 Druid 的前置工作：</strong></p><ol><li><p><a href="https://github.com/alibaba/druid">Druid jar 包下载</a></p><p>……这个链接打不开的话，试试 <a href="https://repo1.maven.org/maven2/com/alibaba/druid/">这个</a></p></li><li><p>配置 jar 包</p></li><li><p>加入配置文件</p><p><strong>durid.properties：</strong>配置文件，文件名任意，放在 <code>src/druid.properties</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">driverClassName=com.mysql.cj.jdbc.Driver</span><br><span class="line">url=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true</span><br><span class="line">username=root</span><br><span class="line">password=123456</span><br><span class="line">initialSize=10</span><br><span class="line">minIdle=5</span><br><span class="line">maxActive=20</span><br><span class="line">maxWait=5000</span><br></pre></td></tr></table></figure><p>minIdle：最小空闲数，一直没有人用的时候至少维持这么多个链接<br>maxActive：最大活跃数，使用链接的上限<br>maxWait：最大等待时间，超过这个时间认为繁忙，放弃这次链接，换下一个</p></li></ol><p>使用 Druid：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* [1] 加载配置文件 */</span><br><span class="line">Properties properties = new Properties();</span><br><span class="line">properties.load(new FileInputStream(&quot;src\\Druid.properties&quot;));</span><br><span class="line">/* [2] 初始化数据池 */</span><br><span class="line">DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">/* [3] 获取连接 */</span><br><span class="line">Connection connection = dataSource.getConnection();</span><br><span class="line">...</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure><ol><li><p>初始化数据池</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);</span><br></pre></td></tr></table></figure></li><li><p>初始化数据池：需要讲一下关闭链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection.close();</span><br></pre></td></tr></table></figure><p><code>Connection</code> 是一个接口，对于方法 <code>close()</code>，不同供应商有不同实现方法。</p><p>原生的 <code>MySQL</code> 的实现方法是关闭连接，而这些连接池的实现方法是取消引用（放回连接池）。</p></li></ol><h2 id="DruidUtils"><a href="#DruidUtils" class="headerlink" title="DruidUtils"></a>DruidUtils</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class JDBCUtilsByDruid &#123;</span><br><span class="line">    private static DataSource ds;</span><br><span class="line">    </span><br><span class="line">    //在静态代码块完成 ds初始化</span><br><span class="line">    static &#123;</span><br><span class="line">        Properties properties = new Properties();</span><br><span class="line">        try &#123;</span><br><span class="line">            properties.load(new FileInputStream(&quot;src\\druid.properties&quot;));</span><br><span class="line">            ds = DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //编写getConnection方法</span><br><span class="line">    public static Connection getConnection() throws SQLException &#123;</span><br><span class="line">        return ds.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //关闭连接, 老师再次强调： 在数据库连接池技术中，close 不是真的断掉连接</span><br><span class="line">    //而是把使用的Connection对象放回连接池</span><br><span class="line">    public static void close(ResultSet resultSet, Statement statement, Connection connection) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (resultSet != null) &#123;</span><br><span class="line">                resultSet.close();</span><br><span class="line">            &#125;</span><br><span class="line">            if (statement != null) &#123;</span><br><span class="line">                statement.close();</span><br><span class="line">            &#125;</span><br><span class="line">            if (connection != null) &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Apache-DbUtils"><a href="#Apache-DbUtils" class="headerlink" title="Apache - DbUtils"></a>Apache - DbUtils</h1><p>JDBC 传统方法的不足：</p><ol><li>结果集和连接是关联的。在连接关闭后，就不能使用结果集。</li><li>结果集只能使用一次，这样不便于数据管理</li><li>使用返回信息不方便</li></ol><p>解决思想：</p><ul><li><p>土方法：创建一个类，其属性与表格的列一一对应。将数据遍历并读取到一个个类对象中，再将这些类对象放置到集合中。这样，就得到了一个与表格数据关联的数据集合。</p></li><li><p>使用 <code>DbUtils</code>：</p><ol><li><p>前置操作：</p><p><a href="https://commons.apache.org/proper/commons-dbutils/download_dbutils.cgi">获取 jar 包</a>，并完成配置</p><p>得到连接 <code>Connection connection</code>，创建数据类（这里是 <code>SQL_Data</code>）</p></li><li><p>执行相关方法，返回结果集</p><ol><li><ul><li><p><code>queryRunner.query</code> 方法：执行 SQL 语句，把得到的 <code>ResultSet</code> 封装到 List 集合。这个方法会自动关闭获得的 <code>ResultSet</code>，所以不会造成资源泄漏</p></li><li><p><code>connection</code>：前置操作中得到的连接</p></li><li><p><code>sql</code>：SQL 语句</p></li><li><p><code>new BeanListHander&lt;&gt;(SQL_Data.class)</code>：利用反射机制，将数据封装到 <code>SQL_Data</code> 对象中</p></li><li><p><code>&quot;id&quot;, 1</code>：给 SQL 语句中的 <code>?</code> 赋值。因为是可变参数，可以写多个，如：<code>queryRunner.query(connection, sql, new BeanListHandler&lt;&gt;(SQL_Data.class), &quot;id&quot;, 1, &quot;name&quot;, &quot;识之律者&quot;);</code></p><p>……这里，可变参数也包含列名的场合，筛选似乎会失效。还不知道原理。特此记录。</p></li></ul></li><li><p>此时只需要关闭 <code>Connection</code></p><p><code>query()</code> 方法已经关闭了 <code>ResultSet</code> 和 <code>PreparedStatement</code></p></li></ol></li></ol></li></ul><p><code>commons-DbUtils</code>：是 Apache 组织提供的一个开源的 JDBC 工具库。它是对 JDBC 的封装。使用 dbutils 能极大简化 JDBC 编码的工作量</p><p><strong>DbUtils 的常用类：</strong></p><ul><li><code>QueryRunner</code> 类：封装了 SQL 的执行。是线程安全的，可以实现增、删、改、查、批处理操作</li><li><code>ResultSetHandler</code> 接口：用于处理 <code>ResultSet</code>，按照需求将数据转化为其他形式</li></ul><p><strong>DbUtils 的常用方法：</strong></p><ul><li>ArrayHandler：把结果集中的第一行数据转成对象数组。</li><li>ArrayListHandler：把结果集中的每一-行数据都转成一 个数组，再存放到List中。</li><li>BeanHandler：将结果集中的第一-行数据封装到- 个对应的JavaBean实例中。</li><li>BeanListHandler：将结果集中的每一行数据都封装到一 个对应的JavaBean实例中，存放到List里。</li><li>ColumnListHandler：将结果集中某一列的数据存放到List中。</li><li>KeyedHandler(name)：将结果集中的每行数据都封装到Map里，再把这些map再存到一个map里，其key为指定的key。</li><li>MapHandler：将结果集中的第一行数据封装到一 个Map里，key是列名， value就是对应的值。</li><li>MapListHandler：将结果集中的每一-行数据都封装到一 个Map里，然后再存放到List</li></ul><h2 id="Apache-DbUtils-常用方法"><a href="#Apache-DbUtils-常用方法" class="headerlink" title="Apache-DbUtils 常用方法"></a>Apache-DbUtils 常用方法</h2><ul><li><p><code>queryRunner.update(connection, sql, ...)</code>：DML 语句。增删改。</p><p>后面传入可变参数，用于给 SQL 语句中的 <code>?</code> 赋值</p><p>返回值 int 代表被影响的行数。</p></li><li><p><code>queryRunner.query(connection, sql, ResultSetHandler, ...)</code>：查询。</p><p>后面传入可变参数，用于给 SQL 语句中的 <code>?</code> 赋值</p><p>关于 <code>ResultSetHandler</code>：</p><ul><li>传入 <code>new BeanListHander&lt;&gt;(SQL_Data.class)</code>：返回多行多列。这个场合，用 <code>List</code> 接收返回值。</li><li>传入 <code>new BeanHandler&lt;&gt;(SQL_Data.class)</code>：返回单行。这个场合，用 <code>SQL_Data data</code> 接收返回值。</li><li>传入 <code>new ScalarHander&lt;&gt;()</code>：返回单行单列。这个场合，用 <code>Object</code> 接收返回值。</li></ul></li></ul><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310151935013.png"></p><h2 id="表和-JavaBean-的对应关系"><a href="#表和-JavaBean-的对应关系" class="headerlink" title="表和 JavaBean 的对应关系"></a>表和 JavaBean 的对应关系</h2><table><thead><tr><th>表类型</th><th>JavaBean类型</th></tr></thead><tbody><tr><td>int、samllint……</td><td>Integer</td></tr><tr><td>char、varchar……</td><td>String</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>date</td><td>java.util.Date</td></tr></tbody></table><h1 id="BasicDao"><a href="#BasicDao" class="headerlink" title="BasicDao"></a>BasicDao</h1><p>apache- dbutils + Druid简化了JDBC开发，但还有不足:</p><ol><li>SQL语句是固定，不能通过参数传入，通用性不好，需要进行改进，更方便执行增删改查</li><li>对于select操作，如果有返回值，返回类型不能固定，<br> 需要使用泛型</li><li>将来的表很多，业务需求复杂，不可能只靠一个Java类完成</li></ol><p>将这些表的公共部分抽出，集成为BasicDao</p><p>DAO：数据访问对象（data access object）</p><ol><li><p>我们把通用的和数据库交互的操作封装到一个通用类中，称为 BasicDAO。</p></li><li><p>在 BasicDAO 基础上，每张表对应一个特化的 DAO（继承 BasicDAO），从而更好地完成功能。</p><p>比如：Data 表 -&gt; Data.java 类（JavaBean）-&gt; DataDAO.java</p></li></ol><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310152122800.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDBC </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-泛型</title>
      <link href="/2023/06/12/Java%E6%B3%9B%E5%9E%8B/"/>
      <url>/2023/06/12/Java%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="泛型引入"><a href="#泛型引入" class="headerlink" title="泛型引入"></a>泛型引入</h2><p>泛型（generic）：又称 参数化类型。是JDK 5 出现的新特性。解决数据类型的安全性问题。在类声明或实例化时只要制定好需要的具体类型即可。</p><p>例1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Properties&lt;Person&gt; prop = <span class="keyword">new</span> <span class="title class_">Properties</span>&lt;Person&gt;();</span><br></pre></td></tr></table></figure><ul><li>上例表示存放到 <code>prop</code> 中的必须是 <code>Person</code> 类型。如果编译器发现添加类型不符合要求，即报错。</li><li>遍历时，直接取出 <code>Person</code> 而非 <code>Object</code></li></ul><p>例2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.base;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">chapter15</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        arrayList.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;旺财&quot;</span>, <span class="number">10</span>));</span><br><span class="line">        arrayList.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;发财&quot;</span>, <span class="number">1</span>));</span><br><span class="line">        arrayList.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;小黄&quot;</span>, <span class="number">5</span>));</span><br><span class="line"><span class="comment">//假如我们的程序员，不小心，添加了一只猫</span></span><br><span class="line">        arrayList.add(<span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;招财猫&quot;</span>, <span class="number">8</span>));</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Object o : arrayList) &#123;</span><br><span class="line"><span class="comment">//向下转型 Object -&gt;Dog</span></span><br><span class="line">            <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) o;</span><br><span class="line">            System.out.println(dog.getName() + <span class="string">&quot;-&quot;</span> + dog.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> &#123; <span class="comment">//Cat 类</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309160944609.png"></p><p>使用传统方法的问题分析</p><ol><li>不能对加入到集合ArrayList中的数据类型进行约束(猫猫狗狗都能加，不加以约束，但是用的时候就有要求了，不安全)</li><li>遍历的时候，需要进行类型转换，如果集合中的数据量较大，对效率有影响（虽然放的就是dog类对象但是就是要用object接受，语法不支持）</li></ol><p>使用泛型好处</p><ol><li>编译时，检查添加元素的类型。可以保证如果编译时没发出警告，运行就不会产生ClassCastException 异常。提高了安全性，使代码更加简洁、健壮。</li><li>也减少了转换的次数，遍历的时候直接取出对象，不用向下转型，提高了效率。</li><li>泛型的作用是：可以在类声明是通过一个标识表示类中某个属性的类型，或某个方法返回值的类型，或参数类型。</li></ol><p>例3：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Javabase.chapter;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">improve</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//使用传统的方法来解决===&gt; 使用泛型</span></span><br><span class="line"><span class="comment">//老韩解读</span></span><br><span class="line"><span class="comment">//1. 当我们 ArrayList&lt;Dog&gt; 表示存放到 ArrayList 集合中的元素是 Dog 类型 (细节后面说...)</span></span><br><span class="line"><span class="comment">//2. 如果编译器发现添加的类型，不满足要求，就会报错</span></span><br><span class="line"><span class="comment">//3. 在遍历的时候，可以直接取出 Dog 类型而不是 Object</span></span><br><span class="line"><span class="comment">//4. public class ArrayList&lt;E&gt; &#123;&#125; E 称为泛型,那么 Dog-&gt;E</span></span><br><span class="line">        ArrayList&lt;Dog&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Dog&gt;();</span><br><span class="line">        arrayList.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;旺财&quot;</span>, <span class="number">10</span>));</span><br><span class="line">        arrayList.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;发财&quot;</span>, <span class="number">1</span>));</span><br><span class="line">        arrayList.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;小黄&quot;</span>, <span class="number">5</span>));</span><br><span class="line"><span class="comment">//假如我们的程序员，不小心，添加了一只猫</span></span><br><span class="line">        <span class="comment">//arrayList.add(new Cat(&quot;招财猫&quot;, 8));</span></span><br><span class="line">        System.out.println(<span class="string">&quot;===使用泛型====&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Dog dog : arrayList) &#123;</span><br><span class="line">            System.out.println(dog.getName() + <span class="string">&quot;-&quot;</span> + dog.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> &#123; <span class="comment">//Cat 类</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>类型不对，直接报错</p></blockquote><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309160947413.png"></p><h2 id="泛型介绍"><a href="#泛型介绍" class="headerlink" title="泛型介绍"></a>泛型介绍</h2><p>泛型(广泛类型) </p><ol><li>泛型又称参数化类型，是Jdk5.0 出现的新特性，解决数据类型的安全性问题</li><li>泛型只能应用于 <strong>引用类型</strong>，int等基本类型要换为Integer等<strong>包装类</strong>（ Integer, String,Dog）</li><li>在类声明或实例化时只要指定好需要的具体的类型即可。</li><li>Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。 同时，代码更加简洁、健壮</li></ol><p><strong>泛型的作用</strong>：可以在类声明时通过一个标识表示类中某个属性的类型，或者是某个方法的返回值的类型，或者是参数类型。 </p><blockquote><p>泛型可以理解为表示数据类型的数据类型。&lt;&gt;中是什么类型，运行就是什么类型</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class P&lt;E&gt; &#123;            //实例化时指定 E 的类型，编译时上例所有 E 会被编译器替换为那个指定类型</span><br><span class="line">E e;//E 表示 e 的数据类型，在定义P类对象时指定。即在编译期间确认类型</span><br><span class="line">public P(E e)&#123;//可作为参数类型</span><br><span class="line">this.e = e;</span><br><span class="line">&#125;</span><br><span class="line">public E f()&#123;    //可作为返回类型</span><br><span class="line">return this.e;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//例</span><br><span class="line">Person&lt;String&gt; person = new Person&lt;String&gt;(&quot;String&quot;);//String</span><br><span class="line">/*</span><br><span class="line">    你可以这样理解，上面的Person类</span><br><span class="line">    class Person &#123;</span><br><span class="line">        String s ;//E表示 s的数据类型, 该数据类型在定义Person对象的时候指定,即在编译期间，就确定E是什么类型</span><br><span class="line">        public Person(String s) &#123;//E也可以是参数类型</span><br><span class="line">            this.s = s;</span><br><span class="line">        &#125;</span><br><span class="line">        public String f() &#123;//返回类型使用E</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">Person&lt;Integer&gt; person2 = new Person&lt;Integer&gt;(100);//Integer</span><br><span class="line">/*</span><br><span class="line">    class Person &#123;</span><br><span class="line">        Integer s ;//E表示 s的数据类型, 该数据类型在定义Person对象的时候指定,即在编译期间，就确定E是什么类型</span><br><span class="line"></span><br><span class="line">        public Person(Integer s) &#123;//E也可以是参数类型</span><br><span class="line">            this.s = s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Integer f() &#123;//返回类型使用E</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309161012445.png"></p><h2 id="泛型语法"><a href="#泛型语法" class="headerlink" title="泛型语法"></a>泛型语法</h2><h3 id="泛型的声明"><a href="#泛型的声明" class="headerlink" title="泛型的声明"></a>泛型的声明</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">interface 接口 &lt;T&gt;&#123;&#125;</span><br><span class="line">class 类 &lt;K,V&gt;&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>KTV不代表值，而是表示类型。任意字母都可以。常用T表示，是Type的缩写</p></blockquote><h3 id="实例化泛型"><a href="#实例化泛型" class="headerlink" title="实例化泛型"></a>实例化泛型</h3><p>类名后面指定类型参数的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strList = new ArrayList&lt;String&gt;();</span><br><span class="line">Iterator&lt;Integer&gt; iterator = vector.interator&lt;Integer&gt;();</span><br></pre></td></tr></table></figure><p><strong>注意细节：</strong></p><ol><li><p>泛型只能是引用类型，基本类型要用他们的包装类</p></li><li><p>指定泛型具体类型后，可以传入该类型或其子类类型（向上转型和向下转型）</p></li><li><p>在实际开发中往往简写泛型，前面写了，后面可以不用写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strList = new ArrayList&lt;&gt;();//前面写了，后面可以不用写</span><br></pre></td></tr></table></figure></li><li><p>实例化不写泛型的场合，相当于默认泛型为 Object（所有类型的总父类），好像没用泛型，但还是用了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list = new ArrayList();</span><br><span class="line">//等价于</span><br><span class="line">ArrayList&lt;&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">//等价于</span><br><span class="line">ArrayList&lt;Object&gt; list = new ArrayList&lt;Object&gt;();</span><br></pre></td></tr></table></figure><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309161053877.png"></p></li></ol><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>例题1</p><ol><li>创建3个学生对象</li><li>放入到HashSet中学生对象</li></ol><p>源码中，集合列表中都有使用泛型，所以在外面定义泛型的时候，就已经定义好了所有相同泛型字母所代表的内容了，所以使用集合的时候自动匹配相应的类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">//学生类</span><br><span class="line">class student&#123;</span><br><span class="line">    public String name;</span><br><span class="line">    public int age;</span><br><span class="line"></span><br><span class="line">    public student(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;student&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class GenericExercise &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //使用泛型方式给HashSet 放入3个学生对象</span><br><span class="line">        HashSet&lt;Student&gt; students = new HashSet&lt;Student&gt;();</span><br><span class="line">        students.add(new Student(&quot;jack&quot;, 18));</span><br><span class="line">        students.add(new Student(&quot;tom&quot;, 28));</span><br><span class="line">        students.add(new Student(&quot;mary&quot;, 19));</span><br><span class="line"></span><br><span class="line">        //遍历</span><br><span class="line">        for (Student student : students) &#123;</span><br><span class="line">            System.out.println(student);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //使用泛型方式给HashMap 放入3个学生对象</span><br><span class="line">        //K -&gt; String V-&gt;Student</span><br><span class="line">        HashMap&lt;String, Student&gt; hm = new HashMap&lt;String, Student&gt;();</span><br><span class="line">        /*</span><br><span class="line">            public class HashMap&lt;K,V&gt;  &#123;&#125;</span><br><span class="line">         */</span><br><span class="line">        hm.put(&quot;milan&quot;, new Student(&quot;milan&quot;, 38));</span><br><span class="line">        hm.put(&quot;smith&quot;, new Student(&quot;smith&quot;, 48));</span><br><span class="line">        hm.put(&quot;hsp&quot;, new Student(&quot;hsp&quot;, 28));</span><br><span class="line">        </span><br><span class="line">        /*源码</span><br><span class="line">        public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">            Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">            return (es = entrySet) == null ? (entrySet = new EntrySet()) : es;</span><br><span class="line">        &#125;</span><br><span class="line">         */</span><br><span class="line">        Set&lt;Map.Entry&lt;String, Student&gt;&gt; entries = hm.entrySet();</span><br><span class="line">        /*源码</span><br><span class="line">            public final Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">                return new EntryIterator();</span><br><span class="line">            &#125;</span><br><span class="line">         */</span><br><span class="line">        Iterator&lt;Map.Entry&lt;String, Student&gt;&gt; iterator = entries.iterator();</span><br><span class="line">        System.out.println(&quot;==============================&quot;);</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;String, Student&gt; next =  iterator.next();</span><br><span class="line">            System.out.println(next.getKey() + &quot;-&quot; + next.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例题2</p><ul><li>定义Employee类<ol><li>该类包含: private成员变量name，sal，birthday，其中birthday为MyDate类的对象;</li><li>为每一个属性定义getter，setter方法;</li><li>重写 toString 方法输出name，sal，birthday</li><li>MyDate类包含: private成员变量month，day，year；并为每一 个属性定义getter，setter方法</li><li>创建该类的3个对象，并把这些对象放入ArrayList集合中（ArrayList 需使用泛型来定义）对集合中的元素进行排序，井遍历输出:</li></ol></li><li>排序方式：调用ArrayList 的sort方法，传入Comparator对象[使用泛型]，先按照name排序，如果name相同，则按生日日期的先后排序。</li></ul><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">Employee</button></li><li class="tab"><button type="button" data-href="#test1-2">MyDate</button></li><li class="tab"><button type="button" data-href="#test1-3">GenericExercise02</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Employee &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private double sal;</span><br><span class="line">    private MyDate birthday;</span><br><span class="line">    public Employee(String name, double sal, MyDate birthday) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.sal = sal;</span><br><span class="line">        this.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public double getSal() &#123;</span><br><span class="line">        return sal;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setSal(double sal) &#123;</span><br><span class="line">        this.sal = sal;</span><br><span class="line">    &#125;</span><br><span class="line">    public MyDate getBirthday() &#123;</span><br><span class="line">        return birthday;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setBirthday(MyDate birthday) &#123;</span><br><span class="line">        this.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;\nEmployee&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, sal=&quot; + sal +</span><br><span class="line">                &quot;, birthday=&quot; + birthday +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public class MyDate implements Comparable&lt;MyDate&gt;&#123;</span><br><span class="line">    private int year;</span><br><span class="line">    private int month;</span><br><span class="line">    private int day;</span><br><span class="line">    public MyDate(int year, int month, int day) &#123;</span><br><span class="line">        this.year = year;</span><br><span class="line">        this.month = month;</span><br><span class="line">        this.day = day;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getYear() &#123;</span><br><span class="line">        return year;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setYear(int year) &#123;</span><br><span class="line">        this.year = year;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getMonth() &#123;</span><br><span class="line">        return month;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setMonth(int month) &#123;</span><br><span class="line">        this.month = month;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getDay() &#123;</span><br><span class="line">        return day;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setDay(int day) &#123;</span><br><span class="line">        this.day = day;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;MyDate&#123;&quot; +</span><br><span class="line">                &quot;year=&quot; + year +</span><br><span class="line">                &quot;, month=&quot; + month +</span><br><span class="line">                &quot;, day=&quot; + day +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    //把对year-month-day比较放在这里</span><br><span class="line">    public int compareTo(MyDate o) &#123; </span><br><span class="line">        int yearMinus = year - o.getYear();</span><br><span class="line">        if(yearMinus != 0) &#123;</span><br><span class="line">            return  yearMinus;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //如果year相同，就比较month</span><br><span class="line">        int monthMinus = month - o.getMonth();</span><br><span class="line">        if(monthMinus != 0) &#123;</span><br><span class="line">            return monthMinus;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //如果year 和 month</span><br><span class="line">        return day - o.getDay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class GenericExercise02 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;Employee&gt; employees = new ArrayList&lt;&gt;();</span><br><span class="line">        employees.add(new Employee(&quot;tom&quot;, 20000, new MyDate(1980,12,11)));</span><br><span class="line">        employees.add(new Employee(&quot;jack&quot;, 12000, new MyDate(2001,12,12)));</span><br><span class="line">        employees.add(new Employee(&quot;tom&quot;, 50000, new MyDate(1980,12,10)));</span><br><span class="line">        System.out.println(&quot;employees=&quot; + employees);</span><br><span class="line">        employees.sort(new Comparator&lt;Employee&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Employee emp1, Employee emp2) &#123;</span><br><span class="line">            </span><br><span class="line">                //先按照name排序，如果name相同，则按生日日期的先后排序</span><br><span class="line">                //先对传入的参数进行验证</span><br><span class="line">                if(!(emp1 instanceof  Employee &amp;&amp; emp2 instanceof Employee)) &#123;</span><br><span class="line">                    System.out.println(&quot;类型不正确..&quot;);</span><br><span class="line">                    return 0;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                //比较name</span><br><span class="line">                int i = emp1.getName().compareTo(emp2.getName());</span><br><span class="line">                if(i != 0) &#123;</span><br><span class="line">                    return i;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                //下面是对birthday的比较，因此，我们最好把这个比较，放在MyDate类完成</span><br><span class="line">                //封装后，将来可维护性和复用性，就大大增强.</span><br><span class="line">                return emp1.getBirthday().compareTo(emp2.getBirthday());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(&quot;==对雇员进行排序==&quot;);</span><br><span class="line">        System.out.println(employees);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="自定义泛型"><a href="#自定义泛型" class="headerlink" title="自定义泛型"></a>自定义泛型</h1><p>官方提供方泛型可以理解为自定义泛型的一种特殊实现</p><h2 id="自定义泛型类"><a href="#自定义泛型类" class="headerlink" title="自定义泛型类"></a>自定义泛型类</h2><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class 类名 &lt;T,R...&gt; &#123; 成员 &#125;  //T、R是泛型标识符，可有多个，一般是单个大写字母表示</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li><p>普通成员可以使用泛型（属性、方法可以使用定义里面的泛型）</p></li><li><p>… 表示可以有多个</p></li><li><p>泛型类的类型，是在创建对象时确定的，创建对象时需要指明类型。</p><p>静态方法中不能使用类的泛型；因为静态是和类相关的，在类加载时，对象还没有创建，所以，如果静态方法和静态属性使用了泛型，JVM 就无法完成初始化</p></li><li><p>使用泛型的数组，也不能初始化，因为数组在 new 不能确定 T 的类型，就无法在内存开空间。</p></li><li><p>创建对象时不指定的场合，默认 Object。建议还是写上 <code>&lt;Object&gt;</code></p></li></ol><p>例子：</p><div class="tabs" id="test2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test2-1">定义类</button></li><li class="tab"><button type="button" data-href="#test2-2">实例化对象</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test2-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">class Tiger&lt;T, R, M&gt; &#123;</span><br><span class="line">    String name;</span><br><span class="line">    R r; //属性使用到泛型</span><br><span class="line">    M m; //属性使用到泛型</span><br><span class="line">    T t; //属性使用到泛型</span><br><span class="line">    //因为数组在 new 不能确定 T 的类型，就无法在内存开空间，可以声明</span><br><span class="line">    T[] ts;</span><br><span class="line">    public Tiger(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public Tiger(R r, M m, T t) &#123;//构造器使用泛型</span><br><span class="line">        this.r = r;</span><br><span class="line">        this.m = m;</span><br><span class="line">        this.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">    public Tiger(String name, R r, M m, T t) &#123;//构造器使用泛型</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.r = r;</span><br><span class="line">        this.m = m;</span><br><span class="line">        this.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">    //</span><br><span class="line">// &#125;</span><br><span class="line">//方法使用泛型</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public R getR() &#123;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setR(R r) &#123;//方法使用到泛型</span><br><span class="line">        this.r = r;</span><br><span class="line">    &#125;</span><br><span class="line">    public M getM() &#123;//返回类型可以使用泛型.</span><br><span class="line">        return m;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setM(M m) &#123;</span><br><span class="line">        this.m = m;</span><br><span class="line">    &#125;</span><br><span class="line">    public T getT() &#123;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setT(T t) &#123;</span><br><span class="line">        this.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Tiger&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, r=&quot; + r +</span><br><span class="line">                &quot;, m=&quot; + m +</span><br><span class="line">                &quot;, t=&quot; + t +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//T=Double, R=String, M=Integer</span><br><span class="line">Tiger&lt;Double,String,Integer&gt; g1 = new Tiger&lt;&gt;(&quot;john&quot;);</span><br><span class="line">g1.setT(10.9); //OK</span><br><span class="line">g1.setT(&quot;yy&quot;); //错误，类型不对</span><br><span class="line">System.out.println(g);</span><br><span class="line"></span><br><span class="line">Tiger g2 = new Tiger(&quot;john~~&quot;);//OK T=Object R=Object M=Object</span><br><span class="line">g2.setT(&quot;yy&quot;); //OK ,因为 T=Object &quot;yy&quot;=String 是Object子类</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;g2=&quot; + g2);</span><br></pre></td></tr></table></figure><p>实例化对象时，T&#x3D;Double, R&#x3D;String, M&#x3D;Integer，这样 g.setT &#x3D; g.setDouble。例如对象 g1</p><p>如果不指明T R M 的类型，默认都是Object。例如对象 g2</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><ol><li>Tiger后面使用到泛型，所以我们把Tiger就称为自定义泛型类</li><li>T,R, M泛型的标识符，一般是单个大写字母</li><li>声明时这些大写字母只是占位符，实例化的时候才真正定义类型，并且是所有的相同大写字母</li><li>泛型标识符可以有多个</li><li>普通成员可以使用泛型(属性、 方法)</li><li>可以声明数组，但是数组在 new 不能确定 T 的类型，就无法在内存开空间</li><li>静态方法中不能使用类的泛型；因为静态是和类相关的，在类加载时，对象还没有创建，所以，如果静态方法和静态属性使用了泛型，JVM 就无法完成初始化</li></ol><h2 id="自定义泛型接口"><a href="#自定义泛型接口" class="headerlink" title="自定义泛型接口"></a>自定义泛型接口</h2><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">interface 接口名 &lt;T,R...&gt;&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意细节：</p><ol><li>接口中，静态成员也不能使用泛型(这个和泛型类规定一样)</li><li>泛型接口的类型，在<strong>继承接口</strong>或者<strong>实现接口</strong>时确定</li><li>没有指定类型，默认为Object</li></ol><p>案例</p><div class="tabs" id="test3"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test3-1">泛型接口</button></li><li class="tab"><button type="button" data-href="#test3-2">继承接口</button></li><li class="tab"><button type="button" data-href="#test3-3">实现接口</button></li><li class="tab"><button type="button" data-href="#test3-4">没有指定</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test3-1"><p>目前该泛型接口使用占位符还没实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface IUsb&lt;U, R&gt; &#123;</span><br><span class="line"></span><br><span class="line">    int n = 10;</span><br><span class="line"></span><br><span class="line">    //普通方法中，可以使用接口泛型</span><br><span class="line">    R get(U u);</span><br><span class="line"></span><br><span class="line">    void hi(R r);</span><br><span class="line"></span><br><span class="line">    void run(R r1, R r2, U u1, U u2);</span><br><span class="line"></span><br><span class="line">    //在jdk8 中，可以在接口中，使用默认方法, 也是可以使用泛型</span><br><span class="line">    default R method(U u) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-2"><p>AA 继承 IA</p><p>IA 是用具体类型实现了 IUsb 这个泛型接口，指定了U 为String，R为Double</p><p>可以看见 IA 里面实现的方法都自动用<strong>具体类</strong>替换了原有的<strong>大写字母</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//在继承接口 指定泛型接口的类型</span><br><span class="line">interface IA extends IUsb&lt;String, Double&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//当我们去实现IA接口时，因为IA在继承IUsu 接口时，指定了U 为String R为Double</span><br><span class="line">//在实现IUsu接口的方法时，使用String替换U, 是Double替换R</span><br><span class="line">class AA implements IA &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Double get(String s) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void hi(Double aDouble) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run(Double r1, Double r2, String u1, String u2) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-3"><p>实现接口时，直接指定泛型接口的类型，给U 指定Integer 给 R 指定了 Float</p><p>所以，当我们实现IUsb方法时，会使用Integer替换U, 使用Float替换R</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//实现接口时，直接指定泛型接口的类型</span><br><span class="line">//给U 指定Integer 给 R 指定了 Float</span><br><span class="line">//所以，当我们实现IUsb方法时，会使用Integer替换U, 使用Float替换R</span><br><span class="line">class BB implements IUsb&lt;Integer, Float&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Float get(Integer integer) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void hi(Float aFloat) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run(Float r1, Float r2, Integer u1, Integer u2) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-4"><p>没有指定类型（啥都不写），语法上是能通过的，默认为Object，可以直接写成 IUsb&lt;Object,Object&gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//没有指定类型，默认为Object</span><br><span class="line">//建议直接写成 IUsb&lt;Object,Object&gt;</span><br><span class="line">class CC implements IUsb &#123; //等价 class CC implements IUsb&lt;Object,Object&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object get(Object o) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void hi(Object o) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run(Object r1, Object r2, Object u1, Object u2) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="自定义泛型方法"><a href="#自定义泛型方法" class="headerlink" title="自定义泛型方法"></a>自定义泛型方法</h2><p>和普通方法的区别就是方法返回类型前面加了泛型修饰符</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;T&gt; 返回值 方法名（参数列表）&#123;&#125;</span><br></pre></td></tr></table></figure><p>细节：</p><ol><li><p>泛型方法，可以定义在普通类中，也可以定义在泛型类里面</p></li><li><p>当泛型方法被调用时，编译器会自动确定类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//&lt;T,R&gt; 就是泛型</span><br><span class="line">//是提供给 fly使用的</span><br><span class="line">public &lt;T, R&gt; void fly(T t, R r) &#123;//泛型方法</span><br><span class="line">    System.out.println(t.getClass());//String</span><br><span class="line">    System.out.println(r.getClass());//Integer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//当调用方法时，传入参数，编译器，就会确定类型</span><br><span class="line">//T = String</span><br><span class="line">//R = Integer(自动装箱)</span><br><span class="line">car.fly(&quot;宝马&quot;, 100);</span><br></pre></td></tr></table></figure></li><li><p>public void eat(E e) {}， 修饰符后没有&lt;TR..&gt; ，该方法不是泛型方法，而是使用了泛型</p></li><li><p>public &lt;TR..&gt; void eat() {}，这个才是泛型方法，泛型方法的<strong>大写字母</strong>建议和泛型类用的大写字母不一样，用来区分</p></li><li><p>泛型方法，可以使用类声明的泛型，也可以使用自己声明泛型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Car1&lt;T,R&gt;&#123;</span><br><span class="line">    public void hi(T t) &#123;//这里没问题，因为T我在类里面就声明了</span><br><span class="line">    &#125;</span><br><span class="line">    //泛型方法，可以使用类声明的泛型，也可以使用自己声明泛型</span><br><span class="line">    public&lt;K&gt; void hello(R r, K k) &#123;</span><br><span class="line">        System.out.println(r.getClass());//ArrayList</span><br><span class="line">        System.out.println(k.getClass());//Float</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Car2&#123;</span><br><span class="line">    public void hi(T t) &#123;//这里会报错，不知道T是什么</span><br><span class="line">    &#125;</span><br><span class="line">    //泛型方法，可以使用类声明的泛型，也可以使用自己声明泛型</span><br><span class="line">    public&lt;K,R&gt; void hello(R r, K k) &#123;//这里没问题，RK在方法里面声明</span><br><span class="line">        System.out.println(r.getClass());//ArrayList</span><br><span class="line">        System.out.println(k.getClass());//Float</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309161756763.png"></p><p>  例题来喽~</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309161800666.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package org.example;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Apple&lt;String, Integer, Double&gt; apple = new Apple&lt;&gt;();</span><br><span class="line">        apple.fly(10);//10 会被自动装箱 Integer10, 输出 Integer</span><br><span class="line">        apple.fly(new Dog());//new出来的，Dog类型</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Apple&lt;T, R, M&gt; &#123;//自定义泛型类</span><br><span class="line">    public &lt;E&gt; void fly(E e) &#123; //泛型方法</span><br><span class="line">        System.out.println(e.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    //public void eat(U u) &#123;&#125;//错误，因为 U 没有声明</span><br><span class="line">    public void run(M m) &#123;</span><br><span class="line">    &#125; //ok</span><br><span class="line">&#125;</span><br><span class="line">class Dog &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="泛型继承和通配符"><a href="#泛型继承和通配符" class="headerlink" title="泛型继承和通配符"></a>泛型继承和通配符</h1><ol><li><p>泛型不具备继承性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; list = new ArrayList &lt;String&gt; ();//这个是错的</span><br></pre></td></tr></table></figure><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309161827820.png"></p></li><li><?> :支持任意泛型类型</li><li><? extends A>:支持A类以及A类的子类，规定了泛型的上限</li><li><? super A>:支持A类以及A类的父类，不限于直接父类，规定了泛型的下限</li><li><p>主要是为了约束，支持传任意的类，但不是所有的类都能传</p></li></ol><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">定义类</button></li><li class="tab"><button type="button" data-href="#test4-2">接受</button></li><li class="tab"><button type="button" data-href="#test4-3">测试</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class AA &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BB extends AA &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CC extends BB &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// ? extends AA 表示 上限，可以接受 AA或者AA子类</span><br><span class="line">public static void printCollection2(List&lt;? extends AA&gt; c) &#123;</span><br><span class="line">    for (Object object : c) &#123;</span><br><span class="line">        System.out.println(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//说明: List&lt;?&gt; 表示 任意的泛型类型都可以接受</span><br><span class="line">public static void printCollection1(List&lt;?&gt; c) &#123;</span><br><span class="line">    for (Object object : c) &#123; // 通配符，取出时，就是Object</span><br><span class="line">        System.out.println(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ? super 子类类名AA:支持AA类以及AA类的父类，不限于直接父类，</span><br><span class="line">//规定了泛型的下限</span><br><span class="line">public static void printCollection3(List&lt;? super AA&gt; c) &#123;</span><br><span class="line">    for (Object object : c) &#123;</span><br><span class="line">        System.out.println(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-3"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Object o = new String(&quot;xx&quot;);</span><br><span class="line"></span><br><span class="line">//泛型没有继承性</span><br><span class="line">//List&lt;Object&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">//举例说明下面三个方法的使用</span><br><span class="line">List&lt;Object&gt; list1 = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; list2 = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;AA&gt; list3 = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;BB&gt; list4 = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;CC&gt; list5 = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">//如果是 List&lt;?&gt; c ，可以接受任意的泛型类型</span><br><span class="line">printCollection1(list1);</span><br><span class="line">printCollection1(list2);</span><br><span class="line">printCollection1(list3);</span><br><span class="line">printCollection1(list4);</span><br><span class="line">printCollection1(list5);</span><br><span class="line"></span><br><span class="line">//List&lt;? extends AA&gt; c： 表示 上限，可以接受 AA或者AA子类</span><br><span class="line">//printCollection2(list1);//×</span><br><span class="line">//printCollection2(list2);//×</span><br><span class="line">printCollection2(list3);//√</span><br><span class="line">printCollection2(list4);//√</span><br><span class="line">printCollection2(list5);//√</span><br><span class="line"></span><br><span class="line">//List&lt;? super AA&gt; c: 支持AA类以及AA类的父类，不限于直接父类</span><br><span class="line">printCollection3(list1);//√</span><br><span class="line">//printCollection3(list2);//×</span><br><span class="line">printCollection3(list3);//√</span><br><span class="line">//printCollection3(list4);//×</span><br><span class="line">//printCollection3(list5);//×</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合</title>
      <link href="/2023/06/07/Java%E9%9B%86%E5%90%88/"/>
      <url>/2023/06/07/Java%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="集合框架体系"><a href="#集合框架体系" class="headerlink" title="集合框架体系"></a>集合框架体系</h1><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310100902114.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310100903447.png" alt=" "></p><p>集合主要是两组(单列集合，双列集合)</p><ul><li><p><strong>Collection 接口</strong>（单列集合）：可以存放多个元素。每个元素可以是 ObjectCollection 接口有两个重要子接口：List（有序集合）和 Set（无序集合）</p></li><li><p><strong>Map 接口</strong>（双列集合）：用于保存具有映射关系的数据：key - value（双列元素）key 和 value 可以是任何类型的引用数据类型。其中 key 不能重复，value 可以重复。key 和 value 存在单一对应关系。通过特定的 key 一定能找到指定的 value</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">单列集合</span><br><span class="line">ArrayList arrayList = new ArrayList();</span><br><span class="line">arrayList.add(&quot;jack&quot;);</span><br><span class="line">arrayList.add(&quot;tom&quot;);</span><br><span class="line"></span><br><span class="line">双列集合</span><br><span class="line">HashMap hashMap = new HashMap();</span><br><span class="line">hashMap.put(&quot;NO1&quot;, &quot;北京&quot;);</span><br><span class="line">hashMap.put(&quot;NO2&quot;, &quot;上海&quot;);</span><br></pre></td></tr></table></figure><h1 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h1><h2 id="单列集合接口-Collection"><a href="#单列集合接口-Collection" class="headerlink" title="单列集合接口 Collection"></a>单列集合接口 Collection</h2><blockquote><p>public interface Collection<E> extends Lterable<E></p></blockquote><ol><li>Collection实现子类可以存放多个元素。每个元素可以是 Object</li><li>有些Collection实现子类能存放重复的元素，有些不能，根据底层是链表还是哈希表决定</li><li>有些 Collection 实现子类是有序的（List） ，有些不是（Set）</li><li>Collection接口没有直接的实现子类，都是通过其子接口（List 和 Set）实现的</li></ol><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><ul><li><p><code>add</code>：添加单个元素，会自动装箱操作</p></li><li><p><code>remove</code>：删除单个元素，能按索引删除，又能按内容删除</p></li><li><p><code>contains</code>：检查元素是否存在</p></li><li><p><code>size</code>：获取元素个数</p></li><li><p><code>isEmpty</code>：判断是否为空</p></li><li><p><code>clear</code>：清空</p></li><li><p><code>addAll</code>：添加多个元素</p></li><li><p><code>containsAll</code>：检查多个元素是否存在</p></li><li><p><code>removeAll</code>：删除多个元素</p></li><li><p><code>Iterator iterator()</code>：返回指向集合开始位置的迭代器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// add:添加单个元素</span><br><span class="line">list.add(&quot;jack&quot;);</span><br><span class="line">list.add(10);//list.add(new Integer(10))</span><br><span class="line">list.add(true);</span><br><span class="line">System.out.println(&quot;list=&quot; + list);</span><br><span class="line"></span><br><span class="line">// remove:删除指定元素</span><br><span class="line">list.remove(0);//删除第一个元素</span><br><span class="line">list.remove(true);//指定删除某个元素</span><br><span class="line">System.out.println(&quot;list=&quot; + list);</span><br><span class="line"></span><br><span class="line">// contains:查找元素是否存在</span><br><span class="line">System.out.println(list.contains(&quot;jack&quot;));//T</span><br><span class="line"></span><br><span class="line">// size:获取元素个数</span><br><span class="line">System.out.println(list.size());//2</span><br><span class="line"></span><br><span class="line">// isEmpty:判断是否为空</span><br><span class="line">System.out.println(list.isEmpty());//F</span><br><span class="line"></span><br><span class="line">// clear:清空</span><br><span class="line">list.clear();</span><br><span class="line">System.out.println(&quot;list=&quot; + list);</span><br><span class="line"></span><br><span class="line">// addAll:添加多个元素</span><br><span class="line">ArrayList list2 = new ArrayList();</span><br><span class="line">list2.add(&quot;红楼梦&quot;);</span><br><span class="line">list2.add(&quot;三国演义&quot;);</span><br><span class="line">list.addAll(list2);</span><br><span class="line">System.out.println(&quot;list=&quot; + list);</span><br><span class="line"></span><br><span class="line">// containsAll:查找多个元素是否都存在</span><br><span class="line">System.out.println(list.containsAll(list2));//T</span><br><span class="line"></span><br><span class="line">// removeAll：删除多个元素</span><br><span class="line">list.add(&quot;聊斋&quot;);</span><br><span class="line">list.removeAll(list2);</span><br><span class="line">System.out.println(&quot;list=&quot; + list);//[聊斋]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="迭代器-Iterator"><a href="#迭代器-Iterator" class="headerlink" title="迭代器 Iterator"></a>迭代器 Iterator</h2><ul><li><p>Iterator 对象称为迭代器，主要用于遍历 Collection 集合中的元素。</p></li><li><p>所有实现了Collection接口的集合类都有一个iterator方法， 用以返回一个实现了Iterator接口的对象，即可以返回一个迭代器。</p></li><li><p>Iterator 对象仅用于遍历集合，本身不存放元素</p></li></ul><blockquote><p>IDEA 中，迭代器 while 循环的模板快捷键：<code>itit</code></p></blockquote><p><strong>常用方法：</strong></p><ul><li>iterator()：构造方法，获取迭代器对象</li></ul><ul><li><code>boolean hasNext()</code>：该方法判断是否有下一个元素。</li><li><code>T next()</code>：该方法会将指针下移，然后返回下移后的位置上的元素</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310100950317.png"></p><p><strong>用迭代器遍历元素：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;Object&gt; c = new LinkedList&lt;&gt;();</span><br><span class="line">Iterator&lt;Object&gt; iterator = c.iterator();// [1]</span><br><span class="line">while (iterator.hasNext())&#123;// [2]</span><br><span class="line">Object obj = iterator.next();// [3]</span><br><span class="line">System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>获取迭代器</p></li><li><p>判断有无下一元素</p></li><li><p>将迭代器后移，并返回那个后移位置上的元素</p></li><li><p>while 循环结束后，指针指向最后元素的位置。再次 <code>next()</code> 会报错。如果需要再使用，需要重置迭代器。</p><blockquote><p>iterator &#x3D; list.iterator();&#x2F;&#x2F;重置迭代器</p></blockquote></li></ol><h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class CollectionIterator &#123;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;all&quot;&#125;)</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Collection col = new ArrayList();</span><br><span class="line"></span><br><span class="line">        col.add(new Book(&quot;三国演义&quot;, &quot;罗贯中&quot;, 10.1));</span><br><span class="line">        col.add(new Book(&quot;小李飞刀&quot;, &quot;古龙&quot;, 5.1));</span><br><span class="line">        col.add(new Book(&quot;红楼梦&quot;, &quot;曹雪芹&quot;, 34.6));</span><br><span class="line"></span><br><span class="line">        //System.out.println(&quot;col=&quot; + col);</span><br><span class="line">        //现在老师希望能够遍历 col集合</span><br><span class="line">        //1. 先得到 col 对应的 迭代器</span><br><span class="line">        Iterator iterator = col.iterator();</span><br><span class="line">        //2. 使用while循环遍历</span><br><span class="line">//        while (iterator.hasNext()) &#123;//判断是否还有数据</span><br><span class="line">//            //返回下一个元素，类型是Object</span><br><span class="line">//            Object obj = iterator.next();</span><br><span class="line">//            System.out.println(&quot;obj=&quot; + obj);</span><br><span class="line">//        &#125;</span><br><span class="line">        //快捷键，快速生成 while =&gt; itit</span><br><span class="line">        //显示所有的快捷键的的快捷键 ctrl + j</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            Object obj = iterator.next();</span><br><span class="line">            System.out.println(&quot;obj=&quot; + obj);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //3. 当退出while循环后 , 这时iterator迭代器，指向最后的元素</span><br><span class="line">        //   iterator.next();//NoSuchElementException</span><br><span class="line">        </span><br><span class="line">        //4. 如果希望再次遍历，需要重置我们的迭代器</span><br><span class="line">        iterator = col.iterator();</span><br><span class="line">        System.out.println(&quot;===第二次遍历===&quot;);</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            Object obj = iterator.next();</span><br><span class="line">            System.out.println(&quot;obj=&quot; + obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="foreach（增强-for-循环）"><a href="#foreach（增强-for-循环）" class="headerlink" title="foreach（增强 for 循环）"></a>foreach（增强 for 循环）</h2><p>for each 的语法与 for 循环相似，但是可以遍历 Collection 和 数组 中的元素</p><blockquote><p>IDEA 中，增强 for 循环的模板快捷键：<code>I</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (Object o : list)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>for each 可在 Collection 集合中使用。</li><li>for each 的底层在本质上也是 <code>Iterator</code>。可以理解为简化版本的迭代器遍历</li></ul><h3 id="例-1"><a href="#例-1" class="headerlink" title="例"></a>例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class CollectionFor &#123;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;all&quot;&#125;)</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Collection col = new ArrayList();</span><br><span class="line"></span><br><span class="line">        col.add(new Book(&quot;三国演义&quot;, &quot;罗贯中&quot;, 10.1));</span><br><span class="line">        col.add(new Book(&quot;小李飞刀&quot;, &quot;古龙&quot;, 5.1));</span><br><span class="line">        col.add(new Book(&quot;红楼梦&quot;, &quot;曹雪芹&quot;, 34.6));</span><br><span class="line"></span><br><span class="line">        //1. 使用增强for, 在Collection集合</span><br><span class="line">        //2. 增强for， 底层仍然是迭代器</span><br><span class="line">        //3. 增强for可以理解成就是简化版本的 迭代器遍历</span><br><span class="line">        //4. 快捷键方式 I</span><br><span class="line">        </span><br><span class="line">//        for (Object book : col) &#123;</span><br><span class="line">//            System.out.println(&quot;book=&quot; + book);</span><br><span class="line">//        &#125;</span><br><span class="line">        for (Object o : col) &#123;</span><br><span class="line">            System.out.println(&quot;book=&quot; + o);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //增强for，也可以直接在数组使用</span><br><span class="line">//        int[] nums = &#123;1, 8, 10, 90&#125;;</span><br><span class="line">//        for (int i : nums) &#123;</span><br><span class="line">//            System.out.println(&quot;i=&quot; + i);</span><br><span class="line">//        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="课堂练习"><a href="#课堂练习" class="headerlink" title="课堂练习"></a>课堂练习</h2><ol><li>创建  3个 Dog {name, age}  对象，放入到 ArrayList 中，赋给 List 引用</li><li>用迭代器和增强for循环两种方式来遍历</li><li>重写Dog 的toString方法， 输出name和age</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">public class CollectionExercise &#123;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;all&quot;&#125;)</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List list = new ArrayList();</span><br><span class="line">        list.add(new Dog(&quot;小黑&quot;, 3));</span><br><span class="line">        list.add(new Dog(&quot;大黄&quot;, 100));</span><br><span class="line">        list.add(new Dog(&quot;大壮&quot;, 8));</span><br><span class="line"></span><br><span class="line">        //先使用for增强</span><br><span class="line">        for (Object dog : list) &#123;</span><br><span class="line">            System.out.println(&quot;dog=&quot; + dog);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //使用迭代器</span><br><span class="line">        System.out.println(&quot;===使用迭代器来遍历===&quot;);</span><br><span class="line">        Iterator iterator = list.iterator();</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            Object dog =  iterator.next();</span><br><span class="line">            System.out.println(&quot;dog=&quot; + dog);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 创建  3个 Dog &#123;name, age&#125;  对象，放入到 ArrayList 中，赋给 List 引用</span><br><span class="line"> * 用迭代器和增强for循环两种方式来遍历</span><br><span class="line"> * 重写Dog 的toString方法， 输出name和age</span><br><span class="line"> */</span><br><span class="line">class Dog &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public Dog(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Dog&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="有序集合接口-List"><a href="#有序集合接口-List" class="headerlink" title="有序集合接口 List"></a>有序集合接口 List</h1><blockquote><p>public interface List<E> extends Collection<E></p></blockquote><p>List 是 Collection 接口的子类接口，里面元素是有序（添加顺序和取出顺序一致）的，元素可重复的，每个元素都有其对应的顺序索引，下标从0开始。</p><p>三个主要的实现子类</p><ol><li>Vector</li><li>LinkedList</li><li>ArrayList</li></ol><h2 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h2><ul><li><p><code>add(int, obj)</code>：在 int 位置插入 obj 元素。返回 true</p><p><code>add(obj)</code>：在末尾插入 obj。返回 true</p><p><code>addElement(obj)</code>：在末尾插入 obj。无返回值。你说要这方法有啥用？名字还长一截</p></li><li><p><code>addAll(int, collection)</code>：在 int 位置插入 collection 中的所有元素</p></li><li><p><code>get(int)</code>：返回 int 位置的元素</p></li><li><p><code>indexOf(obj)</code>：返回 obj 首次出现时的位置</p></li><li><p><code>lastIndexOf(obj)</code>：返回 obj 最后一次出现时的位置</p></li><li><p><code>remove(int)</code>：移除 int 位置的元素，并返回那个被移除的元素</p></li><li><p><code>set(int, obj)</code>：设置 int 位置的元素为 obj。相当于替换。返回那个被替换元素的下标</p><p><code>setElement(obj, int)</code>：设置 int 位置的元素为 obj。无返回值</p></li><li><p><code>subList(int1, int2)</code>：返回 [int1, int2) 范围的元素构成的子集合</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        List list = new ArrayList();</span><br><span class="line">        list.add(&quot;张三丰&quot;);</span><br><span class="line">        list.add(&quot;贾宝玉&quot;);</span><br><span class="line">        </span><br><span class="line">//      void add(int index, Object ele):在index位置插入ele元素</span><br><span class="line">        //在index = 1的位置插入一个对象</span><br><span class="line">        list.add(1, &quot;韩顺平&quot;);</span><br><span class="line">        System.out.println(&quot;list=&quot; + list);</span><br><span class="line">        </span><br><span class="line">//      boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来</span><br><span class="line">        List list2 = new ArrayList();</span><br><span class="line">        list2.add(&quot;jack&quot;);</span><br><span class="line">        list2.add(&quot;tom&quot;);</span><br><span class="line">        list.addAll(1, list2);</span><br><span class="line">        System.out.println(&quot;list=&quot; + list);</span><br><span class="line">        </span><br><span class="line">//      Object get(int index):获取指定index位置的元素</span><br><span class="line">       </span><br><span class="line">//      int indexOf(Object obj):返回obj在集合中首次出现的位置</span><br><span class="line">        System.out.println(list.indexOf(&quot;tom&quot;));//2</span><br><span class="line">        </span><br><span class="line">//      int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置</span><br><span class="line">        list.add(&quot;韩顺平&quot;);</span><br><span class="line">        System.out.println(&quot;list=&quot; + list);</span><br><span class="line">        System.out.println(list.lastIndexOf(&quot;韩顺平&quot;));</span><br><span class="line">        </span><br><span class="line">//      Object remove(int index):移除指定index位置的元素，并返回此元素</span><br><span class="line">        list.remove(0);</span><br><span class="line">        System.out.println(&quot;list=&quot; + list);</span><br><span class="line">        </span><br><span class="line">//      Object set(int index, Object ele):设置指定index位置的元素为ele , 相当于是替换.</span><br><span class="line">        list.set(1, &quot;玛丽&quot;);</span><br><span class="line">        System.out.println(&quot;list=&quot; + list);</span><br><span class="line">        </span><br><span class="line">//      List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合</span><br><span class="line">        // 注意返回的子集合 fromIndex &lt;= subList &lt; toIndex</span><br><span class="line">        List returnlist = list.subList(0, 2);</span><br><span class="line">        System.out.println(&quot;returnlist=&quot; + returnlist);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="List-的三种遍历方式"><a href="#List-的三种遍历方式" class="headerlink" title="List 的三种遍历方式"></a>List 的三种遍历方式</h2><p> ArrayList，LinkedList，Vector三者通用</p><ol><li>迭代器</li><li>foreach</li><li>普通for</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    //List 接口的实现子类 Vector LinkedList</span><br><span class="line">    //List list = new ArrayList();</span><br><span class="line">    //List list = new Vector();</span><br><span class="line">    List list = new LinkedList();</span><br><span class="line"></span><br><span class="line">    list.add(&quot;jack&quot;);</span><br><span class="line">    list.add(&quot;tom&quot;);</span><br><span class="line">    list.add(&quot;鱼香肉丝&quot;);</span><br><span class="line">    list.add(&quot;北京烤鸭子&quot;);</span><br><span class="line"></span><br><span class="line">    //遍历</span><br><span class="line">    //1. 迭代器</span><br><span class="line">    Iterator iterator = list.iterator();</span><br><span class="line">    while (iterator.hasNext()) &#123;</span><br><span class="line">        Object obj =  iterator.next();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;=====增强for=====&quot;);</span><br><span class="line">    //2. 增强for</span><br><span class="line">    for (Object o : list) &#123;</span><br><span class="line">        System.out.println(&quot;o=&quot; + o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;=====普通for====&quot;);</span><br><span class="line">    //3. 使用普通for</span><br><span class="line">    for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">        System.out.println(&quot;对象=&quot; + list.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可变数组ArrayList"><a href="#可变数组ArrayList" class="headerlink" title="可变数组ArrayList"></a>可变数组ArrayList</h2><blockquote><p>public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable</p></blockquote><p>ArrayList 是 List 的实现子类。其底层由<strong>数组</strong>来实现存储。ArrayList 允许存放任何元素，包括null，并且可以有多个相同元素</p><p>ArrayList基本等同于Vector ,除了ArrayList是线程不安全，但执行效率高。</p><p>在多线程情况下，不建议使用ArrayList</p><h3 id="ArrayList-的源码"><a href="#ArrayList-的源码" class="headerlink" title="ArrayList 的源码"></a>ArrayList 的源码</h3><p>结论：</p><ol><li><p>ArrayList 中维护了一个 Object 类型的数组 elementData。该数组就是用来存放元素的数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient Object[] elementData;</span><br></pre></td></tr></table></figure><blockquote><p>transient 表示瞬间,短暂的，表示该属性不会被序列化</p></blockquote></li><li><p>创建 ArrayList 对象时</p><p>使用无参构造器，则 elementData[] 初始容量为 0</p><p>使用指定大小构造器，则初始容量为指定大小。</p></li><li><p>扩容的场合：</p><p>初始长度为 0 的 elementData，第一次扩容，容量置为10。后面每次扩容乘以1.5 倍。</p><p>初始长度为 capacity 的 elementData，每次扩容乘以1.5 。</p></li><li><p>当添加元素时：先判断是否需要扩容，如果需要扩容，则调用grow方法，否则直接添加元素到合适位置</p></li></ol><h3 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h3><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310101139825.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310101140986.png"></p><ul><li><p>构造器：创建一个数组</p></li><li><p>add()：</p><ol><li>确定是否扩容</li><li>添加元素</li></ol></li><li><p>扩容：</p><p>1</p></li></ul><h2 id="可变数组Vector"><a href="#可变数组Vector" class="headerlink" title="可变数组Vector"></a>可变数组Vector</h2><blockquote><p>public class Vector<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable</p></blockquote><p>Vector 是 List 的实现子类。其底层由<strong>数组</strong>来实现存储，但是线程安全。</p><blockquote><p>Vector 与 ArrayList 基本等同。ArrayList 效率更高，Vector 线程安全。</p><p>在开发中，需要考虑线程安全时，建议使用 Vector ，而非 ArrayList</p></blockquote><h3 id="Vector的源码"><a href="#Vector的源码" class="headerlink" title="Vector的源码"></a>Vector的源码</h3><ol><li><p>底层维护了一个 Object 类型的数组 elementData。用以存放元素</p></li><li><p>使用无参构造器创建对象时，默认大小是 10</p><p>使用有参构造器的场合，默认是那个指定大小（initialCapaticy）</p><p>也能在构造器中指定那个扩容的增长速度（capacityIncrement）</p></li><li><p>扩容的场合，容量变成 2 倍</p><p>使用有参构造器改变了 capacityIncrement 的场合，增量是那个指定数值</p></li></ol><h3 id="ArrayList-和Vector-的比较"><a href="#ArrayList-和Vector-的比较" class="headerlink" title="ArrayList 和Vector 的比较"></a>ArrayList 和Vector 的比较</h3><table><thead><tr><th></th><th>底层结构</th><th>版本</th><th>线程安全(同步)效率</th><th>扩容倍数</th></tr></thead><tbody><tr><td>ArrayList</td><td>可变数组</td><td>jdk1.2出现</td><td>不安全，效率高</td><td>如果有参构造1.5倍<br>如果是无参，第一次10，后面1.5倍扩容</td></tr><tr><td>Vector</td><td>可变数组 Object[ ]</td><td>jdk1.0出现</td><td>安全，效率不高</td><td>如果是无参，默认10，后面2倍扩容<br>如果是有参，初始大小就是参数，后面2倍扩容</td></tr></tbody></table><h2 id="链表-LinkedList"><a href="#链表-LinkedList" class="headerlink" title="链表 LinkedList"></a>链表 LinkedList</h2><blockquote><p>public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Deque<E>, Cloneable, java.io.Serializable</p></blockquote><p>在 Java 中，LinkedList 是 List 的实现子类，底层以<strong>双向非环链表</strong>形式存储元素。</p><p>LinkedList 底层实现了 双向链表 和 双端队列 特点。在 Java 中，LinkedList 也实现了 Deque 接口。</p><p>LinkedList 可以添加 null，可添加重复元素。但没有实现同步，因此线程不安全。</p><blockquote><p>链表是一种<strong>线性结构</strong>：其以节点方式存储，节点间在内存上的位置不连续。</p></blockquote><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310102139766.png"></p><h3 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h3><p><code>void addLast(E e)</code>：尾插一个新的元素，LinkedList 的 add 方法即调用该方法</p><p><code>void addFirst(E e)</code>：头插一个新的元素</p><p><code>E removeLast()</code>：移除并返回尾部元素。为空时报错</p><p><code>E poll()</code>：移除并返回尾部元素。为空时返回 null</p><p><code>E removeFirst()</code>：移除并返回头部元素。为空时报错</p><p><code>E getLast()</code>：仅返回尾部元素。为空时报错</p><p><code>E peek()</code>：返回尾部元素。为空时返回 null</p><p><code>E element()</code>：返回头部元素。为空时返回 null</p><p><code>E getFirst()</code></p><h3 id="LinkedList-的源码"><a href="#LinkedList-的源码" class="headerlink" title="LinkedList 的源码"></a>LinkedList 的源码</h3><ol><li><p>LinkedList 只有默认构造器和一个拷贝构造器</p></li><li><p>LinkedList 底层维护了一个 双向链表</p><p>每个节点（Node 对象）有 prev、next、item 属性。</p><p>其中 item 用来存放数据。</p><p>其中通过 prev 指向前一个节点，通过 next 指向后一个节点。最终实现双向链表。</p></li><li><p>LinkedList 不需要扩容。其增删元素时只要改变节点的指向即可。</p><p>也因此，其添加、删除元素效率比数组更高</p></li></ol><h2 id="ArrayList-x2F-Vector-和-LinkedList-的比较："><a href="#ArrayList-x2F-Vector-和-LinkedList-的比较：" class="headerlink" title="ArrayList&#x2F;Vector 和 LinkedList 的比较："></a>ArrayList&#x2F;Vector 和 LinkedList 的比较：</h2><table><thead><tr><th></th><th>底层结构</th><th>增删效率</th><th>改查效率</th></tr></thead><tbody><tr><td>ArrayList &#x2F; Vector</td><td>可变数组</td><td>低（数组扩容）</td><td>高</td></tr><tr><td><code>LinkedList</code></td><td>双向链表</td><td>高（链表追加）</td><td>低</td></tr></tbody></table><p>如何选择ArrayList和LinkedList：</p><ol><li>如果我们改查的操作多，选择ArrayList</li><li>如果我们增删的操作多，选择LinkedList</li><li>一般来说，在程序中，80%-90%都是查询，因此大部分情况下会选择ArrayList</li><li>在一个项目中，根据业务灵活选择，也可能这样，一个模块使用的是ArrayList,另外一个模块是LinkedList,也就是说，要根据业务来进行选择</li></ol><h1 id="无序集合接口-Set"><a href="#无序集合接口-Set" class="headerlink" title="无序集合接口 Set"></a>无序集合接口 Set</h1><blockquote><p>public interface Set<E> extends Collection<E></p></blockquote><p>Set 是 Collection 接口的子类接口。常用方法和 Collection 接口一样</p><p>Set 接口的特点是无序，没有索引，不允许重复元素。最多包含一个 null</p><h2 id="Set-接口的遍历方式"><a href="#Set-接口的遍历方式" class="headerlink" title="Set 接口的遍历方式"></a>Set 接口的遍历方式</h2><p>set 接口对象存放数据是无序（即添加的顺序和取出的顺序不一致）</p><p>可以使用迭代器和foreach，但是用不了普通for循环（没有索引）</p><blockquote><p>取出的顺序的顺序虽然不是添加的顺序，但是这个顺序是固定的</p></blockquote><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><ol><li><p>HashSet实现了Set接口</p></li><li><p>HashSet实际上是HashMap</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public HashSet() &#123;</span><br><span class="line">    map = new HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以存放null值，但是只能有一个null</p></li><li><p>HashSet不保证元素是有序的，取决于hash后，再确定索引的结果</p><blockquote><p>不保证存放元素的顺序和取出顺序致</p></blockquote></li><li><p>不能有重复元素&#x2F;对象</p><blockquote><p>Set共同特点</p></blockquote></li><li><p>add方法：会返回一个 boolen 值，根据内存地址判断是不是同一个对象，往 set 中加东西</p><blockquote><p>非常经典的面试题，涉及了 add 方法和字符串常量池</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set.add(new String(&quot;hsp&quot;));//ok</span><br><span class="line">set.add(new String(&quot;hsp&quot;));//加入不了.</span><br><span class="line">System.out.println(&quot;set=&quot; + set);</span><br></pre></td></tr></table></figure></blockquote></li></ol><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><blockquote><p>public class LinkedHashSet<E> extends HashSet<E> implements Set<E>, Cloneable, java.io.Serializable</p></blockquote><p>LinkedHashSet 是 HashSet 的子类</p><p>LinkedHashSet 底层是一个 LinkedHashMap，维护了一个数组 + 双向链表。</p><p>LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置。同时，使用链表维护元素的次序。这使得元素看起来是以插入顺序保存的，并得以按照放入顺序取出</p><h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p>当我们使用无参构造器，创建TreeSet时，仍然是无序的，使用TreeSet 提供的一个构造器，可以传入一个比较器(匿名内部类)并指定排序规则，构造器可以重构，实现不同功能，但最终返回一个</p><ul><li><p>无参构造器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TreeMap treeMap = new TreeMap();</span><br><span class="line"></span><br><span class="line">treeSet.add(&quot;jack&quot;);</span><br><span class="line">treeSet.add(&quot;tom&quot;);//3</span><br><span class="line">treeSet.add(&quot;sp&quot;);</span><br><span class="line">treeSet.add(&quot;a&quot;);</span><br><span class="line">treeSet.add(&quot;abc&quot;);//3</span><br></pre></td></tr></table></figure></li><li><p>带比较器的构造器</p><p>按字符串大小比较的比较器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TreeMap treeMap = new TreeMap(new Comparator() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Object o1, Object o2) &#123;</span><br><span class="line">        return ((String) o2).compareTo((String) o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>按照长度大小排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TreeMap treeMap = new TreeMap(new Comparator() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Object o1, Object o2) &#123;</span><br><span class="line">        return ((String) o2).length() - ((String) o1).length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><ol><li><p>构造器把传入的比较器对象，赋给了 TreeSet的底层的 TreeMap的属性this.comparator</p><p>TreeSet 底层还是 TreeMap</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public TreeMap(Comparator&lt;? super K&gt; comparator) &#123;</span><br><span class="line">    this.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在调用 treeSet.add(“tom”)，在底层会执行到下面判断，这个是真正决定添加的部分，构造器中进行的判断只是给下面的方法提供条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if (cpr != null) &#123;//cpr 就是我们的匿名内部类(对象)</span><br><span class="line">    do &#123;</span><br><span class="line">        parent = t;</span><br><span class="line">        //动态绑定到我们的匿名内部类(对象)compare</span><br><span class="line">        cmp = cpr.compare(key, t.key);</span><br><span class="line">        if (cmp &lt; 0)</span><br><span class="line">            t = t.left;</span><br><span class="line">        else if (cmp &gt; 0)</span><br><span class="line">            t = t.right;</span><br><span class="line">        else //如果相等，即返回0,这个Key就没有加入</span><br><span class="line">            return t.setValue(value);</span><br><span class="line">    &#125; while (t != null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310121000041.png"></p><p>Map接口的常用实现类: HashMap、Hashtable 和 Properties</p><p>Map接口实现类的特点：这里讲的是 JDK8 的Map接口特点</p><ol><li><p>Map用于保存具有映射关系的数据:Key-Value（键值对）</p></li><li><p>Map中的 key 和 value 可以是任何引用类型的数据，会封装到 HashMap$Node 对象中</p></li><li><p>Map中的key不允许重复，原因和HashSet 一样，当有相同的k，就等价于替换，</p></li><li><p>Map中的 value 可以重复</p></li><li><p>Map的 key 可以为 null，value 也可以为 null，key 为 nul，只能有一个，value 为 null，可以多个</p></li><li><p>常用 String 类作为 Map 的 key，但是不是只有字符串才能做 key</p><blockquote><p>put方法中 key 的类型是Object，啥都能接受。value 的类型也是Object，啥都能接受。</p></blockquote></li><li><p>key和value之间存在单向一对一关系，即通过指定的key总能找到对应的value</p></li><li><p>Map 存放数据的 key-value 示意图，一对 k-v 是放在一个HashMap$Node中的， 有因为Node实现了Entry 接口，有些书上也说一对 k-v 就是一个 Entry</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        return new  &lt;&gt;(hash, key, value, next);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>  Map真正的把 key 和 value 放在HashMap中</p><p>  Set 和 Collection 只是指向了HashMap</p><ol><li><p>k-v 最后是 HashMap$Node node &#x3D; newNode(hash, key, value, null)</p></li><li><p>k-v 为了方便程序员的遍历，还会 创建 EntrySet 集合 ，该集合存放的元素的类型 Entry, 而一个Entry对象就有k,v。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br></pre></td></tr></table></figure></li><li><p>EntrySet中，定义的类型是 Map.Entry， 但是实际上存放的还是 HashMap$Node</p><p>这是因为 static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt;。HashMap实现了Entry接口</p></li><li><p>当把 HashMap$Node 对象存放到 entrySet 就方便我们的遍历，因为 Map.Entry 提供了重要方法 K getKey() 和 V getValue();</p></li></ol></li></ol><h2 id="Map接口常用方法"><a href="#Map接口常用方法" class="headerlink" title="Map接口常用方法"></a>Map接口常用方法</h2><ol><li>put：添加</li><li>remove：根据键删除映射关系</li><li>get：根据键获取值</li><li>size：获取元素个数</li><li>isEmpty：判断个数是否为0</li><li>clear：清除</li><li>containsKey：查找键是否存在</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//      remove:根据键删除映射关系</span><br><span class="line">        map.remove(null);</span><br><span class="line">        </span><br><span class="line">//      get：根据键获取值</span><br><span class="line">        Object val = map.get(&quot;鹿晗&quot;);</span><br><span class="line">        </span><br><span class="line">//      size:获取元素个数</span><br><span class="line">        System.out.println(&quot;k-v=&quot; + map.size());</span><br><span class="line">        </span><br><span class="line">//      isEmpty:判断个数是否为0</span><br><span class="line">        System.out.println(map.isEmpty());//F</span><br><span class="line">        </span><br><span class="line">//      clear:清空</span><br><span class="line">        //map.clear();</span><br><span class="line">        System.out.println(&quot;map=&quot; + map);</span><br><span class="line">        </span><br><span class="line">//      containsKey:查找键是否存在</span><br><span class="line">        System.out.println(&quot;结果=&quot; + map.containsKey(&quot;hsp&quot;));//T</span><br></pre></td></tr></table></figure><h2 id="Map遍历方式"><a href="#Map遍历方式" class="headerlink" title="Map遍历方式"></a>Map遍历方式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//第一组: 先取出 所有的Key , 通过Key 取出对应的Value</span><br><span class="line">Set keyset = map.keySet();</span><br><span class="line">//(1) 增强for</span><br><span class="line">System.out.println(&quot;-----第一种方式-------&quot;);</span><br><span class="line">for (Object key : keyset) &#123;</span><br><span class="line">    System.out.println(key + &quot;-&quot; + map.get(key));</span><br><span class="line">&#125;</span><br><span class="line">//(2) 迭代器</span><br><span class="line">System.out.println(&quot;----第二种方式--------&quot;);</span><br><span class="line">Iterator iterator = keyset.iterator();</span><br><span class="line">while (iterator.hasNext()) &#123;</span><br><span class="line">    Object key =  iterator.next();</span><br><span class="line">    System.out.println(key + &quot;-&quot; + map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//第二组: 把所有的values取出</span><br><span class="line">Collection values = map.values();</span><br><span class="line">//这里可以使用所有的Collections使用的遍历方法</span><br><span class="line">//(1) 增强for</span><br><span class="line">System.out.println(&quot;---取出所有的value 增强for----&quot;);</span><br><span class="line">for (Object value : values) &#123;</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br><span class="line">//(2) 迭代器</span><br><span class="line">System.out.println(&quot;---取出所有的value 迭代器----&quot;);</span><br><span class="line">Iterator iterator2 = values.iterator();</span><br><span class="line">while (iterator2.hasNext()) &#123;</span><br><span class="line">    Object value =  iterator2.next();</span><br><span class="line">    System.out.println(value);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//第三组: 通过EntrySet 来获取 k-v</span><br><span class="line">Set entrySet = map.entrySet();// EntrySet&lt;Map.Entry&lt;K,V&gt;&gt;</span><br><span class="line">//        (1) 增强for</span><br><span class="line">System.out.println(&quot;----使用EntrySet 的 for增强(第3种)----&quot;);</span><br><span class="line">for (Object entry : entrySet) &#123;</span><br><span class="line">    //将entry 转成 Map.Entry</span><br><span class="line">    Map.Entry m = (Map.Entry) entry;</span><br><span class="line">    System.out.println(m.getKey() + &quot;-&quot; + m.getValue());</span><br><span class="line">&#125;</span><br><span class="line">//(2) 迭代器</span><br><span class="line">System.out.println(&quot;----使用EntrySet 的 迭代器(第4种)----&quot;);</span><br><span class="line">Iterator iterator3 = entrySet.iterator();</span><br><span class="line">while (iterator3.hasNext()) &#123;</span><br><span class="line">    Object entry =  iterator3.next();</span><br><span class="line">    System.out.println(entry.getClass());//HashMap$Node -实现-&gt; Map.Entry (getKey,getValue)</span><br><span class="line">    //向下转型 Map.Entry</span><br><span class="line">    Map.Entry m = (Map.Entry) entry;</span><br><span class="line">    System.out.println(m.getKey() + &quot;-&quot; + m.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><ol><li>HashMap是Map接口使用频率最高的实现类。</li><li>HashMap是以key-val对的方式来存储数据（HashMap$Node类型）</li><li>key不能重复，但是是值可以重复，允许使用nulI键和null值。</li><li>如果添加相同的key，则会覆盖原来的key-val ,等同于修改（key不会替换，val会替换）</li><li>与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式来存储的。JDK8中 hashMap 底层数组+链表+红黑树</li><li>HashMap没有实现同步，因此是线程不安全的</li></ol><h3 id="底层机制"><a href="#底层机制" class="headerlink" title="底层机制"></a>底层机制</h3><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109104621185.png" alt="image-20231109104621185"></p><p>k,v 是一个Node 实现了 Map.Entry&lt;K,V&gt; ，查看HashMap的源码可以看到</p><p>扩容机制和HashSet相同</p><ol><li>HashMap底层维护了Node类型的数组table,默认为null</li><li>当创建对象时，将加载因子(loadfactor)初始化为0.75.</li><li>当添动加key-val时，通过key的哈希值得到在table的索引。然后判断该索引处是否有元素，如果没有元素直接添加。如果该索引处有元素，继续判断该元素的key是否和准备加入的key相等，如果相等，则直接替换val;如果不相等需要判断是树结构还是链表结构，做出相应处理。如果添加时发现容量不够，则需要打容。</li><li>第1次添加，则需要扩容table容量为16,临界值为12（16 * 0.75）</li><li>以后再扩容，则需要扩容table容量为原来的2倍，临界值为原来的2倍，即24，依次类推</li><li>在Java8中，存在转化为红黑树的情况</li></ol><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">1. 执行构造器 new HashMap()</span><br><span class="line">初始化加载因子 loadfactor = 0.75</span><br><span class="line">HashMap$Node[] table = null</span><br><span class="line"></span><br><span class="line">2. 执行put 调用 hash方法，计算 key的 hash值 (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</span><br><span class="line">public V put(K key, V value) &#123;//K = &quot;java&quot; value = 10</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3. 执行 putVal</span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">       boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;//辅助变量</span><br><span class="line">    //如果底层的table 数组为null, 或者 length =0 , 就扩容到16</span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    //取出hash值对应的table的索引位置的Node, 如果为null, 就直接把加入的k-v</span><br><span class="line">    //, 创建成一个 Node ,加入该位置即可</span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line">    else &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;//辅助变量</span><br><span class="line">    // 如果table的索引位置的key的hash相同和新的key的hash值相同，</span><br><span class="line">     // 并 满足(table现有的结点的key和准备添加的key是同一个对象  || equals返回真)</span><br><span class="line">     // 就认为不能加入新的k-v</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        else if (p instanceof TreeNode)//如果当前的table的已有的Node 是红黑树，就按照红黑树的方式处理</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        else &#123;</span><br><span class="line">            //如果找到的结点，后面是链表，就循环比较</span><br><span class="line">            for (int binCount = 0; ; ++binCount) &#123;//死循环</span><br><span class="line">                if ((e = p.next) == null) &#123;//如果整个链表，没有和他相同,就加到该链表的最后</span><br><span class="line">                    p.next = newNode(hash, key, value, null);</span><br><span class="line">                    //加入后，判断当前链表的个数，是否已经到8个，到8个，后</span><br><span class="line">                    //就调用 treeifyBin 方法进行红黑树的转换</span><br><span class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (e.hash == hash &amp;&amp; //如果在循环比较过程中，发现有相同,就break,就只是替换value</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    break;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (e != null) &#123; // existing mapping for key</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                e.value = value; //替换，key对应value</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;//每增加一个Node ,就size++</span><br><span class="line">    if (++size &gt; threshold[12-24-48])//如size &gt; 临界值，就扩容</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">5. 关于树化(转成红黑树)</span><br><span class="line">//如果table 为null ,或者大小还没有到 64，暂时不树化，而是进行扩容.</span><br><span class="line">//否则才会真正的树化 -&gt; 剪枝</span><br><span class="line">final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;</span><br><span class="line">int n, index; Node&lt;K,V&gt; e;</span><br><span class="line">if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">    resize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树化案例"><a href="#树化案例" class="headerlink" title="树化案例"></a>树化案例</h3><h2 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h2><blockquote><p> public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable,  java.io.Serializable {</p></blockquote><ol><li>存放的元素是键值对即K-V</li><li>hashtable的键和值都不能为null，否则会抛出NullPointerException</li><li>hashTable使用方法基本上和HashMap-样</li><li>hashTable是线程安全的（synchronized），hashMap是线程不安全的</li></ol><h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><ol><li>Properties 类继承自 Hashtable 类并且实现了 Map 接口， 也是使用一种键值对的形式来保存数据。</li><li>他的使用特点和Hashtable类似，键和值都不能为null，否则会抛出NullPointerException</li><li>Properties 还可以用于从xx.properties文件中，加载数据到Properties类对象并进行读取和修改</li><li>工作后xx.properties 文件通常作为配置文件</li></ol><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>Properties 继承  Hashtable，可以通过 k-v 存放数据，当然key 和 value 不能为 null</p><ul><li>增加：put(Object key,Object value);</li><li>删除：remove(Object key);</li><li>修改</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//1. Properties 继承  Hashtable</span><br><span class="line">//2. 可以通过 k-v 存放数据，当然key 和 value 不能为 null</span><br><span class="line">//增加</span><br><span class="line">Properties properties = new Properties();</span><br><span class="line">//properties.put(null, &quot;abc&quot;);//抛出 空指针异常</span><br><span class="line">//properties.put(&quot;abc&quot;, null); //抛出 空指针异常</span><br><span class="line">properties.put(&quot;john&quot;, 100);//k-v</span><br><span class="line">properties.put(&quot;lucy&quot;, 100);</span><br><span class="line">properties.put(&quot;lic&quot;, 100);</span><br><span class="line">properties.put(&quot;lic&quot;, 88);//如果有相同的key ， value被替换</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;properties=&quot; + properties);</span><br><span class="line"></span><br><span class="line">//通过k 获取对应值</span><br><span class="line">System.out.println(properties.get(&quot;lic&quot;));//88</span><br><span class="line"></span><br><span class="line">//删除</span><br><span class="line">properties.remove(&quot;lic&quot;);</span><br><span class="line">System.out.println(&quot;properties=&quot; + properties);</span><br><span class="line"></span><br><span class="line">//修改</span><br><span class="line">properties.put(&quot;john&quot;, &quot;约翰&quot;);</span><br><span class="line">System.out.println(&quot;properties=&quot; + properties);</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在开发中，选择什么集合实现类，主要取决于业务操作特点，然后根据集合实现类特性进行选择，分析如下:</p><ol><li><p>先判断存储的类型(一组对象或一组键值对)</p></li><li><p>一组对象: Collection接口</p><ul><li><p>允许重复: List<br>增删多: LinkedList [底层维护了一个双向链表]</p><p>改查多: ArrayList [底层维护Object类型的可变数组]</p></li><li><p>不允许重复: Set</p><p>无序: HashSet [底层是HashMap，维护了一个哈希表 即(数组+链表+红黑树)]</p><p>排序: TreeSet</p><p>插入和取出顺序一致: LinkedHashSet ， 维护数组+双向链表</p></li></ul></li><li><p>一组键值对: Map</p><ul><li>键无序: HashMap [jdk8: 数组+链表+红黑树]</li><li>键排序: TreeMap</li><li>键插入和取出顺序一致: LinkedHashMap</li><li>读取文件Properties</li></ul></li></ol><h1 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h1><p>Collections工具类介绍</p><ol><li>Collections是一个操作 Set、List 和Map等集合的工具类</li><li>Collections中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作</li><li>只有一个构造器，方法极多</li></ol><hr><p>排序操作: (均为static方法)</p><ol><li>reverse(List)：反转List中元素的顺序</li><li>shuffle(List)：对List集合元素进行随机排序</li><li>sort(List)：根据元素的自然顺序对指定List集合元素按升序排序</li><li>sort(List, Comparator)：根据指定的Comparator产生的顺序对List 集合元素进行<br>排序</li><li>swap(List, int, int)：将指定list集合中的i处元素和j处元素进行交换</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-物理层</title>
      <link href="/2023/06/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.4/"/>
      <url>/2023/06/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.4/</url>
      
        <content type="html"><![CDATA[<h1 id="物理层的基本概念"><a href="#物理层的基本概念" class="headerlink" title="物理层的基本概念"></a>物理层的基本概念</h1><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606155648.png"></p><p>传输方式：在计算机网络中，用来连接各种网络设备的传输媒体种类众多，大致分为两类</p><ol><li>导引型传输媒体</li><li>非导引型传输媒体</li></ol><p>物理层协议的主要任务:</p><ol><li><p>机械特性</p><p>指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置。</p></li><li><p>电气特性</p><p>指明在接口电缆的各条线上出现的电压的范围。</p></li><li><p>功能特性</p><p>指明某条线上出现的某一电平的电压表示何种意义。</p></li><li><p>过程特性</p><p>指明对于不同功能的各种可能事件的出现顺序。</p></li></ol><p>物理连接方式：点对点，广播连接等。物理层协议种类比较多，每种物理层协议都包含了上述四个任务的具体内容。</p><blockquote><p>物理层考虑的是怎样才能在连接各种计算机的传输媒体,上传输数据比特流。</p></blockquote><p>物理层为数据链路层屏蔽了各种传输媒体的差异，使数据链路层只需要考虑如何完成本层的协议和服务,而不必考虑网络具体的传输媒体是什么。</p><h1 id="物理层下面的传输媒体"><a href="#物理层下面的传输媒体" class="headerlink" title="物理层下面的传输媒体"></a>物理层下面的传输媒体</h1><p>传输媒体大致分为两类</p><ol><li>导引型传输媒体</li><li>非导引型传输媒体</li></ol><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606160834.png"></p><h2 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h2><h3 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h3><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606161056.png"></p><ul><li>基带同轴电缆( 50 Ω )：数字传输，过去用于局域网</li><li>宽带同轴电缆( 75 Ω )：模拟传输，目前主要用于有线电视</li></ul><p>同轴电缆价格较贵且布线不够灵活和方便，随着集线器的出现，在局域网领域基本上都是采用双绞线作为传输媒体。</p><h3 id="双绞线（网线）"><a href="#双绞线（网线）" class="headerlink" title="双绞线（网线）"></a>双绞线（网线）</h3><p>把两根相互绝缘的铜导线并排放在一起。然后按照一定规则绞合起来就构成了双绞线</p><p>绞合的作用：</p><ol><li>抵御部分来自外界的电磁波干扰</li><li>减少相邻导线的电磁干扰</li></ol><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606161428.png"></p><h3 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h3><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606161524.png"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606162348.png"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606162429.png"></p><p>工作原理：当光从高折射率的媒体射向低折射率的媒体时，其折射角将大于入射角;因此，如果入射角足够大，就会出现全反射，即光碰到包层时，就会反射回纤芯。</p><p>纤芯直径：</p><ol><li>多模光纤：50微米，62.5微米</li><li>单模光纤：9微米</li></ol><p>工作波长：</p><ol><li>0.85微米</li><li>1.3 微米</li><li>1.55微米</li></ol><p>光纤优点：</p><ol><li>通信容量大(25000~ 30000GHz的带宽)</li><li>传输损耗小，远距离传输时更加经济。</li><li>抗雷电和电磁子扰性能好。这在大电流脉冲抗雷电和电磁子扰性能好。这在大电流脉冲</li><li>无串音干扰，保密性好，不易被窃听。</li><li>体积小，重量轻。</li></ol><p>光纤缺点：</p><ol><li>割接需要专用设备</li><li>光电接口贵</li></ol><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606162621.png"></p><p>多模光纤：</p><p>由于色散(模式、材料、波导色散)， 光在多模光纤中传输一定距离后必然产生信号失真(脉冲展宽)</p><p>因此，多模光纤只适合近距离传输(建筑物内)</p><p>发送光源:发光二极管;接收检测:光电二极管</p><p>单模光纤：</p><p>没有模式色散，在1 .31微米波长附近材料色散和波导色散大小相等符号相反，两者正好抵消。</p><p>单模光纤适合长距离传输且衰减小，但其制造成本高，对光源要求高。</p><p>发送光源:发光二极管;接收检测:光电二极管</p><h3 id="电力线"><a href="#电力线" class="headerlink" title="电力线"></a>电力线</h3><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606163002.png"></p><p>应用电力线传输信号的实例最早是电力线电话。</p><h2 id="非导引型传输媒体"><a href="#非导引型传输媒体" class="headerlink" title="非导引型传输媒体"></a>非导引型传输媒体</h2><h3 id="微波"><a href="#微波" class="headerlink" title="微波"></a>微波</h3><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606163144.png"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606163313.png"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606163449.png"></p><p>微波是直线传播，一般只有五十公里左右，为了实现远距离通信，必须在一条微波通信信道的两个终端之间建立若干个中继站。中继站将前一站送来的信号经过放大后再发送到下一站。称为“接力”。传播时延大</p><h3 id="红外线"><a href="#红外线" class="headerlink" title="红外线"></a>红外线</h3><p>红外线属于点对点无线传输，直线传输，中间不能有障碍物，传输距离短，传输速率低(4Mb&#x2F;s~ 16Mb&#x2F;s)。</p><h3 id="可见光"><a href="#可见光" class="headerlink" title="可见光"></a>可见光</h3><p>LIFI：一种新型光传播方式，还在实验阶段。</p><h1 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h1><p>串行传输：是一个比特一个比特传输，因此发送端和传输端之间<strong>只需要一条数据传输线路</strong>即可。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606164310.png"></p><p>并行传输：是指一次性传输多个比特，而不是一个比特。接发收端<strong>有 n 条传输线路</strong>。速度是串行传输的n倍，但是成本高。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606164452.png"></p><p><strong>计算机内部</strong>常采用<strong>并行传输</strong>的方式（总线）</p><p>计算机之间常采用<strong>串行传输</strong>的方式</p><blockquote><p>远距离传输是串行传输，计算机内部传输是并行传输，常见的数据总线宽度有 8 位，16位，32 位和 64 位。</p></blockquote><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606164650.png"></p><p>同步传输：发送端发送连续不间断的信号，接收端按照时钟频率进行接收，因为接发收端频率不同步，所以会产生一定的时钟误差，那么要需要一些方式来使时钟保持同步。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606164918.png"></p><p>由于不同设备的时钟频率存在一定差异，在传输大量数据的过程中，肪产生的判别刻的累计误差会导致接收端对批特信导的判别错位。</p><p>实现收发双方时钟同步的方法：</p><ol><li><p>外同步：两条信号线，一条接收数据信号，一条接收时钟频率信号。</p></li><li><p>内同步：发送端将时钟同步信号编码和发送数据一同发送（传统以太网所采用的就是曼彻斯特编码。）</p></li></ol><p>异步传输：发送数据是有间隔不联系的，接收端仅在每个字节的起始处对字节内的比特实现同步。为此，通常要在每个字节前后分别加上起始位和结束位</p><p><img src="C:\Users\CWL25\AppData\Roaming\Typora\typora-user-images\image-20230606165209094.png" alt="image-20230606165209094"></p><p>异步：字节之间异步(字节之间的时间间隔不固定)，字节中的每个比特仍然要同步(各比特的持续时间是相同的)</p><p>单向通信(单工)：通信双方只有一个数据传输方向。只需要一条信道</p><p>例如。无线电广播采用的就是这种通信方式。</p><p>双向交替通信(半双工)：通信双方可以相互传输数据。但不能同时进行。需要两条信道，来去各一条</p><p>例如。对讲机采用的就是这种通信方式</p><p>双向同时通信(全双工)：通信双方可以同时发送和接收信息。需要两条信道，来去各一条</p><p>例如。 电话采用的就是这种通信方式</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606171651.png"></p><h1 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h1><p>计算机需要处理和传输用户的文字。图片。音频和视频。它们可以统称为消息。</p><p>信导是数据的电磁表现。由信源发出的原始电信导称为基带信号。</p><p>基带信导可分为两类：</p><ol><li>数字基带信号。例如，计算机内部CPU与内存之间传输的信导。</li><li>模拟基带信号。例如，麦克风收到声音局产生的音频信号</li></ol><p>信号需要在信道中进行传输。</p><p>信道可分为数字信道和模拟信道两种。</p><p>在不改变信导性质的前提下，仅对数字基带信的波开形进行变换。称为编码。编码后产生的信号仍为数字信导，可以在数字信道中传输。</p><p>把数字基带信号的频率范围，搬移到较高的频段。并转换为模拟信导，称为调制。调制后产生的信导是模拟信号，可以在模拟信道中传输。</p><p>例如。WIF使用补码键控、直接序列扩频、正交频分复用等调制方法。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606172637.png"></p><p>传输媒体和信道不能直接划等号。对于单工传输，传输媒体中只包含一个信道。要么是发送信道，要么是接收信道。对于半双工和全双工传输。传输媒体中要包含两个信道。一个是发送信道，咼个是接收信道。如果使用信道复用技术。一条传输媒体还可以包含多个信道。</p><p>码元：在使用时间域的波形表示数字信号时,代表不同离散数值的基本波形。</p><h2 id="编码与调制-1"><a href="#编码与调制-1" class="headerlink" title="编码与调制"></a>编码与调制</h2><h3 id="常用编码"><a href="#常用编码" class="headerlink" title="常用编码"></a>常用编码</h3><p>不归零编码：不归零，就是指在整个码元时间肉，电平不会出现零电平</p><p>归零编码</p><p>曼彻斯特编码</p><p>差分曼彻斯特编码</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606173840.png"></p><h3 id="基本调制方法"><a href="#基本调制方法" class="headerlink" title="基本调制方法"></a>基本调制方法</h3><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606174456.png"></p><p>因为频率和相位是相关的，即频率是相位随时间的变化率。所以一次只能调制频率和相位两个中的-一个。</p><p>通常情况下，相位和振幅可以结合起来一起调制， 称为正交振幅调制QAM。</p><p>正交振幅调制QAM：</p><p>QAM-16：12种相位，每种相位有1或2种振幅可选，可以调制出16种码元(波形)，每种码元可以对应表示4个比特，每个码元与4个比特的对应关系不能随便定义。码元与4个比特的对应关系采用格雷码</p><h1 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h1><p>码间串扰：信号在传输过程中或受到各种因素的影响，一个数字信号通过实际的信道后，波形会产生失真，在失真不严重时，在输出端还可根据已失真的波形还原出发送的码元。在失真严重时，很难判断这个信号是什么时候是 1，什么时候是 0，信号波形失去了码元之间的清晰界限。</p><p>失真因素：</p><ol><li><p>码元传输速率</p></li><li><p>信号传输距离</p></li><li><p>噪声干扰</p></li><li><p>传输媒体质量</p></li></ol><p>奈氏准则：在假定的理想条件下，为了避免码间串扰，码元传输速率是有上限的。</p><p>理想低通信道的最高码元传输速率&#x3D; 2W Baud &#x3D; 2W 码元&#x2F;秒</p><p>理想带通信道的最高码元传输速率&#x3D; W Baud &#x3D; W 码元&#x2F;秒</p><p>W ：信道带宽(单位为Hz)</p><p>Baud ：波特，即码元&#x2F;秒</p><p>码元传输速率又称为波特率、调制速率、波形速率或符号速率。它与比特率有一定关系:</p><ol><li>当1个码元只携带1比特的信息量时，则波特率(码元&#x2F;秒)与比特率(此特&#x2F;秒)在数值上是相等的;</li><li>当1个码元携带n比特的信息量时，则波特率转换成比特率时,数值要乘以n。</li></ol><p>要提高信息传输速率(比特率)，就必须设法使每一个码元能携带更多个比特的信息量。这需要采用多元制。</p><p>实际的信道所能传输的最高码元速率，要明显低于奈氏准则给出的这个，上限数值。</p><p><strong>香农公式</strong>：带宽受限且有高斯白噪声干扰的信道的极限信息传输速率。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606182307.png"><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606182141.png"></p><p>信道带宽或信道中信噪比越大，信息的极限传输速率越高。</p><p>在实际信道上能够达到的信息传输速率要比该公式的极限传输速率低不少。这是因为在实际信道中，信号还要受到其他些损伤，如各种脉冲干扰、信号在传输中的衰减和失真些损伤，如各种脉冲干扰、信号在传输中的衰减和失真</p><p>在信道带宽一定的情况下， 根据奈氏准则和香农公式，要想提高信息的传输速率就必须采用多元制(更好的调制方法)和努力提高信道中的信噪比。</p><p>自从香农公式发表后，各种新的信号处理和调制方法就不断出现，其目的都是为了尽可能地接近香农公式给出的传输速率极限。</p><p>不管题目给出的调制技术多么“牛或对于我们而言有多陌生，这都不会影响我们解题。我们只需关心这种调制技术可以调制我们只需关心这种调制技术可以调制</p><h1 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h1><p>复用(Multiplexing) 就是在一条传输媒体.上同时传输多路用户的信号。</p><p>当一条传输媒体的传输容量大于多条信道传输的总容量时，就可以通过复用技术，在这条传输媒体上建立多条通信信道,以便充分利用传输媒体的带宽。</p><p>尽管实现信道复用会增加通信成本(需要复用器、分用器以及费用较高的大容量共享信道) ,但如果复用的信道数量较大，还是比较划算的。</p><h2 id="常见的信道复用技术"><a href="#常见的信道复用技术" class="headerlink" title="常见的信道复用技术"></a>常见的信道复用技术</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606183608.png"></p><p>FDM：将传输媒体的总频带划分成多个子频带，每个子频带作为一个通信子信道，每对用户使用其中的一个子信道进行通信，各子信道之间需要留出隔离频带，以免造成子信道间的干扰，频分复用的所有用户同时占用不同的频带资源发送数据 。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606183758.png"></p><p>频分复用的所有用户同时占用不同的频带资源发送数据</p><p>TDM：将时间划分为一段段等长的时隙，每一个时分复用的用户，在其相应时隙内，独占传输媒体的资源进行通信，时分复用的各用户所对应的时隙就构成了时分复用帧。每个用户占用的时隙是周期性的，其周期就是 TDM 帧的长度。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606183925.png"></p><blockquote><p>TDM帧实际上是一段固定长度的时间，它与数据链路层对等实体间逻辑通信的”帧”是完全不同的概念。</p></blockquote><p>时分复用的所有用户在不同的时间占用同样的频带进行通信</p><p>WDM：就是光的频分复用，由频分复用的设计思想，可在一根光纤上同时传输多个频率（波长）相近的光载波信号，实现基于光纤的频分复用技术。</p><blockquote><p>目前可以在一根光纤上复用 80 路或更多路的光载波信号。因此，这种复用技术也称为密集波复用 DWDM。</p></blockquote><p>下图是其物理意义</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606184142.png"></p><p>铺设光缆的工程耗资巨大，应尽量在一根光缆中放入尽可能多的光纤，然后对每一根光纤使用密集波分复用技术。</p><p>CDM：它是在扩频通信技术的基础上发展起来的一种无线通信技术。与<strong>频分复用</strong>和<strong>时分复用</strong>不同，码分多址的每个用户可以<strong>在相同的时间使用相同的频带进行通信</strong>。</p><p>码分多址最初用于军事通信，这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。随着技术的进步，码分多址设备的价格和体积都大幅度下降，因而现在已广泛用于民用的移动通信中。</p><p>码分多址将每个比特时间划分成为 m 个更短的时间片，称为<strong>码片</strong>。M 的取值通常为 64 或 128.为了简单起见，在后续的举例中，我们假设 m 分取值为 8。码分多址中的每个站点都被指派一个唯一的 <strong>m 比特码片序列。</strong>某个站要<strong>发送比特 1</strong>，则发送它自己的 <strong>m 比特码片序列</strong>。某个站要发送<strong>比特 0</strong>，则发送它自己的 <strong>m 比特码片序列的反码</strong>。</p><p>如果有两个或多个站同时发送数据，则信道中的信号就是这些站各自所发送一系列码片序列或码片序列反码的叠加，为了从信道中分离出每个站的信号，给每个站指派码片序列时，必须遵循以下原则：</p><ol><li>分配给每个站的<strong>码片序列必须各不相同</strong>，实际常采用伪随机码序列。</li><li>分配给每个站的<strong>码片序列必须相互正交</strong>，即各码片序列相应的码片向量之间的<strong>规格化内积为 0</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC</title>
      <link href="/2023/06/04/JDBC/"/>
      <url>/2023/06/04/JDBC/</url>
      
        <content type="html"><![CDATA[<h1 id="JDBC概述"><a href="#JDBC概述" class="headerlink" title="JDBC概述"></a>JDBC概述</h1><h2 id="数据的持久化"><a href="#数据的持久化" class="headerlink" title="数据的持久化"></a>数据的持久化</h2><ul><li>持久化(persistence)：把数据保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企业级应用，数据持久化意味着将内存中的数据保存到硬盘上加以”固化”，而持久化的实现过程大多通过各种关系数据库来完成。</li><li>持久化的主要应用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。</li></ul><h2 id="Java中的数据存储技术"><a href="#Java中的数据存储技术" class="headerlink" title="Java中的数据存储技术"></a>Java中的数据存储技术</h2><ul><li>在Java中，数据库存取技术可分为如下几类：<ul><li>JDBC直接访问数据库</li><li>JDO (Java Data Object )技术</li><li>第三方O&#x2F;R工具，如Hibernate, Mybatis 等</li></ul></li><li>JDBC是java访问数据库的基石，JDO、Hibernate、MyBatis等只是更好的封装了JDBC。</li></ul><h2 id="JDBC介绍"><a href="#JDBC介绍" class="headerlink" title="JDBC介绍"></a>JDBC介绍</h2><ul><li>JDBC(Java Database Connectivity)是一个独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口（一组API），定义了用来访问数据库的标准Java类库，（java.sql,javax.sql）使用这些类库可以以一种标准的方法、方便地访问数据库资源。</li><li>JDBC为访问不同的数据库提供了一种统一的途径，为开发者屏蔽了一些细节问题。</li><li>JDBC的目标是使Java程序员使用JDBC可以连接任何提供了JDBC驱动程序的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。</li><li>如果没有JDBC，那么Java程序访问数据库时是这样的：<br><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310092034056.png"></li><li>有了JDBC，Java程序访问数据库时是这样的：<br><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310092034585.png"></li><li>总结如下：<br><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310092034573.png"></li></ul><h2 id="JDBC体系结构"><a href="#JDBC体系结构" class="headerlink" title="JDBC体系结构"></a>JDBC体系结构</h2><p>JDBC接口（API）包括两个层次：</p><ul><li>面向应用的API：Java API，抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果）。</li><li>面向数据库的API：Java Driver API，供开发商开发数据库驱动程序用。</li></ul><blockquote><p>JDBC是sun公司提供一套用于数据库操作的接口，java程序员只需要面向这套接口编程即可。不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。——面向接口编程</p></blockquote><h2 id="JDBC程序编写步骤"><a href="#JDBC程序编写步骤" class="headerlink" title="JDBC程序编写步骤"></a>JDBC程序编写步骤</h2><blockquote><p>补充：ODBC(Open Database Connectivity，开放式数据库连接)，是微软在Windows平台下推出的。使用者在程序中只需要调用ODBC API，由 ODBC 驱动程序将调用转换成为对特定的数据库的调用请求。</p></blockquote><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310161000701.png"></p><h1 id="获取数据库连接"><a href="#获取数据库连接" class="headerlink" title="获取数据库连接"></a>获取数据库连接</h1><h2 id="要素一：Driver接口实现类"><a href="#要素一：Driver接口实现类" class="headerlink" title="要素一：Driver接口实现类"></a>要素一：Driver接口实现类</h2><h3 id="Driver接口介绍"><a href="#Driver接口介绍" class="headerlink" title="Driver接口介绍"></a>Driver接口介绍</h3><p>java.sql.Driver 接口是所有 JDBC 驱动程序需要实现的接口。这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现。</p><p>在程序中不需要直接去访问实现了 Driver 接口的类，而是由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver实现。</p><ul><li>Oracle的驱动：oracle.jdbc.driver.OracleDriver</li><li>mySql的驱动： com.mysql.jdbc.Driver</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310161003540.png"></p><p>connection：用于获取连接的方法</p><h3 id="加载与注册JDBC驱动"><a href="#加载与注册JDBC驱动" class="headerlink" title="加载与注册JDBC驱动"></a>加载与注册JDBC驱动</h3><ul><li><p>加载驱动：加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名 Class.forName(“com.mysql.jdbc.Driver”);</p></li><li><p>注册驱动：DriverManager 类是驱动程序管理器类，负责管理驱动程序</p></li><li><p>使用DriverManager.registerDriver(com.mysql.jdbc.Driver)来注册驱动</p></li><li><p>通常不用显式调用 DriverManager 类的 registerDriver() 方法来注册驱动程序类的实例，因为 Driver 接口的驱动程序类都包含了静态代码块，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注册自身的一个实例。下面是MySQL的Driver实现类的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.mysql.jdbc;</span><br><span class="line"></span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line"></span><br><span class="line">public class Driver extends NonRegisteringDriver implements java.sql.Driver &#123;</span><br><span class="line">    public Driver() throws SQLException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            DriverManager.registerDriver(new Driver());</span><br><span class="line">        &#125; catch (SQLException var1) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Can&#x27;t register driver!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="要素二：URL"><a href="#要素二：URL" class="headerlink" title="要素二：URL"></a>要素二：URL</h2><p>JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。</p><p>JDBC URL的标准由三部分组成，各部分间用冒号分隔。</p><ul><li>jdbc：子协议:子名称</li><li>协议：JDBC URL中的协议总是jdbc</li><li>子协议：子协议用于标识一个数据库驱动程序</li><li>子名称：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了定位数据库提供足够的信息。包含主机名(对应服务端的ip地址)，端口号，数据库名</li></ul><p>举例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jdbc:mysql://localhost:3306/dbtest</span><br><span class="line"></span><br><span class="line">其中</span><br><span class="line">jdbc --&gt; 协议</span><br><span class="line">mysql --&gt; 子协议</span><br><span class="line">localhost:3306/dbtest --&gt; 子名称</span><br><span class="line">    localhost --&gt; 主机名</span><br><span class="line">    3306 --&gt; 端口号(MySQL默认端口号为3306)</span><br><span class="line">    dbtest --&gt; 数据库名</span><br></pre></td></tr></table></figure><p>几种常用数据库的 JDBC URL</p><ul><li><p>MySQL的连接URL编写方式：</p><ul><li><p>jdbc:mysql:&#x2F;&#x2F;主机名称:mysql服务端口号&#x2F;数据库名称?参数&#x3D;值&amp;参数&#x3D;值</p></li><li><p>jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test</p></li><li><p>jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8</p><blockquote><p>如果JDBC程序与服务器端的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集</p></blockquote></li><li><p>jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test?user&#x3D;root&amp;password&#x3D;123456</p></li></ul></li><li><p>Oracle 9i的连接URL编写方式：</p><ul><li>jdbc:oracle:thin:@主机名称:oracle服务端口号:数据库名称</li><li>jdbc:oracle:thin:@localhost:1521:test</li></ul></li><li><p>SQLServer的连接URL编写方式：</p><ul><li>jdbc:sqlserver:&#x2F;&#x2F;主机名称:sqlserver服务端口号:DatabaseName&#x3D;数据库名称</li><li>jdbc:sqlserver:&#x2F;&#x2F;localhost:1433:DatabaseName&#x3D;test</li></ul></li></ul><h2 id="要素三：用户名和密码"><a href="#要素三：用户名和密码" class="headerlink" title="要素三：用户名和密码"></a>要素三：用户名和密码</h2><p>user,password可以用“属性名&#x3D;属性值”（键值对）方式告诉数据库</p><p>可以调用 DriverManager 类的 getConnection() 方法建立到数据库的连接</p><h2 id="数据库连接方式举例（5个，迭代关系）"><a href="#数据库连接方式举例（5个，迭代关系）" class="headerlink" title="数据库连接方式举例（5个，迭代关系）"></a>数据库连接方式举例（5个，迭代关系）</h2><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">方式1</button></li><li class="tab"><button type="button" data-href="#test1-2">方法2</button></li><li class="tab"><button type="button" data-href="#test1-3">方法3</button></li><li class="tab"><button type="button" data-href="#test1-4">方法4</button></li><li class="tab"><button type="button" data-href="#test1-5">方法5</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class ConnectionTest &#123;</span><br><span class="line"></span><br><span class="line">    //方式一 ：</span><br><span class="line">    @Test</span><br><span class="line">    public void testConnection1()  throws SQLException &#123;</span><br><span class="line"></span><br><span class="line">        Driver driver = new com.mysql.jdbc.Driver();</span><br><span class="line"></span><br><span class="line">        //jdbc:mysql:协议</span><br><span class="line">        //localhost：ip地址</span><br><span class="line">        //3306：默认mysql的端口号</span><br><span class="line">        //test：数据库名</span><br><span class="line">        String url = &quot;jdbc:mysql://localhost:3306/test&quot;;</span><br><span class="line">        //将用户名和密码封装在Properties中</span><br><span class="line">        Properties info = new Properties();</span><br><span class="line">        info.setProperty(&quot;user&quot;, &quot;root&quot;);</span><br><span class="line">        info.setProperty(&quot;password&quot;,&quot;111111&quot;);</span><br><span class="line">        Connection conn = driver.connect(url,info);</span><br><span class="line"></span><br><span class="line">    System.out.println(conn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>说明：上述代码中显式出现了第三方数据库的API，就是 new com.mysql.jdbc.Driver(); 这里</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p>方式二：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//方式二: 对方式一的迭代：不出现第三方API ，使程序有更好的可移植性</span><br><span class="line">    @Test</span><br><span class="line">    public void testConnection2() throws Exception &#123;</span><br><span class="line">        //1 获取Driver实现类对象，反射实现</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">        Driver driver = (Driver) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">        //2 提供要连接的数据库</span><br><span class="line">        String url = &quot;jdbc:mysql://localhost:3306/test&quot;;</span><br><span class="line">        //3 用户名密码</span><br><span class="line">        Properties info = new Properties();</span><br><span class="line">        info.setProperty(&quot;user&quot;, &quot;root&quot;);</span><br><span class="line">        info.setProperty(&quot;password&quot;,&quot;abc123&quot;);</span><br><span class="line">        //4 获取连接</span><br><span class="line">        Connection conn = driver.connect(url,info);</span><br><span class="line"></span><br><span class="line">        System.out.println(conn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>说明：相较于方式一，这里使用反射实例化Driver，不在代码中体现第三方数据库的API。体现了面向接口编程思想。</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p>方式三：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//方式三：DriverManager替换Driver</span><br><span class="line">    @Test</span><br><span class="line">    public void testConnection3() throws Exception &#123;</span><br><span class="line">        //1 获取Driver实现类对象</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">        Driver driver = (Driver) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">        //2 获取连接基本信息</span><br><span class="line">        String url = &quot;jdbc:mysql://localhost:3306/test&quot;;</span><br><span class="line">        String user = &quot;root&quot;;</span><br><span class="line">        String password = &quot;abc123&quot;;</span><br><span class="line">        //注册驱动</span><br><span class="line">        DriverManager.registerDriver(driver);</span><br><span class="line"></span><br><span class="line">        //获取连接</span><br><span class="line">        Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">        System.out.println(connection);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>说明：使用DriverManager实现数据库的连接。体会获取连接必要的4个基本要素。</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><p>方式四：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//方式四：省略了实例化和注册驱动，源码有静态代码自动注册</span><br><span class="line">    @Test</span><br><span class="line">    public void testConnection4() throws Exception &#123;</span><br><span class="line">        //1 获取连接基本信息</span><br><span class="line">        String url = &quot;jdbc:mysql://localhost:3306/test&quot;;</span><br><span class="line">        String user = &quot;root&quot;;</span><br><span class="line">        String password = &quot;abc123&quot;;</span><br><span class="line"></span><br><span class="line">        //2 加载Driver</span><br><span class="line">        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">        //3 获取连接</span><br><span class="line">        Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">        System.out.println(connection);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>说明：不必显式的注册驱动了。因为在DriverManager的源码中已经存在静态代码块，实现了驱动的注册。</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-5"><p>方式五：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//方式五：将数据库连接需要的基本信息声明在配置文件中，通过读取配置文件方式获得连接</span><br><span class="line">    @Test</span><br><span class="line">    public void testConnection5() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        //1 获取连接基本信息</span><br><span class="line">        InputStream is = ConnectionTest.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;);</span><br><span class="line"></span><br><span class="line">        Properties properties = new Properties();</span><br><span class="line">        properties.load(is);</span><br><span class="line"></span><br><span class="line">        String user = properties.getProperty(&quot;user&quot;);</span><br><span class="line">        String password = properties.getProperty(&quot;password&quot;);</span><br><span class="line">        String url = properties.getProperty(&quot;url&quot;);</span><br><span class="line">        String driverClass = properties.getProperty(&quot;driverClass&quot;);</span><br><span class="line"></span><br><span class="line">        //2 加载驱动</span><br><span class="line">        Class.forName(driverClass);</span><br><span class="line"></span><br><span class="line">        //3 获取连接</span><br><span class="line">        Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">1.实现数据和代码的分离、解耦</span><br><span class="line">2.如果需要修改配置信息，可以避免程序重新打包</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>其中，配置文件声明在工程的src目录下：jdbc.properties</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PROPERTIES</span><br><span class="line">user=root</span><br><span class="line">password=yourpassword</span><br><span class="line">url=jdbc:mysql://localhost:3306/test</span><br><span class="line">driverClass=com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure><blockquote><p>说明：使用配置文件的方式保存配置信息，在代码中加载配置文件</p></blockquote><p>使用配置文件的好处：</p><ul><li>实现了代码和数据的分离，如果需要修改配置信息，直接在配置文件中修改，不需要深入代码</li><li>如果修改了配置信息，省去重新编译的过程。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="使用PreparedStatement实现CRUD操作"><a href="#使用PreparedStatement实现CRUD操作" class="headerlink" title="使用PreparedStatement实现CRUD操作"></a>使用PreparedStatement实现CRUD操作</h1><h2 id="操作和访问数据库"><a href="#操作和访问数据库" class="headerlink" title="操作和访问数据库"></a>操作和访问数据库</h2><p>数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。其实一个数据库连接就是一个Socket连接。</p><p>在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式：</p><ul><li><p><code>Statement</code>：用于执行静态 SQL 语句并返回它所生成结果的对象。</p></li><li><p><code>PrepatedStatement</code>：SQL 语句被<strong>预编译</strong>并存储在此对象中，可以使用此对象多次高效地执行该语句。</p><blockquote><p>PrepatedStatement 是 Statement 的子接口（实现优化功能）</p></blockquote></li><li><p><code>CallableStatement</code>：用于执行 SQL 存储过程</p></li></ul><h2 id="使用Statement操作数据表的弊端"><a href="#使用Statement操作数据表的弊端" class="headerlink" title="使用Statement操作数据表的弊端"></a>使用Statement操作数据表的弊端</h2><p>通过调用 <code>Connection</code> 对象的 <code>createStatement()</code> 方法创建该对象。该对象用于执行静态的 SQL 语句，并且返回执行结果。</p><p>Statement 接口中定义了下列方法用于执行 SQL 语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int excuteUpdate(String sql) //执行更新操作INSERT、UPDATE、DELETE</span><br><span class="line">ResultSet executeQuery(String sql) //执行查询操作SELECT</span><br></pre></td></tr></table></figure><p>但是使用Statement操作数据表存在弊端：</p><ul><li>问题一：存在拼串操作，繁琐</li><li>问题二：存在SQL注入问题</li></ul><p>SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令，从而利用系统的 SQL 引擎完成恶意行为的做法。</p><p>对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement(从Statement扩展而来) 取代 Statement 就可以了。</p><h2 id="PreparedStatement的使用"><a href="#PreparedStatement的使用" class="headerlink" title="PreparedStatement的使用"></a>PreparedStatement的使用</h2><h3 id="PreparedStatement介绍"><a href="#PreparedStatement介绍" class="headerlink" title="PreparedStatement介绍"></a>PreparedStatement介绍</h3><ul><li>可以通过调用 <code>Connection</code> 对象的 <code>preparedStatement(String sql)</code> 方法获取 <code>PreparedStatement</code> 对象</li><li><code>PreparedStatement</code> 接口是 <code>Statement</code> 的子接口，它表示一条预编译过的 SQL 语句</li><li><code>PreparedStatement</code> 对象所代表的 SQL 语句中的参数用问号(<code>?</code>)来表示，调用 <code>PreparedStatement</code> 对象的<code>setXxx()</code> 方法来设置这些参数. <code>setXxx()</code> 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从1开始)，第二个是设置的 SQL 语句中的参数的值</li></ul><h3 id="PreparedStatement-vs-Statement"><a href="#PreparedStatement-vs-Statement" class="headerlink" title="PreparedStatement vs Statement"></a>PreparedStatement vs Statement</h3><ul><li>代码的可读性和可维护性</li><li>PreparedStatement 能最大可能提高性能：<ul><li>DBServer会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。</li><li>在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样每执行一次都要对传入的语句编译一次。</li></ul></li><li>PreparedStatement 可以防止 SQL 注入</li></ul><h3 id="Java与SQL对应数据类型转换表"><a href="#Java与SQL对应数据类型转换表" class="headerlink" title="Java与SQL对应数据类型转换表"></a>Java与SQL对应数据类型转换表</h3><table><thead><tr><th align="center">Java类型</th><th align="center">SQL类型</th></tr></thead><tbody><tr><td align="center">BOOLEAN</td><td align="center">BIT</td></tr><tr><td align="center">BYTE</td><td align="center">TINYINT</td></tr><tr><td align="center">short</td><td align="center">SMALLINT</td></tr><tr><td align="center">INT</td><td align="center">INTEGER</td></tr><tr><td align="center">LONG</td><td align="center">BIGINT</td></tr><tr><td align="center">STRING</td><td align="center">CHAR,VARCHAR,LONGVARCHAR</td></tr><tr><td align="center">BYTE array</td><td align="center">BINARY , VAR BINARY</td></tr><tr><td align="center">java.sql.Date</td><td align="center">DATE</td></tr><tr><td align="center">java.sql.Time</td><td align="center">TIME</td></tr><tr><td align="center">java.sql.Timestamp</td><td align="center">TIMESTAMP</td></tr></tbody></table><h3 id="使用PreparedStatement实现增、删、改操作"><a href="#使用PreparedStatement实现增、删、改操作" class="headerlink" title="使用PreparedStatement实现增、删、改操作"></a>使用PreparedStatement实现增、删、改操作</h3><p>例1：</p><p>为了更容易的看清代码结构，这里采用抛异常处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testInsert() throws Exception&#123;</span><br><span class="line">        //1. 读取配置文件</span><br><span class="line">        InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;);</span><br><span class="line">        Properties properties = new Properties();</span><br><span class="line">        properties.load(is);</span><br><span class="line">        String user = properties.getProperty(&quot;user&quot;);</span><br><span class="line">        String password = properties.getProperty(&quot;password&quot;);</span><br><span class="line">        String url = properties.getProperty(&quot;url&quot;);</span><br><span class="line">        String className = properties.getProperty(&quot;className&quot;);</span><br><span class="line">        //2. 加载驱动</span><br><span class="line">        Class.forName(className);</span><br><span class="line">        //3. 获取连接</span><br><span class="line">        Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">        //4. 预编译SQL语句，返回PreparedStatement实例</span><br><span class="line">        String sql = &quot;insert into customers(name,email,birth) values(?,?,?)&quot;;</span><br><span class="line">        PreparedStatement ps = connection.prepareStatement(sql);</span><br><span class="line">        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">        java.util.Date date =  sdf.parse(&quot;1999-12-21&quot;);</span><br><span class="line">        //5. 填充占位符</span><br><span class="line">        ps.setObject(1,&quot;张三&quot;);</span><br><span class="line">        ps.setObject(2,&quot;zhangsan@gmail.com&quot;);</span><br><span class="line">        ps.setObject(3,date);</span><br><span class="line">        //6. 执行操作</span><br><span class="line">        ps.execute();</span><br><span class="line">        //7. 资源的关闭</span><br><span class="line">        ps.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>遇到资源的关闭，还是要用try&#x2F;catch&#x2F;finally处理的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testInsert() &#123;</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        PreparedStatement ps = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            //1. 读取配置文件</span><br><span class="line">            InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;);</span><br><span class="line">            Properties properties = new Properties();</span><br><span class="line">            properties.load(is);</span><br><span class="line">            String user = properties.getProperty(&quot;user&quot;);</span><br><span class="line">            String password = properties.getProperty(&quot;password&quot;);</span><br><span class="line">            String url = properties.getProperty(&quot;url&quot;);</span><br><span class="line">            String className = properties.getProperty(&quot;className&quot;);</span><br><span class="line">            //2. 加载驱动</span><br><span class="line">            Class.forName(className);</span><br><span class="line">            //3. 获取连接</span><br><span class="line">            connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">            //4. 预编译SQL语句，返回PreparedStatement实例</span><br><span class="line">            String sql = &quot;insert into customers(name,email,birth) values(?,?,?)&quot;;</span><br><span class="line">            ps = connection.prepareStatement(sql);</span><br><span class="line">            SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">            Date date =  sdf.parse(&quot;1999-08-11&quot;);</span><br><span class="line">            //5. 填充占位符</span><br><span class="line">            ps.setObject(1,&quot;李四&quot;);</span><br><span class="line">            ps.setObject(2,&quot;lisi@gmail.com&quot;);</span><br><span class="line">            ps.setObject(3,date);</span><br><span class="line">            //6. 执行操作</span><br><span class="line">            ps.execute();</span><br><span class="line">        &#125; catch (IOException | ClassNotFoundException | SQLException | ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //7. 资源的关闭</span><br><span class="line">            if (ps!=null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    ps.close();</span><br><span class="line">                &#125; catch (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (connection!=null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; catch (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>增删改的通用操作<br>注意到增删改都需要建立连接和关闭资源，所以可以将这二者封装成两个方法，写成一个工具类</p><ol><li><p>工具类提供通用的连接数据库和关闭资源的操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import java.io.InputStream;</span><br><span class="line">import java.sql.*;</span><br><span class="line">import java.util.Properties;</span><br><span class="line"></span><br><span class="line">public class JDBCUtil &#123;</span><br><span class="line">    public static Connection getConnection() throws Exception&#123;</span><br><span class="line">        //1. 读取配置文件</span><br><span class="line">        InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;);</span><br><span class="line">        Properties properties = new Properties();</span><br><span class="line">        properties.load(is);</span><br><span class="line">        String user = properties.getProperty(&quot;user&quot;);</span><br><span class="line">        String password = properties.getProperty(&quot;password&quot;);</span><br><span class="line">        String url = properties.getProperty(&quot;url&quot;);</span><br><span class="line">        String className = properties.getProperty(&quot;className&quot;);</span><br><span class="line">        //2. 加载驱动</span><br><span class="line">        Class.forName(className);</span><br><span class="line">        //3. 获取连接</span><br><span class="line">        Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">        return connection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void closeResource(Connection connection, Statement ps)&#123;</span><br><span class="line">        //资源的关闭</span><br><span class="line">        if (connection!=null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (ps!=null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                ps.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>增删改的通用操作</p><p>根据不同的SQL语句和占位符，可以实现任意的增删改操作，由于占位符的个数不确定，所以这里采用可变形参。</p><p>可变形参的底层是一个数组，所以我们可以用args.length来获取形参个数，从而进行遍历填充占位符</p><p>关于可变形参的说明：</p><ul><li><p>1.可变形参的个数可以是0个，1个，任意个</p></li><li><p>2.可变形参的底层就是一个数组</p></li><li><p>3.和可变形参相同类型的数组不构成方法重载</p></li><li><p>4.可变形参只能放在形参列表的最后一个</p></li><li><p>5.在一个形参列表中最多只能有一个可变形参</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void update(String sql, Object ...args) &#123;</span><br><span class="line">    Connection connection = null;</span><br><span class="line">    PreparedStatement ps = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        //1. 获取数据库的连接</span><br><span class="line">        connection = JDBCUtil.getConnection();</span><br><span class="line">        //2. 预编译SQL语句，返回PreparedStatement的实例</span><br><span class="line">        ps = connection.prepareStatement(sql);</span><br><span class="line">        //3. 填充占位符</span><br><span class="line">        for (int i = 0; i &lt; args.length; i++) &#123;</span><br><span class="line">            ps.setObject(i + 1, args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        //4. 执行</span><br><span class="line">        ps.execute();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //5. 资源的关闭</span><br><span class="line">        JDBCUtil.closeResource(connection, ps);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testUpdate() throws Exception&#123;</span><br><span class="line">        // 增</span><br><span class="line">        String sql1 = &quot;insert into customers(name,email,birth) values(?,?,?)&quot;;</span><br><span class="line">        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">        java.util.Date date = sdf.parse(&quot;1997-02-27&quot;);</span><br><span class="line">        update(sql1,&quot;王五&quot;,&quot;wangwu@gmail.com&quot;,date);</span><br><span class="line">        </span><br><span class="line">        // 删</span><br><span class="line">        String sql2 = &quot;delete from customers where id = ?&quot;;</span><br><span class="line">        update(sql2,4);</span><br><span class="line">        </span><br><span class="line">        // 改</span><br><span class="line">        String sql3 = &quot;update `order` set order_name = ? where order_id = ?&quot;;</span><br><span class="line">        update(sql3,&quot;DD&quot;,2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="使用PreparedStatement实现查询操作"><a href="#使用PreparedStatement实现查询操作" class="headerlink" title="使用PreparedStatement实现查询操作"></a>使用PreparedStatement实现查询操作</h3><p>查询操作不同于增删改操作，<strong>查询操作需要我们返回一个对象（多属性）</strong><br>Java中万事万物皆对象，例如我们在SQL中查询到的一条Customers对象，就可以对应一个Java类的对象<br>其中Customers表中的每一个字段，都对应着Java类中的一个属性</p><h4 id="针对Customers表的-不通用的-查询操作"><a href="#针对Customers表的-不通用的-查询操作" class="headerlink" title="针对Customers表的 不通用的 查询操作"></a>针对Customers表的 <code>不通用的</code> 查询操作</h4><ol><li><p>Customers类</p><p>下面是Customers表的描述，暂时无视掉这个photo，根据表的描述建一个Customer类</p><table><thead><tr><th align="center">Field</th><th align="center">Type</th><th align="center">Null</th><th align="center">Key</th><th align="center">Default</th><th align="center">Extra</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">int(10)</td><td align="center">NO</td><td align="center">PRI</td><td align="center"></td><td align="center">auto_increment</td></tr><tr><td align="center">name</td><td align="center">varchar(15)</td><td align="center">YES</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">email</td><td align="center">varchar(20)</td><td align="center">YES</td><td align="center"></td><td align="center"></td><td align="center">auto_increment</td></tr><tr><td align="center">birth</td><td align="center">date</td><td align="center">YES</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">photo</td><td align="center">mediumblob</td><td align="center">YES</td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table></li><li><p>select操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testQuery() throws Exception &#123;</span><br><span class="line">        //1. 获取数据库连接</span><br><span class="line">        Connection connection = JDBCUtil.getConnection();</span><br><span class="line">        //2. 预编译SQL语句，返回PreparedStatement对象实例</span><br><span class="line">        String sql = &quot;select id,name,email,birth from customers where id = ?&quot;;</span><br><span class="line">        PreparedStatement ps = connection.prepareStatement(sql);</span><br><span class="line">        //3. 填充占位符</span><br><span class="line">        ps.setObject(1, 1);</span><br><span class="line">        //4. 执行并返回结果集</span><br><span class="line">        ResultSet rs = ps.executeQuery();</span><br><span class="line">        //5. 处理结果集</span><br><span class="line">        //next():判断结果集的下一条是否有数据，有则返回true，无则返回false</span><br><span class="line">        //如果查询到了多条数据，把if换成while，这里的示例只查询了一条，所以这里用了if</span><br><span class="line">        if (rs.next()) &#123;</span><br><span class="line">            //获取当前数据的各个字段值，上面有Java与SQL对应的数据类型转换表</span><br><span class="line">            int id = rs.getInt(1);</span><br><span class="line">            String name = rs.getString(2);</span><br><span class="line">            String email = rs.getString(3);</span><br><span class="line">            Date date = rs.getDate(4);</span><br><span class="line">            //万事万物皆对象，将数据封装成一个类</span><br><span class="line">            Customer customer = new Customer(id, name, email, date);</span><br><span class="line">            System.out.println(customer);</span><br><span class="line">        &#125;</span><br><span class="line">        //6. 关闭资源，ResultSet也需要关闭，所以在JDBCUtil工具类中，重载一下closeResource方法</span><br><span class="line">        JDBCUtil.closeResource(connection, ps, rs);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>重载一下关闭资源的方法</p><p>由于结果集也需要我们关闭一下，所以在JDBCUtil工具类中，重载一下关闭资源的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static void closeResource(Connection connection, Statement ps,ResultSet rs)&#123;</span><br><span class="line">        //资源的关闭</span><br><span class="line">        if (connection!=null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (ps!=null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                ps.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (rs!=null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="针对Customers表-通用的-查询操作"><a href="#针对Customers表-通用的-查询操作" class="headerlink" title="针对Customers表 通用的 查询操作"></a>针对Customers表 <code>通用的</code> 查询操作</h4><ol><li><p>查询函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public Customer customerForQuery(String sql, Object... args) &#123;</span><br><span class="line">    Connection connection = null;</span><br><span class="line">    PreparedStatement ps = null;</span><br><span class="line">    ResultSet rs = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        //1. 连接数据库</span><br><span class="line">        connection = JDBCUtil.getConnection();</span><br><span class="line">        //2. 预编译SQL语句，获取PreparedStatement实例对象</span><br><span class="line">        ps = connection.prepareStatement(sql);</span><br><span class="line">        //3. 填充占位符</span><br><span class="line">        for (int i = 0; i &lt; args.length; i++) &#123;</span><br><span class="line">            ps.setObject(i + 1, args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        //4. 执行executeQuery()，获得结果集</span><br><span class="line">        rs = ps.executeQuery();</span><br><span class="line">        //5. 获得结果集的元数据</span><br><span class="line">        ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line">        //6. 通过元数据获取ColumnCount，即结果集中有几个列</span><br><span class="line">        int columnCount = rsmd.getColumnCount();</span><br><span class="line">        //7. 如果有数据</span><br><span class="line">        if (rs.next()) &#123;</span><br><span class="line">            //则生成一个对象实例，当然这里可以使用泛型</span><br><span class="line">            Customer customer = new Customer();</span><br><span class="line">            //遍历每一个列</span><br><span class="line">            for (int i = 0; i &lt; columnCount; i++) &#123;</span><br><span class="line">                //8. 获取列值</span><br><span class="line">                Object columnValue = rs.getObject(i + 1);</span><br><span class="line">                //9. 获取列名</span><br><span class="line">                String columnName = rsmd.getColumnName(i + 1);</span><br><span class="line">                //10. 使用反射给相应属性赋值，注意属性都是private的，将Accessible设置为true</span><br><span class="line">                Field field = customer.getClass().getDeclaredField(columnName);</span><br><span class="line">                field.setAccessible(true);</span><br><span class="line">                field.set(customer, columnValue);</span><br><span class="line">            &#125;</span><br><span class="line">            return customer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //11. 资源的关闭</span><br><span class="line">        JDBCUtil.clossResource(connection, ps, rs);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testQuery2() &#123;</span><br><span class="line">        String sql = &quot;select id,name,email,birth from customers where id = ?&quot;;</span><br><span class="line">        Customer customer = customerForQuery(sql, &quot;1&quot;);</span><br><span class="line">        System.out.println(customer);</span><br><span class="line">        //Customer&#123;id=1, name=&#x27;汪峰&#x27;, email=&#x27;wf@126.com&#x27;, birth=2010-02-02&#125;</span><br><span class="line"></span><br><span class="line">        sql = &quot;select name,birth from customers where name = ?&quot;;</span><br><span class="line">        customer = customerForQuery(sql,&quot;周杰伦&quot;);</span><br><span class="line">        System.out.println(customer);</span><br><span class="line">        //Customer&#123;id=0, name=&#x27;周杰伦&#x27;, email=&#x27;null&#x27;, birth=1979-11-15&#125;</span><br><span class="line">        //这里只查询了两个字段，故查询结果中的其他字段为默认值        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="针对Order表-通用的-查询操作"><a href="#针对Order表-通用的-查询操作" class="headerlink" title="针对Order表 通用的 查询操作"></a>针对Order表 <code>通用的</code> 查询操作</h4><ol><li><p>order类</p><p>根据下表创建一个Order类，但<strong>SQL中的命名方式与Java中的命名方式不一样</strong>，我们按照Java中的命名方式即可，但是这样会导致反射时找不到对应的字段名去赋值。解决办法也很简单，<strong>在SQL查询语句中，可以给列起别名，将别名设定为Java中的命名方式即可</strong>，获取元数据的时候，使用getColumnLabel()方法来获取列的别名，这样就完美解决了这二者不同的命名方式产生的问题</p><table><thead><tr><th align="center">Field</th><th align="center">Type</th><th align="center">Null</th><th align="center">Key</th><th align="center">Default</th><th align="center">Extra</th></tr></thead><tbody><tr><td align="center">order_id</td><td align="center">int(10)</td><td align="center">NO</td><td align="center">PRI</td><td align="center"></td><td align="center">auto_increment</td></tr><tr><td align="center">order_name</td><td align="center">varchar(20)</td><td align="center">YES</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">order_date</td><td align="center">date</td><td align="center">YES</td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class Order &#123;</span><br><span class="line">    private int orderId;</span><br><span class="line">    private String orderName;</span><br><span class="line">    private Date orderDate;</span><br><span class="line"></span><br><span class="line">    public int getorderId() &#123;</span><br><span class="line">        return orderId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setorderId(int orderId) &#123;</span><br><span class="line">        this.orderId = orderId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getorderName() &#123;</span><br><span class="line">        return orderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setorderName(String orderName) &#123;</span><br><span class="line">        this.orderName = orderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Date getorderDate() &#123;</span><br><span class="line">        return orderDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setorderDate(Date orderDate) &#123;</span><br><span class="line">        this.orderDate = orderDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Order(int orderId, String orderName, Date orderDate) &#123;</span><br><span class="line">        this.orderId = orderId;</span><br><span class="line">        this.orderName = orderName;</span><br><span class="line">        this.orderDate = orderDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Order() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Order&#123;&quot; +</span><br><span class="line">                &quot;orderId=&quot; + orderId +</span><br><span class="line">                &quot;, orderName=&#x27;&quot; + orderName + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, orderDate=&quot; + orderDate +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>queryForOrder</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public Order queryForOrder(String sql, Object... args) &#123;</span><br><span class="line">    Connection connection = null;</span><br><span class="line">    PreparedStatement ps = null;</span><br><span class="line">    ResultSet rs = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        connection = JDBCUtil.getConnection();</span><br><span class="line">        ps = connection.prepareStatement(sql);</span><br><span class="line">        for (int i = 0; i &lt; args.length; i++) &#123;</span><br><span class="line">            ps.setObject(i + 1, args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        rs = ps.executeQuery();</span><br><span class="line">        ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line">        int columnCount = rsmd.getColumnCount();</span><br><span class="line">        if (rs.next()) &#123;</span><br><span class="line">            Order order = new Order();</span><br><span class="line">            for (int i = 0; i &lt; columnCount; i++) &#123;</span><br><span class="line">                //这里改成了getColumnLabel来获取别名，如果未给列取别名，那么别名就是列名</span><br><span class="line">                String columnLabel = rsmd.getColumnLabel(i + 1);</span><br><span class="line">                Object columnValue = rs.getObject(i + 1);</span><br><span class="line">                //别名与Java中命名方式相同，所以反射的时候通过别名来找到对应字段值来赋值</span><br><span class="line">                Field field = order.getClass().getDeclaredField(columnLabel);</span><br><span class="line">                field.setAccessible(true);</span><br><span class="line">                field.set(order, columnValue);</span><br><span class="line">            &#125;</span><br><span class="line">            return order;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        JDBCUtil.clossResource(connection, ps, rs);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testQuery() &#123;</span><br><span class="line">        String sql = &quot;select order_name as orderName,order_date as orderDate from `order` where order_id = ?&quot;;</span><br><span class="line">        Order order = queryForOrder(sql, 2);</span><br><span class="line">        System.out.println(order);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>当表的字段名和类的属性名不同时：</p><ul><li>1.在声明sql时，使用类的属性名来命名字段的别名</li><li>2.使用ResultSetMetaData的getColumnLabel()方法来替代getColumnName()方法，获得列的列名的别名。</li><li>3.说明：没有别名时，getColumnLabel()方法获取的就是列名；所以无论有没有别名，都使用getColumnLabel()方法</li></ul></blockquote><h4 id="通用的查询操作，但只返回一条记录"><a href="#通用的查询操作，但只返回一条记录" class="headerlink" title="通用的查询操作，但只返回一条记录"></a><code>通用的</code>查询操作，但只返回一条记录</h4><ol><li><p>通用的查询操作</p><p>利用泛型方法来解决</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T getInstance(Class&lt;T&gt; clazz, String sql, Object... args) &#123;</span><br><span class="line">    Connection connection = null;</span><br><span class="line">    PreparedStatement ps = null;</span><br><span class="line">    ResultSet rs = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        connection = JDBCUtil.getConnection();</span><br><span class="line">        ps = connection.prepareStatement(sql);</span><br><span class="line">        for (int i = 0; i &lt; args.length; i++) &#123;</span><br><span class="line">            ps.setObject(i + 1, args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        rs = ps.executeQuery();</span><br><span class="line">        if (rs.next()) &#123;</span><br><span class="line">            T t = clazz.newInstance();</span><br><span class="line">            ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line">            int columnCount = rsmd.getColumnCount();</span><br><span class="line">            for (int i = 0; i &lt; columnCount; i++) &#123;</span><br><span class="line">                Object columnValue = rs.getObject(i + 1);</span><br><span class="line">                String columnLabel = rsmd.getColumnLabel(i + 1);</span><br><span class="line">                Field field = t.getClass().getDeclaredField(columnLabel);</span><br><span class="line">                field.setAccessible(true);</span><br><span class="line">                field.set(t, columnValue);</span><br><span class="line">            &#125;</span><br><span class="line">            return t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        JDBCUtil.clossResource(connection, ps, rs);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void queryTest() &#123;</span><br><span class="line">        String sql1 = &quot;select order_id as orderId,order_name as orderName,order_date as orderDate from `order` where order_id = ?&quot;;</span><br><span class="line">        Order order = getInstance(Order.class, sql1, 1);</span><br><span class="line">        System.out.println(order);</span><br><span class="line"></span><br><span class="line">        String sql2 = &quot;select id,name,email,birth from customers where id = ?&quot;;</span><br><span class="line">        Customer customer = getInstance(Customer.class, sql2, 7);</span><br><span class="line">        System.out.println(customer);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="通用的查询操作，返回多条记录"><a href="#通用的查询操作，返回多条记录" class="headerlink" title="通用的查询操作，返回多条记录"></a><code>通用的</code>查询操作，返回多条记录</h4><p>只需要在返回一条记录的基础上，修改一些代码即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">//把返回类型改为集合</span><br><span class="line">public &lt;T&gt; ArrayList&lt;T&gt; getForList(Class&lt;T&gt; clazz, String sql, Object... args)&#123;</span><br><span class="line">    Connection connection = null;</span><br><span class="line">    PreparedStatement ps = null;</span><br><span class="line">    ResultSet rs = null;</span><br><span class="line">    ArrayList&lt;T&gt; ts = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        connection = JDBCUtil.getConnection();</span><br><span class="line">        ps = connection.prepareStatement(sql);</span><br><span class="line">        for (int i = 0; i &lt; args.length; i++) &#123;</span><br><span class="line">            ps.setObject(i + 1, args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        rs = ps.executeQuery();</span><br><span class="line">        ts = new ArrayList&lt;&gt;();</span><br><span class="line">        ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line">        int columnCount = rsmd.getColumnCount();</span><br><span class="line">        //这里的if改成while</span><br><span class="line">        while (rs.next()) &#123;</span><br><span class="line">            T t = clazz.newInstance();</span><br><span class="line">            for (int i = 0; i &lt; columnCount; i++) &#123;</span><br><span class="line">                Object columnValue = rs.getObject(i + 1);</span><br><span class="line">                String columnLabel = rsmd.getColumnLabel(i + 1);</span><br><span class="line">                Field field = t.getClass().getDeclaredField(columnLabel);</span><br><span class="line">                field.setAccessible(true);</span><br><span class="line">                field.set(t, columnValue);</span><br><span class="line">            &#125;</span><br><span class="line">            //没查询完一条数据，将其加入到集合中</span><br><span class="line">            ts.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">        return ts;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        JDBCUtil.clossResource(connection, ps, rs);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询Customers表中id小于某个值的所有数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">@Test</span><br><span class="line">    public void queryTest() &#123;</span><br><span class="line">        String sql = &quot;select id,name,email,birth from customers where id &lt; ?&quot;;</span><br><span class="line">        ArrayList&lt;Customer&gt; ts = getForList(Customer.class,sql, 13);</span><br><span class="line">        for (Customer c : ts) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="使用PreparedStatement代替Statement原因："><a href="#使用PreparedStatement代替Statement原因：" class="headerlink" title="使用PreparedStatement代替Statement原因："></a>使用PreparedStatement代替Statement原因：</h3><ol><li>PreparedStatement是预编译的sql语句，可以解决Statement的拼串和sql注入问题；<ul><li>PreparedStatement首先确定了语法逻辑，然后填充相应的数值；</li><li>而Statement会连着数值里包含的非法语法一起编译，就会造成对原来语法逻辑的破坏。</li></ul></li><li>PreparedStatement还可以操作Blob类型的数据，而Statement不行；</li><li>PreparedStatement可以实现跟高效的批量操作：<ul><li>如果访问10000条数据，PreparedStatement会将语法固定，只用填充占位符就好了。</li></ul></li></ol><h2 id="JDBC-API小结"><a href="#JDBC-API小结" class="headerlink" title="JDBC API小结"></a>JDBC API小结</h2><p>两种思想</p><ul><li>面向接口编程的思想</li><li>ORM思想(object relational mapping)<ul><li>一个数据表对应一个java类</li><li>表中的一条记录对应java类的一个对象</li><li>表中的一个字段对应java类的一个属性</li></ul></li></ul><p>sql是需要结合列名和表的属性名来写。注意起别名。</p><p>两种技术</p><ul><li>JDBC结果集的元数据：ResultSetMetaData<ul><li>获取列数：getColumnCount()</li><li>获取列的别名：getColumnLabel()</li></ul></li><li>通过反射，创建指定类的对象，获取指定的属性并赋值</li></ul><h1 id="操作BLOB类型字段"><a href="#操作BLOB类型字段" class="headerlink" title="操作BLOB类型字段"></a>操作BLOB类型字段</h1><h2 id="MySQL-BLOB类型"><a href="#MySQL-BLOB类型" class="headerlink" title="MySQL BLOB类型"></a>MySQL BLOB类型</h2><p>MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。</p><p>插入BLOB类型的数据<strong>必须使用PreparedStatement</strong>，因为BLOB类型的数据无法使用字符串拼接写的。</p><p>MySQL的四种BLOB类型除了在存储的最大信息量上不同外，他们是等同的</p><table><thead><tr><th align="center">类型</th><th align="center">大小{单位:字节)</th></tr></thead><tbody><tr><td align="center">TINYBLOB</td><td align="center">最大255</td></tr><tr><td align="center">BLOB</td><td align="center">最大65K</td></tr><tr><td align="center">MEDIUMBLOB</td><td align="center">最大16M</td></tr><tr><td align="center">LONGBLOB</td><td align="center">最大4G</td></tr></tbody></table><blockquote><p>但实际上packet 有大小限制，超过1M 还是会报错</p><p>如果在指定了相关的Blob类型以后，还报错：xxx too large，那么在mysql的安装目录下，找my.ini文件加上如下的配置参数： max_allowed_packet&#x3D;16M。</p><p>同时注意：修改了my.ini文件之后，需要重新启动mysql服务。</p></blockquote><p>实际使用中根据需要存入的数据大小定义不同的BLOB类型。</p><p>需要注意的是：如果存储的文件过大，数据库的性能会下降。</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>向数据表中插入大数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void blobTest() &#123;</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        PreparedStatement ps = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            String sql = &quot;insert into customers(name,email,birth,photo) values(?,?,?,?)&quot;;</span><br><span class="line">            //获取连接</span><br><span class="line">            connection = JDBCUtil.getConnection();</span><br><span class="line">            //预编译SQL语句，获取prepareStatement实例对象</span><br><span class="line">            ps = connection.prepareStatement(sql);</span><br><span class="line">            //填充占位符</span><br><span class="line">            ps.setObject(1, &quot;Kyle&quot;);</span><br><span class="line">            ps.setObject(2, &quot;Kyle@126.com&quot;);</span><br><span class="line">            ps.setObject(3, &quot;1997-08-07&quot;);</span><br><span class="line">            //操作Blob类型变量</span><br><span class="line">            ps.setBlob(4, new FileInputStream(&quot;头像.png&quot;));</span><br><span class="line">            //执行</span><br><span class="line">            ps.execute();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            JDBCUtil.clossResource(connection, ps);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><p>从数据表中读取大数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void blobTest2() &#123;</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        PreparedStatement ps = null;</span><br><span class="line">        ResultSet rs = null;</span><br><span class="line">        InputStream is = null;</span><br><span class="line">        OutputStream os = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            String sql = &quot;select id,name,email,birth,photo from customers where id = ?&quot;;</span><br><span class="line">            connection = JDBCUtil.getConnection();</span><br><span class="line">            ps = connection.prepareStatement(sql);</span><br><span class="line">            ps.setObject(1, 16);</span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line">            if (rs.next())&#123;</span><br><span class="line">                int id = rs.getInt(&quot;id&quot;);</span><br><span class="line">                String name = rs.getString(&quot;name&quot;);</span><br><span class="line">                String email = rs.getString(&quot;email&quot;);</span><br><span class="line">                Date birth = rs.getDate(&quot;birth&quot;);</span><br><span class="line">                Customer customer = new Customer(id, name, email, birth);</span><br><span class="line">                System.out.println(customer);</span><br><span class="line">                Blob photo = rs.getBlob(&quot;photo&quot;);</span><br><span class="line">                is = photo.getBinaryStream();</span><br><span class="line">                os = new FileOutputStream(&quot;照片.png&quot;);</span><br><span class="line">                byte[] buffer = new byte[1024];</span><br><span class="line">                int len;</span><br><span class="line">                while ((len = is.read(buffer)) != -1) &#123;</span><br><span class="line">                    os.write(buffer, 0, len);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (is != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (os != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            JDBCUtil.clossResource(connection, ps, rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h2><h3 id="批量执行SQL语句"><a href="#批量执行SQL语句" class="headerlink" title="批量执行SQL语句"></a>批量执行SQL语句</h3><p>当需要成批插入或者更新记录时，可以采用 Java的<code>批量更新</code>机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率</p><p>JDBC的批量处理语句包括下面三个方法：</p><ul><li>addBatch(String)：添加需要批量处理的SQL语句或是参数；</li><li>executeBatch()：执行批量处理语句；</li><li>clearBatch():清空缓存的数据</li></ul><p>通常我们会遇到两种批量执行SQL语句的情况：</p><ul><li>多条SQL语句的批量处理；</li><li>一个SQL语句的批量传参；</li></ul><h3 id="高效的批量插入"><a href="#高效的批量插入" class="headerlink" title="高效的批量插入"></a>高效的批量插入</h3><p>举例：向数据表中插入20000条数据</p><ul><li><p>首先先创建一个goods表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE goods(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">`name` VARCHAR(25)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><p>下面是四种实现方式，效率逐渐提高，都是基于低层次实现的优化</p><ol><li><p>使用Statement</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//耗时：15006ms</span><br><span class="line">@Test</span><br><span class="line">    public void testInsert01() &#123;</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        Statement st = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            connection = JDBCUtil.getConnection();</span><br><span class="line">            st = connection.createStatement();</span><br><span class="line">            long start = System.currentTimeMillis();</span><br><span class="line">            for (int i = 1; i &lt;= 20000; i++) &#123;</span><br><span class="line">                String sql = &quot;insert into goods(name) values(&#x27;name_ &quot; + i + &quot;&#x27;)&quot;;</span><br><span class="line">                st.executeUpdate(sql);</span><br><span class="line">            &#125;</span><br><span class="line">            long end = System.currentTimeMillis();</span><br><span class="line">            System.out.println(&quot;耗时：&quot; + (end - start)  + &quot;ms&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            JDBCUtil.clossResource(connection, st);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>使用PreparedStatement</p><p>PreparedStatement优于Statement的地方：</p><ul><li>在于sql语句Statement内存中会有很多个sql语句，并且每次都会做一次语法检查，而PreparedStatement只有一个sql语句，每次只是填充占位符。（预编译）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testInsert02()&#123;</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        PreparedStatement ps = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            String sql = &quot;insert into goods(name) values(?)&quot;;</span><br><span class="line">            connection = JDBCUtil.getConnection();</span><br><span class="line">            ps = connection.prepareStatement(sql);</span><br><span class="line">            long start = System.currentTimeMillis();</span><br><span class="line">            for (int i = 0; i &lt; 20000; i++) &#123;</span><br><span class="line">                ps.setObject(1, &quot;name_&quot; + i);</span><br><span class="line">            &#125;</span><br><span class="line">            long end = System.currentTimeMillis();</span><br><span class="line">            System.out.println(&quot;耗时：&quot; + (end - start) + &quot;ms&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            JDBCUtil.clossResource(connection, ps);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>相较于实现层次二的优点：</p><p>使用Batch批量处理：addBatch()、executeBatch()、clearBatch()</p><p>mysql服务器默认是关闭批处理的，我们需要通过一个参数，让mysql开启批处理的支持。在jdbc.properties配置文件的url后添上：?rewriteBatchedStatements&#x3D;true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//耗时：196ms</span><br><span class="line">@Test</span><br><span class="line">    public void testInsert03() &#123;</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        PreparedStatement ps = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            String sql = &quot;insert into goods(name) values(?)&quot;;</span><br><span class="line">            connection = JDBCUtil.getConnection();</span><br><span class="line">            ps = connection.prepareStatement(sql);</span><br><span class="line">            long start = System.currentTimeMillis();</span><br><span class="line">            for (int i = 0; i &lt; 20000; i++) &#123;</span><br><span class="line">                ps.setObject(1, &quot;name_&quot; + i);</span><br><span class="line">                //1.“攒”sql</span><br><span class="line">                ps.addBatch();</span><br><span class="line">                if (i % 10000 == 0)&#123;</span><br><span class="line">                    //2.执行</span><br><span class="line">                    ps.executeBatch();</span><br><span class="line">                    //3.清空</span><br><span class="line">                    ps.clearBatch();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            long end = System.currentTimeMillis();</span><br><span class="line">            System.out.println(&quot;耗时：&quot; + (end - start) + &quot;ms&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            JDBCUtil.clossResource(connection, ps);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><ul><li>每500条数据执行一次ps.executeBatch();</li><li>这样每500条就会提交一次。</li><li>但每次提交都会占用一点时间，所以先不提交，都传完以后，最后再提交。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//耗时：157ms</span><br><span class="line">@Test</span><br><span class="line">    public void testInsert04() &#123;</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        PreparedStatement ps = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            String sql = &quot;insert into goods(name) values(?)&quot;;</span><br><span class="line">            connection = JDBCUtil.getConnection();</span><br><span class="line">            //1.设置为不自动提交数据</span><br><span class="line">            connection.setAutoCommit(false);</span><br><span class="line">            ps = connection.prepareStatement(sql);</span><br><span class="line">            long start = System.currentTimeMillis();</span><br><span class="line">            for (int i = 0; i &lt; 20000; i++) &#123;</span><br><span class="line">                ps.setObject(1, &quot;name_&quot; + i);</span><br><span class="line">                //1.“攒”sql</span><br><span class="line">                ps.addBatch();</span><br><span class="line">                if (i % 10000 == 0)&#123;</span><br><span class="line">                    //2.执行</span><br><span class="line">                    ps.executeBatch();</span><br><span class="line">                    //3.清空</span><br><span class="line">                    ps.clearBatch();</span><br><span class="line">            &#125;</span><br><span class="line">            //2.提交数据</span><br><span class="line">            connection.commit();</span><br><span class="line">            long end = System.currentTimeMillis();</span><br><span class="line">            System.out.println(&quot;耗时：&quot; + (end - start) + &quot;ms&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            JDBCUtil.clossResource(connection, ps);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h1><h2 id="数据库事务介绍"><a href="#数据库事务介绍" class="headerlink" title="数据库事务介绍"></a>数据库事务介绍</h2><p>事务：一组逻辑操作单元,使数据从一种状态变换到另一种状态。</p><p>事务处理（事务操作）：</p><p>保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交(<code>commit</code>)，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务回滚(<code>rollback</code>)到最初状态。</p><p>为确保数据库中数据的一致性，数据的操纵应当是离散的成组的逻辑单元：当它全部完成时，数据的一致性可以保持，而当这个单元中的一部分操作失败，整个事务应全部视为错误，所有从起始点以后的操作应全部回退到开始状态。</p><h2 id="JDBC事务处理"><a href="#JDBC事务处理" class="headerlink" title="JDBC事务处理"></a>JDBC事务处理</h2><p>数据一旦提交，就不可回滚。</p><p>哪些操作会导致数据的自动提交？</p><ul><li>DDL操作一旦执行，都会自动提交；<code>set autocommit = false</code>对操作失效；</li><li>DML默认情况下，一旦执行，就会自动提交；但我们可以通过<code>set autocommit = false</code>的方式取消DML操作的自动提交；</li><li>关闭连接的时候也会默认自动提交</li></ul><p>JDBC程序中为了让多个 SQL 语句作为一个事务执行：</p><ul><li>调用 Connection 对象的 <code>setAutoCommit(false);</code> 以取消自动提交事务</li><li>在所有的 SQL 语句都成功执行后，调用 <code>commit();</code> 方法提交事务</li><li>在出现异常时，调用 <code>rollback();</code> 方法回滚事务</li></ul><blockquote><p>若此时 Connection 没有被关闭，还可能被重复使用，则需要恢复其自动提交状态<code>setAutoCommit(true)</code>。尤其是在使用数据库连接池技术时，执行close()方法前，建议恢复自动提交状态。</p></blockquote><h2 id="事务的ACID属性"><a href="#事务的ACID属性" class="headerlink" title="事务的ACID属性"></a>事务的ACID属性</h2><ol><li>原子性（Atomicity） 原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</li><li>一致性（Consistency） 事务必须使数据库从一个一致性状态变换到另外一个一致性状态。</li><li>隔离性（Isolation） 事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</li><li>持久性（Durability） 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。</li></ol><h2 id="数据库的并发问题"><a href="#数据库的并发问题" class="headerlink" title="数据库的并发问题"></a>数据库的并发问题</h2><p>对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:</p><ul><li>脏读：对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。</li><li>不可重复读：对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段。之后, T1再次读取同一个字段, 值就不同了。（例如在购物网站刷新界面，库存可能会增加或减少）</li><li>幻读：对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插入了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。（刷新购物网站，多了几条新商品）</li></ul><p>数据库事务的隔离性:数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。</p><p>一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高</p><h4 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h4><p>数据库提供的4种事务隔离级别：</p><table><thead><tr><th align="center">隔离级别</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">READ UNCOMMITTED (读未提交数据)</td><td align="center">允许事务读取未被其他事物提交的变更.脏读,不可重复读和幻读的问题都会出现</td></tr><tr><td align="center">READ COMMITED (读已提交数据)</td><td align="center">只允许事务读取已经被其它事务提交的变更.可以避免脏读,但不可重复读和幻读问题仍然可能出现</td></tr><tr><td align="center">REPEATABLE READ (可重复读)</td><td align="center">确保事务可以多次从一个字段中读取相同的值.在这个事务持续期间, 禁止其他事物对这个字段进行更新.可以避免脏读和不可重复读,但幻读的问题仍然存在.</td></tr><tr><td align="center">SERIALIZABLE (串行化)</td><td align="center">执行插入,更新和删除操作.所有并发问题都可以避免, 但性能十分低下确保事务可以从一个表中读取相同的行.在这个事务持续期间,禁止其他事务对该表</td></tr></tbody></table><ul><li>Oracle 支持的 2 种事务隔离级别：<code>READ COMMITED</code>, <code>SERIALIZABLE</code>。 Oracle 默认的事务隔离级别为: <code>READ COMMITED</code> 。</li><li>Mysql 支持 4 种事务隔离级别。Mysql 默认的事务隔离级别为: <code>REPEATABLE READ</code>。</li></ul><h3 id="在MySql中设置隔离级别"><a href="#在MySql中设置隔离级别" class="headerlink" title="在MySql中设置隔离级别"></a>在MySql中设置隔离级别</h3><p>每启动一个 mysql 程序, 就会获得一个单独的数据库连接. 每个数据库连接都有一个全局变量 @@tx_isolation,表示当前的事务隔离级别。</p><ul><li>查看当前的隔离级别:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@tx_isolation;</span><br></pre></td></tr></table></figure><ul><li>设置当前 mySQL 连接的隔离级别:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br></pre></td></tr></table></figure><ul><li>设置数据库系统的全局的隔离级别:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br></pre></td></tr></table></figure><h3 id="在Java代码中设置隔离级别"><a href="#在Java代码中设置隔离级别" class="headerlink" title="在Java代码中设置隔离级别"></a>在Java代码中设置隔离级别</h3><p>使用getTransactionIsolation()可以获得当前隔离级别的int值，对应如下</p><ul><li>int TRANSACTION_READ_UNCOMMITTED &#x3D; 1;</li><li>int TRANSACTION_READ_COMMITTED &#x3D; 2;</li><li>int TRANSACTION_REPEATABLE_READ &#x3D; 4;</li><li>int TRANSACTION_SERIALIZABLE &#x3D; 8;</li></ul><p>使用setTransactionIsolation可以设置隔离级别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testTransactionUpdate() throws Exception&#123;</span><br><span class="line">        Connection connection = JDBCUtil.getConnection();</span><br><span class="line">        //获取数据库隔离级别</span><br><span class="line">        System.out.println(connection.getTransactionIsolation());</span><br><span class="line">        //设置数据库隔离级别</span><br><span class="line">        connection.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);</span><br><span class="line">        String sql = &quot;update user_table set balance = ? where user = ?&quot;;</span><br><span class="line">        update(sql,5000,&quot;CC&quot;);</span><br><span class="line">        System.out.println(&quot;修改结束&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="DAO及相关实现类"><a href="#DAO及相关实现类" class="headerlink" title="DAO及相关实现类"></a>DAO及相关实现类</h1><p>DAO：Data Access Object 访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息。有时也称作：BaseDAO</p><p>作用：为了实现功能的模块化，更有利于代码的维护和升级</p>]]></content>
      
      
      <categories>
          
          <category> JDBC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDBC </tag>
            
            <tag> 数据库 </tag>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-线性表</title>
      <link href="/2023/06/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.2/"/>
      <url>/2023/06/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.2/</url>
      
        <content type="html"><![CDATA[<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="线性表定义"><a href="#线性表定义" class="headerlink" title="线性表定义"></a>线性表定义</h2><p>线性表是具有<strong>相同数据类型</strong>的n (n≥0) 个数据元素的有限序列，其中n为表长，当n&#x3D; 0时线性表是一个空表。若用L命名线性表，则其一般表示为：L &#x3D; （a1 ,a2 ,a3 …  ,an ,）</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230624160546.png"></p><p>ai是线性表中的“第i个”元素线性表中的位序,a1是表头元素 ,an 是表尾元素</p><p>除第一个元素外，每个元素有且仅有一个直接前驱:除最后一个元素外，每个元素有且仅有一个直接后继</p><h2 id="线性表基本操作"><a href="#线性表基本操作" class="headerlink" title="线性表基本操作"></a>线性表基本操作</h2><p>InitList(&amp;L):初始化表。构造-一个空的线性表L，分配内存空间。</p><p>DestroyList(&amp;L);销毁操作。销毁线性表，并释放线性表L所占用的内存空间。</p><p>ListInsert(&amp;L,i,e):插入操作。在表L中的第i个位置上插入指定元素e。</p><p>ListDelete(&amp;L,&amp;e):删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。</p><p>LocateElem():按值查找操作。在表L中查找具有给定关键字值的元素。</p><p>GetElem(,):按位查找操作。获取表L中第1个位置的元素的值。</p><p>其他常用操作:</p><p>Length(L):求表长。返回线性表L的长度，即L中数据元素的个数。</p><p>PrintList(L):输出操作。按前后顺序输出线性表L的所有元素值。</p><p>Empty(L):判空操作。若l为空表，则返回true,否则返回false.</p><blockquote><p>对数据的操作(记忆思路)：创销、增删改查</p></blockquote><h2 id="线性表实现-顺序表（顺序存储）"><a href="#线性表实现-顺序表（顺序存储）" class="headerlink" title="线性表实现-顺序表（顺序存储）"></a>线性表实现-顺序表（顺序存储）</h2><p>顺序表：用顺序存储的方式实现线性表</p><blockquote><p>顺序存储：把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。</p></blockquote><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230624160546.png"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230624163153.png"></p><h3 id="顺序表的实现"><a href="#顺序表的实现" class="headerlink" title="顺序表的实现"></a>顺序表的实现</h3><p>静态分配</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230624164126.png"></p><p>动态分配</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230625125620.png"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230625125704.png"></p><p>顺序表特点</p><ol><li>随机访问，即可以在0(1)时间内找到第i个元素</li><li>存储密度高，每个节颜存储数据元素</li><li>拓展容量不方便(即便采用动态分配的方式实现，拓展长度的时间复杂度也比较高)</li><li>插入、删除操作不方便，需要移动大量元素</li></ol><h2 id="线性表实现-链表（链式存储）"><a href="#线性表实现-链表（链式存储）" class="headerlink" title="线性表实现-链表（链式存储）"></a>线性表实现-链表（链式存储）</h2>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-绪论</title>
      <link href="/2023/06/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.1/"/>
      <url>/2023/06/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.1/</url>
      
        <content type="html"><![CDATA[<h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><h2 id="数据-Data"><a href="#数据-Data" class="headerlink" title="数据(Data)"></a>数据(Data)</h2><p>数据：是能输入计算机且能被计算机处理的各种符号的集合</p><p>包括:</p><ol><li>数值型的数据:整数、实数等</li><li>非数值型的数据:文字、图像、图形、声音</li></ol><h2 id="数据元素-Data-Element"><a href="#数据元素-Data-Element" class="headerlink" title="数据元素(Data Element)"></a>数据元素(Data Element)</h2><p>数据元素：是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理。也简称为<strong>元素</strong>，或称为<strong>记录</strong>、结点或<strong>顶点</strong>。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230605180351.png"></p><h2 id="数据项-Data-Item"><a href="#数据项-Data-Item" class="headerlink" title="数据项(Data Item)"></a>数据项(Data Item)</h2><p>数据项：构成数据元素的不可分割的最小单位。</p><blockquote><p>数据、数据元素、数据项三者之间的关系：</p><p>数据 &gt; 数据元素 &gt; 数据项</p></blockquote><h2 id="数据对象-Data-Object"><a href="#数据对象-Data-Object" class="headerlink" title="数据对象(Data Object)"></a>数据对象(Data Object)</h2><p>数据对象：是性质相同的数据元素的集合，是数据的一个子集。</p><p>例如:</p><ul><li>整数数据对象是集合N&#x3D;{0， +1， +2， …</li><li>字母字符数据对象是集合C&#x3D;{‘A’，’B’，’Z’}</li><li>学籍表也可看作一个数据对象</li></ul><p>数据元素：组成数据的基本单位</p><p>与数据的关系:是集合的个体</p><p>数据对象：性质相同的数据元素的集合</p><p>与数据的关系是:集合的子集</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>数据元素不是孤立存在的，它们之间存在着某种关系，<strong>数据元素相互之间的关系称为结构</strong>( Structure )<br>，是指<strong>相互之间存在一种或多种特定关系</strong>的数据元素集合。或者说，数据结构是<strong>带结构的</strong>数据元素的集合</p><p>数据结构包括以下三个方面的内容:</p><ol><li>数据元素之间的<strong>逻辑关系</strong>，也称为<strong>逻辑结构</strong>。</li><li>数据元素及其关系在<strong>计算机内存中的表示</strong>(又称为<strong>映像</strong>)， 称为数据的<strong>物理结构</strong>或数据的<strong>存储结构</strong>。</li><li>数据的<strong>运算和实现</strong>，即对数据元素可以施加的操作以及这些操作在相应的存储结构上的实现。</li></ol><p>逻辑结构</p><ul><li>描述数据元素之间的逻辑关系</li><li>与数据的存储无关，独立于计算机</li><li>是从具体问题抽象出来的数学模型</li></ul><p>物理结构</p><ul><li>数据元素及其关系在计算机存储器中的结构(存储方式)</li><li>是数据结构在计算机中的表示</li></ul><p>逻辑结构与存储结构的关系:</p><ul><li>存储结构是逻辑关系的映象与元素本身的映象。</li><li>逻辑结构是数据结构的抽象，存储结构是数据结构的实现</li></ul><h2 id="逻辑结构的种类"><a href="#逻辑结构的种类" class="headerlink" title="逻辑结构的种类"></a>逻辑结构的种类</h2><p>划分一：</p><ol><li>线性结构（一对一）</li></ol><p>有且仅有一一个开始和一个终端结点，并且所有结点都最多只有一个直接前趋和一个直接后继。<br>例如：线性表、栈、队列、串</p><ol start="2"><li>非线性结构（一对多  多对多）</li></ol><p>一个个结点可能有多个直接前趋和直接后继<br>例如:树、图</p><p>划分方式二一四类基本逻辑结构</p><ol><li>集合结构:结构中的数据元素之间除了同属于一个集合的关系外，无任何其它关系。</li><li>线性结构:结构中的数据元素之间存在着一对一的线性关系。</li><li>树形结构:结构中的数据元素之间存在着一对多的层次关系。</li><li>图状结构或网状结构:结构中的数据元素之间存在着多对多的任意关系。</li></ol><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230605180429.png"></p><h2 id="存储结构的种类"><a href="#存储结构的种类" class="headerlink" title="存储结构的种类"></a>存储结构的种类</h2><p>四种基本的存储结构:</p><ol><li><p>顺序存储结构<br>用一组连续的存储单元依次存储数据元素，数据元素之间的逻辑关系由元素的存储位置来表示。</p></li><li><p>链式存储结构<br>用一组任意的存储单元存储数据元素，数据元素之间的逻辑关系用指针来表示。</p></li><li><p>索引存储结构<br>在存储结点信息的同时，还建立附加的索引表。</p></li><li><p>散列存储结构<br>根据结点的关键字直接计算出该结点的存储地址。</p></li></ol><h1 id="数据类型和抽象数据类型"><a href="#数据类型和抽象数据类型" class="headerlink" title="数据类型和抽象数据类型"></a>数据类型和抽象数据类型</h1><p>在使用高级程序设计语言编写程序时，必须对程序中出现的每个变量、常量或表达式，明确说明它们所属的数据类型。</p><p>一些最基本数据结构可以用数据类型来实现，如数组、字符串等;而另一些常用的数据结构，如栈、队列、树、图等，不能直接用数据类型来表示。</p><p>高级语言中的数据类型明显地或隐含地规定了在程序执行期间变量和表达的所有可能的取值范围，以及在这些数值范围上所允许进行的操表达的所有可能的取值范围，以及在这些数值范围上所允许进行的操作。</p><ul><li>例如，C语言中定义变量i为int类型，就表示i是[-min,max]范围的整数，在这个整数集上可以进行+、一、*、\、 %等操作</li></ul><p>数据类型的作用：</p><ol><li>约束变量或常量的取值范围。</li><li>约束变量或常量的操作。</li></ol><h2 id="数据类型-Data-Type"><a href="#数据类型-Data-Type" class="headerlink" title="数据类型(Data Type)"></a>数据类型(Data Type)</h2><p>定义:数据类型是一组性质相同的值的集合以及定义于这个值集合上的一组操作的总称。</p><p><strong>数据类型 &#x3D; 值的集合 + 值集合上的一组操作</strong></p><h2 id="抽象数据类型-Abstract-Data-Type-ADT"><a href="#抽象数据类型-Abstract-Data-Type-ADT" class="headerlink" title="抽象数据类型(Abstract Data Type, ADT)"></a>抽象数据类型(Abstract Data Type, ADT)</h2><p>是指一个数学模型以及定义在此数学模型.上的一-组操作。</p><p>包括：</p><ol><li>由用户定义，从问题抽象出数据模型(逻辑结构)</li><li>还包括定义在数据模型上的一组抽象运算(相关操作)</li><li>不考虑计算机内的具体存储结构与运算的具体实现算法</li></ol><h3 id="抽象数据类型的形式定义"><a href="#抽象数据类型的形式定义" class="headerlink" title="抽象数据类型的形式定义"></a>抽象数据类型的形式定义</h3><p>抽象数据类型可用(D, S, P)三元组表示</p><ol><li>D 是数据对象</li><li>S是 D 上的关系集</li><li>P是对 D 的基本操作集</li></ol><h1 id="算法和算法分析"><a href="#算法和算法分析" class="headerlink" title="算法和算法分析"></a>算法和算法分析</h1><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/Snipaste_2023-06-04_16-03-53.png"></p><p>算法的定义：</p><p>对特定问题求解方法和步骤的一种描述，它是指令的有限序列。其中每个指令表示一个或多个操作。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/Snipaste_2023-06-04_16-05-06.png"></p><p>算法的描述</p><ol><li>自然语言：英语、中文</li><li>流程图：传统流程图、NS流程图</li><li>伪代码：类语言：C语言（最常见）</li><li>程序代码: C语言程序、JAVA语言程….</li></ol><p>算法与程序：</p><ul><li>算法是解决问题的一种方法或一个过程， 考虑如何将输入转换成输出,一个问题可以有多种算法。</li><li>程序是用某种程序设计语言对算法的具体实现。</li></ul><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/Snipaste_2023-06-04_16-07-46.png"></p><h2 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h2><p>一个算法必须具备以下五个重要特性：</p><ol><li>有穷性：一个算法必须总是在执行有穷步之后结束，且每一步都在有穷时间内完成。</li><li>确定性：算法中的每一条指令必须有确切的含义，没有二_义性，在任何条件下，只有唯一的一条执行路径，即对于相同的输入只能得到相同的输出。</li><li>可行性：算法是可执行的，算法描述的操作可以通过已经实现的基本操作执行有限次来实现。</li><li>输入：一个算法有零个或多个输入。</li><li>输出：一个算法有一个戴多个输出。</li></ol><h2 id="算法设计的要求"><a href="#算法设计的要求" class="headerlink" title="算法设计的要求"></a>算法设计的要求</h2><ol><li>正确性(Correctness)<br><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/Snipaste_2023-06-04_16-10-15.png"></li><li>可读性(Readability)<br><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/Snipaste_2023-06-04_16-10-36.png"></li><li>健壮性(Robustness)<br><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/Snipaste_2023-06-04_16-10-53.png"></li><li>高效性(Efficiency)<br><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/Snipaste_2023-06-04_16-11-42.png"></li></ol><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>一个好的算法首先要具备正确性，然后是健壮性，可读性，在几个方面都满足的情况下，主要考虑算法的效率，通过算法的效率高低来评判不同算法的优劣程度。</p><p>算法效率以下两个方面来考虑：</p><ol><li><p>时间效率:指的是算法所耗费的时间;</p></li><li><p>空间效率:指的是算法执行过程中所耗费的存储空间。</p></li></ol><blockquote><p>时间效率和空间效率有时候是矛盾的。</p></blockquote><h3 id="算法时间效率的度量"><a href="#算法时间效率的度量" class="headerlink" title="算法时间效率的度量"></a>算法时间效率的度量</h3><p>算法时间效率可以用依据该算法编制的程序在计算机上执行所消耗的时间来度量。</p><p>两种度量方法：</p><ol><li>事后统计：将算法实现,测算其时间和空间开销。</li><li>事前分析：对算法所消耗资源的一种估算方法。</li></ol><h4 id="事前分析方法"><a href="#事前分析方法" class="headerlink" title="事前分析方法"></a>事前分析方法</h4><p>一个算法的运行时间是指一个算法在计算机上运行所耗费的时间大致可以等于计算机执行一种简单的操作(如赋值、比较、移动等)所需的时间与算法中进行的简单操作次数乘积。</p><p><strong>算法运行时间 &#x3D; 一个简单操作所需的时间 x 简单操作次数</strong></p><p>也即算法中每条语句的执行时间之和</p><p>算法运行时间 &#x3D; ∑ 每条语句的执行次数（语句频度） x 该语句执行一次所需的时间</p><p>我们把算法所耗费的时间定文为该算法中每条语句的频度之和，算法的时间消耗记为 T(n)</p><p>为了便于比较不同算法的时间效率，我们仅比较它们的<strong>数量级</strong>。记作T(n)&#x3D;O(f(n))，称O(f(n))为算法的<strong>渐进时间复杂度</strong> (O是数量级的符号)，简称<strong>时间复杂度</strong>。</p><p>最坏时间复杂度:指在最坏情况下，算法的时间复杂度。</p><p>平均时间复杂度:指在所有可能输入实例在等概率出现的情况下，算法的期望运行时间。</p><p>最好时间复杂度:指在最好情况下，算法的时间复杂度。</p><blockquote><p>一般总是考虑在最坏情况下的时间复杂度，以保证算法的运行时间不会比它更长。</p></blockquote><p>对于复杂的算法，可以将它分成几个容易估算的部分，然后利用大O 加法法则和乘法法则，计算算法的时间复杂度: </p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/Snipaste_2023-06-04_16-30-41.png"></p><h3 id="渐进空间复杂度"><a href="#渐进空间复杂度" class="headerlink" title="渐进空间复杂度"></a>渐进空间复杂度</h3><p>空间复杂度:算法所需存储空间的度量，</p><p>记作：S(n)&#x3D;O(f(n))  其中n为问题的规模(或大小) </p><p>算法要占据的空间：</p><ol><li>算法本身要占据的空间，输入&#x2F;输出，指令，常数，变量等</li><li>算法要使用的辅助空间</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java常用类</title>
      <link href="/2023/05/28/Java%E5%B8%B8%E7%94%A8%E7%B1%BB/"/>
      <url>/2023/05/28/Java%E5%B8%B8%E7%94%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Wrapper类-x2F-包装类"><a href="#Wrapper类-x2F-包装类" class="headerlink" title="Wrapper类&#x2F;包装类"></a>Wrapper类&#x2F;包装类</h1><p>包装类（Wrapper）：针对<strong>八种基本数据类型</strong>相应的 引用类型。有了类的特点，就可以调用类中的方法</p><p>理解了继承体系才知道有哪些方法能用，继承体系如下</p><table><thead><tr><th>基本数据类型</th><th>包装类</th><th>父类</th></tr></thead><tbody><tr><td>boolean</td><td>Boolean</td><td>Object</td></tr><tr><td>char</td><td>Character</td><td>Object</td></tr><tr><td>int</td><td>Integer</td><td>Number</td></tr><tr><td>float</td><td>Float</td><td>Number</td></tr><tr><td>double</td><td>Double</td><td>Number</td></tr><tr><td>long</td><td>Long</td><td>Number</td></tr><tr><td>short</td><td>Short</td><td>Number</td></tr><tr><td>byte</td><td>Byte</td><td>Number</td></tr><tr><td>void</td><td>Void</td><td>Object</td></tr></tbody></table><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309161838462.png"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309161838778.png" alt="char"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309161839328.png" alt="数字类都能看这个图"></p><h2 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h2><p>以int为例，其他的类似</p><p>装箱：int转为Interger</p><p>拆箱：interger转为Int</p><h3 id="手动装箱和拆箱（JDK-5-以前）"><a href="#手动装箱和拆箱（JDK-5-以前）" class="headerlink" title="手动装箱和拆箱（JDK 5 以前）"></a>手动装箱和拆箱（JDK 5 以前）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int n1 = 100;</span><br><span class="line">Integer integer = new Integer(n1);// 手动装箱</span><br><span class="line">Integer integer2 = Integer.valueOf(n1);// 手动装箱</span><br><span class="line">int i = integer.intValue();// 手动拆箱</span><br></pre></td></tr></table></figure><h3 id="自动装箱和拆箱（JDK-5-以后）"><a href="#自动装箱和拆箱（JDK-5-以后）" class="headerlink" title="自动装箱和拆箱（JDK 5 以后）"></a>自动装箱和拆箱（JDK 5 以后）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n2 = 200;</span><br><span class="line">Integer integer3 = n2;// 自动装箱，底层用的是valueOf()</span><br><span class="line">int j = integer3;// 自动拆箱，底层用的是intValue()</span><br></pre></td></tr></table></figure><p>虽然可以自动装箱、拆箱，但使用 &#x3D;&#x3D; 直接比较两个包装类时，仍然是比较其地址。以下比较通常会失败：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer ia = 1000;</span><br><span class="line">Integer ib = 1000;</span><br><span class="line">System.out.print(ia == ib);// false</span><br></pre></td></tr></table></figure><p>但是，Byte、Boolean 以及 Short、Integer 中 [-128, 127] 间的值已被包装到固定的对象中。对他们的比较可以成功。</p><blockquote><p>底层存了一个256大小的数组，如果值在 [-128, 127]中，直接用这个数组的地址，不用额外创建对象</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer ia = 127;</span><br><span class="line">Integer ib = 127;</span><br><span class="line">System.out.print(ia == ib);// true</span><br></pre></td></tr></table></figure><p>由此可见，使用 &#x3D;&#x3D; 直接比较两个包装类会带来不确定性。<strong>尽量使用 equals 方法对包装类进行比较。</strong></p><p>装箱与拆箱是 <strong>编译器</strong> 的工作。在生成可执行的字节码文件时，编译器已经插入了必要的方法调用。</p><h2 id="包装类和-String-的相互转换"><a href="#包装类和-String-的相互转换" class="headerlink" title="包装类和 String 的相互转换"></a>包装类和 <code>String</code> 的相互转换</h2><p>包装类转 <code>String</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer integer = 100;</span><br><span class="line">String str1 = integer + &quot;&quot;;//方法1（自动拆箱）</span><br><span class="line">String str2 = integer.toString();//方法2（toString方法）</span><br><span class="line">String str3 = String.valueOf(integer);//方法3（自动拆箱）</span><br></pre></td></tr></table></figure><p><code>String</code> 转包装类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str4 = &quot;100&quot;;</span><br><span class="line">Integer integer2 = Integer.parseInt(str4);//方法1（自动装箱）</span><br><span class="line">Integer integer3 = new Integer(str4);//方法2（构造器）</span><br></pre></td></tr></table></figure><h2 id="包装类的常用方法"><a href="#包装类的常用方法" class="headerlink" title="包装类的常用方法"></a>包装类的常用方法</h2><ul><li><p><code>Integer.MIN_VALUE</code>：返回最大值</p></li><li><p><code>Double.MAX_VALUE</code>：返回最小值</p></li><li><p><code>byteValue()</code>、<code>doubleValue()</code>、<code>floatValue()</code>、<code>intValue()</code>、<code>longValue()</code></p><p>按各种基本数据类型返回该对象的值</p></li><li><p><code>Character.isDigit(int)</code>：判断是不是数字</p><p><code>Character.isLetter(int)</code>：判断是不是字母</p><p><code>Character.isUpperCase(int)</code>：判断是不是大写字母</p><p><code>Character.isLowerCase(int)</code>：判断是不是小写字母</p><p><code>Characher.isWhitespace(int)</code>：判断是不是空格</p></li><li><p><code>Character.toUpperCase(int)</code>：转成大写字母</p><p><code>Character.toLowerCase(int)</code>：转成小写字母</p></li><li><p><code>Integer.parseInt(string)</code>：将 String 内容转为 int</p><p>double等同理</p></li></ul><h2 id="Interger创建机制"><a href="#Interger创建机制" class="headerlink" title="Interger创建机制"></a>Interger创建机制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">        if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        return new Integer(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309162137184.png"></p><p>值在[-128,127]中，直接从IntegerCache中取出，用IntegerCache的地址，不在这个范围里面的才用new新建对象。</p><p>但是如果直接用new创建对象，一定不一样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer i1 = new Integer(127);</span><br><span class="line">        Integer i2 = new Integer(127);</span><br><span class="line">        System.out.print(&quot;i1 == i2&quot;);</span><br><span class="line">        System.out.println(i1 == i2);</span><br><span class="line">        Integer i3 = new Integer(128);</span><br><span class="line">        Integer i4 = new Integer(128);</span><br><span class="line">        System.out.print(&quot;i3 == i4&quot;);</span><br><span class="line">        System.out.println(i3 == i4);</span><br><span class="line">        Integer i5 = 127;</span><br><span class="line">        Integer i6 = 127;</span><br><span class="line">        System.out.print(&quot;i5 == i6&quot;);</span><br><span class="line">        System.out.println(i5 == i6);</span><br><span class="line">        Integer i7 = 128;</span><br><span class="line">        Integer i8 = 128;</span><br><span class="line">        System.out.print(&quot;i7 == i8&quot;);</span><br><span class="line">        System.out.println(i7 == i8);</span><br><span class="line">        Integer a5 = 127;</span><br><span class="line">        Integer a6 = new Integer(127);</span><br><span class="line">        System.out.print(&quot;a5 == a6&quot;);</span><br><span class="line">        System.out.println(a5 == a6);</span><br><span class="line">        Integer a7 = 128;</span><br><span class="line">        int a8 = 128;</span><br><span class="line">        System.out.print(&quot;a7 == a8&quot;);</span><br><span class="line">        System.out.println(a7 == a8);</span><br><span class="line">        Integer a9 = 127;</span><br><span class="line">        int a0 = 127;</span><br><span class="line">        System.out.print(&quot;a9 == a0&quot;);</span><br><span class="line">        System.out.println(a9 == a0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h1><p>数学类，是静态类，封装了一堆数学方法，直接<strong>类名.方法</strong>调用</p><p>常用方法：</p><ol><li><p><code>Math.multiplyExact(int n1, int n2)</code>：进行乘法运算，返回运算结果</p><p>通常的乘法 <code>n1 * n2</code> 在结果大于那个数据类型存储上限时，可能返回错误的值。</p><p>使用此方法，结果大于那个数据类型存储上限时，会抛出异常</p><p><code>Math.addExact(int n1, int n2)</code>：加法</p><p><code>Math.subtractExact(int n1, int n2)</code>：减法</p><p><code>Math.incrementExact(int n1)</code>：自增</p><p><code>Math.decrementExact(int n1)</code>：自减</p><p><code>Math.negateExact(int n1, int n2)</code>：改变符号</p></li><li><p><code>Math.abs(n)</code>：求绝对值，返回 |n1|</p></li><li><p><code>Math.pow(n, i)</code>：求幂，返回 n3 ^ i</p></li><li><p><code>Math.ceil(n)</code>：向上取整，返回 &gt;&#x3D; n3 的最小整数（转成double）</p></li><li><p><code>Math.floor(n)</code>：向下取整，返回 &lt;&#x3D;n4 的最小整数（转成double）</p></li><li><p><code>Math.floorMod(int n1, int n2)</code>：返回 n1 除以 n2 的余数</p><p><code>n1 % n2</code> 的场合，返回的可能是负数，而不是数学意义上的余数</p></li><li><p><code>Math.round(n)</code>：四舍五入，相当于 <code>Math.floor(n5 + 0.5)</code></p></li><li><p><code>Math.sqrt(n)</code>：求开方。负数的场合，返回 <code>NaN</code></p></li><li><p><code>Math.random()</code>：返回一个 [0, 1) 区间的随机小数</p></li><li><p><code>Math.sin(n)</code>：正弦函数</p><p><code>Math.cos(n)</code>：余弦函数</p><p><code>Math.tan(n)</code>、<code>Math.atan(n)</code>、<code>Math.atan2(n)</code></p><p>要注意，上述方法传入的参数是 <strong>弧度值</strong>。</p><p>要得到一个角度的弧度值，应使用：<code>Math.toRadians(n)</code></p></li><li><p><code>Math.exp(n)</code>：e 的 n 次幂</p><p><code>Math.log10(n)</code>：10 为底的对数</p><p><code>Math.log()</code>：自然对数</p></li><li><p><code>Math.PI</code>：圆周率的近似值</p><p><code>Math.E</code>：e 的近似值</p></li></ol><h1 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h1><p><code>Arrays.toString()</code>：返回数组的字符串形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] nums = &#123;0, 1, 33&#125;;</span><br><span class="line">String str = Array.toString(nums);//此时，str = &quot;[0, 1, 33]&quot;</span><br></pre></td></tr></table></figure><blockquote><p>特别的，输入为 null 时返回 “null”</p></blockquote><p><code>Arrays.sort(arr)</code>：排序</p><blockquote><p>因为数组是引用类型，使用 sort 排序后，会直接影响到实参</p></blockquote><p><code>Arrays.sort(arr, Comparator c)</code>：按照传入的比较器决定排序方法，可以改变是升序还是降序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Integer[] nums;</span><br><span class="line">...</span><br><span class="line">Comparator&lt;Integer, Integer&gt; c = new Comparator&lt;Integer, Integer&gt;()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Integer o1, Integer o2)&#123;</span><br><span class="line">        return n2 - n1;// 这个场合，变成从大到小排序</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Arrays.sort(nums, c);</span><br></pre></td></tr></table></figure><p><code>Arrays.binarySearch(array, num)</code>：通过二分搜索法查找。前提是必须先排序。找不到的场合，返回 - (low + 1)。即，其应该在的位置的负值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] nums2 = &#123;-10, -5, -2, 0, 4, 5, 9&#125;;</span><br><span class="line">int index = Arrays.binarySearch(nums2, 7);// 此时 index = -7</span><br><span class="line">// 如果 7 存在，应该在第 7 个位置</span><br></pre></td></tr></table></figure><p><code>Arrays.copyOf(arr, n)</code>：从 <code>arr</code> 中，复制 n 个元素（成为新的数组）。</p><p>n &gt; arr.length 的场合，在多余的位置添加 <code>null</code>。n &lt; 0 的场合，抛出异常。</p><p>该方法的底层使用的是 <code>System.arraycopy</code></p><p><code>Arrays.fill(arr, o)</code>：用 o 填充 <code>num</code> 的所有元素。</p><p><code>Arrays.equals(arr1, arr2)</code>：比较两个数组元素是否完全一致（<code>true</code>&#x2F;<code>false</code>）</p><p><code>Arrays.asList(a, b, c, d)</code>：将输入数据转成一个 <code>List</code> 集合</p><h1 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h1><ul><li><p><code>System.exit(0)</code>：退出当前程序。0 表示一个状态，正常状态是 0</p></li><li><p><code>System.arraycopy(arr, 0, newArr, 0 ,3)</code>：复制数组元素。</p><p>上例是：arr 自下标 0 起开始，向 newArr 自下标 0 开始，依次拷贝 3 个值</p><p>这个方法比较适合底层调用。我们一般使用 <code>Arrays.copyOf</code> 来做</p></li><li><p><code>System.currentTimeMillis</code>：返回当前时间距离 1970 - 1 - 1 的毫秒数</p></li><li><p><code>System.gc</code>：运行垃圾回收机制</p></li></ul><h1 id="BigInteger-和-BigDecimal-类"><a href="#BigInteger-和-BigDecimal-类" class="headerlink" title="BigInteger 和 BigDecimal 类"></a>BigInteger 和 BigDecimal 类</h1><p>BigInteger：适合保存更大的整数</p><p>BigDecimal：适合保存精度更大的浮点数</p><p><strong>构造方法：</strong></p><ul><li><p><code>new BigInteger(String intStr)</code>：通过一个字符串构建大数</p><blockquote><p>直接用数值会报错，用字符串倒是没问题</p></blockquote></li><li><p><code>BigInteger BigInteger.valueOf(1)</code>：通过静态方法，让整数类型转成大数</p></li></ul><p>在对 <code>BigInteger</code> 和 <code>BigDecimal</code> 进行加减乘除的时候，需要使用对应方法，不能直接用 <code>+</code> <code>-</code> <code>*</code> <code>/</code></p><ul><li><p><code>BigInteger add(BigInteger)</code>：加法运算。返回新的大数</p></li><li><p><code>BigInteger subtract(BigInteger)</code>：减法</p></li><li><p><code>BigInteger multiply(BigInteger)</code>：乘法</p></li><li><p><code>BigInteger divide(BigInteger)</code>：除法运算</p><p>该方法可能抛出异常。因为可能产生是无限长度小数。</p><p>解决方法（保留分子精度）：<code>bigDecimal.divide(bD3, BigDecimal.ROUND_CELLING)</code></p></li></ul><p>一些常量：</p><p><code>BigInteger.ONE</code>、<code>BigInteger.ZERO</code>、<code>BigInteger.TEN</code> 分别是 1、0、10</p><h1 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h1><h2 id="第一代日期类Date"><a href="#第一代日期类Date" class="headerlink" title="第一代日期类Date"></a>第一代日期类Date</h2><p>Date：精确到毫秒，代表特定瞬间。需要导入 java.util.Date</p><p>SimpleDateFormat：格式和解析日期的类。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309170944323.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Date d1 = new Date(); //获取当前系统时间</span><br><span class="line">System.out.println(&quot;当前日期=&quot; + d1);</span><br><span class="line">Date d2 = new Date(9234567); //通过指定毫秒数得到时间</span><br><span class="line">System.out.println(&quot;d2=&quot; + d2); //获取某个时间对应的毫秒数</span><br></pre></td></tr></table></figure><p>默认输出日期格式是国外的格式，因此通常需要进行格式转换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy.MM.dd HH.mm.ss&quot;);</span><br><span class="line">String dateFormated = sdf.(d1);//日期转成指定格式。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Date d1 = new Date(); //获取当前系统时间</span><br><span class="line">System.out.println(&quot;当前日期=&quot; + d1);</span><br><span class="line">Date d2 = new Date(9234567); //通过指定毫秒数得到时间</span><br><span class="line">System.out.println(&quot;d2=&quot; + d2); //获取某个时间对应的毫秒数</span><br><span class="line">//1. 创建 SimpleDateFormat 对象，可以指定相应的格式</span><br><span class="line">//2. 这里的格式使用的字母是规定好，不能乱写</span><br><span class="line">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy 年 MM 月 dd 日 hh:mm:ss E&quot;);</span><br><span class="line">String format = sdf.format(d1); // format:将日期转换成指定格式的字符串</span><br><span class="line">System.out.println(&quot;当前日期=&quot; + format);</span><br><span class="line">//1. 可以把一个格式化的 String 转成对应的 Date</span><br><span class="line">//2. 得到 Date 仍然在输出时，还是按照国外的形式，如果希望指定格式输出，需要转换</span><br><span class="line">//3. 在把 String -&gt; Date ， 使用的 sdf 格式需要和你给的 String 的格式一样，否则会抛出转换异常</span><br><span class="line">String s = &quot;1996 年 01 月 01 日 10:20:30 星期一&quot;;</span><br><span class="line">Date parse = sdf.parse(s);</span><br><span class="line">System.out.println(&quot;parse=&quot; + sdf.format(parse));</span><br></pre></td></tr></table></figure><h2 id="第二代日期类Calendar"><a href="#第二代日期类Calendar" class="headerlink" title="第二代日期类Calendar"></a>第二代日期类Calendar</h2><p>Calendar：构造器是私有的，要通过 getInstance 方法获取实例</p><ol><li><p>Calendar 是一个抽象类，其构造器私有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Calendar c1 = Calendar.genInstance();//获取实例的方法</span><br></pre></td></tr></table></figure></li><li><p>提供大量方法和字段提供给程序员使用</p><ul><li><p><code>c1.get(Calendar.YEAR)</code>：获取年份数</p></li><li><p><code>c1.get(Calendar.MONTH)</code>：获取月份数</p><blockquote><p>特别的，实际月份是 返回值 +1。因为 Calendar 的月份是从 0 开始编号的</p></blockquote></li><li><p><code>c1.get(Calendar.DAY_OF_MONTH)</code>：获取日数</p></li><li><p><code>c1.get(Calendar.HOUR)</code>：获取小时数（12小时制）</p><p><code>c1.get(Calendar.HOUR_OF_DATE)</code>：获取小时数（24小时制）</p></li><li><p><code>c1.get(Calendar.MINUTE)</code>：获取分钟数</p></li><li><p><code>c1.get(Calendar.SECOND)</code>：获取秒数</p></li></ul><p>Calendar 没有专门的格式化方法，需要程序员自己组合来显示</p><p>Calendar 也存在不足：</p><ol><li>可变性：像日期和实际这样的类应该是不可改变的</li><li>偏移性：年份都是从 1900 年开始，月份都是从 0 开始</li><li>格式化：只对 Date 有用，对 Calendar 没用</li><li>其他问题：如不能保证线程安全，不能处理闰秒（每隔 2 天多 1 秒）等</li></ol></li></ol><h2 id="第三代日期类"><a href="#第三代日期类" class="headerlink" title="第三代日期类"></a>第三代日期类</h2><p>在 JDK 8 加入了以下新日期类：</p><ul><li>LocalDate：只包含 日期（年月日），可以获取 日期字段</li><li>LocalTime：只包含 时间（时分秒），可以获取 时间字段</li><li>LocalDateTime：包含 日期 + 时间，可以获取 日期 + 时间字段</li><li>DateTimeFormatter：格式化日期</li><li>Instant：时间戳</li></ul><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309171027031.png"></p><ol><li><ul><li><p>使用 <code>now()</code> 方法返回当前时间的对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime ldt = LocalDateTime.now();//获取当前时间</span><br></pre></td></tr></table></figure></li></ul></li><li><p>获取各字段方法：</p><ul><li><p><code>ldt.getYear();</code>：获取年份数</p></li><li><p><code>ldt.getMonth();</code>：获取月份数（英文）</p><p><code>ldt.getMonthValue();</code>：获取月份数（数字）</p></li><li><p><code>ldt.getDayOfMonth();</code>：获取日数</p></li><li><p><code>LocalDateTime ldt2 = ldt.plusDays(100);</code>：获取 ldt 时间 100 天后的时间实例</p></li><li><p><code>LocalDateTime ldt3 = ldt.minusHours(100);</code>：获取 ldt 时间 100 小时前的时间实例</p></li></ul></li><li><p>格式化日期：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter dtf = new DateTimeFormatter(&quot;yyyy.MM.dd HH.mm.ss&quot;);</span><br><span class="line">String date = dtf.format(ldt);//获取格式化字符串</span><br></pre></td></tr></table></figure></li><li><p><code>Instant</code> 和 <code>Date</code> 类似</p><ul><li>获取当前时间戳：<code>Instant instant = Instant.now();</code></li><li>转换为 <code>Date</code>：<code>Date date = Date.form(instant);</code></li><li>由 <code>Date</code> 转换：<code>Instant instant = date.toInstant;</code></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 内置类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java异常</title>
      <link href="/2023/05/28/Java%E5%BC%82%E5%B8%B8/"/>
      <url>/2023/05/28/Java%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>在 Java 语言中，将程序执行中发生的不正常情况称为 “异常”（开发过程中的语法错误和逻辑错误不是异常）</p><p>这些 异常事件 可分为两类：</p><ol><li><p>Error（错误）：Java 虚拟机无法解决的严重问题。</p><p>如：JVM 系统内部错误，资源耗尽等严重情况。Error 是严重错误，程序会崩溃。</p></li><li><p>Exception（异常）：其他因编程错误或偶然的外部因素导致的一般性问题，可以使用针对性的代码进行处理。</p><p>如：空指针访问，试图读取不存在的文件，网络中断等等。</p><p>Exception 又分为两大类：</p><ul><li>运行时异常（程序运行时，发生的异常）</li><li>编译时异常（编程时，编译器检查出的异常，会爆红）</li></ul></li></ol><h2 id="异常体系图"><a href="#异常体系图" class="headerlink" title="异常体系图"></a>异常体系图</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/%25E5%25BC%2582%25E5%25B8%25B8%25E4%25BD%2593%25E7%25B3%25BB%25E5%259B%25BE_11.1.webp"></p><p>异常分为两大类：运行时异常 和 编译时异常</p><ul><li><p>运行时异常，编译器不要求强制处置的异常。一般是指编程的逻辑错误，是程序员应该避免其出现的异常。</p><p>java.lang.RuntimeException 类及它的子类都是运行时异常</p><p>对于运行时异常，可以不做处理。因为这类异常很普遍，若全处理会对程序的可读性和运行效率产生影响</p></li><li><p>编译时异常，是编译器要求必须处置的异常</p></li></ul><h2 id="常见的运行时异常"><a href="#常见的运行时异常" class="headerlink" title="常见的运行时异常"></a>常见的运行时异常</h2><p>常见的运行时异常（RuntimeException）包括</p><ol><li><p>NullPointerException：空指针异常</p><ul><li><p>当应用程序试图在需要对象的地方使用 null 时，抛出该异常</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = null;</span><br><span class="line">int n = str.length;//这里，出现了 空指针异常</span><br></pre></td></tr></table></figure></li></ul></li><li><p>ArithmeticException：数学运算异常</p><ul><li><p>当出现异常的运算条件时，抛出该异常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double n = 100 / 0;//这里，出现了 数学运算异常</span><br></pre></td></tr></table></figure></li></ul></li><li><p>ArrayIndexOutOfBoundsException：数组下标越界异常</p><ul><li><p>用非法索引（为负或超出范围）访问数组时，抛出该异常</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] nums = &#123;0, 0, 0, 0&#125;;</span><br><span class="line">nums[-50] = 100;//这里，出现了 数组下标越界异常</span><br></pre></td></tr></table></figure></li></ul></li><li><p>ClassCastException：类型转换异常</p><ul><li><p>当试图把对象强制转换为不是实例的子类时，抛出该异常</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Example &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        A a1 = new A1();</span><br><span class="line">        A2 a1 = (A2)a1;//这里，出现了 类型转换异常</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class A &#123;&#125;</span><br><span class="line">class A1 extends A &#123;&#125;</span><br><span class="line">class A2 extends A &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>NumberFormatException：数学格式异常</p><ul><li><p>当应用程序试图将字符串转成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;ABC&quot;;</span><br><span class="line">int num = Integer.parseInt(str);//这里，出现了 数字格式不正确异常</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="常见的编译异常"><a href="#常见的编译异常" class="headerlink" title="常见的编译异常"></a>常见的编译异常</h2><p>常见的编译异常：一般发生在网络、文件、数据库操作中。</p><ul><li>SQLException：操作数据库时，查询表可能发生异常</li><li>IOException：操作文件时，发生的异常</li><li>FileNotFoundException：操作一个不存在的文件时，发生的异常</li><li>ClassNotFoundException：加载类，而该类不存在时，发生的异常</li><li>EOFException：操作文件，到文档末尾，发生的异常</li><li>IllegalArguementException：参数异常</li></ul><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>异常发生时，对异常的处理方式。如果没有显式异常处理，默认处理方式是 <code>throws</code></p><blockquote><ul><li><code>try - chatch - finally</code>：程序员在代码中捕获发生的异常，自行处理</li><li><code>throws</code>：将发生的异常抛出，交给调用者（方法）来处理。最顶级的处理者就是 JVM</li></ul></blockquote><h2 id="try-chatch-finally"><a href="#try-chatch-finally" class="headerlink" title="try - chatch - finally"></a>try - chatch - finally</h2><p>Java 提供 try 和 catch 块 来处理异常。try 块用于包含可能出错的代码，catch 块用于处理 try 块中的异常。可以根据需要在程序中有多个 <code>try - catch</code> 块。</p><p>基本语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">//可疑代码</span><br><span class="line">//将异常生成对应的异常对象，传递给 catch 块</span><br><span class="line">&#125; catch(Exception e) &#123;</span><br><span class="line">//如果发生异常，执行这些代码</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    //无论是否异常，都执行这些代码</span><br><span class="line">    //finally 块可以不写</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h4><ol><li><p>如果异常发生了，则异常发生后面的代码块都不执行，直接进入 catch 块</p></li><li><p>如果异常未发生，则顺序执行 try 代码块，catch 块不执行</p></li><li><p>如果希望不管是否异常，都执行一些代码，则使用 finally</p></li><li><p>可以有多个 catch 捕获不同的异常。要求 子类异常在前，父类异常在后。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">...</span><br><span class="line">&#125; catch (NullPointerException e) &#123;</span><br><span class="line">...</span><br><span class="line">&#125; catch (ArithmeticException e) &#123;</span><br><span class="line">...</span><br><span class="line">&#125; catch (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">...</span><br><span class="line">&#125; catch (Exception e)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以进行 try - finally 配合使用（不写 catch）。这种用法相当于没有捕获异常，此时程序如果出错会直接退出。</p><p>应用场景，就是写一段代码，不管是否发生异常，都必须执行某个业务逻辑。</p></li><li><p>如果没有出现异常，执行 try 中所有语句，不执行 catch 语句，最后执行 finally 语句</p></li><li><p>如果出现异常，则 try 块异常发生后，剩余语句不执行。之后执行 catch 语句，最后，执行 finally 语句。</p></li></ol><p>例子：如果用户输入的不是一个整数，就提示他反复输入，直到输入一个整数为止</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package org.example;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        int num;</span><br><span class="line">        String str = new String();</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            System.out.println(&quot;请输入&quot;);</span><br><span class="line">            str = scanner.next();</span><br><span class="line">            try&#123;</span><br><span class="line">                num = Integer.parseInt(str);</span><br><span class="line">                break;</span><br><span class="line">            &#125;catch (NumberFormatException e)&#123;</span><br><span class="line">                System.out.println(&quot;warring&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h2><p>如果一个方法可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显式地声明抛出异常，表明该方法将不对这些异常进行处理，而由调用者负责处理</p><p>在方法中声明 <code>throws</code> 语句可以声明抛出异常的列表。<code>throws</code> 后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void metord() throws FileNontFoundException ,NullPointerException &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309181432554.png"></p><blockquote><p>除了JVM层，每一层都能选择使用try还是throws，到JVM就直接报红错误。</p><p>下面层中，每一层二选一处理。</p></blockquote><p>使用细节：</p><ol><li>对于 <strong>编译异常</strong>，程序中必须处理。</li><li>对于 <strong>运行异常</strong>，程序中诺没有处理，默认处理是 <code>throws</code></li><li>子类 重写 父类方法时，子类方法抛出的异常类型必须和父类一致，或者是父类抛出异常类型的子类型。</li><li>如果有 <code>try - catch</code> 就不必 <code>throws</code> 了</li></ol><h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><p>当程序中出现了某些 “错误”，但该信息并未在 <code>Throwable</code> 子类中描述处理，这时候可以自己设计异常类，用于描述该错误信息</p><p>过程：</p><ol><li>定义类：自定义异常类名，继承 RuntimeException 或 Exception</li><li>如果继承 Exception，属于 编译异常。</li><li>如果继承 RuntimeException，属于 运行异常。（一般来说，选这个。这样利用了默认处理机制throws，更方便）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Metords &#123;</span><br><span class="line">   public void method() &#123;</span><br><span class="line">       int n = 10;</span><br><span class="line">       if(n &gt; 100)&#123;</span><br><span class="line">           throw new CustomException(&quot;不能大于100&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CustomException extends RuntimeException &#123;</span><br><span class="line">public CustomException(String message) &#123;</span><br><span class="line">super(message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="throw-和-throws"><a href="#throw-和-throws" class="headerlink" title="throw 和 throws"></a>throw 和 throws</h1><table><thead><tr><th></th><th>意义</th><th>位置</th><th>后面跟的东西</th></tr></thead><tbody><tr><td><code>throws</code></td><td>异常处理的一种方式</td><td>方法声明时</td><td>异常类型</td></tr><tr><td><code>throw</code></td><td>手动生成异常对象关键字</td><td>方法体中</td><td>异常对象</td></tr></tbody></table><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="编程小技巧编写异常时，先确定正确的情况，然后取反。这样写，你的思路就不乱。"><a href="#编程小技巧编写异常时，先确定正确的情况，然后取反。这样写，你的思路就不乱。" class="headerlink" title="编程小技巧编写异常时，先确定正确的情况，然后取反。这样写，你的思路就不乱。"></a>编程小技巧编写异常时，先确定正确的情况，然后取反。这样写，你的思路就不乱。</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java接口</title>
      <link href="/2023/05/26/Mysql%E8%BF%9B%E9%98%B6/"/>
      <url>/2023/05/26/Mysql%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>视图（view）是一种虚拟存在的表。视图中的数据并不存在数据库中实际存在，行和列数据来自定义视图的查询中使用过的表，并且是在使用视图时动态生成的（视图的数据不是唯一的，而是随着表的数据变化而变化）</p><p>通俗的讲，<strong>视图只保存了查询的SQL逻辑，不保存查询的结果</strong>。所以我们在创建视图的时候，主要的工作就落在创建这条SQL语句上。</p><ol><li><p>创建</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">or</span> replace] <span class="keyword">view</span> 视图名称[(列名列表)] <span class="keyword">as</span> <span class="keyword">select</span>语句 [<span class="keyword">with</span>[<span class="keyword">cascaded</span><span class="operator">|</span><span class="keyword">local</span>] <span class="keyword">check</span> option]</span><br><span class="line"></span><br><span class="line"><span class="comment">--创建视图</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_v_1 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">where</span> id<span class="operator">&lt;</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查看创建视图语句</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">view</span> 视图名称;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查看视图数据(可以将视图理解为表的查询使用)</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 视图名称....;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">view</span> stu_v_1;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu_v_1;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu_v_1 <span class="keyword">where</span> id<span class="operator">&lt;</span><span class="number">5</span>;</span><br></pre></td></tr></table></figure></li><li><p>修改</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--方式一</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> 视图名称[(列名列表)] <span class="keyword">as</span> <span class="keyword">select</span>语句 [<span class="keyword">with</span>[<span class="keyword">cascaded</span><span class="operator">|</span><span class="keyword">local</span>]<span class="keyword">check</span> option]</span><br><span class="line"></span><br><span class="line"><span class="comment">--方式二</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> 视图名称[(列名列表)] <span class="keyword">as</span> <span class="keyword">select</span>语句 [<span class="keyword">with</span>[<span class="keyword">cascaded</span><span class="operator">|</span><span class="keyword">local</span>] <span class="keyword">check</span> option]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace stu_v_1 <span class="keyword">as</span> <span class="keyword">select</span> id,name,<span class="keyword">no</span> <span class="keyword">from</span> student <span class="keyword">where</span> id<span class="operator">&lt;=</span><span class="number">10</span>;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> stu_v_1 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">where</span> id<span class="operator">&lt;=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> [if <span class="keyword">exists</span>] 视图名称[,视图名称]</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> if <span class="keyword">exists</span> stu_v_1;</span><br></pre></td></tr></table></figure></li></ol><h2 id="检查选项"><a href="#检查选项" class="headerlink" title="检查选项"></a>检查选项</h2><p>当使用**<code>WITH CHECK OPTION</code>**子句创建视图时，MySQL会通过试图检查正在更改的每个行，例如 插入、更新、删除，以使其符合视图的定义。MySQL允许基于另一个视图创建视图，他还会检查依赖视图中的规则来保持一致性。为了确定检查的范围，MySQL提供了两个选项：cascaded和local，默认值为cascaded</p><h3 id="cascaded"><a href="#cascaded" class="headerlink" title="cascaded"></a>cascaded</h3><p>用继承帮助理解。使用这个关键字，不管父类有没有用**<code>WITH CHECK OPTION</code><strong>，都会检查父类的</strong><code>where</code>**条件。但是不管子类。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">创建视图</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v1 <span class="keyword">as</span> <span class="keyword">select</span> id,namd <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span><span class="number">20</span> <span class="keyword">with</span> <span class="keyword">cascaded</span> <span class="keyword">check</span> option;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v2 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> v1 <span class="keyword">where</span> id <span class="operator">&gt;=</span><span class="number">10</span> <span class="keyword">with</span> <span class="keyword">cascaded</span> <span class="keyword">check</span> option;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v3 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> v2 <span class="keyword">where</span> id<span class="operator">&lt;</span><span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">插入测试</span><br><span class="line"><span class="comment">--1</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_v_1 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">where</span> id<span class="operator">&lt;=</span><span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--2, 可以正常运行，但是数据添加在 student 表中，而不是在视图中。视图可以查看到</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_1 <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--3，可以正常运行，不报错，但是数据添加在 student 表中，而不是在视图中。视图中不存在这条数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_1 <span class="keyword">values</span>(<span class="number">25</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--4</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_v_2 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> stu_v_1 <span class="keyword">where</span> id<span class="operator">&gt;=</span><span class="number">10</span> <span class="keyword">with</span> <span class="keyword">cascaded</span> <span class="keyword">check</span> option;</span><br><span class="line"></span><br><span class="line"><span class="comment">--5 报错，因为不满足 id&gt;=10 的条件</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_2 <span class="keyword">values</span>(<span class="number">7</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--6 报错，因为不满足 v1视图 的id &lt;=20 条件</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_2 <span class="keyword">values</span>(<span class="number">26</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--7 可以正常运行，首先判断 是否满足4中 id&gt;=10 的条件，其次检查是否满足1中 id&lt;=20 的条件</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_2 <span class="keyword">values</span>(<span class="number">15</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--8 </span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_v_3 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> stu_v_2 <span class="keyword">where</span> id<span class="operator">&lt;=</span><span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--9 可以正常运行，因为满足v3中id&lt;=15，v2中id&gt;=10, v1&lt;=20 的条件</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_3 <span class="keyword">values</span>(<span class="number">11</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--10 可以正常运行，v3视图没有with cascaede check option,所以不会检查是否 &lt;=15,</span></span><br><span class="line"><span class="comment">--   然后检查v2视图条件，满足 id&gt;=10</span></span><br><span class="line"><span class="comment">--   因为v2视图含有with cascaede check option，检查v1视图条件 id&lt;=20</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_3 <span class="keyword">values</span>(<span class="number">17</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--11 报错，v3视图没有with cascaede check option,所以不会检查是否 &lt;=15,</span></span><br><span class="line"><span class="comment">--   然后检查v2视图条件，满足 id&gt;=10</span></span><br><span class="line"><span class="comment">--   因为v2视图含有with cascaede check option，检查v1视图条件 id&lt;=20，不满足，报错</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_3 <span class="keyword">values</span>(<span class="number">28</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="local"><a href="#local" class="headerlink" title="local"></a>local</h3><p>用继承帮助理解。使用这个关键字，如果父类使用**<code>WITH CHECK OPTION</code><strong>，才检查父类的</strong><code>where</code><strong>条件，没有</strong><code>WITH CHECK OPTION</code>**就不加条件。同样不管子类。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">创建视图</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_v_4 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">where</span> id<span class="operator">&lt;=</span><span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">插入测试</span><br><span class="line"><span class="comment">--2, 可以正常运行，但是数据添加在 student 表中，而不是在视图中。视图可以查看到</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_4 <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--3，可以正常运行，不报错，但是数据添加在 student 表中，而不是在视图中。视图中不存在这条数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_4 <span class="keyword">values</span>(<span class="number">16</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--4</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_v_5 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> stu_v_4 <span class="keyword">where</span> id<span class="operator">&gt;=</span><span class="number">10</span> <span class="keyword">with</span> <span class="keyword">local</span> <span class="keyword">check</span> option;</span><br><span class="line"></span><br><span class="line"><span class="comment">--5 可以正常运行，不报错，，因为满足v5的id&gt;=10，且v4的id&lt;=15不检查(没有local) 的条件</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_5 <span class="keyword">values</span>(<span class="number">13</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--6 可以正常运行，不报错，因为满足v5的id&gt;=10，且v4的id&lt;=15不检查(没有local) 的条件</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_5 <span class="keyword">values</span>(<span class="number">17</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--7 </span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_v_6 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> stu_v_5 <span class="keyword">where</span> id<span class="operator">&lt;=</span><span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--8 可以正常运行，因为满足v5的id&gt;=10，且v4的id&lt;=15和v6的id&lt;=20不检查(没有local) 的条件</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_6 <span class="keyword">values</span>(<span class="number">14</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="视图的更新和作用"><a href="#视图的更新和作用" class="headerlink" title="视图的更新和作用"></a>视图的更新和作用</h2><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一项，则该视图不可更新：</p><ol><li>聚合函数或者函窗口函数（sum(), min(), max(), count()等）</li><li>distinct 去重</li><li>group by 分组</li><li>having 过滤</li><li>union 或者 union all 合并查询结果</li></ol><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li><p>简单</p><p>视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件</p></li><li><p>安全</p><p>数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能看到的数据</p></li><li><p>数据独立</p><p>视图可以帮助用户屏蔽真实表结构变化带来的影响</p></li></ol><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310041019321.png"></p><ol><li><p>为了保证数据库表的安全性，开发人员在操作tb_user表时，只能看到的用户的基本字段，屏蔽手机号和邮箱两个字段。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> tb_user_view <span class="keyword">as</span> <span class="keyword">select</span> id,name,profession,age,gender,status <span class="keyword">from</span> tb_user;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user_view;</span><br></pre></td></tr></table></figure></li><li><p>查询每个学生所选修的课程（三张表联查），这个功能在很多业务中都有使用到，为了简化操作，定义一个视图</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">多表联查</span><br><span class="line"><span class="keyword">select</span> s.name,s.no,c.name <span class="keyword">from</span> student s,stuent_course sc,course c <span class="keyword">where</span> s.id <span class="operator">=</span> sc.studentid <span class="keyword">and</span> c.id <span class="operator">=</span> sc.courseid;</span><br><span class="line"></span><br><span class="line">根据联查创建视图</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> tb_stu_course_view <span class="keyword">as</span> selest s.name,s.no,c.name <span class="keyword">from</span> student s,stuent_course sc,course c <span class="keyword">where</span> s.id <span class="operator">=</span> sc.studentid <span class="keyword">and</span> c.id <span class="operator">=</span> sc.courseid;</span><br><span class="line"></span><br><span class="line">这一步大概率报错，说叫name的太多了，要起别名</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> tb_stu_course_view <span class="keyword">as</span> selest s.name student_name,s.no student_no,c.name course_name <span class="keyword">from</span> student s,stuent_course sc,course c <span class="keyword">where</span> s.id <span class="operator">=</span> sc.studentid <span class="keyword">and</span> c.id <span class="operator">=</span> sc.courseid;</span><br></pre></td></tr></table></figure></li></ol><h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><p>存储过程是事先经过编译并存储在数据库中的一段sql语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的</p><p>存储过程思想很简单，就是把数据库SQL语言层面的代码封装与重用</p><p><strong>特点：</strong>封装、复用；可以接受参数，也可以返回数据；减少网络交互，效率提升</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>创建</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名称([参数列表])</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  若干<span class="keyword">sql</span>语句</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>调用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> 名称([参数])</span><br></pre></td></tr></table></figure><p>查看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查询指定数据库的存储过程及状态信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.routines <span class="keyword">where</span> routine_schema<span class="operator">=</span><span class="string">&#x27;xxx&#x27;</span>;  </span><br><span class="line"></span><br><span class="line">查询某个存储过程的定义</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名称;</span><br></pre></td></tr></table></figure><p>删除</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> [if <span class="keyword">exists</span>] 存储过程名称;</span><br></pre></td></tr></table></figure><p>例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">存储过程基本语法</span><br><span class="line"></span><br><span class="line">创建</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p1()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> student;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">调用</span><br><span class="line"><span class="keyword">call</span> p1();</span><br><span class="line"></span><br><span class="line">查看  (查看itcast数据库的所有存储过程)</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.ROUTINES <span class="keyword">where</span> ROUTINE_SCHEMA<span class="operator">=</span><span class="string">&#x27;itcast&#x27;</span></span><br><span class="line">(查看存储过程p1的创建语句)</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">procedure</span> p1;</span><br><span class="line"></span><br><span class="line">删除</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> if <span class="keyword">exists</span> p1; </span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310041105910.png"></p><p>报错，因为命令行看见 ; 就认为结束了，打断正确语法</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310041106783.png"></p><blockquote><p><strong>注意：在命令行中，执行创建存储过程的SQL时，需要通过关键词delimiter指定SQL语句的结束符（见上图）</strong></p></blockquote><blockquote><p>delimiter：更改结束符号，如上图改为$$，避免提前结束。但是效果是持久的，要么改回来，要么j就用改的</p></blockquote><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310041117993.png"></p><h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><p>是MySQL服务器提供的，不是用户定义的，属于服务器层面。分为全局变量（GLOBAL）、会话变量（SESSION），默认会话变量</p><blockquote><p>类似浏览器页面，一个页面就是一个会话</p></blockquote><p>查看系统变量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">查看所有系统变量</span><br><span class="line"><span class="keyword">show</span> [session<span class="operator">|</span><span class="keyword">global</span>] variables; </span><br><span class="line"></span><br><span class="line">可以通过<span class="keyword">like</span>模糊匹配方式查找变量</span><br><span class="line"><span class="keyword">show</span> [session<span class="operator">|</span><span class="keyword">global</span>] variables <span class="keyword">like</span> <span class="string">&#x27;xxxx&#x27;</span>;</span><br><span class="line"></span><br><span class="line">查看指定变量的值</span><br><span class="line"><span class="keyword">select</span> @@[session<span class="operator">|</span><span class="keyword">global</span>] 系统变量名;</span><br></pre></td></tr></table></figure><p>设置系统变量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> [session<span class="operator">|</span><span class="keyword">global</span>] 系统变量名<span class="operator">=</span>值;</span><br><span class="line"><span class="keyword">set</span> @@[session<span class="operator">|</span><span class="keyword">global</span>] 系统变量名<span class="operator">=</span>值;</span><br></pre></td></tr></table></figure><blockquote><p>如果没有指定session、global，默认是session级别，会话变量</p><p>MySQL服务重新启动之后，所设置的全局参数会失效，想要不失效，可以在&#x2F;etc&#x2F;my.cnf中配置</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--  变量：系统变量</span></span><br><span class="line"><span class="comment">--  查看系统变量</span></span><br><span class="line"><span class="keyword">show</span> session variables;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> session variables <span class="keyword">like</span> <span class="string">&#x27;auto%&#x27;</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;auto%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@autocommit</span>;</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@global</span>.autocommit;   <span class="comment">--查看global级别的autocommit变量值1</span></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@session</span>.autocommit;  <span class="comment">--查看session级别的autocommit变量值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--  设置系统变量</span></span><br><span class="line"><span class="keyword">set</span> session autocommit <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> autocommit<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="用户自定义变量"><a href="#用户自定义变量" class="headerlink" title="用户自定义变量"></a>用户自定义变量</h3><p>是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用”@变量名”使用就可以。其作用域为当前连接（session级别）</p><blockquote><p>@@ 是系统变量</p><p>@    是用户自定义变量 </p></blockquote><p>赋值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="variable">@var</span>_name <span class="operator">=</span> expr [,<span class="variable">@var</span>_name2 <span class="operator">=</span> expr]...;</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@var</span>_name :<span class="operator">=</span> expr [,<span class="variable">@var</span>_name2 :<span class="operator">=</span> expr]...;</span><br><span class="line"></span><br><span class="line">推荐 :<span class="operator">=</span> ，用以区分等于运算符</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="variable">@var</span>_name :<span class="operator">=</span>expr[,<span class="variable">@var</span>_name2:<span class="operator">=</span>expr]...;</span><br><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">into</span> <span class="variable">@var</span>_name <span class="keyword">from</span> 表名；</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="variable">@var</span>_name;</span><br></pre></td></tr></table></figure><blockquote><p>用户定义的变量无需对其进行声明或初始化，只不过获取到的值为null</p></blockquote><p>例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--变量：用户变量</span></span><br><span class="line"><span class="comment">--赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="variable">@myname</span> <span class="operator">=</span> <span class="string">&#x27;itcast&#x27;</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@myage</span> :<span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@mygender</span> :<span class="operator">=</span><span class="string">&#x27;男&#x27;</span>,<span class="variable">@myhobby</span>:<span class="operator">=</span><span class="string">&#x27;java&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="variable">@mycolor</span> :<span class="operator">=</span> <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">into</span> <span class="variable">@mycount</span> <span class="keyword">from</span> tb_user;</span><br><span class="line"></span><br><span class="line"><span class="comment">--使用</span></span><br><span class="line"><span class="keyword">select</span> <span class="variable">@myname</span>,<span class="variable">@myage</span>,<span class="variable">@mygender</span>,<span class="variable">@myhobby</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@mycolor</span>,<span class="variable">@mycount</span>;</span><br></pre></td></tr></table></figure><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>局部变量是根据需要定义的在局部生效的变量，访问之前，需要declare声明。可以作存储过程内的局部变量和输入参数，局部变量的范围是在其内部声明的<code>begin ... end</code>块中有效，超出则无效。</p><p>声明</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> 变量名 数据类型 [<span class="keyword">default</span> 默认值];</span><br><span class="line"></span><br><span class="line">变量的数据类型就是数据库字段类型：<span class="type">int</span>, <span class="type">bigint</span>, <span class="type">char</span>, <span class="type">varchar</span>, <span class="type">date</span>, <span class="type">time</span>等</span><br></pre></td></tr></table></figure><p>赋值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--赋值</span></span><br><span class="line"><span class="keyword">set</span> 变量名 :<span class="operator">=</span> 值;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">into</span> 变量名 <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure><h2 id="if条件判断"><a href="#if条件判断" class="headerlink" title="if条件判断"></a>if条件判断</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if 条件<span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">....</span><br><span class="line">elseif 条件<span class="number">2</span> <span class="keyword">then</span></span><br><span class="line">....</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">....</span><br><span class="line"><span class="keyword">end</span> if; 用来结束if</span><br></pre></td></tr></table></figure><p>例：</p><p>定义存储过程，完成如下需求</p><p>根据定义的分数score变量，判断当前分数对应的分数等级</p><ol><li>score&gt;&#x3D;85,等级为优秀</li><li>score&gt;&#x3D;60分 且 score &lt;85分，等级为及格</li><li>score&lt;60分，等级为不及格</li></ol><p>缺点：</p><ol><li>当前数据写死，要改为由变量传递数值</li><li>当前结果只是展示，需要实现返回</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p1()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> scoure <span class="type">int</span> <span class="keyword">default</span> <span class="number">58</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">result</span> <span class="type">varchar</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">if score <span class="operator">&gt;=</span><span class="number">85</span> <span class="keyword">then</span>     <span class="comment">--情况1</span></span><br><span class="line">      <span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;优秀&#x27;</span>;</span><br><span class="line">elseif score<span class="operator">&gt;=</span><span class="number">60</span> <span class="keyword">then</span>  <span class="comment">--情况2 </span></span><br><span class="line">  <span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;及格&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span>                   <span class="comment">--余下情况    </span></span><br><span class="line">      <span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;不及格&#x27;</span>;</span><br><span class="line"><span class="keyword">end</span> if;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">result</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h2 id="参数（IN，OUT，INOUT）"><a href="#参数（IN，OUT，INOUT）" class="headerlink" title="参数（IN，OUT，INOUT）"></a>参数（IN，OUT，INOUT）</h2><table><thead><tr><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>IN（默认值）</td><td>该类参数作为输入，也就是需要调用时传入值</td></tr><tr><td>OUT</td><td>该类参数作为输出，也就是该参数可以作为返回值</td></tr><tr><td>INOUT</td><td>既可以作为参数，也可以作为输出参数</td></tr></tbody></table><p>用法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名称([<span class="keyword">IN</span><span class="operator">/</span><span class="keyword">OUT</span><span class="operator">/</span><span class="keyword">INOUT</span> 参数名 参数类型])</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">sql</span>语句</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>例</p><ol><li><p>根据传入参数score，判断当前分数对应的分数等级，并返回</p></li><li><ol><li>score&gt;&#x3D;85分，等级为优秀</li><li>score&gt;&#x3D;60 且score&lt;85分，等级为及格</li><li>score&lt;60分，等级为不及格</li></ol></li><li><p>&#96;&#96;&#96;sql<br>create procedure p1(in score int,out result varchar(10))<br>begin<br>  if score &gt;&#x3D; 85 then<br>set result :&#x3D; ‘优秀’;<br>  elseif score &gt;&#x3D; 60 then<br>set result :&#x3D; ‘及格’;<br>  else<br>set result :&#x3D; ‘不及格’;<br>  end if;<br>end;</p><p>call p1(66,@result)<br>select @result;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. </span><br><span class="line"></span><br><span class="line">## case</span><br><span class="line"></span><br><span class="line">![](https://raw.githubusercontent.com/icyhalo/picgo/main/202310041516564.png)</span><br><span class="line"></span><br><span class="line">```sql</span><br><span class="line">--case</span><br><span class="line">--根据传入的月份，判断月份所属的季节（要求采用case结构）</span><br><span class="line">--1-3月份，为第一季度</span><br><span class="line">--4-6月份，为第二季度</span><br><span class="line">--7-9月份，为第三季度</span><br><span class="line">--10-12月份，为第四季度</span><br><span class="line"></span><br><span class="line">create procedure p6(in month int)</span><br><span class="line">begin</span><br><span class="line">  declare result varchar(10);</span><br><span class="line">  case </span><br><span class="line">when month&gt;=1 and month&lt;=3 then </span><br><span class="line">set result:=&#x27;第一季度&#x27;;</span><br><span class="line">      when month&gt;=4 and month&lt;=6 then </span><br><span class="line">    set result:=&#x27;第二季度&#x27;;</span><br><span class="line">when month&gt;=7 and month&lt;=9 then </span><br><span class="line">set result:=&#x27;第三季度&#x27;;</span><br><span class="line">      when month&gt;=10 and month&lt;=12 then </span><br><span class="line">    set result:=&#x27;第四季度&#x27;;</span><br><span class="line">else </span><br><span class="line">set result:=&#x27;非法参数&#x27;;</span><br><span class="line">end case;</span><br><span class="line">  select concat(&#x27;您输入的月份为&#x27;,month,&#x27;,所属的季度为：&#x27;,result);</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">call p6(4);</span><br></pre></td></tr></table></figure></li></ol><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p>while循环是有条件的循环控制语句。满足条件后，再执行循环体中的SQL语句。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">先判断条件，如果条件为<span class="literal">true</span>，则执行逻辑，否则不执行逻辑</span><br><span class="line">while 条件 do</span><br><span class="line">sql...</span><br><span class="line"><span class="keyword">end</span> while;</span><br></pre></td></tr></table></figure><p>例：</p><p>计算从1累加到n的值，n为传入的参数值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p7(<span class="keyword">in</span> n <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> total <span class="type">int</span> defult <span class="number">0</span>;</span><br><span class="line">while n<span class="operator">&gt;</span><span class="number">0</span> do</span><br><span class="line">  <span class="keyword">set</span> total :<span class="operator">=</span> total <span class="operator">+</span> n;</span><br><span class="line">  <span class="keyword">set</span> n :<span class="operator">=</span> n<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> p7(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h3><p>repeat是有条件的循环控制语句，当满足条件的时候退出循环。</p><blockquote><p>至少执行一次，其余和 while 相反</p></blockquote><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#先执行一次逻辑，然后判断逻辑是否满足，如果满足，则退出。如果不满足，则继续下一次循环</span><br><span class="line">repeat</span><br><span class="line">    <span class="keyword">sql</span>逻辑</span><br><span class="line">    until条件</span><br><span class="line"><span class="keyword">end</span> repeat;</span><br></pre></td></tr></table></figure><p>例：</p><p>计算从1累加到n的值，n为传入的参数值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--A，定义局部变量，记录累加之后的值</span></span><br><span class="line"><span class="comment">--B，每循环一次，就会对n进行减1，如果n减到0，则退出循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p8(<span class="keyword">in</span> n <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line">    <span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    repeat</span><br><span class="line">        <span class="keyword">set</span> total <span class="operator">=</span> total <span class="operator">+</span> n;</span><br><span class="line">        <span class="keyword">set</span> n <span class="operator">=</span> n<span class="number">-1</span>;</span><br><span class="line">        until n<span class="operator">&lt;=</span><span class="number">0</span></span><br><span class="line">    <span class="keyword">end</span> repeat;</span><br><span class="line">    <span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> p8(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">call</span> p8(<span class="number">11</span>);</span><br></pre></td></tr></table></figure><h3 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h3><p>loop实现简单的循环，如果不在SQL逻辑中增加退出循环的条件，可以用其来实现简单的死循环。loop可以配合以下两个语句使用：</p><ul><li>leave：配合循环使用，退出循环</li><li>iterate：必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--[begin_label]的意思是标记一个名字为 [begin_label] 的循环</span></span><br><span class="line"></span><br><span class="line">[begin_label]loop</span><br><span class="line">    <span class="keyword">sql</span>逻辑</span><br><span class="line"><span class="keyword">end</span> loop [end_label]</span><br><span class="line"></span><br><span class="line">leave label;    <span class="comment">--退出指定标记的循环体，label 循环的标识</span></span><br><span class="line">iterate label;  <span class="comment">--直接进入下一次循环</span></span><br></pre></td></tr></table></figure><p>例：</p><ol><li>计算从1累加到n的值，n为传入的参数值</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p9()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    sum:loop                       <span class="comment">-- sum:loop 意思是：创建一个名字为sum的loop循环，从此处开始</span></span><br><span class="line">        if n<span class="operator">&lt;=</span><span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">            leave sum;             <span class="comment">-- leave sum 意思是：如果满足if的条件，则结束sum整这个循环</span></span><br><span class="line">        <span class="keyword">end</span> if;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">set</span> total <span class="operator">=</span> total <span class="operator">+</span> n;</span><br><span class="line">        <span class="keyword">set</span> n <span class="operator">=</span> n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">end</span> loop sum;                  <span class="comment">-- end loop sum 意思是：结束loop循环</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> p9(<span class="number">10</span>)  ;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>计算从1到n之间的偶数累加的值，n为传入的参数值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--分析问题，解决思路</span></span><br><span class="line"><span class="comment">--A，定义局部变量，记录累加之后的值</span></span><br><span class="line"><span class="comment">--B，每循环一次，就会对n进行-1，如果n减到0，则退出循环  -----&gt; leave xxx</span></span><br><span class="line"><span class="comment">--C，如果当次累加的数据是奇数，则直接进入下一次循环     -----&gt; iterate xxx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p10(<span class="keyword">in</span> n <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    sum:loop</span><br><span class="line">        if n<span class="operator">&lt;=</span><span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">            leave sum;</span><br><span class="line">        <span class="keyword">end</span> if;</span><br><span class="line">        </span><br><span class="line">        if n<span class="operator">%</span><span class="number">2</span> <span class="operator">=</span><span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">set</span> n<span class="operator">=</span> n<span class="number">-1</span>;</span><br><span class="line">            iterate sum;</span><br><span class="line">        <span class="keyword">end</span> if;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">set</span> total <span class="operator">=</span> total <span class="operator">+</span> n;</span><br><span class="line">        <span class="keyword">set</span> n<span class="operator">=</span>n<span class="number">-1</span>；</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">end</span> loop sum;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> p10(<span class="number">100</span>);</span><br></pre></td></tr></table></figure></li></ol><h2 id="游标-cursor"><a href="#游标-cursor" class="headerlink" title="游标 cursor"></a>游标 cursor</h2><p>游标（cursor）是用来存储查询结果集的数据类型，在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括游标的声明、open、fetch、close</p><p>声明</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> 游标名称 <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> 查询语句;</span><br></pre></td></tr></table></figure><p>open</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">OPEN</span> 游标名称;  </span><br></pre></td></tr></table></figure><p>fetch</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FETCH</span> 游标名称 <span class="keyword">INTO</span> 变量[，变量];</span><br></pre></td></tr></table></figure><p>close</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CLOSE</span> 游标名称;</span><br></pre></td></tr></table></figure><p>例.</p><p>根据传入的参数uage，来查询用户表tb_user中，所有的用户年龄小于等于uage的用户姓名(name)和专业(profession),并将用户的姓名和专业插入到所创建的一张新表(id,name,profession)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--逻辑</span></span><br><span class="line"><span class="comment">--A,声明游标，存储查询结果集</span></span><br><span class="line"><span class="comment">--B，准备：创建表结构</span></span><br><span class="line"><span class="comment">--C，开启游标</span></span><br><span class="line"><span class="comment">--D，获取游标中的记录</span></span><br><span class="line"><span class="comment">--E，插入数据到新表中</span></span><br><span class="line"><span class="comment">--F，关闭游标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p11(<span class="keyword">in</span> uage <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> uname <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">declare</span> upro <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">declare</span> u_cursor <span class="keyword">cursor</span> <span class="keyword">for</span> <span class="keyword">select</span> name,profession <span class="keyword">from</span> tb_user <span class="keyword">where</span> age<span class="operator">&lt;=</span>uage;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> tb_user_pro;</span><br><span class="line">    <span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> tb_user_pro(</span><br><span class="line">        id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">        name <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">        profession <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">open</span> u_cursor;</span><br><span class="line">    while ture do</span><br><span class="line">        <span class="keyword">fetch</span> u_cursor <span class="keyword">into</span> uname,upro;</span><br><span class="line">        <span class="keyword">insert</span> <span class="keyword">into</span> ub_user_pro <span class="keyword">values</span>(<span class="keyword">null</span>, uname,upro);</span><br><span class="line">    <span class="keyword">end</span> while;</span><br><span class="line">    <span class="keyword">close</span> u_cursor;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><p>触发器是与表有关的数据库对象，指在insert&#x2F;update&#x2F;delete之前或之后，触发并执行触发器中定义的SQL语句集合。<strong>触发器的这种特性可以协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作。</strong></p><p>使用别名OLD或者NEW来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还支持行级触发（触发几次就执行几次），不支持语句级触发（针对这一个语句只触发一次）。</p><p><strong>查看触发器有没有触发只需要去日志表中查看有无数据即可。</strong></p><table><thead><tr><th>类型</th><th>old 和 new</th></tr></thead><tbody><tr><td>insert型</td><td>new表示将要或者已经新增的数据</td></tr><tr><td>update型</td><td>old表示修改之前的数据，new表示将要或已经修改后的数据</td></tr><tr><td>delete型</td><td>old表示修改之前的数据,，new表示将要或已经修改后的数据</td></tr></tbody></table><p>创建触发器</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> 触发器名称</span><br><span class="line">before<span class="operator">/</span>after <span class="keyword">insert</span><span class="operator">/</span><span class="keyword">update</span><span class="operator">/</span><span class="keyword">delete</span> <span class="comment">--前后触发 和 类型</span></span><br><span class="line"><span class="keyword">on</span> 表名 <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span>  <span class="comment">--行级触发器</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    trigger_stmt;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>查看触发器</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> triggers;</span><br></pre></td></tr></table></figure><p>删除触发器</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">trigger</span> 表名.触发器名;  <span class="comment">--如果不指定表名，默认为当前数据库</span></span><br></pre></td></tr></table></figure><h3 id="例-insert触发器"><a href="#例-insert触发器" class="headerlink" title="例.insert触发器"></a>例.insert触发器</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">创建触发器</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tb_user_insert_trigger</span><br><span class="line">after <span class="keyword">update</span> <span class="keyword">on</span> tb_user <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> user_logs(id, operation, operation_time, operation_id, operate_params) <span class="keyword">values</span></span><br><span class="line">    (<span class="keyword">null</span>, <span class="string">&#x27;insert&#x27;</span>, now(), new.id, concat(<span class="string">&#x27;插入的数据内容为：id=&#x27;</span>, new.id,<span class="string">&#x27;,name=&#x27;</span>,new.name,<span class="string">&#x27;,phone=&#x27;</span>,new.phone,<span class="string">&#x27;,email=&#x27;</span>,new.eamil,<span class="string">&#x27;,profession=&#x27;</span>,new.profession))</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">查看触发器</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">trigger</span>;</span><br><span class="line"></span><br><span class="line">删除触发器</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">trigger</span> tb_user_insert_trigger;</span><br><span class="line"></span><br><span class="line">验证tb_user_insert_trigger触发器效果</span><br><span class="line"><span class="comment">--1.先插入数据到tb_user</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_user(id,name,phone,email,profession,age,gender,status,createtime)</span><br><span class="line"><span class="keyword">values</span>(<span class="number">25</span>,<span class="string">&#x27;二皇子&#x27;</span>,<span class="string">&#x27;18809091212&#x27;</span>,<span class="string">&#x27;erhuangzi@163.com&#x27;</span>,<span class="string">&#x27;软件工程&#x27;</span>,<span class="number">23</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,now());</span><br><span class="line"></span><br><span class="line"><span class="comment">--2.查看日志表是否含有新插入的数据</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user_logs;</span><br><span class="line"></span><br><span class="line"><span class="comment">--3.再插入一条数据到tb_user</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_user(id,name,phone,email,profession,age,gender,status,createtime)</span><br><span class="line"><span class="keyword">values</span>(<span class="number">26</span>,<span class="string">&#x27;三皇子&#x27;</span>,<span class="string">&#x27;18809091212&#x27;</span>,<span class="string">&#x27;erhuangzi@163.com&#x27;</span>,<span class="string">&#x27;软件工程&#x27;</span>,<span class="number">23</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,now());</span><br><span class="line"></span><br><span class="line"><span class="comment">--4.再次查看日志表是否含有新插入的数据</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user_logs;</span><br></pre></td></tr></table></figure><h3 id="例-update触发器"><a href="#例-update触发器" class="headerlink" title="例.update触发器"></a>例.update触发器</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--1.创建update类型的触发器</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tb_user_update_trigger</span><br><span class="line">after <span class="keyword">update</span> <span class="keyword">on</span> tb_user <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> user_logs(id, operation, operation_time, operation_id, operation_param) <span class="keyword">values</span></span><br><span class="line">    (<span class="keyword">null</span>,<span class="string">&#x27;update&#x27;</span>,now(),new.id, </span><br><span class="line">        concat(<span class="string">&#x27;更新之前的数据：id=&#x27;</span>,old.id,<span class="string">&#x27;,name=&#x27;</span>,<span class="string">&#x27;,name=&#x27;</span>,old.name,<span class="string">&#x27;,phone=&#x27;</span>,old.phone,<span class="string">&#x27;,email=&#x27;</span>,old.eamil,<span class="string">&#x27;,profession=&#x27;</span>,old.profession,</span><br><span class="line">        <span class="string">&#x27;| 更新之后的数据：id=&#x27;</span>,new.id,<span class="string">&#x27;,name=&#x27;</span>,new.name,<span class="string">&#x27;,phone=&#x27;</span>,new.phone,<span class="string">&#x27;,email=&#x27;</span>,new.eamil,<span class="string">&#x27;,profession=&#x27;</span>,new.profession)</span><br><span class="line">    );</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--2.更新tb_user表中的数据</span></span><br><span class="line"><span class="keyword">update</span> tb_user <span class="keyword">set</span> profession <span class="operator">=</span><span class="string">&#x27;会计&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span><span class="number">23</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--3.验证tb_user_update_trigger触发器是否有作用，查看user_logs表数据</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>  user_logs;  </span><br></pre></td></tr></table></figure><h3 id="例-delete触发器"><a href="#例-delete触发器" class="headerlink" title="例.delete触发器"></a>例.delete触发器</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--1，创建删除触发器</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tb_user_delete_trigger</span><br><span class="line">after <span class="keyword">delete</span> <span class="keyword">on</span> tb_user <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> user_logs(id, operation, operation_time, operation_id, operation_param) <span class="keyword">values</span></span><br><span class="line">    (<span class="keyword">null</span>,<span class="string">&#x27;update&#x27;</span>,now(),new.id, </span><br><span class="line">        concat(<span class="string">&#x27;删除之前的数据：id=&#x27;</span>,old.id,<span class="string">&#x27;,name=&#x27;</span>,<span class="string">&#x27;,name=&#x27;</span>,old.name,<span class="string">&#x27;,phone=&#x27;</span>,old.phone,<span class="string">&#x27;,email=&#x27;</span>,old.eamil,<span class="string">&#x27;,profession=&#x27;</span>,old.profession));</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--2，删除tb_user表中的数据</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> id<span class="operator">=</span><span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--3,验证删除触发器是否执行，查询user_logs表中是否有删除的记录数据</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user_logs;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310041710156.png"></p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源(CPU、RAM、I&#x2F;O)的争用以外，数据也是一种供多个用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，针对数据库而言显得尤为重要，也更加复杂。</p><p>MySQL中的锁，按照锁的粒度分，分为以下三类：</p><ol><li>全局锁：锁定数据库中的所有表</li><li>表级锁：每次操作锁住整张表</li><li>行级锁：每次操作锁住对应的行数据</li></ol><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。</p><p>其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性的视图，保证数据的完整性。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--1.添加全局锁</span></span><br><span class="line">mysql<span class="operator">&gt;</span> flush tables <span class="keyword">with</span> read lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">--2.备份表,直接在cmd命令中执行</span></span><br><span class="line">CMD: mysqldump <span class="operator">-</span>h ip <span class="operator">-</span>u用户名 <span class="operator">-</span>p密码 数据库名 <span class="operator">&gt;</span> 磁盘路径<span class="operator">/</span>文件名.<span class="keyword">sql</span></span><br><span class="line">CMD: mysqldump <span class="operator">-</span>h <span class="number">192.168</span><span class="number">.200</span><span class="number">.202</span> <span class="operator">-</span>uroot <span class="operator">-</span>p1234 db01 <span class="operator">&gt;</span> D:<span class="operator">/</span>db01.sql</span><br><span class="line"></span><br><span class="line"><span class="comment">--3.释放锁</span></span><br><span class="line">mysql<span class="operator">&gt;</span> unlook tables;</span><br></pre></td></tr></table></figure><ul><li>特点</li></ul><p>数据库中加全局锁，是一个比较中的操作，存在以下问题：</p><ol><li>如果在主库中备份，那么在备份期间都不能执行更新，业务基本上就得停摆</li><li>如果在从库中备份，那么在备份期间从库不能执行主库同步过来的二进制日志(binlog)，会导致主从延迟</li></ol><p> 在InnoDB引擎中，我们可以在备份时加上参数 –single-transaction 参数来完成不加锁的一致性数据备份</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="comment">--single-transaction -uroot -p1234 itcast &gt; itcast.sql</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310041718267.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310041722798.png"></p><blockquote><p>此时只能查询，其他语句都无效</p></blockquote><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310041726659.png"></p><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>表级锁，每次操作锁住整张锁。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中</p><p>对于表级锁，主要分为以下三类：</p><ol><li>表锁</li><li>元数据锁（meta data lock, MDL）</li><li>意向锁</li></ol><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>对于表锁，分为两类：</p><ol><li>表共享读锁 &#x2F; 读锁（read lock）</li><li>表独占写锁 &#x2F; 写锁（write lock）</li></ol><p>语法</p><ol><li>加锁：lock tables 表名 …… read&#x2F;write;</li><li>释放锁：unlock tables&#x2F; 客户端断开连接</li></ol><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310042151317.png"></p><blockquote><p>加读锁，其他进程能读不能写</p><p>加写锁，其他进程能读不能写也不能读</p></blockquote><h3 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h3><p>MDL（meta data lock）加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与DDL冲突(增删改查和修改表结构语句的冲突)，保证读写的正确性。</p><p>在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁（共享）；当对表结构进行变更操作的时候，加MDL写锁（排他）</p><blockquote><p>元数据简单理解就是 表结构</p></blockquote><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310042155630.png"></p><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查<br><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310042202748.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310042203183.png"></p><ol><li>意向共享锁（IS）：与表锁共享锁(read)兼容，与表锁排它锁（write）互斥。由语句select ….. Lock in share mode添加</li><li>意向排它锁（IX）：与表锁共享锁(read)及排他锁（write）都互斥。意向锁之间不会互斥。由insert、update、delete、select…..for update 添加</li></ol><p>线程A执行：首先begin开启事务，执行update的时候会将指定行的加上行锁，紧接着会对整张表加上一个意向锁</p><p>线程B执行的之前，会检查这张表得到意向锁情况，能否加上线程B的锁取决于对意向锁的判断。如果线程B添加的表锁和线程A的意向锁兼容，则可以加锁。如果不兼容，则线程B处于阻塞状态，阻塞状态随着线程A事务的commit提交，释放意向锁和行锁之后，线程B才能加表锁。</p><p>可以通过以下SQL，查看意向锁及行锁的加锁情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> object_schema, object_name, index_name, lock_type, lock_mode, lock_data </span><br><span class="line"><span class="keyword">from</span> performance_schema.data_locks;</span><br></pre></td></tr></table></figure><h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。</p><p>InnoDB的数据是基于索引组织的，行锁的通过对索引上的索引项来加锁实现的，而不是对记录加的锁。对于行级锁，主要分为三类：</p><ol><li>行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此进行update和delete。在Read Commit、Read Repeatable隔离级别下都支持</li><li>间隙锁（Gap Lock ）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RP隔离级别下都支持</li><li>临键锁（Next-key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RP隔离级别下支持</li></ol><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310042035102.png"></p><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p>InnoDB实现了以下两种类型的行锁</p><ol><li>共享锁（S）：运行一个事务去读一行，阻止其他事务获得相同数据集的排他锁</li><li>排他锁（X）：运行获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁</li></ol><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310042037218.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310042043978.png"></p><h4 id="行锁演示"><a href="#行锁演示" class="headerlink" title="行锁演示"></a>行锁演示</h4><p>默认情况下，InnoDB在Repeatable Read事务隔离级别运行，在InnoDB使用next-key锁进行搜索和索引扫描，以防止幻读</p><ol><li>针对唯一索引进行检索时，对已存在的记录进行等值匹配，将会自动优化为行锁</li><li>InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会升级为表锁。</li></ol><p>可以通过以下SQL，查看意向锁及行锁的加锁情况</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> object<span class="operator">-</span>schema, object_name, index_name, lock_type, lock_mode, lock_data</span><br><span class="line"><span class="keyword">from</span> performance_schema.data_locks;</span><br></pre></td></tr></table></figure><h3 id="间隙锁、临键锁"><a href="#间隙锁、临键锁" class="headerlink" title="间隙锁、临键锁"></a>间隙锁、临键锁</h3><p>默认情况下，InnoDB在RepeatableRead事务隔离级别运行，InnoDB使用next-key锁进行搜索和索引扫描，以防止幻读</p><ol><li>索引上的等值查询（唯一索引），给不存在的记录加锁时，优化为间隙锁</li><li>索引上的等值查询（普通索引），向右遍历时最后一个值不满足查询需求时，next-key lock退化为间隙锁</li><li>索引上的范围查询（唯一索引），会访问到不满足条件的第一个值为止</li></ol><blockquote><p>间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一个间隙上采用间隙锁。</p><p>间隙锁不包含边界，只包含间隙范围 ()</p><p>临键锁包含边界数据和间隙范围 []</p></blockquote><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310042133775.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310042207350.png"></p><h1 id="InnoDB引擎"><a href="#InnoDB引擎" class="headerlink" title="InnoDB引擎"></a>InnoDB引擎</h1><h2 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310050937462.png"></p><p><strong>表空间（idb文件）</strong>：一个MySQL实例可以对应多个表空间，用来存储记录、索引等数据</p><p><strong>段</strong>：分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段（Rollback segment）、InnoDB是索引组织表，数据段就是B+树的叶子节点，索引段即为B+树的非叶子节点。段用来管理多个Extent（区）</p><p><strong>区</strong>：表空间的单元结构，每个区的大小为1M。默认情况下，InnoDB存储引擎页大小为16K，即一个区中一共有64个连续的页。</p><p><strong>页</strong>：是InnoDB存储引擎磁盘管理的最小单元，每个页的大小默认为16KB。为了保证页的连续性，InnoDB存储引擎每次从磁盘申请4–5个区</p><p><strong>行</strong>：InnoDB存储引擎数据是按行进行存放的。</p><p>Trx_id：每次对某条记录进行改动时，都会把对应的事务Id赋值给Tri_id隐藏列</p><p>Roll_pointer：每次对某条记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310050940962.png"></p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>MySQL5.5版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发中使用非常广泛。下面是InnoDB架构图，左侧为内存结构，右侧为磁盘结构</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310050942995.png"></p><h3 id="内存架构"><a href="#内存架构" class="headerlink" title="内存架构"></a>内存架构</h3><h4 id="Buffer-Pool：缓冲池"><a href="#Buffer-Pool：缓冲池" class="headerlink" title="Buffer Pool：缓冲池"></a>Buffer Pool：缓冲池</h4><p>缓冲池是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度。</p><p>缓冲池以Page页为单位，底层采用链表数据结构管理Page。根据状态，将Page分为三种类型（上图中不同颜色的方块表示）</p><ul><li>Free page：空闲page，未被使用</li><li>Clean page：被使用page，数据没有被修改过</li><li>Dirty page：脏页，被使用page，数据被修改过，页中数据与磁盘的数据产生了不一致。</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310050943396.png"></p><h4 id="Change-Buffer：更改缓冲区"><a href="#Change-Buffer：更改缓冲区" class="headerlink" title="Change Buffer：更改缓冲区"></a>Change Buffer：更改缓冲区</h4><p>Change buffer：更改缓冲区（针对于非唯一二级索引页），在执行DML语句时，如果这些数据Page没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区Change Buffer中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中</p><p><strong>Change Buffer的意义是什么？</strong></p><p>与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量得到磁盘IO。有了Change Buffer之后，我们可以在缓冲池中进行合并处理，减少磁盘IO</p><h4 id="Adaptive-hash-Index：自适应哈希索引"><a href="#Adaptive-hash-Index：自适应哈希索引" class="headerlink" title="Adaptive hash Index：自适应哈希索引"></a>Adaptive hash Index：自适应哈希索引</h4><p>自适应hash索引，用于优化对BufferPool数据的查询。InnoDB存储引擎会监控对表上各索引页的查询，如果观察到hash索引可以提升速度，则建立Hash索引，称之为自适应hash索引</p><p>自适应哈希索引，无需人工干预，是系统根据情况自动完成的</p><p>参数：adaptive_hash_index</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%hash_index%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--on 表示开启</span></span><br></pre></td></tr></table></figure><h4 id="Log-Buffer：日志缓存区"><a href="#Log-Buffer：日志缓存区" class="headerlink" title="Log Buffer：日志缓存区"></a>Log Buffer：日志缓存区</h4><p>用来保存要写入到磁盘中的log日志数据（redo log、undo log），默认大小为16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或者删除许多行的事务，增加日志缓冲区的大小可以节省磁盘I&#x2F;O</p><p>参数： innodb_log_buffer_size：缓冲区大小</p><p> innodb_flush_log_at_trx_commit：日志刷新到磁盘时机。 </p><p>0：每秒将日志写入并刷新到磁盘一次</p><p>1：日志在每次事务提交时写入并刷新到磁盘（默认值）</p><p>2：日志在每次事务提交后写入，并每秒刷新到磁盘一次</p><h3 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h3><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310050950558.png"></p><h4 id="System-Tablespace"><a href="#System-Tablespace" class="headerlink" title="System Tablespace"></a>System Tablespace</h4><p>系统表空间是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建的，它也可能包含表和索引数据。（在MySQL5.x版本中还包含InnoDB数据字典、undolog等）</p><p>参数：innodb_data_file_path</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310050952666.png"></p><h4 id="File-Per-Tablespaces"><a href="#File-Per-Tablespaces" class="headerlink" title="File-Per-Tablespaces"></a>File-Per-Tablespaces</h4><p>每个表的文件表空间包含单个InnoDB表的数据和索引，并存储在文件系统上的单个数据文件中</p><p>参数：innodb_file_per_table。</p><p>on表示每一张表都会生成一个表空间文件。下图 .idb 结尾的文件就是表空间文件。每个表空间文件中存储的是这个表的表结构、数据、索引</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310050953194.png"></p><h4 id="General-Tablespace"><a href="#General-Tablespace" class="headerlink" title="General Tablespace"></a>General Tablespace</h4><p>通用表空间，需要通过CREATE TABLESPACE语法创建通用表空间，在创建表时，可以指定该表空间</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--创建通用表空间语法</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span>space xxx <span class="keyword">add</span> datafile <span class="string">&#x27;文件名&#x27;</span> engine <span class="operator">=</span> 引擎名称;</span><br><span class="line"></span><br><span class="line"><span class="comment">--实操案例，创建表空间</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span>space ts_itheima <span class="keyword">add</span> datafile <span class="string">&#x27;myitheima.idb&#x27;</span> engin <span class="operator">=</span> innodb;</span><br><span class="line"></span><br><span class="line">use itcast;</span><br><span class="line"></span><br><span class="line"><span class="comment">--创建表，指定这个表的表空间为ts_itheima </span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> a(id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment, name <span class="type">varchar</span>(<span class="number">20</span>))engine<span class="operator">=</span>innodb tablespace ts_itheima;</span><br></pre></td></tr></table></figure><h4 id="Undo-Tablespace"><a href="#Undo-Tablespace" class="headerlink" title="Undo Tablespace"></a>Undo Tablespace</h4><p>撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间（初始化大小16M），用于存储undo log日志</p><h4 id="Temporary-Tablespace"><a href="#Temporary-Tablespace" class="headerlink" title="Temporary Tablespace"></a>Temporary Tablespace</h4><p>InnoDB使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据</p><h4 id="Doublewrite-Buffer-Files"><a href="#Doublewrite-Buffer-Files" class="headerlink" title="Doublewrite Buffer Files"></a>Doublewrite Buffer Files</h4><p>双写缓冲区，innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入到双写缓冲区文件中，便于系统异常时恢复数据</p><h4 id="Redo-log"><a href="#Redo-log" class="headerlink" title="Redo log"></a>Redo log</h4><p>重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲(在内存中，redo log buffer)以及重做日志文件(在磁盘中，redo log)。当事务提交之后会把所有修改信息都会存到该日志中，用于在刷新脏页到磁盘时，发生错误时，进行数据恢复使用。</p><p>以循环方式写入重做日志文件，涉及两个文件：ib_logfile0 , ib_logfile1</p><h3 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h3><p>后台线程的作用就是在合适的时机将InnoDB存储引擎缓冲池的数据刷新到磁盘文件当中。</p><p>后台线程有4种：</p><ol><li><p>Master Thread  </p><p>核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中，保持数据的一致性，还包括脏页的刷新、合并插入缓存、undo页的回收</p></li><li><p>IO Thread  </p><p>在InnoDB存储引擎中大量使用了AIO(异步IO)来处理IO请求，这样可以极大的提高数据库的性能，而IO Thread主要负责这些IO请求的回调</p></li></ol><table><thead><tr><th>线程类型</th><th>默认个数</th><th>职责</th></tr></thead><tbody><tr><td>Read thread</td><td>4</td><td>负责读操作</td></tr><tr><td>Write thread</td><td>4</td><td>负责写操作</td></tr><tr><td>Log thread</td><td>1</td><td>负责将日志缓冲区刷新到磁盘</td></tr><tr><td>Insert buffer thread</td><td>1</td><td>负责将写缓冲区内容刷新到磁盘</td></tr></tbody></table><ol start="3"><li><p>Purge Thread</p><p>主要用于回收事务已经提交了undo log，在事务提交之后，undo log可能不用了 ，就用此线程来回收</p></li><li><p>Page Cleaner Thread</p><p>协助Master Thread刷新脏页到磁盘的线程，他可以减轻Master Thread的工作压力，减少阻塞。</p></li></ol><h2 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h2><h3 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a><strong>什么是事务？</strong></h3><p>是一组操作的集合，他是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败</p><h3 id="事务的特点"><a href="#事务的特点" class="headerlink" title="事务的特点"></a><strong>事务的特点</strong></h3><ul><li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败</li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li><li>持久性（Durability）：事务一旦提交或回滚，它对数据库的数据的改变就是永久的</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051012233.png"></p><h3 id="Redo-log-–-持久性"><a href="#Redo-log-–-持久性" class="headerlink" title="Redo log – 持久性"></a>Redo log – 持久性</h3><p>重做日志，记录的是事务提交时数据页的物理修改，<strong>是用来实现事务的持久性</strong>。</p><p>该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file）,前者是在内存中，后者是在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中，用于在刷新脏页到磁盘，发生错误时，进行数据恢复使用</p><p>正常执行的先后顺序是1234，当4（缓冲池的数据刷新到磁盘时）发生了错误，此时redo log的两份日志文件会将数据正确的同步到相应操作受影响的表空间(.ibd文件)中</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051017488.png"></p><h3 id="Undo-log-–-原子性"><a href="#Undo-log-–-原子性" class="headerlink" title="Undo log – 原子性"></a>Undo log – 原子性</h3><p> 回滚日志，用于记录数据被修改前的信息，作用包含两个：提供回滚和MVCC（多版本并发控制）</p><p>Undo log（逻辑日志）和 redo log（物理日志）不一样。可以认为当delete一条数据时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚</p><p>Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC</p><p>Undo log存储：undo log采用段的方式进行管理和记录，存放在前面介绍的rollback segment回滚段中，内部包含1024个undo log segment</p><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><ul><li><strong>当前读</strong></li></ul><p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如select … Lock in share mode(共享锁),select … For update、update、insert、delete（排他锁）都是一种当前读。</p><ul><li><strong>快照读</strong></li></ul><p>简单的select（不加锁）就是快照读，快照读读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。</p><ul><li><p>Read Committted：每次select，都生成一个快照读</p></li><li><p>Repeatable Read：开始事务后第一个select语句才是快照读的地方</p></li><li><p>Serializable：快照读会退化为当前读。</p></li><li><p><strong>MVCC</strong></p></li></ul><p>全称Muti-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySql实现MVCC提供一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库中的三个隐式字段、undo log日志、readView</p><h3 id="MVCC–实现原理"><a href="#MVCC–实现原理" class="headerlink" title="MVCC–实现原理"></a>MVCC–实现原理</h3><h4 id="记录中的隐藏字段"><a href="#记录中的隐藏字段" class="headerlink" title="记录中的隐藏字段"></a>记录中的隐藏字段</h4><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051031987.png"></p><p>如图所示，当创建表的字段有 id age name的时候，MySQL会创建 DB_TRX_ID，DB_ROLL_PTR，DB_ROW_ID这三个隐藏字段</p><table><thead><tr><th>隐藏字段</th><th>含义</th></tr></thead><tbody><tr><td>DB_TRX_ID</td><td>最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID</td></tr><tr><td>DB_ROLL_PTR</td><td>回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版本</td></tr><tr><td>DB_ROW_ID</td><td>隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查看表空间文件，表空间文件中可以查看表的详细信息，比如数据库的版本号，表的所有字段（包括隐藏字段）</span><br><span class="line">ibd2sdi xxx.ibd</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051033402.png"></p><h4 id="Undo-log版本链"><a href="#Undo-log版本链" class="headerlink" title="Undo log版本链"></a>Undo log版本链</h4><ul><li><p>Undo log</p><p>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志</p><p>当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。</p><p>而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会被立即删除。</p></li><li><p>Undo log 版本链</p><p>不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条记录版本链表，链表的头部是最新的旧纪录，链表尾部是最早的旧纪录。</p><p>那么我执行一条查询语句，数据库给我反馈的数据到底是哪个版本，是谁控制决定的呢？看下面ReadView</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051039486.png" alt="初始"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051039179.png"></p></li></ul><h4 id="Readview"><a href="#Readview" class="headerlink" title="Readview"></a>Readview</h4><p>ReadView(读视图)是快照读SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id.</p><p>readview中包含了四个核心字段：</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>m_ids</td><td>当前活跃的事务ID集合</td></tr><tr><td>min_trx_id</td><td>最小活跃事务ID</td></tr><tr><td>max_trx_id</td><td>预分配事务ID，当前最大事务ID+1（因为事务ID是自增的）</td></tr><tr><td>create_trx_id</td><td>ReadView创建者的事务ID</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051044061.png"></p><p><strong>不同的隔离级别，生成ReadView的时机不同：</strong></p><ul><li><strong>READ COMMITTED：在事务中每一次执行快照读时生成ReadView</strong></li><li><strong>REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView</strong></li></ul><h3 id="MVCC–原理分析"><a href="#MVCC–原理分析" class="headerlink" title="MVCC–原理分析"></a>MVCC–原理分析</h3><p>RC读已提交隔离级别下，在事务中每一次执行快 照读时生成ReadView。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051048472.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051055787.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051055429.png"></p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051055494.png"></p><h1 id="MySQL管理"><a href="#MySQL管理" class="headerlink" title="MySQL管理"></a>MySQL管理</h1><h2 id="系统数据库介绍"><a href="#系统数据库介绍" class="headerlink" title="系统数据库介绍"></a>系统数据库介绍</h2><p>MySQL数据库安装完成后，自带了以下四个数据库（8.0之后），具体作用如下：</p><table><thead><tr><th>数据库</th><th>含义</th></tr></thead><tbody><tr><td>mysql</td><td>存储MySQL服务器正常运行所需要的各种信息（时区、主从、用户、权限等）</td></tr><tr><td>information_schema</td><td>提供了访问数据库元数据的各种表和视图，包含数据库、表、字段类型及访问权限</td></tr><tr><td>performance_schema</td><td>为MySQL服务器运行时状态提供了一个底层监控功能，主要用于收集数据库服务器性能参数</td></tr><tr><td>sys</td><td>包含了一系列方便DBA和开发人员利用performance_schema性能数据库进行性能调优和诊断的视图</td></tr></tbody></table><h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h2><h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><p>该mysql不是指mysql服务，而是指mysql的客户端工具</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--语法</span></span><br><span class="line">mysql [options] [database]</span><br><span class="line"></span><br><span class="line"><span class="comment">--选项</span></span><br><span class="line"><span class="operator">-</span>u, <span class="comment">--user=name         #指定用户名</span></span><br><span class="line"><span class="operator">-</span>p, <span class="comment">--password[=name]   #指定密码</span></span><br><span class="line"><span class="operator">-</span>h, <span class="comment">--host=name         #指定服务器IP或域名</span></span><br><span class="line"><span class="operator">-</span>P, <span class="comment">--port=port         #指定连接端口</span></span><br><span class="line"><span class="operator">-</span>e, <span class="comment">--execute=name      #执行SQL语句并退出</span></span><br></pre></td></tr></table></figure><p>-e选项可以在MySQL客户端执行SQL语句，而不用连接到MySQL数据库再执行，对于一些批处理脚本，这种方式尤其方便，实例如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">-</span>uroot <span class="operator">-</span>p123456 db01 <span class="operator">-</span>e &quot;select * from stu&quot;;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051116745.png"></p><h3 id="mysqladmin"><a href="#mysqladmin" class="headerlink" title="mysqladmin"></a>mysqladmin</h3><p>mysqladmin是一个执行管理操作的客户端程序。可以用它来检查服务器的配置和当前状态、创建并删除数据库等</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--通过帮助文档查看选项</span></span><br><span class="line">mysqladmin <span class="comment">--help</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--示例</span></span><br><span class="line">mysqladmin <span class="operator">-</span>uroot <span class="operator">-</span>p123456 <span class="keyword">drop</span> <span class="string">&#x27;test01&#x27;</span>;   <span class="comment">--删除数据库test01</span></span><br><span class="line"></span><br><span class="line">mysqladmin <span class="operator">-</span>uroot <span class="operator">-</span>p123456 version;         <span class="comment">--查看数据库版本信息</span></span><br></pre></td></tr></table></figure><h3 id="mysqlbinlog"><a href="#mysqlbinlog" class="headerlink" title="mysqlbinlog"></a>mysqlbinlog</h3><p>由于服务器生成的二进制日志文件以二进制格式保存，所以如果想要检查这些文本的文本格式，就会使用到mysqlbinlog日志管理工具</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">mysqlbinlog [options] log<span class="operator">-</span>files1 log<span class="operator">-</span>files2......</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line"><span class="operator">-</span>d, <span class="comment">--database=name                 指定数据库名称，只列出指定的数据库相关操作</span></span><br><span class="line"><span class="operator">-</span>o, <span class="comment">--offser=#                              忽略掉日志中的前n行命令</span></span><br><span class="line"><span class="operator">-</span>r, <span class="comment">--result-file=name                   将输出的文本格式日志输出到指定文件</span></span><br><span class="line"><span class="operator">-</span>s, <span class="comment">--short-form                           显示简单格式，省略掉一些信息</span></span><br><span class="line"><span class="comment">--start-datatime=data1  --stop-datatime=data2     指定日期间隔内的所有日志</span></span><br><span class="line"><span class="comment">--start-position=pos1  --stop-position=pos2          指定位置间隔内的所有日志</span></span><br></pre></td></tr></table></figure><h3 id="mysqlshow"><a href="#mysqlshow" class="headerlink" title="mysqlshow"></a>mysqlshow</h3><p>mysqlshow客户端对象查找工具，用来很快的查找存在哪些数据库、数据库中的表、表中的列、或者索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">Mysqlshow [options] [db_name [table_name[column_name]]]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line"><span class="comment">--count     显示数据库及表的统计信息（数据库，表均可不指定）</span></span><br><span class="line"><span class="operator">-</span>i              显示指定数据库或者指定表的状态信息</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">\#查询每个数据库的表的数量及表中记录的数量</span><br><span class="line">mysqlshow <span class="operator">-</span>uroot <span class="operator">-</span>p123456 <span class="comment">--count</span></span><br><span class="line">\#查询test数据库中每个表中的字段数，及行数</span><br><span class="line">mysqlshow <span class="operator">-</span>uroot <span class="operator">-</span>p123456 test <span class="comment">--count</span></span><br><span class="line">\#查询test数据库中book表的详细情况</span><br><span class="line">mysqlshow <span class="operator">-</span>uroot <span class="operator">-</span>p123456 test book <span class="comment">--count</span></span><br></pre></td></tr></table></figure><h3 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h3><p>mysqldump客户端工具用来被封数据库或在不同数据库之间进行数据迁移。备份内容包含创建表，及插入表的SQL语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">语法</span><br><span class="line">Mysqldump [options] db_name [tables]</span><br><span class="line">Mysqldump [options] <span class="comment">--database / -B db1 [db2 db3...]</span></span><br><span class="line">Mysqldump [options] <span class="comment">--all -databases /-A</span></span><br><span class="line"></span><br><span class="line">连接选项：</span><br><span class="line"><span class="operator">-</span>u，<span class="comment">--user=name              指定用户名</span></span><br><span class="line"><span class="operator">-</span>p，<span class="comment">--password[=name]    指定密码</span></span><br><span class="line"><span class="operator">-</span>h，<span class="comment">--host=name               指定服务器ip或域名</span></span><br><span class="line"><span class="operator">-</span>P，<span class="comment">--port=#                      指定连接端口</span></span><br><span class="line"></span><br><span class="line">输出选项：</span><br><span class="line"><span class="comment">--add-drop-database         在每个数据库创建语句前加上drop database语句</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java枚举和注解</title>
      <link href="/2023/05/25/Java%E6%9E%9A%E4%B8%BE/"/>
      <url>/2023/05/25/Java%E6%9E%9A%E4%B8%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>把具体的对象一一列举出来的类，就称为 枚举类（enumeration）。</p><p>枚举是一组常量的集合。可以这里理解：枚举属于一种特殊的类，里面只包含一组有限的特定的对象。</p><p>实现方法：</p><ol><li>自定义枚举</li><li>enum 关键字枚举</li></ol><h2 id="自定义枚举"><a href="#自定义枚举" class="headerlink" title="自定义枚举"></a>自定义枚举</h2><ol><li><p>构造器私有化，防止在外面 new 对象。</p></li><li><p>去掉 set 方法（可保留 get），防止属性被修改。因为枚举对象值通常为只读</p></li><li><p>在类内部直接创建固定对象。使用 <code>final</code> + <code>static</code> 共同修饰，对象名通常全部大写。</p></li><li><p>使用 类名.对象名 使用对象</p></li><li><p>枚举对象按照需要可以有多个属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Enum.e1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Enum&#123;</span><br><span class="line">    public String name;</span><br><span class="line">    public String desc;</span><br><span class="line"></span><br><span class="line">    private Enum(String name, String desc) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getDesc() &#123;</span><br><span class="line">        return desc;</span><br><span class="line">    &#125;</span><br><span class="line">    public static final Enum e1 = new Enum(&quot;华农&quot;,&quot;211&quot;);</span><br><span class="line">    public static final Enum e2 = new Enum(&quot;华中师范&quot;,&quot;211&quot;);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Enum&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, desc=&#x27;&quot; + desc + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="enum关键字"><a href="#enum关键字" class="headerlink" title="enum关键字"></a>enum关键字</h2><ol><li><p>用关键字 enum 替代 class</p></li><li><p>用 常量名.(形参列表); 代替创建对象（放在前面）。多个对象的场合，用 , 间隔。</p></li><li><p>如果使用 enum 枚举，要求将常量对象写在前面</p></li><li><p>必须要有 属性、构造器、枚举常量。get、set方法都可以去除。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enum School&#123;</span><br><span class="line">    WUHAN(&quot;湖北&quot;,&quot;一线&quot;);</span><br><span class="line">    private String sheng;</span><br><span class="line">    private String grade;</span><br><span class="line">    private School(String sheng, String grade) &#123;</span><br><span class="line">        this.sheng = sheng;</span><br><span class="line">        this.grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h3><ol><li><p>当我们用 <code>enum</code> 关键字开发一个枚举类时，默认会继承 java.lang.Enum 类，而且是一个 <code>final</code> 类。</p><p>这样，我们就能使用 Enum 中的相关方法。</p></li><li><p><code>enum</code> 类不能继承其他类，亦不能被其它类继承，</p></li><li><p><code>enum</code> 类和其他类一样，可以实现接口。</p></li><li><p>传统的 <code>public ststic final RED(&quot;小红&quot;, 10);</code> 简化为 <code>RED(&quot;小红&quot;, 10);</code></p></li><li><p>如果使用无参构造器创建枚举对象，则 实参列表 和 <code>()</code> 都能省略</p></li></ol><h3 id="Enum-类常用方法"><a href="#Enum-类常用方法" class="headerlink" title="Enum 类常用方法"></a><code>Enum</code> 类常用方法</h3><ul><li><code>valueOf</code>：将字符串转换成枚举对象。要求字符串必须是已有的常量名，否则报异常。</li><li><code>values</code>：返回一个数组 <code>Example[]</code>，其中包含定义的所有枚举对象</li><li><code>getDeclaringClass</code>：得到枚举常量所属的 <code>class</code></li><li><code>name</code>：得到当前枚举常量的名称。建议优先用 <code>toString</code></li><li><code>ordinal</code>：输出该枚举对象的次序&#x2F;编号（从 0 开始编号。如上例 <code>BLUE.ordinal = 1</code>）</li><li><code>compareTo</code>：比较两个枚举常量的编号（调用常量编号 减去 传入常量编号）</li><li><code>clone</code>：枚举类不能 <code>clone</code>，所以，这是一个只会抛出异常的方法</li></ul><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>注解（Annotation）也被称为元数据（Metadata）。用于修饰 包、类、方法、属性、构造器、局部变量 等数据信息。</p><p>和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息。</p><p>在 JavaSE 中，注解的使用目的比较简单，例如 标记过时的功能，忽略警告 等。在 JavaEE 中注解占据了更重要的角色，例如用于配置应用程序的任何切面，代替 JavaEE 旧版中所遗留的繁冗代码和 XML 配置等。</p><ol><li>使用 <code>@Annotation</code> 时要在前面增加 <code>@</code> 符号，并把该注解当成一个修饰符使用。用于修饰它支持的程序元素。</li><li>三个基本的@Annotation：<ul><li><code>@Override</code>：限定某个方法，是 重写 父类方法。该注解只能用于方法。如果你写了该注解，编译器会替你校验，看看是不是真的 重写 了父类方法。</li><li><code>@Deprecated</code>：用于表示某个程序元素（类、方法等）已经过时</li><li><code>@SuppressWarnings()</code>：抑制编辑器警告</li></ul></li><li>如果发现 <code>public @interface XXX&#123;&#125;</code> 这种东西，说明是定义了一个注解类 <code>XXX</code>。这里的 <code>@interface</code> 不代表接口（<code>interface</code>）。</li></ol><h2 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h2><p>@Override 表示指定重写父类的方法（从编译器层面验证），如果父类没有该方法，就报错。</p><blockquote><p>不写该注解，重写依然构成重写，所以这个就别碰</p></blockquote><p>@Override 只能修饰方法，不能修饰其他 类、包、属性等</p><h2 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h2><p>@Deprecated 表示指定的某个程序元素（类、方法等）已过时，不推荐使用，但仍能使用，@Deprecated 可以做到新旧版本的兼容和过度</p><p>可以修饰方法、类、字段、包、参数</p><h2 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings()"></a>@SuppressWarnings()</h2><p>当我们不想看到警告信息时，用 <code>@SuppressWarnings()</code></p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&#123;&quot;...&quot;&#125;)</span><br></pre></td></tr></table></figure><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>在后面 <code>(&#123;&quot;unused&quot;, &quot;unchecked&quot;&#125;)</code> 这样写入你希望抑制的信息</p><table><thead><tr><th align="left"><strong>关键字</strong></th><th align="left"><strong>用途</strong></th></tr></thead><tbody><tr><td align="left">all</td><td align="left">抑制所有警告</td></tr><tr><td align="left">boxing</td><td align="left">抑制与装箱&#x2F;解装箱操作相关的警告</td></tr><tr><td align="left">cast</td><td align="left">抑制与强制转换操作相关的警告</td></tr><tr><td align="left">dep-ann</td><td align="left">抑制与已弃用注释相关的警告</td></tr><tr><td align="left">deprecation</td><td align="left">抑制与弃用有关的警告</td></tr><tr><td align="left">fallthrough</td><td align="left">抑制与 switch 语句中丢失断点相关的警告</td></tr><tr><td align="left">finally</td><td align="left">抑制不返回的 finally 块的相关警告</td></tr><tr><td align="left">hiding</td><td align="left">抑制与隐藏变量的局部变量相关的警告</td></tr><tr><td align="left">incomplete-switch</td><td align="left">抑制与 switch 语句中缺少条目相关的警告（enum）</td></tr><tr><td align="left">nls</td><td align="left">抑制与 非nls 字符串字面值相关的警告</td></tr><tr><td align="left">null</td><td align="left">抑制相对于null分析的警告</td></tr><tr><td align="left">rawtypes</td><td align="left">在类参数上使用泛型时，抑制与非特定类型相关的警告</td></tr><tr><td align="left">restriction</td><td align="left">抑制与不推荐或禁止引用有关的警告</td></tr><tr><td align="left">serial</td><td align="left">抑制与可序列化类缺少serialVersionUID字段相关的警告</td></tr><tr><td align="left">static-access</td><td align="left">抑制与不正确的静态访问有关的警告</td></tr><tr><td align="left">synthetic-access</td><td align="left">抑制与未优化的内部类访问相关的警告</td></tr><tr><td align="left">unchecked</td><td align="left">抑制与未检查的操作相关的警告</td></tr><tr><td align="left">unqualified-field-access</td><td align="left">抑制与字段访问不合格相关的警告</td></tr><tr><td align="left">unused</td><td align="left">抑制与未使用代码相关的警告</td></tr></tbody></table><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p><code>@SuppressWarnings</code> 的范围与你放置的位置相关。</p><ul><li>放在方法外第一行，范围是整个方法</li><li>放在方法内，范围是下一句语句</li></ul><h3 id="JDK-的元注解（了解即可）"><a href="#JDK-的元注解（了解即可）" class="headerlink" title="JDK 的元注解（了解即可）"></a>JDK 的元注解（了解即可）</h3><blockquote><p>JDK 的 元注解 是用于修饰其他注解的注解</p></blockquote><ol><li><p><code>@Rentention</code>：指定注解的作用范围，有三种范围 <code>SOURCE</code> <code>CLASS</code> <code>RUNTIME</code></p><p><code>@Rentention</code> 的三种值：</p><ul><li><code>RententionPolicy.SOURCE</code>：编译器使用后，直接丢弃这种策略的注释</li><li><code>RententionPolicy.CLASS</code>：编译器把注解记录在 class 文件中。当运行 Java 程序时， JVM 不会保留注释。这是默认值</li><li><code>RententionPolicy.RUNTIME</code>：编译器把注解记录在 class 文件中。当运行 Java 程序时，JVM 会保留注解。程序可以通过反射获取该注解</li></ul></li><li><p><code>@Target</code>：指定注解的使用范围</p><p><code>@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</code></p></li><li><p><code>@Documented</code>：指定该注解会不会在 Javadoc 体现</p></li><li><p><code>@Inherited</code>：子类会继承父类注解</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java类与对象</title>
      <link href="/2023/05/24/Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
      <url>/2023/05/24/Java%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>面向对象是一种开发软件的方法，使分析、设计和实现一个系统的方法尽可能接近人们认识一个系统的方法。包括三个方面：面向对象分析、面向对象设计、面向对象程序设计。</p><p>Java 语言是纯面向对象的语言。其所有数据类型都有相应的类，程序可以完全基于对象编写。</p><hr><p>面向对象和面向过程的区别：</p><p>两者的主要区别在于解决问题的方式不同：</p><ul><li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li><li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li></ul><p>优缺点：</p><p>面向过程：</p><ul><li><p>优点：</p><p>流程化使得编程任务明确，在开发之前基本考虑了实现方式和最终结果，具体步骤清楚，便于节点分析。</p><p>效率高，面向过程强调代码的短小精悍，善于结合数据结构来开发高效率的程序。</p></li><li><p>缺点：</p><p>需要深入的思考，耗费精力，代码重用性低，扩展能力差，后期维护难度比较大。</p></li></ul><p>面向对象：</p><ul><li><p>优点:</p><p>结构清晰，程序是模块化和结构化，更加符合人类的思维方式；</p><p>易扩展，代码重用率高，可继承，可覆盖，可以设计出低耦合的系统；</p><p>易维护，系统低耦合的特点有利于减少程序的后期维护工作量。</p></li><li><p>缺点：</p><p>开销大，当要修改对象内部时，对象的属性不允许外部直接存取，所以要增加许多没有其他意义、只负责读或写的行为。这会为编程工作增加负担，增加运行开销，并且使程序显得臃肿。</p><p>性能低，由于面向更高的逻辑抽象层，使得面向对象在实现的时候，不得不做出性能上面的牺牲，计算时间和空间存储大小都开销很大。</p></li></ul><h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><p>类就是数据类型。可以是int也可以是自定义类</p><p>对象就是其中具体的实例。可以是100也可以是现实生活的物体</p><p>从类到对象，可以称为创建一个对象，也可以说实例化一个对象，或者把对象实例化</p><ol><li>类是抽象的、概念的，代表一类事物</li><li>对象是具体的、实际的，代表一个个具体事物</li><li>类是对象的模板，对象是类的一个个体，对应一个实例</li></ol><p>类一共有5种成员：<strong>属性、方法、构造器、代码块、内部类</strong></p><h2 id="属性-x2F-成员变量"><a href="#属性-x2F-成员变量" class="headerlink" title="属性&#x2F;成员变量"></a>属性&#x2F;成员变量</h2><p>属性可以是基本数据类型，也可以是引用数据类型。</p><ol><li><p>属性的定义语法同变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 属性类型 属性名</span><br></pre></td></tr></table></figure><ul><li>访问修饰符：控制属性的访问范围。有四种：publie protected 默认(空) private</li></ul></li><li><p>属性的定义类型可以为任意类型，包含基本类型或引用类型</p></li><li><p>属性如果不赋值，有默认值。规则同数组</p></li></ol><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><ol><li><p>先声明再创建：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cat cat1;      //声明对象cat1</span><br><span class="line">cat1 = new Cat();//创建对象</span><br></pre></td></tr></table></figure></li><li><p>直接创建：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cat cat2 = new Cat();</span><br></pre></td></tr></table></figure></li></ol><p>注意事项：</p><ol><li><p>声明对象的场合，只是在内存中建立了一个引用。此时，该地址引用不指向任何内存空间。</p><p>对象的引用，也被称为对象的句柄。</p></li><li><p>使用 new 运算符创建对象实例时，会为对象分配空间，就会调用类的构造方法。那之后，会将该段内存的首地址赋给刚才建立的引用</p></li></ol><h3 id="访问对象"><a href="#访问对象" class="headerlink" title="访问对象"></a>访问对象</h3><p>基本语法：对象名.属性名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(cat1.name);</span><br></pre></td></tr></table></figure><h3 id="类与对象的内存访问机制"><a href="#类与对象的内存访问机制" class="headerlink" title="类与对象的内存访问机制"></a>类与对象的内存访问机制</h3><blockquote><p>JVM内存空间：</p><p>栈：一般存放基本数据类型（局部变量）</p><p>堆：存放对象（如Cat cat1 &#x3D; new Cat()，是在这里开辟的空间，所有 new 的变量都在这里）</p><p>方法区：常量池（常量，比如字符串），类加载信息</p></blockquote><ol><li>创建对象时，先加载类信息，然后在堆中分配空间，栈中的对象名被赋予指向那个空间的地址。</li><li>之后进行指定初始化。该对象的属性中，是基本数据类型的直接记录在堆中；是字符串的记录一个地址，该地址指向方法区，那里的常量池有该字符串。</li></ol><h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><p>在某些情况下，我们需要定义成员方法。比如Cat除了有属性外，还可以有一些行为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回数据类型 方法名(形参列表)&#123;</span><br><span class="line">方法体语句;</span><br><span class="line">returen 返回值;//返回数据类型是 void 的场合，return语句不是必须的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>方法名必须是一个合法的标识符</p></li><li><p>返回类型即返回值的类型。如果方法没有返回值，应声明为void</p></li><li><p>修饰符段可以有几个不同的修饰符。</p><p>比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static strictfp final void method() &#123;</span><br><span class="line">        System.out.println(&quot;哎呦~你干嘛&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>参数列表是传递给方法的参数表。各个元素间以,分隔。每个元素由一个类型和一个标识符表示的参数组成。特别地，参数类型…标识符这样的参数被称为可变参数</p></li><li><p>方法体是实际要执行的代码块。方法体一般用return作为方法的结束。</p></li></ol><p>使用成员方法，能提高代码的复用性。而且能把实现的细节<strong>封装</strong>起来，供其他用户调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Cat&#123;</span><br><span class="line">String name;</span><br><span class="line">int age;</span><br><span class="line">public void speak()&#123;</span><br><span class="line">  System.out.println(&quot;哎呦~你干嘛&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>方法写好后，不去调用就不会输出</li><li>先创建对象，然后调用方法即可</li><li>静态方法也可以用对象调用，但是不推荐</li></ol><h3 id="方法的调用机制"><a href="#方法的调用机制" class="headerlink" title="方法的调用机制"></a>方法的调用机制</h3><ol><li>当程序执行到方法时，在栈中开辟一个新的<strong>栈</strong>空间。</li><li>当方法执行完毕，或执行到return语句时，就会返回（计算机组成原理里面有提到，JVM中也有讲解）</li><li>把新栈空间中的返回值返回main栈中调用方法的地方</li><li>返回后，继续执行该方法的后续代码</li><li>当一个方法执行完毕，或遇到return就会返回。遵守谁调用就返回给谁。同时当方法执行完毕或返回时，该方法也执行完毕。</li></ol><p>方法使用细节</p><ol><li><p>访问修饰符：作用是控制方法的使用范围。</p><ul><li>不写（默认访问控制范围）</li><li>public：公共</li><li>protected：受保护</li><li>private：私有</li></ul></li><li><p>返回数据类型：</p><ul><li>一个方法最多有一个返回值。要返回多个结果可以使用<strong>数组或者集合</strong>。</li><li>返回类型为任意类型。包括基本数据类型和引用数据类型。</li><li>如果方法要求有返回数据类型，则方法体中最后的执行语句必为return值，且返回类型必须和return的值一致。</li><li>如果返回数据类型为void，则可以不写return语句</li></ul></li><li><p>方法名：</p><ul><li>遵循驼峰命名法，最好见名知意，表达出该功能的意思。</li></ul></li><li><p>参数列表（形参列表）：</p><ul><li>一个方法可以有0个参数，也可以有多个参数。参数间用,间隔。</li><li>参数类型可以为任意类型，包含基本类型和引用类型。</li><li>调用带参数的方法时，一定对应着参数列表传入相同类型或兼容类型的参数。</li><li>方法定义时的参数称为形式参数，简称形参；方法调用时的参数（传入的参数）称为实际参数，简称实参。实参与形参的类型、个数、顺序必须一致。</li></ul></li><li><p>方法体：</p><ul><li>写完成功能的具体语句。方法中不能再定义方法。即：方法不能嵌套定义。</li></ul></li><li><p>调用细节：</p><ul><li><p>同一个类中的方法调用，可以直接调用。</p></li><li><p>跨类的方法调用，需要创建新对象，然后通过对象调用方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class C1&#123;</span><br><span class="line">public void m1()&#123;</span><br><span class="line">&#125;</span><br><span class="line">public void m2()&#123;</span><br><span class="line">   m1();//同一个类中的方法调用，可以直接调用。</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C2&#123;</span><br><span class="line">public void m3()&#123;</span><br><span class="line">   C1 c = new C1();</span><br><span class="line">   c.m2();//跨类的方法调用，需要创建新对象，然后再调用方法。</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="成员方法传参机制"><a href="#成员方法传参机制" class="headerlink" title="成员方法传参机制"></a>成员方法传参机制</h3><p>Java语言对对象采用的是<strong>值传递</strong>，方法得到的总是那个传入对象的副本。java没有引用传递机制</p><ul><li><p>方法不能修改基本数据类型的参数。基本数据类型传递的是一个值，形参不影响实参。</p></li><li><p>方法可以改变对象参数的状态。</p><p>引用类型传递的是一个地址，形参和实参指向一处，两者总会相关。</p><p>但改变那个形参地址指向的场合，实参的指向不会改变</p></li></ul><h3 id="方法重载-x2F-Overload"><a href="#方法重载-x2F-Overload" class="headerlink" title="方法重载&#x2F;Overload"></a>方法重载&#x2F;Overload</h3><p>方法重载（Overload）：Java中允许同一类中，多个同名方法的存在，但要求形参列表不一致。</p><p><strong>使用细节：</strong></p><ol><li>方法名：必须相同</li><li>形参列表：必须不同（参数的类型、个数、顺序，这其中至少一个不同）</li><li>返回值：无要求，可以相同，可以不同</li></ol><p><strong>签名：</strong>由于重载的存在，要完整的描述一个方法，要指定方法名及参数类型。这叫做方法的签名。</p><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><blockquote><p>Java允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法。</p></blockquote><p>语法：访问修饰符 返回类型 方法名（数据类型… 形参名）{代码块;}</p><p><strong>使用细节</strong></p><ol><li>可变参数的实参可以是0个，也可以是任意多个。</li><li>可变参数的实参可以是数组</li><li>可变参数本质就是数组</li></ol><p><strong>相关语法糖</strong>：底层是用等长数组存放的参数，所以要求可变参数放最后，用的时候在数组中依次取值</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ol><li>在Java编程中，主要的变量就是属性（成员变量）和局部变量。</li><li>我们说的局部变量一般是指在成员方法中定义的变量。</li><li>作用域的分类<ul><li>全局变量：也就是属性，作用域为整个类体</li><li>局部变量：除了属性外的其他变量。作用域为定义它的代码块中</li></ul></li><li>全局变量（属性）可以不赋值直接使用，那个场合有默认值。局部变量必须赋值使用</li></ol><p><strong>使用细节</strong></p><ol><li><p>属性和局部变量可以重名，访问时遵循就近原则</p></li><li><p>在同一作用域中，两个局部变量不能重名</p></li><li><p>属性的生命周期较长。其伴随对象的创建而创建，伴随对象的销毁而销毁。</p><p>局部变量生命周期较短。其伴随代码块的执行而创建，伴随代码块的结束而销毁。</p></li><li><p>全局变量&#x2F;属性可以被本类使用，也可以被其他类（通过对象）使用。</p><p>局部变量只能被本类的对应方法中调用</p></li><li><p>全局变量&#x2F;属性<strong>可以加</strong>修饰符</p><p>局部变量<strong>不能加</strong>修饰符</p></li></ol><h2 id="构造方法、构造器"><a href="#构造方法、构造器" class="headerlink" title="构造方法、构造器"></a>构造方法、构造器</h2><blockquote><p>构造方法又叫构造器（constructor），是类的一种特殊的方法。它的主要作用是完成对新对象的初始化。</p></blockquote><p>语法：[修饰符]方法名(形参列表){方法体}</p><ol><li>构造器的修饰符可以是默认。也可以是别的</li><li>参数列表规则同成员方法</li></ol><p><strong>使用细节</strong></p><ol><li>构造器本质也是方法。所以，可以构造器<strong>重载</strong>，但是不能重写</li><li>构造器名和类名相同</li><li>构造器无返回值，不能写返回类型</li><li>构造器是完成对象的初始化，而不是创建</li><li>创建对象时，系统自动调用构造器</li><li>如果程序员没有定义构造器，系统会自动给类生成一个无参构造器（默认构造器）</li><li>一旦定义了自己的构造器，就不能用无参构造器了。除非显式的定义一个无参构造器</li></ol><h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a><strong>流程分析</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = new Person(&quot;Amy&quot;, 10);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">class Person&#123;</span><br><span class="line">String name;</span><br><span class="line">int age = 20;</span><br><span class="line">public Person(String pName, int pAge)&#123;</span><br><span class="line">name = pName;</span><br><span class="line">age = pAge;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>加载类信息（方法区）</p></li><li><p>在堆中开辟空间（地址）</p></li><li><p>完成对象初始化</p><ul><li><p>首先默认初始化。age &#x3D; 0; name &#x3D; null</p></li><li><p>之后显式初始化。age &#x3D; 20; name &#x3D; null</p><p>其中，显式初始化和代码块初始化按编写的先后顺序依次进行。</p></li><li><p>之后构造器的初始化。age &#x3D; 10; name &#x3D; “Amy”</p></li></ul></li><li><p>把对象在堆中的地址，返回给 p1</p></li></ol><h2 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h2><p>JVM 会给每个对象分配 this 代表当前对象。相当于在 堆 中，this 指向自己（对象）</p><blockquote><p>在类定义的方法中，Java 会自动用 this 关键字把所有变量和方法引用结合在一起。</p><p>遇到有同名的局部变量的场合，需要程序员加入 this 关键字进行区分。不加入 this 关键字的场合，Java 遵循就近原则。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Example&#123;</span><br><span class="line">    int n = 0;</span><br><span class="line">public void act(int n) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个类的 act() 方法实际有 2 个参数。对其调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Example e = new Exmaple();</span><br><span class="line">e.act(100);</span><br></pre></td></tr></table></figure><p>可见，出现在方法名前的参数 e，以及出现在方法名后的括号中的参数 100</p><p>出现在方法名前的参数被称为<strong>隐式参数</strong>也称为 方法调用的 目标 或 接收者）</p><p>出现在方法名后的参数被称为<strong>显式参数</strong>，就是所谓的实参</p><p>在每一个方法中，用 this 指代隐式参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void act(int n) &#123;</span><br><span class="line">    this.n = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，再以相同方式调用方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.act(100);// &lt;———— 相当于 e.n = 100;</span><br></pre></td></tr></table></figure><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol><li><p>this 关键字可以用来访问本类的属性、方法、构造器</p></li><li><p>this 用于区分当前类的 属性 和 局部变量</p></li><li><p>访问本类中成员方法的语法：this.方法名</p></li><li><p>访问构造器的语法：this(参数列表);</p><p>注意：只能在构造器中访问另一个构造器。而且，如果有这个语法，必须放置在第一条语句。</p></li><li><p>this 不能在类定义的 外部 使用，只能在类定义的方法中使用</p></li></ol><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>代码块：又称为初始化块。属于类中的成员。类似于方法，将逻辑语句封装在方法体中，通过 <code>&#123; &#125;</code> 包围起来。和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类 显式调用，而是<strong>加载类时，或创建对象时隐式调用。</strong></p><p>语法：<code>[修饰符]&#123;代码&#125;;</code></p><p>注意：</p><ol><li>修饰符 是可选项，可不写。要写的话，只能写 <code>static</code></li><li>代码块分为两类：<ul><li>静态代码块：有 <code>static</code></li><li>普通代码块：无 <code>static</code></li></ul></li><li>逻辑语句可以为任意的逻辑语句。</li><li><code>;</code> 可以写，也可以省略。建议写上。</li><li>代码块相当于另一种形式的构造器（构造器的补充机制），可以做初始化操作</li><li>如果多个构造器中都有重复语句，就可以抽取到初始化块中，提高代码复用率。这样，不管用哪个构造器，都会执行代码块</li></ol><h3 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h3><p>static代码块：作用是对类进行初始化。<strong>随着 类的加载 会且只会执行一次</strong>。相对的：普通代码块每创建一个对象就执行一次。</p><p>**类什么时候被加载？ **</p><ul><li>创建对象实例时（new）</li><li>创建子类对象实例，父类也会加载</li><li>使用类的静态成员时（父类也会加载）</li></ul><p>以上情况下类会被加载。加载后不需要再次加载，所以，静态代码块也只会执行一次。</p><ol><li><p>创建一个对象时，在 <strong>一个类里</strong> 调用顺序是：</p><ul><li>调用静态代码块 和 静态属性初始化。这两者优先级相同，多个存在时按照定义的顺序依次执行。</li><li>调用普通代码块 和 普通属性初始化。这两者优先级也相同。</li><li>调用构造器。</li></ul></li><li><p><code>构造器</code> 的最前面其实隐含了 <code>super();</code> 和 <code>调用普通代码块</code>。而静态相关的代码块，属性初始化，在类加载时就执行完毕了。</p><p>这样，创建一个对象时，在 <strong>有继承关系的多个类里</strong> 调用顺序是：</p><ul><li>父类 静态代码块 和 静态初始化</li><li>子类 静态代码块 和 静态初始化</li><li>父类 普通代码块 和 普通初始化</li><li>父类 构造器</li><li>子类 普通代码块 和 普通初始化</li><li>子类 构造器</li></ul></li><li><p>静态代码块 只能调用 静态成员。普通代码块 能调用 任意成员。</p></li></ol><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>一个类的内部又完整的嵌套了另一个类结构。被嵌套的类被称为 内部类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Outer&#123;//外部类</span><br><span class="line">class Inner&#123;//内部类</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Other&#123;//外部其他类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部类的最大特点是可以直接访问私有属性，并且可以体现类与类之间的包含关系。</p><h3 id="四种内部类"><a href="#四种内部类" class="headerlink" title="四种内部类"></a>四种内部类</h3><ol><li><p>定义在外部类的局部位置上</p><ul><li>局部内部类：有 类名</li><li>匿名内部类：无 类名</li></ul></li><li><p>定义在外部类的成员位置上</p><ul><li>成员内部类：无 <code>static</code> 修饰</li><li>静态内部类： <code>static</code> 修饰的类</li></ul></li></ol><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>局部内部类：定义在外部类的局部位置上，并且有类名。</p><p>局部位置：比如：方法&#x2F;代码块里，和局部变量一个位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Outer &#123;//外部类</span><br><span class="line">    public void tools01() &#123;</span><br><span class="line">        class Inner &#123;//局部内部类</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用细节:</p><ol><li><p>定义在外部类的局部位置上，并且有类名。</p></li><li><p>可以访问外部类的所有成员，包含私有成员</p></li><li><p>局部内部类可以 直接访问 外部类的成员。</p></li><li><p>不能添加 访问修饰符，因为其地位相当于局部变量。但，可以使用 <code>final</code>，因为局部变量也能用 <code>final</code></p></li><li><p>作用域 仅仅在定义它的方法或代码块中</p></li><li><p>外部类 在方法中，可以创建 局部内部类 的对象实例，然后调用方法。</p></li><li><p>外部其他类 不能访问 局部内部类</p></li><li><p>如果外部类和局部内部类的成员重名时，默认遵循就近原则。那个场合，访问外部类成员使用 <code>外部类名.this.变量名</code></p><p><code>外部类名.this</code> 本质就是 外部类的对象。即，调用了该方法（上例的 <code>tools01</code> ）的对象</p></li></ol><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类：定义在外部类的局部位置，且没有类名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new 类/接口 (参数列表) &#123;</span><br><span class="line">    类体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名内部类本质是没有名字的类，而且是内部类。同时，还是一个对象。</p><p>可以用匿名内部类简化开发</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Outer &#123;//外部类</span><br><span class="line">   public void tools01() &#123;</span><br><span class="line">       Inter whatEver = new Inter()&#123;//匿名内部类            </span><br><span class="line">       &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">interface Inter&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用细节:</p><ol><li>匿名内部类语法比较独特。其既是一个类的定义，也是一个对象。因此，从语法上看，其既有 定义类的特征，也有 创建对象的特征。</li><li>可以访问外部类的所有成员，包括私有的。</li><li>局部内部类可以 直接访问 外部类的成员。</li><li>不能添加 访问修饰符，因为其地位相当于局部变量。但，可以使用 <code>final</code>，因为局部变量也能用 <code>final</code></li><li>作用域：仅仅在定义它的方法或方法快中</li><li>外部其他类 不能访问 匿名内部类</li><li>如果外部类和匿名内部类的成员重名时，默认遵循就近原则。那个场合，访问外部类成员使用 <code>外部类名.this.变量名</code></li></ol><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>成员内部类：定义在外部类的成员位置，并且没有 <code>static</code> 修饰</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Outer&#123;</span><br><span class="line">class Inner&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 使用细节:</p><ol><li>可以直接访问外部类的所有成员，包括私有的</li><li>可以添加任意访问修饰符。因为，成员内部类的地位就是一个成员。</li><li>作用域 和外部类其他成员相同，为整个类体。</li><li>局部内部类可以 直接访问 外部类的成员。</li><li>外部类可以通过创建对象的方式访问成员内部类</li><li>外部其他类访问成员内部类<ul><li><code>Outer.Inner name = Outer.new Inner(); </code>下个方法的缩写</li><li><code>Outer.Inner name = new Outer().new Inner();</code></li><li>在外部类中编写一个方法，返回一个 <code>Inner</code> 的对象实例（就是对象的 getter）</li></ul></li><li>如果外部类和匿名内部类的成员重名时，默认遵循就近原则。那个场合，访问外部类成员使用 <code>外部类名.this.变量名</code></li></ol><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类：定义在外部类的成员位置，经由 <code>static</code> 修饰</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Outer&#123;</span><br><span class="line">static class Inner&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用细节:</p><ol><li>可以直接访问外部类的所有 <strong>静态</strong> 成员，包括私有的。但不能访问非静态成员</li><li>可以添加访问修饰符。因为，静态内部类的地位就是一个成员。</li><li>作用域 和其他成员相同，为整个类体。</li><li>静态内部类可以 直接访问 外部类的成员。</li><li>外部类可以通过创建对象的方式访问静态内部类</li><li>外部其他类访问静态内部类<ul><li><code>Outer.Inner name = new Outer.Inner();</code> 即通过类名直接访问</li><li>在外部类中编写一个方法，返回一个 <code>Inner</code> 的对象实例</li><li>如果外部类和匿名内部类的成员重名时，默认遵循就近原则。那个场合，访问外部类成员使用 <code>外部类名.变量名</code>。<em>（怎么不一样了呢？因为静态内部类访问的都是静态成员）</em></li></ul></li></ol><h1 id="static-静态"><a href="#static-静态" class="headerlink" title="static 静态"></a>static 静态</h1><h2 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h2><p>类变量：也叫 静态变量&#x2F;静态属性。是该类所有对象共享的变量。任何一个该类对象访问时都是相同的值，任何一个该类对象修改时也是同一个变量。</p><p>语法：<code>访问修饰符 static 数据类型 变量名;</code></p><p>根据 JDK 版本的不同，类变量存放在 堆 中或 方法区 中</p><ol><li><p>什么时候需要用类变量：</p><p>当我们需要让某个类的所有对象都共享一个变量时，就可以考虑使用类变量（静态变量）</p></li><li><p>类变量 与 实例变量（普通属性）的区别：</p><p>类变量 是该类所有对象共享的，而 实例变量 是每个对象独享的</p></li><li><p>加上 <code>static</code> 称为 类变量 或 静态变量。否则称为 实例变量&#x2F;普通变量&#x2F;非静态变量</p></li><li><p>静态变量 可以通过 <code>类名.类变量名;</code> 或 <code>对象名.类变量名;</code> 来访问。但 Java 设计者推荐我们用 <code>类名.类变量名;</code> 来访问。（需满足访问权限和范围）</p></li><li><p>类变量 是在加载类时就初始化了。所以，没有创建对象实例也能访问。</p></li><li><p>类变量 的生命周期是随着 类的加载 开始，随着 类的消亡 而销毁。</p></li><li><p>特别地：<strong>一个 null 对象也可以访问静态变量 &#x2F; 静态方法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">    static int n = 0;</span><br><span class="line">    static void met() &#123;</span><br><span class="line">        System.out.println(++n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Test t = null;</span><br><span class="line">        System.out.println(t.n);//这样不会报错</span><br><span class="line">        t.met();//这样也不会报错</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><p>当方法使用 <code>static</code> 修饰后，就是 静态方法。静态方法就能访问静态属性。如果我们不希望创建实例，也能调用方法，这个场合把方法做成静态方法是合适的。开发工具类时就可以如此做。</p><ol><li>类方法和普通方法都是随着类的加载而加载，将结构信息存储在 方法区。</li><li>类方法中不允许使用和对象有关的关键字。所以，类方法没有 <code>this</code> 或 <code>super</code></li><li>类方法可以通过类名调用，也能通过对象名调用。普通方法不能通过类名调用。</li><li>类方法 中只能访问 类变量 或 类方法</li><li>普通方法既可以访问普通方法也可以访问类方法</li></ol><h2 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h2><p>受static 修饰的代码块，类加载的时候就运行了，在 jvm 中所有的静态代码块被合一，按照各自的顺序加载</p><h2 id="main-方法"><a href="#main-方法" class="headerlink" title="main 方法"></a>main 方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;...&#125;</span><br></pre></td></tr></table></figure><ol><li><p><code>main</code> 方法 是 JVM 调用的方法。所以该方法的 访问权限 必须为 <code>public</code></p></li><li><p>JVM 在执行 <code>main</code> 方法时不必创建对象，所以 <code>main</code>方法 必须为 <code>static</code></p></li><li><p>该方法接收 <code>String</code> 类型的数组参数。该数组中保存执行 Java 命令 时传递给所运行的类的参数。</p></li><li><p>在 <code>main</code> 方法 中，我们可以直接调用 <code>main</code> 方法 所在类的静态方法或静态属性。</p><p>工作台中：<code>javac 执行的程序.java</code></p><p> <code>java 执行的程序 参数1(arg[0]) 参数2(arg[1]) 参数3(arg[2]) ..</code></p></li><li><p>不能直接访问该类中的非静态成员，必须创建该类的一个实例后才能通过该实例访问非静态成员</p></li></ol><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p><code>final</code> 可以修饰 类、属性、方法、局部变量</p><p>以下情况下，可能用到 <code>final</code></p><ol><li><code>final</code> 修饰类：该类不能被继承</li><li><code>final</code> 修饰方法：该方法不能被重写</li><li><code>final</code> 修饰值：该值不能被修改</li></ol><p>使用细节：</p><ol><li><p><code>final</code> 修饰的属性又叫常量，一般用 XX_XX_XX 来命名（全大写字母+下划线）</p></li><li><p><code>final</code> 修饰的属性在定义时，必须赋初始值，且之后不能再修改。赋值可以在下列位置之一：</p><ul><li>定义时</li><li>构造器中</li><li>代码块中</li></ul><p>注意：如果 <code>final</code> 修饰的属性是**静态的(static)**，则只能在以下位置赋值。</p><ul><li>定义时</li><li>静态代码块中</li></ul></li><li><p><code>final</code> 类不能继承，但能实例化对象。对的，是可以的。</p></li><li><p>如果不是 <code>final</code> 类，但含有 <code>final</code> 方法，虽然该方法不能重写，但能被继承。</p></li><li><p><code>final</code> 类可以有 <code>final</code> 方法。可以，但没必要。</p></li><li><p><code>final</code> 不能修饰构造方法。</p></li><li><p><code>final</code> 和 <code>static</code> 搭配使用，效率更高（那个场合，虽然顺序不限，还是推荐 <code>static</code> 在前）。底层编译器做了优化处理。这样做，调用 <strong>属性（定义时赋值）</strong> 时居然 <strong>不会造成类的加载！</strong></p></li><li><p>包装类（Integer、Double、Float、Boolean、String等）都是 <code>final</code> 类，都不能被继承。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java字符串</title>
      <link href="/2023/05/20/Java%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2023/05/20/Java%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h1><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309171056678.png"></p><ol><li><p><code>String</code> 对象用于保存字符串，也就是一组字符序列</p></li><li><p>字符串常量对象是用双引号扩起的字符序列。例如 <code>&quot;你好&quot;</code></p></li><li><p>字符串的字符使用 Unicode 字符编码。一个字符（不论字母汉字）占 2 字节</p></li><li><p>常用构造器：</p><ul><li><p><code>String str1 = new String();</code></p></li><li><p><code>String str2 = new String(String original);</code></p></li><li><p><code>String str3 = new String(char[] a);</code></p></li><li><p><code>String str4 = new String(char[] a, int startIndex, int count);</code></p><p>这句意思是：<code>char[]</code> 从 <code>startIndex</code> 起的 <code>count</code> 个字符</p></li></ul></li><li><p><code>String</code> 实现了接口 <code>Serializable</code> 和 <code>Comparable</code> ，可以 串行化和 比较大小</p><blockquote><p><strong>串行化：即，可以被网络传输，也能保存到文件</strong></p></blockquote></li><li><p><code>String</code> 是 <code>final</code> 类，不能被继承</p></li><li><p><code>String</code> 有属性 <code>private final char[] value;</code> 用于存放字符串内容。</p><p><code>value</code> 是 <code>final</code> 属性。其在栈中的地址不能修改，但内容可以修改</p></li></ol><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309171101558.png"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309171103557.png"></p><h2 id="String创建对象"><a href="#String创建对象" class="headerlink" title="String创建对象"></a>String创建对象</h2><p>两种创建String对象的区别（JVM中有讲解）</p><ol><li><p>直接赋值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;你干嘛，哎呦~&quot;</span><br></pre></td></tr></table></figure><p>方式一：先从常量池查看是否有**”你干嘛，哎呦~”**数据空间，如果有，直接指向；如果没有则重新创建，然后指向。s最终指向的是常量池的空间地址</p></li><li><p>调用构造器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str1 = new String();</span><br></pre></td></tr></table></figure><p>方式二：先在堆中创建空间，里面维护了value属性，指向常量池的**”你干嘛，哎呦<del>“<strong>空间。如果常量池没有</strong>“你干嘛，哎呦</del>“**，重新创建，如果有，直接通过value指向。 最终指向的是堆中的空间地址。</p></li></ol><h3 id="画出两种方式的内存分布图"><a href="#画出两种方式的内存分布图" class="headerlink" title="画出两种方式的内存分布图"></a>画出两种方式的内存分布图</h3><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309180850664.png"></p><h3 id="String对象比较"><a href="#String对象比较" class="headerlink" title="String对象比较"></a>String对象比较</h3><blockquote><p>JVM中有一部分讲这个的，比Java部分的更加全面</p></blockquote><p>引用类型怎么比较？默认比较地址，重写方法可能比较内容。</p><ol><li><p>**&#x3D;&#x3D;**：比较二者的地址，内容不一样的话肯定不一样。内容一样的话如果都是new的，由于new的特性，也不一样。</p></li><li><p>equals：String中重写了方法，比较的是值是否相同，区分大小写。</p></li><li><p>常量相加比较：由于构造器自身优化，池会自动创建一个相加后的常量</p></li><li><p>变量相加比较：是在堆中调用Stringbuilder类通过append和toString方法生成一个新对象，二者不一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb = new StringBuilder();</span><br><span class="line">sb.append(a);</span><br><span class="line">sb.append(b);</span><br><span class="line">str2 = sb.toString();//sb.toString()：return new String(value, 0, count);</span><br></pre></td></tr></table></figure></li></ol><h2 id="String对象特性"><a href="#String对象特性" class="headerlink" title="String对象特性"></a>String对象特性</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String e = &quot;你干嘛&quot; + &quot;哎呦&quot;;//创建了几个对象？</span><br></pre></td></tr></table></figure><p>1个：由于构造器自身优化，池会自动创建一个相加后的常量，相当于直接 e &#x3D; “你干嘛哎呦”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String a = &quot;你干嘛&quot;; //创建 a对象</span><br><span class="line">String b = &quot;哎呦&quot;;//创建 b对象</span><br><span class="line"> String c = a + b;</span><br></pre></td></tr></table></figure><p>3个：</p><ol><li>先 创建一个 StringBuilder sb &#x3D; StringBuilder()</li><li>执行  sb.append(“你干嘛”);</li><li>sb.append(“哎呦”);</li><li>String c&#x3D; sb.toString()<br>最后其实是 c 指向堆中的对象(String) value[] -&gt; 池中 “你干嘛哎呦”</li></ol><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309180941489.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String a = &quot;hello&quot;; //创建 a对象</span><br><span class="line">String b = &quot;abc&quot;;//创建 b对象</span><br><span class="line">String c = a + b;//e指向堆</span><br><span class="line">String d = &quot;helloabc&quot;;</span><br><span class="line">System.out.println(c == d);//真还是假? 是false</span><br><span class="line">String e = &quot;hello&quot; + &quot;abc&quot;;//直接看池， e指向常量池</span><br><span class="line">System.out.println(d == e);//真还是假? 是true</span><br></pre></td></tr></table></figure><h2 id="String-的常用方法"><a href="#String-的常用方法" class="headerlink" title="String 的常用方法"></a>String 的常用方法</h2><p>以下方法不需死记硬背，手熟自然牢记</p><ul><li><p><code>boolean equals(String s)</code>：区分大小写，判断内容是否相等</p><p><code>boolean equalsIgnoreCase(String s)</code>：判断内容是否相等（忽略大小写）</p></li><li><p><code>boolean empty()</code>：返回是否为空</p></li><li><p><code>int charAt(int index)</code>：获取某索引处的字符（代码单元）。</p><p>必须用 <code>char c = str.charAt(15);</code>，不能用 <code>char c = str[15];</code></p><p><code>int codePointAt(int index)</code></p><p><code>int length()</code>：获取字符（<strong>代码单元</strong>）的个数</p><p><code>IntStream codePoints()</code>：返回字符串中全部码点构成的流</p><p><code>long codePoints().count()</code>：返回真正长度（码点数量）</p></li><li><p><code>int indexOf(String str)</code>：获取字符（串）在字符串中第一次出现的索引。如果找不到，返回 -1</p><p><code>int indexOf(int char)</code> 参数也可以传入一个 int。由于自动类型转换的存在，也能填入 char</p><p><code>int indexOf(String str, int index)</code>：从 index 处（包含）开始查找指定字符（串）</p><p><code>int lastIndexOf(String str)</code>：获取字符在字符串中最后一次出现的索引。如果找不到，返回 -1</p></li><li><p><code>String substring(int start, int end)</code>：返回截取指定范围 [start, end) 的 <strong>新</strong> 字符串</p><p><code>String substring(int index)</code>：截取 index（包含）之后的部分</p></li><li><p><code>String trim()</code>：返回去前后空格的新字符串</p></li><li><p><code>String toUperCase()</code>：返回字母全部转为大写的新字符串</p><p><code>String toLowerCase()</code>：返回字母全部转为小写的新字符串</p></li><li><p><code>String concat(String another)</code>：返回拼接字符串</p></li><li><p><code>String replace(char oldChar, char newChar)</code>：替换字符串中的元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;Foolish cultists&quot;;</span><br><span class="line">String str2 = str1.replace(&quot;cultists&quot;, &quot;believers&quot;);//str1不变，str2为改变的值JAVA</span><br></pre></td></tr></table></figure></li><li><p><code>String[] split(String regex)</code>：分割字符串。</p><p>对于某些分割字符，我们需要转义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;aaa,bbb,ccc&quot;;</span><br><span class="line">String[] strs1 = str1.split(&quot;,&quot;);//这个场合，strs = &#123;&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;&#125;;4</span><br><span class="line">String str2 = &quot;aaa\bbb\ccc&quot;;</span><br><span class="line">String[] strs2 = str2.split(&quot;\\&quot;);//&quot;\&quot; 是特殊字符，需要转义为 &quot;\\&quot;JAVA</span><br></pre></td></tr></table></figure></li><li><p><code>int compareTo(String another)</code>：按照字典顺序比较两个字符串（的大小）。</p><p>返回出现第一处不同的字符的编号差。前面字符相同，长度不同的场合，返回那个长度差。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;ccc&quot;;</span><br><span class="line">String str2 = &quot;ca&quot;;</span><br><span class="line">String str3 = &quot;ccc111abc&quot;;</span><br><span class="line">int n1 = str1.compareTo(str2);//此时 n1 = &#x27;c&#x27; - &#x27;a&#x27; = 2</span><br><span class="line">int n2 = str1.compareTo(str3);//此时 n2 = str1,length - str3.length = -6</span><br><span class="line">int n3 = str1.compareTo(str1);//此时 n3 = 0JAVA</span><br></pre></td></tr></table></figure></li><li><p><code>char[] toCharArray()</code>：转换成字符数组</p><p><code>byte[] getBytes()</code>：字符串转为字节数组</p></li><li><p><code>String String.format(String format, Object... args)</code>：（静态方法）格式字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String name = &quot;Roin&quot;;</span><br><span class="line">String age = &quot;1M&quot;;</span><br><span class="line">String state = &quot;computer&quot;;</span><br><span class="line">String formatStr = &quot;I am %s, I am %s old, I am a %s&quot;;</span><br><span class="line">String str = String.format(formatStr, name, age, state);</span><br><span class="line">//其中 %s 是占位符。此时，str = &quot;I am Roin, I am 1M old, I am a computer&quot;;</span><br><span class="line">//%s 表示字符串替换；%d 表示整数替换；#.2f 表示小数（四舍五入保留2位）替换；%c 表示字符替换JAVA</span><br></pre></td></tr></table></figure></li><li><p><code>String join(deli, ele...)</code>：拼接字符串（<code>ele...</code>），以 <code>deli</code> 间隔。</p></li><li><p><code>boolean startsWith(str)</code>：测试 str 是否为当前字符串的前缀</p></li><li><p><code>String repeat(int n)</code>：返回该字符串重复 n 次的结果</p></li></ul><h1 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h1><p>StringBuffer代表可变的字符序列。可以对字符串内容进行增删。</p><p>很多方法和 String 相同，但 StringBuffer 是可变长度。同时，StringBuffer 是一个容器</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309180952088.png"></p><ol><li><code>StringBuffer</code> 的直接父类是 <code>AbstractStringBuffer</code></li><li><code>StringBuffer</code> 实现了 <code>Serialiazable</code>，可以串行化</li><li>在父类中，<code>AbstractStringBuffer</code> 有属性 <code>char[] value</code> 不是 <code>final</code></li><li><code>StringBuffer</code> 是一个 <code>final</code> 类，不能被继承</li><li>StringBuffer的字符内容存放在char[] value中，不用每次都更换地址(不是每次创建新对象)，所以效率高于 String</li></ol><h2 id="String-对比-StringBuffer"><a href="#String-对比-StringBuffer" class="headerlink" title="String 对比 StringBuffer"></a>String 对比 StringBuffer</h2><ul><li><code>String</code> 保存字符串常量，其中的值不能更改。每次更新实际上是更改地址，效率较低</li><li><code>StringBuffer</code> 保存字符串变量，里面的值可以更改。每次更新是更新内容，不用每次更新地址</li></ul><h2 id="StringBuffer-构造方法"><a href="#StringBuffer-构造方法" class="headerlink" title="StringBuffer 构造方法"></a>StringBuffer 构造方法</h2><ol><li><p>无参构造</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer strb1 = new StringBuffer();</span><br></pre></td></tr></table></figure><blockquote><p>创造一个 16 位容量（默认容量）的空 <code>StringBuffer</code></p></blockquote></li><li><p>传入字符串构造</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;abcabc&quot;;</span><br><span class="line">StringBuffer strb2 = new StringBuffer(str1);</span><br></pre></td></tr></table></figure><blockquote><p>（上例）创造一个 str1.length + 16 容量的 <code>StringBuffer</code></p></blockquote></li><li><p>指定容量构造</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer strb3 = new StringBuffer(3);</span><br></pre></td></tr></table></figure><blockquote><p>（上例）创造一个 3 容量的空 <code>StringBuffer</code></p></blockquote></li></ol><h2 id="String-和-StringBuffer的转换"><a href="#String-和-StringBuffer的转换" class="headerlink" title="String 和 StringBuffer的转换"></a>String 和 StringBuffer的转换</h2><ol><li><p>转 StringBuffer</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;abcabc&quot;;</span><br><span class="line">StringBuffer strb1 = new StringBuffer(str1);//方法1（构造器）</span><br><span class="line">StringBuffer strb1 = new StringBuffer();</span><br><span class="line">strb1 = strb1.append(str1);//方法2（先空再append）</span><br></pre></td></tr></table></figure></li><li><p>转 String</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str2 = strb1.toString();//方法1（toString）</span><br><span class="line">String str3 = new String(strb1);//方法2（构造器）</span><br></pre></td></tr></table></figure></li></ol><h2 id="StringBuffer常用方法"><a href="#StringBuffer常用方法" class="headerlink" title="StringBuffer常用方法"></a>StringBuffer常用方法</h2><ul><li><p><code>append(char c)</code>：增加</p><p><code>append(String s)</code> 参数也能是字符串</p><p>特别的，<code>append(null);</code> 的场合，等同于 <code>append(&quot;null&quot;);</code></p></li><li><p><code>append(String s)</code> 参数也能是字符串</p><p>特别的，<code>append(null);</code> 的场合，等同于 <code>append(&quot;null&quot;);</code></p></li><li><p><code>delete(start, end)</code>：删减 [start, end) 的内容</p></li><li><p><code>replace(start, end, string)</code>：将 start 与 end 间的内容替换为 string</p></li><li><p><code>indexOf</code>：查找指定字符串第一次出现时的索引。没找到的场合返回 -1</p></li><li><p><code>insert</code>：在指定索引位置之前插入指定字符串</p></li><li><p><code>length()</code>：返回字符长度</p><p><code>capacity()</code>：返回当前的容量</p><p>String 类对象分配内存时，按照对象中所含字符个数等量分配。</p><p>StringBuffer 类对象分配内存时，除去字符所占空间外，会另加 16 字符大小的缓冲区。</p><p>对于 <code>length()</code> 方法，返回的是字符串长度。对于 <code>capacity()</code> 方法，返回的是 字符串 + 缓冲区 的大小。</p></li></ul><h1 id="StringBuilder-类"><a href="#StringBuilder-类" class="headerlink" title="StringBuilder 类"></a>StringBuilder 类</h1><p>一个可变的字符序列。此类提供一个与 <code>StringBuffer</code> 兼容的 API，但不保证同步（<strong>有线程安全问题</strong>）。该类被设计成 <code>StringBuffer</code> 的一个简易替换，<strong>用在字符串缓冲区被单个线程使用的时候</strong>，建议优先使用该类。在大多数实现中，它比起 <code>StringBuffer</code> 要快。</p><p>在 <code>StringBuilder</code> 是的主要操作是 <code>append</code> 和 <code>insert</code> 方法。可以重载这些方法，以接受任意类型的数据。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309181028471.png"></p><ol><li><code>StringBuilder</code> 也继承了 <code>AbstractStringBuffer</code></li><li><code>StringBuilder</code> 也实现了 <code>Serialiazable</code>，可以串行化</li><li>仍然是在父类中有属性 <code>char[] value</code> ，而且不是 <code>final</code></li><li><code>StringBuilder</code> 也是一个 <code>final</code> 类，不能被继承</li><li><code>StringBuilder</code> 的方法，没有做互斥的处理（没有 <code>synchronize</code>），故而存在线程安全问题</li></ol><h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><ol><li><code>StringBuilder</code> 和 <code>StringBuffer</code> 类似，均代表可变字符序列，而且方法也一样</li><li><code>String</code>：不可变字符序列，效率低，但复用率高</li><li><code>StringBuffer</code>：可变字符序列，效率较高，线程安全（多线程用）</li><li><code>StringBuilder</code>：可变字符序列，效率最高，存在线程安全问题（单线程用）</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java数组</title>
      <link href="/2023/05/10/Java%E6%95%B0%E7%BB%84/"/>
      <url>/2023/05/10/Java%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组：可以存放多个<strong>同一类型</strong>的数据。数组也是一种数据，是<strong>引用类型</strong>。数组本身存放的是一个地址。</p><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><p>数组可以是多个相同类型数据的组合，实现对这些数据的统一管理。数组中的元素可以是任何数据类型。包括基本类型和引用类型。</p><p>数组的下标从 0 开始。且必须在指定范围内使用，否则报错。</p><p>数组属于 引用类型，数组型数据是 对象（Object）</p><p>数组创建后，如果没有赋值，有默认值：</p><table><thead><tr><th>int</th><th>0</th></tr></thead><tbody><tr><td>short</td><td>0</td></tr><tr><td>byte</td><td>0</td></tr><tr><td>long</td><td>0L</td></tr><tr><td>float</td><td>0.0F</td></tr><tr><td>double（</td><td>0.0</td></tr><tr><td>char</td><td>\u0000</td></tr><tr><td>boolean</td><td>false</td></tr><tr><td>String</td><td>null</td></tr><tr><td>Object</td><td>null</td></tr></tbody></table><p>使用数组的步骤：</p><ol><li>声明数组并开辟空间 </li><li>给数组各个元素赋值 </li><li>使用数组</li></ol><p><strong>数组的构造方法</strong></p><ul><li><p>构造方式1：动态初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[] ints = new int[5];// 创建了数组 name，存放5个int</span><br><span class="line">int ints2[] = new int[1];// 这种写法也行</span><br><span class="line">ints[2] = 15;// 访问数组第3个数</span><br></pre></td></tr></table></figure></li><li><p>构造方式2：动态初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char[] chars;// 先声明数组 name，此时数组是 null</span><br><span class="line">chars = new char[2];// 分配内存空间，可以存放数据了</span><br><span class="line">chars[1] = &#x27;\t&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>构造方式3：静态初始化</p></li></ul><blockquote><p>确切知道数组每个元素的场合可以用这个方法。</p></blockquote>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boolean[] bools = &#123;true, false, true, false&#125;;</span><br><span class="line">String[] strs = new String[]&#123;&quot;a&quot;, &quot;b&quot;&#125;;</span><br></pre></td></tr></table></figure><p><strong>数组的使用方法：</strong></p><ul><li><p>访问数组元素：<code>数组名[元素下标]</code></p><p>其中，元素下标从 0 开始编号。如：访问 strs 数组的第一个元素 <code>strs[0]</code></p></li><li><p>数组长度：<code>数组名.length</code></p><p>是一个 int 值。不能通过试图改变该值来改变数组容量</p></li></ul><h2 id="数组赋值机制"><a href="#数组赋值机制" class="headerlink" title="数组赋值机制"></a>数组赋值机制</h2><p><strong>基本数据类型</strong>：赋值方式是值拷贝。这个值就是具体的数据，且互不影响。</p><p><strong>引用数据类型</strong>：赋值方式是地址拷贝。赋的值是地址，赋值方式为引用传达。</p><p>数组在默认情况下是引用传递，赋的值是地址，赋值方式为引用传达。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[] array1 = &#123;0, 0, 0&#125;;</span><br><span class="line">int[] array2 = array1;</span><br><span class="line">array2[0] = 100;</span><br></pre></td></tr></table></figure><p>因为数组在 JVM 的栈里是一个地址，指向 堆 里的一个空间。这两个数组在此时指向同一空间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int[] array1 = &#123;0, 0, 0&#125;;</span><br><span class="line">int[] array2 = new int[array1.length];</span><br><span class="line">for (int i = 0;i &lt; array1.length;i++) &#123;</span><br><span class="line">    array2[i] = array1[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，2个数组都是new出来的，二者地址独立，内容相同。</p><h2 id="数组的扩容"><a href="#数组的扩容" class="headerlink" title="数组的扩容"></a>数组的扩容</h2><p>数组的大小生成时固定，当数组达到上限时，创建一个容量更大的新数组。将旧数组的元素依次放入，之后替换旧数组。</p><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>二维数组实际是由多个一维数组组成的，它的各个元素的长度可以相同，也可以不同。数组是一个对象，所以二维数组的元素存放的是一维数组的地址。</p><p><strong>二维数组构造方法：</strong></p><ul><li><p>构造方法1：动态初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[][] many_ints = new int[3][4]// 创建 有3个 包含4个元素的一维数组 的二维数组</span><br></pre></td></tr></table></figure></li><li><p>构造方法2：动态初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double[][] many_doubles;// 先声明变量</span><br><span class="line">many_doubles = new double[3][4];// 再开辟空间</span><br></pre></td></tr></table></figure></li><li><p>构造方法3：动态初始化-列数不确定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char[][] many_chars = new char[3][];// 创建一个三行列数不确定的二维数组</span><br><span class="line">for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">    many_chars[i] = new char[i + 1];// 此时，每个数组空间依次增大</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造方法4：静态初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[][] many_many = &#123;&#123;1, 3&#125;, &#123;4, 10, 2&#125;, &#123;95&#125;&#125;;</span><br></pre></td></tr></table></figure></li></ul><p><strong>二维数组使用方法：</strong></p><ul><li><code>ints.length</code>：该二维数组的长度</li><li><code>ints[0]</code>：该二维数组的第一个一维数组</li><li><code>ints[x].length</code>：该二维数组的第 X 个子数组的长度</li><li><code>ints[1][0]</code>：该二维数组第二个子数组的第一个元素的值</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java流程结构</title>
      <link href="/2023/05/02/Java%E7%BB%93%E6%9E%84/"/>
      <url>/2023/05/02/Java%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="程序控制结构"><a href="#程序控制结构" class="headerlink" title="程序控制结构"></a>程序控制结构</h1><p>程序运行的流程控制决定程序是如何执行的。主要分为：顺序控制、分支控制、循环控制</p><h2 id="顺序控制"><a href="#顺序控制" class="headerlink" title="顺序控制"></a>顺序控制</h2><p>程序从上到下逐行执行，中间没有任何判断和跳转（默认的控制顺序）</p><p>语句：Java 中最小的执行单位。语句分为 单语句 和 复合语句。</p><ul><li><p>单语句：通常意义的一条语句。语句间以分号 <code>;</code> 分隔。</p></li><li><p>复合语句：一对大括号括起来的语句组。也称为 “块”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    语句1; </span><br><span class="line">    语句2;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>块中可以有多条语句。块后没有分号 <code>;</code></p></li></ul><h2 id="分支控制"><a href="#分支控制" class="headerlink" title="分支控制"></a>分支控制</h2><p>让程序有选择的执行。主要分为：单分支控制、双分支控制</p><h3 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h3><p><strong>单分支控制</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (条件表达式) 语句;</span><br><span class="line">或者，把代码块（复合语句）作为语句的场合也能这样写：</span><br><span class="line">if (条件表达式) &#123;</span><br><span class="line"> 执行代码块;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当条件表达式为 <code>true</code>，就会执行 <code>&#123;执行代码块;&#125;</code>；如果为 <code>false</code> 则不执行。特别地：如果 <code>&#123;执行代码块;&#125;</code> 中只有一条代码，也可以不写 <code>&#123; &#125;</code></p><p><strong>双分支控制</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (条件表达式) &#123;</span><br><span class="line"> 执行代码块;</span><br><span class="line">&#125; else &#123;</span><br><span class="line"> 执行代码块2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当条件表达式为 <code>ture</code>，就会执行 <code>&#123;执行代码块1;&#125;</code>；如果为 <code>false</code> 则执行 <code>&#123;执行代码块2;&#125;</code></p><p><strong>多分支控制</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (条件表达式) &#123;</span><br><span class="line"> 执行代码块;</span><br><span class="line">&#125; else if (条件表达式2) &#123;</span><br><span class="line"> 执行代码块2;</span><br><span class="line">&#125; else if (条件表达式3) &#123;</span><br><span class="line"> 执行代码块3;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">else &#123;</span><br><span class="line"> 执行代码块n；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别地：多分支可以没有 <code>else</code>。此时如果条件都不成立，则无执行入口</p><h3 id="嵌套分支"><a href="#嵌套分支" class="headerlink" title="嵌套分支"></a>嵌套分支</h3><p>在一个分支结构中又完整嵌套了另一个完整的分支结构。里面的分支称为内层分支，外面的分支称为外层分支。</p><p>Java 规定，else 子句属于逻辑上距其最近，且没有匹配 else 的 if 语句：</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int n = 0;</span><br><span class="line">if (n &gt; 0) n++;</span><br><span class="line">if (n &gt; 1) n++;</span><br><span class="line">else n--;//属于上面这个 if 语句</span><br></pre></td></tr></table></figure><p>这个场合，这个 else 语句属于上面的 <code>if (n &gt; 1)</code> 这个语句</p></blockquote><p>要想改变那个匹配关系，要使用 <code>&#123; &#125;</code> 改变语句结构：</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int n = 0;</span><br><span class="line">if (n &gt; 0) &#123;</span><br><span class="line">    n++;</span><br><span class="line">if (n &gt; 1) n++;  </span><br><span class="line">&#125; else n--;</span><br></pre></td></tr></table></figure></blockquote><p><strong>规范：嵌套尽量不超过 3 层（可读性不好）</strong></p><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">switch(表达式)&#123;</span><br><span class="line">case 常量1:</span><br><span class="line">语句块1;</span><br><span class="line">break;//break 语句可选</span><br><span class="line">case 常量2:</span><br><span class="line">语句块2;</span><br><span class="line">break;//break 语句可选</span><br><span class="line">...</span><br><span class="line">default://default 语句可选</span><br><span class="line">default语句块;</span><br><span class="line">break;//break 语句可选</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>switch</code> 关键字，表示 switch 分支。</li><li><code>表达式</code> 对应一个值。<strong>该值必须是 int 或 char</strong>（char 可以转化为 int）。是 byte 或 short 的场合，要提升为 int。不允许 long、double 或 float</li><li><code>case 常量1;</code> 表示：当 <code>表达式</code> 的值等于 <code>常量1</code> ，则执行 <code>语句块1</code>。</li><li><code>break;</code> 表示退出 switch 分支。</li><li>当 <code>表达式</code> 的值匹配 <code>常量1</code> ，则执行 <code>语句块1</code>，如果不匹配，则继续匹配 <code>常量2</code> ，以此类推。</li><li>如果全都不匹配，则执行 <code>default</code>。</li><li>如果不写 <code>break;</code> ，则会发生<strong>穿透</strong>，即不进行判断而继续执行下一语句块。</li></ol><p><strong>使用细节</strong></p><ol><li><code>表达式;</code> 数据类型，应和 <code>case</code> 后的 <code>常量</code> 类型一致，或者是可以自动转换成可以比较的类型。如：输入的是 <code>char</code> 而 <code>常量</code> 是 <code>int</code></li><li>switch 中 <code>表达式</code> 的返回值必须是：<code>byte</code> <code>short</code> <code>int</code> <code>char</code> <code>enum</code> <code>String</code></li><li><code>case</code> 语句中的值必须是 常量 或 常量表达式，不能是 变量。</li><li><code>default</code> 是可选的。没有就不执行。</li><li><code>break;</code> 用来跳出 switch 分支。如果不写，会持续执行语句，直到分支结束或遇到下一个 <code>break;</code></li></ol><h2 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h2><h3 id="普通for循环"><a href="#普通for循环" class="headerlink" title="普通for循环"></a>普通for循环</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(循环变量初始化;循环条件;循环变量迭代)&#123;</span><br><span class="line">循环操作（代码块）;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>for</code> 关键字，表示循环控制</li><li>四个要素：1. 循环变量初始化 2. 循环的条件 3. 循环的操作 4. 循环变量迭代</li></ul><p>所有循环开始前仅一次进行初始化。直到循环条件变为 false 前，执行循环操作。每轮循环结束后，进行循环变量迭代。</p><ul><li>循环操作可以有多条语句</li><li>如果循环操作只有一条语句，可以省略 <code>&quot;&#123;&#125;&quot;</code>，但建议不省略</li></ul><p><strong>使用细节</strong></p><ol><li><p>循环条件是返回一个 boolean 值（<code>ture</code> 或 <code>false</code>）的公式。</p><p>循环条件可以为空。这个场合，默认为真（true）</p></li><li><p><code>for(;循环条件;)&#123; &#125;</code> 其中的初始化和变量迭代可以写在别处，但 <code>;</code> 不能省略。如果不写在别处，那个 <code>循环变量初始化</code> 中声明的变量只能在该 for 循环中使用。</p></li><li><p>控制台用 ctrl + c 强制结束一个流程</p></li><li><p>循环初始值可以有多条初始化语句，但要求类型一样，并用 <code>,</code> 隔开。</p><p>变量迭代也可以有多条代码，用 <code>,</code> 隔开</p></li></ol><h3 id="for-each（泛型-for-循环）"><a href="#for-each（泛型-for-循环）" class="headerlink" title="for each（泛型 for 循环）"></a>for each（泛型 for 循环）</h3><p>泛型 for 循环（增强 for 循环）能用来依次处理数组、集合中的每个元素，而不必考虑下标值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(int i : nums)&#123;//其中 nums 是一个一维 int 数组</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型 for 循环适用于数组或一个实现了 Iterable 接口的对象。泛型 for 循环的本质是一个 Iterator（迭代器）</p><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while(循环条件)&#123;</span><br><span class="line"> 循环体(代码块);</span><br><span class="line"> 循环变量迭代;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>while</code> 也有四要素，只是位置和 <code>for</code> 不同</p><p><strong>使用细节</strong></p><ol><li><p>循环条件是返回一个 boolean 值（<code>ture</code> 或 <code>false</code>）的公式。</p><p>while 循环中，循环条件不能为空。</p></li><li><p><code>while</code> 循环是先判断再执行语句</p></li></ol><h3 id="do-while"><a href="#do-while" class="headerlink" title="do..while"></a>do..while</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">循环体;</span><br><span class="line">循环变量迭代;</span><br><span class="line">&#125;while(循环条件);</span><br></pre></td></tr></table></figure><ol><li><code>do</code> <code>while</code> 是关键字</li><li>也有四要素，位置不同</li><li>先执行，再判断。也就是说，一定会至少执行一次</li><li><strong>最后有一个 <code>;</code></strong></li><li><code>while</code> 与 <code>do..while</code> 区别：“要账”</li></ol><p><strong>使用细节</strong></p><ol><li>循环条件是返回一个 boolean 值（<code>ture</code> 或 <code>false</code>）的公式。</li><li><code>do..while</code> 循环是先执行再判断的语句。因此至少执行一次。</li></ol><h3 id="多重循环控制"><a href="#多重循环控制" class="headerlink" title="多重循环控制"></a>多重循环控制</h3><p>将一个循环放在另一个循环体内，就形成了嵌套循环。建议一般使用两层，最多不超过三层。</p><p>嵌套循环 是把 内层循环 当成 外层循环 的 循环体。只有内层 <code>false</code> 时才可能结束当层循环。</p><p>若内层执行 n 次，外层 m 次，则合计会循环 n*m 次</p><h2 id="跳转控制语句"><a href="#跳转控制语句" class="headerlink" title="跳转控制语句"></a>跳转控制语句</h2><p>跳转控制语句用于分支或循环中，以便程序员更好控制程序执行方向</p><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a:&#123;</span><br><span class="line">b:&#123;</span><br><span class="line">c:&#123;</span><br><span class="line">   ...</span><br><span class="line"> berak b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>a:</code> <code>b:</code> <code>c:</code> 是标签，名字由程序员指定</li><li><code>break</code> 后指定哪个标签就退出到哪里</li><li><strong>实际开发中，尽量不要使用标签</strong></li></ol><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>用于中止一个语句块的执行</p><p>语法：<code>break;</code></p><p>break 可以被用在三种场合中</p><ul><li><p>switch 语句中，以跳出判断（结束穿透）</p></li><li><p>for、while、do…while 循环语句中，以跳出循环</p></li><li><p>语句块中，以跳过本块中所有剩余语句</p></li></ul><blockquote><p><code>break</code> 语句出现在多层嵌套的语句块中时，可以通过 <strong>标签</strong> 指明要终止的时哪一层语句块。</p></blockquote><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>在循环中出现。用于结束本次循环，继续下一次循环</p><p>语法：<code>continue;</code></p><p>进行下次循环前，仍会判断循环条件是否满足</p><p>在多层嵌套循环中，可以通过标签指出跳出哪次循环（同 <code>break</code>）</p><h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><p>用于方法。表示跳出所在的方法</p><p>语法：<code>return;</code></p><p>方法有返回值的场合，将返回值写在 return 后：<code>return 值;</code></p><p>如果写在主方法 则跳出程序。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 流程结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-应用层</title>
      <link href="/2023/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.2/"/>
      <url>/2023/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.2/</url>
      
        <content type="html"><![CDATA[<h1 id="应用层概述"><a href="#应用层概述" class="headerlink" title="应用层概述"></a>应用层概述</h1><p>应用层是计算机网络体系结构的最顶层，是设计和建立计算机网络的最终目的，也是计算机网络中发展最快的部分。</p><ul><li>早期基于文本的应用(电子邮件、远程登录、文件传输、新闻组)。</li><li>20世纪90年代将因特网带入干家万户的万维网WWW。</li><li>当今流行的即时通信、P2P文件共享及各种音视频应用。</li><li>计算设备的小型化和“无处不在”，宽带住宅接入和无线接入的日益普及和迅速发展，为未来更多<br>的新型应用提供了广阔的舞台。</li></ul><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514132852.png"></p><h1 id="应用进程通信方式"><a href="#应用进程通信方式" class="headerlink" title="应用进程通信方式"></a>应用进程通信方式</h1><p>网络应用程序运行在处于网络边缘的不同的端系统上,通过彼此间的通信来共同完成某项任务。</p><p>开发一种新的网络应用首先要考虑的问题就是网络应用程序在各种端系统上的组织方式和它们之间的关系。<br>目前流行的主要有以下两种:</p><h2 id="客户-x2F-服务器方式"><a href="#客户-x2F-服务器方式" class="headerlink" title="客户&#x2F;服务器方式"></a>客户&#x2F;服务器方式</h2><p>应用层的许多协议是基于C&#x2F;S方式，例如，在移动互联网环境下，每个应用APP都是一个客户端。</p><p>客户&#x2F;服务器方式特点：</p><ul><li>客户(client)和服务器(server)是指通信中所涉及的2个应用进程</li><li>客户&#x2F;服务器方式描述的是应用进程之间服务和被服务的关系</li><li>客户是服务请求方(主动请求服务，被服务)</li><li>服务器是服务提供方(被动接受服务请求提供服务)</li><li>服务器总是处于运行状态，并等待客户的服务请求。服务器具有固定端口号(例如HTTP服务<br>器的默认端口号为80) ，而运行服务器的主机也具有固定的IP地址。</li></ul><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514133535.png"></p><p>主机 A 中运行的是客户程序，正在运行的客户程序称为客户进程，也可简称为客户。主机 A 应称为客户计算机，也可简称为客户。</p><p>主机 B 中运行的是服务器程序，正在运行的服务器程序称为服务器进程，也可简称为服务器。主机 B 应称为服务器计算机，也可简称为服务器。</p><p>C&#x2F;S方式是因特网上传统的、同时也是最成熟的方式，很多我们熟悉的网络应用采用的都是C&#x2F;S方式。包括万维网WWW.电子邮件、文件传输FTP等。</p><p>基于C&#x2F;S方式的应用服务通常是服务集中型的，即应用服务集中在网络中比客户计算机少得多的服务器计算机上。</p><p>由于一台服务器计算机要为多个客户机提供服务,在C&#x2F;S应用中，常会出现服务器计算机跟不上众多客户机请求的情况。</p><p>为此，在C&#x2F;S应用中，常用计算机群集(或服务器场)构建一个强大的虚拟服务器。</p><h2 id="浏览器-x2F-服务器方式"><a href="#浏览器-x2F-服务器方式" class="headerlink" title="浏览器&#x2F;服务器方式"></a>浏览器&#x2F;服务器方式</h2><ul><li>B&#x2F;S方式可以看做C&#x2F;S方式的特例，即客户软件改为浏览器了</li><li>B&#x2F;S方式采取浏览器请求、服务器响应的工作模式</li><li>在B&#x2F;S方式下，用户界面完全通过Web浏览器实现，一部分事务逻辑在前端实现，但主要的事务逻辑在服务器端实现</li></ul><p>B&#x2F;S方式通常采取3层架构实现</p><ol><li>数据层:由数据库服务器承担数据处理逻辑，其任务是接受Web服务器对数据库服务器提出的数据操作请求，然后由数据库服务器进行数据处理并把处理结果返回给web服务器</li><li>处理层:由Web服务器承担业务处理逻辑和页面存储管理，接受客户浏览器的任务请求，执行<br>相应的事务处理</li><li>表现层:浏览器仅承担网页信息的浏览功能，以，超文本格式实现信息的输入和浏览</li></ol><blockquote><p>实际部署时也可以把数据库服务器和web服务器部署在同一台设备上</p></blockquote><p>B&#x2F;S方式的特点：</p><ul><li>界面统- -, 使用简单。客户端只需要安装浏览器软件</li><li>易于维护。对应用系统升级时，只需更新服务器端的软件，减轻了系统维护和升级的成本</li><li>可扩展性好。采用标准的TCP&#x2F;IP和HTTP协议，具有良好的扩展性</li><li>信息共享度高。HTML是数据格式的一个开放标准，目前大多数流行的软件均支持HTML</li><li>需要注意的是，在- -种浏览器环境下开发的界面在另一种浏览器环境下可能有不完全适配的情况，这时需要安装对应的浏览器</li></ul><h2 id="对等方式"><a href="#对等方式" class="headerlink" title="对等方式"></a>对等方式</h2><p>在P2P方式中，没有固定的服务请求者和服务提供者,分布在网络边缘各端系统中的应用进程是对等<br>的，被称为对等方。对等方相互之间直接通信，每个对等方既是服务的请求者，又是服务的提供者。</p><p>目前，在因特网.上流行的P2P应用主要包括P2P文件共享、即时通信、P2P流媒体、分布式存储等</p><p>基于P2P的应用是服务分散型的，因为服务不是集中在少数几个服务器计算机中,而是分散在大量对等计算机中，这些计算机并不为服务提供商所有，而是为个人控制的桌面计算机和笔记本电脑，它们通常位于住宅、校园和办公室中。</p><p>P2P方式的最突出特性之一就是它的可扩展性。 因为系统每增加一一个对等方,不仅增加的是服务的请求者，同时也增加了服务的提供者，系统性能不会因规模的增大而降低。</p><p>P2P方式具有成本上的优势，因为它通常不需要庞大的服务器设施和服务器带宽。为了降低成本,服务提供商对于将P2P方式用于应用的兴趣越来越大。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514134619.png"></p><p>对比：</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514134649.png"></p><h1 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h1><p>域名系统DNS作用：方便用户记忆，但IP地址和域名的映射关系并非永久不变</p><h2 id="层次树状结构的域名结构"><a href="#层次树状结构的域名结构" class="headerlink" title="层次树状结构的域名结构"></a>层次树状结构的域名结构</h2><p>早在1983年，因特网就开始采用层次结构的命名树作为主机的名字(即域名)并使用分布式的域名系统DNS。<strong>DNS使大多数域名都在本地解析，仅少量解析需要在因特网上通信，因此系统效率很高</strong>。</p><p>域名的结构由若干个分量组成，各分量之间用“点”隔开,分别代表不同级别的域名</p><ol><li>每一级的域名都由英文字母和数字组成，不超过63个字符，不区分大小写字母。</li><li>级别最低的域名写在最左边，而级别最高的顶级域名写在最右边。</li><li>完整的域名不超过255个字符。</li></ol><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514142044.png"></p><p>域名系统既不规定一个域名需要包含多少个下级域名， 也不规定每一级的域名代表什么意思。</p><p>各级域名由其上一级的域名管理机构管理，而最高的顶级域名则由因特网名称与数字地址分配机构ICANN进行管理。</p><h2 id="顶级域名TLD"><a href="#顶级域名TLD" class="headerlink" title="顶级域名TLD"></a>顶级域名TLD</h2><p>顶级域名TLD分为3类：</p><ol><li>国家顶级域名nTLD：采用ISO 3166的规定。如cn表示中国</li><li>通用顶级域名gTLD：最常见的通用顶级域名有七个，即: com (公司企业)、net (网络服务机构)、org (非营利性组织)、int (国际组织)、edu (美国教育结构)、gov (美国政府部门)、mil (美国军事部门)</li><li>反向域arpa：用于反向域名解析，即IP地址反向解析为域名。</li></ol><h2 id="二级域名"><a href="#二级域名" class="headerlink" title="二级域名"></a>二级域名</h2><p>在国家顶级域名下注册的二级域名均由该国家自行确定。我国则将二级域名划分为以下两类:</p><ol><li>类别域名：共七个: ac (科研机构)、com (工、商、金融等企业)、edu (教育机构) .gov (政府部门) . net (提供网络服务的机构)、mil (军事机构)和org (非营利性组织)。</li><li>行政区域名：共34个，适用于我国的各省、自治区、直辖市。</li></ol><blockquote><p>需要注意的是，名称相同的域名其登记未必相同。例如，com 是通用顶级域名，但我国顶级</p><p>域名 cn 下也有一个名称为 com 的二级域名</p></blockquote><h2 id="因特网的域名空间"><a href="#因特网的域名空间" class="headerlink" title="因特网的域名空间"></a>因特网的域名空间</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514142622.png"></p><p>这种按等级管理的命名方法便于维护名字的唯一性， 并且也容易设计出一种高效的域名查询机制。需要注意的是，域名只是个逻辑概念，并不代表计算机所在的物理地点。MAC才是物理地址</p><h2 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h2><p>域名和IP地址的映射关系必须保存在域名服务器中,供所有其他应用查询。显然不能将所有信息都储存在一台域名服务器中。DNS使用分布在各地的域名服务器来实现域名到IP地址的转换。</p><p>域名服务器可以划分为以下四种不同的类型：</p><ol><li><p>根域名服务器：</p><p>根域名服务器是<strong>最高层次的域名服务器</strong>。<strong>每个根域名服务器都知道所有的顶级域名服务器的域名及其IP地址</strong>。因特网上共有13个不同IP地址的根域名服务器。尽管我们将这13个根域名服务器中的每一个都视为单个的服务器, 但“每台服务器”实际上是由许多分布在世界各地的计算机构成的服务器群集。<strong>当本地域名服务器向根域名服务器发出查询请求时，路由器就把查询请求报文转发到离这个DNS客户最近的-一个根域名服务器。这就加快了DNS的查询过程</strong>，同时也更合理地利用了因特网的资源。<strong>根域名服务器通常并不直接对域名进行解析，而是返回该域名所属顶级域名的顶级域名服务器的IP地址</strong>。</p></li><li><p>顶级域名服务器：</p><p>这些域名服务器<strong>负责管理在该顶级域名服务器注册的所有二级域名</strong>。当收到DNS查询请求时就给出相应的回答(可能是最后的结果，也可能是下一级权限域名服务器的IP地址)。</p></li><li><p>权限域名服务器：</p><p>这些域名服务器<strong>负责管理某个区的域名</strong>。每一个主机的域名都必须在某个权限域名服务器处注册登记。因此权限域名服务器知道其管辖的域名与IP地址的映射关系。另外,权限域名服务器还知道其下级域名服务器的地址。</p></li><li><p>本地域名服务器：</p><p>本地域名服务器<strong>不属于上述的域名服务器的等级结构</strong>。当一个主机发出DNS请求报文时,这个报文就首先被送往该主机的本地域名服务器。<strong>本地域名服务器起着代理的作用</strong>，会将该报文转发到上述的域名服务器的等级结构中。每一个因特网服务提供者ISP, 一个大学,甚至一个大学里的学院，都可以拥有一个本地域名服务器，<strong>它有时也称为默认域名服务器</strong>。本地域名服务器离用户较近，一般不超过几个路由器的距离，也有可能就在同-一个局域网中。<strong>本地域名服务器的IP地址需要直接配置在需要域名解析的主机中</strong>。</p></li></ol><blockquote><p>上述服务器分别管理下一级的域名和其IP地址</p></blockquote><h2 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h2><p>域名解析的过程有<strong>递归</strong>和<strong>迭代</strong>2种查询方式</p><p>递归查询：每一个服务器都进行一次查询过程，递归查询对于被查询的域名服务器负担太大</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514143555.png"></p><p>迭代查询：通常采用从请求主机到本地域名服务器的查询是递归查询，而其余的查询是迭代查询。减轻服务器负担</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514143729.png"></p><p>为了提高DNS的查询效率,并减轻根域名服务器的负荷和减少因特网上的DNS查询报文数量,在域名服务器中广泛地使用了<strong>高速缓存</strong>。高速缓存用来存放最近查询过的域名以及从何处获得域名映射信息的记录。</p><p>例题</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514144530.png"></p><h1 id="文件传送协议-FTP"><a href="#文件传送协议-FTP" class="headerlink" title="文件传送协议 FTP"></a><strong>文件传送协议 FTP</strong></h1><p>将某台计算机中的文件通过网络传送到可能相距很远的另-台计算机中，是一项基本的网络应用，即<strong>文件传送</strong>。</p><p>文件传送协议FTP (File Transfer Protocol)是因特网上使用得最广泛的文件传送协议。</p><p>FTP<strong>提供交互式的访问</strong>，<strong>允许客户指明文件的类型与格式</strong>(如指明是否使用ASCII码) 并<strong>允许文件具有存取权限</strong>(如访问文件的用户必须经过授权，并输入有效的口令)。</p><p>FTP<strong>屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算机之间传送文件</strong>。</p><p>常见用途：</p><ol><li>FTP的常见用途是在计算机之间传输文件，尤其是用于批量传输文件。</li><li>FTP的另一个常见用途是让网站设计者将构成网站内容的大量文件批量.上传到他们的Web服务器。</li></ol><h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514145258.png"></p><p>FTP传送分<strong>主动模式</strong>和<strong>被动模式</strong></p><p>主动模式：</p><p>被动模式：</p><h1 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h1><p>电子邮件(E-mail) 是因特网上最早流行的一种应用，并且仍然是当今因特网上最重要、最实用的应用之一。</p><p>电子邮件与邮政系统的寄信相似。特点：</p><ol><li>发件人将邮件发送到自己使用的邮件服务器;</li><li>发件人的邮件服务器将收到的邮件按其目的地址转发到收件人邮件服务器中的收件人邮箱;</li><li>收件人在方便的时候访问收件人邮件服务器中自己的邮箱，获取收到的电子邮件。</li></ol><p>电子邮件系统采用<strong>客户&#x2F;服务器</strong>方式。</p><h2 id="电子邮件格式"><a href="#电子邮件格式" class="headerlink" title="电子邮件格式"></a>电子邮件格式</h2><p>电子邮件的信息格式并不是由SMTP定义的，而是在RFC 822中单独定义的。这个RFC文档已在2008年更新为RFC 5322。一个电子邮件有<strong>信封和内容</strong>两部分。而内容又由<strong>首部和主体</strong>两部分构成。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514150512.png"></p><h2 id="电子邮件系统构件"><a href="#电子邮件系统构件" class="headerlink" title="电子邮件系统构件"></a>电子邮件系统构件</h2><p>电子邮件系统的三个主要组成构件：<strong>用户代理、邮件服务器、电子邮件所需的协议</strong>。</p><p>用户代理：用户代理是用户与电子邮件系统的接口，又称为电子邮件客户端软件。</p><p>邮件服务器：邮件服务器是电子邮件系统的基础设施。因特网.上所有的ISP都有邮件服务器，其功能是发送和接收邮件,同时还要负责维护用户的邮箱。</p><p>电子邮件所需的协议：协议包括邮件发送协议(例如SMTP)和邮件读取协议(例如POP3，IMAP)。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514150049.png"></p><h2 id="发送协议"><a href="#发送协议" class="headerlink" title="发送协议"></a>发送协议</h2><p>简单邮件传送协议SMTP（Simple Mail Transfer Protocol）</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514150315.png"></p><p>SMTP协议<strong>只能传送ASCII码文本数据</strong>，不能传送可执行文件或其他的二进制对象。</p><p>SMTP不能满足传送多媒体邮件(例如带有图片、音频或视频数据)的需要。并且许多其他非英语国家的文字(例如中文、俄文、甚至带有重音符号的法文或德文)也无法用SMTP传送。<strong>为解决SMTP传送非ASCII码文本的问题，提出了多用途因特网邮件扩展MIME</strong> (Multipurpose Intemet Mail Extensions)</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514150654.png"></p><h2 id="读取协议"><a href="#读取协议" class="headerlink" title="读取协议"></a>读取协议</h2><p>常用的邮件读取协议有以下两个：**POP **和 <strong>IMAP</strong></p><p>邮局协议POP (Post Office Protocol)，POP3是其第3三个版本,是因特网正式标准。非常简单、功能有限的邮件读取协议。用户<strong>只能以下载并删除方式或下载并保留方式</strong>从邮件服务器下载邮件到用户方计算机。<strong>不允许用户在邮件服务器上管理自己的邮件</strong>。(例如创建文件夹, 对邮件进行分类管理等)。</p><p>因特网邮件访问协议IMAP (Internet Message Access Protocol)，IMAP4是其第四个版本，目前还只是因特网建议标准。功能比POP3强大的邮件读取协议。用<strong>户在自己的计算机上就可以操控邮件服务器中的邮箱</strong>，就像在本地操控一样，因此IMAP是  一个联机协议。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514150926.png"></p><p>POP3和IMAP4<strong>都采用基于TCP连接的客户&#x2F;服务器方式</strong>。POP3使用熟知端口110, IMAP4使用熟知端口143。</p><h1 id="万维网"><a href="#万维网" class="headerlink" title="万维网"></a>万维网</h1><p>万维网WWW (World Wide Web)<strong>并非某种特殊的计算机网络</strong>。它是一-个大规模的、联机式的信息储藏所，<strong>是运行在因特网上的一个分布式应用</strong>。万维网<strong>利用网页之间的超链接将不同网站的网页链接成一-张逻辑上的信息网</strong>。</p><p>万维网使用<strong>统一资源定位符URL</strong>来指明因特网上任何种类“资源”的位置。</p><p>URL的一般形式由以下四个部分组成:</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514151340.png"></p><h2 id="超文本传输协议-HTTP"><a href="#超文本传输协议-HTTP" class="headerlink" title="超文本传输协议 HTTP"></a>超文本传输协议 HTTP</h2><p>HTTP&#x2F;1.0采用<strong>非持续连接方式</strong>。在该方式下，每次浏览器要请求-个文件都要与服务器建立TCP连接,当收到响应后就立即关闭连接。</p><p>问题：<strong>每请求一个文档就要有两倍的RTT的开销</strong>。若-个网页上有很多引用对象(例如图片等)，那么请求每一个对象都需要花费2RTT的时间。<strong>为了减小时延，浏览器通常会建立多个并行的TCP连接同时请求多个对象</strong>。<strong>但是,这会大量占用万维网服务器的资源</strong>，特别是万维网服务器往往要同时服务于大量客户的请求，这会使其负担很重。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514151610.png"></p><p>HTTP&#x2F;1.1采用<strong>持续连接方式</strong>。在该方式下，万维网服务器在发送响应后仍然保持这条连接，使同一个客户(浏览器)和该服务器可以继续在这条连接上传送后续的HTTP请求报文和响应报文。<strong>这并不局限于传送同一个页面上引用的对象，而是只要这些文档都在同一个服务器上就行</strong>。</p><p>为了进一步提高效率， HTTP&#x2F;1.1 的持续连接还可以使用<strong>流水线</strong>方式工作，即浏览器在收到HTTP的响应报文之前就能够连续发送多个请求报文。这样的一个接一个的请求报文到达服务器后，服务器就发回一个接一个的响应报文。这样就节省了很多个RTT时间，使TCP连接中的空闲时间减少,提高了下载文档的效率。</p><h2 id="HTTP的报文格式"><a href="#HTTP的报文格式" class="headerlink" title="HTTP的报文格式"></a>HTTP的报文格式</h2><p>HTTP是面向文本的，其报文中的每一个字段都是-些ASCII码串, 并且每个字段的长度都是不确定的。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514151938.png"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514152013.png"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514152047.png"></p><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>使用Cookie在服务器上记录用户信息</p><p>早期的万维网应用非常简单，仅仅是用户查看存放在不同服务器上的各种静态的文档。因此HTTP被设计为一种无状态的协议。这样可以简化服务器的设计。</p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-引言</title>
      <link href="/2023/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.1/"/>
      <url>/2023/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.1/</url>
      
        <content type="html"><![CDATA[<h1 id="因特网简介"><a href="#因特网简介" class="headerlink" title="因特网简介"></a>因特网简介</h1><h2 id="网络，互联网与因特网的区别于关系"><a href="#网络，互联网与因特网的区别于关系" class="headerlink" title="网络，互联网与因特网的区别于关系"></a>网络，互联网与因特网的区别于关系</h2><p>网络：使用有线链路的简单网络</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514115621.png"></p><p>互联网：若干网络通过路由器互联形成互联网</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514115639.png"></p><p>因特网：最大的互联网，日常生活中，人们口中的互联网指因特网</p><p>Internet 与 internet对比：</p><p>Internet：专用名词，必须使用 TCP&#x2F;IP 协议族，叫做因特网</p><p>internet：通用名词，可以使用任意的协议，叫互联网</p><h2 id="因特网发展的三个阶段"><a href="#因特网发展的三个阶段" class="headerlink" title="因特网发展的三个阶段"></a>因特网发展的三个阶段</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514120308.png"></p><p>ISP：internet service provider，因特网服务提供者</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514120513.png"></p><p>因特网已发展成为基于ISP的多层次结构的互连网络，三层ISP结构互联网示意图</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514120708.png"></p><h2 id="因特网标准化工作"><a href="#因特网标准化工作" class="headerlink" title="因特网标准化工作"></a>因特网标准化工作</h2><p>因特网的标准化工作是面向公众的,其任何一个建议标准在成为因特网标准之前都以RFC技术文档的形式在因特网上发表。<br>RFC (Request For Comments)的意思是“请求评论”。任何人都可以从因特网上免费下载RFC文档(<a href="http://ww.etf.org/rfc.html">http://ww.etf.org/rfc.html</a>) ，并随时对某个RFC文档发表意见和建议。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514121151.png"></p><h2 id="因特网的管理机构"><a href="#因特网的管理机构" class="headerlink" title="因特网的管理机构"></a>因特网的管理机构</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514121239.png"></p><h2 id="因特网组成"><a href="#因特网组成" class="headerlink" title="因特网组成"></a>因特网组成</h2><p>因特网由<strong>核心部分</strong>和<strong>边缘部分</strong>组成</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514121431.png"></p><p>核心部分：大量异构网络和连接这些网络搭建服务器组成，为边缘部分提供连通性和数据交换服务</p><p>边缘部分：由各个用户设备组成，这些设备称为主机，直接由用户使用，为用户提供网络服务</p><p>核心部分中起特殊作用的是路由器，用来实现分组交换，分组交换是网络核心部分最重要的功能</p><h1 id="数据交换方式"><a href="#数据交换方式" class="headerlink" title="数据交换方式"></a>数据交换方式</h1><p>数据交换有：<strong>电路交换，分组交换，报文交换</strong></p><h2 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514122122.png"></p><p>电路交换过程由于链路一直存在，占用资源，导致线路传输效率一般都会很低</p><h2 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h2><p>采用报文的方式，将长数据分解成一段段的带首部的短数据。分组交换网中的节点先缓存短数据，然后从首部中提取出目的的地址，按照目的地址查找自己的转发表，找到相应的转发接口后，将分组转发出去把分组交给下一个转发节点，经过多个节点的存储转发后，分组最终转发到目的主机。主机接收到数据后，去掉首部，将各数据段组合还原出原始报文</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514123235.png"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514123408.png"></p><h2 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h2><p>报文交换是<strong>分组交换的前身</strong>，在报文交换中， <strong>报文被整个地发送</strong>，而不是拆分成若干个分组进行发送。交换节点将报文<strong>整体接收完成后才能查找转发表</strong>，将整个报文转发到下一个节点。因此，报文交换比分组交换带来的<strong>转发时延要长很多</strong>，需要交换节点具有的<strong>缓存空间也大很多</strong>。</p><h2 id="三种交换方式的对比"><a href="#三种交换方式的对比" class="headerlink" title="三种交换方式的对比"></a>三种交换方式的对比</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514123725.png"></p><p>若要连续传送大量的数据，并且数据传送时间远大于建立连接的时间，则使用电路交换可以有较高的传输效率。然而计算机的数据传送往往是突发式的，采用电路交换时通信线路的利用率会很低。</p><p>报文交换和分组交换都不需要建立连接(即预先分配通信资源) ，在传送计算机的突发数据时可以提高通信线路的利用率。</p><p>将报文构造成若干个更小的分组进行分组交换，比将整个报文进行报文交换的时延要小，并且还可以避免太长的报文长时间占用链路，有利于差错控制，同时具有更好的灵活性。</p><h1 id="计算机网络定义和分类"><a href="#计算机网络定义和分类" class="headerlink" title="计算机网络定义和分类"></a>计算机网络定义和分类</h1><h2 id="计算机网络定义"><a href="#计算机网络定义" class="headerlink" title="计算机网络定义"></a>计算机网络定义</h2><p><strong>早期</strong>计算机网络定义：一些互联的、自治的、计算机集合</p><p>互联：可通过有线或无线的方式进行数据通信</p><p>自治：独立的计算机有自己的硬件和软件，可独立运行</p><p>计算机集合：至少2台及以上的计算机</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514124344.png"></p><p><strong>现阶段</strong>计算机网络定义：计算机网络主要是由一些通用的、可编程的硬件互连而成的，而这些硬件并非专门用来实现某一特定目的(例如，传送数据或视频信号)这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。</p><p>可编程的硬件：不限于计算机，而是包括了智能手机、具有网络功能的传感器以及智能家电等智能硬件，这些硬件一定包含有中央处理单元(CPU)</p><p>各类应用：计算机网络并非只用来传送数据，而是能够基于数据传送进而实现各种各样的应用，包括今后可能出现的各种应用。</p><h2 id="计算机网络分类"><a href="#计算机网络分类" class="headerlink" title="计算机网络分类"></a>计算机网络分类</h2><p>交换方式：可分为<strong>电路交换、报文交换、分组交换</strong></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514123725.png">使用者：可分为<strong>公用网、专用网</strong></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514124819.png"></p><p>传输介质：</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514124937.png"></p><p>覆盖范围：</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514124954.png"></p><p>拓扑：</p><p>总线型：使用单根传输线把计算机连接起来<br>星型<br>环型<br>网状型</p><h1 id="计算机网络性能指标"><a href="#计算机网络性能指标" class="headerlink" title="计算机网络性能指标"></a>计算机网络性能指标</h1><p>从不同方面度量计算机网络的性能：常用的八个计算机网络的性能指标</p><h2 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h2><p>速率是指<strong>数据的传送速率(即每秒传送多少个比特)<strong>，也称为</strong>数据率</strong>(Data Rate) 或<strong>比特率</strong>(Bit Rate)</p><p>速率的基本单位是比特秒（bit&#x2F;s）, 可简记为 b&#x2F;s ,有时也记为bps,即bit per second) 。速率的常用单位有千比特秒(kb&#x2F;s或kbps) 、兆比特秒(Mb&#x2F;s或Mbps) 、吉比特秒(Gb&#x2F;s或Gbps) 以及太比特秒<br>(Tb&#x2F;s或Tbps)。<img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514125655.png"></p><p>比特(bit, 记为小写b)是计算机中数据量的基本单位，一个比特就是二进制数字中的一个1或0。</p><p>数据量的常用单位有字节(byte， 记为大写B)、干字节(KB)、兆字节(MB)、吉字节(GB)以及太字节(TB) 。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514125632.png"></p><blockquote><p>做题时注意字母代表的数字是多少进制，注意看是 B 还是 b</p></blockquote><h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514125906.png"></p><p>带宽：用来表示网络的通信线路所能传送数据的能力，即在单位时间内，能传送的最高数据率，单位与速度相同</p><p>数据传送速率&#x3D; min [主机接口速率,线路带宽,交换机或路由器的接口速率]</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514130228.png"></p><h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>吞吐量：单位时间内通过某个网络或接口的实际数据量，受带宽限制</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514130409.png"></p><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>时延：数据从网络的一端传送到另一端所耗费的时间，也称为延迟或迟延。</p><p>总时延 &#x3D; 发送时延 + 传播时延 + 处理时延 + 排队时延</p><p>发送时延</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514130629.png"></p><p>传播时延</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514130653.png"></p><p>处理时延、排队时延不便计算，一般给出或不计</p><p>电磁波传播速度：</p><p>自由空间：3.0x10^8</p><p>铜线：2.3x10^8</p><p>光纤：2.0x10^8</p><blockquote><p>选光纤是因为光纤带宽大</p></blockquote><p>例题.多段路由器下时延计算通用公式</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514131839.png"></p><p>电路交换：时延&#x3D;2x建立连接时间+报文发送时间+报文传输时间(连接释放时间与其重叠）</p><p>分组交换：报文发送时间+传播时间+中间结点转发时间</p><h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><p>时延带宽积 &#x3D; 传播时延 x 带宽</p><p>链路的时延带宽积又称为以比特为单位的链路长度。</p><h2 id="往返时间"><a href="#往返时间" class="headerlink" title="往返时间"></a>往返时间</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514132134.png"></p><h2 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h2><p>信道利用率：用来表示某信道有百分之几的时间是被利用的(有数据通过)。<br>网络利用率：全网络的信道利用率的加权平均。</p><p>根据排队论，当某信道的利用率增大时，该信道引起的时延也会迅速增加。因此，<strong>信道利用率并非越高越好</strong></p><p>如果令D0表示网络空闲时的时延，D表示网络当前的时延，那么在适当的假定条件下，可以用下面的简单公式来表示D、D0和利用率U之间的关系:</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514132402.png"></p><h2 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h2><p>丢包率即分组丢失率,是指在一定的时间范围内，传输过程中丢失的分组数量与总分组数量的比率。</p><p>丢包率具体可分为接口丢包率、结点丢包率、链路丢包率、路径丢包率、网络丢包率等。</p><p>丢包率是网络运维人员非常关心的一个网络性能指标,但对于普通用户来说往往并不关心这个指标，因为他们通常意识不到网络丢包。</p><p>分组丢失主要有两种情况:</p><ol><li>分组在传输过程中出现误码，被结点丢弃。</li><li>分组到达一台队列已满的分组交换机时被丢弃;在通信量较大时就可能造成网络拥塞。</li></ol><p>因此，丢包率反映了网络的拥塞情况:</p><p>无拥塞时路径丢包率为0，轻度拥塞时路径丢包率为1%<del>4%，严重拥塞时路径丢包率为5%</del>15%</p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-运输层</title>
      <link href="/2023/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.3/"/>
      <url>/2023/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.3/</url>
      
        <content type="html"><![CDATA[<h1 id="数据传输过程"><a href="#数据传输过程" class="headerlink" title="数据传输过程"></a>数据传输过程</h1><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514152751.png"></p><p>数据沿图中止下多次的虚线方向传送的</p><p>运输层直接为应用进程间的逻辑通信提供服务</p><p>运输层向高层用户屏蔽了下面网络核心的细节(如网络拓扑、所采用的路由选择协议等) ，它使应用进看见的就好像是在两个运输层实体之间有一条端到端的逻辑通信信道。根据应用需求的不同，因特网的运输层为应用层提供了两种不同的运输协议，即<strong>面向连接的TCP</strong>和<strong>无连接的UDP</strong>，这两种协议就是本章要讨论的主要内容。</p><h1 id="TCP-x2F-IP-体系结构"><a href="#TCP-x2F-IP-体系结构" class="headerlink" title="TCP&#x2F;IP 体系结构"></a>TCP&#x2F;IP 体系结构</h1><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230520181329.png"></p><p>网络接口层并没有规定什么具体内容，这是为了可以使用各种不同的网络接口，这是 TCP&#x2F;IP体系结构网际层中的协议。</p><p>网际协议 IP 是网际层中的核心协议，它可以互连不同的网络接口，也就是互连各种异构型网络，并为其上层提供无连接，不可靠的数据报传输服务。</p><p>应用层中，包含有大量的应用层协议，其中有些应用层协议需要使用可靠传输服务，有些应用层协议使用不可靠传输协议。</p><p>TCP&#x2F;IP 体系结构运输层的主要任务就是使用端口号，为运行再不同主机上的应用进程，提供逻辑通信服务，使用 TCP 协议为应用层中那些需要使用可靠传输服务的协议，提供可靠传输服务，另外使用 UDP 协议为应用层中那些使用不可靠传输服务的协议提供不可靠传输服务。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230520182140.png"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230520182241.png"></p><h1 id="运输层端口号"><a href="#运输层端口号" class="headerlink" title="运输层端口号"></a>运输层端口号</h1><p>运行在计算机上的进程使用进程标识符PID来标志。因特网_上的计算机并不是使用统- -的操作系统，不同的操作系统(windows, Linux, Mac OS)又使用不同格式的进程标识符。为了使运行不同操作系统的计算机的应用进程之间能够进行网络通信，就必须使用统- -的方法对TCP&#x2F;IP体系的应用进程进行标识。</p><p>TCP&#x2F;IP体系的运输层使用端口号来区分应用层的不同应用进程。端口号使用16比特表示，取值范围0~65535;</p><ol><li>熟知端口号: 0~1023, IANA把这些端口号指派给了TCP&#x2F;IP体系中最重要的一些应用协议，例如:FTP使用21&#x2F;20, HTTP使用80, DNS使用53.</li><li>登记端口号: 1024~49151,为没有熟知端口号的应用程序使用。使用这类端口号必须在IANA按照规定的手续登记，以防止重复。例如: Microsoft RDP微软远程桌面使用的端口是3389。</li><li>短暂端口号: 49152~65535, 留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。</li></ol><blockquote><p>端口号只具有本地意义，即端口号只是为了标识本计算机应用层中的各进程，在因特网中,不同计算机中的相同端口号是没有联系的。</p></blockquote><h1 id="发送方的复用和接收方的分用"><a href="#发送方的复用和接收方的分用" class="headerlink" title="发送方的复用和接收方的分用"></a>发送方的复用和接收方的分用</h1><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230520183055.png"></p><p>发送方的某些应用进程所发送的不同应用报文，在运输层使 UDP 协议进行封装，称为 UDP复用</p><p>一些应用进程所发送的不同应用报文，在运输层使用 TCP 协议进行封装，这称为 TCP 复用</p><p>运输层使用端口号来区分不同的应用进程，不管是使用运输层的 UDP 协议封装成的 UDP 用户数据报，还是使用 TCP 协议封装成的 TCP 报文段，在网络层都需要使用 IP协议封装成 IP 数据报，这称为 IP 复用</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230520183256.png"></p><h1 id="UDP和TCP"><a href="#UDP和TCP" class="headerlink" title="UDP和TCP"></a>UDP和TCP</h1><p>UDP和TCP是TCP&#x2F;IP体系结构运输层中的两个重要协议</p><h2 id="二者对比"><a href="#二者对比" class="headerlink" title="二者对比"></a>二者对比</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230520184351.png"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230520183623.png"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230520183731.png"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20230520184044122.png" alt="image-20230520184044122"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230520184244.png"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230520184312.png"></p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>为了实现可靠传输，TCP采用了<strong>面向字节流</strong>的方式。但TCP在发送数据时，是从发送缓存取出一-部分或全部字节并给其添加一个首部使之成为<strong>TCP报文段</strong>后进行发送。</p><p>一个TCP报文段由首部和数据载荷两部分构成。</p><h3 id="TCP首部"><a href="#TCP首部" class="headerlink" title="TCP首部"></a>TCP首部</h3><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230520184619.png"></p><p>源端口：占16比特，写入源端口号，用来标识发送该TCP报文段的应用进程。</p><p>目的端口：占16比特，写入目的端口号，用来标识接收该TCP报文段的应用进程。</p><p>序号:占32比特，序号增加到最后一个后，下一个序号就又回到0，指出本TCP报文段数据载荷的第一个字节的序号.</p><p>确认号：占32比特，确认号增加到最后-一个后，下一一个确认号就又回到0，指出期望收到对方下一个TCP报文段的数据载荷的第一个字节的序号，同时也是对之前收到的所有数据的确认。若确认号&#x3D;n,则表明到序号n-1为止的所有数据都已正确接收，期望接收序号为n的数据。</p><p>数据偏移：占4比特，并以4字节为单位。用来指出TCP报文段的数据载荷部分的起始处距离TCP报文段的起始处有多远。这个字段实际，上是指出了TCP报文段的首部长度。首部固定长度为20字节，因此数据偏移字段的最小值为(0101)2首部最大长度为60字节，因此数据偏移字段的最大值为(1111)2</p><p>保留:占6比特，保留为今后使用，但目前应置为0。</p><p>紧急标志位URG:取值为1时紧急指针字段有效;取值为0时紧急指针字段无效。</p><p>确认标志位ACK:取值为1时确认号字段才有效;取值为0时确认号字段无效。</p><p>推送标志位PSH:接收方的TCP收到该标志位为1的报文段会尽快上交应用进程,而不必等到接收缓存都填满后再向上交付。</p><p>复位标志位RST:用来复位TCP连接。当RST&#x3D;1时，表明TCP连接出现了异常，必须释放连接，然后再重新建立连接。RST置1还用来拒绝-一个非法的报文段或拒绝打开- -个TCP连接。</p><p>同步标志位SYN:在TCP连接建立时用来同步序号。</p><p>终止标志位FIN:用来释放TCP连接。</p><p>窗口:占16比特，以字节为单位。指出发送本报文段的- -方的接收窗口。窗口值作为接收方让发送方设置其发送窗口的依据。</p><p>校验和:占16比特，检查范围包括TCP报文段的首部和数据载荷两部分。在计算校验和时，要在TCP报文段的前面加上12字节的伪首部。</p><p>紧急指针:占16比特，以字节为单位，用来指明紧急数据的长度。</p><p>选项：</p><ol><li>最大报文段长度MSS选项: TCP报文段数据载荷部分的最大长度。</li><li>窗口扩大选项:为了扩大窗口(提高吞吐率)。</li><li>时间戳选项: 用来计算往返时间RTT，用于处理序号超范围的情况， 又称为防止序号绕回PAWS。</li><li>选择确认选项</li></ol><p>填充:由于选项的长度可变，因此使用填充来确保报文段首部能被4整除(因为数据偏移字段,也就是首部长度字段，是以4字节为单位的)</p><h3 id="TCP连接建立"><a href="#TCP连接建立" class="headerlink" title="TCP连接建立"></a>TCP连接建立</h3><p>TCP是面向连接的协议，它基于运输连接来传送TCP报文段。TCP运输连接的建立和释放是每一次面向连接的通信中必不可少的过程。</p><p>TCP运输连接有以下三个阶段:</p><ol><li>建立TCP连接（三握手）</li><li>数据传送</li><li>释放TCP连接（四挥手）</li></ol><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230520192534.png"></p><p>TCP的连接建立要解决以下三个问题:</p><ol><li>使TCP双方能够确知对方的存在;</li><li>使TCP双方能够协商- 些参数(如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等) ;</li><li>使TCP双方能够对运输实体资源 (如缓存大小、连接表中的项目等)进行分配。</li></ol><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230520201746.png"></p><p>三握手过程：</p><ol><li>TCP服务器进程首先创建传输控制块。用来存储TCP连接中的一些重要信息。就准备接受TCP客户进程的连接请求。此时，TCP服务器进程就进入监听状态。</li><li>TCP客户进程也是首先创建传输控制块。在打算建立TCP连接时向TCP服务器迸程发送TCP连接请求报文段并进入同步已发送状态。</li><li>TCP服务器进程则向TCP客户进程发送TCP连接清求确认报文段。并进入同步已接收状态。</li><li>TCP客户进程收到TCP连接清求确认报文段后。还要向TCP服务器进程发送一个普通的TCP确认报文段。并进入连接已建立状态。</li><li>TCP服务器进程收到该确认报文段后也进入连接已建立状态。</li></ol><p>注意: TCP规定SYN被设置为1的报文段不能携带数据。但要消耗掉一个序号。</p><p>为什么是三握手而不能简化为两握手：</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230520202001.png"></p><p>如上图，TCP客户进程发送一个连接请求，但该报文段在某些网络结点长时间滞留了。这必然会造成该报文段的超时重传。假设重传的报文段被TCP服务器进程常接收。TCP服务器迸程给TCP客户进程发送一个TCP连接请求确认报文段并进入连接已建立状态。一段时间后，之前滞留在网络中的那个失效的 TCP 连接请求报文段，到达了 TCP 服务器进程。TCP 服务器进程会误认为这是 TCP 客户进程又发起了一个新的 TCP连接请求。于是给 TCP 客户进程发送 TCP 连接请求确认报文段，并进入连接已建立状态。由于 TCP 客户进程并没有发起新的 TCP 连接请求，并且处于关闭状态，因此不会理会该报文段。但 TCP 服务器已进入连接已建立状态，它认为新的 TCP连接已建立好了，并一直等待 TCP 客户进程发来数据，这将白白浪费 TCP 服务器进程所在主机的很多资源。</p><h3 id="TCP连接释放"><a href="#TCP连接释放" class="headerlink" title="TCP连接释放"></a>TCP连接释放</h3><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230520212350.png">四挥手过程：</p><p>1. </p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程</title>
      <link href="/2023/01/04/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2023/01/04/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>程序：为完成特定任务，用某种语言编写的一组指令的集合。</p><p>进程：运行中的程序。当你运行一个程序，系统就会为该进程分配空间。进程是程序的一次执行过程。是一个动态过程，有其自身产生、存在、消亡的过程。</p><p>线程：由进程创建的，进程的一个实体。一个进程可以有多个线程。</p><p>单线程：同一时刻，只允许执行一个线程。</p><p>多线程：同一时刻，可以执行多个线程。</p><p>并发：同一时刻，多个任务交替执行，造成一种貌似并行的状态。单核 CPU 实现的多任务就是并发。</p><p>并行：同一时刻，多个任务同时进行。多核 CPU 可以实现并行。</p><blockquote><p>进程即是程序在处理机中的一次运行。在这样一个结构中不仅包含程序代码，也包括了系统资源的概念。</p><p>在单 CPU 计算机内部，微观上讲，同一时间只能有一个线程运行。实现多线程即从宏观上使多个作业同时执行。</p></blockquote><h2 id="用户线程和守护线程"><a href="#用户线程和守护线程" class="headerlink" title="用户线程和守护线程"></a>用户线程和守护线程</h2><ul><li><p>用户线程：也叫工作线程。当线程任务执行完毕或通知方式结束</p></li><li><p>守护线程：一般是为工作线程服务的。当所有线程结束，守护线程自动结束</p><p>常见的守护线程：垃圾回收机制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread thraed = new Thread(bullet);</span><br><span class="line">thread.setDeamon(true);//这样，子线程被设置为主线程的守护线程</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure></li></ul><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><blockquote><p>Java 的线程是通过包 java.lang 中定义的类 Thread 或者 接口 Runnable来实现的。当生成了一个 Thread 类后就产生了一个线程。通过该对象实例，可以启动线程、终止线程，或暂时挂起线程</p></blockquote><p>线程共有 4 种状态：新建（New）、可运行（Runnable）、死亡（Dead）、阻塞（Blocked）</p><ul><li><p><strong>新建（New）：</strong></p><p>线程对象刚刚创建，还未启动（New）。此时还处于不可运行状态，但已有了相应内存空间及其他资源</p></li><li><p><strong>可运行（Runnable）：</strong></p><p>此时线程已经启动，处于线程的 run() 方法中。这种情况下线程可能正在运行；也可能没有运行，但只要 CPU 空闲就会立刻运行。</p><p>可以运行但没在运行的线程都排在一个队列中，这个队列称为就绪队列。</p><p>可运行状态下，运行中的线程处于运行状态（Running），未运行线程处于就绪状态（Ready）。</p><p>调用 start() 方法可以让线程进入可运行状态。</p></li><li><p><strong>死亡（Dead）：</strong></p><p>线程死亡（Terminated）的原因有两个：一是 run() 方法最后一个语句执行完毕，二是线程遇到异常退出</p></li><li><p><strong>阻塞（Blocked）：</strong></p><p>一个正常运行的线程因为特殊原因被暂停执行，就进入阻塞状态（Blocked）。</p><p>阻塞时线程不能进入就绪对流排队，必须等到引起阻塞的原因消除，才能重新进入队列排队。</p><p>引起阻塞的方法很多，sleep() 和 wait() 是两个常用的阻塞方法</p></li><li><p><strong>中断线程：</strong></p><ul><li><p>void interrupt()：向一个线程发送一个中断请求，并把该线程的 interruptd 状态变为 true。</p><p>中断阻塞线程的场合，会抛出 InterruptException 异常</p></li><li><p>static boolean interrupted()：检测当前线程是否被中断，并重置状态 interrupted 的值。</p><p>连续调用该方法的场合，第二次调用会返回 false</p></li><li><p>boolean isInterrupted()：检测当前线程是否中断。不改变 interrupted 的值</p></li></ul></li></ul><h1 id="线程的创建和使用"><a href="#线程的创建和使用" class="headerlink" title="线程的创建和使用"></a>线程的创建和使用</h1><h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h2><p>在 Java 中线程使用有两种方法：</p><ol><li><p>继承 Thread 类，重写 run 方法</p></li><li><p>实现 Runable 接口，重写 run 方法</p></li></ol><blockquote><p>public class Thread implements RunnableThread 也是实现了 Runable 接口</p></blockquote><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310142038052.png"></p><h3 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h3><blockquote><p>Thread 类是 Java 用于表示线程的类。那么，一个类被定义为其子类，则该类也能用来表示线程</p></blockquote><ol><li>当一个类继承了 Thread 类， 该类就可以当做线程使用</li><li>run方法，Thread 类实现了 Runnable 接口的run方法</li><li>我们需要重写 run方法，写上自己的业务代码</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class Thread01 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        //创建Cat对象，可以当做线程使用</span><br><span class="line">        Cat cat = new Cat();</span><br><span class="line">        cat.start();//启动线程-&gt; 最终会执行cat的run方法</span><br><span class="line">        </span><br><span class="line">        //说明: 当main线程启动一个子线程 Thread-0, 主线程不会阻塞, 会继续执行</span><br><span class="line">        //这时 主线程和子线程是交替执行..</span><br><span class="line">        System.out.println(&quot;主线程继续执行&quot; + Thread.currentThread().getName());//名字main</span><br><span class="line">        for(int i = 0; i &lt; 60; i++) &#123;</span><br><span class="line">            System.out.println(&quot;主线程 i=&quot; + i);</span><br><span class="line">            //让主线程休眠</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat extends Thread &#123;</span><br><span class="line">    int times = 0;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;//重写run方法，写上自己的业务逻辑</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            //该线程每隔1秒。在控制台输出 “喵喵, 我是小猫咪”</span><br><span class="line">            System.out.println(&quot;喵喵, 我是小猫咪&quot; + (++times) + &quot; 线程名=&quot; +  Thread.currentThread().getName());</span><br><span class="line">            //让该线程休眠1秒 ctrl+alt+t</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            if(times == 80) &#123;</span><br><span class="line">                break;//当times 到80, 退出while, 这时线程也就退出..</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现-Runable-接口"><a href="#实现-Runable-接口" class="headerlink" title="实现 Runable 接口"></a>实现 Runable 接口</h3><blockquote><p>Runnable 是 Java 用以实现线程的接口。任何实现线程的类都必须实现该接口。</p></blockquote><ol><li><p>java是单继承的，在某些情况下一一个类可能已经继承了某个父类，这时在用继承Thread类方法来创建线程显然不可能了。</p></li><li><p>java设计者们提供了另外个方式创建线程，就是通过实现Runnable接口来创建线程</p></li><li><p>但是，实现接口这里，因为类没有 start 方法，所以创建线程的方法有所不同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//dog.start(); 这里不能调用start，dog类里面没有这个方法啊</span><br><span class="line">//创建了Thread对象，把 dog对象(实现Runnable),放入Thread</span><br><span class="line">Thread thread = new Thread(dog);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><blockquote><p>这里底层使用了设计模式</p></blockquote></li></ol><p><strong>运用看上方代码</strong></p><p><strong>原理看下方代码</strong></p><p>例.模拟实现设计模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//模拟一个 Thread 类</span><br><span class="line">class ThreadProxy implements Runnable &#123;//你可以把Proxy类当做 ThreadProxy</span><br><span class="line"></span><br><span class="line">    private Runnable target = null;//属性，类型是 Runnable</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        if (target != null) &#123;</span><br><span class="line">            target.run();//动态绑定（运行类型Tiger）</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //构造器，所有实现了 Runnable 接口的类都能传来</span><br><span class="line">    public ThreadProxy(Runnable target) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //模拟的 start 方法</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        start0();//这个方法时真正实现多线程方法</span><br><span class="line">    &#125;</span><br><span class="line">    public void start0() &#123;</span><br><span class="line">        run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图中构造器参数显示，可以接受 Runnable 的实现类，实现 Thread 对象接受相应的实现类，运行线程的方法</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310142118198.png"></p><h3 id="继承-Thread-和-实现-Runable-的区别"><a href="#继承-Thread-和-实现-Runable-的区别" class="headerlink" title="继承 Thread 和 实现 Runable 的区别"></a>继承 Thread 和 实现 Runable 的区别</h3><ol><li>从 Java 设计来看，两者本质上没有区别。Thread 类本身就实现了 Runable 接口，但是 java 是单继承的</li><li>实现 Runable 接口的方式更加适合多个线程共享一个资源的情况，配合Thread类创建新线程，避免了单继承的限制。建议使用</li></ol><h2 id="run-和-start"><a href="#run-和-start" class="headerlink" title="run() 和 start()"></a>run() 和 start()</h2><p>对象.start(); 启动线程，最终会执行cat的run方法，那为什么不直接执行 run方法呢？</p><p>对象.run() 相当于调用类中的 run方法，没有启动线程的功能。这个方法运行完以后，才会继续执行该线程后续的代码。</p><p>run里面只写了要执行的功能。而对象.start()才是真正创建线程并调用该对象的run方法</p><p>start() 源码：</p><ol><li>start() 方法调用了一个 start0() 底层方法</li><li>start0() 是本地方法，由 JVM 调用，底层是 c&#x2F;c++ 实现</li><li>真正的多线程效果，是 start0()，而不是 run()</li><li>start() 方法调用 start0() 方法后，该线程不一定会立刻执行，只是将线程变成了可运行状态。具体何时运行，由 CPU 统一调度</li></ol><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310142101834.png"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310142059184.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void start() &#123;</span><br><span class="line">  start0();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//start0() 是本地方法，是JVM调用, 底层是c/c++实现</span><br><span class="line">//真正实现多线程的效果， 是start0(), 而不是 run</span><br><span class="line">private native void start0();</span><br></pre></td></tr></table></figure><h2 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h2><p>线程有2种终止原因：</p><ol><li><p>当线程结束后，会自动退出（自然行为）</p></li><li><p>还可以通过使用变量来控制 run 方法退出的方式来停止线程，即 <strong>通知方式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadExit_ &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        T t1 = new T();</span><br><span class="line">        t1.start();</span><br><span class="line">        //如果希望main线程去控制t1 线程的终止, 必须可以修改 loop</span><br><span class="line">        //让t1 退出run方法，从而终止 t1线程 -&gt; 通知方式      </span><br><span class="line">        //让主线程休眠 10 秒，再通知 t1线程退出</span><br><span class="line">        System.out.println(&quot;main线程休眠10s...&quot;);</span><br><span class="line">        Thread.sleep(10 * 1000);</span><br><span class="line">        t1.setLoop(false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class T extends Thread &#123;</span><br><span class="line">    private int count = 0;</span><br><span class="line">    //设置一个控制变量</span><br><span class="line">    private boolean loop = true;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (loop) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(50);// 让当前线程休眠50ms</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;T 运行中....&quot; + (++count));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setLoop(boolean loop) &#123;</span><br><span class="line">        this.loop = loop;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="线程常用方法"><a href="#线程常用方法" class="headerlink" title="线程常用方法"></a>线程常用方法</h2><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><ul><li><p>setName(name)：设置线程名称，使之与参数 name 相同</p></li><li><p>getName()：返回线程名称</p></li><li><p>start()：线程开始执行。JVM 调用 start0 方法。该方法会创建新的线程，新线程调用 run。</p></li><li><p>run()调用线程的 run 方法，接口给出，需要我们重写成我们的逻辑</p></li><li><p>sleep(int millsecond)让线程休眠指定的时间，该方法是 Thread 类的静态方法，可以直接调用</p></li><li><p>interrupt()中断线程（不是 中止）</p></li><li><p>wait()：导致当前线程等待</p><p>直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法才能唤醒此线程</p></li><li><p>notify()：唤醒因 wait() 阻塞的线程。</p><p>notifyAll()：唤醒因 wait() 阻塞的线程。</p><p>这些方法（wait()、notify()、notifyAll()）只能在 synchrnized 方法或代码块中调用</p></li><li><p>isAlive()：测试当前线程是否在活动</p></li><li><p>Thread.currentThread()：引用当前运行中的线程</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadMethod01 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        //测试相关的方法</span><br><span class="line">        T t = new T();</span><br><span class="line">        t.setName(&quot;老韩&quot;);</span><br><span class="line">        t.setPriority(Thread.MIN_PRIORITY);//1</span><br><span class="line">        t.start();//启动子线程</span><br><span class="line">        //主线程打印5 hi ,然后我就中断 子线程的休眠</span><br><span class="line">        for(int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            System.out.println(&quot;hi &quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(t.getName() + &quot; 线程的优先级 =&quot; + t.getPriority());//1</span><br><span class="line">        t.interrupt();//当执行到这里，就会中断 t线程的休眠.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class T extends Thread &#123; //自定义的线程类</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">                //Thread.currentThread().getName() 获取当前线程的名称</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;  吃包子~~~~&quot; + i);</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot; 休眠中~~~&quot;);</span><br><span class="line">                Thread.sleep(20000);//20秒</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                //当该线程执行到一个interrupt 方法时，就会catch 一个 异常, 可以加入自己的业务代码</span><br><span class="line">                //InterruptedException 是捕获到一个中断异常.</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;被 interrupt了&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="切换线程"><a href="#切换线程" class="headerlink" title="切换线程"></a>切换线程</h3><ul><li><p>yield()：线程的礼让。让出 CPU 让其他线程执行。因为礼让的时间不确定，所以不一定礼让成功。本质是 RUNNING 切换为 READY，即让当前线程放弃执行权</p></li><li><p>join()：线程的插队。插队的线程一旦插入成功，则必定先执行完插队线程的所有任务将导致其他线程的等待，直到 join() 方法的线程结束</p></li><li><p>join(long timeout)：join，但是时间到后也能结束其他线程的等待</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadMethod02 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        T2 t2 = new T2();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        for(int i = 1; i &lt;= 20; i++) &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            System.out.println(&quot;主线程(小弟) 吃了 &quot; + i  + &quot; 包子&quot;);</span><br><span class="line">            if(i == 5) &#123;</span><br><span class="line">                System.out.println(&quot;主线程(小弟) 让 子线程(老大) 先吃&quot;);</span><br><span class="line">                //join, 线程插队</span><br><span class="line">                //t2.join();// 这里相当于让t2 线程先执行完毕</span><br><span class="line">                //Thread.yield();//礼让，不一定成功..</span><br><span class="line">                System.out.println(&quot;线程(老大) 吃完了 主线程(小弟) 接着吃..&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class T2 extends Thread &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 1; i &lt;= 20; i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);//休眠1秒</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;子线程(老大) 吃了 &quot; + i +  &quot; 包子&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><ul><li><p>setPriority(int priority)：更改线程优先级</p></li><li><p>getPriority()：获取线程优先级</p><p>priority 范围：</p><ul><li>MAX_PRIORITY：最高优先级（10）</li><li>MIN_PRIORITY：最低优先级（1）</li><li>NORM_PRIORITY：不高不低，真是好极了的优先级（5）</li></ul><blockquote><p>每个线程都有一个<strong>优先级</strong>。Java 线程调度采用如下优先级策略：</p></blockquote><ul><li>优先级高的先执行，优先级低的后执行</li><li>每个线程创建时会被自动分配一个优先级。默认的场合，继承父类优先级</li><li>任务紧急的线程，优先级较高</li><li>同优先级线程按 “先进先出” 原则调度</li></ul></li></ul><h2 id="多线程机制"><a href="#多线程机制" class="headerlink" title="多线程机制"></a>多线程机制</h2><ul><li>main线程：程序运行时运行到 main 方法时，会创建 main线程</li><li>子线程：程序运行到 start() 方法时，会开启一个新线程</li></ul><p>Thread.currentThread().getName()：获取当前线程的名字</p><p>各线程间相互独立，某个线程的结束不会影响其他线程。各线程会继续按逻辑运行自己的代码，所有线程都关闭后，进程关闭。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310142052479.png"></p><h3 id="买票案例"><a href="#买票案例" class="headerlink" title="买票案例"></a>买票案例</h3><p>编程模拟三个售票窗口售票100，分别使用继承Thread和实现Runnable方式，并分析有什么问题?</p><p>如图，出现了资源超出的现象，这个问题需要通过线程同步来解决。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public class SellTicket &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//        这里我们会出现超卖..</span><br><span class="line"></span><br><span class="line">//        System.out.println(&quot;===使用继承Thread方式来售票=====&quot;);</span><br><span class="line">//        SellTicket01 sellTicket01 = new SellTicket01();</span><br><span class="line">//        SellTicket01 sellTicket02 = new SellTicket01();</span><br><span class="line">//        SellTicket01 sellTicket03 = new SellTicket01();</span><br><span class="line">//        sellTicket01.start();//启动售票线程</span><br><span class="line">//        sellTicket02.start();//启动售票线程</span><br><span class="line">//        sellTicket03.start();//启动售票线程</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;===使用实现接口方式来售票=====&quot;);</span><br><span class="line">        SellTicket02 sellTicket02 = new SellTicket02();</span><br><span class="line">        new Thread(sellTicket02).start();//第1个线程-窗口</span><br><span class="line">        new Thread(sellTicket02).start();//第2个线程-窗口</span><br><span class="line">        new Thread(sellTicket02).start();//第3个线程-窗口</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//使用Thread方式</span><br><span class="line">class SellTicket01 extends Thread &#123;</span><br><span class="line">    private static int ticketNum = 100;//让多个线程共享 ticketNum</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (ticketNum &lt;= 0) &#123;</span><br><span class="line">                System.out.println(&quot;售票结束...&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //休眠50毫秒, 模拟</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(50);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;窗口 &quot; + Thread.currentThread().getName() + &quot; 售出一张票&quot;</span><br><span class="line">                    + &quot; 剩余票数=&quot; + (--ticketNum));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//实现接口方式</span><br><span class="line">class SellTicket02 implements Runnable &#123;</span><br><span class="line">    private int ticketNum = 100;//让多个线程共享 ticketNum</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (ticketNum &lt;= 0) &#123;</span><br><span class="line">                System.out.println(&quot;售票结束...&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //休眠50毫秒, 模拟</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(50);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;窗口 &quot; + Thread.currentThread().getName() + &quot; 售出一张票&quot;</span><br><span class="line">                    + &quot; 剩余票数=&quot; + (--ticketNum));//1 - 0 - -1  - -2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310142126917.png"></p><h1 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h1><p>线程的状态有（ java 官方枚举中给出的线程状态）：6种</p><ul><li><p><strong>新建（New）：</strong></p><p>线程对象刚刚创建，还未启动（New）。此时还处于不可运行状态，但已有了相应内存空间及其他资源</p></li><li><p><strong>可运行（Runnable）：</strong></p><p>此时线程已经启动，处于线程的 run() 方法中。这种情况下线程可能正在运行；也可能没有运行，但只要 CPU 空闲就会立刻运行。</p><p>可以运行但没在运行的线程都排在一个队列中，这个队列称为就绪队列。</p><p>可运行状态下，运行中的线程处于运行状态（Running），未运行线程处于就绪状态（Ready）。</p><p>调用 start() 方法可以让线程进入可运行状态。</p></li><li><p><strong>阻塞（Blocked）：</strong></p><p>一个正常运行的线程因为特殊原因被暂停执行，就进入阻塞状态（Blocked）。</p><p>阻塞时线程不能进入就绪对流排队，必须等到引起阻塞的原因消除，才能重新进入队列排队。</p><p>引起阻塞的方法很多，sleep() 和 wait() 是两个常用的阻塞方法</p></li><li><p>WAITING：正等待另一个线程执行特定动作的线程</p></li><li><p>TIMED_WAITING：正等待另一个线程执行特定动作达到等待时间的线程</p></li><li><p>TERMINATED：已退出的线程</p></li></ul><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310142205682.png"></p><h1 id="线程同步机制"><a href="#线程同步机制" class="headerlink" title="线程同步机制"></a>线程同步机制</h1><p>在多线程编程，一些敏感数据不允许被多个线程同时访问。此时就用同步访问技术，保证数据在任意时刻，最多有一个线程同时访问，以保证数据的完整性。</p><p>也可以这样理解：线程同步，即当有一个线程对内存进行操作时，其他线程都不能对这个内存地址进行操作（被阻塞），直到该线程完成操作，再让下一线程进行操作。</p><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><ol><li>Java语言中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。</li><li>每个对象都对应于一个可称为互斥锁的标记，这个标记用来保证在任一时刻,， 只能有一个线程访问该对象。</li><li>关键宇synchronized来与对象的互斥锁联系。当某个对象用synchronized修饰时，表明该对象在任一时刻只能由一 个线程访问</li><li>同步的局限性：导致程序的执行效率要降低</li><li>同步方法(非静态的)的锁可以是this，也可以是其他对象(要求是同一个对象)。</li><li>同步方法(静态的)的锁为当前类本身。同步方法(静态的)的锁为当前类本身。</li></ol><blockquote><p>同步方法如果没有使用static修饰，默认锁对象：this</p><p>如果方法使用static修饰，默认锁对象：当前类.class</p></blockquote><p>Java 语言中，有 2 种方式实现互斥锁：</p><ol><li><p>synchronized 关键字</p><p>同步代码块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized (对象) &#123;//得到对象的锁，才能操作同步代码</span><br><span class="line">需要被同步代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步方法：放在方法声明中，表示整个方法为同步方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void method()&#123;</span><br><span class="line">代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用关键字 volatile 声明一个共享数据（变量）。一般很少使用该关键字</p></li></ol><p>前面买票的改进</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">public class SellTicket &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SellTicket03 sellTicket03 = new SellTicket03();</span><br><span class="line">        new Thread(sellTicket03).start();//第1个线程-窗口</span><br><span class="line">        new Thread(sellTicket03).start();//第2个线程-窗口</span><br><span class="line">        new Thread(sellTicket03).start();//第3个线程-窗口</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//实现接口方式, 使用synchronized实现线程同步</span><br><span class="line">class SellTicket03 implements Runnable &#123;</span><br><span class="line">    private int ticketNum = 100;//让多个线程共享 ticketNum</span><br><span class="line">    private boolean loop = true;//控制run方法变量</span><br><span class="line">    Object object = new Object();</span><br><span class="line"></span><br><span class="line">    //同步方法（静态的）的锁为当前类本身</span><br><span class="line">    //1. public synchronized static void m1() &#123;&#125; 锁是加在 SellTicket03.class</span><br><span class="line">    //2. 如果在静态方法中，实现一个同步代码块.</span><br><span class="line">    public static  void m2() &#123;</span><br><span class="line">        synchronized (SellTicket03.class) &#123;</span><br><span class="line">            System.out.println(&quot;m2&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //1. public synchronized void sell() &#123;&#125; 就是一个同步方法</span><br><span class="line">    //2. 这时锁在 this对象</span><br><span class="line">    //3. 也可以在代码块上写 synchronize ,同步代码块, 互斥锁还是在this对象</span><br><span class="line">    public /*synchronized*/ void sell() &#123; //同步方法, 在同一时刻， 只能有一个线程来执行sell方法</span><br><span class="line">        synchronized (/*this*/ object) &#123;</span><br><span class="line">            if (ticketNum &lt;= 0) &#123;</span><br><span class="line">                System.out.println(&quot;售票结束...&quot;);</span><br><span class="line">                loop = false;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            //休眠50毫秒, 模拟</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(50);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;窗口 &quot; + Thread.currentThread().getName() + &quot; 售出一张票&quot;</span><br><span class="line">                    + &quot; 剩余票数=&quot; + (--ticketNum));//1 - 0 - -1  - -2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (loop) &#123;</span><br><span class="line">            sell();//sell方法是一共同步方法</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用Thread方式</span><br><span class="line">class SellTicket01 extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    private static int ticketNum = 100;//让多个线程共享 ticketNum</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (ticketNum &lt;= 0) &#123;</span><br><span class="line">                System.out.println(&quot;售票结束...&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //休眠50毫秒, 模拟</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(50);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;窗口 &quot; + Thread.currentThread().getName() + &quot; 售出一张票&quot;</span><br><span class="line">                    + &quot; 剩余票数=&quot; + (--ticketNum));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//实现接口方式</span><br><span class="line">class SellTicket02 implements Runnable &#123;</span><br><span class="line">    private int ticketNum = 100;//让多个线程共享 ticketNum</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (ticketNum &lt;= 0) &#123;</span><br><span class="line">                System.out.println(&quot;售票结束...&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //休眠50毫秒, 模拟</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(50);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;窗口 &quot; + Thread.currentThread().getName() + &quot; 售出一张票&quot;</span><br><span class="line">                    + &quot; 剩余票数=&quot; + (--ticketNum));//1 - 0 - -1  - -2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h2><p>多个线程都占用了对方的资源，不肯相让，就导致了死锁。编程时要避免死锁的产生。</p><p>上锁是要消耗资源的，应尽量减少上锁的次数，优化代码。</p><p>如一个循环，锁在循环体内和循环体外差距极大</p><ul><li><p>释放锁操作</p><ol><li>当前线程的同步方法、同步代码块执行结束。</li><li>当前线程在同步方法、同步代码块中遇到 break、return</li><li>当前线程在同步方法、同步代码块中出现了未处理的 Error</li><li>当前线程在同步方法、同步代码块中执行了 wait() 方法，当前线程暂停，并释放锁</li></ol></li><li><p><strong>不会</strong>释放锁操作</p><ol><li><p>执行同步方法、同步代码块时，程序调用 Thread.sleep() 或 Thread.yield() 方法暂停当前线程的执行，不会释放锁</p></li><li><p>线程执行同步代码块时，其他线程调用了该线程的 suspend() 方法将该线程挂起，该线程不会释放锁</p><p>所以，应尽量避免使用 suspend() 和 resume() 来控制线程</p></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>至每一个来到这里的人</title>
      <link href="/2022/08/16/hello-world/"/>
      <url>/2022/08/16/hello-world/</url>
      
        <content type="html"><![CDATA[<p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/TEHSN5228DVNJ0IKG8LMEF5.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 必看 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java变量、数据类型</title>
      <link href="/2022/05/17/Java%E5%8F%98%E9%87%8F/"/>
      <url>/2022/05/17/Java%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><p>变量是程序的基本组成单位</p><p>变量的三个基本要素：类型 + 名称 + 值</p><blockquote><p>示例：<code>int a = 1</code>;  类型 int 名称 a 值 1</p></blockquote><p><strong>声明变量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方法1：</span><br><span class="line">int a;</span><br><span class="line">a = 100;</span><br><span class="line">方法2：</span><br><span class="line">int b = 100;</span><br></pre></td></tr></table></figure><h2 id="变量使用注意事项"><a href="#变量使用注意事项" class="headerlink" title="变量使用注意事项"></a>变量使用注意事项</h2><ol><li>变量表示内存中的一个存储区域。不同变量，不同类型，占用的空间大小不同。如 <code>int</code> 有 4 byte，而 <code>double</code> 有 8 byte。</li><li>该区域有自己的名称 <code>变量名</code> 和类型 <code>数据类型</code></li><li>变量必须先声明，后使用。</li><li>变量在同一作用域内不能重名。</li><li>该区域的数据 · 值可以在同一类型范围内变化。</li><li>变量的三个基本要素：类型 + 名称 + 值</li></ol><h1 id="Java-数据类型"><a href="#Java-数据类型" class="headerlink" title="Java 数据类型"></a>Java 数据类型</h1><h4 id="基本数据类型（8个）"><a href="#基本数据类型（8个）" class="headerlink" title="基本数据类型（8个）"></a>基本数据类型（8个）</h4><ul><li><strong>数值型</strong><ul><li>整数类型：<ul><li>byte：占用 1 字节</li><li>short：占用 2 字节</li><li>int：占用 4 字节</li><li>long：占用 8 字节</li></ul></li><li>浮点（小数）类型：<ul><li>float：占用 4 字节</li><li>double：占用 8 字节</li></ul></li></ul></li><li><strong>字符型</strong><ul><li>char：存放单个字符，占用 2 字节</li></ul></li><li><strong>布尔型</strong><ul><li>boolean：存放 true（真），false（假）。占用 1 字节</li></ul></li></ul><h4 id="引用数据类型（复合数据类型）"><a href="#引用数据类型（复合数据类型）" class="headerlink" title="引用数据类型（复合数据类型）"></a>引用数据类型（复合数据类型）</h4><ul><li><strong>类</strong>：class</li><li><strong>接口</strong>：interface</li><li><strong>数组</strong>：<code>[]</code></li></ul><p>引用数据类型存储一个地址，通过这个地址去内存中找值。</p><h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><blockquote><p>用于存放整数值</p></blockquote><ul><li><code>byte</code> 占用 1 字节，范围 -128 ~ 127</li><li><code>short</code> 占用 2 字节，范围 -2<sup>15</sup> ~ 2^15 - 1</li><li><code>int</code> 占用 4 字节，范围 -2^31 ~ 2^31 - 1</li><li><code>long</code> 占用 8 字节，范围 -2^63 ~ 2^63 - 1</li></ul><p><strong>使用细节：</strong></p><ol><li>Java 各整数类型有固定的范围和字符长度，不受具体 OS（操作系统）影响，以保证 Java 程序的可移植性。（Java 由 JVM实现运算，结构统一）</li><li>Java 默认整型常量为 <code>int</code> ，要声明 <code>long</code> 型常量必须后加 <code>l</code> 或 <code>L</code>。</li><li>从 Java 7 开始，加上前缀 <code>0b</code> 或 <code>0B</code> 就可以写二进制数。</li><li>从 Java 7 开始，可以为数字字面添加下划线。这不会影响数字的值，只是为了方便阅读。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int n = 0b0010;</span><br><span class="line">n = 0b001;</span><br><span class="line">n = 100_0_000000;</span><br><span class="line">n = 0B0000_0010_1100;</span><br><span class="line">float f = 1.0F;JAVA</span><br></pre></td></tr></table></figure><p>如果基本的整数、浮点类型不能满足范围、精度的需求，可以使用 “大数”</p><h2 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h2><blockquote><p>可以表示一个小数</p></blockquote><ul><li><code>float</code> 单精度（6 ~ 7 位有效数字），占用 4 字节，范围约 -3.403E38 ~ 3.403E38</li><li><code>double</code> 双精度（15 位有效数字），占用 8 字节，范围约 -1.798E308 ~ 1.798E308</li></ul><p><em>浮点数在机器中存放形式为：浮点数 &#x3D; 符号位 + 指数位 + 尾数位</em></p><p><em><strong>因此，尾数部分可能丢失，造成精度损失。换言之，小数都是近似值</strong></em></p><h3 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h3><ol><li><p>与整数类型相似，有固定的范围和字符长度，不受具体 OS（操作系统）影响。</p></li><li><p>Java 默认浮点常量为 <code>double</code> ，要声明 <code>float</code> 型常量必须后加 ”f“ 或 ”F“</p></li><li><p>浮点型常量有两种表示形式</p><blockquote><p>十进制数形式：<code>5.13</code>、<code>315.4F</code>、<code>.414</code></p><p>科学计数法：<code>5.12e2</code> 即[5.12 × 102]、<code>5.12E-2</code> 即[5.12 &#x2F; 102]</p></blockquote></li><li><p>通常情况下，应该使用 <code>double</code> 类型，以其更为精确。</p></li><li><p>浮点数使用陷阱：当我们对运算结果是小数的进行相对判断时，要小心。（因为<em><strong>小数都是近似值</strong></em>）</p><p>正确方法是：<strong>以两个数差值的绝对值，在某个精度范围内判断</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (Math.abs(num1 - num2) &lt; 0.00001) &#123;</span><br><span class="line">System.out.println(&quot;插值范围内认为相等&quot;);</span><br><span class="line">&#125;JAVA</span><br></pre></td></tr></table></figure></li><li><p>特殊的浮点类型常量</p><ul><li><p>正无穷大：<code>Float.POSITIVE_INFINITY</code>、<code>Double.POSITIVE_INFINITY</code></p><p>（浮点数运算中）一个正数除以 0，会得到该值</p></li><li><p>负无穷大：<code>Float.NEGATIVE_INFINITY</code>、<code>Double.NEGATIVE_INFINITY</code></p><p>（浮点数运算中）一个负数除以 0，会得到该值</p></li><li><p>0 &#x2F; 0：<code>Float.NaN</code>、<code>Double.NaN</code></p><p>（浮点数运算中）0 除以 0，会得到该值</p></li><li><p>最大、最小值：<code>Float.MAX_VALUE</code>、<code>Double.MIN_VALUE</code></p></li></ul></li><li><p>不能用运算符来比较特殊值，而要用特别的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">double num = 0.0 / 0;</span><br><span class="line">System.out.println(num == Double.NaN);// &lt;——— 始终为 false。不能如此比较</span><br><span class="line">System.out.println(Double.isNaN(num));// &lt;——— 判断是否是 NaN</span><br><span class="line">num = 1.0 / 0;</span><br><span class="line">System.out.println(Double.isInfinite(num));// &lt;——— 是否是无穷大JAVA</span><br></pre></td></tr></table></figure></li><li><p>由于不同处理器寄存浮点数的策略可能不同，浮点数运算的结果也可能不同。</p></li></ol><h2 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h2><blockquote><p>可以表示单个字符。（可以存放一个数字，因为其字符是数字编号的。输出时会输出数字对应的字符。”编码的概念“）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char c1 = &#x27;a&#x27;;` `char c2 = &#x27;\t&#x27;;` `char c3 = &#x27;字&#x27;;` `char c4 = 99;</span><br></pre></td></tr></table></figure></blockquote><h3 id="使用细节-1"><a href="#使用细节-1" class="headerlink" title="使用细节"></a>使用细节</h3><ol><li><p>字符常量用单引号括起 ‘字’</p></li><li><p><code>char</code> 的本质是一个整数，输出时，输出的是 unicode 码对应的字符</p><p>要输出那个整数，用 <code>int</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char c1 = &#x27;a&#x27;;</span><br><span class="line">System.out.println((int)c1);JAVA</span><br></pre></td></tr></table></figure></li><li><p><code>char</code> 是可以进行运算的，其相当于一个整数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 注：(int)&#x27;a&#x27; = 97</span><br><span class="line">char c1 = &#x27;a&#x27; + 1;// 相当于 char c1 = &#x27;b&#x27;</span><br><span class="line">System.out.println(&#x27;a&#x27; + 1);// 这个代码输出 98</span><br><span class="line">System.out.println(&quot;a&quot; + 1);// 这个代码输出 a1JAVA</span><br></pre></td></tr></table></figure></li><li><p>字符允许使用转义符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char c = &#x27;\u0041&#x27;;</span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure><p><strong>转义序列 \u 能出现在引号外。所有这些转义序列会在解析代码前得到处理</strong></p><ul><li><p>以下字符串是空串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;\u0022+\u0022&quot;;</span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure><p>因为 \u0022 表示引号。该代码等同于以下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;&quot; + &quot;&quot;;</span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure></li><li><p>以下注释会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// \u000A is a newline</span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure><p>因为 \u000A 是换行符。在解析前会得到处理。在程序看来，上述注释等于以下写法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// </span><br><span class="line">is a newlineJAVA</span><br></pre></td></tr></table></figure></li><li><p>以下注释也会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// look inside c:\users</span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure><p>因为程序认为，\users 不是一个合法的转义字符</p></li><li><p>在某些场合下这种写法似乎也能实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int\u005B\u005D a;// int[] a; 一个数组</span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="字符本质与编码表"><a href="#字符本质与编码表" class="headerlink" title="字符本质与编码表"></a>字符本质与编码表</h3><ul><li><p>字符类型的本质，是把字符对应的码值编程二进制，存储。显示时将二进制代码转化为码值，找到对应的字符。</p></li><li><p>字符与码值的对应关系是字符编码表规定的。</p><blockquote><p>ASCII 编码表，占用 1 byte，共有 128 个字符。</p><p>Unicode 编码表，占用 2 byte，字母汉字都占用 2 byte，这样可能浪费空间。0 - 127 的字符与 ASCII 相同，所以兼容 ASCII。</p><p>UTF-8 编码表，根据不同符号大小可变（1 - 6 byte），字母占用 1 byte，汉字占用 3 byte。是 Unicode 的改进，是互联网上使用最广的 Unicode 实现方式。</p><p>GBK 编码表，可以表示汉字，字母占用 1 byte，汉字占用 2 byte。</p><p>GB2312 编码表，可以表示汉字（GB2312 &lt; GBK）</p><p>BIG5 编码表，可以存放繁体中文（香港，台湾）</p></blockquote></li><li><p>UTF-16 编码采用不同长度的编码表示所有 Unicode 码点。包含从 U+0000 到 U+FFFF 的经典 Unicode 代码（16位，1 个代码单元），以及 U+10000 到 U+10FFFF 的辅助字符（32位，2 个代码单元）</p></li><li><p>在 Java 中，char 类型描述的是 UTF-16 编码中的 1 个代码单元。</p><p>字符串中的一个辅助字符（如 @）可能占用 2 个代码单元。这个场合，使用 char 可能会导致错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;123&quot;;</span><br><span class="line">char c = str.charAt(1);</span><br></pre></td></tr></table></figure><p><strong>因此，一般不建议在程序中使用 char 类型</strong></p></li></ul><h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><blockquote><p><code>boolean</code> 只允许取值 <code>ture</code> 或 <code>false</code> ，没有 <code>null</code>。适用于逻辑运算，通常用于程序流程控制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if` `while` `do-while` `for</span><br></pre></td></tr></table></figure></blockquote><p><strong>使用细节：</strong></p><ol><li>不可以用 0 或 非0 的整数替代 <code>false</code> 或 <code>ture</code> 。这点和 C语言 不同。</li><li>不能让布尔类型转换为其他类型。如需转换，请使用如下方法：</li></ol><h1 id="基本数据类型转换"><a href="#基本数据类型转换" class="headerlink" title="基本数据类型转换"></a>基本数据类型转换</h1><h2 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h2><p>自动类型转换：Java 在进行赋值或运算时，精度（容量）小的类型自动转换为精度（容量）大的类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char &gt; int &gt; long &gt; float &gt; double</span><br><span class="line">byte &gt; short &gt; int &gt; long &gt; float &gt; double</span><br></pre></td></tr></table></figure><blockquote><p>例：<code>int a = &#39;c&#39;</code> 或者 <code>double b = 80</code></p></blockquote><p><strong>使用细节</strong></p><ol><li><p>有多种类型数据混合运算时，系统会将所有数据转换成容量最大的那种，再进行运算。</p></li><li><p>如若把大精度（容量）数据赋值给小精度（容量）类型，就会报错（小数由于精度原因，大赋小会丢失精度，必不可用。但整数大赋小时：1.赋予具体数值时，判断范围。2.变量赋值时，判断类型。反之进行自动类型转换。</p></li><li><p><code>byte</code> <code>short</code> <code>char</code> 三者不会相互自动转换，但可以计算。计算时首先转化为 <code>int</code>。</p><blockquote><p><code>byte a = 1;</code></p><p><code>byte b = 1;</code></p><p><code>a + b</code> 结果是 <code>int</code> 类型</p></blockquote></li><li><p><code>boolean</code> 类型不参与自动转换</p></li><li><p>自动提升原则：表达式结果的类型自动提升为操作数中最大的类型</p></li></ol><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>强制类型转换：自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时加上强制转换符 <code>( )</code> ，但<strong>可能造成精度降低或溢出</strong>，要格外注意。</p><blockquote><p>例：int a &#x3D; (int)(3 * 2.5 + 1.1 * 6);</p></blockquote><p> <strong>使用细节</strong></p><ol><li>当进行数据从大到小转换时，用强制转换。</li><li>强制转换只能对最近的操作数有效，往往会使用 <code>( )</code> 提升优先级。</li><li><code>char</code> 可以保留 <code>int</code> 的常量值，但不能保存其变量值。此时需要强制类型转换。</li><li><code>byte</code> <code>short</code> <code>char</code> 在进行运算时，当作 <code>int</code> 处理。</li></ol><h2 id="基本数据类型和-String-的转换"><a href="#基本数据类型和-String-的转换" class="headerlink" title="基本数据类型和 String 的转换"></a>基本数据类型和 <code>String</code> 的转换</h2><ol><li>基本类型转 <code>String</code>：基本数据类型加上 <code>&quot; &quot;</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int n1 = 100;</span><br><span class="line">String s = n1 + &quot;&quot;;</span><br><span class="line">System.out.println(n1 + &quot;&quot; + n1 + &quot;&quot; + n1 + &quot;&quot;);</span><br></pre></td></tr></table></figure><ol start="2"><li><code>String</code> 转基本数据类型：通过基本数据类型的包装类调用 <code>parseXX</code> 方法。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;100&quot;;</span><br><span class="line">int n1 = Interger parseInt(s);</span><br></pre></td></tr></table></figure><ol start="3"><li>特别的，把 <code>String</code> 转换为 <code>char</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char c = s.charAt(0);// 得到 s 字符串中的第一个字符。</span><br><span class="line">charAt（a）库函数，得到位序为a的字符</span><br></pre></td></tr></table></figure><h4 id="使用细节-2"><a href="#使用细节-2" class="headerlink" title="使用细节"></a>使用细节</h4><ol><li>将 <code>String</code> 转成基本数据类型时，要保证其能转换为有效数据。即不能把 <code>&quot;Hello&quot;</code> 转换成 <code>int</code>。</li><li>如果格式不正确，会抛出异常，程序会中止。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 变量 </tag>
            
            <tag> 数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-运算符、输入输出</title>
      <link href="/2022/05/17/Java%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
      <url>/2022/05/17/Java%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>运算符：一种特殊的符号，用于表示数据的运算、赋值和比较等。</p><h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><p>算术运算符是对数值类型的变量进行运算的运算符，在 Java 程序中使用得非常多。其运算结果是一个数值量。</p><ul><li><p><code>+</code> ; <code>-</code> ; <code>*</code> ; <code>/</code> ：加（正）、减（负）、乘、除</p></li><li><p><code>%</code> ：取模（求余数），结果和被取模数同号。</p></li><li><p><code>++</code> ：自增。</p><p><code>++i</code> 先自增后赋值；<code>i++</code> 先赋值后自增</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i = 10;</span><br><span class="line">int j = ++i; //等价于 i = i + 1; j = i; 此时 i = 10; j = 10`</span><br><span class="line">int k = i++; //等价于 k = i; i = i + 1; 此时 i = 11; k = 10`</span><br><span class="line">i = i++; //系统会先后执行 int temp = i;     i = i + 1;     i = temp</span><br><span class="line">i = ++i; //系统会先后执行 i = i + 1;     int temp = i;     i = tempJAVA</span><br></pre></td></tr></table></figure></li><li><p><code>--</code> ：自减。和 <code>++</code> 同理。</p></li><li><p><code>+</code> ：字符串相加，数字遇到字符串的 + 会转为字符串类型</p></li></ul><h2 id="关系运算符（比较运算符）"><a href="#关系运算符（比较运算符）" class="headerlink" title="关系运算符（比较运算符）"></a>关系运算符（比较运算符）</h2><p>关系运算符结果都为 <code>boolean</code> 型，要么是 <code>true</code> 要么是 <code>false</code>。其关系表达式经常用在 <code>if</code> 结构的条件中或循环结构的条件中。</p><ul><li><code>==</code> ：相等于。<code>8 == 7</code> 结果 <code>false</code></li><li><code>!=</code> ：不等于</li><li><code>&lt;</code> <code>&gt;</code> ：小于、大于</li><li><code>&lt;=</code> <code>&gt;=</code> ：小于等于、大于等于</li><li><code>instanceof</code> ：检查是否是类的对象。<code>&quot;a&quot; istanceof String</code> 结果 <code>true</code></li></ul><h3 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h3><ol><li>关系运算符结果都是 <code>boolean</code> 型，要么是 <code>true</code> ，要么是 <code>false</code></li><li>关系运算符的表达式，称为<em>关系表达式</em></li><li>比较运算符 <code>==</code> 不要误写为 <code>=</code></li><li>Java 允许将 <code>==</code>、<code>!=</code> 两种运算用于任何数据类型</li></ol><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>用于连接多个条件（多个关系表达式），最终的结果也是一个 <code>boolean</code> 值。</p><ul><li><p><code>&amp;&amp;</code> ：短路与。<code>a</code> <code>b</code> 同时为 <code>true</code>，则结果为 <code>true</code>，否则为 <code>false</code>。</p></li><li><p><code>&amp;</code> ：逻辑与。<code>a</code> <code>b</code> 同时为 <code>true</code>，则结果为 <code>true</code>，否则为 <code>false</code>。</p><p><code>&amp;&amp;</code> 与 <code>&amp;</code> 的区别，在于 <code>a &amp;&amp; b</code> 的场合，<code>a = false</code> 时，则 <code>b</code> 不判断。而 <code>&amp;</code> 会2个都判断。开发中多用 <code>&amp;&amp;</code> ，因为其效率更高。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">int b = 1;</span><br><span class="line"></span><br><span class="line">if (a++ &gt; 1 &amp;&amp; ++b &lt; 1) System.out.println(&quot;Nothing happened&quot;);</span><br><span class="line">/*</span><br><span class="line">此时 a 经历了先判断后自增，返回 false 并且 a = 2</span><br><span class="line">但此时 b = 1; 因为 a = false; 所以 ++b 不执行。</span><br><span class="line">*/JAVA</span><br></pre></td></tr></table></figure></li><li><p><code>||</code> ：短路或。<code>a</code> <code>b</code> 任一为 <code>true</code>，则结果为 <code>true</code>，否则为 <code>false</code>。</p></li><li><p><code>|</code> ：逻辑或。<code>a</code> <code>b</code> 任一为 <code>true</code>，则结果为 <code>true</code>，否则为 <code>false</code>。</p><blockquote><p>两者的区别和<code>&amp;&amp;</code> 与 <code>&amp;</code> 相似，若第一个为 <code>true</code> ，则 <code>||</code> 不会判断第二个。</p></blockquote></li><li><p><code>!</code> ：取反。<code>a</code> 为 <code>true</code>，则结果为 <code>false</code>。反之为 <code>true</code>。</p></li><li><p><code>^</code>：逻辑异或。<code>a</code> <code>b</code> 不同时，结果为 <code>true</code>，否则为 <code>false</code>。</p></li></ul><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><blockquote><p>将某个运算后的值，赋给指定变量</p></blockquote><ul><li><p>基本赋值运算符：<code>=</code></p></li><li><p>符合赋值运算符：<code>+=</code> ; <code>-=</code> ; <code>*=</code> ; <code>/=</code> ; <code>%=</code> 等</p><blockquote><p><code>a += b</code> 等价于 <code>a = a + b</code>。其余同理。</p></blockquote></li></ul><h3 id="使用细节-1"><a href="#使用细节-1" class="headerlink" title="使用细节"></a>使用细节</h3><ol><li><p>运算顺序从右往左。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int num = a + b + c;// 先运行(a + b + c)，再结算int num </span><br></pre></td></tr></table></figure></li><li><p>运算符左边只能是变量，右边可以是变量、表达式、常量值。</p></li><li><p>复合赋值运算符会进行类型转换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte b = 2; b += 3;// 此时 b += 3 等价于 b = (byte)(b + 3)</span><br><span class="line">b++;// 同理</span><br></pre></td></tr></table></figure></li></ol><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>基本语法：<code>条件表达式 ? 表达式1 : 表达式2;</code></p><p>运算规则：如果条件表达式为 <code>ture</code> ，运算的结果是表达式1；反之为表达式2。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">int b = 11;</span><br><span class="line">int result = (a == b ? a++ : b++);// 此时 a = 10  result = 11  b = 12</span><br></pre></td></tr></table></figure><h3 id="使用细节-2"><a href="#使用细节-2" class="headerlink" title="使用细节"></a>使用细节</h3><ol><li>表达式1 和 表达式2 要为可以赋给接受变量的类型（或可以自动转换，或进行强制转换）</li><li>三元运算符可以转成 <code>if--else</code></li><li>三元运算符是一个整体。</li></ol><blockquote><p>例： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj = true ? new Integer(1) : new Double(2.2);</span><br><span class="line">System.out.print(obj)</span><br></pre></td></tr></table></figure><p>系统将会输出 <code>1.0</code>，因为 三元运算符 是一个整体，所以 发生了类型转换</p></blockquote><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><table><thead><tr><th>运算符（优先级从高到低）</th><th>结核性</th></tr></thead><tbody><tr><td><code>[]</code>、<code>()</code> 方法调用</td><td>从左向右</td></tr><tr><td><code>!</code>、<code>~</code>、<code>++</code>、<code>--</code>、<code>+</code>（一元运算）、<code>-</code>（一元运算）、强制类型转换、new</td><td>从右向左</td></tr><tr><td><code>*</code>、<code>/</code>、<code>%</code></td><td>从左向右</td></tr><tr><td><code>+</code>、<code>-</code></td><td>从左向右</td></tr><tr><td><code>&lt;&lt;</code>、<code>&gt;&gt;</code>、<code>&gt;&gt;&gt;</code></td><td>从左向右</td></tr><tr><td><code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code>、instanceof</td><td>从左向右</td></tr><tr><td><code>==</code>、<code>!=</code></td><td>从左向右</td></tr><tr><td><code>&amp;</code></td><td>从左向右</td></tr><tr><td><code>^</code></td><td>从左向右</td></tr><tr><td><code>&amp;&amp;</code></td><td>从左向右</td></tr><tr><td><code>?:</code>（三元运算符）</td><td>从右向左</td></tr><tr><td><code>=</code>、<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>&amp;=</code>、<code>%=</code>、<code>^=</code>、&#96;</td><td>&#x3D;<code>、</code>&lt;&lt;&#x3D;<code>、</code>&gt;&gt;&#x3D;<code>、</code>&gt;&gt;&gt;&#x3D;&#96;</td></tr></tbody></table><ol><li>运算符有不同优先级。优先级高的总是优先于低的。</li><li>只有单目运算符、赋值运算符是从右向左运算的。</li></ol><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>Java 对各种变量、方法和类等命名时使用的字符序列称为标识符，凡是自己可以起名字的地方都叫标识符 </p><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><ol><li>标识符由 26 个大、小写英文字母，0 - 9 阿拉伯数字，_ 或 $ 符号组成。</li><li><strong>数字不能开头</strong>。</li><li>不能是关键字和保留字。</li><li>严格区分大小写，长度无限制。</li><li>不能包含空格。</li><li>与多数编程语言不同。Java 可以用任何 Unicode 字符（特殊字符除外）作为标识符，包括中文。但不推荐这么做。</li></ol><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><ol><li>包名：多单词组成时所有字母都小写：aaa.bbb.ccc</li><li>类名、接口名：多单词组成时，采用大驼峰法，所有单词的首字母大写：XxxYyyZzz</li><li>变量名、方法名：多单词组成时，采小驼峰法（驼峰法），第一个单词首字母小写，第二个开始每个单词首字母大写：xxxYyyZzz</li><li>常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ</li></ol><h1 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h1><p>为满足读取用户输入、输出的需求，Java 提供了几个基本类，通过 util 包导入</p><h3 id="输入-x2F-Scanner-类"><a href="#输入-x2F-Scanner-类" class="headerlink" title="输入&#x2F;Scanner 类"></a>输入&#x2F;Scanner 类</h3><p>在编程中，需要接收用户输入的数据，就可以使用键盘输入语句来获取。<code>Input.java</code> ，需要一个 扫描器（对象），就是 Scanner</p><p>使用过程：</p><ol><li>导入该类所在的包 import java.util.Scanner;</li><li>创建该类对象（声明变量）Scanner scanner &#x3D; new Scanner(System.in);</li><li>调用里面的功能，接收用户输入</li></ol><p>构造方法：</p><ul><li><code>new Scanner(System.in)</code>：该方法接收一个参数（输入源）。其中 <code>System.in</code> 代表标准输入流。默认情况指键盘。</li></ul><p>常用方法：</p><ul><li><p><code>String next()</code>：读取下一个输入对象</p><p>Scanner 对象用空白（空格、水平制表符或回车换行符）作为输入的分隔元素</p></li><li><p><code>Double nextDouble()</code>：读取下一个 double</p><p><code>Int nextInt()</code>：读取下一个 int</p></li><li><p><code>String nextLine()</code>：读入当前行的所有输入，直到行尾</p></li><li><p><code>boolean hasNext()</code>：输入中是否还有其他单词</p><p><code>boolean hasNextInt()</code>、<code>boolean hasNextDouble()</code></p></li></ul><h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><blockquote><p>System.out 标准输出流。调用该流方法以输出内容至控制台窗口</p></blockquote><ul><li><code>println()</code>：输出字符，结束后换行</li><li><code>print()</code>：输出字符，结束后不换行</li><li><code>printf(String format, Object ... args)</code>：格式化输出</li></ul><p>以 % 开头的 <em>格式说明符</em> 都用相应参数替换。格式说明符尾部的转换符表示要格式化的数值类型</p><table><thead><tr><th>转换符</th><th>类型</th><th>转换符</th><th>类型</th></tr></thead><tbody><tr><td>%d</td><td>十进制整数</td><td>%s</td><td>字符串</td></tr><tr><td>%x</td><td>十六进制整数</td><td>%c</td><td>字符</td></tr><tr><td>%o</td><td>八进制整数</td><td>%b</td><td>布尔值</td></tr><tr><td>%f</td><td>定点浮点数</td><td>%h</td><td>散列码</td></tr><tr><td>%e</td><td>指数浮点数</td><td>%tx</td><td>日期时间（T强制大写）</td></tr><tr><td>%g</td><td>通用浮点数</td><td>%%</td><td>百分号</td></tr><tr><td>%a</td><td>十六进制浮点数</td><td>%n</td><td>行分隔符</td></tr></tbody></table><p>也能指定控制格式化输出外观的各种标志</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 运算符 </tag>
            
            <tag> 输入输出 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java集合</title>
      <link href="/2023/10/26/Java%E9%9B%86%E5%90%88/"/>
      <url>/2023/10/26/Java%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h1><h1 id="集合框架体系"><a href="#集合框架体系" class="headerlink" title="集合框架体系"></a>集合框架体系</h1><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310100902114.png"></p><blockquote><p>集合主要是两组(单列集合，双列集合)<br>Collection接口有两个重要的子接口List Set，他们的实现子类都是单列集合<br>Map接口的实现子类是双列集合，存放的K-V</p></blockquote><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310100903447.png"></p><p><strong>Collection 接口</strong>（单列集合）：可以存放多个元素。每个元素可以是 ObjectCollection 接口有两个重要子接口：List（有序集合）和 Set（无序集合）</p><p><strong>Map 接口</strong>（双列集合）：用于保存具有映射关系的数据：key - value（双列元素）key 和 value 可以是任何类型的引用数据类型。其中 key 不能重复，value 可以重复。key 和 value 存在单一对应关系。通过特定的 key 一定能找到指定的 value</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">单列集合</span><br><span class="line">ArrayList arrayList = new ArrayList();</span><br><span class="line">arrayList.add(&quot;jack&quot;);</span><br><span class="line">arrayList.add(&quot;tom&quot;);</span><br><span class="line"></span><br><span class="line">双列集合</span><br><span class="line">HashMap hashMap = new HashMap();</span><br><span class="line">hashMap.put(&quot;NO1&quot;, &quot;北京&quot;);</span><br><span class="line">hashMap.put(&quot;NO2&quot;, &quot;上海&quot;);</span><br></pre></td></tr></table></figure><h1 id="Collection-接口和常用方法"><a href="#Collection-接口和常用方法" class="headerlink" title="Collection 接口和常用方法"></a>Collection 接口和常用方法</h1><h2 id="单列集合接口-Collection"><a href="#单列集合接口-Collection" class="headerlink" title="单列集合接口 Collection"></a>单列集合接口 Collection</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public interface Collection&lt;E&gt; extends Lterable&lt;E&gt;</span><br></pre></td></tr></table></figure><p>Collection 实现子类可以存放多个元素。每个元素可以是 Object</p><p>有些 Collection 实现子类能存放重复的元素，有些不能</p><p>有些 Collection 实现子类是有序的（List） ，有些不是（Set）</p><p>Collection 接口没有直接的实现子类，都是通过其子接口实现的</p><h2 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h2><ul><li><p><code>add</code>：添加单个元素</p></li><li><p><code>remove</code>：删除单个元素</p></li><li><p><code>contains</code>：检查元素是否存在</p></li><li><p><code>size</code>：获取元素个数</p></li><li><p><code>isEmpty</code>：判断是否为空</p></li><li><p><code>clear</code>：清空</p></li><li><p><code>addAll</code>：添加多个元素</p></li><li><p><code>containsAll</code>：检查多个元素是否存在</p></li><li><p><code>removeAll</code>：删除多个元素</p></li><li><p><code>Iterator iterator()</code>：返回指向集合开始位置的迭代器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// add:添加单个元素</span><br><span class="line">list.add(&quot;jack&quot;);</span><br><span class="line">list.add(10);//list.add(new Integer(10))</span><br><span class="line">list.add(true);</span><br><span class="line">System.out.println(&quot;list=&quot; + list);</span><br><span class="line"></span><br><span class="line">// remove:删除指定元素</span><br><span class="line">//list.remove(0);//删除第一个元素</span><br><span class="line">list.remove(true);//指定删除某个元素</span><br><span class="line">System.out.println(&quot;list=&quot; + list);</span><br><span class="line"></span><br><span class="line">// contains:查找元素是否存在</span><br><span class="line">System.out.println(list.contains(&quot;jack&quot;));//T</span><br><span class="line"></span><br><span class="line">// size:获取元素个数</span><br><span class="line">System.out.println(list.size());//2</span><br><span class="line"></span><br><span class="line">// isEmpty:判断是否为空</span><br><span class="line">System.out.println(list.isEmpty());//F</span><br><span class="line"></span><br><span class="line">// clear:清空</span><br><span class="line">list.clear();</span><br><span class="line">System.out.println(&quot;list=&quot; + list);</span><br><span class="line"></span><br><span class="line">// addAll:添加多个元素</span><br><span class="line">ArrayList list2 = new ArrayList();</span><br><span class="line">list2.add(&quot;红楼梦&quot;);</span><br><span class="line">list2.add(&quot;三国演义&quot;);</span><br><span class="line">list.addAll(list2);</span><br><span class="line">System.out.println(&quot;list=&quot; + list);</span><br><span class="line"></span><br><span class="line">// containsAll:查找多个元素是否都存在</span><br><span class="line">System.out.println(list.containsAll(list2));//T</span><br><span class="line"></span><br><span class="line">// removeAll：删除多个元素</span><br><span class="line">list.add(&quot;聊斋&quot;);</span><br><span class="line">list.removeAll(list2);</span><br><span class="line">System.out.println(&quot;list=&quot; + list);//[聊斋]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="迭代器-Iterator"><a href="#迭代器-Iterator" class="headerlink" title="迭代器 Iterator"></a>迭代器 Iterator</h3><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310100902114.png"></p><p>Iterator 对象称为迭代器，主要用于遍历 Collection 集合中的元素。</p><p>Collection 继承的 Iterable （最上面那个）接口中，提供了 <code>iterator()</code> 方法，会返回一个新的迭代器。</p><p>Iterator 对象仅用于遍历集合，本身不存放元素</p><blockquote><p>IDEA 中，迭代器 while 循环的模板快捷键：<code>itit</code></p></blockquote><p><strong>常用方法：</strong></p><ul><li><code>boolean hasNext()</code>：该方法判断是否有下一个元素。</li><li><code>T next()</code>：该方法会将指针下移，然后返回下移后的位置上的元素</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310100950317.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310100951606.png"></p><p><strong>用迭代器遍历元素：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;Object&gt; c = new LinkedList&lt;&gt;();</span><br><span class="line">Iterator&lt;Object&gt; iterator = c.iterator();// [1]</span><br><span class="line">while (iterator.hasNext())&#123;// [2]</span><br><span class="line">Object obj = iterator.next();// [3]</span><br><span class="line">System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>获取迭代器</p></li><li><p>判断有无下一元素</p></li><li><p>将迭代器后移，并返回那个后移位置上的元素</p><p>while 循环结束后，指针指向最后元素的位置。再次 <code>next()</code> 会报错。如果需要再使用，需要重置迭代器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iterator = list.iterator();// 重置了迭代器</span><br></pre></td></tr></table></figure></li></ol><p>例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class CollectionIterator &#123;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;all&quot;&#125;)</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Collection col = new ArrayList();</span><br><span class="line"></span><br><span class="line">        col.add(new Book(&quot;三国演义&quot;, &quot;罗贯中&quot;, 10.1));</span><br><span class="line">        col.add(new Book(&quot;小李飞刀&quot;, &quot;古龙&quot;, 5.1));</span><br><span class="line">        col.add(new Book(&quot;红楼梦&quot;, &quot;曹雪芹&quot;, 34.6));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //System.out.println(&quot;col=&quot; + col);</span><br><span class="line">        //现在老师希望能够遍历 col集合</span><br><span class="line">        //1. 先得到 col 对应的 迭代器</span><br><span class="line">        Iterator iterator = col.iterator();</span><br><span class="line">        //2. 使用while循环遍历</span><br><span class="line">//        while (iterator.hasNext()) &#123;//判断是否还有数据</span><br><span class="line">//            //返回下一个元素，类型是Object</span><br><span class="line">//            Object obj = iterator.next();</span><br><span class="line">//            System.out.println(&quot;obj=&quot; + obj);</span><br><span class="line">//        &#125;</span><br><span class="line">        //老师教大家一个快捷键，快速生成 while =&gt; itit</span><br><span class="line">        //显示所有的快捷键的的快捷键 ctrl + j</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            Object obj = iterator.next();</span><br><span class="line">            System.out.println(&quot;obj=&quot; + obj);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        //3. 当退出while循环后 , 这时iterator迭代器，指向最后的元素</span><br><span class="line">        //   iterator.next();//NoSuchElementException</span><br><span class="line">        //4. 如果希望再次遍历，需要重置我们的迭代器</span><br><span class="line">        iterator = col.iterator();</span><br><span class="line">        System.out.println(&quot;===第二次遍历===&quot;);</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            Object obj = iterator.next();</span><br><span class="line">            System.out.println(&quot;obj=&quot; + obj);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Book &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private String author;</span><br><span class="line">    private double price;</span><br><span class="line"></span><br><span class="line">    public Book(String name, String author, double price) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.author = author;</span><br><span class="line">        this.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getAuthor() &#123;</span><br><span class="line">        return author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAuthor(String author) &#123;</span><br><span class="line">        this.author = author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double getPrice() &#123;</span><br><span class="line">        return price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPrice(double price) &#123;</span><br><span class="line">        this.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Book&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, author=&#x27;&quot; + author + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, price=&quot; + price +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="for-each（增强-for-循环）"><a href="#for-each（增强-for-循环）" class="headerlink" title="for each（增强 for 循环）"></a><strong>for each（增强 for 循环）</strong></h3><p>for each 的语法与 for 循环相似，但是可以遍历 Collection 和 数组 中的元素</p><blockquote><p>IDEA 中，增强 for 循环的模板快捷键：<code>I</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (Object o : list)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>for each 可在 Collection 集合中使用。</li><li>for each 的底层在本质上也是 <code>Iterator</code>。可以理解为简化版本的迭代器遍历</li></ul><p>例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class CollectionFor &#123;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;all&quot;&#125;)</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Collection col = new ArrayList();</span><br><span class="line"></span><br><span class="line">        col.add(new Book(&quot;三国演义&quot;, &quot;罗贯中&quot;, 10.1));</span><br><span class="line">        col.add(new Book(&quot;小李飞刀&quot;, &quot;古龙&quot;, 5.1));</span><br><span class="line">        col.add(new Book(&quot;红楼梦&quot;, &quot;曹雪芹&quot;, 34.6));</span><br><span class="line"></span><br><span class="line">        //老韩解读</span><br><span class="line">        //1. 使用增强for, 在Collection集合</span><br><span class="line">        //2. 增强for， 底层仍然是迭代器</span><br><span class="line">        //3. 增强for可以理解成就是简化版本的 迭代器遍历</span><br><span class="line">        //4. 快捷键方式 I</span><br><span class="line">//        for (Object book : col) &#123;</span><br><span class="line">//            System.out.println(&quot;book=&quot; + book);</span><br><span class="line">//        &#125;</span><br><span class="line">        for (Object o : col) &#123;</span><br><span class="line">            System.out.println(&quot;book=&quot; + o);</span><br><span class="line">        &#125;</span><br><span class="line">        //增强for，也可以直接在数组使用</span><br><span class="line">//        int[] nums = &#123;1, 8, 10, 90&#125;;</span><br><span class="line">//        for (int i : nums) &#123;</span><br><span class="line">//            System.out.println(&quot;i=&quot; + i);</span><br><span class="line">//        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="课堂练习"><a href="#课堂练习" class="headerlink" title="课堂练习"></a>课堂练习</h3><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310100959431.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">public class CollectionExercise &#123;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;all&quot;&#125;)</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List list = new ArrayList();</span><br><span class="line">        list.add(new Dog(&quot;小黑&quot;, 3));</span><br><span class="line">        list.add(new Dog(&quot;大黄&quot;, 100));</span><br><span class="line">        list.add(new Dog(&quot;大壮&quot;, 8));</span><br><span class="line"></span><br><span class="line">        //先使用for增强</span><br><span class="line">        for (Object dog : list) &#123;</span><br><span class="line">            System.out.println(&quot;dog=&quot; + dog);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //使用迭代器</span><br><span class="line">        System.out.println(&quot;===使用迭代器来遍历===&quot;);</span><br><span class="line">        Iterator iterator = list.iterator();</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            Object dog =  iterator.next();</span><br><span class="line">            System.out.println(&quot;dog=&quot; + dog);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 创建  3个 Dog &#123;name, age&#125;  对象，放入到 ArrayList 中，赋给 List 引用</span><br><span class="line"> * 用迭代器和增强for循环两种方式来遍历</span><br><span class="line"> * 重写Dog 的toString方法， 输出name和age</span><br><span class="line"> */</span><br><span class="line">class Dog &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public Dog(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Dog&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="有序集合接口-List"><a href="#有序集合接口-List" class="headerlink" title="有序集合接口 List"></a>有序集合接口 List</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public interface List&lt;E&gt; extends Collection&lt;E&gt;</span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure><p>List 是 Collection 接口的子类接口</p><p>List中元素是有序（添加顺序和取出顺序一致）的，可重复的</p><p>List 中的每个元素都有其对应的顺序索引（从 0 开始编号）</p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><ul><li><p><code>add(int, obj)</code>：在 int 位置插入 obj 元素。返回 true</p><p><code>add(obj)</code>：在末尾插入 obj。返回 true</p><p><code>addElement(obj)</code>：在末尾插入 obj。无返回值。你说要这方法有啥用？名字还长一截</p></li><li><p><code>addAll(int, collection)</code>：在 int 位置插入 collection 中的所有元素</p></li><li><p><code>get(int)</code>：返回 int 位置的元素</p></li><li><p><code>indexOf(obj)</code>：返回 obj 首次出现时的位置</p></li><li><p><code>lastIndexOf(obj)</code>：返回 obj 最后一次出现时的位置</p></li><li><p><code>remove(int)</code>：移除 int 位置的元素，并返回那个被移除的元素</p></li><li><p><code>set(int, obj)</code>：设置 int 位置的元素为 obj。相当于替换。返回那个被替换元素的下标</p><p><code>setElement(obj, int)</code>：设置 int 位置的元素为 obj。无返回值</p></li><li><p><code>subList(int1, int2)</code>：返回 [int1, int2) 范围的元素构成的子集合</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        List list = new ArrayList();</span><br><span class="line">        list.add(&quot;张三丰&quot;);</span><br><span class="line">        list.add(&quot;贾宝玉&quot;);</span><br><span class="line">        </span><br><span class="line">//      void add(int index, Object ele):在index位置插入ele元素</span><br><span class="line">        //在index = 1的位置插入一个对象</span><br><span class="line">        list.add(1, &quot;韩顺平&quot;);</span><br><span class="line">        System.out.println(&quot;list=&quot; + list);</span><br><span class="line">        </span><br><span class="line">//      boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来</span><br><span class="line">        List list2 = new ArrayList();</span><br><span class="line">        list2.add(&quot;jack&quot;);</span><br><span class="line">        list2.add(&quot;tom&quot;);</span><br><span class="line">        list.addAll(1, list2);</span><br><span class="line">        System.out.println(&quot;list=&quot; + list);</span><br><span class="line">        </span><br><span class="line">//      Object get(int index):获取指定index位置的元素</span><br><span class="line">       </span><br><span class="line">        </span><br><span class="line">//      int indexOf(Object obj):返回obj在集合中首次出现的位置</span><br><span class="line">        System.out.println(list.indexOf(&quot;tom&quot;));//2</span><br><span class="line">        </span><br><span class="line">//      int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置</span><br><span class="line">        list.add(&quot;韩顺平&quot;);</span><br><span class="line">        System.out.println(&quot;list=&quot; + list);</span><br><span class="line">        System.out.println(list.lastIndexOf(&quot;韩顺平&quot;));</span><br><span class="line">        </span><br><span class="line">//      Object remove(int index):移除指定index位置的元素，并返回此元素</span><br><span class="line">        list.remove(0);</span><br><span class="line">        System.out.println(&quot;list=&quot; + list);</span><br><span class="line">        </span><br><span class="line">//      Object set(int index, Object ele):设置指定index位置的元素为ele , 相当于是替换.</span><br><span class="line">        list.set(1, &quot;玛丽&quot;);</span><br><span class="line">        System.out.println(&quot;list=&quot; + list);</span><br><span class="line">        </span><br><span class="line">//      List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合</span><br><span class="line">        // 注意返回的子集合 fromIndex &lt;= subList &lt; toIndex</span><br><span class="line">        List returnlist = list.subList(0, 2);</span><br><span class="line">        System.out.println(&quot;returnlist=&quot; + returnlist);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="List-的三种遍历方式"><a href="#List-的三种遍历方式" class="headerlink" title="List 的三种遍历方式"></a>List 的三种遍历方式</h2><p> ArrayList，LinkedList，Vector三者通用</p><ol><li>迭代器</li><li>foreach</li><li>普通for</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    //List 接口的实现子类 Vector LinkedList</span><br><span class="line">    //List list = new ArrayList();</span><br><span class="line">    //List list = new Vector();</span><br><span class="line">    List list = new LinkedList();</span><br><span class="line"></span><br><span class="line">    list.add(&quot;jack&quot;);</span><br><span class="line">    list.add(&quot;tom&quot;);</span><br><span class="line">    list.add(&quot;鱼香肉丝&quot;);</span><br><span class="line">    list.add(&quot;北京烤鸭子&quot;);</span><br><span class="line"></span><br><span class="line">    //遍历</span><br><span class="line">    //1. 迭代器</span><br><span class="line">    Iterator iterator = list.iterator();</span><br><span class="line">    while (iterator.hasNext()) &#123;</span><br><span class="line">        Object obj =  iterator.next();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;=====增强for=====&quot;);</span><br><span class="line">    //2. 增强for</span><br><span class="line">    for (Object o : list) &#123;</span><br><span class="line">        System.out.println(&quot;o=&quot; + o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;=====普通for====&quot;);</span><br><span class="line">    //3. 使用普通for</span><br><span class="line">    for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">        System.out.println(&quot;对象=&quot; + list.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>练习：</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310101044489.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class ListExercise02 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //List list = new ArrayList();</span><br><span class="line">        List list = new LinkedList();</span><br><span class="line">        //List list = new Vector();</span><br><span class="line">        list.add(new Book(&quot;红楼梦&quot;, &quot;曹雪芹&quot;, 100));</span><br><span class="line">        list.add(new Book(&quot;西游记&quot;, &quot;吴承恩&quot;, 10));</span><br><span class="line">        list.add(new Book(&quot;水浒传&quot;, &quot;施耐庵&quot;, 19));</span><br><span class="line">        list.add(new Book(&quot;三国&quot;, &quot;罗贯中&quot;, 80));</span><br><span class="line">        //list.add(new Book(&quot;西游记&quot;, &quot;吴承恩&quot;, 10));</span><br><span class="line">        //如何对集合进行排序</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //遍历</span><br><span class="line">        for (Object o : list) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //冒泡排序</span><br><span class="line">        sort(list);</span><br><span class="line">        System.out.println(&quot;==排序后==&quot;);</span><br><span class="line">        for (Object o : list) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //静态方法</span><br><span class="line">    //价格要求是从小到大</span><br><span class="line">    public static void sort(List list) &#123;</span><br><span class="line"></span><br><span class="line">        int listSize = list.size();</span><br><span class="line">        for (int i = 0; i &lt; listSize - 1; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; listSize - 1 - i; j++) &#123;</span><br><span class="line">                //取出对象Book</span><br><span class="line">                Book book1 = (Book) list.get(j);</span><br><span class="line">                Book book2 = (Book) list.get(j + 1);</span><br><span class="line">                if (book1.getPrice() &gt; book2.getPrice()) &#123;//交换</span><br><span class="line">                    list.set(j, book2);</span><br><span class="line">                    list.set(j + 1, book1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class ListExercise02 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        //List list = new ArrayList();</span><br><span class="line">        List list = new LinkedList();</span><br><span class="line">        //List list = new Vector();</span><br><span class="line">        list.add(new Book(&quot;红楼梦&quot;, &quot;曹雪芹&quot;, 100));</span><br><span class="line">        list.add(new Book(&quot;西游记&quot;, &quot;吴承恩&quot;, 10));</span><br><span class="line">        list.add(new Book(&quot;水浒传&quot;, &quot;施耐庵&quot;, 19));</span><br><span class="line">        list.add(new Book(&quot;三国&quot;, &quot;罗贯中&quot;, 80));</span><br><span class="line">        //list.add(new Book(&quot;西游记&quot;, &quot;吴承恩&quot;, 10));</span><br><span class="line"></span><br><span class="line">        //如何对集合进行排序</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //遍历</span><br><span class="line"></span><br><span class="line">        for (Object o : list) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //冒泡排序</span><br><span class="line">        sort(list);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;==排序后==&quot;);</span><br><span class="line"></span><br><span class="line">        for (Object o : list) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //静态方法</span><br><span class="line">    //价格要求是从小到大</span><br><span class="line">    public static void sort(List list) &#123;</span><br><span class="line"></span><br><span class="line">        int listSize = list.size();</span><br><span class="line">        for (int i = 0; i &lt; listSize - 1; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; listSize - 1 - i; j++) &#123;</span><br><span class="line">                //取出对象Book</span><br><span class="line">                Book book1 = (Book) list.get(j);</span><br><span class="line">                Book book2 = (Book) list.get(j + 1);</span><br><span class="line">                if (book1.getPrice() &gt; book2.getPrice()) &#123;//交换</span><br><span class="line">                    list.set(j, book2);</span><br><span class="line">                    list.set(j + 1, book1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可变数组-ArrayList"><a href="#可变数组-ArrayList" class="headerlink" title="可变数组 ArrayList"></a>可变数组 ArrayList</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;</span><br><span class="line">     implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><p>ArrayList 是 List 的实现子类。其底层由数组来实现存储。ArrayList 可以存放 null</p><h3 id="ArrayList-的源码"><a href="#ArrayList-的源码" class="headerlink" title="ArrayList 的源码"></a>ArrayList 的源码</h3><p>结论：</p><ol><li><p>ArrayList 中维护了一个 Object 类型的数组 elementData。该数组就是用来存放元素的数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient Object[] elementData;</span><br></pre></td></tr></table></figure><blockquote><p>transient 表示瞬间,短暂的，表示该属性不会被序列化</p></blockquote></li><li><p>创建 ArrayList 对象时，如果使用无参构造器，则 elementData[] 初始容量为 0</p></li><li><p>如果使用指定大小构造器，则初始容量为指定大小。</p></li><li><p>扩容的场合：</p><p>如果是 <strong>无参构造器生成的初始 0 长度的 elementData</strong>，则将其容量置为 10。</p><p>否则容量扩容为 1.5 倍。</p></li></ol><h3 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h3><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310101139825.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310101140986.png"></p><h2 id="可变数组-Vector"><a href="#可变数组-Vector" class="headerlink" title="可变数组 Vector"></a>可变数组 Vector</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Vector&lt;E&gt;</span><br><span class="line">    extends AbstractList&lt;E&gt;</span><br><span class="line">    implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><p>Vector 是 List 的实现子类。其底层由<strong>数组</strong>来实现存储，但是线程安全。</p><blockquote><p>Vector 与 ArrayList 基本等同。ArrayList 效率更高，Vector 线程安全。</p><p>在开发中，需要考虑线程安全时，建议使用 Vector ，而非 ArrayList</p></blockquote><h3 id="Vector-的源码"><a href="#Vector-的源码" class="headerlink" title="Vector 的源码"></a>Vector 的源码</h3><ol><li><p>底层维护了一个 Object 类型的数组 elementData。用以存放元素</p></li><li><p>使用无参构造器创建对象时，默认大小是 10</p><p>使用有参构造器的场合，默认是那个指定大小（initialCapaticy）</p><p>也能在构造器中指定那个扩容的增长速度（capacityIncrement）</p></li><li><p>扩容的场合，容量变成 2 倍</p><p>使用有参构造器改变了 capacityIncrement 的场合，增量是那个指定数值</p></li></ol><h3 id="ArrayList-和Vector-的比较"><a href="#ArrayList-和Vector-的比较" class="headerlink" title="ArrayList 和Vector 的比较"></a>ArrayList 和Vector 的比较</h3><table><thead><tr><th></th><th>底层结构</th><th>版本</th><th>线程安全(同步)效率</th><th>扩容倍数</th></tr></thead><tbody><tr><td>ArrayList</td><td>可变数组</td><td>jdk1.2出现</td><td>不安全，效率高</td><td>如果有参构造1.5倍<br>如果是无参，第一次10，后面1.5倍扩容</td></tr><tr><td>Vector</td><td>可变数组 Object[ ]</td><td>jdk1.0出现</td><td>安全，效率不高</td><td>如果是无参，默认10，后面2倍扩容<br>如果是无参，初始大小就是参数，后面2倍扩容</td></tr></tbody></table><h2 id="链表-LinkedList"><a href="#链表-LinkedList" class="headerlink" title="链表 LinkedList"></a>链表 LinkedList</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedList&lt;E&gt;</span><br><span class="line">    extends AbstractSequentialList&lt;E&gt;</span><br><span class="line">    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><p>在 Java 中，LinkedList 是 List 的实现子类，底层以<strong>双向非环链表</strong>形式存储元素。</p><p>链表是一种<strong>非线性结构</strong>：其以节点方式存储，节点间在内存上的位置不连续。</p><p>LinkedList 底层实现了 双向链表 和 双端队列 特点。在 Java 中，LinkedList 也实现了 Deque 接口。</p><p>LinkedList 可以添加 null，可添加重复元素。但没有实现同步，因此线程不安全。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310102139766.png"></p><h3 id="常用方法：-1"><a href="#常用方法：-1" class="headerlink" title="常用方法："></a>常用方法：</h3><p><code>void addLast(E e)</code>：尾插一个新的元素，LinkedList 的 add 方法即调用该方法</p><p><code>void addFirst(E e)</code>：头插一个新的元素</p><p><code>E removeLast()</code>：移除并返回尾部元素。为空时报错</p><p><code>E poll()</code>：移除并返回尾部元素。为空时返回 null</p><p><code>E removeFirst()</code>：移除并返回头部元素。为空时报错</p><p><code>E getLast()</code>：仅返回尾部元素。为空时报错</p><p><code>E peek()</code>：返回尾部元素。为空时返回 null</p><p><code>E element()</code>：返回头部元素。为空时返回 null</p><p><code>E getFirst()</code></p><h3 id="LinkedList-的源码"><a href="#LinkedList-的源码" class="headerlink" title="LinkedList 的源码"></a>LinkedList 的源码</h3><ol><li><p>LinkedList 只有默认构造器和一个拷贝构造器</p></li><li><p>LinkedList 底层维护了一个 双向链表</p><p>每个节点（Node 对象）有 prev、next、item 属性。</p><p>其中 item 用来存放数据。</p><p>其中通过 prev 指向前一个节点，通过 next 指向后一个节点。最终实现双向链表。</p></li><li><p>LinkedList 不需要扩容。其增删元素时只要改变节点的指向即可。</p><p>也因此，其添加、删除元素效率比数组更高</p></li></ol><h2 id="ArrayList-x2F-Vector-和-LinkedList-的比较："><a href="#ArrayList-x2F-Vector-和-LinkedList-的比较：" class="headerlink" title="ArrayList&#x2F;Vector 和 LinkedList 的比较："></a>ArrayList&#x2F;Vector 和 LinkedList 的比较：</h2><table><thead><tr><th></th><th>底层结构</th><th>增删效率</th><th>改查效率</th></tr></thead><tbody><tr><td>ArrayList &#x2F; Vector</td><td>可变数组</td><td>低（数组扩容）</td><td>高</td></tr><tr><td><code>LinkedList</code></td><td>双向链表</td><td>高（链表追加）</td><td>低</td></tr></tbody></table><p>如何选择ArrayList和LinkedList：</p><ol><li>如果我们改查的操作多，选择ArrayList</li><li>如果我们增删的操作多，选择LinkedList</li><li>一般来说，在程序中，80%-90%都是查询，因此大部分情况下会选择ArrayList</li><li>在一个项目中，根据业务灵活选择，也可能这样，一个模块使用的是ArrayList,另外一个模块是LinkedList,也就是说，要根据业务来进行选择</li></ol><h1 id="无序集合接口-Set"><a href="#无序集合接口-Set" class="headerlink" title="无序集合接口 Set"></a>无序集合接口 Set</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public interface Set&lt;E&gt; extends Collection&lt;E&gt;</span><br></pre></td></tr></table></figure><p>Set 是 Collection 接口的子类接口。常用方法和 Collection 接口一样</p><p>Set 接口的特点是无序，没有索引，不允许重复元素。最多包含一个 null</p><h2 id="Set-接口的遍历方式"><a href="#Set-接口的遍历方式" class="headerlink" title="Set 接口的遍历方式"></a>Set 接口的遍历方式</h2><p>set 接口对象存放数据是无序(即添加的顺序和取出的顺序不一致)。</p><p>可以使用迭代器和foreach，但是用不了普通for循环（没有索引）</p><blockquote><p>取出的顺序的顺序虽然不是添加的顺序，但是顺序固定</p></blockquote><h2 id="HashSet接口实现类"><a href="#HashSet接口实现类" class="headerlink" title="HashSet接口实现类"></a>HashSet接口实现类</h2><ol><li><p>HashSet实现了Set接口</p></li><li><p>HashSet实际上是HashMap，</p></li><li><p>可以存放null值，但是只能有一个null</p></li><li><p>HashSet不保证元素是有序的，取决于hash后，再确定索引的结果</p><blockquote><p>不保证存放元素的顺序和取出顺序致</p></blockquote></li><li><p>不能有重复元素&#x2F;对象</p><blockquote><p>Set共同特点</p></blockquote></li></ol><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedHashSet&lt;E&gt;</span><br><span class="line">    extends HashSet&lt;E&gt;</span><br><span class="line">    implements Set&lt;E&gt;, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><p>LinkedHashSet 是 HashSet 的子类</p><p>LinkedHashSet 底层是一个 LinkedHashMap，维护了一个数组 + 双向链表。~~~~</p><p>LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置。同时，使用链表维护元素的次序。这使得元素看起来是以插入顺序保存的，并得以按照放入顺序取出</p><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310121000041.png"></p><p>Map接口实现类的特点：这里讲的是JDK8的Map接口特点</p><ol><li><p>用于保存具有映射关系的数据:Key-Value（键值对）</p></li><li><p>Map中的key和value 可以是任何引用类型的数据，会封装到HashMap$Node<br>  对象中</p></li><li><p>Map中的key不允许重复，原因和HashSet 一样，前面分析过源码。</p><blockquote><p>当有相同的k，就等价于替换，</p></blockquote></li><li><p>Map中的value可以重复</p></li><li><p>Map的key可以为nul, value也可以为null ,注意key为nul,只能有一个，<br>  value为null ,可以多个</p></li><li><p>常用String类作为Map的key，但是不是只有字符串才能做key</p><blockquote><p>put方法中key的类型是Object，啥都能接受</p></blockquote></li><li><p>key和value之间存在单向一对一关系，即通过指定的key总能找到对应的value</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Map_ &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //1. 用于保存具有映射关系的数据:Key-Value(双列元素)</span><br><span class="line">        //2. Map 中的 key 和  value 可以是任何引用类型的数据，会封装到HashMap$Node 对象中</span><br><span class="line">        //3. Map 中的 key 不允许重复，原因和HashSet 一样，前面分析过源码.</span><br><span class="line">        //4. Map 中的 value 可以重复</span><br><span class="line">        //5. Map 的key 可以为 null, value 也可以为null ，注意 key 为null,</span><br><span class="line">        //   只能有一个，value 为null ,可以多个</span><br><span class="line">        //6. 常用String类作为Map的 key</span><br><span class="line">        //7. key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到对应的 value</span><br><span class="line">        Map map = new HashMap();</span><br><span class="line">        map.put(&quot;no1&quot;, &quot;韩顺平&quot;);//k-v</span><br><span class="line">        map.put(&quot;no2&quot;, &quot;张无忌&quot;);//k-v</span><br><span class="line">        map.put(&quot;no1&quot;, &quot;张三丰&quot;);//当有相同的k , 就等价于替换.</span><br><span class="line">        map.put(&quot;no3&quot;, &quot;张三丰&quot;);//k-v</span><br><span class="line">        map.put(null, null); //k-v</span><br><span class="line">        map.put(null, &quot;abc&quot;); //等价替换</span><br><span class="line">        map.put(&quot;no4&quot;, null); //k-v</span><br><span class="line">        map.put(&quot;no5&quot;, null); //k-v</span><br><span class="line">        map.put(1, &quot;赵敏&quot;);//k-v</span><br><span class="line">        map.put(new Object(), &quot;金毛狮王&quot;);//k-v</span><br><span class="line">        // 通过get 方法，传入 key ,会返回对应的value</span><br><span class="line">        System.out.println(map.get(&quot;no2&quot;));//张无忌</span><br><span class="line">        System.out.println(&quot;map=&quot; + map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310121028191.png"></p><h2 id="Map接口常用方法"><a href="#Map接口常用方法" class="headerlink" title="Map接口常用方法"></a>Map接口常用方法</h2><ol><li>put：添加</li><li>remove：根据键删除映射关系</li><li>get：根据键获取值</li><li>size：获取元素个数</li><li>isEmpty：判断个数是否为0</li><li>clear：清除</li><li>containsKey：查找键是否存在</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//      remove:根据键删除映射关系</span><br><span class="line">        map.remove(null);</span><br><span class="line">        System.out.println(&quot;map=&quot; + map);</span><br><span class="line">        </span><br><span class="line">//      get：根据键获取值</span><br><span class="line">        Object val = map.get(&quot;鹿晗&quot;);</span><br><span class="line">        System.out.println(&quot;val=&quot; + val);</span><br><span class="line">        </span><br><span class="line">//      size:获取元素个数</span><br><span class="line">        System.out.println(&quot;k-v=&quot; + map.size());</span><br><span class="line">        </span><br><span class="line">//      isEmpty:判断个数是否为0</span><br><span class="line">        System.out.println(map.isEmpty());//F</span><br><span class="line">        </span><br><span class="line">//      clear:清空</span><br><span class="line">        //map.clear();</span><br><span class="line">        System.out.println(&quot;map=&quot; + map);</span><br><span class="line">        </span><br><span class="line">//      containsKey:查找键是否存在</span><br><span class="line">        System.out.println(&quot;结果=&quot; + map.containsKey(&quot;hsp&quot;));//T</span><br></pre></td></tr></table></figure><h2 id="Map遍历方式"><a href="#Map遍历方式" class="headerlink" title="Map遍历方式"></a>Map遍历方式</h2>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis</title>
      <link href="/2023/10/26/Mbatis/"/>
      <url>/2023/10/26/Mbatis/</url>
      
        <content type="html"><![CDATA[<h1 id="MyBatis简介"><a href="#MyBatis简介" class="headerlink" title="MyBatis简介"></a>MyBatis简介</h1><h2 id="MyBatis历史"><a href="#MyBatis历史" class="headerlink" title="MyBatis历史"></a>MyBatis历史</h2><p>MyBatis最初是Apache的一个开源项目iBatis, 2010年6月这个项目由Apache Software Foundation迁 移到了Google Code。随着开发团队转投Google Code旗下， iBatis3.x正式更名为MyBatis。代码于 2013年11月迁移到Github。<br>iBatis一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。 iBatis提供的持久层框架 包括SQL Maps和Data Access Objects(DAO)。</p><h2 id="MyBatis特性"><a href="#MyBatis特性" class="headerlink" title="MyBatis特性"></a>MyBatis特性</h2><p>MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架<br>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集<br>MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO(Plain Old Java Objects，普通的Java对象) 映射成数据库中的记录<br>MyBatis 是一个 半自动的ORM(Object Relation Mapping) 框架</p><h2 id="MyBatis下载"><a href="#MyBatis下载" class="headerlink" title="MyBatis下载"></a>MyBatis下载</h2><p>MyBatis下载地址: <a href="https://github.com/mybatis/mybatis-3">https://github.com/mybatis/mybatis-3</a></p><p>使用Maven创建工程可以不用下载jar包，在这里面选择下载全部资源然后找到里面的官方文档即可。不看官方文档的可以跳过这一步。</p><h2 id="和其它持久化层技术对比"><a href="#和其它持久化层技术对比" class="headerlink" title="和其它持久化层技术对比"></a>和其它持久化层技术对比</h2><p>JDBC：</p><ol><li>SQL 夹杂在Java代码中耦合度高，导致硬编码内伤</li><li>维护不易且实际开发需求中 SQL 有变化，频繁修改的情况多见</li><li>代码冗长，开发效率低</li></ol><p>Hibernate 和 JPA：</p><ol><li>操作简便，开发效率高</li><li>程序中的长难复杂 SQL 需要绕过框架</li><li>内部自动生产的 SQL，不容易做特殊优化</li><li>基于全映射的全自动框架，大量字段的POJO 进行部分映射时比较困难。</li><li>反射操作太多，导致数据库性能下降</li></ol><p>MyBatis：</p><ol><li>轻量级，性能出色 SQL 和 Java 编码分开，功能边界清晰。</li><li>Java代码专注业务、SQL语句专注数据</li><li>开发效率稍逊于Hibernate，但是完全能够接受</li></ol><h1 id="Mybatis入门案例"><a href="#Mybatis入门案例" class="headerlink" title="Mybatis入门案例"></a>Mybatis入门案例</h1><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>IDEL：idea 2022.3<br>构建工具：maven 3.6.3<br>MySQL版本：MySQL 8.0<br>MyBatis版本：MyBatis 3.5.13</p><h2 id="创建maven工程"><a href="#创建maven工程" class="headerlink" title="创建maven工程"></a>创建maven工程</h2><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">创建 maven 项目</button></li><li class="tab"><button type="button" data-href="#test1-2">配置 pom.xml</button></li><li class="tab"><button type="button" data-href="#test1-3">建立sql表单</button></li><li class="tab"><button type="button" data-href="#test1-4">创建 MyBatis核心配置文件</button></li><li class="tab"><button type="button" data-href="#test1-5">创建Mapper接口</button></li><li class="tab"><button type="button" data-href="#test1-6">创建MyBatis的映射文件</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p>创建一个普通Java项目，然后在其中新建一个maven工程，名称为mybatis_demo1。项目SDK选择Java 1.8。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p> 配置maven打包方式为jar</p><p>引入mybatis、junit、mysql依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;groupId&gt;com.atguigu.mybatis&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;MB-1&lt;/artifactId&gt;</span><br><span class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!-- Mybatis核心 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.5.13&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- junit测试 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.10&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- MySQL驱动 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;8.0.15&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p>创建一个名称为 user 的table，并设置属性：id(主键、非空、自增)、username等</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310161827564.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><p>习惯上命名为mybatis-config.xml，这个文件名仅仅只是建议，并非强制要求。将来整合Spring之后，这个配置文件可以省略，所以大家操作时可以直接复制、粘贴。</p><p>核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息。<br>核心配置文件存放的位置是src&#x2F;main&#x2F;resources目录下。</p><p>新建一个<code>mybatis-config.xml</code>文件，将以下内容粘贴进去：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;!--设置连接数据库的环境--&gt;</span><br><span class="line">&lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">    &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">        &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class="line">        &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;url&quot;</span><br><span class="line">                      value=&quot;jdbc:mysql://localhost:3306/test?serverTimezone=UTC&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt;</span><br><span class="line">            &lt;!--注意：如果在建sql表单的时候选了字符集（如utf8），</span><br><span class="line">            这里的value要改成：value=&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf8&quot;--&gt;</span><br><span class="line">            &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;password&quot; value=&quot;161519&quot;/&gt;</span><br><span class="line">        &lt;/dataSource&gt;</span><br><span class="line">    &lt;/environment&gt;</span><br><span class="line">&lt;/environments&gt;</span><br><span class="line">    &lt;!--引入映射文件--&gt; &lt;mappers&gt;</span><br><span class="line">    &lt;mapper resource=&quot;mappers/UserMapper.xml&quot;/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-5"><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310161835568.png">MyBatis中的mapper接口相当于以前的dao。<br>区别在于：mapper仅仅是接口，我们不需要提供实现类。</p><p>创建实体类，对应表单 </p><ol><li><p>创建User类pojo，对应表单 user</p><p>User类中，包括private类型的对应字段、一个有参构造器、一个无参构造器、所有字段的getter和setter</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String username;</span><br><span class="line">    private String password;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private String gender;</span><br><span class="line">    private  String email;</span><br><span class="line"></span><br><span class="line">    public User() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public User(Integer id, String username, String password, Integer age, String gender, String email) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.username = username;</span><br><span class="line">        this.password = password;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.gender = gender;</span><br><span class="line">        this.email = email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123;&quot; +</span><br><span class="line">                &quot;id=&quot; + id +</span><br><span class="line">                &quot;, username=&#x27;&quot; + username + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, password=&#x27;&quot; + password + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &quot;, gender=&#x27;&quot; + gender + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, email=&#x27;&quot; + email + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUsername(String username) &#123;</span><br><span class="line">        this.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getPassword() &#123;</span><br><span class="line">        return password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPassword(String password) &#123;</span><br><span class="line">        this.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(Integer age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getGender() &#123;</span><br><span class="line">        return gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setGender(String gender) &#123;</span><br><span class="line">        this.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getEmail() &#123;</span><br><span class="line">        return email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setEmail(String email) &#123;</span><br><span class="line">        this.email = email;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>创建UserMapper接口</p><p>MyBatis面向接口编程的两个一致：</p><ol><li>映射文件namespace和Mapper接口的全类名一致（第一个一致）</li><li>映射文件中sql语句的id和mapper接口中的方法一致（第二个一致）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface UserMapper &#123;</span><br><span class="line">    int insertUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>映射路径：</p><ol><li><p>在UserMapper.xml中，namespace为 ”com.atguigu.mybatis.mapper.UserMapper” ，定位到这个com.atguigu.mybatis.mapper.UserMapper类。</p></li><li><p>根据元素id，例如 insert id&#x3D;”insertUser”，找到UserMapper.insertUser()。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public interface UserMapper &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 添加用户信息</span><br><span class="line">     * sql写在映射文件中</span><br><span class="line">     */</span><br><span class="line">    int insertUser();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 修改用户信息</span><br><span class="line">     */</span><br><span class="line">    void updateUser();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除用户信息</span><br><span class="line">     */</span><br><span class="line">    void deleteUser();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据id查询用户信息</span><br><span class="line">     */</span><br><span class="line">    User getUserById();</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查询所有的用户信息</span><br><span class="line">     */</span><br><span class="line">    List&lt;User&gt; getAllUser();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-6"><p>相关概念：<strong>ORM(Object Relationship Mapping)对象关系映射</strong>。</p><ul><li>对象：Java的实体类对象</li><li>关系：关系型数据库</li><li>映射：二者之间的对应关系</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310161837207.png"></p><p>映射文件的命名规则:</p><p>表所对应的实体类的类名+Mapper.xml</p><blockquote><p>例如:表user，映射的实体类为User，所对应的映射文件为UserMapper.xml (一张表一个映射文件)<br>因此一个映射文件对应一个实体类，对应一张表的操作<br>MyBatis映射文件用于编写SQL，访问以及操作表中的数据 MyBatis映射文件存放的位置是src&#x2F;main&#x2F;resources&#x2F;mappers目录下</p></blockquote><p>MyBatis中可以面向接口操作数据，<strong>要保证两个一致:</strong></p><ol><li>mapper接口的全类名和映射文件的命名空间(namespace)保持一致</li><li>mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致</li></ol><p>在src&#x2F;main&#x2F;resources下，创建UserMapper.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.atguigu.mybatis.mapper.UserMapper&quot;&gt;</span><br><span class="line">    &lt;!--int insertUser();--&gt;</span><br><span class="line">    &lt;insert id=&quot;insertUser&quot;&gt;</span><br><span class="line">        insert into t_user values(null, &quot;marina&quot;, &quot;456&quot;,23,&#x27;f&#x27;,&quot;153456@qq.com&quot;)</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--void updateUser();--&gt;</span><br><span class="line">    &lt;update id=&quot;updateUser&quot;&gt;</span><br><span class="line">        update t_user set username = &quot;RUOYI&quot; where id = 4</span><br><span class="line">    &lt;/update&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--void deleteUser();--&gt;</span><br><span class="line">    &lt;delete id=&quot;deleteUser&quot;&gt;</span><br><span class="line">        delete from t_user where id = 5</span><br><span class="line">    &lt;/delete&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--User getUserById();--&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">        查询功能的标签必须设置resultType或者resultMap</span><br><span class="line">        resultType：设置默认的映射关系</span><br><span class="line">        resultMap：设置自定义的映射关系（字段名和表头不一样）</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;select id=&quot;getUserById&quot; resultType=&quot;com.atguigu.mybatis.pojo.User&quot;&gt;</span><br><span class="line">        select * from t_user where id = 4</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--List&lt;User&gt; getAllUser();--&gt;</span><br><span class="line">    &lt;select id=&quot;getAllUser&quot; resultType=&quot;com.atguigu.mybatis.pojo.User&quot;&gt;</span><br><span class="line">        select * from t_user</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;/mapper&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="通过junit进行测试"><a href="#通过junit进行测试" class="headerlink" title="通过junit进行测试"></a>通过junit进行测试</h3><p>在src&#x2F;test下建立com.atguigu.mybatis.test包，创建MyBatisTest测试类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">public class MyBatisTest &#123;</span><br><span class="line">    /**</span><br><span class="line">     * sqlsession默认不自动提交事务，如果需要自动提交事务，可以使用SqlSessionFactory.openSession(true);</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void testInsertUser() throws IOException &#123;</span><br><span class="line">        //加载核心配置文件</span><br><span class="line">        InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">        //获取sqlsessionfactorybuilder</span><br><span class="line">        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();</span><br><span class="line">        //获取factory</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);</span><br><span class="line">        //获取sqlsession</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession(true);</span><br><span class="line">        //获取mapper接口对象</span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper.class); //代理模式</span><br><span class="line"></span><br><span class="line">        //测试功能</span><br><span class="line">        int result = mapper.insertUser();</span><br><span class="line"></span><br><span class="line">        //提交事务（写的type是JDBC）</span><br><span class="line">//        sqlSession.commit();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;result: &quot; + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testUpdateUser() throws IOException &#123;</span><br><span class="line">        InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession(true);</span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">        mapper.updateUser();</span><br><span class="line">        System.out.println(&quot;updating...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testDeleteUser() throws IOException &#123;</span><br><span class="line">        InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession(true);</span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">        mapper.deleteUser();</span><br><span class="line">        System.out.println(&quot;deleteUser-...&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testSelectUser() throws IOException &#123;</span><br><span class="line">        InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession(true);</span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 如果不在UserMapper.xml中配置：</span><br><span class="line">         * &lt;select id=&quot;getAllUser&quot; resultType=&quot;com.atguigu.mybatis.pojo.User&quot;&gt;</span><br><span class="line">         * </span><br><span class="line">         * 会报错：A query was run and no Result Maps were found</span><br><span class="line">         *           for the Mapped Statement &#x27;com.atguigu.mybatis.mapper.UserMapper.getUserById&#x27;</span><br><span class="line">         *          It&#x27;s likely that neither a Result Type nor a Result Map was specified.</span><br><span class="line">         *</span><br><span class="line">         * com.atguigu.mybatis.mapper.UserMapper.getUserById： 命名空间.方法名</span><br><span class="line">         *</span><br><span class="line">         * 因此，要设置一个a Result Type nor a Result Map，这个type就是返回来的对应的类（要写全类名）</span><br><span class="line">         *</span><br><span class="line">         * 在UserMapper里进行设置</span><br><span class="line">         */</span><br><span class="line">        User user = mapper.getUserById();</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; allUser = mapper.getAllUser();</span><br><span class="line">        allUser.forEach(user1 -&gt; System.out.println(user1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="MyBatis-中的事务"><a href="#MyBatis-中的事务" class="headerlink" title="MyBatis 中的事务"></a>MyBatis 中的事务</h4><p>这里用的 JDBC 默认是不开启自动提交的，需要人为执行 commit 方法，但是上面的 openSession 方法中，默认值是 false，改为 true 后会自动提交。</p><h3 id="加入log4j日志功能"><a href="#加入log4j日志功能" class="headerlink" title="加入log4j日志功能"></a>加入log4j日志功能</h3><p>日志功能可以记录测试的sql语句、参数、结果，如：</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310161944281.png"></p><p><strong>引入依赖</strong></p><ol><li><p>在pom.xml中加入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- log4j日志 --&gt; </span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>加入log4j的配置文件<br>在src&#x2F;main&#x2F;resources目录下，创建log4j.xml文件，加入配置信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE log4j:configuration SYSTEM &quot;log4j.dtd&quot;&gt;</span><br><span class="line">&lt;log4j:configuration xmlns:log4j=&quot;http://jakarta.apache.org/log4j/&quot;&gt;</span><br><span class="line">    &lt;appender name=&quot;STDOUT&quot; class=&quot;org.apache.log4j.ConsoleAppender&quot;&gt;</span><br><span class="line">        &lt;param name=&quot;Encoding&quot; value=&quot;UTF-8&quot; /&gt;</span><br><span class="line">        &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt;</span><br><span class="line">            &lt;param name=&quot;ConversionPattern&quot; value=&quot;%-5p %d&#123;MM-dd HH:mm:ss,SSS&#125;</span><br><span class="line">%m  (%F:%L) \n&quot; /&gt;</span><br><span class="line">        &lt;/layout&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line">    &lt;logger name=&quot;java.sql&quot;&gt;</span><br><span class="line">        &lt;level value=&quot;debug&quot; /&gt;</span><br><span class="line">    &lt;/logger&gt;</span><br><span class="line">    &lt;logger name=&quot;org.apache.ibatis&quot;&gt;</span><br><span class="line">        &lt;level value=&quot;info&quot; /&gt;</span><br><span class="line">    &lt;/logger&gt;</span><br><span class="line">    &lt;root&gt;</span><br><span class="line">        &lt;level value=&quot;debug&quot; /&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;STDOUT&quot; /&gt;</span><br><span class="line">    &lt;/root&gt;</span><br><span class="line">&lt;/log4j:configuration&gt;</span><br></pre></td></tr></table></figure></li></ol><p>日志的级别：<br>FATAL(致命)&gt;ERROR(错误)&gt;WARN(警告)&gt;INFO(信息)&gt;DEBUG(调试)<br>从左到右打印的内容越来越详细，即，如果选择DEBUG级别，一定会打印出前面几种级别的信息。</p><h2 id="MyBatis的增删改查"><a href="#MyBatis的增删改查" class="headerlink" title="MyBatis的增删改查"></a>MyBatis的增删改查</h2><p>注意：</p><ol><li>查询的标签select必须设置属性resultType或resultMap，用于设置实体类和数据库表的映射关系<br>resultType：自动映射，用于属性名和表中字段名一致的情况<br>resultMap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况</li><li>当查询的数据为多条时，不能使用实体类作为返回值，只能使用集合，否则会抛出异常TooManyResultsException；但是若查询的数据只有一条，可以使用实体类或集合作为返回值</li></ol><p>增删改的返回值：受影响的行数，类型固定</p><p>查的返回值：查到的结果，根据不同结果用不同的东西接受</p><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">增</button></li><li class="tab"><button type="button" data-href="#test4-2">删</button></li><li class="tab"><button type="button" data-href="#test4-3">改</button></li><li class="tab"><button type="button" data-href="#test4-4">查</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--int insertUser();--&gt;</span><br><span class="line">&lt;insert id=&quot;insertUser&quot;&gt;</span><br><span class="line">insert into t_user values(null,&#x27;admin&#x27;,&#x27;123456&#x27;,23,&#x27;男&#x27;,&#x27;12345@qq.com&#x27;)</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--int deleteUser();--&gt;</span><br><span class="line">&lt;delete id=&quot;deleteUser&quot;&gt;</span><br><span class="line">    delete from t_user where id = 6</span><br><span class="line">&lt;/delete&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-3"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--int updateUser();--&gt;</span><br><span class="line">&lt;update id=&quot;updateUser&quot;&gt;</span><br><span class="line">    update t_user set username = &#x27;张三&#x27; where id = 5</span><br><span class="line">&lt;/update&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-4"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">查询一个实体类对象</span><br><span class="line">&lt;!--User getUserById();--&gt;  </span><br><span class="line">&lt;select id=&quot;getUserById&quot; resultType=&quot;com.atguigu.mybatis.bean.User&quot;&gt;  </span><br><span class="line">select * from t_user where id = 2  </span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line">查询集合</span><br><span class="line">&lt;!--List&lt;User&gt; getUserList();--&gt;</span><br><span class="line">&lt;select id=&quot;getUserList&quot; resultType=&quot;com.atguigu.mybatis.bean.User&quot;&gt;</span><br><span class="line">select * from t_user</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="核心配置文件"><a href="#核心配置文件" class="headerlink" title="核心配置文件"></a>核心配置文件</h1><blockquote><p>mybatis中有2中配置文件，一个是<strong>核心配置文件</strong>，另一个是<strong>映射文件</strong></p></blockquote><p>核心配置文件没有固定的名字，但是默认都叫<strong>mybatis-config</strong></p><p>核心配置文件中的标签必须按照固定的顺序(有的标签可以不写，但顺序一定不能乱)：</p><ol><li>properties</li><li>settings</li><li>typeAliases</li><li>typeHandlers</li><li>objectFactory</li><li>objectWrapperFactory</li><li>reflectorFactory</li><li>plugins</li><li>environments</li><li>databaseIdProvider</li><li>mappers</li></ol><blockquote><p>没写的不管，写了的一定要按顺序，不然会报错</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;!--    MyBatis核心配置文件，标签的顺序</span><br><span class="line">        properties?,settings?,typeAliases?,typeHandlers?,</span><br><span class="line">        objectFactory?,objectWrapperFactory?,reflectorFactory?,</span><br><span class="line">        plugins?,environments?,databaseIdProvider?,mappers?--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties resource=&quot;jdbc.properties&quot;&gt;&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--    设置类型别名，大小写不敏感。</span><br><span class="line">        如果不设置alias，则默认为类名（大小写不敏感）--&gt;</span><br><span class="line">        </span><br><span class="line">    &lt;typeAliases&gt;</span><br><span class="line">        &lt;!--</span><br><span class="line">            typeAlias: 设置某个类型的别名</span><br><span class="line">            属性：</span><br><span class="line">                type 设置需要设置别名的类型</span><br><span class="line">                alias 设置某个类型的别名，如果不设置该属性，那么该类型拥有默认的类名，且不区分大小写</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;typeAlias type=&quot;com.atguigu.mybatis.pojo.User&quot; alias=&quot;User&quot;&gt;&lt;/typeAlias&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--        以包为单位，将包下所有的类型设置默认的类型别名且不区分大小写--&gt;</span><br><span class="line">        &lt;package name=&quot;com.atguigu.mybatis.pojo&quot;/&gt;</span><br><span class="line">    &lt;/typeAliases&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!--设置连接数据库的环境--&gt; </span><br><span class="line">&lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">    &lt;!--每一个environment都是具体连接数据库的环境--&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">        一个项目中只会用一个环境，default用于使用默认使用的环境：</span><br><span class="line">        id：表示连接数据库的环境的唯一标识 不能重复</span><br><span class="line"></span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">        transactionmanager:设置事务管理方式</span><br><span class="line">        属性：</span><br><span class="line">            type=&quot;JDBC/MANAGED&quot;</span><br><span class="line">            JDBC: 在当前环境中，执行sql时，使用的时jdbc原声的事务管理方式，需要手动的提交和回滚事务</span><br><span class="line">            MANAGED：被管理，例如Spring</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--        dataSource：配置数据源</span><br><span class="line">            属性&quot;</span><br><span class="line">                type：设置数据源的类型</span><br><span class="line">                type=&quot;&quot;</span><br><span class="line">                POOLED:表示使用数据库连接池缓存数据库连接</span><br><span class="line">                UNPOOLED：表示不实用数据库连接池</span><br><span class="line">                JNDI：表示使用上下文中的数据源</span><br><span class="line">--&gt;</span><br><span class="line">        &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">            &lt;!--设置连接数据库的驱动--&gt;</span><br><span class="line">            &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;</span><br><span class="line">            &lt;!--设置连接地址--&gt;</span><br><span class="line">            &lt;property name=&quot;url&quot;</span><br><span class="line">                      value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;</span><br><span class="line">            &lt;!--用户名和密码--&gt;</span><br><span class="line">            &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;</span><br><span class="line">        &lt;/dataSource&gt;</span><br><span class="line">    &lt;/environment&gt;</span><br><span class="line">&lt;/environments&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!--引入映射文件--&gt; </span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">&lt;!--        &lt;mapper resource=&quot;mappers/UserMapper.xml&quot;/&gt;--&gt;</span><br><span class="line">&lt;!--        BindingException: Type interface com.atguigu.mybatis.mapper.UserMapper is not known to the MapperRegistry.</span><br><span class="line">            没有成功建立映射关系</span><br><span class="line">            以包为单位引入映射文件，要求：</span><br><span class="line">                1。 mapper接口所在的包要和映射文件所在的包一致</span><br><span class="line">                2。 mapper接口要和映射文件的名字一致--&gt;</span><br><span class="line">&lt;!--        com.atguigu.mybatis.mapper创建包时要用/分隔，这样才是目录，否则这整一个就只是文件夹名字而已--&gt;</span><br><span class="line">        &lt;package name=&quot;com.atguigu.mybatis.mapper&quot;/&gt;</span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><h2 id="environments"><a href="#environments" class="headerlink" title="environments"></a>environments</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">        &lt;!--</span><br><span class="line">        environment：设置具体的连接数据库的环境信息</span><br><span class="line">        属性：</span><br><span class="line">    id：设置环境的唯一标识，可通过environments标签中的default设置某一个环境的id，表示默认使用的环境</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">            &lt;!--</span><br><span class="line">            transactionManager：设置事务管理方式</span><br><span class="line">            属性：</span><br><span class="line">            type：设置事务管理方式，type=&quot;JDBC|MANAGED&quot;</span><br><span class="line">            type=&quot;JDBC&quot;：设置当前环境的事务管理都必须手动处理</span><br><span class="line">            type=&quot;MANAGED&quot;：设置事务被管理，例如spring中的AOP</span><br><span class="line">            --&gt;</span><br><span class="line">            &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class="line">            &lt;!--</span><br><span class="line">            dataSource：设置数据源</span><br><span class="line">            属性：</span><br><span class="line">            type：设置数据源的类型，type=&quot;POOLED|UNPOOLED|JNDI&quot;</span><br><span class="line">            type=&quot;POOLED&quot;：使用数据库连接池，即会将创建的连接进行缓存，下次使用可以从缓存中直接获取，不需要重新创建</span><br><span class="line">            type=&quot;UNPOOLED&quot;：不使用数据库连接池，即每次使用连接都需要重新创建</span><br><span class="line">            type=&quot;JNDI&quot;：调用上下文中的数据源</span><br><span class="line">            --&gt;</span><br><span class="line">            &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">                &lt;!--设置驱动类的全类名--&gt;</span><br><span class="line">                &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;</span><br><span class="line">                &lt;!--设置连接数据库的连接地址--&gt;</span><br><span class="line">                &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;</span><br><span class="line">                &lt;!--设置连接数据库的用户名--&gt;</span><br><span class="line">                &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;</span><br><span class="line">                &lt;!--设置连接数据库的密码--&gt;</span><br><span class="line">                &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br></pre></td></tr></table></figure><h3 id="environment：设置数据库环境"><a href="#environment：设置数据库环境" class="headerlink" title="environment：设置数据库环境"></a>environment：设置数据库环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  &lt;!--设置连接数据库的环境--&gt; </span><br><span class="line">&lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">  &lt;!--每一个environment都是具体连接数据库的环境--&gt;</span><br><span class="line">  &lt;!--</span><br><span class="line">      一个项目中只会用一个环境，default用于使用默认使用的环境：</span><br><span class="line">      id：表示连接数据库的环境的唯一标识 不能重复</span><br><span class="line">  --&gt;</span><br><span class="line">  &lt;environment id=&quot;development&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="transactionManager：设置事务管理方式"><a href="#transactionManager：设置事务管理方式" class="headerlink" title="transactionManager：设置事务管理方式"></a>transactionManager：设置事务管理方式</h3><p><strong>属性：type&#x3D;”JDBC&#x2F;MANAGED”</strong></p><ul><li>JDBC: 在当前环境中，执行sql时，使用的是jdbc原生的事务管理方式，需要手动的提交和回滚事务</li><li>MANAGED：被管理，例如Spring</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br></pre></td></tr></table></figure><h3 id="properties：动态写入信息"><a href="#properties：动态写入信息" class="headerlink" title="${} + properties：动态写入信息"></a>${} + properties：动态写入信息</h3><p>如果想动态地写数据库驱动的信息，可以新建一个配置文件（jdbc.properties），文件类型为resource bundle。</p><ol><li><p>在jdbc.properties文件中，以字符串形式定义各个属性。<br>每个属性最好以有意义的标识作前缀，如jdbc.xxx。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driver=com.mysql.cj.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql://localhost:3306/test?serverTimezone=UTC&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=</span><br></pre></td></tr></table></figure></li><li><p>在<code>mybatis-config.xml</code>文件中，添加<code>&lt;properties&gt;</code>元素，将资源文件引入配置文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties resource=&quot;jdbc.properties&quot;&gt;&lt;/properties&gt;</span><br></pre></td></tr></table></figure></li><li><p>在dataSource中，使用<code>$&#123;xxx&#125;</code>格式，引入对应的属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--        dataSource：配置数据源</span><br><span class="line">            属性&quot;</span><br><span class="line">                type：设置数据源的类型</span><br><span class="line">                type=&quot;POOLED/UNPOOLED/JNDI&quot;</span><br><span class="line">                POOLED:表示使用数据库连接池缓存数据库连接</span><br><span class="line">                UNPOOLED：表示不实用数据库连接池</span><br><span class="line">                JNDI：表示使用上下文中的数据源</span><br><span class="line">--&gt;</span><br><span class="line">        &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">            &lt;!--设置连接数据库的驱动--&gt;</span><br><span class="line">            &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;</span><br><span class="line">            &lt;!--设置连接地址--&gt;</span><br><span class="line">            &lt;property name=&quot;url&quot;</span><br><span class="line">                      value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;</span><br><span class="line">            &lt;!--用户名和密码--&gt;</span><br><span class="line">            &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;</span><br><span class="line">        &lt;/dataSource&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="typeAlias-x2F-package：设置某个类型的别名"><a href="#typeAlias-x2F-package：设置某个类型的别名" class="headerlink" title="typeAlias&#x2F;package：设置某个类型的别名"></a>typeAlias&#x2F;package：设置某个类型的别名</h3><p><strong>typeAlias属性：</strong></p><ul><li><p>type: 设置需要设置别名的类型</p></li><li><p>alias: 设置某个类型的别名，如果不设置该属性，那么该类型拥有默认的类名，且不区分大小写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;typeAliases&gt;</span><br><span class="line">        &lt;typeAlias type=&quot;com.atguigu.mybatis.pojo.User&quot; alias=&quot;User&quot;&gt;&lt;/typeAlias&gt;</span><br><span class="line">&lt;/typeAliases&gt;</span><br></pre></td></tr></table></figure></li></ul><p>即，使用<code>User</code>作为<code>com.atguigu.mybatis.pojo.User</code>的别名，可以在mapper的配置文件中直接使用User来代表这个类。</p><p>也可以使用<code>&lt;package&gt;</code>来表示，以该包为单位，将包下所有的类型设置默认的类型别名且不区分大小写。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;typeAliases&gt;</span><br><span class="line">&lt;!--        以包为单位，将包下所有的类型设置默认的类型别名且不区分大小写--&gt;</span><br><span class="line">        &lt;package name=&quot;com.atguigu.mybatis.pojo&quot;/&gt;</span><br><span class="line">&lt;/typeAliases&gt;</span><br></pre></td></tr></table></figure><h1 id="mappers：引入映射文件"><a href="#mappers：引入映射文件" class="headerlink" title="mappers：引入映射文件"></a>mappers：引入映射文件</h1><p>以包为单位引入映射文件，要求：</p><ol><li>mapper接口所在的包要和映射文件所在的包一致</li><li>mapper接口要和映射文件的名字一致</li></ol><p>XXXMapper接口：里面存放各种抽象方法</p><p>XXXMapper.Xml：里面存放抽象方法的具体实现SQL语句</p><blockquote><p>com.atguigu.mybatis.mapper创建包时要用&#x2F;分隔（new package时，名称要写成com&#x2F;atguigu&#x2F;mybatis&#x2F;mapper），这样才是目录，否则这整一个就只是文件夹名字而已，就不能正确映射，会报错：BindingException: Type interface com.atguigu.mybatis.mapper.UserMapper is not known to the MapperRegistry。</p></blockquote><p>我就有一次mapper和mappers没区分报错..</p><h1 id="MyBatis获取参数值"><a href="#MyBatis获取参数值" class="headerlink" title="MyBatis获取参数值"></a>MyBatis获取参数值</h1><h2 id="设置配置文件模板"><a href="#设置配置文件模板" class="headerlink" title="设置配置文件模板"></a>设置配置文件模板</h2><h3 id="设置mybatis-config-xml配置文件模版"><a href="#设置mybatis-config-xml配置文件模版" class="headerlink" title="设置mybatis-config.xml配置文件模版"></a>设置mybatis-config.xml配置文件模版</h3><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">模板内容</button></li><li class="tab"><button type="button" data-href="#test4-2">添加模版步骤</button></li><li class="tab"><button type="button" data-href="#test4-3">创建模版</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties resource=&quot;jdbc.properties&quot;&gt;&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;typeAliases&gt;</span><br><span class="line">        &lt;package name=&quot;&quot;&gt;&lt;/package&gt;</span><br><span class="line">    &lt;/typeAliases&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--设置连接数据库的环境--&gt;</span><br><span class="line">    &lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">        &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">            &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class="line">            &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">                &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;url&quot;</span><br><span class="line">                          value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br><span class="line">    &lt;!--引入映射文件--&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;package name=&quot;&quot;/&gt;</span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><p><strong><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310171510113.png"></strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-3"><p>完成后就可以直接new一个<code>mybatis-config</code>模版啦。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310171512633.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="设置xxxMapper-xml配置文件模版"><a href="#设置xxxMapper-xml配置文件模版" class="headerlink" title="设置xxxMapper.xml配置文件模版"></a>设置xxxMapper.xml配置文件模版</h3><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">模板内容</button></li><li class="tab"><button type="button" data-href="#test4-2">添加模版步骤</button></li><li class="tab"><button type="button" data-href="#test4-3">创建模版</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><p>过程与config模版相同。图我就用上一张了</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310171510113.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-3"><p>完成后就可以直接new一个模版啦。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310171512633.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="封装SqlSessionUtils-工具类并测试功能"><a href="#封装SqlSessionUtils-工具类并测试功能" class="headerlink" title="封装SqlSessionUtils. 工具类并测试功能"></a>封装SqlSessionUtils. 工具类并测试功能</h2><p>原来的测试里面每一个测试都有共同的加载部分，抽出来，封装成方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testSelectUser() throws IOException &#123;</span><br><span class="line">        //加载核心配置文件</span><br><span class="line">        InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">        //获取sqlsessionfactorybuilder</span><br><span class="line">        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();</span><br><span class="line">        //获取factory</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);</span><br><span class="line">        //获取sqlsession</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession(true);</span><br><span class="line">        //获取mapper接口对象</span><br><span class="line">        UserMapper mapper = sqlSession.getMapper(UserMapper.class); //代理模式</span><br><span class="line"></span><br><span class="line">        //测试功能</span><br><span class="line">        int result = mapper.updateUser();</span><br><span class="line"></span><br><span class="line">        //提交事务（写的type是JDBC）</span><br><span class="line">//        sqlSession.commit();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;result: &quot; + result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li><p>创建SqlSessionUtils工具类</p><p>具体功能就是加载核心配置文件直到获取sqlsession</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class SqlSessionUtils &#123;</span><br><span class="line">    public static SqlSession getSqlSession() throws IOException &#123;</span><br><span class="line">        InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">        SqlSession sqlSession = null;</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);</span><br><span class="line">        sqlSession = sqlSessionFactory.openSession(true);</span><br><span class="line">        return sqlSession;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取mapper</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void testGetAllUser() throws IOException &#123;</span><br><span class="line">    SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">    ParaMeterMapper mapper = sqlSession.getMapper(ParaMeterMapper.class);</span><br><span class="line">    List&lt;User&gt; list = mapper.getAllUser();</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="MyBatis获取参数值的两种方式（重点）"><a href="#MyBatis获取参数值的两种方式（重点）" class="headerlink" title="MyBatis获取参数值的两种方式（重点）"></a>MyBatis获取参数值的两种方式（重点）</h2><p>这里的参数不一定得是类的属性，是根据get&#x2F;set方法获取的，以后可能遇到没有这个属性却有get&#x2F;set方法的情况</p><h3 id="JDBC原生的获取参数值的方式"><a href="#JDBC原生的获取参数值的方式" class="headerlink" title="JDBC原生的获取参数值的方式"></a>JDBC原生的获取参数值的方式</h3><ul><li>字符串拼接 （Statement ，${}）：需要自己补充 ‘’</li><li>占位符拼接 （PreparedStatement，#{}）：系统提供 ‘’</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testJDBC() throws SQLException, ClassNotFoundException &#123;</span><br><span class="line">    String username = &quot;cherry&quot;;</span><br><span class="line">    Class.forName(&quot;&quot;);</span><br><span class="line">    Connection connection = DriverManager.getConnection(&quot;&quot;, &quot;&quot;, &quot;&quot;);</span><br><span class="line">    // 1. 字符串拼接 -&gt;获得预编译对象 -》sql注入问题</span><br><span class="line">    PreparedStatement preparedStatement = connection.prepareStatement(&quot;select * from t_user where username = &#x27;&quot; + username + &quot;&#x27;&quot;);</span><br><span class="line"></span><br><span class="line">    // 2. 占位符</span><br><span class="line">    PreparedStatement ps2 = connection.prepareStatement(&quot;select * from t_user where username = ?&quot;);</span><br><span class="line">    ps2.setString(1, username);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="MyBatis获取参数值的两种方式：-和"><a href="#MyBatis获取参数值的两种方式：-和" class="headerlink" title="MyBatis获取参数值的两种方式：${}和#{}"></a>MyBatis获取参数值的两种方式：${}和#{}</h3><ol><li><p>${}的本质就是字符串拼接</p><p>${}使用字符串拼接的方式拼接sql，若为字符串类型或日期类型的字段进行赋值时，需要手动加单引号，不推荐，但是有必须用的时候</p></li><li><p>#{}的本质就是占位符赋值</p><p>#{}使用占位符赋值的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时，可以自动添加单引号</p></li></ol><h2 id="MyBatis获取参数值的五种情况"><a href="#MyBatis获取参数值的五种情况" class="headerlink" title="MyBatis获取参数值的五种情况"></a>MyBatis获取参数值的五种情况</h2><p>以后取参数只有2种方法</p><ol><li>实体类对像</li><li>用Param取别名</li></ol><h3 id="情况1-单个字面量类型的参数"><a href="#情况1-单个字面量类型的参数" class="headerlink" title="情况1: 单个字面量类型的参数"></a>情况1: 单个字面量类型的参数</h3><p>若mapper接口中的方法参数为单个的字面量类型<br>此时可以使用 ${} 和 #{} 以任意的名称获取参数的值，注意 ${} 需要手动加单引号</p><p>ParameterMapper接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface ParameterMapper &#123;</span><br><span class="line">    /**</span><br><span class="line">      单个的字面量类型:</span><br><span class="line">      根据用户名查询用户信息</span><br><span class="line">    */</span><br><span class="line">         User getUserByUserName(String username);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>对应在ParameterMapper.xml中配置。</p><p>方式一：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--    User getUserByUserName(String username);--&gt;</span><br><span class="line">&lt;!--    使用#&#123;&#125;，里面内容可以随便写，都是传进来的username的值--&gt;</span><br><span class="line">    &lt;select id=&quot;getUserByUserName&quot; resultType=&quot;User&quot;&gt;</span><br><span class="line">       select * from t_user where username = #&#123;username&#125;</span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure><p>方式二：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--    User getUserByUserName(String username);--&gt;</span><br><span class="line">    &lt;select id=&quot;getUserByUserName&quot; resultType=&quot;User&quot;&gt;</span><br><span class="line">        &lt;!-- </span><br><span class="line">       select * from t_user where username = $&#123;username&#125;</span><br><span class="line">          如果使用这种方式，得到的sql语句是：</span><br><span class="line">          Preparing: select * from t_user where username = RUOYI</span><br><span class="line">          而其中username的值‘RUOYI’没有单引号，语句不正确，会报错。</span><br><span class="line">          因此要手动添加单引号</span><br><span class="line">       --&gt;</span><br><span class="line">        select * from t_user where username = &#x27;$&#123;username&#125;&#x27;</span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure><p>测试类：</p><pre><code>/** * MyBatis获取参数值的各种情况： * 情况1： mapper接口方法的参数为单个字面量的参数 * 可以通过$&#123;&#125; #&#123;&#125;以任意的字符串获得参数值，但需要注意$&#123;&#125;的单引号问题 */@Testpublic void testgetUserByUserName()&#123;    SqlSession sqlSession = SqlSessionUtils.getSqlSession();    ParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class);    User user = mapper.getUserByUserName(&quot;RUOYI&quot;);    System.out.println(user);&#125;</code></pre><h3 id="情况2：多个字面量类型的参数"><a href="#情况2：多个字面量类型的参数" class="headerlink" title="情况2：多个字面量类型的参数"></a>情况2：多个字面量类型的参数</h3><p>若mapper接口中的方法参数为多个时,此时MyBatis会自动将这些参数放在一个map集合中。</p><ul><li><p>以[arg0，arg1…]，以参数为值;</p></li><li><p>以[param1，param2…]，以参数为值;</p></li></ul><blockquote><p>注意2个集合的开始序列，另外这俩不同名字的东西其实可以混用</p></blockquote><p>因此只需要通过 ${} 和 #{} 访问 map 集合就可以获取相对应的值，<strong>注意 ${} 需要手动加单引号</strong></p><p>ParameterMapper接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface ParaMeterMapper &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 验证登录</span><br><span class="line">     */</span><br><span class="line">    User checkLogin(String username, String password);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对应在ParameterMapper.xml中配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--    User checkLogin(String username, String password);--&gt;</span><br><span class="line">    &lt;select id=&quot;checkLogin&quot; resultType=&quot;User&quot;&gt;</span><br><span class="line">        &lt;!--</span><br><span class="line">        写：select * from t_user where username = #&#123;username&#125; and password = #&#123;password&#125;</span><br><span class="line">        会报错：Parameter &#x27;username&#x27; not found. Available parameters are [arg1, arg0, param1, param2]</span><br><span class="line">        因为sql语句没有解析成功--&gt;</span><br><span class="line">            &lt;!--以map集合形式存储，arg0-&gt;param1, arg1-&gt;param2，这时直接用键arg访问就好了，用param访问也行。</span><br><span class="line"></span><br><span class="line">以下两种方式选一个：--&gt;</span><br><span class="line">    select * from t_user where username = #&#123;arg0&#125; and password = #&#123;arg1&#125;</span><br><span class="line">    select * from t_user where username = &#x27;#&#123;param1&#125;&#x27; and password = &#x27;#&#123;param2&#125;&#x27;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>测试类：</p><pre><code>/** * 情况2：mapper接口方法的参数为多个时 * 此时MyBatis会将这些参数放在一个map集合中，以两种方式进行存储 * a》以arg0，arg1。。为键，参数为值 * b》以param0，param1。。为键，参数位置 * 因此只需要通过#&#123;&#125;和$&#123;&#125;以键的方式访问值即可，但需要注意$&#123;&#125;的单引号问题 */@Testpublic void testCheckLogin()&#123;    SqlSession sqlSession = SqlSessionUtils.getSqlSession();    ParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class);    User user = mapper.checkLogin(&quot;RUOYI&quot;,&quot;123456&quot;);    System.out.println(user);&#125;</code></pre><h3 id="情况3：map集合类型的参数"><a href="#情况3：map集合类型的参数" class="headerlink" title="情况3：map集合类型的参数"></a>情况3：map集合类型的参数</h3><p>若mapper接口中的方法需要的参数为多个时，此时可以<strong>手动创建map集合</strong>，将这些数据放在map中，只需要通过<code>$&#123;&#125;和#&#123;&#125;</code>访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号</p><blockquote><p>这次由我们创建 map 集合，map叫什么由我们来决定了</p></blockquote><p>ParameterMapper接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface ParameterMapper &#123;</span><br><span class="line">/**</span><br><span class="line">     * 验证登录</span><br><span class="line">     */</span><br><span class="line">    User checkLoginByMap(Map&lt;String, Object&gt; map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应在ParameterMapper.xml中配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--    User checkLoginByMap(Map&lt;String, Object&gt; map);--&gt;</span><br><span class="line">    &lt;select id=&quot;checkLoginByMap&quot; resultType=&quot;User&quot;&gt;</span><br><span class="line">        select * from t_user where username = #&#123;username&#125; and password = #&#123;password&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 情况3：若mapper接口方法的参数有多个时，可以手动将这些参数放在一个map中存储</span><br><span class="line"> * 只需要通过#&#123;&#125; $&#123;&#125;以键的方式访问值即可，但是需要注意$&#123;&#125;的单引号问题</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void testCheckLoginByMap()&#123;</span><br><span class="line">    SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">    ParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class);</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    map.put(&quot;username&quot;,&quot;RUOYI&quot;);</span><br><span class="line">    map.put(&quot;password&quot;,&quot;123456&quot;);</span><br><span class="line"></span><br><span class="line">    User user = mapper.checkLoginByMap(map);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="情况4-mapper接口方法的参数是实体类类型的参数"><a href="#情况4-mapper接口方法的参数是实体类类型的参数" class="headerlink" title="情况4:mapper接口方法的参数是实体类类型的参数"></a>情况4:mapper接口方法的参数是实体类类型的参数</h3><p>直接用类的对象来接受</p><p>ParameterMapper接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface ParameterMapper &#123;</span><br><span class="line">    /**</span><br><span class="line">    *</span><br><span class="line">    * 添加用户信息</span><br><span class="line">     /</span><br><span class="line">         int insertUser(User user);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>对应在ParameterMapper.xml中配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--        int insertUser(User user);--&gt;</span><br><span class="line">&lt;!--    找到相对应的get方法，如username-&gt;找getUsername()，看get/set方法--&gt;</span><br><span class="line">    &lt;insert id=&quot;insertUser&quot;&gt;</span><br><span class="line">        insert into t_user values(null, #&#123;username&#125;, #&#123;password&#125;, #&#123;age&#125;, #&#123;gender&#125;, #&#123;email&#125;)</span><br><span class="line">    &lt;/insert&gt;</span><br></pre></td></tr></table></figure><p>测试类：</p><pre><code>/** * 情况4：mapper接口方法的参数是实体类类型的参数（web从control层传过来的） * 只需要通过#&#123;&#125; $&#123;&#125;以属性的方式访问属性值即可，但是需要注意$&#123;&#125;的单引号问题 */@Testpublic void testInsertUser()&#123;    SqlSession sqlSession = SqlSessionUtils.getSqlSession();    ParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class);    User user = new User(null, &quot;Pandora&quot;, &quot;4444&quot;, 66, &quot;m&quot;, &quot;1111@gmail.com&quot;);    mapper.insertUser(user);&#125;</code></pre><h3 id="情况5-使用-Param标识参数"><a href="#情况5-使用-Param标识参数" class="headerlink" title="情况5: 使用@Param标识参数"></a>情况5: 使用@Param标识参数</h3><p>可以通过@Param注解标识mapper接口中的方法参数，此时，会将这些参数放在map集合中</p><ol><li>以@Param注解的 value 属性值为键，以参数为值；</li><li>以 param1，param2 … 为键，以参数为值</li></ol><p>只需要通过${}和#{}访问map集合的键就可以获取相对应的值， <strong>注意${}需要手动加单引号</strong><br>ParameterMapper接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface ParameterMapper &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 验证登录 （使用@Param）</span><br><span class="line">     */</span><br><span class="line">    User checkLoginByParam(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应在ParameterMapper.xml中配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--    以@Param的值为键，参数为值; 或以&quot;param1&quot;/&quot;param2&quot;为键，参数为值--&gt;</span><br><span class="line">&lt;!--    User checkLoginByParam(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password);--&gt;</span><br><span class="line">    &lt;select id=&quot;checkLoginByParam&quot; resultType=&quot;User&quot;&gt;</span><br><span class="line">        select * from t_user where username = #&#123;username&#125; and password = #&#123;password&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 情况5：使用@Param注解来命名参数</span><br><span class="line"> * 此时MyBatis会将这些参数放在一个map集合中，以两种方式进行存储</span><br><span class="line"> * a》以@Param的值为键，参数为值; @Param(value = &quot;xxx&quot;)</span><br><span class="line"> * b》以param0，param1...为键，参数为值</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void testCheckLoginByParam()&#123;</span><br><span class="line">    SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">    ParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class);</span><br><span class="line">    User user = mapper.checkLoginByParam(&quot;RUOYI&quot;,&quot;123456&quot;);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Param源码分析"><a href="#Param源码分析" class="headerlink" title="@Param源码分析"></a>@Param源码分析</h3><h1 id="MyBatis的各种查询功能"><a href="#MyBatis的各种查询功能" class="headerlink" title="MyBatis的各种查询功能"></a>MyBatis的各种查询功能</h1><p>MyBatis的各种查询功能: </p><ul><li><p>若查询出的数据只有一条，可以通过</p><ol><li>实体类对象接收</li><li>List集合接收</li><li>Map集合接收，结果<code>&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;</code></li></ol></li><li><p>若查询出的数据有多条，一定不能通过实体类对象接收，此时会抛异常TooManyResul tsException。</p><ol><li><p>实体类类型的LIst集合接收</p></li><li><p>Map类型的LIst集合接收</p></li><li><p>在mapper接口的方法上添加@MapKey注解</p><blockquote><p>@MapKey：声明Map，把原有的Map记录作为一个键，用来封装多条数据</p></blockquote></li></ol></li></ul><p><strong>接口类综合代码：</strong></p><p>public interface SelectMapper {<br>    &#x2F;**<br>     * 根据id查询用户信息<br>          *&#x2F;<br>        User getUserById(@Param(“id”) Integer id);</p><pre><code>/** * 查询所有用户信息 */List&lt;User&gt; getAllUser();/** * 查询用户信息的总记录数 */Integer getCount();/** * 根据id查询用户信息为一个map集合 */Map&lt;String, Object&gt; getUserByIdToMap(Integer id);/** * 查询所有用户信息为map集合 *///  List&lt;Map&lt;String, Object&gt;&gt; getAllUserToMap();    @MapKey(&quot;id&quot;)    Map&lt;String, Object&gt; getAllUserToMap();&#125; </code></pre><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">查询一个实体类对象</button></li><li class="tab"><button type="button" data-href="#test4-2">查询一个list集合</button></li><li class="tab"><button type="button" data-href="#test4-3">查询单个数据</button></li><li class="tab"><button type="button" data-href="#test4-4">查询一条数据为map集合</button></li><li class="tab"><button type="button" data-href="#test4-5">查询多条数据为map集合</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p>SelectMapper接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface SelectMapper &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 根据id查询用户信息</span><br><span class="line">     */</span><br><span class="line">    User getUserById(@Param(&quot;id&quot;) Integer id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--    User getUserById(@Param(&quot;id&quot;) Integer id);--&gt;</span><br><span class="line">    &lt;select id=&quot;getUserById&quot; resultType=&quot;User&quot;&gt;</span><br><span class="line">        select * from t_user where id = #&#123;id&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * MyBatis的各种查询功能：</span><br><span class="line"> * 1。 若查询出的数据只有一条，可以通过实体类对象 / list集合 / map集合 来接收</span><br><span class="line"> * 2。 若查询处的数据有多条，一定不能通过实体类对象来接收，此时会抛出TooManyResultsException</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void testGetUserById()&#123;</span><br><span class="line">    SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">    SelectMapper mapper = sqlSession.getMapper(SelectMapper.class);</span><br><span class="line">    User userById = mapper.getUserById(4);</span><br><span class="line">    System.out.println(userById);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><p>SelectMapper接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SelectMapper</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有用户信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">getAllUser</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    List&lt;User&gt; getAllUser();--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        select * from t_user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试类：</p><pre><code>/** * MyBatis的各种查询功能： * 1。 若查询出的数据只有一条，可以通过实体类对象 / list集合 / map集合 来接收 * 2。 若查询处的数据有多条，一定不能通过实体类对象来接收，此时会抛出TooManyResultsException */@Testpublic void testGetUserById(){    SqlSession sqlSession = SqlSessionUtils.getSqlSession();    SelectMapper mapper = sqlSession.getMapper(SelectMapper.class);    List&lt;User&gt; allUser = mapper.getAllUser();    allUser.forEach(user -&gt; System.out.println(user));}</code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-3"><p>SelectMapper接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SelectMapper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询用户信息的总记录数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Integer <span class="title function_">getCount</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--    Integer getCount();--&gt;</span><br><span class="line">&lt;!--    integer写大小写都可以，写 Integer/integer/_int/_integer  都可以，都是java.lang.Integer的别名--&gt;</span><br><span class="line">    &lt;select id=&quot;getCount&quot; resultType=&quot;java.lang.Integer&quot;&gt;</span><br><span class="line">        select count(*) from t_user</span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure><p>测试类：</p><pre><code>/** * 获取记录数 * * MyBatis中设置了默认的类型别名 * Java.lang.Integer -&gt; int, integer * int -&gt; _int, _integer * Map -&gt; map * List -&gt; list */@Testpublic void testGetCount(){    SqlSession sqlSession = SqlSessionUtils.getSqlSession();    SelectMapper mapper = sqlSession.getMapper(SelectMapper.class);    System.out.println(mapper.getCount());}</code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-4"><p>SelectMapper接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface SelectMapper &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 根据id查询用户信息为一个map集合</span><br><span class="line">     */</span><br><span class="line">    Map&lt;String, Object&gt; getUserByIdToMap(Integer id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--        Map&lt;String, Object&gt; getUserByIdToMap(Integer id);--&gt;</span><br><span class="line">&lt;select id=&quot;getUserByIdToMap&quot; resultType=&quot;map&quot;&gt;</span><br><span class="line">    select * from t_user where id = #&#123;id&#125;</span><br><span class="line">&lt;/select&gt;  </span><br></pre></td></tr></table></figure><p>测试类：</p><pre><code>/** * 如果没有实体类对象，就把它映射成map集合 * 从数据库中查询数据，将其映射为map集合 * 例如把它传到网页端，就映射成json对象，所以转成map很常用 * * 以字段为键 */@Testpublic void testgetUserByIdToMap(){    SqlSession sqlSession = SqlSessionUtils.getSqlSession();    SelectMapper mapper = sqlSession.getMapper(SelectMapper.class);    System.out.println(mapper.getUserByIdToMap(4));}</code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-5"><p>SelectMapper接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface SelectMapper &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 查询所有用户信息为map集合，每一条记录是一个map</span><br><span class="line">     */</span><br><span class="line">     //方式一：</span><br><span class="line">//    List&lt;Map&lt;String, Object&gt;&gt; getAllUserToMap();</span><br><span class="line"></span><br><span class="line">//方式二：</span><br><span class="line">    @MapKey(&quot;id&quot;)</span><br><span class="line">    Map&lt;String, Object&gt; getAllUserToMap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--        Map&lt;String, Object&gt; getAllUserToMap();--&gt;</span><br><span class="line">    &lt;select id=&quot;getAllUserToMap&quot; resultType=&quot;map&quot;&gt;</span><br><span class="line">        select * from t_user</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void testgetAllUser()&#123;</span><br><span class="line">    SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">    SelectMapper mapper = sqlSession.getMapper(SelectMapper.class);</span><br><span class="line">    System.out.println(mapper.getAllUserToMap());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="常用类型别名"><a href="#常用类型别名" class="headerlink" title="常用类型别名"></a>常用类型别名</h2><p>别名不区分大小写</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310191546383.png"></p><h1 id="自定义映射resultMap"><a href="#自定义映射resultMap" class="headerlink" title="自定义映射resultMap"></a>自定义映射resultMap</h1><p>默认映射：名字一样就映射上</p><h2 id="字段和属性的映射关系"><a href="#字段和属性的映射关系" class="headerlink" title="字段和属性的映射关系"></a>字段和属性的映射关系</h2><p>字段名和实体类中的属性名可能不一致，二者命名规则不同</p><ol><li>字段名符合数据库的规则(使用_)</li><li>实体类中的属性名符合Java的规则(使用驼峰)</li></ol><blockquote><p>此时大概率不会报错，但是找不到的添null，找得到的添加匹配值</p></blockquote><p>有三中解决方式：</p><ol><li><p>可以通过为字段起别名的方式（sql 起别名），保证和实体类中的属性名保持一致</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;getAllEmp&quot; resultType=&quot;Emp&quot;&gt;</span><br><span class="line">        select eid, emp_name empName, age, sex, email from t_emp</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>可以在MyBatis的<strong>核心配置文件</strong>中设置一个全局配置信息mapUnderscoreToCamelCase，可 以在查询表中数据时，自动将 _ 类型的字段名转换为驼峰，日志输出的时候也会转换</p><p>注意核心配置文件中的顺序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--    设置MyBatis的全剧配置--&gt;</span><br><span class="line">    &lt;settings&gt;</span><br><span class="line">&lt;!--        将下划线自动映射成驼峰，比如emp_name -&gt; empName --&gt;</span><br><span class="line">        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;/settings&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>例.字段名user_name，设置了mapUnderscoreToCamelCase，此时字段名就会转换为 userName</p></blockquote></li><li><p>逐一设置resultMap映射关系</p><p>在resultMap中，一一对应地设置属性名 字段名，再在 select标签中添加 resultMap&#x3D;”对应resultMap的id”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">        resultMap设置自定义映射关系</span><br><span class="line">        id      唯一标识</span><br><span class="line">        type    映射的实体类型</span><br><span class="line"></span><br><span class="line">        子标签：id 设置主键的映射关系， result设置其他的映射关系</span><br><span class="line">            property    设置映射关系中的属性名，必须是type属性所设置的实体类类型的属性名</span><br><span class="line">            column      设置映射关系中的字段名，必须是sql语句查询出来的字段名</span><br><span class="line"></span><br><span class="line">        如果使用resultMap，就所有属性都需要设置</span><br><span class="line">--&gt;</span><br><span class="line">    &lt;resultMap id=&quot;empResultMap&quot; type=&quot;Emp&quot;&gt;</span><br><span class="line">        &lt;id property=&quot;eid&quot; column=&quot;eid&quot;&gt;&lt;/id&gt;</span><br><span class="line">        &lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=&quot;age&quot; column=&quot;age&quot;&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=&quot;email&quot; column=&quot;email&quot;&gt;&lt;/result&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=&quot;getAllEmp&quot; resultMap=&quot;empResultMap&quot;&gt;</span><br><span class="line">        select * from t_emp</span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="多对一的映射"><a href="#多对一的映射" class="headerlink" title="多对一的映射"></a>多对一的映射</h2><p>需要查询一对多、多对一的关系，需要在“一”的pojo中加入List&lt;多&gt;属性，在“多”的pojo中加入“一”。<br>也就是说，在Dept类中，要加入private List&lt; Emp &gt; emps；在Emp类中，要加入private Dept dept;。然后给他们各自添加get、set方法，重写构造器和toString()</p><ol><li><p>级联方式处理映射关系</p><p>EmpMapper.xml中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--    多对一映射关系，方式一：级联属性赋值--&gt;</span><br><span class="line">    &lt;resultMap id=&quot;getEmpAndDeptResultMapOne&quot; type=&quot;Emp&quot;&gt;</span><br><span class="line">        &lt;id property=&quot;eid&quot; column=&quot;eid&quot;&gt;&lt;/id&gt;</span><br><span class="line">        &lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=&quot;age&quot; column=&quot;age&quot;&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=&quot;email&quot; column=&quot;email&quot;&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=&quot;dept.did&quot; column=&quot;did&quot;&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=&quot;dept.deptName&quot; column=&quot;dept_name&quot;&gt;&lt;/result&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--        Emp getEmpAndDept(@Param(&quot;eid&quot;) Integer eid);--&gt;</span><br><span class="line">    &lt;select id=&quot;getEmpAndDept&quot; resultMap=&quot;getEmpAndDeptResultMapOne&quot;&gt;</span><br><span class="line">        select * from t_emp left join t_dept</span><br><span class="line">            on t_emp.eid = t_dept.did WHERE t_emp.eid = #&#123;eid&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>EmpMapper类中:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface EmpMapper &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 查询员工及其所对应的部门信息</span><br><span class="line">     */</span><br><span class="line">    Emp getEmpAndDept(@Param(&quot;eid&quot;) Integer eid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 处理多对一的映射关系</span><br><span class="line"> * a&gt; 级联属性赋值</span><br><span class="line"> * b&gt; association</span><br><span class="line"> * c&gt; 分步查询</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void testGetEmpAndDept()&#123;</span><br><span class="line">    SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">    EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);</span><br><span class="line">    Emp empAndDept = mapper.getEmpAndDept(3);</span><br><span class="line">    System.out.println(empAndDept);</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure></li><li><p>使用association处理映射关系</p><p>EmpMapper.xml:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap id=&quot;empDeptMap&quot; type=&quot;Emp&quot;&gt;</span><br><span class="line">    &lt;id column=&quot;eid&quot; property=&quot;eid&quot;&gt;&lt;/id&gt;</span><br><span class="line">    &lt;result column=&quot;ename&quot; property=&quot;ename&quot;&gt;&lt;/result&gt;</span><br><span class="line">    &lt;result column=&quot;age&quot; property=&quot;age&quot;&gt;&lt;/result&gt;</span><br><span class="line">    &lt;result column=&quot;sex&quot; property=&quot;sex&quot;&gt;&lt;/result&gt;</span><br><span class="line">    &lt;association property=&quot;dept&quot; javaType=&quot;Dept&quot;&gt;</span><br><span class="line">        &lt;id column=&quot;did&quot; property=&quot;did&quot;&gt;&lt;/id&gt;</span><br><span class="line">        &lt;result column=&quot;dname&quot; property=&quot;dname&quot;&gt;&lt;/result&gt;</span><br><span class="line">    &lt;/association&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line">&lt;!--Emp getEmpAndDeptByEid(@Param(&quot;eid&quot;) int eid);--&gt;</span><br><span class="line">&lt;select id=&quot;getEmpAndDeptByEid&quot; resultMap=&quot;empDeptMap&quot;&gt;</span><br><span class="line">    select emp.*,dept.* from t_emp emp left join t_dept dept on emp.did =</span><br><span class="line">dept.did where emp.eid = #&#123;eid&#125;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>分步查询</p><p>查询员工信息</p><p>EmpMapper类中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface EmpMapper &#123;</span><br><span class="line">/**</span><br><span class="line">* 通过分步查询查询员工信息 * @param eid</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">Emp getEmpByStep(@Param(&quot;eid&quot;) int eid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>EmpMapper.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--    com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo是这条sql语句的全类名--&gt;</span><br><span class="line">    &lt;resultMap id=&quot;getEmpAndDeptByStepResultMap&quot; type=&quot;Emp&quot;&gt;</span><br><span class="line">        &lt;id property=&quot;eid&quot; column=&quot;eid&quot;&gt;&lt;/id&gt;</span><br><span class="line">        &lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=&quot;age&quot; column=&quot;age&quot;&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt;</span><br><span class="line">        &lt;result property=&quot;email&quot; column=&quot;email&quot;&gt;&lt;/result&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">        select: 设置分步查询的sql的唯一标识（namespace.SQLId或mapper接口的全类名.方法名）</span><br><span class="line">        column：分步查询的条件</span><br><span class="line">        fetchType: 当开启了全局的延迟记载后，可通过此属性手动控制延迟加载的效果</span><br><span class="line">        fetchType：&quot;lazy/eager&quot; lazy表示延迟加载，eager表示立即加载</span><br><span class="line">--&gt;</span><br><span class="line">        &lt;association property=&quot;dept&quot;</span><br><span class="line">                     select=&quot;com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo&quot;</span><br><span class="line">                     column=&quot;did&quot;</span><br><span class="line">                     fetchType=&quot;eager&quot;&gt;</span><br><span class="line">        &lt;/association&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line">    </span><br><span class="line">&lt;!--    Emp getEmpAndDeptByStepOne(@Param(&quot;eid&quot;) Integer eid);--&gt;</span><br><span class="line">    &lt;select id=&quot;getEmpAndDeptByStepOne&quot; resultMap=&quot;getEmpAndDeptByStepResultMap&quot;&gt;</span><br><span class="line">        select * from t_emp where eid = #&#123;eid&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 根据员工所对应的部门id查询部门信息</p><p>DeptMapper接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface DeptMapper &#123;</span><br><span class="line">/**</span><br><span class="line">* 分步查询的第二步:根据员工所对应的did查询部门信息</span><br><span class="line">*/</span><br><span class="line">Dept getEmpDeptByStep(@Param(&quot;did&quot;) int did);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>DeptMapper.xml:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--        Dept getEmpAndDeptByStepTwo(Integer did);--&gt;</span><br><span class="line">&lt;!--    分步查询可以实现懒加载--&gt;</span><br><span class="line">    &lt;select id=&quot;getEmpAndDeptByStepTwo&quot; resultType=&quot;Dept&quot;&gt;</span><br><span class="line">        select * from t_dept where did = #&#123;did&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h3><p>分步查询的优点:可以实现延迟加载，但是必须在核心配置文件中设置全局配置信息:</p><p>lazyLoadingEnabled：延迟加载的全局开关。当开启时，所有关联对象都会延迟加载<br>aggressiveLazyLoading:当开启时，任何方法的调用都会加载该对象的所有属性。 否则，每个属性会按需加载。此时就可以实现按需加载，获取的数据是什么，就只会执行相应的sql。此时可通过association和 collection中的fetchType属性设置当前的分步查询是否使用延迟加载，fetchType&#x3D;“lazy(延迟加 载)|eager(立即加载)”</p><h2 id="一对多的映射"><a href="#一对多的映射" class="headerlink" title="一对多的映射"></a>一对多的映射</h2><p> 需要查询一对多、多对一的关系，需要在“一”的pojo中加入List&lt;多&gt;属性，在“多”的pojo中加入“一”。</p><p>也就是说，在Dept类中，要加入<code>private List&lt;Emp&gt; emps;</code>；在Emp类中，要加入<code>private Dept dept;</code>。然后给他们各自添加get、set方法，重写构造器和toString()</p><h3 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h3><p>DeptMapper接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DeptMapper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取部门以及部门中所有的员工信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Dept <span class="title function_">getDeptAndEmp</span><span class="params">(<span class="meta">@Param(&quot;did&quot;)</span> Integer did)</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>DeptMapper.xml</p><pre><code>    &lt;resultMap id=&quot;deptAndEmpResultMap&quot; type=&quot;Dept&quot;&gt;        &lt;id property=&quot;did&quot; column=&quot;did&quot;&gt;&lt;/id&gt;        &lt;result property=&quot;deptName&quot; column=&quot;dept_name&quot;&gt;&lt;/result&gt;&lt;!--            collection：处理一对多的映射关系            ofType：表示该属性对应的集合中存储数据的类型--&gt;        &lt;collection property=&quot;emps&quot; ofType=&quot;Emp&quot;&gt;            &lt;id property=&quot;eid&quot; column=&quot;eid&quot;&gt;&lt;/id&gt;            &lt;result property=&quot;empName&quot; column=&quot;emp_name&quot;&gt;&lt;/result&gt;            &lt;result property=&quot;age&quot; column=&quot;age&quot;&gt;&lt;/result&gt;            &lt;result property=&quot;sex&quot; column=&quot;sex&quot;&gt;&lt;/result&gt;            &lt;result property=&quot;email&quot; column=&quot;email&quot;&gt;&lt;/result&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;&lt;!--        Dept getDeptAndEmp(@Param(&quot;did&quot;) Integer did);--&gt;    &lt;select id=&quot;getDeptAndEmp&quot; resultMap=&quot;deptAndEmpResultMap&quot;&gt;        select * from t_dept left join t_emp on t_dept.did = t_emp.did where t_dept.did = #&#123;did&#125;    &lt;/select&gt;</code></pre><p>测试类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testGetDeptAndEmp()&#123;</span><br><span class="line">        SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">        DeptMapper mapper = sqlSession.getMapper(DeptMapper.class);</span><br><span class="line">        Dept dept = mapper.getDeptAndEmp(1);</span><br><span class="line">        System.out.println(dept);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="分步查询"><a href="#分步查询" class="headerlink" title="分步查询"></a>分步查询</h3><ol><li><p>查询部门信息</p><p>DeptMapper接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface DeptMapper &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 分步查询 查询部门及其所有的员工信息</span><br><span class="line">     * 第一步  查询部门信息</span><br><span class="line">     */</span><br><span class="line">    Dept getDeptAndEmoByStepOne(@Param(&quot;did&quot;) Integer did);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>DeptMapper.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--    分步查询--&gt;</span><br><span class="line">    &lt;resultMap id=&quot;deptAndEmoByStepOneMap&quot; type=&quot;Dept&quot;&gt;</span><br><span class="line">        &lt;id property=&quot;did&quot; column=&quot;did&quot;&gt;&lt;/id&gt;</span><br><span class="line">        &lt;result property=&quot;deptName&quot; column=&quot;dept_name&quot;&gt;&lt;/result&gt;</span><br><span class="line">        &lt;collection property=&quot;emps&quot;</span><br><span class="line">                    select=&quot;com.atguigu.mybatis.mapper.EmpMapper.getDeptAndEmpByStepTwo&quot;</span><br><span class="line">                    column=&quot;did&quot;&gt;</span><br><span class="line">        &lt;/collection&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line">&lt;!--        Dept getDeptAndEmoByStepOne(@Param(&quot;did&quot;) Integer did);--&gt;</span><br><span class="line">    &lt;select id=&quot;getDeptAndEmoByStepOne&quot; resultMap=&quot;deptAndEmoByStepOneMap&quot;&gt;</span><br><span class="line">        select * from t_dept where did = #&#123;did&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>根据部门id查询部门中的所有员工</p><p>EmpMapper</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface EmpMapper &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 分步查询 查询部门及其所有的员工信息</span><br><span class="line">     * 第一步  查询部门信息</span><br><span class="line">     * 第二步  根据查询员工信息</span><br><span class="line">     */</span><br><span class="line">    List&lt;Emp&gt; getDeptAndEmpByStepTwo(@Param(&quot;did&quot;) Integer did);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>EmpMapper.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--    分步查询--&gt;</span><br><span class="line">&lt;!--    List&lt;Emp&gt; getDeptAndEmpByStepTwo(@Param(&quot;did&quot;) Integer did);--&gt;</span><br><span class="line">    &lt;select id=&quot;getDeptAndEmpByStepTwo&quot; resultType=&quot;Emp&quot;&gt;</span><br><span class="line">        select * from t_emp where did = #&#123;did&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>测试类</p></li></ol>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testGetDeptAndEmpBySteps()&#123;</span><br><span class="line">    SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">    DeptMapper mapper = sqlSession.getMapper(DeptMapper.class);</span><br><span class="line">    Dept dept = mapper.getDeptAndEmoByStepOne(2);</span><br><span class="line">    System.out.println(dept.getDeptName());</span><br><span class="line">    System.out.println(&quot;-----****************======分割线=======-----****************&quot;);</span><br><span class="line">    System.out.println(dept);</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure><h1 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h1><p>动态SQL技术是一种根据特定条件动态拼装SQL语句的功能，它存在的意义是为了<strong>解决拼接SQL语句字符串时的痛点问题。</strong></p><p>如：第一个属性为空，但是后面有值，就会在where 后面直接跟着一个 and，sql语句会报错</p><h2 id="if标签"><a href="#if标签" class="headerlink" title="if标签"></a>if标签</h2><p>if标签可通过test属性的表达式进行判断，若表达式的结果为true，则标签中的内容会执行；反之标签中的内容不会执行</p><p>DynamicSqlMapper接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface DynamicSQLMapper &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 多条件查询</span><br><span class="line">     */</span><br><span class="line">    List&lt;Emp&gt; getEmpByCondition(Emp emp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>DynamicSqlMapper.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--        List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;</span><br><span class="line">&lt;!--    加上1=1使得：即使emp_name为空，也不会导致sql语句变成：where and xxx--&gt;</span><br><span class="line">    &lt;select id=&quot;getEmpByCondition&quot; resultType=&quot;Emp&quot;&gt;</span><br><span class="line">        select * from t_emp where 1=1</span><br><span class="line">        &lt;if test=&quot;empName != null and empName != &#x27;&#x27;&quot;&gt;</span><br><span class="line">            and emp_name = #&#123;empName&#125;</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">        &lt;if test=&quot;age != null and age != &#x27;&#x27;&quot;&gt;</span><br><span class="line">            and age = #&#123;age&#125;</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">        &lt;if test=&quot;email != null and email != &#x27;&#x27;&quot;&gt;</span><br><span class="line">            and email = #&#123;email&#125;</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">        &lt;if test=&quot;sex != null and sex != &#x27;&#x27;&quot;&gt;</span><br><span class="line">            and sex = #&#123;sex&#125;</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 动态sql</span><br><span class="line"> * 1： if： 根据标签中test属性所对应的内容决定标签中的内容是否拼接在sql语句中</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void testGetEmpByCondition()&#123;</span><br><span class="line">    SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">    DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);</span><br><span class="line">    // 各信息都不为null/空字符串</span><br><span class="line">    List&lt;Emp&gt; emp1 = mapper.getEmpByCondition(new Emp(null, &quot;Apple&quot;, 22, &quot;女&quot;, &quot;123@gmail.com&quot;));</span><br><span class="line">    // 中间存在查询出来是空，可能导致&quot;select * from t_emp where emp_name= ? and and sex = ?...&quot;的and和and在一起的情况</span><br><span class="line">    List&lt;Emp&gt; emp2 = mapper.getEmpByCondition(new Emp(null, &quot;Apple&quot;, null, &quot;女&quot;, &quot;123@gmail.com&quot;));</span><br><span class="line">    // 第一个查询条件为空字符串，可能导致&quot;select * from t_emp where and age = ? and ...&quot;的where和and在一起的情况</span><br><span class="line">    List&lt;Emp&gt; emp3 = mapper.getEmpByCondition(new Emp(null, null, null, &quot;女&quot;, &quot;123@gmail.com&quot;));        System.out.println(emp1);</span><br><span class="line">    System.out.println(emp1);</span><br><span class="line">    System.out.println(emp2);</span><br><span class="line">    System.out.println(emp3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if拼接就会出现上面例子中的情况，可以用类似sql注入的方法加一个 1and 1，解决这个问题，但是这个方法本来就是有问题的</p><h2 id="where"><a href="#where" class="headerlink" title="where"></a>where</h2><p>应用场景：多条件查询</p><p>DynamicSqlMapper接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface DynamicSQLMapper &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 多条件查询</span><br><span class="line">     */</span><br><span class="line">    List&lt;Emp&gt; getEmpByCondition(Emp emp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>DynamicSqlMapper.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--    where标签中，如果有内容，则添加关键字，如果没有内容，则把and/or去掉--&gt;</span><br><span class="line">    &lt;select id=&quot;getEmpByCondition&quot; resultType=&quot;Emp&quot;&gt;</span><br><span class="line">        select * from t_emp</span><br><span class="line">        &lt;where&gt;</span><br><span class="line">            &lt;if test=&quot;empName != null and empName != &#x27;&#x27;&quot;&gt;</span><br><span class="line">                and emp_name = #&#123;empName&#125;</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">            &lt;if test=&quot;age != null and age != &#x27;&#x27;&quot;&gt;</span><br><span class="line">                and age = #&#123;age&#125;</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">            &lt;if test=&quot;email != null and email != &#x27;&#x27;&quot;&gt;</span><br><span class="line">                and email = #&#123;email&#125;</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">            &lt;if test=&quot;sex != null and sex != &#x27;&#x27;&quot;&gt;</span><br><span class="line">                and sex = #&#123;sex&#125;</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">        &lt;/where&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 2、where：</span><br><span class="line"> *      当where标签中有内容时，会自动生成where关键字，并将内容前多余的and或or去掉</span><br><span class="line"> *      当where标签中没有内容时，此时where标签没有任何效果</span><br><span class="line"> *          注意：where标签不能将其中内容后面多余的and或or去掉</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void testGetEmpByCondition2()&#123;</span><br><span class="line">    SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">    DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);</span><br><span class="line">    // 各信息都不为null/空字符串</span><br><span class="line">    List&lt;Emp&gt; emp1 = mapper.getEmpByCondition(new Emp(null, &quot;Apple&quot;, 22, &quot;女&quot;, &quot;123@gmail.com&quot;));</span><br><span class="line">    // 中间存在查询出来是空，可能导致&quot;select * from t_emp where emp_name= ? and and sex = ?...&quot;的and和and在一起的情况</span><br><span class="line">    List&lt;Emp&gt; emp2 = mapper.getEmpByCondition(new Emp(null, &quot;Apple&quot;, null, &quot;女&quot;, &quot;123@gmail.com&quot;));</span><br><span class="line">    // 第一个查询条件为空字符串，可能导致&quot;select * from t_emp where and age = ? and ...&quot;的where和and在一起的情况</span><br><span class="line">    List&lt;Emp&gt; emp3 = mapper.getEmpByCondition(new Emp(null, null, null, &quot;女&quot;, &quot;123@gmail.com&quot;));        System.out.println(emp1);</span><br><span class="line">    System.out.println(emp1);</span><br><span class="line">    System.out.println(emp2);</span><br><span class="line">    System.out.println(emp3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h2><p>应用场景：多条件查询</p><p>DynamicSqlMapper接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface DynamicSQLMapper &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 多条件查询</span><br><span class="line">     */</span><br><span class="line">    List&lt;Emp&gt; getEmpByCondition(Emp emp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>DynamicSqlMapper.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;getEmpByCondition&quot; resultType=&quot;Emp&quot;&gt;</span><br><span class="line">    select * from t_emp</span><br><span class="line">    &lt;trim prefix=&quot;where&quot; suffixOverrides=&quot;and|or&quot;&gt;</span><br><span class="line">        &lt;if test=&quot;empName != null and empName != &#x27;&#x27;&quot;&gt;</span><br><span class="line">            emp_name = #&#123;empName&#125; and</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">        &lt;if test=&quot;age != null and age != &#x27;&#x27;&quot;&gt;</span><br><span class="line">            age = #&#123;age&#125; or</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">        &lt;if test=&quot;email != null and email != &#x27;&#x27;&quot;&gt;</span><br><span class="line">            email = #&#123;email&#125; and</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">        &lt;if test=&quot;sex != null and sex != &#x27;&#x27;&quot;&gt;</span><br><span class="line">            sex = #&#123;sex&#125;</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">    &lt;/trim&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 3、trim</span><br><span class="line"> *      若标签中有内容时：</span><br><span class="line"> *          prefix/suffix   在trim标签中内容前面或后面 去添加指定内容</span><br><span class="line"> *          prefixOverrides/suffixOverrides   在trim标签中内容前面或后面 去删掉指定内容</span><br><span class="line"> *      若标签中没有内容时：trim标签也没有任何效果</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void testGetEmpByCondition3()&#123;</span><br><span class="line">    SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">    DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);</span><br><span class="line">    // 各信息都不为null/空字符串</span><br><span class="line">    List&lt;Emp&gt; emp1 = mapper.getEmpByCondition(new Emp(null, &quot;Apple&quot;, 22, &quot;女&quot;, &quot;123@gmail.com&quot;));</span><br><span class="line">    // 中间存在查询出来是空，可能导致&quot;select * from t_emp where emp_name= ? and and sex = ?...&quot;的and和and在一起的情况</span><br><span class="line">    List&lt;Emp&gt; emp2 = mapper.getEmpByCondition(new Emp(null, &quot;Apple&quot;, null, &quot;女&quot;, &quot;123@gmail.com&quot;));</span><br><span class="line">    // 第一个查询条件为空字符串，可能导致&quot;select * from t_emp where and age = ? and ...&quot;的where和and在一起的情况</span><br><span class="line">    List&lt;Emp&gt; emp3 = mapper.getEmpByCondition(new Emp(null, null, null, &quot;女&quot;, &quot;123@gmail.com&quot;));</span><br><span class="line">    System.out.println(emp1);</span><br><span class="line">    System.out.println(emp2);</span><br><span class="line">    System.out.println(emp3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="choose-when-otherwise"><a href="#choose-when-otherwise" class="headerlink" title="choose-when-otherwise"></a>choose-when-otherwise</h2><p><strong>choose、when、otherwise相当于if…else if…else</strong></p><p>DynamicSqlMapper接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface DynamicSQLMapper &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 测试choose when otherwise</span><br><span class="line">     */</span><br><span class="line">    List&lt;Emp&gt; getEmpByChoose(Emp emp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>DynamicSqlMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--        List&lt;Emp&gt; getEmpByChoose(Emp emp);--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByChoose&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">        select * from t_emp</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;empName != null and empName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">                    emp_name = #&#123;empName&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">                    age = #&#123;age&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;sex != null and sex != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">                    sex = #&#123;sex&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;email != null and email != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">                    email = #&#123;email&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">                    did = 2</span><br><span class="line">                <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 4、choose/when/otherwise: 相当于if..else if..else</span><br><span class="line"> *  when至少要有一个， otherwise最有只能有一个</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void testGetEmpByChoose()&#123;</span><br><span class="line">    SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">    DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);</span><br><span class="line">    // 各信息都不为null/空字符串</span><br><span class="line">    List&lt;Emp&gt; emp1 = mapper.getEmpByChoose(new Emp(null, &quot;Apple&quot;, 22, &quot;女&quot;, &quot;123@gmail.com&quot;));</span><br><span class="line">    // 中间存在查询出来是空，可能导致&quot;select * from t_emp where emp_name= ? and and sex = ?...&quot;的and和and在一起的情况</span><br><span class="line">    List&lt;Emp&gt; emp2 = mapper.getEmpByChoose(new Emp(null, &quot;Apple&quot;, null, &quot;女&quot;, &quot;123@gmail.com&quot;));</span><br><span class="line">    // 第一个查询条件为空字符串，可能导致&quot;select * from t_emp where and age = ? and ...&quot;的where和and在一起的情况</span><br><span class="line">    List&lt;Emp&gt; emp3 = mapper.getEmpByChoose(new Emp(null, null, null, &quot;&quot;, &quot;&quot;));</span><br><span class="line">    System.out.println(emp1);</span><br><span class="line">    System.out.println(emp2);</span><br><span class="line">    System.out.println(emp3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><p><strong>应用场景1：</strong> 通过数组实现批量删除</p><p>DynamicSqlMapper接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface DynamicSQLMapper &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 通过数组实现批量删除</span><br><span class="line">     */</span><br><span class="line">    int deleteMoreByArray(@Param(&quot;eids&quot;) Integer[] eids);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>DynamicSqlMapper.xml<br>方法一：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--        int deleteMoreByArray(Integer[] eids);--&gt;</span><br><span class="line">&lt;!--    没加@Param时，</span><br><span class="line">        报错：Parameter &#x27;eids&#x27; not found. Available parameters are [array, arg0]</span><br><span class="line">        因此最好都加上@Param--&gt;</span><br><span class="line">&lt;!--        int deleteMoreByArray(@Param(&quot;eids&quot;) Integer[] eids);--&gt;</span><br><span class="line">    &lt;delete id=&quot;deleteMoreByArray&quot;&gt;</span><br><span class="line">        delete from t_emp where eid in</span><br><span class="line">            &lt;foreach collection=&quot;eids&quot; item=&quot;eid&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt;</span><br><span class="line">                #&#123;eid&#125;</span><br><span class="line">    &lt;/foreach&gt;</span><br><span class="line">    &lt;/delete&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--        int deleteMoreByArray(Integer[] eids);--&gt;</span><br><span class="line">    &lt;delete id=&quot;deleteMoreByArray&quot;&gt;</span><br><span class="line">    &lt;!--方法2：--&gt;</span><br><span class="line">        delete from t_emp where</span><br><span class="line">        &lt;foreach collection=&quot;eids&quot;  item=&quot;eid&quot; separator=&quot;or&quot;&gt;</span><br><span class="line">            eid = #&#123;eid&#125;</span><br><span class="line">        &lt;/foreach&gt;</span><br><span class="line">    &lt;/delete&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 5、foreach</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void testDeleteMoreByArray()&#123;</span><br><span class="line">    SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">    DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);</span><br><span class="line">    int result = mapper.deleteMoreByArray(new Integer[]&#123;7, 8, 9&#125;);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>应用场景2：</strong> 通过list集合实现批量添加</p><p>DynamicSqlMapper接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface DynamicSQLMapper &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 通过list集合实现批量添加</span><br><span class="line">     */</span><br><span class="line">    int insertMoreByList(@Param(&quot;emps&quot;) List&lt;Emp&gt; emps);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>DynamicSqlMapper.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--        int insertMoreByList(List&lt;Emp&gt; emps);--&gt;</span><br><span class="line">&lt;!--    不加注解会报错：Parameter &#x27;emps&#x27; not found. Available parameters are [arg0, collection, list]--&gt;</span><br><span class="line">&lt;!--    int insertMoreByList(@Param(&quot;emps&quot;) List&lt;Emp&gt; emps);--&gt;</span><br><span class="line">    &lt;insert id=&quot;insertMoreByList&quot;&gt;</span><br><span class="line">        insert into t_emp values</span><br><span class="line">        &lt;foreach collection=&quot;emps&quot; item=&quot;emp&quot; separator=&quot;,&quot;&gt;</span><br><span class="line">            (null, #&#123;emp.empName&#125;, #&#123;emp.age&#125;, #&#123;emp.sex&#125;, #&#123;emp.email&#125;, null)</span><br><span class="line">        &lt;/foreach&gt;</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 5、foreach</span><br><span class="line"> *      collection  需要循环的数组或集合</span><br><span class="line"> *      item        表示数组或集合中的每一个数据</span><br><span class="line"> *      separator   循环体之间的分隔符</span><br><span class="line"> *      open        foreach标签所循环的所有内容的开始符</span><br><span class="line"> *      close       foreach标签所循环的所有内容的结束符</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void testInsertMoreByList()&#123;</span><br><span class="line">    SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">    DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);</span><br><span class="line">    Emp emp1 = new Emp(null, &quot;Mary&quot;, 23, &quot;女&quot;, &quot;11111@qq.com&quot;);</span><br><span class="line">    Emp emp2 = new Emp(null, &quot;Linda&quot;, 23, &quot;女&quot;, &quot;1144111@qq.com&quot;);</span><br><span class="line">    Emp emp3 = new Emp(null, &quot;Jackoline&quot;, 23, &quot;女&quot;, &quot;1122111@qq.com&quot;);</span><br><span class="line">    List&lt;Emp&gt; emps = Arrays.asList(emp1, emp2, emp3);</span><br><span class="line">    System.out.println(mapper.insertMoreByList(emps));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="sql片段-include"><a href="#sql片段-include" class="headerlink" title="sql片段 include"></a>sql片段 include</h2><p>应用场景：获取所有员工的某些信息</p><p>DynamicSqlMapper接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface DynamicSQLMapper &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 获取所有员工的某些信息</span><br><span class="line">     */</span><br><span class="line">    List&lt;Emp&gt; getAllEmpNameAndAge();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>DynamicSqlMapper.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--    sql片段--&gt;</span><br><span class="line">&lt;!--        List&lt;Emp&gt; getAllEmpNameAndAge();--&gt;</span><br><span class="line">    &lt;sql id=&quot;empColumns&quot;&gt;emp_name, age&lt;/sql&gt;</span><br><span class="line">    &lt;select id=&quot;getAllEmpNameAndAge&quot; resultType=&quot;Emp&quot;&gt;</span><br><span class="line">        select &lt;include refid=&quot;empColumns&quot;&gt;&lt;/include&gt; from t_emp</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 6、sql片段</span><br><span class="line"> *   设置：</span><br><span class="line"> *   &lt;sql id=&quot;empColumns&quot;&gt;emp_name, age&lt;/sql&gt;</span><br><span class="line"> *   使用：</span><br><span class="line"> *   select &lt;include refid=&quot;empColumns&quot;&gt;&lt;/include&gt; from t_emp</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void testGetAllEmp()&#123;</span><br><span class="line">    SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">    DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class);</span><br><span class="line">    System.out.println(mapper.getAllEmpNameAndAge());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Mybatis的缓存"><a href="#Mybatis的缓存" class="headerlink" title="Mybatis的缓存"></a>Mybatis的缓存</h1><h2 id="MyBatis的一级缓存"><a href="#MyBatis的一级缓存" class="headerlink" title="MyBatis的一级缓存"></a>MyBatis的一级缓存</h2><p>一级缓存是SqlSession级别的，通过<strong>同一个SqlSession 对象</strong>查询的数据会被缓存，下次查询<strong>相同的数据</strong>，就 会从缓存中直接获取，不会从数据库重新访问。一级缓存默认开启</p><p>使一级缓存失效的四种情况:</p><ol><li><p>不同的SqlSession对应不同的一级缓存</p><blockquote><p>一级缓存的范围是SqlSession，不同的SqlSession对应不同的一级缓存</p></blockquote></li><li><p>同一个SqlSession但是查询条件不同</p></li><li><p>同一个SqlSession两次查询期间执行了任何一次增删改操作</p><blockquote><p>为了确保数据的正确，只要一改就会清空，后面二级缓存也一样</p></blockquote></li><li><p>同一个SqlSession两次查询期间手动清空了缓存</p></li></ol><p>不同的SqlSession对应不同的一级缓存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testCache()&#123;</span><br><span class="line">    SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">    CacheMapper mapper = sqlSession.getMapper(CacheMapper.class);</span><br><span class="line">    Emp emp1 = mapper.getEmpById(3);</span><br><span class="line">    System.out.println(emp1);</span><br><span class="line">    System.out.println(&quot;========第二次调用========从缓存中取数据&quot;);</span><br><span class="line">    Emp emp2 = mapper.getEmpById(3);</span><br><span class="line">    System.out.println(emp2);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;\n========即使用的不是同一个Mapper，也同样从缓存中取(同一个sqlsession)========&quot;);</span><br><span class="line">    CacheMapper mapper2 = sqlSession.getMapper(CacheMapper.class);</span><br><span class="line">    Emp empByMapper2 = mapper2.getEmpById(3);</span><br><span class="line">    System.out.println(empByMapper2);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;\n========一级缓存的范围在sqlsession中，换一个新的sqlsession就会再次用sql读取数据========&quot;);</span><br><span class="line">    SqlSession sqlSession2 = SqlSessionUtils.getSqlSession();</span><br><span class="line">    CacheMapper mapper2BySqlSession2 = sqlSession2.getMapper(CacheMapper.class);</span><br><span class="line">    System.out.println(mapper2BySqlSession2.getEmpById(3));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310191104641.png"></p><p>同一个SqlSession但是查询条件不同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testCache3()&#123;</span><br><span class="line">    SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">    CacheMapper mapper = sqlSession.getMapper(CacheMapper.class);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;=====第一次获取数据=====&quot;);</span><br><span class="line">    Emp emp1 = mapper.getEmpById(3);</span><br><span class="line">    System.out.println(emp1);</span><br><span class="line">    </span><br><span class="line">    System.out.println(&quot;\n=====查询条件不同=====&quot;);</span><br><span class="line">    Emp emp2 = mapper.getEmpById(5);</span><br><span class="line">    System.out.println(emp2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310191104217.png"></p><p>同一个SqlSession两次查询期间执行了任何一次增删改操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testCache2()&#123;</span><br><span class="line">    SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">    CacheMapper mapper = sqlSession.getMapper(CacheMapper.class);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;=====第一次获取数据=====&quot;);</span><br><span class="line">    Emp emp1 = mapper.getEmpById(3);</span><br><span class="line">    System.out.println(emp1);</span><br><span class="line">    Emp emp2 = mapper.getEmpById(3);</span><br><span class="line">    System.out.println(emp2);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;\n=====进行增删改操作=====&quot;);</span><br><span class="line">    mapper.insetEmp(new Emp(null, &quot;Joey&quot;, 44, &quot;男&quot;, &quot;8888@gmai.com&quot;));</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;\n=====同一个sqlsession，再获取数据=====&quot;);</span><br><span class="line">    Emp emp3 = mapper.getEmpById(3);</span><br><span class="line">    System.out.println(emp3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310191104525.png"></p><p>同一个SqlSession两次查询期间手动清空了（一级）缓存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testCache4()&#123;</span><br><span class="line">    SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">    CacheMapper mapper = sqlSession.getMapper(CacheMapper.class);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;=====第一次获取数据=====&quot;);</span><br><span class="line">    Emp emp1 = mapper.getEmpById(3);</span><br><span class="line">    System.out.println(emp1);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;\n=====两次查询期间手动清空缓存=====&quot;);</span><br><span class="line">    sqlSession.clearCache();</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;\n=====再次查询id=3的emp=====&quot;);</span><br><span class="line">    Emp emp2 = mapper.getEmpById(3);</span><br><span class="line">    System.out.println(emp2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310191105166.png"></p><h2 id="MyBatis的二级缓存"><a href="#MyBatis的二级缓存" class="headerlink" title="MyBatis的二级缓存"></a>MyBatis的二级缓存</h2><p>二级缓存是SqlSessionFactory级别，范围比一级缓存大，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取</p><p>二级缓存开启的条件：</p><ol><li>在核心配置文件中，设置全局配置属性cacheEnabled&#x3D;“true”，默认为true，不需要设置</li><li>在映射文件中设置标签&lt; cache &#x2F;&gt;</li><li>二级缓存必须在SqlSession关闭或提交之后有效</li><li>查询的数据所转换的实体类类型必须实现序列化的接口</li></ol><p>使二级缓存失效的情况：</p><ol><li><p><strong>两次查询之间执行了任意的增删改</strong>，会使一级和二级缓存同时失效</p></li><li><p>没有提交sqlsession时，数据会保存在一级缓存中，提交后，会保存在二级缓存中。</p></li></ol><p>缓存有个属性是命中率，值有2中情况</p><ol><li>值为0：缓存中没有需要的结果</li><li>值非0：缓存中有需要的结果</li></ol><p>测试</p><ol><li>要把Emp Class加上<code>implements Serializable</code></li></ol>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    @Test</span><br><span class="line">    public void testCacheTwo()&#123;</span><br><span class="line">        //这里不能用工具类了，因为每次都会创建新的sqlsessionfactory</span><br><span class="line">//        SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span><br><span class="line">//        CacheMapper mapper = sqlSession.getMapper(CacheMapper.class);</span><br><span class="line"></span><br><span class="line">        //只要是同一个sqlsessionfactory获得的sqlsession就可以</span><br><span class="line">        try &#123;</span><br><span class="line">            InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">            SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);</span><br><span class="line">            SqlSession sqlSession1 = sqlSessionFactory.openSession(true);</span><br><span class="line">            CacheMapper mapper1 = sqlSession1.getMapper(CacheMapper.class);</span><br><span class="line">            System.out.println(mapper1.getEmpById(1));</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;Cache Hit Ratio：缓存命中率，指的是在缓存中有没有这条数据&quot;);</span><br><span class="line">            System.out.println(&quot;=====二级缓存未打开，没从缓存中获取数据=====&quot;);</span><br><span class="line">            SqlSession sqlSession2 = sqlSessionFactory.openSession(true);</span><br><span class="line">            CacheMapper mapper2 = sqlSession2.getMapper(CacheMapper.class);</span><br><span class="line">            System.out.println(mapper2.getEmpById(1));</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>   <img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310191107676.png"></p><ol start="2"><li><p>关闭sqlSession，再看是用sql从数据库读取数据还是从缓存中取数据：</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310191108932.png"></p></li></ol><h3 id="二级缓存的相关配置"><a href="#二级缓存的相关配置" class="headerlink" title="二级缓存的相关配置"></a>二级缓存的相关配置</h3><p>在mapper配置文件中添加的cache标签可以设置一些属性:</p><ol><li>eviction属性：缓存回收策略<br>LRU(Least Recently Used) ：最近最少使用的:移除最长时间不被使用的对象。<br>FIFO(First in First out)：先进先出:按对象进入缓存的顺序来移除它们。<br>SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。<br>WEAK –弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。<br>默认的是 LRU。</li><li>flushInterval属性：刷新间隔，单位毫秒<br>默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句（增删改） 时刷新</li><li>size属性：引用数目，正整数<br>代表缓存最多可以存储多少个对象，太大容易导致内存溢出</li><li>readOnly属性：只读，true&#x2F;false<br>true：只读缓存; 会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。【性能好】<br>false：读写缓存; 会返回缓存对象的拷贝(通过序列化)。这会慢一些，但是安全，因此默认是 false。【安全】</li></ol><h2 id="MyBatis缓存查询的顺序"><a href="#MyBatis缓存查询的顺序" class="headerlink" title="MyBatis缓存查询的顺序"></a>MyBatis缓存查询的顺序</h2><p>先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用。<br>如果二级缓存没有命中，再查询一级缓存<br>如果一级缓存也没有命中，则查询数据库<br>SqlSession关闭之后，一级缓存中的数据会写入二级缓存。</p><h1 id="MyBatis逆向工程"><a href="#MyBatis逆向工程" class="headerlink" title="MyBatis逆向工程"></a>MyBatis逆向工程</h1><p>MBG ：MyBatis Generator<br>MyBatis逆向工程指的是根据一张sql表单，借助Maven和MBG直接创建pojo、mapper接口（xxxMapper）、映射文件（xxxMapper.xml）。就不需要我们自己一个一个创建文件去配置</p><h2 id="创建逆向工程的步骤"><a href="#创建逆向工程的步骤" class="headerlink" title="创建逆向工程的步骤"></a>创建逆向工程的步骤</h2><ol><li><p>添加依赖和插件</p><p>在pom.xml中添加依赖和插件，更新maven。在插件 build 里面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;org.example&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;MyBatis_MBG&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;</span><br><span class="line">        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 依赖MyBatis核心包 --&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.5.7&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- junit测试 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- MySQL驱动 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.3&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- log4j日志 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;RELEASE&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">    &lt;!-- 控制Maven在构建过程中相关配置 --&gt;</span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;!-- 构建过程中用到的插件 --&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 --&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;1.3.0&lt;/version&gt;</span><br><span class="line">                &lt;!-- 插件的依赖 --&gt;</span><br><span class="line">                &lt;dependencies&gt;</span><br><span class="line">                    &lt;!-- 逆向工程的核心依赖 --&gt;</span><br><span class="line">                    &lt;dependency&gt;</span><br><span class="line">                        &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;</span><br><span class="line">                        &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;</span><br><span class="line">                        &lt;version&gt;1.3.2&lt;/version&gt;</span><br><span class="line">                    &lt;/dependency&gt;</span><br><span class="line">                    &lt;!-- 数据库连接池 --&gt;</span><br><span class="line">                    &lt;dependency&gt;</span><br><span class="line">                        &lt;groupId&gt;com.mchange&lt;/groupId&gt;</span><br><span class="line">                        &lt;artifactId&gt;c3p0&lt;/artifactId&gt;</span><br><span class="line">                        &lt;version&gt;0.9.2&lt;/version&gt;</span><br><span class="line">                    &lt;/dependency&gt;</span><br><span class="line">                    &lt;!-- MySQL驱动 --&gt;</span><br><span class="line">                    &lt;dependency&gt;</span><br><span class="line">                        &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">                        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">                        &lt;version&gt;5.1.8&lt;/version&gt;</span><br><span class="line">                    &lt;/dependency&gt;</span><br><span class="line">                &lt;/dependencies&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>创建MyBatis的核心配置文件</p><p>在src&#x2F;main&#x2F;resources下创建mybatis-config.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties resource=&quot;jdbc.properties&quot;&gt;&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--设置连接数据库的环境--&gt;</span><br><span class="line">    &lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">        &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">            &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class="line">            &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">                &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;url&quot;</span><br><span class="line">                          value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br><span class="line"></span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建jdbc.properties文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf8</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=写你的数据库密码</span><br></pre></td></tr></table></figure><p>创建log4j.xml文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE log4j:configuration SYSTEM &quot;log4j.dtd&quot;&gt;</span><br><span class="line">&lt;log4j:configuration xmlns:log4j=&quot;http://jakarta.apache.org/log4j/&quot;</span><br><span class="line">                     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">                     xsi:schemaLocation=&quot;http://jakarta.apache.org/log4j/ &quot;&gt;</span><br><span class="line">    &lt;appender name=&quot;STDOUT&quot; class=&quot;org.apache.log4j.ConsoleAppender&quot;&gt;</span><br><span class="line">        &lt;param name=&quot;Encoding&quot; value=&quot;UTF-8&quot;/&gt;</span><br><span class="line">        &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt;</span><br><span class="line">            &lt;param name=&quot;ConversionPattern&quot; value=&quot;%-5p %d&#123;MM-dd HH:mm:ss,SSS&#125;</span><br><span class="line">%m  (%F:%L) \n&quot;/&gt;</span><br><span class="line">        &lt;/layout&gt;</span><br><span class="line">    &lt;/appender&gt;</span><br><span class="line">    &lt;logger name=&quot;java.sql&quot;&gt;</span><br><span class="line">        &lt;level value=&quot;debug&quot;/&gt;</span><br><span class="line">    &lt;/logger&gt;</span><br><span class="line">    &lt;logger name=&quot;org.apache.ibatis&quot;&gt;</span><br><span class="line">        &lt;level value=&quot;info&quot;/&gt;</span><br><span class="line">    &lt;/logger&gt;</span><br><span class="line">    &lt;root&gt;</span><br><span class="line">        &lt;level value=&quot;debug&quot;/&gt;</span><br><span class="line">        &lt;appender-ref ref=&quot;STDOUT&quot;/&gt;</span><br><span class="line">    &lt;/root&gt;</span><br><span class="line">&lt;/log4j:configuration&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>创建逆向工程的配置文件<br>文件名必须是：generatorConfig.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE generatorConfiguration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;</span><br><span class="line">&lt;generatorConfiguration&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!--</span><br><span class="line">    targetRuntime: 执行生成的逆向工程的版本</span><br><span class="line">        MyBatis3Simple: 生成基本的CRUD(清新简洁版)</span><br><span class="line">        MyBatis3: 生成带条件的CRUD(奢华尊享版)</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3Simple&quot;&gt; &lt;!-- 数据库的连接信息 --&gt;</span><br><span class="line">        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">                        connectionURL=&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span><br><span class="line">                        userId=&quot;root&quot;</span><br><span class="line">                        password=&quot;这里改成你自己的数据库密码&quot;&gt;</span><br><span class="line">        &lt;/jdbcConnection&gt;</span><br><span class="line">        &lt;!-- javaBean的生成策略--&gt;</span><br><span class="line">        &lt;javaModelGenerator targetPackage=&quot;com.atguigu.mybatis.pojo&quot;</span><br><span class="line">                            targetProject=&quot;.\src\main\java&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;/javaModelGenerator&gt;</span><br><span class="line">        &lt;!-- SQL映射文件的生成策略 --&gt;</span><br><span class="line">        &lt;sqlMapGenerator targetPackage=&quot;com.atguigu.mybatis.mapper&quot;</span><br><span class="line">                         targetProject=&quot;.\src\main\resources&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;/sqlMapGenerator&gt;</span><br><span class="line">        &lt;!-- Mapper接口的生成策略 --&gt;</span><br><span class="line">        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot;</span><br><span class="line">                             targetPackage=&quot;com.atguigu.mybatis.mapper&quot; targetProject=&quot;.\src\main\java&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;/javaClientGenerator&gt;</span><br><span class="line">        &lt;!-- 逆向分析的表 --&gt;</span><br><span class="line">        &lt;!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName --&gt; &lt;!-- domainObjectName属性指定生成出来的实体类的类名 --&gt;</span><br><span class="line">        &lt;table tableName=&quot;t_emp&quot; domainObjectName=&quot;Emp&quot;/&gt;</span><br><span class="line">        &lt;table tableName=&quot;t_dept&quot; domainObjectName=&quot;Dept&quot;/&gt;</span><br><span class="line">    &lt;/context&gt;</span><br><span class="line">&lt;/generatorConfiguration&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>执行MBG插件的generate目标</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310191509238.png"></p><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">操作前</button></li><li class="tab"><button type="button" data-href="#test4-2">操作后</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310191511746.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310191511567.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">简易自动生成</button></li><li class="tab"><button type="button" data-href="#test4-2">更改参数为MyBatis3: 生成带条件的CRUD</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p>pojo中自动生成属性和get&#x2F;set方法</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310191514697.png"></p><p>Mapper接口中自动生成基础增删改查功能</p><p>此时逆向工程的配置文件<code>generatorConfig.xml</code>中：<code>targetRuntime=“MyBatis3Simple&quot;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public interface EmpMapper &#123;</span><br><span class="line">    int deleteByPrimaryKey(Integer eid);</span><br><span class="line">    </span><br><span class="line">    int insert(Emp record);</span><br><span class="line">    </span><br><span class="line">    Emp selectByPrimaryKey(Integer eid);</span><br><span class="line">    </span><br><span class="line">    List&lt;Emp&gt; selectAll();</span><br><span class="line">    </span><br><span class="line">    int updateByPrimaryKey(Emp record);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Mapper映射文件中自动生成相对应方法的配置信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.atguigu.mybatis.mapper.EmpMapper&quot; &gt;</span><br><span class="line">  &lt;resultMap id=&quot;BaseResultMap&quot; type=&quot;com.atguigu.mybatis.pojo.Emp&quot; &gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">      WARNING - @mbggenerated</span><br><span class="line">      This element is automatically generated by MyBatis Generator, do not modify.</span><br><span class="line">      This element was generated on Wed Mar 02 16:05:18 CST 2022.</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;id column=&quot;eid&quot; property=&quot;eid&quot; jdbcType=&quot;INTEGER&quot; /&gt;</span><br><span class="line">    &lt;result column=&quot;emp_name&quot; property=&quot;empName&quot; jdbcType=&quot;VARCHAR&quot; /&gt;</span><br><span class="line">    &lt;result column=&quot;age&quot; property=&quot;age&quot; jdbcType=&quot;INTEGER&quot; /&gt;</span><br><span class="line">    &lt;result column=&quot;sex&quot; property=&quot;sex&quot; jdbcType=&quot;CHAR&quot; /&gt;</span><br><span class="line">    &lt;result column=&quot;email&quot; property=&quot;email&quot; jdbcType=&quot;VARCHAR&quot; /&gt;</span><br><span class="line">    &lt;result column=&quot;did&quot; property=&quot;did&quot; jdbcType=&quot;INTEGER&quot; /&gt;</span><br><span class="line">  &lt;/resultMap&gt;</span><br><span class="line">  &lt;delete id=&quot;deleteByPrimaryKey&quot; parameterType=&quot;java.lang.Integer&quot; &gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">      WARNING - @mbggenerated</span><br><span class="line">      This element is automatically generated by MyBatis Generator, do not modify.</span><br><span class="line">      This element was generated on Wed Mar 02 16:05:18 CST 2022.</span><br><span class="line">    --&gt;</span><br><span class="line">    delete from t_emp</span><br><span class="line">    where eid = #&#123;eid,jdbcType=INTEGER&#125;</span><br><span class="line">  &lt;/delete&gt;</span><br><span class="line">  &lt;insert id=&quot;insert&quot; parameterType=&quot;com.atguigu.mybatis.pojo.Emp&quot; &gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">      WARNING - @mbggenerated</span><br><span class="line">      This element is automatically generated by MyBatis Generator, do not modify.</span><br><span class="line">      This element was generated on Wed Mar 02 16:05:18 CST 2022.</span><br><span class="line">    --&gt;</span><br><span class="line">    insert into t_emp (eid, emp_name, age, </span><br><span class="line">      sex, email, did)</span><br><span class="line">    values (#&#123;eid,jdbcType=INTEGER&#125;, #&#123;empName,jdbcType=VARCHAR&#125;, #&#123;age,jdbcType=INTEGER&#125;, </span><br><span class="line">      #&#123;sex,jdbcType=CHAR&#125;, #&#123;email,jdbcType=VARCHAR&#125;, #&#123;did,jdbcType=INTEGER&#125;)</span><br><span class="line">  &lt;/insert&gt;</span><br><span class="line">  &lt;update id=&quot;updateByPrimaryKey&quot; parameterType=&quot;com.atguigu.mybatis.pojo.Emp&quot; &gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">      WARNING - @mbggenerated</span><br><span class="line">      This element is automatically generated by MyBatis Generator, do not modify.</span><br><span class="line">      This element was generated on Wed Mar 02 16:05:18 CST 2022.</span><br><span class="line">    --&gt;</span><br><span class="line">    update t_emp</span><br><span class="line">    set emp_name = #&#123;empName,jdbcType=VARCHAR&#125;,</span><br><span class="line">      age = #&#123;age,jdbcType=INTEGER&#125;,</span><br><span class="line">      sex = #&#123;sex,jdbcType=CHAR&#125;,</span><br><span class="line">      email = #&#123;email,jdbcType=VARCHAR&#125;,</span><br><span class="line">      did = #&#123;did,jdbcType=INTEGER&#125;</span><br><span class="line">    where eid = #&#123;eid,jdbcType=INTEGER&#125;</span><br><span class="line">  &lt;/update&gt;</span><br><span class="line">  &lt;select id=&quot;selectByPrimaryKey&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;java.lang.Integer&quot; &gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">      WARNING - @mbggenerated</span><br><span class="line">      This element is automatically generated by MyBatis Generator, do not modify.</span><br><span class="line">      This element was generated on Wed Mar 02 16:05:18 CST 2022.</span><br><span class="line">    --&gt;</span><br><span class="line">    select eid, emp_name, age, sex, email, did</span><br><span class="line">    from t_emp</span><br><span class="line">    where eid = #&#123;eid,jdbcType=INTEGER&#125;</span><br><span class="line">  &lt;/select&gt;</span><br><span class="line">  &lt;select id=&quot;selectAll&quot; resultMap=&quot;BaseResultMap&quot; &gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">      WARNING - @mbggenerated</span><br><span class="line">      This element is automatically generated by MyBatis Generator, do not modify.</span><br><span class="line">      This element was generated on Wed Mar 02 16:05:18 CST 2022.</span><br><span class="line">    --&gt;</span><br><span class="line">    select eid, emp_name, age, sex, email, did</span><br><span class="line">    from t_emp</span><br><span class="line">  &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310191520688.png"></p><p>自动生成的Mapper接口中的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public interface EmpMapper &#123;</span><br><span class="line">// 根据条件计数</span><br><span class="line">    int countByExample(EmpExample example);</span><br><span class="line"></span><br><span class="line">//根据条件删除</span><br><span class="line">    int deleteByExample(EmpExample example);</span><br><span class="line">//根据主键删除</span><br><span class="line">    int deleteByPrimaryKey(Integer eid);</span><br><span class="line"></span><br><span class="line">//普通插入</span><br><span class="line">    int insert(Emp record);</span><br><span class="line">//选择性插入：没写的就是null</span><br><span class="line">    int insertSelective(Emp record);</span><br><span class="line"></span><br><span class="line">//根据条件查询</span><br><span class="line">    List&lt;Emp&gt; selectByExample(EmpExample example);</span><br><span class="line">//根据主键查询</span><br><span class="line">    Emp selectByPrimaryKey(Integer eid);</span><br><span class="line"></span><br><span class="line">//根据条件选择性修改：</span><br><span class="line">    int updateByExampleSelective(@Param(&quot;record&quot;) Emp record, @Param(&quot;example&quot;) EmpExample example);</span><br><span class="line">    //根据条件修改</span><br><span class="line">    int updateByExample(@Param(&quot;record&quot;) Emp record, @Param(&quot;example&quot;) EmpExample example);</span><br><span class="line">//根据主键选择性修改</span><br><span class="line">    int updateByPrimaryKeySelective(Emp record);</span><br><span class="line">//根据主键修改</span><br><span class="line">    int updateByPrimaryKey(Emp record);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Mapper映射文件中自动生成相对应方法的配置信息：</p><p>这次的Mapper映射文件很复杂很全面，提供了大量的功能</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></li></ol><blockquote><p>pom.xml里有两个配置sql的地方，一个是给项目加的，一个是给插件加的。2个sql依赖</p></blockquote><h1 id="分页插件的配置及使用"><a href="#分页插件的配置及使用" class="headerlink" title="分页插件的配置及使用"></a>分页插件的配置及使用</h1><h2 id="分页插件配置"><a href="#分页插件配置" class="headerlink" title="分页插件配置"></a>分页插件配置</h2><ol><li><p>添加依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.2.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>配置分页插件</p><p>在MyBatis的核心配置文件中配置插件，注意顺序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">&lt;!--设置分页插件--&gt;</span><br><span class="line">    &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt;&lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="分页插件的使用"><a href="#分页插件的使用" class="headerlink" title="分页插件的使用"></a>分页插件的使用</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310191527610.png"></p><ol><li><p>在查询功能之前使用 PageHelper.startPage(int pageNum, int pageSize) 开启分页功能</p><ul><li>pageNum:当前页的页码</li><li>pageSize:每页显示的条数</li></ul></li><li><p>在查询获取list集合之后，使用PageInfo pageInfo &#x3D; new PageInfo&lt;&gt;(List list, int navigatePages)获取分页相关数据</p><ul><li>list:分页之后的数据</li><li>navigatePages:导航分页的页码数</li></ul></li><li><p>分页相关数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PageInfo&#123;</span><br><span class="line">pageNum=8, pageSize=4, size=2, startRow=29, endRow=30, total=30, pages=8,</span><br><span class="line">list=Page&#123;count=true, pageNum=8, pageSize=4, startRow=28, endRow=32, total=30, pages=8, reasonable=false, pageSizeZero=false&#125;,</span><br><span class="line">prePage=7, nextPage=0, isFirstPage=false, isLastPage=true, hasPreviousPage=true, hasNextPage=false, navigatePages=5, navigateFirstPage4, navigateLastPage8, navigatepageNums=[4, 5, 6, 7, 8]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>pageNum:当前页的页码</li><li>pageSize:每页显示的条数</li><li>size:当前页显示的真实条数</li><li>total:总记录数</li><li>pages:总页数</li><li>prePage:上一页的页码</li><li>nextPage:下一页的页码</li><li>isFirstPage&#x2F;isLastPage:是否为第一页&#x2F;最后一页</li><li>hasPreviousPage&#x2F;hasNextPage:是否存在上一页&#x2F;下一页</li><li>navigatePages:导航分页的页码数</li><li>navigatepageNums:导航分页的页码，[1,2,3,4,5]</li></ul></li></ol><p>测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * limit    index，pagesize</span><br><span class="line"> * index    当前页的起始索引</span><br><span class="line"> * pageSize 每页显示的条数</span><br><span class="line"> * pageNum  当前页的页码</span><br><span class="line"> * 当前页的起始索引 = 每页条数 * 页码 - 1</span><br><span class="line"> * index = pageNum * pageSize - 1</span><br><span class="line"> *</span><br><span class="line"> * 通过索引获得数据</span><br><span class="line"> *</span><br><span class="line"> * 使用MyBatis的分页插件，实现分页功能：</span><br><span class="line"> * 1。需要在查询功能之前开启分页</span><br><span class="line"> * PageHelper.startPage(2, 4);</span><br><span class="line"> * </span><br><span class="line"> * 2。在查询功能之后获取分页相关信息</span><br><span class="line"> *   PageInfo&lt;Emp&gt; pages = new PageInfo&lt;&gt;(emps, 5); 5表示导航分页的数量</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void test2()&#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;\n查询功能前开启分页&quot;);</span><br><span class="line">        PageHelper.startPage(2, 4);</span><br><span class="line">        List&lt;Emp&gt; emps = mapper.selectByExample(null);</span><br><span class="line">        emps.forEach(emp -&gt; System.out.println(emp));</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;\n&quot;);</span><br><span class="line">        PageInfo&lt;Emp&gt; pages = new PageInfo&lt;&gt;(emps, 5);</span><br><span class="line">        System.out.println(&quot;PageInfo-----&gt;&quot;+pages);</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java反射</title>
      <link href="/2023/10/26/Java%E5%8F%8D%E5%B0%84/"/>
      <url>/2023/10/26/Java%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="反射入门"><a href="#反射入门" class="headerlink" title="反射入门"></a>反射入门</h1><p>反射机制（Reflection）允许程序在执行期借助于 Reflection API 取得任何类的内部信息（如成员变量、成员方法等），并能操作对象的属性及方法。反射在设计模式和框架底层都会用到。</p><p>加载完类之后，在<strong>堆</strong>中就产生了一个 <code>Class</code> 类型的对象（一个类只有一个 <code>Class</code> 对象），这个对象包含了类的完整结构信息。通过这个对象得到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构。所以，形象地称之为：反射</p><p>Class类：就是一个类，恰好叫Class</p><blockquote><p>ocp 原则（开闭原则）：不修改源码来扩展功能</p></blockquote><p>反射入门案例：根据配置文件 re.properties 指定信息, 创建Cat对象并调用方法hi</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class ReflectionQuestion &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException, ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException &#123;</span><br><span class="line"></span><br><span class="line">        //根据配置文件 re.properties 指定信息, 创建Cat对象并调用方法hi</span><br><span class="line">        //传统的方式 new 对象 -》 调用方法</span><br><span class="line">//        Cat cat = new Cat();</span><br><span class="line">//        cat.hi(); ===&gt; cat.cry() 修改源码.</span><br><span class="line"></span><br><span class="line">        //我们尝试做一做 -&gt; 明白反射</span><br><span class="line">        //1. 使用Properties 类, 可以读写配置文件</span><br><span class="line">        Properties properties = new Properties();</span><br><span class="line">        properties.load(new FileInputStream(&quot;src\\re.properties&quot;));</span><br><span class="line">        String classfullpath = properties.get(&quot;classfullpath&quot;).toString();//&quot;com.hspedu.Cat&quot;</span><br><span class="line">        String methodName = properties.get(&quot;method&quot;).toString();//&quot;hi&quot;</span><br><span class="line">        System.out.println(&quot;classfullpath=&quot; + classfullpath);</span><br><span class="line">        System.out.println(&quot;method=&quot; + methodName);</span><br><span class="line"></span><br><span class="line">        //2. 创建对象 , 传统的方法，行不通 =》 反射机制</span><br><span class="line">        //new classfullpath();</span><br><span class="line"></span><br><span class="line">        //3. 使用反射机制解决</span><br><span class="line">        //(1) 加载类, 返回Class类型的对象cls</span><br><span class="line">        Class cls = Class.forName(classfullpath);</span><br><span class="line">        //(2) 通过 cls 得到你加载的类 com.hspedu.Cat 的对象实例</span><br><span class="line">        Object o = cls.newInstance();</span><br><span class="line">        System.out.println(&quot;o的运行类型=&quot; + o.getClass()); //运行类型</span><br><span class="line">        //(3) 通过 cls 得到你加载的类 com.hspedu.Cat 的 methodName&quot;hi&quot;  的方法对象</span><br><span class="line">        //    即：在反射中，可以把方法视为对象（万物皆对象）</span><br><span class="line">        Method method1 = cls.getMethod(methodName);</span><br><span class="line">        //(4) 通过method1 调用方法: 即通过方法对象来实现调用方法</span><br><span class="line">        System.out.println(&quot;=============================&quot;);</span><br><span class="line">        method1.invoke(o); //传统方法 对象.方法() , 反射机制 方法.invoke(对象)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="反射原理"><a href="#反射原理" class="headerlink" title="反射原理"></a>反射原理</h1><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310151310761.png"></p><h1 id="反射相关的常用类"><a href="#反射相关的常用类" class="headerlink" title="反射相关的常用类"></a>反射相关的常用类</h1><ol><li><code>java.lang.Class</code>：代表一个类。<code>Class</code> 对象表示某个类加载后在堆中的对象</li><li><code>java.lang.reflect.Method</code>：代表类的方法。<code>Method</code> 对象表示某个类的某个方法</li><li><code>java.lang.reflect.Field</code>：代表类的成员变量</li><li><code>java.lang.reflect.Constructor</code>：代表类的构造方法</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    //1. 使用Properties 类, 可以读写配置文件</span><br><span class="line">    Properties properties = new Properties();</span><br><span class="line">    properties.load(new FileInputStream(&quot;src\\re.properties&quot;));</span><br><span class="line">    String classfullpath = properties.get(&quot;classfullpath&quot;).toString();//&quot;com.hspedu.Cat&quot;</span><br><span class="line">    String methodName = properties.get(&quot;method&quot;).toString();//&quot;hi&quot;</span><br><span class="line"></span><br><span class="line">    //2. 使用反射机制解决</span><br><span class="line">    //(1) 加载类, 返回Class类型的对象cls</span><br><span class="line">    Class cls = Class.forName(classfullpath);</span><br><span class="line">    //(2) 通过 cls 得到你加载的类 com.hspedu.Cat 的对象实例</span><br><span class="line">    Object o = cls.newInstance();</span><br><span class="line">    System.out.println(&quot;o的运行类型=&quot; + o.getClass()); //运行类型</span><br><span class="line">    //(3) 通过 cls 得到你加载的类 com.hspedu.Cat 的 methodName&quot;hi&quot;  的方法对象</span><br><span class="line">    //    即：在反射中，可以把方法视为对象（万物皆对象）</span><br><span class="line">    Method method1 = cls.getMethod(methodName);</span><br><span class="line">    //(4) 通过method1 调用方法: 即通过方法对象来实现调用方法</span><br><span class="line">    System.out.println(&quot;=============================&quot;);</span><br><span class="line">    method1.invoke(o); //传统方法 对象.方法() , 反射机制 方法.invoke(对象)</span><br><span class="line"></span><br><span class="line">    //java.lang.reflect.Field: 代表类的成员变量, Field对象表示某个类的成员变量</span><br><span class="line">    //得到name字段</span><br><span class="line">    //getField不能得到私有的属性</span><br><span class="line">    Field nameField = cls.getField(&quot;age&quot;); //</span><br><span class="line">    System.out.println(nameField.get(o)); // 传统写法 对象.成员变量 , 反射 :  成员变量对象.get(对象)</span><br><span class="line"></span><br><span class="line">    //java.lang.reflect.Constructor: 代表类的构造方法, Constructor对象表示构造器</span><br><span class="line">    Constructor constructor = cls.getConstructor(); //()中可以指定构造器参数类型, 返回无参构造器</span><br><span class="line">    System.out.println(constructor);//Cat()</span><br><span class="line"></span><br><span class="line">    Constructor constructor2 = cls.getConstructor(String.class); //这里老师传入的 String.class 就是String类的Class对象</span><br><span class="line">    System.out.println(constructor2);//Cat(String name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>反射的优点和缺点</strong></p><ul><li>优点：可以动态地创建和使用对象（也是框架底层核心），使用灵活。没有反射机制，框架技术就失去底层支撑</li><li>缺点：使用反射基本是解释执行。这对执行速度有影响。</li></ul><p><strong>反射调用优化 - 关闭访问检查</strong></p><ol><li><p><code>Method</code> 和 <code>Field</code>、<code>Constructor</code> 对象都有 <code>setAccessible()</code> 方法</p></li><li><p><code>setAccessible()</code> 作用是启动和禁用访问安全检查的开关</p></li><li><p>参数值为 true，表示反射对象在使用时取消访问检查，这样能提高反射效率。</p><p>为 false 表示执行访问检查</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程</title>
      <link href="/2023/10/26/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2023/10/26/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>程序：为完成特定任务，用某种语言编写的一组指令的集合。</p><p>进程：运行中的程序。当你运行一个程序，系统就会为该进程分配空间。进程是程序的一次执行过程。是一个动态过程：有其自身产生、存在、消亡的过程。</p><p>线程：由进程创建的，进程的一个实体。一个进程可以有多个线程。</p><p>单线程：同一时刻，只允许执行一个线程。</p><p>多线程：同一时刻，可以执行多个线程。</p><p>并发：同一时刻，多个任务交替执行，造成一种貌似并行的状态。单核 CPU 实现的多任务就是并发。</p><p>并行：同一时刻，多个任务同时进行。多核 CPU 可以实现并行。</p><blockquote><p>进程即是程序在处理机中的一次运行。在这样一个结构中不仅包含程序代码，也包括了系统资源的概念。</p><p>在单 CPU 计算机内部，微观上讲，同一时间只能有一个线程运行。实现多线程即从宏观上使多个作业同时执行。</p></blockquote><h2 id="用户线程和守护线程"><a href="#用户线程和守护线程" class="headerlink" title="用户线程和守护线程"></a>用户线程和守护线程</h2><ul><li><p>用户线程：也叫工作线程。当线程任务执行完毕或通知方式结束</p></li><li><p>守护线程：一般是为工作线程服务的。当所有线程结束，守护线程自动结束</p><p>常见的守护线程：垃圾回收机制</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread thraed = new Thread(bullet);</span><br><span class="line">thread.setDeamon(true);//这样，子线程被设置为主线程的守护线程</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure></blockquote></li></ul><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><blockquote><p>Java 的线程是通过包 java.lang 中定义的类 Thread 或者 接口 Runnable来实现的。当生成了一个 Thread 类后就产生了一个线程。通过该对象实例，可以启动线程、终止线程，或暂时挂起线程</p></blockquote><p>线程共有 4 种状态：新建（New）、可运行（Runnable）、死亡（Dead）、阻塞（Blocked）</p><ul><li><p><strong>新建（New）：</strong></p><p>线程对象刚刚创建，还未启动（New）。此时还处于不可运行状态，但已有了相应内存空间及其他资源</p></li><li><p><strong>可运行（Runnable）：</strong></p><p>此时线程已经启动，处于线程的 <code>run()</code> 方法中。这种情况下线程可能正在运行；也可能没有运行，但只要 CPU 空闲就会立刻运行。</p><p>可以运行但没在运行的线程都排在一个队列中，这个队列称为就绪队列。</p><p>可运行状态下，运行中的线程处于运行状态（Running），未运行线程处于就绪状态（Ready）。</p><p>调用 <code>start()</code> 方法可以让线程进入可运行状态。</p></li><li><p><strong>死亡（Dead）：</strong></p><p>线程死亡（Terminated）的原因有两个：一是 <code>run()</code> 方法最后一个语句执行完毕，二是线程遇到异常退出</p></li><li><p><strong>阻塞（Blocked）：</strong></p><p>一个正常运行的线程因为特殊原因被暂停执行，就进入阻塞状态（Blocked）。</p><p>阻塞时线程不能进入就绪对流排队，必须等到引起阻塞的原因消除，才能重新进入队列排队。</p><p>引起阻塞的方法很多，<code>sleep()</code> 和 <code>wait()</code> 是两个常用的阻塞方法</p></li><li><p><strong>中断线程：</strong></p><ul><li><p><code>void interrupt()</code>：向一个线程发送一个中断请求，并把该线程的 interruptd 状态变为 true。</p><p>中断阻塞线程的场合，会抛出 InterruptException 异常</p></li><li><p><code>static boolean interrupted()</code>：检测当前线程是否被中断，并重置状态 interrupted 的值。</p><p>连续调用该方法的场合，第二次调用会返回 false</p></li><li><p><code>boolean isInterrupted()</code>：检测当前线程是否中断。不改变 interrupted 的值</p></li></ul></li></ul><h1 id="线程的创建和使用"><a href="#线程的创建和使用" class="headerlink" title="线程的创建和使用"></a>线程的创建和使用</h1><h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h2><p>在 Java 中线程使用有两种方法：</p><ol><li><p>继承 <code>Thread</code> 类，重写 <code>run</code> 方法</p></li><li><p>实现 <code>Runable</code> 接口，重写 <code>run</code> 方法</p><blockquote><p>public class Thread implements RunnableThread 也是实现了 Runable 接口</p></blockquote></li></ol><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310142038052.png"></p><h3 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h3><blockquote><p>Thread 类是 Java 用于表示线程的类。那么，一个类被定义为其子类，则该类也能用来表示线程</p></blockquote><ol><li>当一个类继承了 Thread 类， 该类就可以当做线程使用</li><li>run Thread 类 实现了 Runnable 接口的run方法</li><li>我们会重写 run方法，写上自己的业务代码</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class Thread01 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        //创建Cat对象，可以当做线程使用</span><br><span class="line">        Cat cat = new Cat();</span><br><span class="line">        cat.start();//启动线程-&gt; 最终会执行cat的run方法</span><br><span class="line">        </span><br><span class="line">        //说明: 当main线程启动一个子线程 Thread-0, 主线程不会阻塞, 会继续执行</span><br><span class="line">        //这时 主线程和子线程是交替执行..</span><br><span class="line">        System.out.println(&quot;主线程继续执行&quot; + Thread.currentThread().getName());//名字main</span><br><span class="line">        for(int i = 0; i &lt; 60; i++) &#123;</span><br><span class="line">            System.out.println(&quot;主线程 i=&quot; + i);</span><br><span class="line">            //让主线程休眠</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat extends Thread &#123;</span><br><span class="line">    int times = 0;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;//重写run方法，写上自己的业务逻辑</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            //该线程每隔1秒。在控制台输出 “喵喵, 我是小猫咪”</span><br><span class="line">            System.out.println(&quot;喵喵, 我是小猫咪&quot; + (++times) + &quot; 线程名=&quot; + Thread.currentThread().getName());</span><br><span class="line">            //让该线程休眠1秒 ctrl+alt+t</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            if(times == 80) &#123;</span><br><span class="line">                break;//当times 到80, 退出while, 这时线程也就退出..</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现-Runable-接口"><a href="#实现-Runable-接口" class="headerlink" title="实现 Runable 接口"></a>实现 Runable 接口</h3><blockquote><p>Runnable 是 Java 用以实现线程的接口。任何实现线程的类都必须实现该接口。</p></blockquote><ol><li>java是单继承的，在某些情况下一一个类可能已经继承了某个父类，这时在用继承Thread类方法来创建线程显然不可能了。</li><li>java设计者们提供了另外个方式创建线程，就是通过实现Runnable接口来创建线程</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public class Thread02 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Dog dog = new Dog();</span><br><span class="line">        //dog.start(); 这里不能调用start，dog类里面没有这个方法啊</span><br><span class="line">        //创建了Thread对象，把 dog对象(实现Runnable),放入Thread</span><br><span class="line">        Thread thread = new Thread(dog);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//模拟一个 Thread 类</span><br><span class="line">class ThreadProxy implements Runnable &#123;//你可以把Proxy类当做 ThreadProxy</span><br><span class="line"></span><br><span class="line">    private Runnable target = null;//属性，类型是 Runnable</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        if (target != null) &#123;</span><br><span class="line">            target.run();//动态绑定（运行类型Tiger）</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ThreadProxy(Runnable target) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void start() &#123;</span><br><span class="line">        start0();//这个方法时真正实现多线程方法</span><br><span class="line">    &#125;</span><br><span class="line">    public void start0() &#123;</span><br><span class="line">        run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Dog implements Runnable &#123; //通过实现Runnable接口，开发线程</span><br><span class="line"></span><br><span class="line">    int count = 0;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123; //普通方法</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            System.out.println(&quot;小狗汪汪叫..hi&quot; + (++count) + Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">            //休眠1秒</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (count == 10) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310142118198.png"></p><p>上图中构造器参数显示，可以接受 Runnable 的实现类，实现 Thread 对象接受相应的实现类，运行线程的方法</p><h3 id="继承-Thread-和-实现-Runable-的区别"><a href="#继承-Thread-和-实现-Runable-的区别" class="headerlink" title="继承 Thread 和 实现 Runable 的区别"></a>继承 Thread 和 实现 Runable 的区别</h3><ol><li>从 Java 设计来看，两者本质上没有区别。<code>Thread</code> 类本身就实现了 <code>Runable</code> 接口，但是 java 是单继承的</li><li>实现 <code>Runable</code> 接口的方式更加适合多个线程共享一个资源的情况，且避免了单继承的限制。建议使用</li></ol><h2 id="多线程机制"><a href="#多线程机制" class="headerlink" title="多线程机制"></a>多线程机制</h2><p>main线程：程序运行时运行到 main 方法时，会创建 main线程</p><p>子线程：程序运行到 start() 方法时，会开启一个新线程</p><p>各线程间相互独立，各线程会继续按逻辑运行自己的代码，所有线程都关闭后，进程关闭</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310142052479.png"></p><h3 id="买票案例"><a href="#买票案例" class="headerlink" title="买票案例"></a>买票案例</h3><p>编程模拟三个售票窗口售票100，分别使用继承Thread和实现Runnable方式，并分析有什么问题?</p><p>如图，出现了资源超出的现象，这个问题需要通过线程同步来解决。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public class SellTicket &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//        这里我们会出现超卖..</span><br><span class="line"></span><br><span class="line">//        System.out.println(&quot;===使用继承Thread方式来售票=====&quot;);</span><br><span class="line">//        SellTicket01 sellTicket01 = new SellTicket01();</span><br><span class="line">//        SellTicket01 sellTicket02 = new SellTicket01();</span><br><span class="line">//        SellTicket01 sellTicket03 = new SellTicket01();</span><br><span class="line">//        sellTicket01.start();//启动售票线程</span><br><span class="line">//        sellTicket02.start();//启动售票线程</span><br><span class="line">//        sellTicket03.start();//启动售票线程</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;===使用实现接口方式来售票=====&quot;);</span><br><span class="line">        SellTicket02 sellTicket02 = new SellTicket02();</span><br><span class="line">        new Thread(sellTicket02).start();//第1个线程-窗口</span><br><span class="line">        new Thread(sellTicket02).start();//第2个线程-窗口</span><br><span class="line">        new Thread(sellTicket02).start();//第3个线程-窗口</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//使用Thread方式</span><br><span class="line">class SellTicket01 extends Thread &#123;</span><br><span class="line">    private static int ticketNum = 100;//让多个线程共享 ticketNum</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (ticketNum &lt;= 0) &#123;</span><br><span class="line">                System.out.println(&quot;售票结束...&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //休眠50毫秒, 模拟</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(50);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;窗口 &quot; + Thread.currentThread().getName() + &quot; 售出一张票&quot;</span><br><span class="line">                    + &quot; 剩余票数=&quot; + (--ticketNum));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//实现接口方式</span><br><span class="line">class SellTicket02 implements Runnable &#123;</span><br><span class="line">    private int ticketNum = 100;//让多个线程共享 ticketNum</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (ticketNum &lt;= 0) &#123;</span><br><span class="line">                System.out.println(&quot;售票结束...&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //休眠50毫秒, 模拟</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(50);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;窗口 &quot; + Thread.currentThread().getName() + &quot; 售出一张票&quot;</span><br><span class="line">                    + &quot; 剩余票数=&quot; + (--ticketNum));//1 - 0 - -1  - -2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310142126917.png"></p><h2 id="start-方法"><a href="#start-方法" class="headerlink" title="start() 方法"></a>start() 方法</h2><p>start() 源码：</p><ol><li><code>start()</code> 方法调用了一个 <code>start0()</code> 底层方法</li><li><code>start0()</code> 是本地方法，由 JVM 调用，底层是 c&#x2F;c++ 实现</li><li>真正的多线程效果，是 <code>start0()</code>，而不是 <code>run()</code></li><li><code>start()</code> 方法调用 <code>start0()</code> 方法后，该线程不一定会立刻执行，只是将线程变成了可运行状态。具体何时运行，由 CPU 统一调度</li></ol><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310142101834.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310142059184.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    (1)</span><br><span class="line">    public synchronized void start() &#123;</span><br><span class="line">        start0();</span><br><span class="line">    &#125;</span><br><span class="line">    (2)</span><br><span class="line">    //start0() 是本地方法，是JVM调用, 底层是c/c++实现</span><br><span class="line">    //真正实现多线程的效果， 是start0(), 而不是 run</span><br><span class="line">    private native void start0();</span><br><span class="line"></span><br><span class="line"> */</span><br></pre></td></tr></table></figure><blockquote><p>cat.start(); 启动线程，最终会执行cat的run方法，那为什么不直接执行 run方法呢？</p><p>对象.run() 相当于调用类中的 run方法，没有启动线程的功能。这个方法运行完以后，才会继续执行该线程后续的代码</p></blockquote><h2 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h2><p>线程有2种终止原因：</p><ol><li><p>当线程结束后，会自动退出（自然行为）</p></li><li><p>还可以通过使用变量来控制 <code>run</code> 方法退出的方式来停止线程，即 <strong>通知方式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadExit_ &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        T t1 = new T();</span><br><span class="line">        t1.start();</span><br><span class="line">        //如果希望main线程去控制t1 线程的终止, 必须可以修改 loop</span><br><span class="line">        //让t1 退出run方法，从而终止 t1线程 -&gt; 通知方式      </span><br><span class="line">        //让主线程休眠 10 秒，再通知 t1线程退出</span><br><span class="line">        System.out.println(&quot;main线程休眠10s...&quot;);</span><br><span class="line">        Thread.sleep(10 * 1000);</span><br><span class="line">        t1.setLoop(false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class T extends Thread &#123;</span><br><span class="line">    private int count = 0;</span><br><span class="line">    //设置一个控制变量</span><br><span class="line">    private boolean loop = true;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (loop) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(50);// 让当前线程休眠50ms</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;T 运行中....&quot; + (++count));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setLoop(boolean loop) &#123;</span><br><span class="line">        this.loop = loop;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="线程常用方法"><a href="#线程常用方法" class="headerlink" title="线程常用方法"></a>线程常用方法</h2><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><ul><li><p><code>setName(name)</code>：设置线程名称，使之与参数 name 相同</p></li><li><p><code>getName()</code>：返回线程名称</p></li><li><p><code>start()</code>：线程开始执行。JVM 调用 <code>start0</code> 方法。该方法会创建新的线程，新线程调用 <code>run</code>。</p></li><li><p><code>run()</code>：调用线程的 run 方法，接口给出，需要我们重写成我们的逻辑</p></li><li><p><code>sleep(int millsecond)</code>：让线程休眠指定的时间，该方法是 Thread 类的静态方法，可以直接调用</p></li><li><p><code>interrupt()</code>：中断线程（不是 中止）</p></li><li><p><code>wait()</code>：导致当前线程等待</p><p>直到其他线程调用此对象的 <code>notify()</code> 方法或 <code>notifyAll()</code> 方法才能唤醒此线程</p><p><code>notify()</code>、<code>notifyAll()</code>：唤醒因 <code>wait()</code> 阻塞的线程。</p><p>这些方法（<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>）只能在 synchrnized 方法或代码块中调用</p></li><li><p><code>isAlive()</code>：测试当前线程是否在活动</p></li><li><p><code>Thread.currentThread()</code>：引用当前运行中的线程</p></li></ul><h3 id="改变顺序"><a href="#改变顺序" class="headerlink" title="改变顺序"></a>改变顺序</h3><ul><li><p><code>yield()</code>：线程的礼让。让出 CPU 让其他线程执行。因为礼让的时间不确定，所以不一定礼让成功。本质是 RUNNING 切换为 READY，即让当前线程放弃执行权</p></li><li><p><code>join()</code>：线程的插队。插队的线程一旦插入成功，则必定先执行完插队线程的所有任务将导致其他线程的等待，直到 <code>join()</code> 方法的线程结束</p></li><li><p><code>join(long timeout)</code>：join，但是时间到后也能结束其他线程的等待</p></li></ul><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><ul><li><p><code>setPriority(int priority)</code>：更改线程优先级</p></li><li><p><code>getPriority()</code>：获取线程优先级</p><p>priority 范围：</p><ul><li>MAX_PRIORITY：最高优先级（10）</li><li>MIN_PRIORITY：最低优先级（1）</li><li>NORM_PRIORITY：不高不低，真是好极了的优先级（5）</li></ul><blockquote><p>每个线程都有一个<strong>优先级</strong>。Java 线程调度采用如下优先级策略：</p></blockquote><ul><li>优先级高的先执行，优先级低的后执行</li><li>每个线程创建时会被自动分配一个优先级。默认的场合，继承父类优先级</li><li>任务紧急的线程，优先级较高</li><li>同优先级线程按 “先进先出” 原则调度</li></ul></li><li></li><li></li></ul><h1 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h1><p>线程的状态有（ java 官方枚举中给出的线程状态）：6种</p><ul><li><p>NEW：尚未启动</p></li><li><p>RUNNABLE：在 JVM 中执行的线程，可细分为 READY 和 RUNNING。</p></li><li><p>BLOCKED：被阻塞等待监视器锁定的线程</p></li><li><p>WAITING：正等待另一个线程执行特定动作的线程</p></li><li><p>TIMED_WAITING：正等待另一个线程执行特定动作达到等待时间的线程</p></li><li><p>TERMINATED：已退出的线程</p></li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310142205682.png"></p><h1 id="线程同步机制"><a href="#线程同步机制" class="headerlink" title="线程同步机制"></a>线程同步机制</h1><p>在多线程编程，一些敏感数据不允许被多个线程同时访问。此时就用同步访问技术，保证数据在任意时刻，最多有一个线程同时访问，以保证数据的完整性。</p><p>也可以这样理解：线程同步，即当有一个线程对内存进行操作时，其他线程都不能对这个内存地址进行操作（被阻塞），直到该线程完成操作，再让下一线程进行操作。</p><h2 id="实现同步"><a href="#实现同步" class="headerlink" title="实现同步"></a>实现同步</h2><p>最简单的方式是关键字 Synchronized。修饰<strong>代码块</strong>或者<strong>方法</strong></p><ul><li><code>wait()</code>：让当前线程释放所有其持有的 “对象互斥锁”，进入等待队列</li><li><code>notify()</code>、<code>notifyAll()</code>：唤醒一个或所有在等待队列中等待的线程，并将他们移入同一个等待 “对象互斥锁” 的队列。</li></ul><p>执行这些方法时如果没有等待中的线程，则其不会生效，也不会被保留到以后再生效。</p><p>因为调用这些方法时必须持有对象的 “对象互斥锁”，所以上述方法只能在 synhronized 方法或代码块中执行。</p><p>前面买票的改进</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">public class SellTicket &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SellTicket03 sellTicket03 = new SellTicket03();</span><br><span class="line">        new Thread(sellTicket03).start();//第1个线程-窗口</span><br><span class="line">        new Thread(sellTicket03).start();//第2个线程-窗口</span><br><span class="line">        new Thread(sellTicket03).start();//第3个线程-窗口</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//实现接口方式, 使用synchronized实现线程同步</span><br><span class="line">class SellTicket03 implements Runnable &#123;</span><br><span class="line">    private int ticketNum = 100;//让多个线程共享 ticketNum</span><br><span class="line">    private boolean loop = true;//控制run方法变量</span><br><span class="line">    Object object = new Object();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //同步方法（静态的）的锁为当前类本身</span><br><span class="line">    //1. public synchronized static void m1() &#123;&#125; 锁是加在 SellTicket03.class</span><br><span class="line">    //2. 如果在静态方法中，实现一个同步代码块.</span><br><span class="line">    public static  void m2() &#123;</span><br><span class="line">        synchronized (SellTicket03.class) &#123;</span><br><span class="line">            System.out.println(&quot;m2&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //1. public synchronized void sell() &#123;&#125; 就是一个同步方法</span><br><span class="line">    //2. 这时锁在 this对象</span><br><span class="line">    //3. 也可以在代码块上写 synchronize ,同步代码块, 互斥锁还是在this对象</span><br><span class="line">    public /*synchronized*/ void sell() &#123; //同步方法, 在同一时刻， 只能有一个线程来执行sell方法</span><br><span class="line">        synchronized (/*this*/ object) &#123;</span><br><span class="line">            if (ticketNum &lt;= 0) &#123;</span><br><span class="line">                System.out.println(&quot;售票结束...&quot;);</span><br><span class="line">                loop = false;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            //休眠50毫秒, 模拟</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(50);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;窗口 &quot; + Thread.currentThread().getName() + &quot; 售出一张票&quot;</span><br><span class="line">                    + &quot; 剩余票数=&quot; + (--ticketNum));//1 - 0 - -1  - -2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (loop) &#123;</span><br><span class="line">            sell();//sell方法是一共同步方法</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用Thread方式</span><br><span class="line">class SellTicket01 extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    private static int ticketNum = 100;//让多个线程共享 ticketNum</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (ticketNum &lt;= 0) &#123;</span><br><span class="line">                System.out.println(&quot;售票结束...&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //休眠50毫秒, 模拟</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(50);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;窗口 &quot; + Thread.currentThread().getName() + &quot; 售出一张票&quot;</span><br><span class="line">                    + &quot; 剩余票数=&quot; + (--ticketNum));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//实现接口方式</span><br><span class="line">class SellTicket02 implements Runnable &#123;</span><br><span class="line">    private int ticketNum = 100;//让多个线程共享 ticketNum</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (ticketNum &lt;= 0) &#123;</span><br><span class="line">                System.out.println(&quot;售票结束...&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //休眠50毫秒, 模拟</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(50);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;窗口 &quot; + Thread.currentThread().getName() + &quot; 售出一张票&quot;</span><br><span class="line">                    + &quot; 剩余票数=&quot; + (--ticketNum));//1 - 0 - -1  - -2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><ol><li>Java语言中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。</li><li>每个对象都对应于一个可称为“互斥锁”的标记，这个标记用来保证在任一时刻,， 只能有一个线程访问该对象。</li><li>关键宇synchronized来与对象的互斥锁联系。当某个对象用synchronized修饰时，表明该对象在任一时刻只能由一 个线程访问</li><li>同步的局限性：导致程序的执行效率要降低</li><li>同步方法(非静态的)的锁可以是this，也可以是其他对象(要求是同一个对象)。</li><li>同步方法(静态的)的锁为当前类本身。同步方法(静态的)的锁为当前类本身。</li></ol><blockquote><p>同步方法如果没有使用static修饰，默认锁对象：this</p><p>如果方法使用static修饰，默认锁对象：当前类.class</p></blockquote><p>Java 语言中，有 2 种方式实现互斥锁：</p><ul><li>用关键字 volatile 声明一个共享数据（变量）。一般很少使用该关键字</li><li>用关键字 synchronized 声明共享数据的一个方法或一个代码</li></ul><h2 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h2><p>多个线程都占用了对方的资源，不肯相让，就导致了死锁。编程时要避免死锁的产生。</p><ul><li><p>以下操作会释放锁</p><ol><li>当前线程的同步方法、同步代码块执行结束。</li><li>当前线程在同步方法、同步代码块中遇到 <code>break</code>、<code>return</code></li><li>当前线程在同步方法、同步代码块中出现了未处理的 <code>Error</code></li><li>当前线程在同步方法、同步代码块中执行了 <code>wait()</code> 方法，当前线程暂停，并释放锁</li></ol></li><li><p>以下操作不会释放锁</p><ol><li><p>执行同步方法、同步代码块时，程序调用 <code>Thread.sleep()</code> 或 <code>Thread.yield()</code> 方法暂停当前线程的执行，不会释放锁</p></li><li><p>线程执行同步代码块时，其他线程调用了该线程的 <code>suspend()</code> 方法将该线程挂起，该线程不会释放锁</p><p>所以，应尽量避免使用 <code>suspend()</code> 和 <code>resume()</code> 来控制线程</p></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaIO流</title>
      <link href="/2023/10/26/Java-io/"/>
      <url>/2023/10/26/Java-io/</url>
      
        <content type="html"><![CDATA[<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><p>我们对文件并不陌生，文件是保存数据的地方,比如大家经常使用的word文档,txt文件,exce|文件都是文件。它既可以保存一张图片， 也可以保持视频,声音…</p><p>文件流：文件在程序中是以<strong>流</strong>的形式来操作的。</p><p>流：数据在数据源（文件）和程序（内存）之间经历的路径</p><p>输入流：数据从数据源到程序（内存）的路径</p><p>输出流：数据从程序（内存）到数据源的路径</p><blockquote><p>输入输出以内存为主视角</p></blockquote><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310170906886.png"></p><h2 id="常用的文件操作"><a href="#常用的文件操作" class="headerlink" title="常用的文件操作"></a>常用的文件操作</h2><p>Java 提供了 File 类，用于处理文件相关的操作</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310170910414.png"></p><ol><li><p>创建文件对象相关构造器和方法</p><ul><li><p><code>new File(String pathname)</code>：根据路径创建一个 File 对象</p></li><li><p><code>new File(File parent, String child)</code>：根据父目录文件 + 子路径构建</p></li><li><p><code>new File(String parent, String child)</code>：根据父路径 + 子路径构建</p></li><li><p><code>creatNewFile()</code>：创建新文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">//方式1 new File(String pathname)</span><br><span class="line">   @Test</span><br><span class="line">   public void create01() &#123;</span><br><span class="line">       String filePath = &quot;e:\\test\\news1.txt&quot;;</span><br><span class="line">       //String filePath = &quot;e:/test/news2.txt&quot;;</span><br><span class="line">       //String filePath = &quot;e:\\test/news3.txt&quot;;</span><br><span class="line">       File file = new File(filePath);</span><br><span class="line">     </span><br><span class="line">       try &#123;</span><br><span class="line">           file.createNewFile();</span><br><span class="line">           System.out.println(&quot;文件创建成功&quot;);</span><br><span class="line">       &#125; catch (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">     </span><br><span class="line">   &#125;</span><br><span class="line">   //方式2 new File(File parent,String child) //根据父目录文件+子路径构建</span><br><span class="line">   //e:\\news2.txt</span><br><span class="line">   @Test</span><br><span class="line">   public  void create02() &#123;</span><br><span class="line">       File parentFile = new File(&quot;e:\\&quot;);</span><br><span class="line">       String fileName = &quot;news2.txt&quot;;</span><br><span class="line">       //这里的file对象，在java程序中，只是一个对象</span><br><span class="line">       //只有执行了createNewFile 方法，才会真正的，在磁盘创建该文件</span><br><span class="line">       File file = new File(parentFile, fileName);</span><br><span class="line">     </span><br><span class="line">       try &#123;</span><br><span class="line">           file.createNewFile();</span><br><span class="line">           System.out.println(&quot;创建成功~&quot;);</span><br><span class="line">       &#125; catch (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">     </span><br><span class="line">   //方式3 new File(String parent,String child) //根据父目录+子路径构建</span><br><span class="line">   @Test</span><br><span class="line">   public void create03() &#123;</span><br><span class="line">       //String parentPath = &quot;e:\\&quot;;</span><br><span class="line">       String parentPath = &quot;e:\\&quot;;</span><br><span class="line">       String fileName = &quot;news4.txt&quot;;</span><br><span class="line">       File file = new File(parentPath, fileName);</span><br><span class="line">     </span><br><span class="line">       try &#123;</span><br><span class="line">           file.createNewFile();</span><br><span class="line">           System.out.println(&quot;创建成功~&quot;);</span><br><span class="line">       &#125; catch (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>注意：</p><p>File file &#x3D; new File(…)：这里的file对象，在java程序中，只是一个对象，在内存里面</p><p>file.createNewFile()：只有执行了createNewFile 方法，才会真正的，在磁盘创建该文件</p></li></ul></li><li><p>获取文件相关信息</p><ul><li><p><code>getName()</code>：获取名称</p></li><li><p><code>getAbsolutePath()</code>：获取文件绝对路径</p></li><li><p><code>getParent()</code>：获取文件父级目录</p></li><li><p><code>long length()</code>：获取文件大小（字节）</p></li><li><p><code>exists()</code>：文件是否存在</p></li><li><p><code>isFile()</code>：是不是一个文件</p></li><li><p><code>isDirectory()</code>：是不是一个目录</p></li><li><p><code>isAbsolute()</code>：是不是绝对路径</p></li><li><p><code>canRead()</code>：是否可读</p><p><code>canWirte()</code>：是否可写</p></li><li><p><code>long lastModified()</code>：最后修改时间</p></li><li><p><code>String[] list()</code>：列出符合模式的文件名</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void info() &#123;</span><br><span class="line">    //先创建文件对象</span><br><span class="line">    File file = new File(&quot;e:\\test/news1.txt&quot;);</span><br><span class="line">   </span><br><span class="line">    //调用相应的方法，得到对应信息</span><br><span class="line">    System.out.println(&quot;文件名字=&quot; + file.getName());</span><br><span class="line">    //getName、getAbsolutePath、getParent、length、exists、isFile、isDirectory</span><br><span class="line">    System.out.println(&quot;文件绝对路径=&quot; + file.getAbsolutePath());</span><br><span class="line">    System.out.println(&quot;文件父级目录=&quot; + file.getParent());</span><br><span class="line">    System.out.println(&quot;文件大小(字节)=&quot; + file.length());</span><br><span class="line">    System.out.println(&quot;文件是否存在=&quot; + file.exists());//T</span><br><span class="line">    System.out.println(&quot;是不是一个文件=&quot; + file.isFile());//T</span><br><span class="line">    System.out.println(&quot;是不是一个目录=&quot; + file.isDirectory());//F</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310170930707.png"></p></li><li><p>目录的操作和文件删除</p><ul><li><code>mkdir</code>：创建一级目录</li><li><code>mkdirs</code>：创建多级目录</li><li><code>delete</code>：删除空目录或文件</li><li><code>boolean renameTo(File newName)</code>：更改文件名</li></ul><p>其实目录（在内存看来）就是特殊的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//判断 d:\\news1.txt 是否存在，如果存在就删除</span><br><span class="line">@Test</span><br><span class="line">public void m1() &#123;</span><br><span class="line">   </span><br><span class="line">    String filePath = &quot;e:\\test/news2.txt&quot;;</span><br><span class="line">    File file = new File(filePath);</span><br><span class="line">    if (file.exists()) &#123;</span><br><span class="line">        if (file.delete()) &#123;</span><br><span class="line">            System.out.println(filePath + &quot;删除成功&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(filePath + &quot;删除失败&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        System.out.println(&quot;该文件不存在...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//判断 D:\\demo\\a\\b\\c 目录是否存在，如果存在就提示已经存在，否则就创建</span><br><span class="line">@Test</span><br><span class="line">public void m3() &#123;</span><br><span class="line">   </span><br><span class="line">    String directoryPath = &quot;D:\\demo\\a\\b\\c&quot;;</span><br><span class="line">    File file = new File(directoryPath);</span><br><span class="line">    if (file.exists()) &#123;</span><br><span class="line">        System.out.println(directoryPath + &quot;存在..&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (file.mkdirs()) &#123; //创建一级目录使用mkdir() ，创建多级目录使用mkdirs()</span><br><span class="line">            System.out.println(directoryPath + &quot;创建成功..&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(directoryPath + &quot;创建失败...&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure></li></ol><p>注意事项：</p><ul><li>File 类可以获取文件的各种相关属性，可以对其进行改名，甚至删除。但除了文件名外的属性没有修改方法</li><li>File 类可以用来描述一个目录，但不能改变目录名，也不能删除目录</li></ul><h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><h2 id="IO原理"><a href="#IO原理" class="headerlink" title="IO原理"></a>IO原理</h2><ol><li>I &#x2F; O 是 Input &#x2F; Output 的缩写。IO 技术是非常实用的技术，用于处理数据传输。如 读 &#x2F; 写 文件，网络通讯等。</li><li>Java 程序中，对于数据的 输入 &#x2F; 输出 操作以 “流（stream）”的方式进行</li><li><code>java.io</code> 包下提供了各种 “流” 类和接口，用以获取不同种类的数据，并通过方法输入或输出数据</li><li>输入（input）：读取外部数据（磁盘、光盘、网络数据等）到程序（内存）中</li><li>输出（output）：将程序（内存）数据输出到外部存储</li></ol><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310170944722.png"></p><h2 id="IO流的分类"><a href="#IO流的分类" class="headerlink" title="IO流的分类"></a>IO流的分类</h2><ul><li><p>按操作数据单位不同分为：</p><ul><li>字节流（8 bit）：二进制文件用该方法，能确保文件无损</li><li>字符流（按照字符，字符的字节数由编码决定）：文本文件，效率更高</li></ul></li><li><p>按数据流的流向不同分为：</p><ul><li>输入流：读取外部数据（磁盘、光盘、网络数据等）到程序（内存）中</li><li>输出流：将程序（内存）数据输出到外部存储</li></ul></li><li><p>按流的角色不同分为：</p><ul><li>节点流</li><li>处理流 &#x2F; 包装流</li></ul><table><thead><tr><th>抽象基类</th><th>字节流</th><th>字符流</th></tr></thead><tbody><tr><td>输入流</td><td>InputStream</td><td>Reader</td></tr><tr><td>输出流</td><td>OutputStream</td><td>Writer</td></tr></tbody></table></li></ul><blockquote><p>Java 的 IO流 总共涉及 40多个类，实际上都是上述 4 类的<strong>抽象基类</strong>派生的</p><p>由这 4 个类派生的子类名称都是以其父类名作为子类名后缀</p></blockquote><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310170947934.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310170948041.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310170948378.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310170949552.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310170949910.png"></p><h2 id="流和文件"><a href="#流和文件" class="headerlink" title="流和文件"></a>流和文件</h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="IO流-常用类"><a href="#IO流-常用类" class="headerlink" title="IO流 常用类"></a>IO流 常用类</h2><h3 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h3><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310171014176.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310171016865.png"></p><ul><li><p>构造器：</p><ul><li>new FileInputStream(File file)：通过打开一个到实际文件的连接来创建一个FileIrputStream,该文件通过文件系统中的File 对象file 指定。</li><li>new FileInputStream(String path)：通过使用文件描述符fd0bj 创建-个FiloIrputStrem, 该文件描述符表示到文件系统中某个实际文件的现有连接。</li><li>new FileInputStream(FileDescriptor fdObj)：通过打开一个到实际文件的连接来创建一个PilernputStrean, 该文件通过文件系统中的路径名name 指定。</li></ul></li><li><p>方法：</p><ul><li><p><code>available()</code>：返回目前可以从流中读取的字节数，实际操作时，读取的字节数可能大于这个返回值</p></li><li><p><code>close()</code>：关闭此文件输入流并释放与此流有关的所有系统资源。</p></li><li><p><code>finalize()</code>：确保在不再引用文件输入流时调用其close 方法。</p></li><li><p><code>getChannel()</code>：返回与此流有关的唯一的 <code>FileChannel</code> 对象</p></li><li><p><code>getFD()</code>：返回描述符</p></li><li><p><code>skip(long n)</code>：从该输入流中跳过并去丢弃 n 个字节的数据</p></li><li><p><code>mark(int markArea)</code>：标记数据量的当前位置，并划出一个缓冲区。缓冲区大小至少为 markArea</p><p><code>reset()</code>：将输入流重新定位到对此流最后调用 <code>mark()</code> 方法时的位置</p><p><code>markSupported()</code>：测试数据流是否支持 <code>mark()</code> 和 <code>reset()</code> 操作</p></li><li><p><code>read()</code>：从该输入流中读取一个数据字节</p><p>如果没有输入可用，该方法会被阻止。返回 -1 的场合，说明到达文件的末尾。</p><p><code>read(byte[] b)</code>：从该输入流中把最多 b.length 个字节的数据读入一个 byte 数组</p><p>读取正常的场合，返回实际读取的字节数。</p><p><code>read(byte[] b, int off, int len)</code>：从该输入流中读取 len 字节数据，从数组下标 off 处起写入</p></li></ul></li></ul><p>read()例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public void readFile01() &#123;</span><br><span class="line">    String filePath = &quot;e:\\test/hi.txt&quot;;</span><br><span class="line">    int readData = 0;</span><br><span class="line">    FileInputStream fileInputStream = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        //创建 FileInputStream 对象，用于读取 文件</span><br><span class="line">        fileInputStream = new FileInputStream(filePath);</span><br><span class="line">        //从该输入流读取一个字节的数据。 如果没有输入可用，此方法将阻止。</span><br><span class="line">        //如果返回-1 , 表示读取完毕</span><br><span class="line">        while ((readData = fileInputStream.read()) != -1) &#123;</span><br><span class="line">            System.out.print((char)readData);//转成char显示</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //关闭文件流，释放资源.</span><br><span class="line">        try &#123;</span><br><span class="line">            fileInputStream.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>read()一次只读一个byte，用循环的方式读取完整个文件的内容，debug时可以看见执行流程，图中 readData 的值会改变，是内容的 ASCII 码</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310171039248.png"></p><p>read(byte[] b)例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public void readFile02() &#123;</span><br><span class="line">    String filePath = &quot;e:\\test/hi.txt&quot;;</span><br><span class="line">    //字节数组</span><br><span class="line">    byte[] buf = new byte[8]; //一次读取8个字节.</span><br><span class="line">    int readLen = 0;</span><br><span class="line">    FileInputStream fileInputStream = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        //创建 FileInputStream 对象，用于读取 文件</span><br><span class="line">        fileInputStream = new FileInputStream(filePath);</span><br><span class="line">        //从该输入流读取最多b.length字节的数据到字节数组。 此方法将阻塞，直到某些输入可用。</span><br><span class="line">        //如果返回-1 , 表示读取完毕</span><br><span class="line">        //如果读取正常, 返回实际读取的字节数</span><br><span class="line">        while ((readLen = fileInputStream.read(buf)) != -1) &#123;</span><br><span class="line">            System.out.print(new String(buf, 0, readLen));//显示</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //关闭文件流，释放资源.</span><br><span class="line">        try &#123;</span><br><span class="line">            fileInputStream.close();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>read(byte[] b) 一次读一个数组的内容，一次够用，就结束并堵塞后面的空位，一次不够就用循环的方式读取完整个文件的内容，debug时可以看见执行流程，图中 buf 的值会改变，是内容的 ASCII 码。</p><p>图中len表示这次读到的东西的长度，第二次只读到2个，后面的都是上一次的脏数据</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310171048636.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310171049716.png"></p><h3 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h3><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310171054116.png"></p><ul><li><p>构造器：</p><ul><li>FileOutputStream(File file)：创建一个向指定 File对象表示的文件中写入数据的文件输出流。</li><li>FileOutputStream(File file, boolean append)：append &#x3D; false，写入采用 覆盖原文件 方式。append &#x3D; true 的场合，写入采用 末尾追加 方式</li><li>FileOutputStream(String path)：通过一个路径指定创建</li><li>FileOutputStream(String path, boolean append)：创建一个向具有指定nane的文件中写入数据的输出文件流。</li><li>FileOutputStream(FileDescriptor fdObj)：创建一个向指定文件描述符处写入数据的输出文件流，该文件描述符表示一个到文件系统中的某个</li></ul></li><li><p>方法：</p><ul><li><p><code>close()</code>：关闭文件输入流，释放资源</p></li><li><p><code>flush()</code>：刷新此输出流并强制写出所有缓冲的输出字节</p></li><li><p><code>finalize()</code>：确保在不引用文件输入流时调用其 <code>close()</code> 方法</p></li><li><p><code>getChannel()</code>：返回与此流有关的唯一的 <code>FileChannel</code> 对象</p></li><li><p><code>getFD()</code>：返回描述符</p></li><li><p><code>write(byte[] b)</code>：将 b.length 个字节从指定 byte 数组写入此文件输出流</p><p><code>write(byte[] b， int off, int len)</code>：将指定 byte 数组中下标 off 开始的 len 个字节写入此文件输出流</p><p><code>write(int b)</code>：将指定字节写入此文件输出流</p></li></ul></li></ul><p>write例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public void writeFile() &#123;</span><br><span class="line"></span><br><span class="line">        //创建 FileOutputStream对象</span><br><span class="line">        String filePath = &quot;e:\\a.txt&quot;;</span><br><span class="line">        FileOutputStream fileOutputStream = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            //得到 FileOutputStream对象 对象</span><br><span class="line">            //老师说明</span><br><span class="line">            //1. new FileOutputStream(filePath) 创建方式，当写入内容是，会覆盖原来的内容</span><br><span class="line">            //2. new FileOutputStream(filePath, true) 创建方式，当写入内容是，是追加到文件后面</span><br><span class="line">            fileOutputStream = new FileOutputStream(filePath, true);</span><br><span class="line">            //写入一个字节</span><br><span class="line">            //fileOutputStream.write(&#x27;H&#x27;);//</span><br><span class="line">            //写入字符串</span><br><span class="line">            String str = &quot;fuck,navid&quot;;</span><br><span class="line">            //str.getBytes() 可以把 字符串-&gt; 字节数组</span><br><span class="line">            fileOutputStream.write(str.getBytes());</span><br><span class="line">            /*</span><br><span class="line">            write(byte[] b, int off, int len) 将 len字节从位于偏移量 off的指定字节数组写入此文件输出流</span><br><span class="line">             */</span><br><span class="line">            //fileOutputStream.write(str.getBytes(), 0, 3);</span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                fileOutputStream.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="测试：文件拷贝"><a href="#测试：文件拷贝" class="headerlink" title="测试：文件拷贝"></a>测试：文件拷贝</h3><p>避免文件很大的情况，应该边输入边输出</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310171120171.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">    String path1 = &quot;E:\\picture/46d1afbd0709d10e398d8a5ed1f26b21ff71b817.jpg&quot;;</span><br><span class="line">    String path2 = &quot;E:\\picture/yuezhengling.jpg&quot;;</span><br><span class="line">    FileInputStream fileInputStream = null;</span><br><span class="line">    FileOutputStream fileOutputStream = null;</span><br><span class="line"></span><br><span class="line">    fileInputStream = new FileInputStream(path1);</span><br><span class="line">    fileOutputStream = new FileOutputStream(path2);</span><br><span class="line">    byte[] bytes = new byte[1024];</span><br><span class="line">    int len = 0;</span><br><span class="line">    while ((len = fileInputStream.read(bytes)) != -1) &#123;</span><br><span class="line">        //读取到后，就写入到文件 通过 fileOutputStream</span><br><span class="line">        //即，是一边读，一边写</span><br><span class="line">        fileOutputStream.write(bytes, 0, len);//一定要使用这个方法</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;拷贝ok~&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FileReader：文件字符输入流"><a href="#FileReader：文件字符输入流" class="headerlink" title="FileReader：文件字符输入流"></a>FileReader：文件字符输入流</h3><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310171135921.png"></p><p>与其他程序设计语言使用 ASCII 码不同，Java 使用 Unicode 码表示字符串和字符。ASCII 码的字符占用 1 字节，可以认为一个字符就是一个字节。但 Unicode 码用 2 字节表示 1 个字符，此时字符流和字节流就不相同。</p><ul><li><p>构造器：</p><p>FileReader(File file)</p><p>FileReader(String string)</p></li><li><p>方法：</p><ul><li><code>read()</code>：读取单个字符。如果到文件末尾返回-1</li><li><code>read(char[])</code>：批量读取多个字符到数组。返回读取到的字符数，如果到文件末尾返回-1</li></ul></li><li><p>相关API：</p><ul><li>new String(char[])：将char[]转换成String</li><li>new String(char[], off, len)：将char[]的指定部分转换成String</li></ul></li></ul><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">   public void readFile01() &#123;</span><br><span class="line">       String filePath = &quot;e:\\story.txt&quot;;</span><br><span class="line">       FileReader fileReader = null;</span><br><span class="line">       int data = 0;</span><br><span class="line">       //1. 创建FileReader对象</span><br><span class="line">       try &#123;</span><br><span class="line">           fileReader = new FileReader(filePath);</span><br><span class="line">           //循环读取 使用read, 单个字符读取</span><br><span class="line">           while ((data = fileReader.read()) != -1) &#123;</span><br><span class="line">               System.out.print((char) data);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125; catch (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               if (fileReader != null) &#123;</span><br><span class="line">                   fileReader.close();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; catch (IOException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 字符数组读取文件</span><br><span class="line">    */</span><br><span class="line">   @Test</span><br><span class="line">   public void readFile02() &#123;</span><br><span class="line">       System.out.println(&quot;~~~readFile02 ~~~&quot;);</span><br><span class="line">       String filePath = &quot;e:\\story.txt&quot;;</span><br><span class="line">       FileReader fileReader = null;</span><br><span class="line"></span><br><span class="line">       int readLen = 0;</span><br><span class="line">       char[] buf = new char[8];</span><br><span class="line">       //1. 创建FileReader对象</span><br><span class="line">       try &#123;</span><br><span class="line">           fileReader = new FileReader(filePath);</span><br><span class="line">           //循环读取 使用read(buf), 返回的是实际读取到的字符数</span><br><span class="line">           //如果返回-1, 说明到文件结束</span><br><span class="line">           while ((readLen = fileReader.read(buf)) != -1) &#123;</span><br><span class="line">               System.out.print(new String(buf, 0, readLen));</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125; catch (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               if (fileReader != null) &#123;</span><br><span class="line">                   fileReader.close();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; catch (IOException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="FileWriter：文件字符输出流"><a href="#FileWriter：文件字符输出流" class="headerlink" title="FileWriter：文件字符输出流"></a>FileWriter：文件字符输出流</h3><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310171143080.png"></p><ul><li><p>构造器：</p><p>FileWriter(File &#x2F; String)：覆盖模式，相当于流的指针在首端</p><p>FileWriter(File &#x2F; String,true)：追加模式，相当于流的指针在尾端</p><blockquote><p>注意以上都是2个方法，参考前面的字节流</p></blockquote></li><li><p>方法</p><ul><li><p>write(int):写入单个字符</p></li><li><p>write(char[]):写入指定数组</p><blockquote><p>因为是以字符为单位了，所以用的是 char[]，用不了 byte[] 了</p></blockquote></li><li><p>write(char[],0,len):写入指定数组的指定部分</p></li><li><p>write (string) :写入整个字符串</p></li><li><p>write(string,off,len):写入字符串的指定部分</p></li></ul></li><li><p>相关API</p><p>String类: toCharArray:将String转换成char[]</p></li></ul><blockquote><p>FileWriter使用后，必须要关闭(close)或刷新(flush)， 否则写入不到指定的文件!</p></blockquote><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        String filePath = &quot;e:\\note.txt&quot;;</span><br><span class="line">        //创建FileWriter对象</span><br><span class="line">        FileWriter fileWriter = null;</span><br><span class="line">        char[] chars = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;;</span><br><span class="line">        try &#123;</span><br><span class="line">            fileWriter = new FileWriter(filePath);//默认是覆盖写入</span><br><span class="line">//            3) write(int):写入单个字符</span><br><span class="line">            fileWriter.write(&#x27;H&#x27;);</span><br><span class="line">//            4) write(char[]):写入指定数组</span><br><span class="line">            fileWriter.write(chars);</span><br><span class="line">//            5) write(char[],off,len):写入指定数组的指定部分</span><br><span class="line">            fileWriter.write(&quot;韩顺平教育&quot;.toCharArray(), 0, 3);</span><br><span class="line">//            6) write（string）：写入整个字符串</span><br><span class="line">            fileWriter.write(&quot; 你好北京~&quot;);</span><br><span class="line">            fileWriter.write(&quot;风雨之后，定见彩虹&quot;);</span><br><span class="line">//            7) write(string,off,len):写入字符串的指定部分</span><br><span class="line">            fileWriter.write(&quot;上海天津&quot;, 0, 2);</span><br><span class="line">            //在数据量大的情况下，可以使用循环操作.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                //fileWriter.flush();</span><br><span class="line">                //关闭文件流，等价 flush() + 关闭</span><br><span class="line">                fileWriter.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;程序结束...&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：一定要关闭文件流，不然有文件，但是文件是空的</p></blockquote><p>关闭的时候，用 fileWriter.flush(); 和 fileWriter.close(); 效果是一样的，都会跑到同一个源码</p><h4 id="fileWriter-close-的源码分析："><a href="#fileWriter-close-的源码分析：" class="headerlink" title="fileWriter.close() 的源码分析："></a>fileWriter.close() 的源码分析：</h4><ol><li><p>强制进入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void close() throws IOException &#123;</span><br><span class="line">    se.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>强制进入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void close() throws IOException &#123;</span><br><span class="line">    synchronized(this.lock) &#123;</span><br><span class="line">        if (this.isOpen) &#123;</span><br><span class="line">            this.implClose();</span><br><span class="line">            this.isOpen = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进入 this.implClose(); 方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void implClose() throws IOException &#123;</span><br><span class="line">        this.flushLeftoverChar((CharBuffer)null, true);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            while(true) &#123;</span><br><span class="line">                CoderResult var1 = this.encoder.flush(this.bb);</span><br><span class="line">                if (var1.isUnderflow()) &#123;</span><br><span class="line">                    if (this.bb.position() &gt; 0) &#123;</span><br><span class="line">                        this.writeBytes();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (this.ch != null) &#123;</span><br><span class="line">                        this.ch.close();</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        this.out.close();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (var1.isOverflow()) &#123;</span><br><span class="line">                    assert this.bb.position() &gt; 0;</span><br><span class="line"></span><br><span class="line">                    this.writeBytes();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    var1.throwException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException var2) &#123;</span><br><span class="line">            this.encoder.reset();</span><br><span class="line">            throw var2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>this.writeBytes()</p></li><li><p>强制进入 this.writeBytes()。此时，才是真正写入东西的时候</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void writeBytes() throws IOException &#123;</span><br><span class="line">    this.bb.flip();</span><br><span class="line">    int var1 = this.bb.limit();</span><br><span class="line">    int var2 = this.bb.position();</span><br><span class="line">   </span><br><span class="line">    assert var2 &lt;= var1;</span><br><span class="line">   </span><br><span class="line">    int var3 = var2 &lt;= var1 ? var1 - var2 : 0;</span><br><span class="line">    if (var3 &gt; 0) &#123;</span><br><span class="line">        if (this.ch != null) &#123;</span><br><span class="line">            assert this.ch.write(this.bb) == var3 : var3;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.out.write(this.bb.array(), this.bb.arrayOffset() + var2, var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    this.bb.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310180942644.png"></p></li></ol><h2 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310181008318.png"></p><ul><li><p>节点流：从一个特定数据源读写数据。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310181011884.png"></p></li><li><p>处理流（包装流）：是 “连接” 在已存在的流（节点流或处理流）上，为程序提供更强大的读写功能。</p></li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310181008393.png"></p><blockquote><p>回顾一下按字节处理和按字符处理，他们的基类和子类名字上的联系</p></blockquote><h3 id="bufferedReader源码例子"><a href="#bufferedReader源码例子" class="headerlink" title="bufferedReader源码例子"></a>bufferedReader源码例子</h3><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310181017851.png"></p><p>图中可见，有个属性是 Readeer 类型，有多态特性，这个变量以后可以接受所有的 Reader 的子类，拓展了功能。</p><blockquote><p>这里只是以 BufferedReader 为例，这样的类还有很多</p></blockquote><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310181024302.png"></p><h3 id="节点流和处理流的区别和联系"><a href="#节点流和处理流的区别和联系" class="headerlink" title="节点流和处理流的区别和联系"></a>节点流和处理流的区别和联系</h3><p>节点流和处理流的区别和联系：</p><ol><li>节点流是 底层流 &#x2F; 低级流。直接和数据源相接。</li><li>处理流（包装流）包装节点流，既可以消除不同节点流的实现差异，也可以提供更方便的方法完成输入输出</li><li>处理流对节点流进行包装，使用了修饰器设计模式。不会直接与数据源相连</li></ol><p>处理流的功能主要体现在</p><ul><li>性能的提高：以增加缓冲的方式提高输入输出的效率</li><li>操作的便捷：处理流可能提供了一系列便捷方法来一次性输入大量数据，使用更加灵活方便</li></ul><p>关闭时关闭外层流即可</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310201000697.png"> </p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310201028445.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310201030987.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven高级</title>
      <link href="/2023/10/25/Maven%E9%AB%98%E7%BA%A7/"/>
      <url>/2023/10/25/Maven%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="分模块开发"><a href="#分模块开发" class="headerlink" title="分模块开发"></a>分模块开发</h1><h2 id="分模块开发设计"><a href="#分模块开发设计" class="headerlink" title="分模块开发设计"></a>分模块开发设计</h2><ol><li>按照功能拆分<ul><li>我们之前的项目都是在一个模块中，比如上篇文章的SSM整合，虽然这样做，功能也都实现了，但是也存在一些问题，我们拿银行的项目举例，来聊聊这件事<ul><li>网络没有那么发达的时候，我们需要到银行柜台或者取款机进行业务操作</li><li>随着互联网的发展，我们有了电脑之后，就可以在网页上登录银行网站使用U盾进行业务操作</li><li>再来就是随着智能手机的普及，我们只需要用手机登录App就可以进行业务操作</li></ul></li><li>上面三个场景出现的时间轴是不同的，如果非要把三个场景的模块代码放到同一个项目，那么当其中某一个模块代码出现问题，就会导致整个项目都无法正常启动，从而导致银行的多个业务都无法正常办理，所以我们会<code>按照功能</code>将项目进行炒粉</li></ul></li><li>按照模块拆分<ul><li>比如电商项目中，有订单和商品两个模块，订单中需要包含商品的详细信息，所以需要商品的模型类，商品模块也会用到商品的模型类，这个时候如果两个模块中都写模型类，就会出现重复代码，后期维护的成本就比较高。我们就想能不能把它们公共的部分抽取成一个独立的模块，其他模块想要使用就可以像<code>导入第三方依赖的坐标</code>一样来使用我们自己抽取的模块，这样就解决了代码重复的问题，这种拆分方式就是我们所说的<code>按照模块</code>拆分</li></ul></li></ol><p>之前的项目包结构如下：</p><ul><li><code>com.blog.config</code>目录存放的是相关的配置类</li><li><code>com.blog.controller</code>编写的是Controller类</li><li><code>com.blog.dao</code>存放的是Dao接口，因为使用的是Mapper接口代理方式，所以没有实现类包</li><li><code>com.blog.service</code>存的是Service接口，<code>com.blog.service.impl</code>存放的是Service实现类</li></ul><p>那我们现在就可以把这些包按照功能拆分成若干个子模块，方便模块之间的相互调用，接口供销，这样的话，项目中的每一层都可以单独维护，也可以很方便的被别人使用。</p><p>那么关于分模块开发的意义，我们就讲完了，说了这么多好处，那么该如何实现呢?</p><h2 id="分模块开发实现"><a href="#分模块开发实现" class="headerlink" title="分模块开发实现"></a>分模块开发实现</h2><p>前面我们已经完成了SSM整合，接下来，我们就基于SSM整合的项目来实现对项目的拆分。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>复制一份之前的ssm项目</p><h3 id="抽取domain层"><a href="#抽取domain层" class="headerlink" title="抽取domain层"></a>抽取domain层</h3><ul><li><p>步骤一：</p><p>创建新模块：</p><ul><li>创建一个名为<code>maven_02_pojo</code>的maven项目</li></ul></li><li><p>步骤二：</p><p>项目中创建domain包：</p><ul><li>在<code>maven_02_pojo</code>中创建<code>com.blog.domain</code>包，并将<code>maven_01_ssm</code>的Book类拷贝到该包中</li></ul></li><li><p>步骤三：</p><p>删除原项目中的domain包：</p><ul><li>删除后，<code>maven_01_ssm</code>项目中用到<code>Book</code>的类中都会爆红</li><li>要想解决上述问题，我们需要在<code>maven_01_ssm</code>中添加<code>maven_02_pojo</code>的依赖。</li></ul></li><li><p>步骤四：</p><p>在<code>maven_01_ssm</code>项目的pom.xml添加<code>maven_02_pojo</code>的依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven_02_pojo&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>因为添加了依赖，所以在<code>maven_01_ssm</code>中就已经能找到Book类，所以刚才的爆红提示就会消失。</p></li></ul><ul><li><p>步骤五：编译maven_01_ssm项目</p><p>控制台会报错，意思就是找不到maven_02_pojo这个jar包</p><p>为啥找不到呢？</p><ul><li>原因是Maven会从本地仓库找对应的jar包，但是本地仓库又不存在该jar包所以会报错。</li><li>在IDEA中是有<code>maven_02_pojo</code>这个项目，所以我们只需要将<code>maven_02_pojo</code>项目安装到本地仓库即可。</li></ul></li><li><p>步骤六：将项目安装本地仓库</p><p>将需要被依赖的项目<code>maven_02_pojo</code>，使用maven的<code>install</code>命令，把其安装到Maven的本地仓库中</p><p>之后再次执行<code>maven_01_ssm</code>的<code>compile</code>的命令后，就已经能够成功编译。</p></li></ul><h3 id="抽取dao层"><a href="#抽取dao层" class="headerlink" title="抽取dao层"></a>抽取dao层</h3><ul><li><p><code>步骤一：</code>创建新模块</p><ul><li>创建一个名为<code>maven_03_dao</code>的maven项目</li></ul></li><li><p><code>步骤二：</code>项目中创建<code>dao</code>包</p><ul><li><p>在<code>maven_03_dao</code>项目中创建<code>com.blog.dao</code>包，并将<code>maven_01_ssm</code>中BookDao类拷贝到该包中</p></li><li><p>在maven_03_dao中会有如下几个问题需要解决下</p><p>项目maven_03_dao的BookDao接口中Book类找不到报错</p><p>解决方案在<code>maven_03_dao</code>项目的pom.xml中添加<code>maven_02_pojo</code>项目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven_02_pojo&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>项目<code>maven_03_dao</code>的BookDao接口中，Mybatis的增删改查注解报错</p><p>解决方案在<code>maven_03_dao</code>项目的pom.xml中添加<code>mybatis</code>的相关依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.5.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.46&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>最后记得使用maven的<code>install</code>命令，把其安装到Maven的本地仓库中</p></li></ul></li><li><p><code>步骤三：</code>删除原项目中的<code>dao</code>包</p><ul><li><p>删除Dao包以后，因为<code>maven_01_ssm</code>中的BookServiceImpl类中有使用到Dao的内容，所以需要在<code>maven_01_ssm</code>的pom.xml添加<code>maven_03_dao</code>的依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven_03_dao&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>步骤四：</code>运行测试</p><ul><li>启动Tomcat服务器，访问<code>http://localhost:8080/pages/books.html</code></li><li>将抽取后的项目进行运行，测试之前的增删改查功能依然能够使用。</li></ul></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>对于项目的拆分，大致会有如下几个步骤</p><ol><li>创建Maven模块</li><li>书写模块代码<ul><li>分模块开发需要先针对模块功能进行设计，再进行编码。不会先将工程开发完毕，然后进行拆分。拆分方式可以按照功能拆也可以按照模块拆。</li></ul></li><li>通过maven指令安装模块到本地仓库(install 指令)<ul><li>由于maven指令只能安装到自己电脑的仓库里，那么团队内部开发需要发布模块功能，需要到团队内部可共享的仓库中(私服)，私服我们后面会讲解。</li></ul></li></ol><h1 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h1><p>我们现在已经能把项目拆分成一个个独立的模块，当在其他项目中想要使用独立出来的这些模块，只需要在其pom.xml使用<code>&lt;dependency&gt;</code>标签来进行jar包的引入即可。<br><code>&lt;dependency&gt;</code>其实就是依赖，关于依赖管理里面涉及的内容有：</p><ul><li>依赖传递</li><li>可选依赖</li><li>排除依赖</li></ul><p>依赖:</p><ul><li><p>依赖指当前项目运行所需的jar一个项目可以设置多个依赖。</p></li><li><p>格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--设置当前项目所依赖的所有jar--&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!--设置具体的依赖--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;!--依赖所属群组id--&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;!--依赖所属项目id--&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">        &lt;!--依赖版本号--&gt;</span><br><span class="line">        &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="依赖传递与冲突问题"><a href="#依赖传递与冲突问题" class="headerlink" title="依赖传递与冲突问题"></a>依赖传递与冲突问题</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310241026863.png"></p><p>依赖是具有传递性的</p><p>A代表自己的项目；B，C，D，E，F，G代表的是项目所依赖的jar包；D1和D2、E1和E2代表是相同jar包的不同版本</p><ol><li>A依赖了B和C，B和C有分别依赖了其他jar包，所以在A项目中就可以使用上面所有jar包，这就是所说的依赖传递</li><li>依赖传递有直接依赖和间接依赖<ul><li>相对于A来说，A直接依赖B和C，间接依赖了D1，E1，G，F，D2和E2</li><li>相对于B来说，B直接依赖了D1和E1，间接依赖了G</li><li>直接依赖和间接依赖是一个相对的概念</li></ul></li><li>因为有依赖传递的存在，就会导致jar包在依赖的过程中出现冲突问题，具体什么是冲突？Maven是如何解决冲突的？</li></ol><p>这里所说的<code>依赖冲突</code>是指项目依赖的某一个jar包，有多个不同的版本，因而造成类包版本冲突。</p><ul><li><p>情况一：在maven_01_ssm的pom.xml中添加两个不同版本的Junit依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">      &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;4.11&lt;/version&gt;</span><br><span class="line">      &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>调换位置，刷新maven面板，我们会发现，maven的dependencies面板上总是显示使用的是后加载的jar包<br>于是我们得出一个结论：</p><ul><li>特殊优先：当同级配置了相同资源的不同版本，后配置的覆盖先配置的。</li></ul></li><li><p>情况二：路径优先：当依赖中出现相同的资源时，层级越深，优先级越低，层级越浅，优先级越高</p><ul><li>A通过B间接依赖到E1</li><li>A通过C间接依赖到E2</li><li>A就会间接依赖到E1和E2，Maven会按照层级来选择，E1是2度，E2是3度，所以最终会选择E1</li></ul></li><li><p>情况三：声明优先：当资源在相同层级被依赖时，配置顺序靠前的覆盖配置顺序靠后的</p><ul><li>A通过B间接依赖到D1</li><li>A通过C间接依赖到D2</li><li>D1和D2都是两度，这个时候就不能按照层级来选择，需要按照声明来，谁先声明用谁，也就是说B在C之前声明，这个时候使用的是D1，反之则为D2</li></ul><p>但是对于上面的结果，我们也不用刻意去记，一切以maven的dependencies面板上显示的为准</p></li></ul><h2 id="可选依赖和排除依赖"><a href="#可选依赖和排除依赖" class="headerlink" title="可选依赖和排除依赖"></a>可选依赖和排除依赖</h2><p>依赖传递介绍完以后，我们来思考一个问题，假如</p><ul><li><code>maven_01_ssm</code> 依赖了 <code>maven_03_dao</code></li><li><code>maven_03_dao</code> 依赖了 <code>maven_02_pojo</code></li><li>因为现在有依赖传递，所以<code>maven_01_ssm</code>能够使用到<code>maven_02_pojo</code>的内容</li><li>如果说现在不想让<code>maven_01_ssm</code>依赖到<code>maven_02_pojo</code>，有哪些解决方案?</li></ul><p><code>方案一：</code>可选依赖</p><ul><li><p>可选依赖指对外隐藏当前所依赖的资源—<code>不透明</code></p></li><li><p>在<code>maven_03_dao</code>的pom.xml，在引入<code>maven_02_pojo</code>的时候，添加<code>optional</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven_02_pojo&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;!--可选依赖是隐藏当前工程所依赖的资源，隐藏后对应资源将不具有依赖传递--&gt;</span><br><span class="line">    &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ul><p><code>方案二：</code>排除依赖</p><ul><li><p>排除依赖指主动断开依赖的资源，被排除的资源无需指定版本—<code>不需要</code></p></li><li><p>前面我们已经通过可选依赖实现了阻断<code>maven_02_pojo</code>的依赖传递，对于排除依赖，则指的是已经有依赖的事实，也就是说<code>maven_01_ssm</code>项目中已经通过依赖传递用到了<code>maven_02_pojo</code>，此时我们需要做的是将其进行排除，所以接下来需要修改<code>maven_01_ssm</code>的pom.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven_03_dao&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;!--排除依赖是隐藏当前资源对应的依赖关系--&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;!--这里可以排除多个依赖，只要你有需求--&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven_02_pojo&lt;/artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ul><p>介绍完这两种方式后，简单来梳理下，就是</p><ul><li><code>A依赖B，B依赖C</code>，<code>C</code>通过依赖传递会被<code>A</code>使用到，现在要想办法让<code>A</code>不去依赖<code>C</code></li><li>可选依赖是在B上设置<code>&lt;optional&gt;</code>，<code>A</code>不知道有<code>C</code>的存在，</li><li>排除依赖是在A上设置<code>&lt;exclusions&gt;</code>，<code>A</code>知道有<code>C</code>的存在，主动将其排除掉。</li></ul><blockquote><p>可选依赖就像抄答案，我抄完了不像让别人抄</p><p>排除依赖就像有答案，但我是个好学生，主动不抄</p></blockquote><h1 id="聚合与继承"><a href="#聚合与继承" class="headerlink" title="聚合与继承"></a>聚合与继承</h1><p>我们的项目已经从以前的单模块，变成了现在的多模块开发。项目一旦变成了多模块开发以后，就会引发一些问题，在这一节中我们主要会学习两个内容<code>聚合</code>和<code>继承</code>，用这两个知识来解决下分模块后的一些问题。</p><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310241039145.png"></p><ul><li>分模块开发后，需要将这四个项目都安装到本地仓库，目前我们只能通过项目Maven面板的install来安装，并且需要安装四个，如果我们的项目足够多，那一个个install也挺麻烦的</li><li>如果四个项目都已经安装成功，当ssm_pojo发生变化后，我们就得将ssm_pojo重新安装到maven仓库，但是为了确保我们对ssm_pojo的修改不会影响到其他模块（比如我们将pojo类中的一个属性删除，如果其他模块调用了这个属性，那必然报错），我们需要对所有模块重新编译，看看有没有问题。然后还需要将所有模块再install一遍</li></ul><p>项目少的话还好，但是如果项目多的话，一个个操作项目就容易出现漏掉或重复操作的问题，所以我们就像能不能抽取一个项目，把所有的项目管理起来，以后再想操作这些项目，做需要操作我们抽取的这个项目，这样就省事儿多了</p><p>这就要用到我们接下来讲的<code>聚合</code>了</p><ul><li>所谓聚合：将多个模块组织成一个整体，同时进行项目构建的过程称为聚合</li><li>聚合工程：通常是一个不具有业务功能的<code>空</code>工程</li><li>作用：使用聚合工程可以将多个工程编组，通过对聚合工程的构建，实现对所包含的所有模块进行同步构建<ul><li>当工程中某个模块发生更新后，必须保障工程中与更新模块关联的模块同步更新，此时就可以使用聚合工程来解决批量模块同步构建的问题</li></ul></li></ul><p>具体实现步骤如下：</p><ul><li><p><code>步骤一：</code>创建一个空的maven项目</p></li><li><p><code>步骤二：</code>将项目打包方式改为<code>pom</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven_00_parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;!--设置打包方式--&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li></ul><p>说明：项目的打包方式，我们接触到的有三种，分别是</p><ol><li>jar:默认情况，说明该项目为java项目</li><li>war:说明该项目为web项目</li><li>pom:说明该项目为聚合或继承(后面会讲)项目</li></ol><ul><li><p><code>步骤三：</code>pom.xml添加所要管理的项目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven_00_parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;!--设置打包方式--&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--设置管理的项目名称--&gt;</span><br><span class="line">    &lt;modules&gt;</span><br><span class="line">        &lt;module&gt;../maven_01_ssm&lt;/module&gt;</span><br><span class="line">        &lt;module&gt;../maven_02_pojo&lt;/module&gt;</span><br><span class="line">        &lt;module&gt;../maven_03_dao&lt;/module&gt;</span><br><span class="line">    &lt;/modules&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>步骤四：</code>使用聚合统一管理项目<br>在maven面板上点击compile，会发现所有受管理的项目都会被执行编译，这就是聚合工程的作用</p></li></ul><p>说明：聚合工程管理的项目在进行运行的时候，会按照项目与项目之间的依赖关系来自动决定执行的顺序和配置的顺序无关。虽然我们配置的顺序是<code>123</code>，但是执行的时候按照依赖关系编译是<code>231</code>。</p><blockquote><p>将每个项目当做资源，没有前置资源的最优先，然后是当前资源能够满足的项目，直到完成</p></blockquote><p>最后总结一句话就是，<strong>聚合工程主要是用来管理项目</strong>。</p><blockquote><p>超市买东西，最后再<strong>买</strong>个袋子打包</p></blockquote><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>我们已经完成了使用聚合工程去管理项目，聚合工程进行某一个构建操作，其他被其管理的项目也会执行相同的构建操作。那么接下来，我们再来分析下，多模块开发存在的另外一个问题，<code>重复配置</code>的问题，我们先来看张图:</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310241043314.png"></p><ul><li><code>spring-webmvc</code>、<code>spring-jdbc</code>在三个项目模块中都有出现，这样就出现了重复的内容</li><li><code>spring-test</code>只在ssm_crm和ssm_goods中出现，而在ssm_order中没有，这里是部分重复的内容</li><li>我们使用的spring版本目前是<code>5.2.10.RELEASE</code>，假如后期要想升级spring版本，所有跟Spring相关jar包都得被修改，涉及到的项目越多，维护成本越高</li></ul><p>面对上面这些问题，我们就得用到接下来要学习的<code>继承</code>（类似 java 语言中的继承）</p><ul><li>所谓继承：描述的是两个工程间的关系，与java中的继承类似，子工程可以继承父工程中的配置信息，常见于依赖关系的继承</li><li>作用：<ul><li>简化配置</li><li>减少版本冲突</li></ul></li></ul><p>实现步骤：</p><ul><li><p><code>步骤一：</code>创建一个空的Maven项目并将其打包方式设置为pom</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven_00_parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;!--设置打包方式--&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>步骤二：</code>在子工程中设置其父工程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置当前工程继承自parent工程--&gt;</span><br><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;artifactId&gt;maven_00_parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;!--配置父项目的pom.xml路径--&gt;</span><br><span class="line">    &lt;relativePath&gt;../maven_00_parent/pom.xml&lt;/relativePath&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>步骤三：</code>优化子项目共有依赖导入问题</p><ol><li><p>将子项目共同使用的jar包都抽取出来，维护在父项目的pom.xml中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">        xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven_00_parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;!--设置打包方式--&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--设置管理的项目名称--&gt;</span><br><span class="line">    &lt;modules&gt;</span><br><span class="line">        &lt;module&gt;../maven_01_ssm&lt;/module&gt;</span><br><span class="line">        &lt;module&gt;../maven_02_pojo&lt;/module&gt;</span><br><span class="line">        &lt;module&gt;../maven_03_dao&lt;/module&gt;</span><br><span class="line">    &lt;/modules&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.5.6&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.3.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.46&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.16&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.9.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li><li><p>删除子项目中已经被抽取到父项目的pom.xml中的jar包</p><ul><li>删除完后，你会发现父项目中有依赖对应的jar包，子项目虽然已经将重复的依赖删除掉了，但是刷新的时候，子项目中所需要的jar包依然存在。</li><li>当项目的<code>&lt;parent&gt;</code>标签被移除掉，会发现多出来的jar包依赖也会随之消失。</li></ul></li><li><p>在父项目中修改jar包的版本，刷新后，子项目中的jar包版本也随之变化</p><p>那么现在我们就可以解决了刚才提到的第一个问题，将子项目中的公共jar包抽取到父工程中进行统一添加依赖，这样做的可以简化配置，并且当父工程中所依赖的jar包版本发生变化，所有子项目中对应的jar包版本也会跟着更新。</p></li></ol></li></ul><ul><li><p><code>步骤四：</code>优化子项目依赖版本问题</p><p>如果把所有用到的jar包都管理在父项目的pom.xml，看上去更简单些，但是这样就会导致有很多项目引入了过多自己不需要的jar包。如上面看到的这张图:</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310241051435.png"></p><p>如果把所有的依赖都放在了父工程中进行统一维护，就会导致ssm_order项目中多引入了<code>spring-test</code>的jar包，如果这样的jar包过多的话，对于ssm_order来说也是一种”负担”。</p></li></ul><p>那针对于这种部分项目有的jar包，我们该如何管理优化呢?</p><ol><li><p>那针对于这种部分项目有的jar包，我们该如何管理优化呢?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--定义依赖管理--&gt;</span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure></li><li><p>将maven_01_ssm的pom.xml中的junit依赖删除掉，刷新Maven<br>刷新后，在maven_01_ssm项目中找不到junit依赖，所以我们得出一个结论<br><code>&lt;dependencyManagement&gt;</code>标签不真正引入jar包，而是配置可供子项目选择的jar包依赖<br>子项目要想使用它所提供的这些jar包，需要自己添加依赖，并且不需要指定<code>&lt;version&gt;</code></p></li><li><p>在在maven_01_ssm的pom.xml添加junit的依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里就不需要添加版本了，这样做的好处就是当父工程<code>dependencyManagement</code>标签中的版本发生变化后，子项目中的依赖版本也会跟着发生变化</p></blockquote></li><li><p>在maven_03_dao的pom.xml添加junit的依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>这个时候，maven_01_ssm和maven_03_dao这两个项目中的junit版本就会跟随着父项目中的标签<code>dependencyManagement</code>中junit的版本发生变化而变化。不需要junit的项目就不需要添加对应的依赖即可（maven_02_pojo中就没添加）</p><p>至此继承就已经学习完了，总结来说，继承可以帮助做两件事</p><ul><li><p>将所有项目公共的jar包依赖提取到父工程的pom.xml中，子项目就可以不用重复编写，简化开发</p></li><li><p>将所有项目的jar包配置到父工程的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dependencyManagement</span><br></pre></td></tr></table></figure><p>标签下，实现版本管理，方便维护</p><ul><li><code>dependencyManagement</code>标签不真正引入jar包，只是管理jar包的版本</li><li>子项目在引入的时候，只需要指定groupId和artifactId，不需要加version</li><li>当<code>dependencyManagement</code>标签中jar包版本发生变化，所有子项目中有用到该jar包的地方对应的版本会自动随之更新</li></ul></li></ul><p>最后总结一句话就是，<code>父工程主要是用来快速配置依赖jar包和管理项目中所使用的资源</code>。</p></li></ol><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>继承的实现步骤:</p><ul><li><p>创建Maven模块，设置打包类型为pom</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;packaging&gt;pom&lt;/packaging&gt;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>在父工程的pom文件中配置依赖关系(子工程将沿用父工程中的依赖关系),一般只抽取子项目中公有的jar包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></li><li><p>在父工程中配置子工程中可选的依赖关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.16&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>在子工程中配置当前工程所继承的父工程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--定义该工程的父工程--&gt;</span><br><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven_01_parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;!--填写父工程的pom文件,可以不写--&gt;</span><br><span class="line">    &lt;relativePath&gt;../maven_01_parent/pom.xml&lt;/relativePath&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure></li><li><p>在子工程中配置使用父工程中可选依赖的坐标</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></li></ul><p>注意事项:</p><ol><li>子工程中使用父工程中的可选依赖时，<strong>仅需要提供群组id和项目id，无需提供版本</strong>，版本由父工程统一提供，避免版本冲突</li><li>子工程中还可以定义父工程中没有定义的依赖关系，只不过不能被父工程进行版本统一管理。</li></ol><h2 id="聚合与继承的区别"><a href="#聚合与继承的区别" class="headerlink" title="聚合与继承的区别"></a>聚合与继承的区别</h2><p>聚合与继承分别的作用:</p><ul><li>聚合用于快速构建项目，对项目进行管理</li><li>继承用于快速配置和管理子项目中所使用jar包的版本</li></ul><p>聚合和继承的相同点:</p><ul><li>聚合与继承的pom.xml文件打包方式均为pom，可以将两种关系制作到同一个pom文件中</li><li>聚合与继承均属于设计型模块，并无实际的模块内容</li></ul><p>聚合和继承的不同点:</p><ul><li>聚合是在当前模块中配置关系，聚合可以感知到参与聚合的模块有哪些</li><li>继承是在子模块中配置关系，父模块无法感知哪些子模块继承了自己</li></ul><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p>属性中会继续解决分模块开发项目存在的问题，版本管理主要是认识下当前主流的版本定义方式。</p><h2 id="属性引入"><a href="#属性引入" class="headerlink" title="属性引入"></a>属性引入</h2><p>问题分析：</p><p>前面我们已经在父工程中的dependencyManagement标签中对项目中所使用的jar包版本进行了统一的管理，但是如果在标签中有如下的内容:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.5.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>如果我们现在想更新Spring的版本，就会发现我们依然需要更新多个jar包的版本，这样的话还是有可能出现漏改导致程序出问题，而且改起来也是比较麻烦。<br>问题清楚后，我们需要解决的话，就可以参考咱们java基础所学习的变量，声明一个变量，在其他地方使用该变量，当变量的值发生变化后，所有使用变量的地方也会跟着变化<br>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String spring_version = &quot;5.2.10.RELEASE&quot;;</span><br></pre></td></tr></table></figure><p>然后将依赖的版本号替换成<code>spring_version</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;spring_version&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>解决步骤</p><ul><li><p><code>步骤一：</code>父工程中定义属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">        &lt;spring.version&gt;5.2.10.RELEASE&lt;/spring.version&gt;</span><br><span class="line">        &lt;mybatis.version&gt;3.5.6&lt;/mybatis.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>步骤二：</code>修改依赖的version</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>此时，我们只需要更新父工程中properties标签中所维护的jar包版本，所有子项目中的版本也就跟着更新。当然除了将spring相关版本进行维护，我们可以将其他的jar包版本也进行抽取，这样就可以对项目中所有jar包的版本进行统一维护</p></li></ul><p>说明：</p><p>使用<code>properties</code>标签来定义属性，在<code>properties</code>标签内自定义标签名当做属性名，自定义标签内的值即为属性值<br>例如：</p><p><code>&lt;spring.version&gt;5.2.10.RELEASE&lt;/spring.version&gt;</code>，属性名为<code>spring.version</code>，属性值为<code>5.2.10.RELEASE</code>，在其他地方引用变量时用<code>$&#123;变量名&#125;</code></p><h2 id="配置文件加载属性"><a href="#配置文件加载属性" class="headerlink" title="配置文件加载属性"></a>配置文件加载属性</h2><p>Maven中的属性我们已经介绍过了，现在也已经能够通过Maven来集中管理Maven中依赖jar包的版本。但是又有新的需求，就是想让Maven对于属性的管理范围能更大些，比如我们之前项目中的<code>jdbc.properties</code>，这个配置文件中的属性，能不能也来让Maven进行管理呢?</p><p>答案是肯定的，具体的实现步骤如下</p><ul><li><p><code>步骤一：</code>父工程定义属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;spring.version&gt;5.2.10.RELEASE&lt;/spring.version&gt;</span><br><span class="line">    &lt;mybatis.version&gt;3.5.6&lt;/mybatis.version&gt;</span><br><span class="line">    &lt;jdbc.driver&gt;com.mysql.jdbc.Driver&lt;/jdbc.driver&gt;</span><br><span class="line">    &lt;jdbc.url&gt;jdbc:mysql://localhost:13306/ssm_db?useSSL=false&lt;/jdbc.url&gt;</span><br><span class="line">    &lt;jdbc.username&gt;root&lt;/jdbc.username&gt;</span><br><span class="line">    &lt;jdbc.password&gt;PASSWORD&lt;/jdbc.password&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>步骤二：</code>jdbc.properties文件中引用属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driver=$&#123;jdbc.driver&#125;</span><br><span class="line">jdbc.url=$&#123;jdbc.url&#125;</span><br><span class="line">jdbc.username=$&#123;jdbc.username&#125;</span><br><span class="line">jdbc.password=$&#123;jdbc.password&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>步骤三：</code>设置maven过滤文件范围<br>直接在properties中引用属性，看起来怪怪的，properties怎么能直接用到maven中配置的属性呢？<br>所以我们还需要来配置一下，让<code>maven_01_ssm/src/main/resources</code>目录下的<code>jdbc.properties</code>文件可以解析<code>$&#123;&#125;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;resources&gt;</span><br><span class="line">        &lt;!--设置资源目录--&gt;</span><br><span class="line">        &lt;resource&gt;</span><br><span class="line">            &lt;directory&gt;../maven_01_ssm/src/main/resources&lt;/directory&gt;</span><br><span class="line">            &lt;!--设置能够解析$&#123;&#125;，默认是false --&gt;</span><br><span class="line">            &lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">        &lt;/resource&gt;</span><br><span class="line">    &lt;/resources&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>步骤四：</code>测试是否生效<br>测试的时候，只需要将maven_01_ssm项目进行打包，然后在本地仓库观察打包结果中最终生成的内容是否为Maven中配置的内容。</p></li><li><p><code>存在的问题</code><br>如果不只是<code>maven_01_ssm</code>项目需要有属性被父工程管理，如果还有多个项目需要配置，该如何实现呢?</p><ul><li><p><code>方式一</code>：可以一个一个配，但是项目足够多的话，这样还是比较繁琐的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;resources&gt;</span><br><span class="line">        &lt;!--设置资源目录，并设置能够解析$&#123;&#125;--&gt;</span><br><span class="line">        &lt;resource&gt;</span><br><span class="line">            &lt;directory&gt;../maven_01_ssm/src/main/resources&lt;/directory&gt;</span><br><span class="line">            &lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">        &lt;/resource&gt;</span><br><span class="line">        &lt;resource&gt;</span><br><span class="line">            &lt;directory&gt;../maven_02_pojo/src/main/resources&lt;/directory&gt;</span><br><span class="line">            &lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">        &lt;/resource&gt;</span><br><span class="line">        ...</span><br><span class="line">    &lt;/resources&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>方式二：</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;resources&gt;</span><br><span class="line">        &lt;!--</span><br><span class="line">            $&#123;project.basedir&#125;: 当前项目所在目录,子项目继承了父项目，</span><br><span class="line">            相当于所有的子项目都添加了资源目录的过滤</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;resource&gt;</span><br><span class="line">            &lt;directory&gt;$&#123;project.basedir&#125;/src/main/resources&lt;/directory&gt;</span><br><span class="line">            &lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">        &lt;/resource&gt;</span><br><span class="line">    &lt;/resources&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>说明：如果打包过程中出现错误<code>Error assembling WAR: webxml attribute is required</code><br>原因就是Maven发现你的项目为web项目，就会去找web项目的入口web.xml(配置文件配置的方式)，发现没有找到，就会报错。</p><ul><li><p><code>解决方案1：</code>在maven_02_ssm项目的<code>src\main\webapp\WEB-INF\</code>添加一个web.xml文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;</span><br><span class="line">         version=&quot;3.1&quot;&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>解决方案2:</code> 配置maven打包war时，忽略web.xml检查</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.2.3&lt;/version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure></li></ul><p>上面我们所使用的都是Maven的自定义属性，除了<code>$&#123;project.basedir&#125;</code>,它属于Maven的内置系统属性。</p><p>在Maven中的属性分为:</p><ul><li>自定义属性（常用）</li><li>内置属性</li><li>Setting属性</li><li>Java系统属性</li><li>环境变量属性</li></ul><table><thead><tr><th align="center">属性分类</th><th align="center">引用格式</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">自定义属性</td><td align="center">${自定义属性名}</td><td align="center">${spring.vension}</td></tr><tr><td align="center">内置属性</td><td align="center">${内置属性名}</td><td align="center">${basedir}、${version}</td></tr><tr><td align="center">setting属性</td><td align="center">${setting.属性名}</td><td align="center">${settings.localRepository}</td></tr><tr><td align="center">ava系统属性</td><td align="center">${系统属性分类.系统属性名}</td><td align="center">${user.home}</td></tr><tr><td align="center">环境变量属性</td><td align="center">${env.环境变量属性名}</td><td align="center">${env.JAVA_HOME}</td></tr></tbody></table><h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><p>关于这个版本管理解决的问题是，在Maven创建项目和引用别人项目的时候，我们都看到过如下内容:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;maven_00_parent&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br></pre></td></tr></table></figure><p>这里面有两个单词，SNAPSHOT和RELEASE，它们所代表的含义是什么呢?</p><ul><li>SNAPSHOT（快照版本）<ul><li>项目开发过程中临时输出的版本，称为快照版本</li><li>快照版本会随着开发的进展不断更新</li></ul></li><li>RELEASE（发布版本）<ul><li>项目开发到一定阶段里程碑后，向团队外部发布较为稳定的版本，这种版本所对应的构件文件是稳定的</li><li>即便进行功能的后续开发，也不会改变当前发布版本内容，这种版本称为发布版本</li></ul></li></ul><p>除了上面的工程版本，我们还经常能看到一些发布版本：</p><ul><li>alpha版：内测版，bug多不稳定内部版本不断添加新功能</li><li>beta版：公测版，不稳定(比alpha稳定些)，bug相对较多不断添加新功能，相信你更新QQ的时候，一定见过QQ的beta测试版</li><li>纯数字版</li></ul><h1 id="多环境配置与应用"><a href="#多环境配置与应用" class="headerlink" title="多环境配置与应用"></a>多环境配置与应用</h1><h2 id="多环境开发"><a href="#多环境开发" class="headerlink" title="多环境开发"></a>多环境开发</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310241117970.png"></p><p>我们平常都是在自己的开发环境进行开发</p><p>当开发完成后，需要把开发的功能部署到测试环境供测试人员进行测试使用</p><p>等测试人员测试通过后，我们会将项目部署到生成环境上线使用。</p><p>这个时候就有一个问题是，不同环境的配置是不相同的，如不可能让三个环境都用一个数据库，所以就会有三个数据库的url配置，</p><p>我们在项目中如何配置?</p><p>要想实现不同环境之间的配置切换又该如何来实现呢?</p><p>maven提供配置多种环境的设定，帮助开发者在使用过程中快速切换环境。具体实现步骤如下</p><ul><li><p><code>步骤一：</code>父工程配置多个环境，并指定默认激活环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;profiles&gt;</span><br><span class="line">    &lt;!--开发环境--&gt;</span><br><span class="line">    &lt;profile&gt;</span><br><span class="line">        &lt;id&gt;env_dep&lt;/id&gt;</span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">            &lt;jdbc.url&gt;jdbc:mysql://127.1.1.1:3306/ssm_db&lt;/jdbc.url&gt;</span><br><span class="line">        &lt;/properties&gt;</span><br><span class="line">        &lt;!--设定是否为默认环境--&gt;</span><br><span class="line">        &lt;activation&gt;</span><br><span class="line">            &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;</span><br><span class="line">        &lt;/activation&gt;</span><br><span class="line">    &lt;/profile&gt;</span><br><span class="line">    &lt;!--生产环境--&gt;</span><br><span class="line">    &lt;profile&gt;</span><br><span class="line">        &lt;id&gt;env_pro&lt;/id&gt;</span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">            &lt;jdbc.url&gt;jdbc:mysql://127.2.2.2:3306/ssm_db&lt;/jdbc.url&gt;</span><br><span class="line">        &lt;/properties&gt;</span><br><span class="line">    &lt;/profile&gt;</span><br><span class="line">    &lt;!--测试环境--&gt;</span><br><span class="line">    &lt;profile&gt;</span><br><span class="line">        &lt;id&gt;env_test&lt;/id&gt;</span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">            &lt;jdbc.url&gt;jdbc:mysql://127.3.3.3:3306/ssm_db&lt;/jdbc.url&gt;</span><br><span class="line">        &lt;/properties&gt;</span><br><span class="line">    &lt;/profile&gt;</span><br><span class="line">&lt;/profiles&gt;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>步骤二：</code>执行install查看env_dep环境是否生效<br>在你本地仓库找到打包的war包，看看jdbc.properties配置文件中的url是否为<code>jdbc:mysql://127.1.1.1:3306/ssm_db</code></p></li><li><p><code>步骤三：</code>切换默认环境为生产环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;profiles&gt;</span><br><span class="line">    &lt;!--开发环境--&gt;</span><br><span class="line">    &lt;profile&gt;</span><br><span class="line">        &lt;id&gt;env_dep&lt;/id&gt;</span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">            &lt;jdbc.url&gt;jdbc:mysql://127.1.1.1:3306/ssm_db&lt;/jdbc.url&gt;</span><br><span class="line">        &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/profile&gt;</span><br><span class="line">    &lt;!--生产环境--&gt;</span><br><span class="line">    &lt;profile&gt;</span><br><span class="line">        &lt;id&gt;env_pro&lt;/id&gt;</span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">            &lt;jdbc.url&gt;jdbc:mysql://127.2.2.2:3306/ssm_db&lt;/jdbc.url&gt;</span><br><span class="line">        &lt;/properties&gt;</span><br><span class="line">        &lt;!--设定是否为默认环境--&gt;</span><br><span class="line">        &lt;activation&gt;</span><br><span class="line">            &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;</span><br><span class="line">        &lt;/activation&gt;</span><br><span class="line">    &lt;/profile&gt;</span><br><span class="line">    &lt;!--测试环境--&gt;</span><br><span class="line">    &lt;profile&gt;</span><br><span class="line">        &lt;id&gt;env_test&lt;/id&gt;</span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">            &lt;jdbc.url&gt;jdbc:mysql://127.3.3.3:3306/ssm_db&lt;/jdbc.url&gt;</span><br><span class="line">        &lt;/properties&gt;</span><br><span class="line">    &lt;/profile&gt;</span><br><span class="line">&lt;/profiles&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>步骤四：</code>执行install并查看env_pro环境是否生效<br>查看到的结果为<code>jdbc:mysql://127.2.2.2:3306/ssm_db</code><br>虽然已经能够实现不同环境的切换，但是每次切换都是需要手动修改，如何来实现在不改变代码的前提下完成环境的切换呢?</p></li><li><p><code>步骤无：</code>命令行实现环境切换<br>在命令后加上环境id<code>mvn install -P env_test</code></p></li><li><p><code>步骤六：</code>执行安装并查看env_test环境是否生效<br>查看到的结果为<code>jdbc:mysql://127.3.3.3:3306/ssm_db</code></p></li></ul><p>所以总结来说，对于多环境切换只需要两步即可:</p><ul><li><p>父工程中定义多环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;profiles&gt;</span><br><span class="line">&lt;profile&gt;</span><br><span class="line">    &lt;id&gt;环境名称&lt;/id&gt;</span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">        &lt;key&gt;value&lt;/key&gt;</span><br><span class="line">        &lt;/properties&gt;</span><br><span class="line">        &lt;activation&gt;</span><br><span class="line">        &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;</span><br><span class="line">        &lt;/activation&gt;</span><br><span class="line">    &lt;/profile&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/profiles&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用多环境(构建过程)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn 指令 -P 环境定义ID</span><br></pre></td></tr></table></figure></li></ul><h2 id="跳过测试"><a href="#跳过测试" class="headerlink" title="跳过测试"></a>跳过测试</h2><p>前面在执行<code>install</code>指令的时候，Maven都会按照顺序从上往下依次执行，每次都会执行<code>test</code>,</p><p>对于<code>test</code>来说有它存在的意义，</p><ul><li>可以确保每次打包或者安装的时候，程序的正确性，假如测试已经通过在我们没有修改程序的前提下再次执行打包或安装命令，由于顺序执行，测试会被再次执行，就有点耗费时间了。</li><li>功能开发过程中有部分模块还没有开发完毕，测试无法通过，但是想要把其中某一部分进行快速打包，此时由于测试环境失败就会导致打包失败。</li></ul><p>遇到上面这些情况的时候，我们就想跳过测试执行下面的构建命令，具体实现方式有很多：</p><ul><li><p><code>方式一：</code>IDEA工具实现跳过测试<br>IDEA的maven面板上有一个按钮，点击之后可以跳过测试，不过此种方式会跳过所有的测试，如果我们想更精细的控制哪些跳过，哪些不跳过，那么就需要使用配置插件的方式来完成了</p></li><li><p><code>方式二：</code>配置插件实现跳过测试<br>在父工程中的pom.xml中添加测试插件配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.12.4&lt;/version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;skipTests&gt;false&lt;/skipTests&gt;</span><br><span class="line">                &lt;!--排除掉不参与测试的内容--&gt;</span><br><span class="line">                &lt;excludes&gt;</span><br><span class="line">                    &lt;exclude&gt;**/BookServiceTest.java&lt;/exclude&gt;</span><br><span class="line">                &lt;/excludes&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p><code>skipTests：</code>如果为true，则跳过所有测试，如果为false，则不跳过测试<br><code>excludes：</code>哪些测试类不参与测试，即排除，针对skipTests为false来设置的<br><code>includes：</code>哪些测试类要参与测试，即包含,针对skipTests为true来设置的</p></li><li><p><code>方式三：</code>命令行跳过测试<br>使用Maven的命令行，<code>mvn 指令 -D skipTests</code></p></li></ul><p>注意事项:</p><ul><li>执行的项目构建指令必须包含测试生命周期，否则无效果。例如执行compile生命周期，不经过test生命周期。</li><li>该命令可以不借助IDEA，直接使用cmd命令行进行跳过测试，需要注意的是cmd要在pom.xml所在目录下进行执行。</li></ul><h1 id="私服"><a href="#私服" class="headerlink" title="私服"></a>私服</h1><h2 id="私服简介"><a href="#私服简介" class="headerlink" title="私服简介"></a>私服简介</h2><p>团队开发现状分析</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310241126067.png"></p><ol><li>张三负责ssm_crm的开发，自己写了一个ssm_pojo模块，要想使用直接将ssm_pojo安装到本地仓库即可</li><li>李四负责ssm_order的开发，需要用到张三所写的ssm_pojo模块，这个时候如何将张三写的ssm_pojo模块交给李四呢?</li><li>如果直接拷贝，那么团队之间的jar包管理会非常混乱而且容器出错，这个时候我们就想能不能将写好的项目上传到中央仓库，谁想用就直接联网下载即可</li><li>Maven的中央仓库不允许私人上传自己的jar包,那么我们就得换种思路，自己搭建一个类似于中央仓库的东西，把自己的内容上传上去，其他人就可以从上面下载jar包使用</li><li>这个类似于中央仓库的东西就是我们接下来要学习的私服</li></ol><p>所以到这就有两个概念，一个是私服，一个是中央仓库</p><ul><li><code>私服:</code>公司内部搭建的用于存储Maven资源的服务器</li><li><code>远程仓库:</code>Maven开发团队维护的用于存储Maven资源的服务器</li></ul><p>结论：私服是一台独立的服务器，用于解决团队内部的资源共享与资源同步问题</p><h2 id="私服仓库分类"><a href="#私服仓库分类" class="headerlink" title="私服仓库分类"></a>私服仓库分类</h2><p>私服资源操作流程分析：</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310241127829.png"></p><ol><li>在没有私服的情况下，我们自己创建的服务都是安装在Maven的本地仓库中</li><li>私服中也有仓库，我们要把自己的资源上传到私服，最终也是放在私服的仓库中</li><li>其他人要想使用你所上传的资源，就需要从私服的仓库中获取</li><li>当我们要使用的资源不是自己写的，是远程中央仓库有的第三方jar包，这个时候就需要从远程中央仓库下载，每个开发者都去远程中央仓库下速度比较慢(中央仓库服务器在国外)</li><li>私服就再准备一个仓库，用来专门存储从远程中央仓库下载的第三方jar包，第一次访问没有就会去远程中央仓库下载，下次再访问就直接走私服下载</li><li>前面在介绍版本管理的时候提到过有<code>SNAPSHOT</code>和<code>RELEASE</code>，如果把这两类的都放到同一个仓库，比较混乱，所以私服就把这两个种jar包放入不同的仓库</li><li>上面我们已经介绍了有三种仓库，一种是存放<code>SNAPSHOT</code>的，一种是存放<code>RELEASE</code>还有一种是存放从远程仓库下载的第三方jar包，那么我们在获取资源的时候要从哪个仓库种获取呢?</li><li>为了方便获取，我们将所有的仓库编成一个组，我们只需要访问仓库组去获取资源。</li></ol><p>所有私服仓库总共分为三大类:</p><ol><li>宿主仓库hosted<ul><li>保存无法从中央仓库获取的资源</li><li>自主研发</li><li>第三方非开源项目,比如Oracle,因为是付费产品，所以中央仓库没有</li></ul></li><li>代理仓库proxy<ul><li>代理远程仓库，通过nexus访问其他公共仓库，例如中央仓库</li></ul></li><li>仓库组group<ul><li>将若干个仓库组成一个群组，简化配置</li><li>仓库组不能保存资源，属于设计型仓库</li></ul></li></ol><table><thead><tr><th align="center">仓库类别</th><th align="center">英文名称</th><th align="center">功能</th><th align="center">关联操作</th></tr></thead><tbody><tr><td align="center">宿主仓库</td><td align="center">hosted</td><td align="center">保存自主研发+第三方资源</td><td align="center">上传</td></tr><tr><td align="center">代理仓库</td><td align="center">proxy</td><td align="center">代理连接中央仓库</td><td align="center">下载</td></tr><tr><td align="center">仓库组</td><td align="center">group</td><td align="center">为仓库编组简化下载操作</td><td align="center">下载</td></tr></tbody></table><h2 id="本地仓库访问私服配置"><a href="#本地仓库访问私服配置" class="headerlink" title="本地仓库访问私服配置"></a>本地仓库访问私服配置</h2><ul><li>我们通过IDEA将开发的模块上传到私服，中间是要经过本地Maven的</li><li>本地Maven需要知道私服的访问地址以及私服访问的用户名和密码</li><li>私服中的仓库很多，Maven最终要把资源上传到哪个仓库?</li><li>Maven下载的时候，又需要携带用户名和密码到私服上找对应的仓库组进行下载，然后再给IDEA</li><li>上面所说的这些内容，我们需要在本地Maven的配置文件<code>settings.xml</code>中进行配置。</li></ul><p>实现：</p><ul><li><p><code>步骤一：</code>私服上配置仓库<br>新建两个仓库，type选hosted，version policy 一个选release，一个选snapshot</p></li><li><p><code>步骤二：</code>配置本地Maven对私服的访问权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;server&gt;</span><br><span class="line">    &lt;!--id就是刚刚创建的仓库名--&gt;</span><br><span class="line">    &lt;id&gt;blog-snapshot&lt;/id&gt;</span><br><span class="line">    &lt;username&gt;admin&lt;/username&gt;</span><br><span class="line">    &lt;password&gt;7d1f6527-cf26-4be3-974a-de177d75cb87&lt;/password&gt;</span><br><span class="line">&lt;/server&gt;</span><br><span class="line">&lt;server&gt;</span><br><span class="line">    &lt;id&gt;blog-release&lt;/id&gt;</span><br><span class="line">    &lt;username&gt;admin&lt;/username&gt;</span><br><span class="line">    &lt;password&gt;7d1f6527-cf26-4be3-974a-de177d75cb87&lt;/password&gt;</span><br><span class="line">&lt;/server&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>步骤三：</code>配置私服的访问路径</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;mirror&gt;</span><br><span class="line">    &lt;!--配置仓库组的ID--&gt;</span><br><span class="line">    &lt;id&gt;maven-public&lt;/id&gt;</span><br><span class="line">    &lt;!--*代表所有内容都从私服获取--&gt;</span><br><span class="line">    &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;</span><br><span class="line">    &lt;!--私服仓库组maven-public的访问路径--&gt;</span><br><span class="line">    &lt;url&gt;http://localhost:8081/repository/maven-public/&lt;/url&gt;</span><br><span class="line">&lt;/mirror&gt;</span><br></pre></td></tr></table></figure><p>最后记得将新创建的两个仓库加入到maven-public的成员中，至此本地仓库就能与私服进行交互了</p><h2 id="私服资源的下载和上传"><a href="#私服资源的下载和上传" class="headerlink" title="私服资源的下载和上传"></a>私服资源的下载和上传</h2><p>本地仓库与私服已经建立了连接，接下来我们就需要往私服上上传资源和下载资源，具体的实现步骤如下</p><ul><li><p><code>步骤一：</code>配置工程上传私服的具体位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;distributionManagement&gt;</span><br><span class="line">    &lt;repository&gt;</span><br><span class="line">        &lt;id&gt;blog-release&lt;/id&gt;</span><br><span class="line">        &lt;url&gt;http://localhost:8081/repository/blog-release/&lt;/url&gt;</span><br><span class="line">    &lt;/repository&gt;</span><br><span class="line">    &lt;snapshotRepository&gt;</span><br><span class="line">        &lt;id&gt;blog-snapshot&lt;/id&gt;</span><br><span class="line">        &lt;url&gt;http://localhost:8081/repository/blog-snapshot/&lt;/url&gt;</span><br><span class="line">    &lt;/snapshotRepository&gt;</span><br><span class="line">&lt;/distributionManagement&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>步骤二：</code>发布资源到私服<br>maven面板中运行<code>deploy</code>，或者执行maven命令<code>mvn deploy</code></p><p>发布成功，在私服中就能看到了</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310241138794.png"></p><p>现在发布是在blog-snapshot仓库中，如果想发布到blog-release仓库中就需要将项目pom.xml中的version修改成RELEASE即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;maven_00_parent&lt;/artifactId&gt;</span><br><span class="line">&lt;!--&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;--&gt;</span><br><span class="line">&lt;version&gt;1.0-RELEASE&lt;/version&gt;</span><br></pre></td></tr></table></figure><p>如果私服中没有对应的jar，会去中央仓库下载，速度很慢。可以配置让私服去阿里云中下载依赖。<br>修改maven-central的Remote storage为<code>http://maven.aliyun.com/nexus/content/groups/public</code></p><p>至此私服的搭建就已经完成，相对来说有点麻烦，但是步骤都比较固定，后期忘了就常回来看</p><p>注意:</p><ul><li>要发布的项目都需要配置<code>distributionManagement</code>标签，要么在自己的pom.xml中配置，要么在其父项目中配置，然后子项目中继承父项目即可。</li><li>如果报401错误，尝试将maven的setting.xml文件复制到<code>C:\Users\username\.m2</code>目录下，然后在重新进行deploy</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JDBC</title>
      <link href="/2023/10/25/JDBC/"/>
      <url>/2023/10/25/JDBC/</url>
      
        <content type="html"><![CDATA[<h1 id="JDBC概述"><a href="#JDBC概述" class="headerlink" title="JDBC概述"></a>JDBC概述</h1><h2 id="数据的持久化"><a href="#数据的持久化" class="headerlink" title="数据的持久化"></a>数据的持久化</h2><ul><li>持久化(persistence)：把数据保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企业级应用，数据持久化意味着将内存中的数据保存到硬盘上加以”固化”，而持久化的实现过程大多通过各种关系数据库来完成。</li><li>持久化的主要应用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。</li></ul><h2 id="Java中的数据存储技术"><a href="#Java中的数据存储技术" class="headerlink" title="Java中的数据存储技术"></a>Java中的数据存储技术</h2><ul><li>在Java中，数据库存取技术可分为如下几类：<ul><li>JDBC直接访问数据库</li><li>JDO (Java Data Object )技术</li><li>第三方O&#x2F;R工具，如Hibernate, Mybatis 等</li></ul></li><li>JDBC是java访问数据库的基石，JDO、Hibernate、MyBatis等只是更好的封装了JDBC。</li></ul><h2 id="JDBC介绍"><a href="#JDBC介绍" class="headerlink" title="JDBC介绍"></a>JDBC介绍</h2><ul><li>JDBC(Java Database Connectivity)是一个独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口（一组API），定义了用来访问数据库的标准Java类库，（java.sql,javax.sql）使用这些类库可以以一种标准的方法、方便地访问数据库资源。</li><li>JDBC为访问不同的数据库提供了一种统一的途径，为开发者屏蔽了一些细节问题。</li><li>JDBC的目标是使Java程序员使用JDBC可以连接任何提供了JDBC驱动程序的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。</li><li>如果没有JDBC，那么Java程序访问数据库时是这样的：<br><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310092034056.png"></li><li>有了JDBC，Java程序访问数据库时是这样的：<br><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310092034585.png"></li><li>总结如下：<br><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310092034573.png"></li></ul><h2 id="JDBC体系结构"><a href="#JDBC体系结构" class="headerlink" title="JDBC体系结构"></a>JDBC体系结构</h2><p>JDBC接口（API）包括两个层次：</p><ul><li>面向应用的API：Java API，抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果）。</li><li>面向数据库的API：Java Driver API，供开发商开发数据库驱动程序用。</li></ul><blockquote><p>JDBC是sun公司提供一套用于数据库操作的接口，java程序员只需要面向这套接口编程即可。不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。——面向接口编程</p></blockquote><h2 id="JDBC程序编写步骤"><a href="#JDBC程序编写步骤" class="headerlink" title="JDBC程序编写步骤"></a>JDBC程序编写步骤</h2><blockquote><p>补充：ODBC(Open Database Connectivity，开放式数据库连接)，是微软在Windows平台下推出的。使用者在程序中只需要调用ODBC API，由 ODBC 驱动程序将调用转换成为对特定的数据库的调用请求。</p></blockquote><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310161000701.png"></p><h1 id="获取数据库连接"><a href="#获取数据库连接" class="headerlink" title="获取数据库连接"></a>获取数据库连接</h1><h2 id="要素一：Driver接口实现类"><a href="#要素一：Driver接口实现类" class="headerlink" title="要素一：Driver接口实现类"></a>要素一：Driver接口实现类</h2><h3 id="Driver接口介绍"><a href="#Driver接口介绍" class="headerlink" title="Driver接口介绍"></a>Driver接口介绍</h3><p>java.sql.Driver 接口是所有 JDBC 驱动程序需要实现的接口。这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现。</p><p>在程序中不需要直接去访问实现了 Driver 接口的类，而是由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver实现。</p><ul><li>Oracle的驱动：oracle.jdbc.driver.OracleDriver</li><li>mySql的驱动： com.mysql.jdbc.Driver</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310161003540.png"></p><p>connection：用于获取连接的方法</p><h3 id="加载与注册JDBC驱动"><a href="#加载与注册JDBC驱动" class="headerlink" title="加载与注册JDBC驱动"></a>加载与注册JDBC驱动</h3><ul><li><p>加载驱动：加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名 Class.forName(“com.mysql.jdbc.Driver”);</p></li><li><p>注册驱动：DriverManager 类是驱动程序管理器类，负责管理驱动程序</p></li><li><p>使用DriverManager.registerDriver(com.mysql.jdbc.Driver)来注册驱动</p></li><li><p>通常不用显式调用 DriverManager 类的 registerDriver() 方法来注册驱动程序类的实例，因为 Driver 接口的驱动程序类都包含了静态代码块，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注册自身的一个实例。下面是MySQL的Driver实现类的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.mysql.jdbc;</span><br><span class="line"></span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line"></span><br><span class="line">public class Driver extends NonRegisteringDriver implements java.sql.Driver &#123;</span><br><span class="line">    public Driver() throws SQLException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            DriverManager.registerDriver(new Driver());</span><br><span class="line">        &#125; catch (SQLException var1) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Can&#x27;t register driver!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="要素二：URL"><a href="#要素二：URL" class="headerlink" title="要素二：URL"></a>要素二：URL</h2><p>JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。</p><p>JDBC URL的标准由三部分组成，各部分间用冒号分隔。</p><ul><li>jdbc：子协议:子名称</li><li>协议：JDBC URL中的协议总是jdbc</li><li>子协议：子协议用于标识一个数据库驱动程序</li><li>子名称：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了定位数据库提供足够的信息。包含主机名(对应服务端的ip地址)，端口号，数据库名</li></ul><p>举例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jdbc:mysql://localhost:3306/dbtest</span><br><span class="line"></span><br><span class="line">其中</span><br><span class="line">jdbc --&gt; 协议</span><br><span class="line">mysql --&gt; 子协议</span><br><span class="line">localhost:3306/dbtest --&gt; 子名称</span><br><span class="line">    localhost --&gt; 主机名</span><br><span class="line">    3306 --&gt; 端口号(MySQL默认端口号为3306)</span><br><span class="line">    dbtest --&gt; 数据库名</span><br></pre></td></tr></table></figure><p>几种常用数据库的 JDBC URL</p><ul><li><p>MySQL的连接URL编写方式：</p><ul><li><p>jdbc:mysql:&#x2F;&#x2F;主机名称:mysql服务端口号&#x2F;数据库名称?参数&#x3D;值&amp;参数&#x3D;值</p></li><li><p>jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test</p></li><li><p>jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8</p><blockquote><p>如果JDBC程序与服务器端的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集</p></blockquote></li><li><p>jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test?user&#x3D;root&amp;password&#x3D;123456</p></li></ul></li><li><p>Oracle 9i的连接URL编写方式：</p><ul><li>jdbc:oracle:thin:@主机名称:oracle服务端口号:数据库名称</li><li>jdbc:oracle:thin:@localhost:1521:test</li></ul></li><li><p>SQLServer的连接URL编写方式：</p><ul><li>jdbc:sqlserver:&#x2F;&#x2F;主机名称:sqlserver服务端口号:DatabaseName&#x3D;数据库名称</li><li>jdbc:sqlserver:&#x2F;&#x2F;localhost:1433:DatabaseName&#x3D;test</li></ul></li></ul><h2 id="要素三：用户名和密码"><a href="#要素三：用户名和密码" class="headerlink" title="要素三：用户名和密码"></a>要素三：用户名和密码</h2><p>user,password可以用“属性名&#x3D;属性值”（键值对）方式告诉数据库</p><p>可以调用 DriverManager 类的 getConnection() 方法建立到数据库的连接</p><h2 id="数据库连接方式举例（5个，迭代关系）"><a href="#数据库连接方式举例（5个，迭代关系）" class="headerlink" title="数据库连接方式举例（5个，迭代关系）"></a>数据库连接方式举例（5个，迭代关系）</h2><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">方式一</button></li><li class="tab"><button type="button" data-href="#test1-2">方法</button></li><li class="tab"><button type="button" data-href="#test1-3">方法</button></li><li class="tab"><button type="button" data-href="#test1-4">方法</button></li><li class="tab"><button type="button" data-href="#test1-5">方法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class ConnectionTest &#123;</span><br><span class="line"></span><br><span class="line">    //方式一 ：</span><br><span class="line">    @Test</span><br><span class="line">    public void testConnection1()  throws SQLException &#123;</span><br><span class="line"></span><br><span class="line">        Driver driver = new com.mysql.jdbc.Driver();</span><br><span class="line"></span><br><span class="line">        //jdbc:mysql:协议</span><br><span class="line">        //localhost：ip地址</span><br><span class="line">        //3306：默认mysql的端口号</span><br><span class="line">        //test：数据库名</span><br><span class="line">        String url = &quot;jdbc:mysql://localhost:3306/test&quot;;</span><br><span class="line">        //将用户名和密码封装在Properties中</span><br><span class="line">        Properties info = new Properties();</span><br><span class="line">        info.setProperty(&quot;user&quot;, &quot;root&quot;);</span><br><span class="line">        info.setProperty(&quot;password&quot;,&quot;111111&quot;);</span><br><span class="line">        Connection conn = driver.connect(url,info);</span><br><span class="line"></span><br><span class="line">    System.out.println(conn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>说明：上述代码中显式出现了第三方数据库的API，就是 new com.mysql.jdbc.Driver(); 这里</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p>方式二：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//方式二: 对方式一的迭代：不出现第三方API ，使程序有更好的可移植性</span><br><span class="line">    @Test</span><br><span class="line">    public void testConnection2() throws Exception &#123;</span><br><span class="line">        //1 获取Driver实现类对象，反射实现</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">        Driver driver = (Driver) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">        //2 提供要连接的数据库</span><br><span class="line">        String url = &quot;jdbc:mysql://localhost:3306/test&quot;;</span><br><span class="line">        //3 用户名密码</span><br><span class="line">        Properties info = new Properties();</span><br><span class="line">        info.setProperty(&quot;user&quot;, &quot;root&quot;);</span><br><span class="line">        info.setProperty(&quot;password&quot;,&quot;abc123&quot;);</span><br><span class="line">        //4 获取连接</span><br><span class="line">        Connection conn = driver.connect(url,info);</span><br><span class="line"></span><br><span class="line">        System.out.println(conn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>说明：相较于方式一，这里使用反射实例化Driver，不在代码中体现第三方数据库的API。体现了面向接口编程思想。</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p>方式三：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//方式三：DriverManager替换Driver</span><br><span class="line">    @Test</span><br><span class="line">    public void testConnection3() throws Exception &#123;</span><br><span class="line">        //1 获取Driver实现类对象</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">        Driver driver = (Driver) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">        //2 获取连接基本信息</span><br><span class="line">        String url = &quot;jdbc:mysql://localhost:3306/test&quot;;</span><br><span class="line">        String user = &quot;root&quot;;</span><br><span class="line">        String password = &quot;abc123&quot;;</span><br><span class="line">        //注册驱动</span><br><span class="line">        DriverManager.registerDriver(driver);</span><br><span class="line"></span><br><span class="line">        //获取连接</span><br><span class="line">        Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">        System.out.println(connection);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>说明：使用DriverManager实现数据库的连接。体会获取连接必要的4个基本要素。</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><p>方式四：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//方式四：省略了实例化和注册驱动，源码有静态代码自动注册</span><br><span class="line">    @Test</span><br><span class="line">    public void testConnection4() throws Exception &#123;</span><br><span class="line">        //1 获取连接基本信息</span><br><span class="line">        String url = &quot;jdbc:mysql://localhost:3306/test&quot;;</span><br><span class="line">        String user = &quot;root&quot;;</span><br><span class="line">        String password = &quot;abc123&quot;;</span><br><span class="line"></span><br><span class="line">        //2 加载Driver</span><br><span class="line">        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line"></span><br><span class="line">        //3 获取连接</span><br><span class="line">        Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">        System.out.println(connection);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>说明：不必显式的注册驱动了。因为在DriverManager的源码中已经存在静态代码块，实现了驱动的注册。</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-5"><p>方式五：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//方式五：将数据库连接需要的基本信息声明在配置文件中，通过读取配置文件方式获得连接</span><br><span class="line">    @Test</span><br><span class="line">    public void testConnection5() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        //1 获取连接基本信息</span><br><span class="line">        InputStream is = ConnectionTest.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;);</span><br><span class="line"></span><br><span class="line">        Properties properties = new Properties();</span><br><span class="line">        properties.load(is);</span><br><span class="line"></span><br><span class="line">        String user = properties.getProperty(&quot;user&quot;);</span><br><span class="line">        String password = properties.getProperty(&quot;password&quot;);</span><br><span class="line">        String url = properties.getProperty(&quot;url&quot;);</span><br><span class="line">        String driverClass = properties.getProperty(&quot;driverClass&quot;);</span><br><span class="line"></span><br><span class="line">        //2 加载驱动</span><br><span class="line">        Class.forName(driverClass);</span><br><span class="line"></span><br><span class="line">        //3 获取连接</span><br><span class="line">        Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">1.实现数据和代码的分离、解耦</span><br><span class="line">2.如果需要修改配置信息，可以避免程序重新打包</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>其中，配置文件声明在工程的src目录下：jdbc.properties</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PROPERTIES</span><br><span class="line">user=root</span><br><span class="line">password=yourpassword</span><br><span class="line">url=jdbc:mysql://localhost:3306/test</span><br><span class="line">driverClass=com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure><blockquote><p>说明：使用配置文件的方式保存配置信息，在代码中加载配置文件</p></blockquote><p>使用配置文件的好处：</p><ul><li>实现了代码和数据的分离，如果需要修改配置信息，直接在配置文件中修改，不需要深入代码</li><li>如果修改了配置信息，省去重新编译的过程。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="使用PreparedStatement实现CRUD操作"><a href="#使用PreparedStatement实现CRUD操作" class="headerlink" title="使用PreparedStatement实现CRUD操作"></a>使用PreparedStatement实现CRUD操作</h1><h2 id="操作和访问数据库"><a href="#操作和访问数据库" class="headerlink" title="操作和访问数据库"></a>操作和访问数据库</h2><p>数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。其实一个数据库连接就是一个Socket连接。</p><p>在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式：</p><ul><li><p><code>Statement</code>：用于执行静态 SQL 语句并返回它所生成结果的对象。</p></li><li><p><code>PrepatedStatement</code>：SQL 语句被<strong>预编译</strong>并存储在此对象中，可以使用此对象多次高效地执行该语句。</p><blockquote><p>PrepatedStatement 是 Statement 的子接口（实现优化功能）</p></blockquote></li><li><p><code>CallableStatement</code>：用于执行 SQL 存储过程</p></li></ul><h2 id="使用Statement操作数据表的弊端"><a href="#使用Statement操作数据表的弊端" class="headerlink" title="使用Statement操作数据表的弊端"></a>使用Statement操作数据表的弊端</h2><p>通过调用 <code>Connection</code> 对象的 <code>createStatement()</code> 方法创建该对象。该对象用于执行静态的 SQL 语句，并且返回执行结果。</p><p>Statement 接口中定义了下列方法用于执行 SQL 语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int excuteUpdate(String sql) //执行更新操作INSERT、UPDATE、DELETE</span><br><span class="line">ResultSet executeQuery(String sql) //执行查询操作SELECT</span><br></pre></td></tr></table></figure><p>但是使用Statement操作数据表存在弊端：</p><ul><li>问题一：存在拼串操作，繁琐</li><li>问题二：存在SQL注入问题</li></ul><p>SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令，从而利用系统的 SQL 引擎完成恶意行为的做法。</p><p>对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement(从Statement扩展而来) 取代 Statement 就可以了。</p><h2 id="PreparedStatement的使用"><a href="#PreparedStatement的使用" class="headerlink" title="PreparedStatement的使用"></a>PreparedStatement的使用</h2><h3 id="PreparedStatement介绍"><a href="#PreparedStatement介绍" class="headerlink" title="PreparedStatement介绍"></a>PreparedStatement介绍</h3><ul><li>可以通过调用 <code>Connection</code> 对象的 <code>preparedStatement(String sql)</code> 方法获取 <code>PreparedStatement</code> 对象</li><li><code>PreparedStatement</code> 接口是 <code>Statement</code> 的子接口，它表示一条预编译过的 SQL 语句</li><li><code>PreparedStatement</code> 对象所代表的 SQL 语句中的参数用问号(<code>?</code>)来表示，调用 <code>PreparedStatement</code> 对象的<code>setXxx()</code> 方法来设置这些参数. <code>setXxx()</code> 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从1开始)，第二个是设置的 SQL 语句中的参数的值</li></ul><h3 id="PreparedStatement-vs-Statement"><a href="#PreparedStatement-vs-Statement" class="headerlink" title="PreparedStatement vs Statement"></a>PreparedStatement vs Statement</h3><ul><li>代码的可读性和可维护性</li><li>PreparedStatement 能最大可能提高性能：<ul><li>DBServer会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。</li><li>在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样每执行一次都要对传入的语句编译一次。</li></ul></li><li>PreparedStatement 可以防止 SQL 注入</li></ul><h3 id="Java与SQL对应数据类型转换表"><a href="#Java与SQL对应数据类型转换表" class="headerlink" title="Java与SQL对应数据类型转换表"></a>Java与SQL对应数据类型转换表</h3><table><thead><tr><th align="center">Java类型</th><th align="center">SQL类型</th></tr></thead><tbody><tr><td align="center">BOOLEAN</td><td align="center">BIT</td></tr><tr><td align="center">BYTE</td><td align="center">TINYINT</td></tr><tr><td align="center">short</td><td align="center">SMALLINT</td></tr><tr><td align="center">INT</td><td align="center">INTEGER</td></tr><tr><td align="center">LONG</td><td align="center">BIGINT</td></tr><tr><td align="center">STRING</td><td align="center">CHAR,VARCHAR,LONGVARCHAR</td></tr><tr><td align="center">BYTE array</td><td align="center">BINARY , VAR BINARY</td></tr><tr><td align="center">java.sql.Date</td><td align="center">DATE</td></tr><tr><td align="center">java.sql.Time</td><td align="center">TIME</td></tr><tr><td align="center">java.sql.Timestamp</td><td align="center">TIMESTAMP</td></tr></tbody></table><h3 id="使用PreparedStatement实现增、删、改操作"><a href="#使用PreparedStatement实现增、删、改操作" class="headerlink" title="使用PreparedStatement实现增、删、改操作"></a>使用PreparedStatement实现增、删、改操作</h3><p>例1：</p><p>为了更容易的看清代码结构，这里采用抛异常处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testInsert() throws Exception&#123;</span><br><span class="line">        //1. 读取配置文件</span><br><span class="line">        InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;);</span><br><span class="line">        Properties properties = new Properties();</span><br><span class="line">        properties.load(is);</span><br><span class="line">        String user = properties.getProperty(&quot;user&quot;);</span><br><span class="line">        String password = properties.getProperty(&quot;password&quot;);</span><br><span class="line">        String url = properties.getProperty(&quot;url&quot;);</span><br><span class="line">        String className = properties.getProperty(&quot;className&quot;);</span><br><span class="line">        //2. 加载驱动</span><br><span class="line">        Class.forName(className);</span><br><span class="line">        //3. 获取连接</span><br><span class="line">        Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">        //4. 预编译SQL语句，返回PreparedStatement实例</span><br><span class="line">        String sql = &quot;insert into customers(name,email,birth) values(?,?,?)&quot;;</span><br><span class="line">        PreparedStatement ps = connection.prepareStatement(sql);</span><br><span class="line">        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">        java.util.Date date =  sdf.parse(&quot;1999-12-21&quot;);</span><br><span class="line">        //5. 填充占位符</span><br><span class="line">        ps.setObject(1,&quot;张三&quot;);</span><br><span class="line">        ps.setObject(2,&quot;zhangsan@gmail.com&quot;);</span><br><span class="line">        ps.setObject(3,date);</span><br><span class="line">        //6. 执行操作</span><br><span class="line">        ps.execute();</span><br><span class="line">        //7. 资源的关闭</span><br><span class="line">        ps.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>遇到资源的关闭，还是要用try&#x2F;catch&#x2F;finally处理的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testInsert() &#123;</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        PreparedStatement ps = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            //1. 读取配置文件</span><br><span class="line">            InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;);</span><br><span class="line">            Properties properties = new Properties();</span><br><span class="line">            properties.load(is);</span><br><span class="line">            String user = properties.getProperty(&quot;user&quot;);</span><br><span class="line">            String password = properties.getProperty(&quot;password&quot;);</span><br><span class="line">            String url = properties.getProperty(&quot;url&quot;);</span><br><span class="line">            String className = properties.getProperty(&quot;className&quot;);</span><br><span class="line">            //2. 加载驱动</span><br><span class="line">            Class.forName(className);</span><br><span class="line">            //3. 获取连接</span><br><span class="line">            connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">            //4. 预编译SQL语句，返回PreparedStatement实例</span><br><span class="line">            String sql = &quot;insert into customers(name,email,birth) values(?,?,?)&quot;;</span><br><span class="line">            ps = connection.prepareStatement(sql);</span><br><span class="line">            SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">            Date date =  sdf.parse(&quot;1999-08-11&quot;);</span><br><span class="line">            //5. 填充占位符</span><br><span class="line">            ps.setObject(1,&quot;李四&quot;);</span><br><span class="line">            ps.setObject(2,&quot;lisi@gmail.com&quot;);</span><br><span class="line">            ps.setObject(3,date);</span><br><span class="line">            //6. 执行操作</span><br><span class="line">            ps.execute();</span><br><span class="line">        &#125; catch (IOException | ClassNotFoundException | SQLException | ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //7. 资源的关闭</span><br><span class="line">            if (ps!=null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    ps.close();</span><br><span class="line">                &#125; catch (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (connection!=null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    connection.close();</span><br><span class="line">                &#125; catch (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>增删改的通用操作<br>注意到增删改都需要建立连接和关闭资源，所以可以将这二者封装成两个方法，写成一个工具类</p><ol><li><p>工具类提供通用的连接数据库和关闭资源的操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import java.io.InputStream;</span><br><span class="line">import java.sql.*;</span><br><span class="line">import java.util.Properties;</span><br><span class="line"></span><br><span class="line">public class JDBCUtil &#123;</span><br><span class="line">    public static Connection getConnection() throws Exception&#123;</span><br><span class="line">        //1. 读取配置文件</span><br><span class="line">        InputStream is = ClassLoader.getSystemClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;);</span><br><span class="line">        Properties properties = new Properties();</span><br><span class="line">        properties.load(is);</span><br><span class="line">        String user = properties.getProperty(&quot;user&quot;);</span><br><span class="line">        String password = properties.getProperty(&quot;password&quot;);</span><br><span class="line">        String url = properties.getProperty(&quot;url&quot;);</span><br><span class="line">        String className = properties.getProperty(&quot;className&quot;);</span><br><span class="line">        //2. 加载驱动</span><br><span class="line">        Class.forName(className);</span><br><span class="line">        //3. 获取连接</span><br><span class="line">        Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line">        return connection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void closeResource(Connection connection, Statement ps)&#123;</span><br><span class="line">        //资源的关闭</span><br><span class="line">        if (connection!=null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (ps!=null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                ps.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>增删改的通用操作</p><p>根据不同的SQL语句和占位符，可以实现任意的增删改操作，由于占位符的个数不确定，所以这里采用可变形参。</p><p>可变形参的底层是一个数组，所以我们可以用args.length来获取形参个数，从而进行遍历填充占位符</p><p>关于可变形参的说明：</p><ul><li><p>1.可变形参的个数可以是0个，1个，任意个</p></li><li><p>2.可变形参的底层就是一个数组</p></li><li><p>3.和可变形参相同类型的数组不构成方法重载</p></li><li><p>4.可变形参只能放在形参列表的最后一个</p></li><li><p>5.在一个形参列表中最多只能有一个可变形参</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void update(String sql, Object ...args) &#123;</span><br><span class="line">    Connection connection = null;</span><br><span class="line">    PreparedStatement ps = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        //1. 获取数据库的连接</span><br><span class="line">        connection = JDBCUtil.getConnection();</span><br><span class="line">        //2. 预编译SQL语句，返回PreparedStatement的实例</span><br><span class="line">        ps = connection.prepareStatement(sql);</span><br><span class="line">        //3. 填充占位符</span><br><span class="line">        for (int i = 0; i &lt; args.length; i++) &#123;</span><br><span class="line">            ps.setObject(i + 1, args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        //4. 执行</span><br><span class="line">        ps.execute();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //5. 资源的关闭</span><br><span class="line">        JDBCUtil.closeResource(connection, ps);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testUpdate() throws Exception&#123;</span><br><span class="line">        // 增</span><br><span class="line">        String sql1 = &quot;insert into customers(name,email,birth) values(?,?,?)&quot;;</span><br><span class="line">        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">        java.util.Date date = sdf.parse(&quot;1997-02-27&quot;);</span><br><span class="line">        update(sql1,&quot;王五&quot;,&quot;wangwu@gmail.com&quot;,date);</span><br><span class="line">        </span><br><span class="line">        // 删</span><br><span class="line">        String sql2 = &quot;delete from customers where id = ?&quot;;</span><br><span class="line">        update(sql2,4);</span><br><span class="line">        </span><br><span class="line">        // 改</span><br><span class="line">        String sql3 = &quot;update `order` set order_name = ? where order_id = ?&quot;;</span><br><span class="line">        update(sql3,&quot;DD&quot;,2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="使用PreparedStatement实现查询操作"><a href="#使用PreparedStatement实现查询操作" class="headerlink" title="使用PreparedStatement实现查询操作"></a>使用PreparedStatement实现查询操作</h3><p>查询操作不同于增删改操作，<strong>查询操作需要我们返回一个对象（多属性）</strong><br>Java中万事万物皆对象，例如我们在SQL中查询到的一条Customers对象，就可以对应一个Java类的对象<br>其中Customers表中的每一个字段，都对应着Java类中的一个属性</p><h4 id="针对Customers表的-不通用的-查询操作"><a href="#针对Customers表的-不通用的-查询操作" class="headerlink" title="针对Customers表的 不通用的 查询操作"></a>针对Customers表的 <code>不通用的</code> 查询操作</h4><ol><li><p>Customers类</p><p>下面是Customers表的描述，暂时无视掉这个photo，根据表的描述建一个Customer类</p><table><thead><tr><th align="center">Field</th><th align="center">Type</th><th align="center">Null</th><th align="center">Key</th><th align="center">Default</th><th align="center">Extra</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">int(10)</td><td align="center">NO</td><td align="center">PRI</td><td align="center"></td><td align="center">auto_increment</td></tr><tr><td align="center">name</td><td align="center">varchar(15)</td><td align="center">YES</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">email</td><td align="center">varchar(20)</td><td align="center">YES</td><td align="center"></td><td align="center"></td><td align="center">auto_increment</td></tr><tr><td align="center">birth</td><td align="center">date</td><td align="center">YES</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">photo</td><td align="center">mediumblob</td><td align="center">YES</td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table></li><li><p>select操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testQuery() throws Exception &#123;</span><br><span class="line">        //1. 获取数据库连接</span><br><span class="line">        Connection connection = JDBCUtil.getConnection();</span><br><span class="line">        //2. 预编译SQL语句，返回PreparedStatement对象实例</span><br><span class="line">        String sql = &quot;select id,name,email,birth from customers where id = ?&quot;;</span><br><span class="line">        PreparedStatement ps = connection.prepareStatement(sql);</span><br><span class="line">        //3. 填充占位符</span><br><span class="line">        ps.setObject(1, 1);</span><br><span class="line">        //4. 执行并返回结果集</span><br><span class="line">        ResultSet rs = ps.executeQuery();</span><br><span class="line">        //5. 处理结果集</span><br><span class="line">        //next():判断结果集的下一条是否有数据，有则返回true，无则返回false</span><br><span class="line">        //如果查询到了多条数据，把if换成while，这里的示例只查询了一条，所以这里用了if</span><br><span class="line">        if (rs.next()) &#123;</span><br><span class="line">            //获取当前数据的各个字段值，上面有Java与SQL对应的数据类型转换表</span><br><span class="line">            int id = rs.getInt(1);</span><br><span class="line">            String name = rs.getString(2);</span><br><span class="line">            String email = rs.getString(3);</span><br><span class="line">            Date date = rs.getDate(4);</span><br><span class="line">            //万事万物皆对象，将数据封装成一个类</span><br><span class="line">            Customer customer = new Customer(id, name, email, date);</span><br><span class="line">            System.out.println(customer);</span><br><span class="line">        &#125;</span><br><span class="line">        //6. 关闭资源，ResultSet也需要关闭，所以在JDBCUtil工具类中，重载一下closeResource方法</span><br><span class="line">        JDBCUtil.closeResource(connection, ps, rs);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>重载一下关闭资源的方法</p><p>由于结果集也需要我们关闭一下，所以在JDBCUtil工具类中，重载一下关闭资源的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static void closeResource(Connection connection, Statement ps,ResultSet rs)&#123;</span><br><span class="line">        //资源的关闭</span><br><span class="line">        if (connection!=null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (ps!=null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                ps.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (rs!=null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="针对Customers表-通用的-查询操作"><a href="#针对Customers表-通用的-查询操作" class="headerlink" title="针对Customers表 通用的 查询操作"></a>针对Customers表 <code>通用的</code> 查询操作</h4><ol><li><p>查询函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public Customer customerForQuery(String sql, Object... args) &#123;</span><br><span class="line">    Connection connection = null;</span><br><span class="line">    PreparedStatement ps = null;</span><br><span class="line">    ResultSet rs = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        //1. 连接数据库</span><br><span class="line">        connection = JDBCUtil.getConnection();</span><br><span class="line">        //2. 预编译SQL语句，获取PreparedStatement实例对象</span><br><span class="line">        ps = connection.prepareStatement(sql);</span><br><span class="line">        //3. 填充占位符</span><br><span class="line">        for (int i = 0; i &lt; args.length; i++) &#123;</span><br><span class="line">            ps.setObject(i + 1, args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        //4. 执行executeQuery()，获得结果集</span><br><span class="line">        rs = ps.executeQuery();</span><br><span class="line">        //5. 获得结果集的元数据</span><br><span class="line">        ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line">        //6. 通过元数据获取ColumnCount，即结果集中有几个列</span><br><span class="line">        int columnCount = rsmd.getColumnCount();</span><br><span class="line">        //7. 如果有数据</span><br><span class="line">        if (rs.next()) &#123;</span><br><span class="line">            //则生成一个对象实例，当然这里可以使用泛型</span><br><span class="line">            Customer customer = new Customer();</span><br><span class="line">            //遍历每一个列</span><br><span class="line">            for (int i = 0; i &lt; columnCount; i++) &#123;</span><br><span class="line">                //8. 获取列值</span><br><span class="line">                Object columnValue = rs.getObject(i + 1);</span><br><span class="line">                //9. 获取列名</span><br><span class="line">                String columnName = rsmd.getColumnName(i + 1);</span><br><span class="line">                //10. 使用反射给相应属性赋值，注意属性都是private的，将Accessible设置为true</span><br><span class="line">                Field field = customer.getClass().getDeclaredField(columnName);</span><br><span class="line">                field.setAccessible(true);</span><br><span class="line">                field.set(customer, columnValue);</span><br><span class="line">            &#125;</span><br><span class="line">            return customer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        //11. 资源的关闭</span><br><span class="line">        JDBCUtil.clossResource(connection, ps, rs);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testQuery2() &#123;</span><br><span class="line">        String sql = &quot;select id,name,email,birth from customers where id = ?&quot;;</span><br><span class="line">        Customer customer = customerForQuery(sql, &quot;1&quot;);</span><br><span class="line">        System.out.println(customer);</span><br><span class="line">        //Customer&#123;id=1, name=&#x27;汪峰&#x27;, email=&#x27;wf@126.com&#x27;, birth=2010-02-02&#125;</span><br><span class="line"></span><br><span class="line">        sql = &quot;select name,birth from customers where name = ?&quot;;</span><br><span class="line">        customer = customerForQuery(sql,&quot;周杰伦&quot;);</span><br><span class="line">        System.out.println(customer);</span><br><span class="line">        //Customer&#123;id=0, name=&#x27;周杰伦&#x27;, email=&#x27;null&#x27;, birth=1979-11-15&#125;</span><br><span class="line">        //这里只查询了两个字段，故查询结果中的其他字段为默认值        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="针对Order表-通用的-查询操作"><a href="#针对Order表-通用的-查询操作" class="headerlink" title="针对Order表 通用的 查询操作"></a>针对Order表 <code>通用的</code> 查询操作</h4><ol><li><p>order类</p><p>根据下表创建一个Order类，但<strong>SQL中的命名方式与Java中的命名方式不一样</strong>，我们按照Java中的命名方式即可，但是这样会导致反射时找不到对应的字段名去赋值。解决办法也很简单，<strong>在SQL查询语句中，可以给列起别名，将别名设定为Java中的命名方式即可</strong>，获取元数据的时候，使用getColumnLabel()方法来获取列的别名，这样就完美解决了这二者不同的命名方式产生的问题</p><table><thead><tr><th align="center">Field</th><th align="center">Type</th><th align="center">Null</th><th align="center">Key</th><th align="center">Default</th><th align="center">Extra</th></tr></thead><tbody><tr><td align="center">order_id</td><td align="center">int(10)</td><td align="center">NO</td><td align="center">PRI</td><td align="center"></td><td align="center">auto_increment</td></tr><tr><td align="center">order_name</td><td align="center">varchar(20)</td><td align="center">YES</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">order_date</td><td align="center">date</td><td align="center">YES</td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class Order &#123;</span><br><span class="line">    private int orderId;</span><br><span class="line">    private String orderName;</span><br><span class="line">    private Date orderDate;</span><br><span class="line"></span><br><span class="line">    public int getorderId() &#123;</span><br><span class="line">        return orderId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setorderId(int orderId) &#123;</span><br><span class="line">        this.orderId = orderId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getorderName() &#123;</span><br><span class="line">        return orderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setorderName(String orderName) &#123;</span><br><span class="line">        this.orderName = orderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Date getorderDate() &#123;</span><br><span class="line">        return orderDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setorderDate(Date orderDate) &#123;</span><br><span class="line">        this.orderDate = orderDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Order(int orderId, String orderName, Date orderDate) &#123;</span><br><span class="line">        this.orderId = orderId;</span><br><span class="line">        this.orderName = orderName;</span><br><span class="line">        this.orderDate = orderDate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Order() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Order&#123;&quot; +</span><br><span class="line">                &quot;orderId=&quot; + orderId +</span><br><span class="line">                &quot;, orderName=&#x27;&quot; + orderName + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, orderDate=&quot; + orderDate +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>queryForOrder</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public Order queryForOrder(String sql, Object... args) &#123;</span><br><span class="line">    Connection connection = null;</span><br><span class="line">    PreparedStatement ps = null;</span><br><span class="line">    ResultSet rs = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        connection = JDBCUtil.getConnection();</span><br><span class="line">        ps = connection.prepareStatement(sql);</span><br><span class="line">        for (int i = 0; i &lt; args.length; i++) &#123;</span><br><span class="line">            ps.setObject(i + 1, args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        rs = ps.executeQuery();</span><br><span class="line">        ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line">        int columnCount = rsmd.getColumnCount();</span><br><span class="line">        if (rs.next()) &#123;</span><br><span class="line">            Order order = new Order();</span><br><span class="line">            for (int i = 0; i &lt; columnCount; i++) &#123;</span><br><span class="line">                //这里改成了getColumnLabel来获取别名，如果未给列取别名，那么别名就是列名</span><br><span class="line">                String columnLabel = rsmd.getColumnLabel(i + 1);</span><br><span class="line">                Object columnValue = rs.getObject(i + 1);</span><br><span class="line">                //别名与Java中命名方式相同，所以反射的时候通过别名来找到对应字段值来赋值</span><br><span class="line">                Field field = order.getClass().getDeclaredField(columnLabel);</span><br><span class="line">                field.setAccessible(true);</span><br><span class="line">                field.set(order, columnValue);</span><br><span class="line">            &#125;</span><br><span class="line">            return order;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        JDBCUtil.clossResource(connection, ps, rs);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testQuery() &#123;</span><br><span class="line">        String sql = &quot;select order_name as orderName,order_date as orderDate from `order` where order_id = ?&quot;;</span><br><span class="line">        Order order = queryForOrder(sql, 2);</span><br><span class="line">        System.out.println(order);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>当表的字段名和类的属性名不同时：</p><ul><li>1.在声明sql时，使用类的属性名来命名字段的别名</li><li>2.使用ResultSetMetaData的getColumnLabel()方法来替代getColumnName()方法，获得列的列名的别名。</li><li>3.说明：没有别名时，getColumnLabel()方法获取的就是列名；所以无论有没有别名，都使用getColumnLabel()方法</li></ul></blockquote><h4 id="通用的查询操作，但只返回一条记录"><a href="#通用的查询操作，但只返回一条记录" class="headerlink" title="通用的查询操作，但只返回一条记录"></a><code>通用的</code>查询操作，但只返回一条记录</h4><ol><li><p>通用的查询操作</p><p>利用泛型方法来解决</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T getInstance(Class&lt;T&gt; clazz, String sql, Object... args) &#123;</span><br><span class="line">    Connection connection = null;</span><br><span class="line">    PreparedStatement ps = null;</span><br><span class="line">    ResultSet rs = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        connection = JDBCUtil.getConnection();</span><br><span class="line">        ps = connection.prepareStatement(sql);</span><br><span class="line">        for (int i = 0; i &lt; args.length; i++) &#123;</span><br><span class="line">            ps.setObject(i + 1, args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        rs = ps.executeQuery();</span><br><span class="line">        if (rs.next()) &#123;</span><br><span class="line">            T t = clazz.newInstance();</span><br><span class="line">            ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line">            int columnCount = rsmd.getColumnCount();</span><br><span class="line">            for (int i = 0; i &lt; columnCount; i++) &#123;</span><br><span class="line">                Object columnValue = rs.getObject(i + 1);</span><br><span class="line">                String columnLabel = rsmd.getColumnLabel(i + 1);</span><br><span class="line">                Field field = t.getClass().getDeclaredField(columnLabel);</span><br><span class="line">                field.setAccessible(true);</span><br><span class="line">                field.set(t, columnValue);</span><br><span class="line">            &#125;</span><br><span class="line">            return t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        JDBCUtil.clossResource(connection, ps, rs);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void queryTest() &#123;</span><br><span class="line">        String sql1 = &quot;select order_id as orderId,order_name as orderName,order_date as orderDate from `order` where order_id = ?&quot;;</span><br><span class="line">        Order order = getInstance(Order.class, sql1, 1);</span><br><span class="line">        System.out.println(order);</span><br><span class="line"></span><br><span class="line">        String sql2 = &quot;select id,name,email,birth from customers where id = ?&quot;;</span><br><span class="line">        Customer customer = getInstance(Customer.class, sql2, 7);</span><br><span class="line">        System.out.println(customer);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="通用的查询操作，返回多条记录"><a href="#通用的查询操作，返回多条记录" class="headerlink" title="通用的查询操作，返回多条记录"></a><code>通用的</code>查询操作，返回多条记录</h4><p>只需要在返回一条记录的基础上，修改一些代码即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">//把返回类型改为集合</span><br><span class="line">public &lt;T&gt; ArrayList&lt;T&gt; getForList(Class&lt;T&gt; clazz, String sql, Object... args)&#123;</span><br><span class="line">    Connection connection = null;</span><br><span class="line">    PreparedStatement ps = null;</span><br><span class="line">    ResultSet rs = null;</span><br><span class="line">    ArrayList&lt;T&gt; ts = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        connection = JDBCUtil.getConnection();</span><br><span class="line">        ps = connection.prepareStatement(sql);</span><br><span class="line">        for (int i = 0; i &lt; args.length; i++) &#123;</span><br><span class="line">            ps.setObject(i + 1, args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        rs = ps.executeQuery();</span><br><span class="line">        ts = new ArrayList&lt;&gt;();</span><br><span class="line">        ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line">        int columnCount = rsmd.getColumnCount();</span><br><span class="line">        //这里的if改成while</span><br><span class="line">        while (rs.next()) &#123;</span><br><span class="line">            T t = clazz.newInstance();</span><br><span class="line">            for (int i = 0; i &lt; columnCount; i++) &#123;</span><br><span class="line">                Object columnValue = rs.getObject(i + 1);</span><br><span class="line">                String columnLabel = rsmd.getColumnLabel(i + 1);</span><br><span class="line">                Field field = t.getClass().getDeclaredField(columnLabel);</span><br><span class="line">                field.setAccessible(true);</span><br><span class="line">                field.set(t, columnValue);</span><br><span class="line">            &#125;</span><br><span class="line">            //没查询完一条数据，将其加入到集合中</span><br><span class="line">            ts.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">        return ts;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        JDBCUtil.clossResource(connection, ps, rs);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询Customers表中id小于某个值的所有数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">@Test</span><br><span class="line">    public void queryTest() &#123;</span><br><span class="line">        String sql = &quot;select id,name,email,birth from customers where id &lt; ?&quot;;</span><br><span class="line">        ArrayList&lt;Customer&gt; ts = getForList(Customer.class,sql, 13);</span><br><span class="line">        for (Customer c : ts) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="使用PreparedStatement代替Statement原因："><a href="#使用PreparedStatement代替Statement原因：" class="headerlink" title="使用PreparedStatement代替Statement原因："></a>使用PreparedStatement代替Statement原因：</h3><ol><li>PreparedStatement是预编译的sql语句，可以解决Statement的拼串和sql注入问题；<ul><li>PreparedStatement首先确定了语法逻辑，然后填充相应的数值；</li><li>而Statement会连着数值里包含的非法语法一起编译，就会造成对原来语法逻辑的破坏。</li></ul></li><li>PreparedStatement还可以操作Blob类型的数据，而Statement不行；</li><li>PreparedStatement可以实现跟高效的批量操作：<ul><li>如果访问10000条数据，PreparedStatement会将语法固定，只用填充占位符就好了。</li></ul></li></ol><h2 id="JDBC-API小结"><a href="#JDBC-API小结" class="headerlink" title="JDBC API小结"></a>JDBC API小结</h2><p>两种思想</p><ul><li>面向接口编程的思想</li><li>ORM思想(object relational mapping)<ul><li>一个数据表对应一个java类</li><li>表中的一条记录对应java类的一个对象</li><li>表中的一个字段对应java类的一个属性</li></ul></li></ul><p>sql是需要结合列名和表的属性名来写。注意起别名。</p><p>两种技术</p><ul><li>JDBC结果集的元数据：ResultSetMetaData<ul><li>获取列数：getColumnCount()</li><li>获取列的别名：getColumnLabel()</li></ul></li><li>通过反射，创建指定类的对象，获取指定的属性并赋值</li></ul><h1 id="操作BLOB类型字段"><a href="#操作BLOB类型字段" class="headerlink" title="操作BLOB类型字段"></a>操作BLOB类型字段</h1><h2 id="MySQL-BLOB类型"><a href="#MySQL-BLOB类型" class="headerlink" title="MySQL BLOB类型"></a>MySQL BLOB类型</h2><p>MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。</p><p>插入BLOB类型的数据<strong>必须使用PreparedStatement</strong>，因为BLOB类型的数据无法使用字符串拼接写的。</p><p>MySQL的四种BLOB类型除了在存储的最大信息量上不同外，他们是等同的</p><table><thead><tr><th align="center">类型</th><th align="center">大小{单位:字节)</th></tr></thead><tbody><tr><td align="center">TINYBLOB</td><td align="center">最大255</td></tr><tr><td align="center">BLOB</td><td align="center">最大65K</td></tr><tr><td align="center">MEDIUMBLOB</td><td align="center">最大16M</td></tr><tr><td align="center">LONGBLOB</td><td align="center">最大4G</td></tr></tbody></table><blockquote><p>但实际上packet 有大小限制，超过1M 还是会报错</p><p>如果在指定了相关的Blob类型以后，还报错：xxx too large，那么在mysql的安装目录下，找my.ini文件加上如下的配置参数： max_allowed_packet&#x3D;16M。</p><p>同时注意：修改了my.ini文件之后，需要重新启动mysql服务。</p></blockquote><p>实际使用中根据需要存入的数据大小定义不同的BLOB类型。</p><p>需要注意的是：如果存储的文件过大，数据库的性能会下降。</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>向数据表中插入大数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void blobTest() &#123;</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        PreparedStatement ps = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            String sql = &quot;insert into customers(name,email,birth,photo) values(?,?,?,?)&quot;;</span><br><span class="line">            //获取连接</span><br><span class="line">            connection = JDBCUtil.getConnection();</span><br><span class="line">            //预编译SQL语句，获取prepareStatement实例对象</span><br><span class="line">            ps = connection.prepareStatement(sql);</span><br><span class="line">            //填充占位符</span><br><span class="line">            ps.setObject(1, &quot;Kyle&quot;);</span><br><span class="line">            ps.setObject(2, &quot;Kyle@126.com&quot;);</span><br><span class="line">            ps.setObject(3, &quot;1997-08-07&quot;);</span><br><span class="line">            //操作Blob类型变量</span><br><span class="line">            ps.setBlob(4, new FileInputStream(&quot;头像.png&quot;));</span><br><span class="line">            //执行</span><br><span class="line">            ps.execute();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            JDBCUtil.clossResource(connection, ps);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><p>从数据表中读取大数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void blobTest2() &#123;</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        PreparedStatement ps = null;</span><br><span class="line">        ResultSet rs = null;</span><br><span class="line">        InputStream is = null;</span><br><span class="line">        OutputStream os = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            String sql = &quot;select id,name,email,birth,photo from customers where id = ?&quot;;</span><br><span class="line">            connection = JDBCUtil.getConnection();</span><br><span class="line">            ps = connection.prepareStatement(sql);</span><br><span class="line">            ps.setObject(1, 16);</span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line">            if (rs.next())&#123;</span><br><span class="line">                int id = rs.getInt(&quot;id&quot;);</span><br><span class="line">                String name = rs.getString(&quot;name&quot;);</span><br><span class="line">                String email = rs.getString(&quot;email&quot;);</span><br><span class="line">                Date birth = rs.getDate(&quot;birth&quot;);</span><br><span class="line">                Customer customer = new Customer(id, name, email, birth);</span><br><span class="line">                System.out.println(customer);</span><br><span class="line">                Blob photo = rs.getBlob(&quot;photo&quot;);</span><br><span class="line">                is = photo.getBinaryStream();</span><br><span class="line">                os = new FileOutputStream(&quot;照片.png&quot;);</span><br><span class="line">                byte[] buffer = new byte[1024];</span><br><span class="line">                int len;</span><br><span class="line">                while ((len = is.read(buffer)) != -1) &#123;</span><br><span class="line">                    os.write(buffer, 0, len);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (is != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (os != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            JDBCUtil.clossResource(connection, ps, rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h2><h3 id="批量执行SQL语句"><a href="#批量执行SQL语句" class="headerlink" title="批量执行SQL语句"></a>批量执行SQL语句</h3><p>当需要成批插入或者更新记录时，可以采用 Java的<code>批量更新</code>机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率</p><p>JDBC的批量处理语句包括下面三个方法：</p><ul><li>addBatch(String)：添加需要批量处理的SQL语句或是参数；</li><li>executeBatch()：执行批量处理语句；</li><li>clearBatch():清空缓存的数据</li></ul><p>通常我们会遇到两种批量执行SQL语句的情况：</p><ul><li>多条SQL语句的批量处理；</li><li>一个SQL语句的批量传参；</li></ul><h3 id="高效的批量插入"><a href="#高效的批量插入" class="headerlink" title="高效的批量插入"></a>高效的批量插入</h3><p>举例：向数据表中插入20000条数据</p><ul><li><p>首先先创建一个goods表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE goods(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">`name` VARCHAR(25)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><p>下面是四种实现方式，效率逐渐提高，都是基于低层次实现的优化</p><ol><li><p>使用Statement</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//耗时：15006ms</span><br><span class="line">@Test</span><br><span class="line">    public void testInsert01() &#123;</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        Statement st = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            connection = JDBCUtil.getConnection();</span><br><span class="line">            st = connection.createStatement();</span><br><span class="line">            long start = System.currentTimeMillis();</span><br><span class="line">            for (int i = 1; i &lt;= 20000; i++) &#123;</span><br><span class="line">                String sql = &quot;insert into goods(name) values(&#x27;name_ &quot; + i + &quot;&#x27;)&quot;;</span><br><span class="line">                st.executeUpdate(sql);</span><br><span class="line">            &#125;</span><br><span class="line">            long end = System.currentTimeMillis();</span><br><span class="line">            System.out.println(&quot;耗时：&quot; + (end - start)  + &quot;ms&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            JDBCUtil.clossResource(connection, st);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>使用PreparedStatement</p><p>PreparedStatement优于Statement的地方：</p><ul><li>在于sql语句Statement内存中会有很多个sql语句，并且每次都会做一次语法检查，而PreparedStatement只有一个sql语句，每次只是填充占位符。（预编译）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testInsert02()&#123;</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        PreparedStatement ps = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            String sql = &quot;insert into goods(name) values(?)&quot;;</span><br><span class="line">            connection = JDBCUtil.getConnection();</span><br><span class="line">            ps = connection.prepareStatement(sql);</span><br><span class="line">            long start = System.currentTimeMillis();</span><br><span class="line">            for (int i = 0; i &lt; 20000; i++) &#123;</span><br><span class="line">                ps.setObject(1, &quot;name_&quot; + i);</span><br><span class="line">            &#125;</span><br><span class="line">            long end = System.currentTimeMillis();</span><br><span class="line">            System.out.println(&quot;耗时：&quot; + (end - start) + &quot;ms&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            JDBCUtil.clossResource(connection, ps);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>相较于实现层次二的优点：</p><p>使用Batch批量处理：addBatch()、executeBatch()、clearBatch()</p><p>mysql服务器默认是关闭批处理的，我们需要通过一个参数，让mysql开启批处理的支持。在jdbc.properties配置文件的url后添上：?rewriteBatchedStatements&#x3D;true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//耗时：196ms</span><br><span class="line">@Test</span><br><span class="line">    public void testInsert03() &#123;</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        PreparedStatement ps = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            String sql = &quot;insert into goods(name) values(?)&quot;;</span><br><span class="line">            connection = JDBCUtil.getConnection();</span><br><span class="line">            ps = connection.prepareStatement(sql);</span><br><span class="line">            long start = System.currentTimeMillis();</span><br><span class="line">            for (int i = 0; i &lt; 20000; i++) &#123;</span><br><span class="line">                ps.setObject(1, &quot;name_&quot; + i);</span><br><span class="line">                //1.“攒”sql</span><br><span class="line">                ps.addBatch();</span><br><span class="line">                if (i % 10000 == 0)&#123;</span><br><span class="line">                    //2.执行</span><br><span class="line">                    ps.executeBatch();</span><br><span class="line">                    //3.清空</span><br><span class="line">                    ps.clearBatch();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            long end = System.currentTimeMillis();</span><br><span class="line">            System.out.println(&quot;耗时：&quot; + (end - start) + &quot;ms&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            JDBCUtil.clossResource(connection, ps);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><ul><li>每500条数据执行一次ps.executeBatch();</li><li>这样每500条就会提交一次。</li><li>但每次提交都会占用一点时间，所以先不提交，都传完以后，最后再提交。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//耗时：157ms</span><br><span class="line">@Test</span><br><span class="line">    public void testInsert04() &#123;</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        PreparedStatement ps = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            String sql = &quot;insert into goods(name) values(?)&quot;;</span><br><span class="line">            connection = JDBCUtil.getConnection();</span><br><span class="line">            //1.设置为不自动提交数据</span><br><span class="line">            connection.setAutoCommit(false);</span><br><span class="line">            ps = connection.prepareStatement(sql);</span><br><span class="line">            long start = System.currentTimeMillis();</span><br><span class="line">            for (int i = 0; i &lt; 20000; i++) &#123;</span><br><span class="line">                ps.setObject(1, &quot;name_&quot; + i);</span><br><span class="line">                //1.“攒”sql</span><br><span class="line">                ps.addBatch();</span><br><span class="line">                if (i % 10000 == 0)&#123;</span><br><span class="line">                    //2.执行</span><br><span class="line">                    ps.executeBatch();</span><br><span class="line">                    //3.清空</span><br><span class="line">                    ps.clearBatch();</span><br><span class="line">            &#125;</span><br><span class="line">            //2.提交数据</span><br><span class="line">            connection.commit();</span><br><span class="line">            long end = System.currentTimeMillis();</span><br><span class="line">            System.out.println(&quot;耗时：&quot; + (end - start) + &quot;ms&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            JDBCUtil.clossResource(connection, ps);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h1><h2 id="数据库事务介绍"><a href="#数据库事务介绍" class="headerlink" title="数据库事务介绍"></a>数据库事务介绍</h2><p>事务：一组逻辑操作单元,使数据从一种状态变换到另一种状态。</p><p>事务处理（事务操作）：</p><p>保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交(<code>commit</code>)，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务回滚(<code>rollback</code>)到最初状态。</p><p>为确保数据库中数据的一致性，数据的操纵应当是离散的成组的逻辑单元：当它全部完成时，数据的一致性可以保持，而当这个单元中的一部分操作失败，整个事务应全部视为错误，所有从起始点以后的操作应全部回退到开始状态。</p><h2 id="JDBC事务处理"><a href="#JDBC事务处理" class="headerlink" title="JDBC事务处理"></a>JDBC事务处理</h2><p>数据一旦提交，就不可回滚。</p><p>哪些操作会导致数据的自动提交？</p><ul><li>DDL操作一旦执行，都会自动提交；<code>set autocommit = false</code>对操作失效；</li><li>DML默认情况下，一旦执行，就会自动提交；但我们可以通过<code>set autocommit = false</code>的方式取消DML操作的自动提交；</li><li>关闭连接的时候也会默认自动提交</li></ul><p>JDBC程序中为了让多个 SQL 语句作为一个事务执行：</p><ul><li>调用 Connection 对象的 <code>setAutoCommit(false);</code> 以取消自动提交事务</li><li>在所有的 SQL 语句都成功执行后，调用 <code>commit();</code> 方法提交事务</li><li>在出现异常时，调用 <code>rollback();</code> 方法回滚事务</li></ul><blockquote><p>若此时 Connection 没有被关闭，还可能被重复使用，则需要恢复其自动提交状态<code>setAutoCommit(true)</code>。尤其是在使用数据库连接池技术时，执行close()方法前，建议恢复自动提交状态。</p></blockquote><h2 id="事务的ACID属性"><a href="#事务的ACID属性" class="headerlink" title="事务的ACID属性"></a>事务的ACID属性</h2><ol><li>原子性（Atomicity） 原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</li><li>一致性（Consistency） 事务必须使数据库从一个一致性状态变换到另外一个一致性状态。</li><li>隔离性（Isolation） 事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</li><li>持久性（Durability） 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。</li></ol><h2 id="数据库的并发问题"><a href="#数据库的并发问题" class="headerlink" title="数据库的并发问题"></a>数据库的并发问题</h2><p>对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:</p><ul><li>脏读：对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。</li><li>不可重复读：对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段。之后, T1再次读取同一个字段, 值就不同了。（例如在购物网站刷新界面，库存可能会增加或减少）</li><li>幻读：对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插入了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。（刷新购物网站，多了几条新商品）</li></ul><p>数据库事务的隔离性:数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。</p><p>一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高</p><h4 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h4><p>数据库提供的4种事务隔离级别：</p><table><thead><tr><th align="center">隔离级别</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">READ UNCOMMITTED (读未提交数据)</td><td align="center">允许事务读取未被其他事物提交的变更.脏读,不可重复读和幻读的问题都会出现</td></tr><tr><td align="center">READ COMMITED (读已提交数据)</td><td align="center">只允许事务读取已经被其它事务提交的变更.可以避免脏读,但不可重复读和幻读问题仍然可能出现</td></tr><tr><td align="center">REPEATABLE READ (可重复读)</td><td align="center">确保事务可以多次从一个字段中读取相同的值.在这个事务持续期间, 禁止其他事物对这个字段进行更新.可以避免脏读和不可重复读,但幻读的问题仍然存在.</td></tr><tr><td align="center">SERIALIZABLE (串行化)</td><td align="center">执行插入,更新和删除操作.所有并发问题都可以避免, 但性能十分低下确保事务可以从一个表中读取相同的行.在这个事务持续期间,禁止其他事务对该表</td></tr></tbody></table><ul><li>Oracle 支持的 2 种事务隔离级别：<code>READ COMMITED</code>, <code>SERIALIZABLE</code>。 Oracle 默认的事务隔离级别为: <code>READ COMMITED</code> 。</li><li>Mysql 支持 4 种事务隔离级别。Mysql 默认的事务隔离级别为: <code>REPEATABLE READ</code>。</li></ul><h3 id="在MySql中设置隔离级别"><a href="#在MySql中设置隔离级别" class="headerlink" title="在MySql中设置隔离级别"></a>在MySql中设置隔离级别</h3><p>每启动一个 mysql 程序, 就会获得一个单独的数据库连接. 每个数据库连接都有一个全局变量 @@tx_isolation,表示当前的事务隔离级别。</p><ul><li>查看当前的隔离级别:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@tx_isolation;</span><br></pre></td></tr></table></figure><ul><li>设置当前 mySQL 连接的隔离级别:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br></pre></td></tr></table></figure><ul><li>设置数据库系统的全局的隔离级别:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br></pre></td></tr></table></figure><h3 id="在Java代码中设置隔离级别"><a href="#在Java代码中设置隔离级别" class="headerlink" title="在Java代码中设置隔离级别"></a>在Java代码中设置隔离级别</h3><p>使用getTransactionIsolation()可以获得当前隔离级别的int值，对应如下</p><ul><li>int TRANSACTION_READ_UNCOMMITTED &#x3D; 1;</li><li>int TRANSACTION_READ_COMMITTED &#x3D; 2;</li><li>int TRANSACTION_REPEATABLE_READ &#x3D; 4;</li><li>int TRANSACTION_SERIALIZABLE &#x3D; 8;</li></ul><p>使用setTransactionIsolation可以设置隔离级别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testTransactionUpdate() throws Exception&#123;</span><br><span class="line">        Connection connection = JDBCUtil.getConnection();</span><br><span class="line">        //获取数据库隔离级别</span><br><span class="line">        System.out.println(connection.getTransactionIsolation());</span><br><span class="line">        //设置数据库隔离级别</span><br><span class="line">        connection.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);</span><br><span class="line">        String sql = &quot;update user_table set balance = ? where user = ?&quot;;</span><br><span class="line">        update(sql,5000,&quot;CC&quot;);</span><br><span class="line">        System.out.println(&quot;修改结束&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="DAO及相关实现类"><a href="#DAO及相关实现类" class="headerlink" title="DAO及相关实现类"></a>DAO及相关实现类</h1><p>DAO：Data Access Object 访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息。有时也称作：BaseDAO</p><p>作用：为了实现功能的模块化，更有利于代码的维护和升级</p>]]></content>
      
      
      <categories>
          
          <category> JDBC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDBC 数据库 sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM整合+拦截器</title>
      <link href="/2023/10/25/SSM%E6%95%B4%E5%90%88/"/>
      <url>/2023/10/25/SSM%E6%95%B4%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a>SSM整合</h1><h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><ol><li>创建工程<ul><li>创建一个Maven的web工程</li><li>pom.xml添加SSM需要的依赖jar包</li><li>编写Web项目的入口配置类，实现AbstractAnnotationConfigDispatcherServletInitializer重写以下方法<ul><li><code>getRootConfigClasses()</code> ：返回Spring的配置类 –&gt; 需要<code>SpringConfig</code>配置类</li><li><code>getServletConfigClasses()</code> ：返回SpringMVC的配置类 –&gt; 需要<code>SpringMvcConfig</code>配置类</li><li><code>getServletMappings()</code> : 设置SpringMVC请求拦截路径规则</li><li><code>getServletFilters()</code> ：设置过滤器，解决POST请求中文乱码问题</li></ul></li></ul></li><li>SSM整合(重点是各个配置的编写)<ul><li>SpringConfig<ul><li>标识该类为配置类，使用<code>@Configuration</code></li><li>扫描<code>Service</code>所在的包，使用<code>@ComponentScan</code></li><li>在<code>Service</code>层要管理事务，使用<code>@EnableTransactionManagement</code></li><li>读取外部的<code>properties</code>配置文件，使用<code>@PropertySource</code></li><li>整合Mybatis需要引入Mybatis相关配置类，使用@Import<ul><li>第三方数据源配置类 <code>JdbcConfig</code></li><li>构建DataSource数据源，DruidDataSouroce，需要注入数据库连接四要素，使用<code> @Bean</code>、<code>@Value</code></li><li>构建平台事务管理器，DataSourceTransactionManager，使用<code>@Bean</code></li><li>Mybatis配置类 <code>MybatisConfig</code></li><li>构建<code>SqlSessionFactoryBean</code>并设置别名扫描与数据源，使用<code>@Bean</code></li><li>构建<code>MapperScannerConfigurer</code>并设置DAO层的包扫描</li></ul></li></ul></li><li>SpringMvcConfig<ul><li>标识该类为配置类，使用<code>@Configuratio</code></li><li>扫描<code>Controller</code>所在的包，使用<code>@ComponentScan</code></li><li>开启SpringMVC注解支持，使用<code>@EnableWebMvc</code></li></ul></li></ul></li><li>功能模块(与具体的业务模块有关)<ul><li>创建数据库表</li><li>根据数据库表创建对应的模型类</li><li>通过Dao层完成数据库表的增删改查(接口+自动代理)</li><li>编写Service层(Service接口+实现类)<ul><li><code>@Service</code></li><li><code>@Transactional</code></li><li>整合Junit对业务层进行单元测试<ul><li><code>@RunWith</code></li><li><code>@ContextConfiguration</code></li><li><code>@Test</code></li></ul></li></ul></li><li>编写Controller层<ul><li>接收请求 <code>@RequestMapping</code>、<code>@GetMapping</code>、<code>@PostMapping</code>、<code>@PutMapping</code>、<code>@DeleteMapping</code></li><li>接收数据 简单、POJO、嵌套POJO、集合、数组、JSON数据类型<ul><li><code>@RequestParam</code></li><li><code>@PathVariable</code></li><li><code>@RequestBody</code></li></ul></li><li>转发业务层<ul><li><code>@Autowired</code></li></ul></li><li>响应结果<ul><li><code>@ResponseBody</code></li></ul></li></ul></li></ul></li></ol><h2 id="整合配置"><a href="#整合配置" class="headerlink" title="整合配置"></a>整合配置</h2><ol><li><p>创建Maven的web项目</p></li><li><p>导入坐标，配置依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.5.6&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.3.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.1.46&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.1.16&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">        &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.9.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></li><li><p>创建项目包结构</p><ul><li><code>com.blog.config</code>目录存放的是相关的配置类</li><li><code>com.blog.controller</code>编写的是Controller类</li><li><code>com.blog.dao</code>存放的是Dao接口，因为使用的是Mapper接口代理方式，所以没有实现类包</li><li><code>com.blog.service</code>存的是Service接口，<code>com.blog.service.impl</code>存放的是Service实现类</li><li><code>resources</code>:存入的是配置文件，如Jdbc.properties</li><li><code>webapp</code>:目录可以存放静态资源</li><li><code>test/java</code>:存放的是测试类</li></ul></li><li><p>创建jdbc.properties（注意版本差异）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql://localhost:13306/test</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=PASSWORD.</span><br></pre></td></tr></table></figure></li><li><p>创建JdbcConfig配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class JdbcConfig &#123;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span><br><span class="line">    private String driver;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.url&#125;&quot;)</span><br><span class="line">    private String url;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.username&#125;&quot;)</span><br><span class="line">    private String username;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.password&#125;&quot;)</span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource() &#123;</span><br><span class="line">        DruidDataSource dataSource = new DruidDataSource();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        return dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public PlatformTransactionManager platformTransactionManager(DataSource dataSource)&#123;</span><br><span class="line">        DataSourceTransactionManager ds = new DataSourceTransactionManager();</span><br><span class="line">        ds.setDataSource(dataSource);</span><br><span class="line">        return ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建MyBatisConfig配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class MyBatisConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource)&#123;</span><br><span class="line">        SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean();</span><br><span class="line">        factoryBean.setDataSource(dataSource);</span><br><span class="line">        factoryBean.setTypeAliasesPackage(&quot;com.blog.domain&quot;);</span><br><span class="line">        return factoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MapperScannerConfigurer mapperScannerConfigurer()&#123;</span><br><span class="line">        MapperScannerConfigurer msc = new MapperScannerConfigurer();</span><br><span class="line">        msc.setBasePackage(&quot;com.blog.dao&quot;);</span><br><span class="line">        return msc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建SpringConfig配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.blog.service&quot;)</span><br><span class="line">@PropertySource(&quot;jdbc.properties&quot;)</span><br><span class="line">@EnableTransactionManagement</span><br><span class="line">@Import(&#123;JdbcConfig.class, MyBatisConfig.class&#125;)</span><br><span class="line">public class SpringConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建SpringMvcConfig配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.blog.controller&quot;)</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class SpringMvcConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建ServletContainersInitConfig配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer &#123;</span><br><span class="line">    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        return new Class[]&#123;SpringConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        return new Class[]&#123;SpringMvcConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected String[] getServletMappings() &#123;</span><br><span class="line">        return new String[]&#123;&quot;/&quot;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Filter[] getServletFilters() &#123;</span><br><span class="line">        CharacterEncodingFilter filter = new CharacterEncodingFilter();</span><br><span class="line">        filter.setEncoding(&quot;utf-8&quot;);</span><br><span class="line">        return new Filter[]&#123;filter&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="功能模块开发"><a href="#功能模块开发" class="headerlink" title="功能模块开发"></a>功能模块开发</h2><p>需求：对表t_book进行新增、修改、删除、根据ID查询和查询所有</p><ol><li><p>创建数据库及表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">create database ssm_db;</span><br><span class="line">use ssm_db;</span><br><span class="line">create table tbl_book</span><br><span class="line">(</span><br><span class="line">    id          int primary key auto_increment,</span><br><span class="line">    type        varchar(20),</span><br><span class="line">    `name`      varchar(50),</span><br><span class="line">    description varchar(255)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">insert into `tbl_book`(`id`, `type`, `name`, `description`)</span><br><span class="line">values (1, &#x27;计算机理论&#x27;, &#x27;Spring实战 第五版&#x27;, &#x27;Spring入门经典教程，深入理解Spring原理技术内幕&#x27;),</span><br><span class="line">       (2, &#x27;计算机理论&#x27;, &#x27;Spring 5核心原理与30个类手写实践&#x27;, &#x27;十年沉淀之作，手写Spring精华思想&#x27;),</span><br><span class="line">       (3, &#x27;计算机理论&#x27;, &#x27;Spring 5设计模式&#x27;, &#x27;深入Spring源码刨析Spring源码中蕴含的10大设计模式&#x27;),</span><br><span class="line">       (4, &#x27;计算机理论&#x27;, &#x27;Spring MVC+Mybatis开发从入门到项目实战&#x27;,</span><br><span class="line">        &#x27;全方位解析面向Web应用的轻量级框架，带你成为Spring MVC开发高手&#x27;),</span><br><span class="line">       (5, &#x27;计算机理论&#x27;, &#x27;轻量级Java Web企业应用实战&#x27;, &#x27;源码级刨析Spring框架，适合已掌握Java基础的读者&#x27;),</span><br><span class="line">       (6, &#x27;计算机理论&#x27;, &#x27;Java核心技术 卷Ⅰ 基础知识(原书第11版)&#x27;,</span><br><span class="line">        &#x27;Core Java第11版，Jolt大奖获奖作品，针对Java SE9、10、11全面更新&#x27;),</span><br><span class="line">       (7, &#x27;计算机理论&#x27;, &#x27;深入理解Java虚拟机&#x27;, &#x27;5个纬度全面刨析JVM,大厂面试知识点全覆盖&#x27;),</span><br><span class="line">       (8, &#x27;计算机理论&#x27;, &#x27;Java编程思想(第4版)&#x27;, &#x27;Java学习必读经典，殿堂级著作！赢得了全球程序员的广泛赞誉&#x27;),</span><br><span class="line">       (9, &#x27;计算机理论&#x27;, &#x27;零基础学Java(全彩版)&#x27;, &#x27;零基础自学编程的入门图书，由浅入深，详解Java语言的编程思想和核心技术&#x27;),</span><br><span class="line">       (10, &#x27;市场营销&#x27;, &#x27;直播就这么做:主播高效沟通实战指南&#x27;, &#x27;李子柒、李佳奇、薇娅成长为网红的秘密都在书中&#x27;),</span><br><span class="line">       (11, &#x27;市场营销&#x27;, &#x27;直播销讲实战一本通&#x27;, &#x27;和秋叶一起学系列网络营销书籍&#x27;),</span><br><span class="line">       (12, &#x27;市场营销&#x27;, &#x27;直播带货:淘宝、天猫直播从新手到高手&#x27;, &#x27;一本教你如何玩转直播的书，10堂课轻松实现带货月入3W+&#x27;);</span><br></pre></td></tr></table></figure></li><li><p>编写模型类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class Book &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String type;</span><br><span class="line">    private String name;</span><br><span class="line">    private String description;</span><br><span class="line">    </span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getType() &#123;</span><br><span class="line">        return type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setType(String type) &#123;</span><br><span class="line">        this.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDescription() &#123;</span><br><span class="line">        return description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDescription(String description) &#123;</span><br><span class="line">        this.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Book&#123;&quot; +</span><br><span class="line">                &quot;id=&quot; + id +</span><br><span class="line">                &quot;, type=&#x27;&quot; + type + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, description=&#x27;&quot; + description + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写Dao接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public interface BookDao &#123;</span><br><span class="line">    @Insert(&quot;insert into tbl_book values (null, #&#123;type&#125;, #&#123;name&#125;, #&#123;description&#125;)&quot;)</span><br><span class="line">    void save(Book book);</span><br><span class="line"></span><br><span class="line">    @Update(&quot;update tbl_book set type=#&#123;type&#125;, `name`=#&#123;name&#125;, `description`=#&#123;description&#125; where id=#&#123;id&#125;&quot;)</span><br><span class="line">    void update(Book book);</span><br><span class="line"></span><br><span class="line">    @Delete(&quot;delete from tbl_book where id=#&#123;id&#125;&quot;)</span><br><span class="line">    void delete(Integer id);</span><br><span class="line"></span><br><span class="line">    @Select(&quot;select * from tbl_book where id=#&#123;id&#125;&quot;)</span><br><span class="line">    void getById(Integer id);</span><br><span class="line"></span><br><span class="line">    @Select(&quot;select * from tbl_book&quot;)</span><br><span class="line">    void getAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写Service接口及其实现类</p><ul><li><p>Service接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">public interface BookService &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 保存</span><br><span class="line">     * @param book</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    boolean save(Book book);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 修改</span><br><span class="line">     * @param book</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    boolean update(Book book);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 按id删除</span><br><span class="line">     * @param id</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    boolean delete(Integer id);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 按id查询</span><br><span class="line">     * @param id</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    Book getById(Integer id);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查询所有</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    List&lt;Book&gt; getAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>BookServiceImpl 实现类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class BookServiceImpl implements BookService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    public boolean save(Book book) &#123;</span><br><span class="line">        bookDao.save(book);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean update(Book book) &#123;</span><br><span class="line">        bookDao.update(book);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean delete(@PathVariable Integer id) &#123;</span><br><span class="line">        bookDao.delete(id);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Book getById(Integer id) &#123;</span><br><span class="line">        return bookDao.getById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;Book&gt; getAll() &#123;</span><br><span class="line">        return bookDao.getAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>编写Controller类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/books&quot;)</span><br><span class="line">public class BookController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private BookService bookService;</span><br><span class="line"></span><br><span class="line">    @PostMapping</span><br><span class="line">    public boolean save(@RequestBody Book book) &#123;</span><br><span class="line">        return bookService.save(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PutMapping</span><br><span class="line">    public boolean update(@RequestBody Book book) &#123;</span><br><span class="line">        return bookService.update(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public boolean delete(@PathVariable Integer id) &#123;</span><br><span class="line">        return bookService.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public Book getById(@PathVariable Integer id) &#123;</span><br><span class="line">        return bookService.getById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping</span><br><span class="line">    public List&lt;Book&gt; getAll() &#123;</span><br><span class="line">        return bookService.getAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><ol><li><p>新建测试类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(classes = SpringConfig.class)</span><br><span class="line">public class BookServiceTest &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注入Service</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(classes = SpringConfig.class)</span><br><span class="line">public class BookServiceTest &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private BookService bookService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写测试方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(classes = SpringConfig.class)</span><br><span class="line">public class BookServiceTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private BookService bookService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testGetById() &#123;</span><br><span class="line">        Book book = bookService.getById(1);</span><br><span class="line">        System.out.println(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testGetAll() &#123;</span><br><span class="line">        for (Book book : bookService.getAll()) &#123;</span><br><span class="line">            System.out.println(book);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试方法，可以查询到对应的数据</p></li></ol><h1 id="统一结果封装"><a href="#统一结果封装" class="headerlink" title="统一结果封装"></a>统一结果封装</h1><h2 id="表现层与前端数据传输协议定义"><a href="#表现层与前端数据传输协议定义" class="headerlink" title="表现层与前端数据传输协议定义"></a>表现层与前端数据传输协议定义</h2><p>SSM整合以及功能模块开发完成后，接下来我们在上述案例的基础上，分析一下有哪些问题需要我们解决。</p><p>在Controller层增删改操作完成后，返回给前端的是boolean类型的数据：true</p><p>在Controller层查询单个，返回给前端的是对象</p><p>在Controller层查询所有，返回给前端的是集合对象</p><p>目前我们就已经有<code>三种数据类型</code>返回给前端了，随着业务的增长，我们需要返回的数据类型就会<code>越来越多</code>。那么前端开发人员在解析数据的时候就比较<code>凌乱</code>了，所以对于前端来说，如果后端能返回一个<code>统一的数据结果</code>，前端在解析的时候就可以按照一种方式进行解析，开发就会变得更加简单</p><p>所以现在我们需要解决的问题就是<code>如何将返回的结果数据进行统一</code>，具体如何来做，大体思路如下</p><ul><li><p>为了封装返回的结果数据：创建结果模型类，封装数据到data属性中</p><blockquote><p>我们可以设置data的数据类型为<code>Object</code>，这样data中就可以放任意的结果类型了，包括但不限于上面的<code>boolean</code>、<code>对象</code>、<code>集合对象</code></p></blockquote></li><li><p>为了封装返回的数据是何种操作，以及是否操作成功：封装操作结果到code属性中</p><blockquote><p>例如增删改操作返回的都是<code>true</code>，那我们怎么分辨这个<code>true</code>到底是<code>增</code>还是<code>删</code>还是<code>改</code>呢？我们就通过这个<code>code</code>来区分</p></blockquote><blockquote><p>操作失败后，需要封装返回错误信息提示给用户：封装特殊消息到message(msg)属性中</p></blockquote><p>例如查询或删除的目标不存在，会返回null，那么此时我们需要提示<code>查询/删除的目标不存在，请重试！</code></p></li></ul><p>那么之前的三种返回方式就可以变为如下形式</p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">boolean</button></li><li class="tab"><button type="button" data-href="#test1-2">对象</button></li><li class="tab"><button type="button" data-href="#test1-3">集合</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p>规则可以自己定<br>这里前三位是固定的<br>第四位表示不同的操作<br>末位表示成功&#x2F;失败，1成功，0失败</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="number">20011</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p>这里的末尾是0，表示失败操作<br>第四位是2，区别于上面的1，表示是不同的操作类型<br>msg给用户提示信息，不是必有项</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="number">20020</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span><span class="string">&quot;数据查询失败，请重试！&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p>这里末尾操作是1，表示成功操作<br>data中显示的是对象集合<br>没有msg</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="number">20031</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;计算机理论&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Spring实战 第5版&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;Spring入门经典教程&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;计算机理论&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Spring 5核心原理与30个类手写实战&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;十年沉淀之作&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>根据分析，我们可以设置统一数据返回结果类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span>&#123;</span><br><span class="line"><span class="keyword">private</span> Object data;</span><br><span class="line"><span class="keyword">private</span> Integer code;</span><br><span class="line"><span class="keyword">private</span> String msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：Result类名及类中的字段并不是固定的，可以根据需要自行增减提供若干个构造方法，方便操作。</p><h2 id="表现层与前端数据传输协议实现"><a href="#表现层与前端数据传输协议实现" class="headerlink" title="表现层与前端数据传输协议实现"></a>表现层与前端数据传输协议实现</h2><p>前面我们已经分析了如何封装返回结果数据，现在我们来具体实现一下</p><p>对于结果封装，我们应该是在表现层进行处理，所以我们把结果类放在controller包下，当然你也可以放在domain包，这个都是可以的，具体如何实现结果封装，具体的步骤如下</p><ol><li><p>创建Result类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public class Result &#123;</span><br><span class="line">    //描述统一格式中的编码，用于区分操作，可以简化配置0或1表示成功失败</span><br><span class="line">    private Integer code;</span><br><span class="line">    //描述统一格式中的数据</span><br><span class="line">    private Object data;</span><br><span class="line">    //描述统一格式中的消息，可选属性</span><br><span class="line">    private String msg;</span><br><span class="line"></span><br><span class="line">    public Result() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //构造器可以根据自己的需要来编写</span><br><span class="line">    public Result(Integer code, Object data) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Result(Integer code, Object data, String msg) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">        this.data = data;</span><br><span class="line">        this.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getCode() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCode(Integer code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object getData() &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Object data) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getMsg() &#123;</span><br><span class="line">        return msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMsg(String msg) &#123;</span><br><span class="line">        this.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Result&#123;&quot; +</span><br><span class="line">                &quot;code=&quot; + code +</span><br><span class="line">                &quot;, data=&quot; + data +</span><br><span class="line">                &quot;, msg=&#x27;&quot; + msg + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>定义返回码Code类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Code &#123;</span><br><span class="line">    public static final Integer SAVE_OK = 20011;</span><br><span class="line">    public static final Integer UPDATE_OK = 20021;</span><br><span class="line">    public static final Integer DELETE_OK = 20031;</span><br><span class="line">    public static final Integer GET_OK = 20041;</span><br><span class="line">    </span><br><span class="line">    public static final Integer SAVE_ERR = 20010;</span><br><span class="line">    public static final Integer UPDATE_ERR = 20020;</span><br><span class="line">    public static final Integer DELETE_ERR = 20030;</span><br><span class="line">    public static final Integer GET_ERR = 20040;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：code类中的常量设计也不是固定的，可以根据需要自行增减，例如将查询再进行细分为<code>GET_OK</code>，<code>GET_ALL_OK</code>，<code>GET_PAGE_OK</code>等。</p></li><li><p>修改Controller类的返回值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/books&quot;)</span><br><span class="line">public class BookController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private BookService bookService;</span><br><span class="line"></span><br><span class="line">    @PostMapping</span><br><span class="line">    public Result save(@RequestBody Book book) &#123;</span><br><span class="line">        boolean flag = bookService.save(book);</span><br><span class="line">        return new Result(flag ? Code.SAVE_OK : Code.SAVE_ERR, flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PutMapping</span><br><span class="line">    public Result update(@RequestBody Book book) &#123;</span><br><span class="line">        boolean flag = bookService.update(book);</span><br><span class="line">        return new Result(flag ? Code.UPDATE_OK : Code.UPDATE_ERR, flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public Result delete(@PathVariable Integer id) &#123;</span><br><span class="line">        boolean flag = bookService.delete(id);</span><br><span class="line">        return new Result(flag ? Code.DELETE_OK : Code.DELETE_ERR, flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public Result getById(@PathVariable Integer id) &#123;</span><br><span class="line">        Book book = bookService.getById(id);</span><br><span class="line">        Integer code = book == null ? Code.GET_ERR : Code.GET_OK;</span><br><span class="line">        String msg = book == null ? &quot;数据查询失败，请重试！&quot; : &quot;&quot;;</span><br><span class="line">        return new Result(code, book, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping</span><br><span class="line">    public Result getAll() &#123;</span><br><span class="line">        List&lt;Book&gt; bookList = bookService.getAll();</span><br><span class="line">        Integer code = bookList == null ? Code.GET_ERR : Code.GET_OK;</span><br><span class="line">        String msg = bookList == null ? &quot;数据查询失败，请重试！&quot; : &quot;&quot;;</span><br><span class="line">        return new Result(code, bookList, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动服务测试<br>五个方法的测试结果如下</p><div class="tabs" id=""><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#-1">save</button></li><li class="tab"><button type="button" data-href="#-2">update</button></li><li class="tab"><button type="button" data-href="#-3">delete</button></li><li class="tab"><button type="button" data-href="#-4">getById</button></li><li class="tab"><button type="button" data-href="#-5">getAll</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 20011,</span><br><span class="line">    &quot;data&quot;: true,</span><br><span class="line">    &quot;msg&quot;: null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 20021,</span><br><span class="line">    &quot;data&quot;: true,</span><br><span class="line">    &quot;msg&quot;: null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-3"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 20031,</span><br><span class="line">    &quot;data&quot;: true,</span><br><span class="line">    &quot;msg&quot;: null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-4"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 20041,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;id&quot;: 1,</span><br><span class="line">        &quot;type&quot;: &quot;计算机理论&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;Spring实战 第五版&quot;,</span><br><span class="line">        &quot;description&quot;: &quot;Spring入门经典教程，深入理解Spring原理技术内幕&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;msg&quot;: &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-5"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 20041,</span><br><span class="line">    &quot;data&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 1,</span><br><span class="line">            &quot;type&quot;: &quot;计算机理论&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;Spring实战 第五版&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;Spring入门经典教程，深入理解Spring原理技术内幕&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 2,</span><br><span class="line">            &quot;type&quot;: &quot;计算机理论&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;Spring 5核心原理与30个类手写实践&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;十年沉淀之作，手写Spring精华思想&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 3,</span><br><span class="line">            &quot;type&quot;: &quot;计算机理论&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;Spring 5设计模式&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;深入Spring源码刨析Spring源码中蕴含的10大设计模式&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 4,</span><br><span class="line">            &quot;type&quot;: &quot;计算机理论&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;Spring MVC+Mybatis开发从入门到项目实战&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;全方位解析面向Web应用的轻量级框架，带你成为Spring MVC开发高手&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 5,</span><br><span class="line">            &quot;type&quot;: &quot;计算机理论&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;轻量级Java Web企业应用实战&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;源码级刨析Spring框架，适合已掌握Java基础的读者&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 6,</span><br><span class="line">            &quot;type&quot;: &quot;计算机理论&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;Java核心技术 卷Ⅰ 基础知识(原书第11版)&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;Core Java第11版，Jolt大奖获奖作品，针对Java SE9、10、11全面更新&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 7,</span><br><span class="line">            &quot;type&quot;: &quot;计算机理论&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;深入理解Java虚拟机&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;5个纬度全面刨析JVM,大厂面试知识点全覆盖&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 8,</span><br><span class="line">            &quot;type&quot;: &quot;计算机理论&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;Java编程思想(第4版)&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;Java学习必读经典，殿堂级著作！赢得了全球程序员的广泛赞誉&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 9,</span><br><span class="line">            &quot;type&quot;: &quot;计算机理论&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;零基础学Java(全彩版)&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;零基础自学编程的入门图书，由浅入深，详解Java语言的编程思想和核心技术&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 10,</span><br><span class="line">            &quot;type&quot;: &quot;市场营销&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;直播就这么做:主播高效沟通实战指南&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;李子柒、李佳奇、薇娅成长为网红的秘密都在书中&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 11,</span><br><span class="line">            &quot;type&quot;: &quot;市场营销&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;直播销讲实战一本通&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;和秋叶一起学系列网络营销书籍&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 12,</span><br><span class="line">            &quot;type&quot;: &quot;市场营销&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;直播带货:淘宝、天猫直播从新手到高手&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;一本教你如何玩转直播的书，10堂课轻松实现带货月入3W+&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 14,</span><br><span class="line">            &quot;type&quot;: &quot;类别测试数据&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;书名测试数据9527&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;描述测试数据&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 15,</span><br><span class="line">            &quot;type&quot;: &quot;类别测试数据&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;书名测试数据&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;描述测试数据&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 16,</span><br><span class="line">            &quot;type&quot;: &quot;类别测试数据&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;书名测试数据&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;描述测试数据&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;msg&quot;: &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></li></ol><h1 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h1><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>先人为弄一个异常出来</p><p>修改<code>BookController</code>的<code>getById()</code>方法，手写一个异常</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">public Result getById(@PathVariable Integer id) &#123;</span><br><span class="line">    //当id为1的时候，手动添加了一个错误信息</span><br><span class="line">    if (id == 1)&#123;</span><br><span class="line">        int a = 1 / 0;</span><br><span class="line">    &#125;</span><br><span class="line">    Book book = bookService.getById(id);</span><br><span class="line">    Integer code = book == null ? Code.GET_ERR : Code.GET_OK;</span><br><span class="line">    String msg = book == null ? &quot;数据查询失败，请重试！&quot; : &quot;&quot;;</span><br><span class="line">    return new Result(code, book, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新启动服务器，使用<code>PostMan</code>发送请求，当传入的<code>id为1</code>时，会出现如下效果</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310201941126.png"></p><p>前端接收到这个信息后，和我们之前约定的格式不一致，怎么解决呢？</p><h2 id="异常的种类"><a href="#异常的种类" class="headerlink" title="异常的种类"></a>异常的种类</h2><p>在解决问题之前，我们先来看一下异常的种类，以及出现异常的原因：</p><ul><li>框架内部抛出的异常：因<code>使用不合规</code>导致</li><li>数据层抛出的异常：因使用<code>外部服务器故障</code>导致（例如：服务器访问超时）</li><li>业务层抛出的异常：因<code>业务逻辑书写错误</code>导致（例如：遍历业务书写操作，导致索引越界异常等）</li><li>表现层抛出的异常：因<code>数据收集</code>、<code>校验</code>等规则导致（例如：不匹配的数据类型间转换导致异常）</li><li>工具类抛出的异常：因工具类<code>书写不严谨</code>，<code>健壮性不足</code>导致（例如：必要时放的连接，长时间未释放等）</li></ul><p>了解完上面这些出现<code>异常的位置</code>，我们发现，在我们开发的<code>任何一个位置</code>都可能会出现异常，而且这些异常是<code>不能避免的</code>，所以我们就需要对这些异常来<code>进行处理</code>。</p><ol><li>各个层级均出现异常，那么异常处理代码要写在哪一层？<ul><li>所有的异常均抛出到表现层进行处理</li></ul></li><li>异常的种类很多，表现层如何将所有的异常都处理到呢？<ul><li>异常分类</li></ul></li><li>表现层处理异常，每个方法中单独书写，代码书写两巨大，且意义不强，如何解决呢？<ul><li>AOP</li></ul></li></ol><p>对于上面这些问题以及解决方案，SpringMVC已经为我们提供了一套了：<strong>异常处理器</strong></p><p>异常处理器：集中的、统一的处理项目中出现的异常</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RestControllerAdvice</span><br><span class="line">public class ProjectExceptionAdvice &#123;</span><br><span class="line">    @ExceptionHandler(Exception.class)</span><br><span class="line">    public Result doException(Exception ex) &#123;</span><br><span class="line">        return new Result(666, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常处理器的使用"><a href="#异常处理器的使用" class="headerlink" title="异常处理器的使用"></a>异常处理器的使用</h2><ol><li><p>创建异常处理器类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RestControllerAdvice</span><br><span class="line">public class ProjectExceptionAdvice &#123;</span><br><span class="line">    @ExceptionHandler(Exception.class)</span><br><span class="line">    public void doException(Exception ex) &#123;</span><br><span class="line">        System.out.println(&quot;嘿嘿，逮到一个异常~&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：要确保SpringMvcConfig能够扫描到异常处理器类，之前放controller包里面就顺带一起扫了</p></li><li><p>让程序抛出异常</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">public Result getById(@PathVariable Integer id) &#123;</span><br><span class="line">    //当id为1的时候，手动添加了一个错误信息</span><br><span class="line">    if (id == 1)&#123;</span><br><span class="line">        int a = 1 / 0;</span><br><span class="line">    &#125;</span><br><span class="line">    Book book = bookService.getById(id);</span><br><span class="line">    Integer code = book == null ? Code.GET_ERR : Code.GET_OK;</span><br><span class="line">    String msg = book == null ? &quot;数据查询失败，请重试！&quot; : &quot;&quot;;</span><br><span class="line">    return new Result(code, book, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>PostMan</code>发送<code>GET</code>请求访问<code>localhost:8080/books/1</code><br>控制台输出如下，说明异常已经被拦截，且执行了<code>doException()</code>方法</p><p>但是现在没有返回数据给前端，为了统一返回结果，我们继续修改异常处理器类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@RestControllerAdvice</span><br><span class="line">public class ProjectExceptionAdvice &#123;</span><br><span class="line">    @ExceptionHandler(Exception.class)</span><br><span class="line">    public Result doException(Exception ex) &#123;</span><br><span class="line">        System.out.println(&quot;有一个异常&quot;);</span><br><span class="line">        return new Result(666, null, &quot;有一个异常&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启服务器，使用PostMan发送请求，此时就能接收到结果了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 666,</span><br><span class="line">    &quot;data&quot;: null,</span><br><span class="line">    &quot;msg&quot;: &quot;有一个异常&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>知识点：<code>@RestControllerAdvice</code></p><p>说明：此注解自带<code>@ResponseBody</code>注解与<code>@Component</code>注解，具备对应的功能</p><table><thead><tr><th align="center">名称</th><th align="center">@RestControllerAdvice</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">类注解</td></tr><tr><td align="center">位置</td><td align="center">Rest风格开发的控制器增强类定义上方</td></tr><tr><td align="center">作用</td><td align="center">为Rest风格开发的控制器类做增强</td></tr></tbody></table><p>知识点：<code>@ExceptionHandler</code></p><p>说明：此类方法可以根据处理的异常不同，制作多个方法分别处理对应的异常</p><table><thead><tr><th align="center">名称</th><th align="center">@ExceptionHandler</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">方法注解</td></tr><tr><td align="center">位置</td><td align="center">专用于异常处理的控制器方法上方</td></tr><tr><td align="center">作用</td><td align="center">设置指定异常的处理方案，功能等同于控制器方法， 出现异常后终止原始控制器执行,并转入当前方法执行</td></tr></tbody></table><h2 id="项目异常处理方案"><a href="#项目异常处理方案" class="headerlink" title="项目异常处理方案"></a>项目异常处理方案</h2><p>异常处理器我们已经能够使用了，那么我们如何在项目中来处理异常呢?</p><h3 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h3><p>因为异常的种类有很多，如果每一个异常都对应一个<code>@ExceptionHandler</code>，那得写多少个方法来处理各自的异常，所以我们在处理异常之前，需要对异常进行一个分类:</p><p>将异常分类以后，针对不同类型的异常，要提供具体的解决方案</p><div class="tabs" id=""><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#-1">业务异常</button></li><li class="tab"><button type="button" data-href="#-2">业务异常</button></li><li class="tab"><button type="button" data-href="#-3">其他异常</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="-1"><p>规范的用户行为产生的异常</p><ul><li>用户在页面输入内容的时候未按照指定格式进行数据填写，如在年龄框输入的是字符串</li></ul><p>不规范的用户行为操作产生的异常</p><ul><li>如用户手改URL，故意传递错误数据<code>localhost:8080/books/略略略</code></li></ul><p>异常解决方案</p><ul><li>发送对应消息传递给用户，提醒规范操作<ul><li>大家常见的就是提示用户名已存在或密码格式不正确等</li></ul></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-2"><p>项目运行过程中可预计，但无法避免的异常</p><ul><li>如服务器宕机</li></ul><p>异常解决方案</p><ul><li>发送固定消息传递给用户，安抚用户<ul><li>系统繁忙，请稍后再试</li><li>系统正在维护升级，请稍后再试</li><li>系统出问题，请联系系统管理员等</li></ul></li><li>发送特定消息给运维人员，提醒维护<ul><li>可以发送短信、邮箱或者是公司内部通信软件</li></ul></li><li>记录日志<ul><li>发消息给运维和记录日志对用户来说是不可见的，属于后台程序</li></ul></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-3"><p>编程人员未预期到的异常</p><ul><li>如：系统找不到指定文件</li></ul><p>异常解决方案</p><ul><li>发送固定消息传递给用户，安抚用户</li><li>发送特定消息给编程人员，提醒维护（纳入预期范围内）<ul><li>一般是程序没有考虑全，比如未做非空校验等</li></ul></li><li>记录日志</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>思路:</p><ol><li>先通过自定义异常，完成BusinessException和SystemException的定义</li><li>将其他异常包装成自定义异常类型</li><li>在异常处理器类中对不同的异常进行处理</li></ol><p>实现：</p><ol><li><p>自定义异常类</p><div class="tabs" id=""><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#-1">SystemException</button></li><li class="tab"><button type="button" data-href="#-2">BusinessException</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class SystemException extends RuntimeException &#123;</span><br><span class="line">    private Integer code;</span><br><span class="line"></span><br><span class="line">    public Integer getCode() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCode(Integer code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SystemException() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SystemException(Integer code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SystemException(Integer code, String message) &#123;</span><br><span class="line">        super(message);</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SystemException(Integer code, String message, Throwable cause) &#123;</span><br><span class="line">        super(message, cause);</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class BusinessException extends RuntimeException&#123;</span><br><span class="line">    private Integer code;</span><br><span class="line"></span><br><span class="line">    public Integer getCode() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCode(Integer code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BusinessException() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BusinessException(Integer code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BusinessException(Integer code, String message) &#123;</span><br><span class="line">        super(message);</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BusinessException(Integer code, String message, Throwable cause) &#123;</span><br><span class="line">        super(message, cause);</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>说明：</p><ul><li>让自定义异常类继承<code>RuntimeException</code>的好处是，后期在抛出这两个异常的时候，就不用在<code>try..catch..</code>或<code>throws</code>了</li><li>自定义异常类中添加<code>code</code>属性的原因是为了更好的区分异常是来自哪个业务的</li></ul></li><li><p>将其他异常包成自定义异常</p><p>假如在<code>BookServiceImpl</code>的<code>getById</code>方法抛异常了，该如何来包装呢?</p><p>具体的包装方式有：</p><ol><li><code>try&#123;&#125;catch()&#123;&#125;</code>在catch中重新throw我们自定义异常即可。</li><li>直接<code>throw</code>自定义异常即可</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public Book getById(Integer id) &#123;</span><br><span class="line">    //模拟业务异常，包装成自定义异常</span><br><span class="line">    if(id == 1)&#123;</span><br><span class="line">        throw new BusinessException(Code.BUSINESS_ERR,&quot;你别给我乱改URL噢&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //模拟系统异常，将可能出现的异常进行包装，转换成自定义异常</span><br><span class="line">    try&#123;</span><br><span class="line">        int i = 1/0;</span><br><span class="line">    &#125;catch (Exception e)&#123;</span><br><span class="line">        throw new SystemException(Code.SYSTEM_TIMEOUT_ERR,&quot;服务器访问超时，请重试!&quot;,e);</span><br><span class="line">    &#125;</span><br><span class="line">    return bookDao.getById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面为了使<code>code</code>看着更专业些，我们在Code类中再新增需要的属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Code &#123;</span><br><span class="line">    public static final Integer SAVE_OK = 20011;</span><br><span class="line">    public static final Integer UPDATE_OK = 20021;</span><br><span class="line">    public static final Integer DELETE_OK = 20031;</span><br><span class="line">    public static final Integer GET_OK = 20041;</span><br><span class="line"></span><br><span class="line">    public static final Integer SAVE_ERR = 20010;</span><br><span class="line">    public static final Integer UPDATE_ERR = 20020;</span><br><span class="line">    public static final Integer DELETE_ERR = 20030;</span><br><span class="line">    public static final Integer GET_ERR = 20040;</span><br><span class="line"></span><br><span class="line">    public static final Integer SYSTEM_ERR = 50001;</span><br><span class="line">    public static final Integer SYSTEM_TIMEOUT_ERR = 50002;</span><br><span class="line">    public static final Integer SYSTEM_UNKNOW_ERR = 59999;</span><br><span class="line"></span><br><span class="line">    public static final Integer BUSINESS_ERR = 60001;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>处理器类中处理自定义异常</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@RestControllerAdvice</span><br><span class="line">public class ProjectExceptionAdvice &#123;</span><br><span class="line">    @ExceptionHandler(SystemException.class)</span><br><span class="line">    public Result doSystemException(SystemException ex) &#123;</span><br><span class="line">        return new Result(ex.getCode(), null, ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ExceptionHandler(BusinessException.class)</span><br><span class="line">    public Result doBusinessException(BusinessException ex) &#123;</span><br><span class="line">        return new Result(ex.getCode(), null, ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ExceptionHandler(Exception.class)</span><br><span class="line">    public Result doException(Exception ex) &#123;</span><br><span class="line">        return new Result(Code.SYSTEM_UNKNOW_ERR, null, &quot;系统繁忙，请稍后再试！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行程序<br>根据ID查询，如果传入的参数为1，会报<code>BusinessException</code></p><p>如果传入的是其他参数，会报<code>SystemException</code>，错误信息应为<code>服务器访问超时，请重试!</code></p><p>那么对于异常我们就已经处理完成了，不管后台哪一层抛出异常，都会以我们与前端约定好的方式进行返回，前端只需要把信息获取到，根据返回的正确与否来展示不同的内容即可。</p></li></ol><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310202001983.png"></p><h1 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h1><h2 id="拦截器概念"><a href="#拦截器概念" class="headerlink" title="拦截器概念"></a>拦截器概念</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310202002007.png"></p><ol><li>浏览器发送一个请求，会先到Tomcat服务器的web服务器</li><li>Tomcat服务器接收到请求后，会先去判断请求的是<code>静态资源</code>还是<code>动态资源</code></li><li>如果是静态资源，会直接到Tomcat的项目部署目录下直接访问</li><li>如果是动态资源，就需要交给项目的后台代码进行处理</li><li>在找到具体的方法之前，我们可以去配置过滤器（可以配置多个），按照顺序进行执行（在这里就可以进行权限校验）</li><li>然后进入到中央处理器（SpringMVC中的内容），SpringMVC会根据配置的规则进行拦截</li><li>如果满足规则，则进行处理，找到其对应的<code>Controller</code>类中的方法进行之星，完成后返回结果</li><li>如果不满足规则，则不进行处理</li><li>这个时候，如果我们需要在每个Controller方法执行的前后添加业务，具体该如何来实现？<ul><li>这个就是拦截器要做的事</li></ul></li></ol><p>拦截器（Interceptor）是一种动态拦截方法调用的机制，在SpringMVC中动态拦截控制器方法的</p><ul><li><p>作用：</p><ul><li><p>在指定的方法调用前后执行预先设定的代码</p></li><li><p>阻止原始方法的执行</p></li><li><p><code>总结：</code>拦截器就是用来作增强</p></li></ul></li><li><p>但是这个拦截器貌似跟我们之前学的过滤器很像啊，不管是从作用上来看还是从执行顺序上来看</p><ul><li>那么拦截器和过滤器之间的区别是什么呢？<ul><li><code>归属不同：</code>Filter属于Servlet技术，而Interceptor属于SpringMVC技术</li><li><code>拦截内容不同：</code>Filter对所有访问进行增强，Interceptor仅对SpringMVC的访问进行增强</li></ul></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310202003631.png"></p><h2 id="拦截器入门案例"><a href="#拦截器入门案例" class="headerlink" title="拦截器入门案例"></a>拦截器入门案例</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ol><li><p>创建一个Web的Maven项目</p></li><li><p>导入坐标</p><p>SpringMvcConfig</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.blog.controller&quot;)</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class SpringMvcConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServletContainersInitConfig</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer &#123;</span><br><span class="line"></span><br><span class="line">    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        return new Class[0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        return new Class[]&#123;SpringMvcConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected String[] getServletMappings() &#123;</span><br><span class="line">        return new String[]&#123;&quot;/&quot;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Filter[] getServletFilters() &#123;</span><br><span class="line">        CharacterEncodingFilter filter = new CharacterEncodingFilter();</span><br><span class="line">        filter.setEncoding(&quot;utf-8&quot;);</span><br><span class="line">        return new Filter[]&#123;filter&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写Controller类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/books&quot;)</span><br><span class="line">public class BookController &#123;</span><br><span class="line"></span><br><span class="line">    @PostMapping</span><br><span class="line">    public String save(@RequestBody Book book)&#123;</span><br><span class="line">        System.out.println(&quot;book save ..&quot; + book);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;book save&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public String delete(@PathVariable Integer id)&#123;</span><br><span class="line">        System.out.println(&quot;book delete ..&quot; + id);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;book delete&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PutMapping</span><br><span class="line">    public String update(@RequestBody Book book)&#123;</span><br><span class="line">        System.out.println(&quot;book update ..&quot; + book);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;book update&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public String getById(@PathVariable Integer id)&#123;</span><br><span class="line">        System.out.println(&quot;book getById ..&quot; + id);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;book getById&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping</span><br><span class="line">    public String getAll()&#123;</span><br><span class="line">        System.out.println(&quot;book getAll ..&quot;);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;book getAll&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用PostMan测试，没有问题的话就可以继续往下看了</p></li></ol><h2 id="拦截器开发"><a href="#拦截器开发" class="headerlink" title="拦截器开发"></a>拦截器开发</h2><ol><li><p>创建拦截器类<br>在<code>com.blog.controller.interceptor</code>下创建<code>ProjectInterceptor</code>类，实现<code>HandlerInterceptor</code>接口，并重写其中的三个方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">//注意当前类必须受Spring容器控制</span><br><span class="line">public class ProjectInterceptor implements HandlerInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    //原始方法调用前执行的内容</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;preHandle&quot;);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //原始方法调用后执行的内容</span><br><span class="line">    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;postHandle&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //原始方法调用完成后执行的内容</span><br><span class="line">    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;afterCompletion&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置拦截器类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class SpringMvcSupport extends WebMvcConfigurationSupport &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ProjectInterceptor projectInterceptor;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">        registry.addResourceHandler(&quot;/pages/**&quot;).addResourceLocations(&quot;/pages/&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        //配置拦截器,拦截路径是/books，只会拦截/books，拦截不到/books/1</span><br><span class="line">        registry.addInterceptor(projectInterceptor).addPathPatterns(&quot;/books&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>SpringMvc添加SpringMvcSupport包扫描</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&#123;&quot;com.blog.controller&quot;, &quot;com.blog.config&quot;&#125;)</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class SpringMvcConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行程序测试</p><p>使用PostMan发送请求给<code>localhost:8080/books</code>，控制台输出如下，说明已经成功拦截</p><blockquote><p>preHandle<br>book update …Book{书名&#x3D;‘书名测试数据9527’, 价格&#x3D;0.0}<br>postHandle<br>afterCompletion</p></blockquote><p>使用PostMan发送请求给<code>localhost:8080/books/9527</code>，控制台输出如下，说明没有拦截，若想拦截，则继续修改拦截器的拦截规则</p><blockquote><p>book getById …9527</p></blockquote></li><li><p>修改拦截器拦截规则</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SpringMvcSupport extends WebMvcConfigurationSupport &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ProjectInterceptor projectInterceptor;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">        registry.addResourceHandler(&quot;/pages/**&quot;).addResourceLocations(&quot;/pages/&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        //配置拦截器，查看源码发现，参数是个可变形参，可以设置任意多个拦截路径</span><br><span class="line">        registry.addInterceptor(projectInterceptor).addPathPatterns(&quot;/books&quot;,&quot;/books/*&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们再次使用PostMan发送请求给<code>localhost:8080/books/9527</code>，控制台输出如下，说明已经成功拦截</p><blockquote><p>preHandle<br>book getById …9527<br>postHandle<br>afterCompletion</p></blockquote><p><strong>就是拦截器中的<code>preHandler</code>方法，如果返回true，则代表放行，会执行原始<code>Controller</code>类中要请求的方法，如果返回<code>false</code>，则代表拦截，后面的就不会再执行了。</strong> </p></li><li><p>简化SpringMvcSupport的编写</p><p>我们可以让<code>SpringMvcConfig</code>类实现<code>WebMvcConfigurer</code>接口，然后直接在<code>SpringMvcConfig</code>中写<code>SpringMvcSupport</code>的东西，这样我们就不用再写<code>SpringMvcSupport</code>类了，全都在<code>SpringMvcConfig</code>中写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.blog.controller&quot;)</span><br><span class="line">@EnableWebMvc</span><br><span class="line">//实现WebMvcConfigurer接口可以简化开发，但具有一定的侵入性</span><br><span class="line">public class SpringMvcConfig implements WebMvcConfigurer &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ProjectInterceptor projectInterceptor;</span><br><span class="line"></span><br><span class="line">    public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">        //对静态资源放行</span><br><span class="line">        registry.addResourceHandler(&quot;/pages/**&quot;).addResourceLocations(&quot;/pages/&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        //配置拦截器</span><br><span class="line">        registry.addInterceptor(projectInterceptor).addPathPatterns(&quot;/books&quot;, &quot;/books/*&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="拦截器的执行流程"><a href="#拦截器的执行流程" class="headerlink" title="拦截器的执行流程"></a>拦截器的执行流程</h3><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310202024542.png"></p><p>当有拦截器后，请求会先进入preHandle方法</p><ul><li>如果方法返回<code>true</code>，则放行继续执行后面的handle(Controller的方法)和后面的方法</li><li>如果返回<code>false</code>，则直接跳过后面方法的执行。</li></ul><h2 id="拦截器参数"><a href="#拦截器参数" class="headerlink" title="拦截器参数"></a>拦截器参数</h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>原始方法之前运行preHandle</p><div class="tabs" id=""><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#-1">前置处理方法</button></li><li class="tab"><button type="button" data-href="#-2">后置处理方法</button></li><li class="tab"><button type="button" data-href="#-3">完成处理方法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="-1"><p>原始方法之前运行preHandle</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">    System.out.println(&quot;preHandle&quot;);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>request:</code>请求对象</li><li><code>response:</code>响应对象</li><li><code>handler:</code>被调用的处理器对象，本质上是一个方法对象，对反射中的Method对象进行了再包装</li></ul><p>使用request对象可以获取请求数据中的内容，如获取请求头的<code>Content-Type</code>，成功输出了Content-Type<code>application/json</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">    String name = request.getHeader(&quot;Content-Type&quot;);</span><br><span class="line">    System.out.println(&quot;preHandle..&quot; + name);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用handler参数，可以获取方法的相关信息，成功输出了方法名<code>save</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">    HandlerMethod handlerMethod = (HandlerMethod) handler;</span><br><span class="line">    String methodName = handlerMethod.getMethod().getName();</span><br><span class="line">    System.out.println(&quot;preHandle..&quot; + methodName);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-2"><p>原始方法运行后运行，如果原始方法被拦截，则不执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//原始方法调用后执行的内容</span><br><span class="line">public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;</span><br><span class="line">    System.out.println(&quot;postHandle&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前三个参数和上面的是一致的。<br><code>modelAndView:</code>如果处理器执行完成具有返回结果，可以读取到对应数据与页面信息，并进行调整<br>因为我们现在都是返回json数据，所以该参数的使用率不高。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-3"><p>拦截器最后执行的方法，无论原始方法是否执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//原始方法调用完成后执行的内容</span><br><span class="line">public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;</span><br><span class="line">    System.out.println(&quot;afterCompletion&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前三个参数与上面的是一致的。但是有第四个参数ex</p><p>ex：如果处理器执行过程中出现异常对象，可以针对异常情况进行单独处理</p><p>因为我们现在已经有全局异常处理器类，所以该参数的使用率也不高。</p><p>这三个方法中，最常用的是<code>preHandle</code>，在这个方法中可以通过返回值来决定是否要进行放行，我们可以把业务逻辑放在该方法中，如果满足业务则返回<code>true</code>放行，不满足则返回<code>false</code>拦截。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="拦截器链配置"><a href="#拦截器链配置" class="headerlink" title="拦截器链配置"></a>拦截器链配置</h2><p>目前，我们在项目中只添加了一个拦截器，如果有多个，该如何配置?配置多个后，执行顺序是什么?</p><ul><li>当配置多个拦截器时，形成拦截器链</li><li>拦截器链的运行顺序参照拦截器添加顺序为准</li><li>当拦截器中出现对原始处理器的拦截，后面的拦截器均终止运行</li><li>当拦截器运行中断，仅运行配置在前面的拦截器的afterCompletion操作</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310202029609.png"></p><ul><li><code>preHandle：</code>与配置顺序相同，必定运行</li><li><code>postHandle:</code>与配置顺序相反，可能不运行</li><li><code>afterCompletion:</code>与配置顺序相反，可能不运行。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot</title>
      <link href="/2023/10/25/SpringBoot/"/>
      <url>/2023/10/25/SpringBoot/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot简介"><a href="#SpringBoot简介" class="headerlink" title="SpringBoot简介"></a>SpringBoot简介</h1><p>SpringBoot是由Pivotal团队提供的全新框架，其设计目的是用来 简化 Spring应用的 初始搭建 以及 开发过程 。<br>使用了Spring框架后已经简化了我们的开发，而SpringBoot又是对Spring开发进行简化的，可想而知SpringBoot使用的简单及广泛性。<br>既然SpringBoot是用来简化Spring开发的，那我们就先回顾一下，以SpringMVC开发为例</p><p>一共四步：加依赖、配置web、配置spring、编写controller</p><ol><li><p>创建一个maven工程，并在pom.xml中导入所需依赖的坐标</p><pre><code>&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;        &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;    &lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;    &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;    &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;    &lt;version&gt;3.5.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;    &lt;version&gt;1.3.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;5.1.46&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid&lt;/artifactId&gt;    &lt;version&gt;1.1.16&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;junit&lt;/groupId&gt;    &lt;artifactId&gt;junit&lt;/artifactId&gt;    &lt;version&gt;4.12&lt;/version&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;    &lt;version&gt;3.1.0&lt;/version&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;    &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;/dependencies&gt;</code></pre></li><li><p>编写web3.0的配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer &#123;</span><br><span class="line">    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        return new Class[]&#123;SpringConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        return new Class[]&#123;SpringMvcConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected String[] getServletMappings() &#123;</span><br><span class="line">        return new String[]&#123;&quot;/&quot;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Filter[] getServletFilters() &#123;</span><br><span class="line">        CharacterEncodingFilter filter = new CharacterEncodingFilter();</span><br><span class="line">        filter.setEncoding(&quot;utf-8&quot;);</span><br><span class="line">        return new Filter[]&#123;filter&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写SpringMvc配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.blog.controller&quot;)</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class SpringMvcConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写Controller类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/books&quot;)</span><br><span class="line">public class BookController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private BookService bookService;</span><br><span class="line"></span><br><span class="line">    @PostMapping</span><br><span class="line">    public boolean save(@RequestBody Book book) &#123;</span><br><span class="line">        return bookService.save(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PutMapping</span><br><span class="line">    public boolean update(@RequestBody Book book) &#123;</span><br><span class="line">        return bookService.update(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public boolean delete(@PathVariable Integer id) &#123;</span><br><span class="line">        return bookService.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public Book getById(@PathVariable Integer id) &#123;</span><br><span class="line">        return bookService.getById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping</span><br><span class="line">    public List&lt;Book&gt; getAll() &#123;</span><br><span class="line">        return bookService.getAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>从上面的 SpringMVC 程序开发可以看到，前三步都是在搭建环境，而且这三步基本都是固定的。SpringBoot 就是对这三步进行简化了。接下来我们通过一个入门案例来体现 SpingBoot 简化 Spring 开发。</p><h2 id="SpringBoot快速入门"><a href="#SpringBoot快速入门" class="headerlink" title="SpringBoot快速入门"></a>SpringBoot快速入门</h2><h3 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h3><p>SpringBoot 开发起来特别简单，分为如下几步：</p><ul><li>创建新模块，选择Spring初始化，并配置模块相关基础信息</li><li>选择当前模块需要使用的技术集</li><li>开发控制器类</li><li>运行自动生成的Application类<br>知道了 SpringBoot 的开发步骤后，下面我们进行具体的操作</li></ul><p>实现：</p><ul><li>步骤一： 创建新模块<br>  在IDEA下创建一个新模块，选择Spring Initializr，用来创建SpringBoot工程</li></ul><p>  选中 Web，然后勾选 Spring Web，由于我们需要开发一个  web  程序，使用到了  SpringMVC  技术，所以按照下图红框进行勾选</p><p>  最后点击创建，就大功告成了，经过以上步骤后就创建了如下结构的模块，它会帮我们自动生成一个 Application 类，而该类一会再启动服务器时会用到</p><p>  注意：</p><ol><li><strong>编写项目的时候不要配置Artifact，这里只需要group的名字</strong></li><li>在创建好的工程中不需要创建配置类</li><li>创建好的项目会自动生成其他的一些文件，而这些文件目前对我们来说没有任何作用，所以可以将这些文件删除。</li><li>可以删除的目录和文件如下：<ul><li>.mvn </li><li>.gitignore </li><li>HELP.md </li><li>mvnw </li><li>mvnw.cmd</li></ul></li></ol><ul><li>步骤二： 创建Controller（除了controller，其余配置都被简化了）<br>  在 com.blog.controller 包下创建BookController，代码如下</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/books&quot;)</span><br><span class="line">public class BookController &#123;</span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public String getById(@PathVariable Integer id) &#123;</span><br><span class="line">        System.out.println(&quot;get id ==&gt; &quot; + id);</span><br><span class="line">        return &quot;hello,spring boot!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>步骤三： 启动服务器<br>  运行  SpringBoot  工程不需要使用本地的  Tomcat  和 插件，只运行项目  com.blog  包下的  Application  类，我们就可以在控制台看出如下信息</li></ul><p>  springboot自带一个java类，这个类就是运行类</p><ul><li>步骤四： 进行测试<br>  依旧是使用PostMan来测试，发送GET请求访问 localhost:8080&#x2F;books&#x2F;9527<br>  可以看到响应回来的结果 hello,spring boot!<br>  同时控制台也输出了 get id &#x3D;&#x3D;&gt; 9527</li></ul><blockquote><p><strong>总结：springboot项目创建也是四步，但是只有controller需要自己实现，其余都自动实现了</strong></p></blockquote><p>通过上面的入门案例我们可以看到使用  SpringBoot  进行开发，使整个开发变得很简单，那它是如何做到的呢？</p><ul><li><p>要研究这个问题，我们需要看看  Application  类和  pom.xml  都书写了什么。先看看  Applicaion  类，该类内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类中的东西很简单，就在类上添加了一个  @SpringBootApplication  注解，而在主方法中就一行代码。我们在启动服务器时就是执行的该类中的主方法。</p></li><li><p>再看看  pom.xml  配置文件中的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;!--指定了一个父工程，父工程中的东西在该工程中可以继承过来使用--&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.7.3&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springboot_01_quickstart&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!--JDK 的版本--&gt;</span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--该依赖就是我们在创建 SpringBoot 工程勾选的那个 Spring Web 产生的--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--这个是单元测试的依赖，我们现在没有进行单元测试，所以这个依赖现在可以没有--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;!--这个插件是在打包时需要的，而这里暂时还没有用到--&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li></ul><p>我们代码之所以能简化，就是因为指定的父工程和  Spring Web  依赖实现的。具体的我们后面在聊。</p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>做完  SpringBoot  的入门案例后，接下来对比一下  Spring  程序和  SpringBoot  程序。</p><table><thead><tr><th align="center">类&#x2F;配置文件</th><th align="center">Spring</th><th align="center">SpringBoot</th></tr></thead><tbody><tr><td align="center">pom文件中的坐标</td><td align="center">手工添加</td><td align="center">勾选添加</td></tr><tr><td align="center">web3.e配置类</td><td align="center">手工制作</td><td align="center">无</td></tr><tr><td align="center">Spring&#x2F;SpringMVC配置类</td><td align="center">手工制作</td><td align="center">无</td></tr><tr><td align="center">控制器</td><td align="center">手工制作</td><td align="center">手工制作</td></tr></tbody></table><ul><li>坐标<br> Spring  程序中的坐标需要自己编写，而且坐标非常多<br> SpringBoot  程序中的坐标是我们在创建工程时进行勾选自动生成的</li><li>web3.0配置类<br> Spring  程序需要自己编写这个配置类。这个配置类我们之前编写过，肯定感觉很复杂<br> SpringBoot  程序不需要我们自己书写</li><li>配置类<br> Spring&#x2F;SpringMVC  程序的配置类需要自己书写。而  SpringBoot  程序则不需要书写。</li></ul><p>注意：基于Idea的  Spring Initializr  快速构建  SpringBoot  工程时需要联网。</p><h2 id="官网构建工程"><a href="#官网构建工程" class="headerlink" title="官网构建工程"></a>官网构建工程</h2><p>在入门案例中之所以能快速构建  SpringBoot  工程，是因为  Idea  使用了官网提供了快速构建  SpringBoot  工程的组件实现的。<br>首先进入SpringBoot官网 <a href="https://spring.io/projects/spring-boot">https://spring.io/projects/spring-boot</a> ，拉到页面最下方，会有一个 Quickstart your project<br>然后点击 Spring Initializr 超链接，就会跳转到如下页面，构建工程的步骤与我们在IDEA中几乎没什么区别</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310241216558.png"></p><p>点击 GENERATE ，就可以生成工程并下载到本地了，打开下载好的压缩包，可以看到工程的内容与IDEA生成的一模一样。<br>通过上面官网的操作，我们知道  Idea  中快速构建  SpringBoot  工程其实就是使用的官网的快速构建组件，那以后即使没有  Idea  也可以使用官网的方式构建  SpringBoot  工程。</p><h2 id="SpringBoot工程快速启动"><a href="#SpringBoot工程快速启动" class="headerlink" title="SpringBoot工程快速启动"></a>SpringBoot工程快速启动</h2><ul><li><p>问题引入<br>以后我们和前端开发人员协同开发，而前端开发人员需要测试前端程序就需要后端开启服务器，这就受制于后端开发人员。为了摆脱这个受制，前端开发人员尝试着在自己电脑上安装  Tomcat  和  Idea  ，在自己电脑上启动后端程序，这显然不现实。<br>我们后端可以将  SpringBoot  工程打成  jar  包，该  jar  包运行不依赖于  Tomcat  和  Idea  这些工具也可以正常运行，只是这个  jar  包在运行过程中连接和我们自己程序相同的  Mysql  数据库即可，这样就可以解决这个问题。</p></li><li><p>那现在问题就是如何打包<br>由于我们在构建  SpringBoot  工程时已经在  pom.xml  中配置了如下插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure></li></ul><p>所以我们只需要使用  Maven  的  package  指令打包就会在  target  目录下生成对应的  Jar  包。</p><blockquote><p>注意：该插件必须配置，不然打好的  jar  包也是有问题的。</p></blockquote><ul><li><p>快速启动<br>进入  jar  包所在位置，在  命令提示符  中输入如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar springboot_01_quickstart-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p>执行上述命令就可以看到  SpringBoot  运行的日志信息，同时使用PostMan发送GET请求访问 localhost:8080&#x2F;books&#x2F;9527 ，也可以正常输出get id &#x3D;&#x3D;&gt; 9527</p></li></ul><blockquote><p>pom中的那个插件就是用来实现快速启动的</p><p>快速打包需要用Maven的package指令进行打包</p><p>虽然能快速启动，但是数据库还是那个数据库，要连到固定数据库上</p></blockquote><h1 id="SpringBoot概述"><a href="#SpringBoot概述" class="headerlink" title="SpringBoot概述"></a>SpringBoot概述</h1><p> SpringBoot  是由Pivotal团队提供的全新框架，其设计目的是用来 简化 Spring应用的 初始搭建 以及 开发过程 。</p><p>原始  Spring  环境搭建和开发存在以下问题</p><ul><li>配置繁琐</li><li>依赖设置繁琐<br> SpringBoot  程序优点恰巧就是针对  Spring  的缺点</li><li>自动配置。这个是用来解决  Spring  程序配置繁琐的问题</li><li>起步依赖。这个是用来解决  Spring  程序依赖设置繁琐的问题</li><li>辅助功能（内置服务器，…）。我们在启动  SpringBoot  程序时既没有使用本地的  tomcat  也没有使用  tomcat  插件，而是使用  SpringBoot  内置的服务器。</li></ul><p>接下来我们来说一下  SpringBoot  的起步依赖</p><h2 id="起步依赖"><a href="#起步依赖" class="headerlink" title="起步依赖"></a>起步依赖</h2><p>我们使用  Spring Initializr  方式创建的  Maven  工程的的  pom.xml  配置文件中自动生成了很多包含  starter  的依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;!--                      ↓↓↓              --&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.7.3&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt; </span><br><span class="line">&lt;/parent&gt;</span><br><span class="line">&lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;springboot_01_quickstart&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;!--                      ↓↓↓              --&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;!--                      ↓↓↓              --&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h3 id="父工程"><a href="#父工程" class="headerlink" title="父工程"></a>父工程</h3><p>从上面的文件中可以看到指定了一个父工程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.7.3&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure><p>进入到父工程，发现父工程中又指定了一个父工程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.7.3&lt;/version&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure><p>进入到<strong>爷工程</strong>中，在该工程中我们可以看到配置内容结构如下</p><div class="tabs" id=""><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#-1">properties</button></li><li class="tab"><button type="button" data-href="#-2">dependencyManagement</button></li><li class="tab"><button type="button" data-href="#-3">plugin</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="-1"><p> properties  标签中定义了各个技术软件依赖的版本，避免了我们在使用不同软件技术时考虑版本的兼容问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;activemq.version&gt;5.16.5&lt;/activemq.version&gt;</span><br><span class="line">&lt;antlr2.version&gt;2.7.7&lt;/antlr2.version&gt;</span><br><span class="line">&lt;appengine-sdk.version&gt;1.9.98&lt;/appengine-sdk.version&gt;</span><br><span class="line">&lt;artemis.version&gt;2.19.1&lt;/artemis.version&gt;</span><br><span class="line">&lt;aspectj.version&gt;1.9.7&lt;/aspectj.version&gt;</span><br><span class="line">&lt;assertj.version&gt;3.22.0&lt;/assertj.version&gt;</span><br><span class="line">&lt;atomikos.version&gt;4.0.6&lt;/atomikos.version&gt;</span><br><span class="line">&lt;awaitility.version&gt;4.2.0&lt;/awaitility.version&gt;</span><br><span class="line">&lt;build-helper-maven-plugin.version&gt;3.3.0&lt;/build-helper-maven-plugin.version&gt;</span><br><span class="line">&lt;byte-buddy.version&gt;1.12.13&lt;/byte-buddy.version&gt;</span><br><span class="line"></span><br><span class="line">···</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-2"><p> dependencyManagement  标签是进行依赖版本锁定，但是并没有导入对应的依赖；如果我们工程需要那个依赖只需要引入依赖的  groupid  和  artifactId  不需要定义  version 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;activemq-amqp&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;activemq.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;activemq-blueprint&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;activemq.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;activemq-broker&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;activemq.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">···</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-3"><p>而  build  标签中也对插件的版本进行了锁定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;build-helper-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;build-helper-maven-plugin.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.flywaydb&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;flyway-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;flyway.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;pl.project13.maven&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;git-commit-id-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;git-commit-id-plugin.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line"></span><br><span class="line">···</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>父工程中指明版本</p><h3 id="starter起步依赖"><a href="#starter起步依赖" class="headerlink" title="starter起步依赖"></a>starter起步依赖</h3><p>工程中的pom.xml中配置了如下依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>进入到该依赖，查看pom.xml的依赖，会发现它引入了如下依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.7.3&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.3.22&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.3.22&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>里面的引入了  spring-web  和  spring-webmvc  的依赖，这就是为什么我们的工程中没有依赖这两个包还能正常使用  springMVC  中的注解的原因。<br>而依赖  spring-boot-starter-tomcat  ，从名字基本能确认内部依赖了  tomcat ，所以我们的工程才能正常启动。<br>结论：以后需要使用技术，只需要引入该技术对应的起步依赖即可</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>starter：</p><ul><li>SpringBoot  中常见项目名称，定义了当前项目使用的所有项目坐标，以达到减少依赖配置的目的</li></ul><p>parent：</p><ul><li>所有  SpringBoot  项目要继承的项目，定义了若干个坐标版本号（依赖管理，而非依赖），以达到减少依赖冲突的目的</li></ul><p>实际开发：</p><ul><li>使用任意坐标时，仅书写GAV中的G和A，V由SpringBoot提供<ul><li>G：groupid</li><li>A：artifactId</li><li>V：version</li></ul></li><li>如发生坐标错误，再指定version（要小心版本冲突）</li></ul><h2 id="程序启动"><a href="#程序启动" class="headerlink" title="程序启动"></a>程序启动</h2><p>创建的每一个  SpringBoot  程序时都包含一个类似于下面的类，我们将这个类称作引导类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class Springboot01QuickstartApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Springboot01QuickstartApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>SpringBoot  在创建项目时，采用jar的打包方式</li><li>SpringBoot  的引导类是项目的入口，运行  main  方法就可以启动项目<br>  因为我们在  pom.xml  中配置了  spring-boot-starter-web  依赖，而该依赖通过前面的学习知道它依赖  tomcat  ，所以运行  main  方法就可以使用  tomcat  启动咱们的工程。</li></ul><h2 id="切换web服务器"><a href="#切换web服务器" class="headerlink" title="切换web服务器"></a>切换web服务器</h2><p>现在我们启动工程使用的是  tomcat  服务器，那能不能不使用  tomcat  而使用  jetty  服务器。而要切换  web  服务器就需要将默认的  tomcat  服务器给排除掉，怎么排除呢？需要用到我们前面学的知识 排除依赖 ，使用  exclusion  标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>然后还要引入  jetty  服务器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;xxxxxxxxxx &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;&lt;/dependency&gt;XML</span><br></pre></td></tr></table></figure><p>接下来再次运行引导类，在日志信息中就可以看到使用的是jetty服务器</p><blockquote><p>通过切换服务器，我们不难发现在使用  SpringBoot  换技术时只需要导入该技术的 起步依赖 即可。</p></blockquote><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><h2 id="配置文件格式"><a href="#配置文件格式" class="headerlink" title="配置文件格式"></a>配置文件格式</h2><p> SpringBoot  提供了 3 种属性配置方式</p><p>注意： SpringBoot  程序的配置文件名必须是  application  ，只是后缀名不同而已。</p><div class="tabs" id=""><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#-1">application.properties</button></li><li class="tab"><button type="button" data-href="#-2">application.yml</button></li><li class="tab"><button type="button" data-href="#-3">application.yaml</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="-1"><p>配置文件必须放在  resources  目录下，而该目录下有一个名为  application.properties  的配置文件（SpringBoot已经为我们提供好了），我们就可以在该配置文件中修改端口号，在该配置文件中书写  port  ， Idea  就会补全提示</p><p>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=80</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-2"><p>在  resources  下（同级）创建一个名为  application.yml  的配置文件，在该文件中书写端口号的配置项，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 81</span><br></pre></td></tr></table></figure><p>注意： 在 : 后，数据前一定要加空格。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-3"><p>然后在  resources  下创建名为  application.yaml  的配置文件，配置内容和后缀名为  yml  的配置文件中的内容相同，只是使用了不同的后缀名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 82</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>三种配合文件的优先级：</p><p>properties &gt; yml &gt; yaml</p><h2 id="yaml格式"><a href="#yaml格式" class="headerlink" title="yaml格式"></a>yaml格式</h2><p>YAML（YAML Ain’t Markup Language），一种数据序列化格式。这种格式的配置文件在近些年已经占有主导地位，那么这种配置文件和前期使用的配置文件是有一些优势的，我们先看之前使用的配置文件。</p><p>最开始我们使用的是  xml  ，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;enterprise&gt;</span><br><span class="line">    &lt;name&gt;Helsing&lt;/name&gt;</span><br><span class="line">    &lt;age&gt;16&lt;/age&gt;</span><br><span class="line">    &lt;tel&gt;400-957-241&lt;/tel&gt;</span><br><span class="line">&lt;/enterprise&gt;</span><br></pre></td></tr></table></figure><p>而  properties  类型的配置文件如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enterprise.name=Helsing</span><br><span class="line">enterprise.age=16</span><br><span class="line">enterprise.tel=400-957-241</span><br></pre></td></tr></table></figure><p>yaml 类型的配置文件内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enterprise:</span><br><span class="line">  name: Helsing</span><br><span class="line">  age: 16</span><br><span class="line">  tel: 400-957-241</span><br></pre></td></tr></table></figure><p>通过对比，我们得出yaml的优点有：</p><ul><li>容易阅读<ul><li>yaml  类型的配置文件比  xml  类型的配置文件更容易阅读，结构更加清晰</li></ul></li><li>容易与脚本语言交互（暂时还体会不到，后面会了解）</li><li>以数据为核心，重数据轻格式<ul><li>yaml  更注重数据，而  xml  更注重格式</li></ul></li></ul><p>YAML 文件扩展名：</p><ul><li>.yml  (主流)</li><li>.yaml</li></ul><p>上面两种后缀名都可以，以后使用更多的还是  yml  的。</p><h2 id="yml语法规则"><a href="#yml语法规则" class="headerlink" title="yml语法规则"></a>yml语法规则</h2><ul><li><p>大小写敏感</p></li><li><p>属性层级关系使用多行描述，每行结尾使用冒号结束</p></li><li><p>使用缩进表示层级关系，同层级左侧对齐，只允许使用空格（不允许使用Tab键）</p><ul><li>空格的个数并不重要，只要保证同层级的左侧对齐即可。</li></ul></li><li><p><strong>属性值前面添加空格</strong>（属性名与属性值之间使用冒号+空格作为分隔）</p></li><li><p>数组数据在数据书写位置的下方使用减号作为数据开始符号，每行书写一个数据，减号与数据间空格分隔</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enterprise:</span><br><span class="line">  name: Helsing</span><br><span class="line">  age: 16</span><br><span class="line">  tel: 400-957-241</span><br><span class="line">  subject:</span><br><span class="line">    - Java</span><br><span class="line">    - Python</span><br><span class="line">    - C#</span><br></pre></td></tr></table></figure></li></ul><h2 id="yaml配置文件数据读取"><a href="#yaml配置文件数据读取" class="headerlink" title="yaml配置文件数据读取"></a>yaml配置文件数据读取</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ul><li><p>修改 resource 目录下的 application.yml 配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">lesson: SpringBoot</span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line">  port: 80</span><br><span class="line"></span><br><span class="line">enterprise:</span><br><span class="line">  name: Helsing</span><br><span class="line">  age: 16</span><br><span class="line">  tel: 400-957-241</span><br><span class="line">  subject:</span><br><span class="line">    - Java</span><br><span class="line">    - Python</span><br><span class="line">    - C#</span><br></pre></td></tr></table></figure></li><li><p>在 com.blog.domain 包下新建一个Enterprise类，用来封装数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package com.blog.domain;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class Enterprise &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private String tel;</span><br><span class="line">    private String[] subject;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getTel() &#123;</span><br><span class="line">        return tel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTel(String tel) &#123;</span><br><span class="line">        this.tel = tel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String[] getSubject() &#123;</span><br><span class="line">        return subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSubject(String[] subject) &#123;</span><br><span class="line">        this.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Enterprise&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &quot;, tel=&#x27;&quot; + tel + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, subject=&quot; + Arrays.toString(subject) +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="读取配置文件"><a href="#读取配置文件" class="headerlink" title="读取配置文件"></a>读取配置文件</h3><div class="tabs" id=""><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#-1"><i class="Value注解"></i>使用</button></li><li class="tab"><button type="button" data-href="#-2">使用 Environment 对象</button></li><li class="tab"><button type="button" data-href="#-3">使用自定义对象</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="-1"><p>使用  @Value(“表达式”)  注解可以从配合文件中读取数据，注解中用于读取属性名引用方式是： ${一级属性名.二级属性名……} </p><p>我们可以在  BookController  中使用  @Value  注解读取配合文件数据，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/books&quot;)</span><br><span class="line">public class BookController &#123;</span><br><span class="line">    @Value(&quot;$&#123;lesson&#125;&quot;)</span><br><span class="line">    private String lesson;</span><br><span class="line">    @Value(&quot;$&#123;server.port&#125;&quot;)</span><br><span class="line">    private Integer port;</span><br><span class="line">    @Value(&quot;$&#123;enterprise.subject[0]&#125;&quot;)</span><br><span class="line">    private String subject_0;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public String getById(@PathVariable Integer id) &#123;</span><br><span class="line">        System.out.println(lesson);</span><br><span class="line">        System.out.println(port);</span><br><span class="line">        System.out.println(subject_0);</span><br><span class="line">        return &quot;hello , spring boot!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-2"><p>上面方式读取到的数据特别零散， SpringBoot  还可以使用  @Autowired  注解注入  Environment  对象的方式读取数据。这种方式  SpringBoot  会将配置文件中所有的数据封装到  Environment  对象中，如果需要使用哪个数据只需要通过调用  Environment  对象的  getProperty(String name)  方法获取。具体代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/books&quot;)</span><br><span class="line">public class BookController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private Environment environment;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public String getById(@PathVariable Integer id) &#123;</span><br><span class="line">        System.out.println(environment.getProperty(&quot;lesson&quot;));</span><br><span class="line">        System.out.println(environment.getProperty(&quot;enterprise.name&quot;));</span><br><span class="line">        System.out.println(environment.getProperty(&quot;enterprise.subject[1]&quot;));</span><br><span class="line">        return &quot;hello , spring boot!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：这种方式在开发中很少用，因为框架内含大量数据</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-3"><p>SpringBoot还提供了将配置文件中的数据封装到我们自定义的实体类对象中的方式。具体操作如下：</p><ul><li><p>将实体类bean的创建交给Spring管理。</p><ul><li>在类上添加  @Component  注解</li></ul></li><li><p>使用@ConfigurationProperties</p><p> 注解表示加载配置文件</p><ul><li>在该注解中也可以使用  prefix  属性指定只加载指定前缀的数据</li></ul></li><li><p>在  BookController  中进行注入</p></li></ul><p>Enterprise 实体类内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(prefix = &quot;enterprise&quot;)</span><br><span class="line">public class Enterprise &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private String tel;</span><br><span class="line">    private String[] subject;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getTel() &#123;</span><br><span class="line">        return tel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTel(String tel) &#123;</span><br><span class="line">        this.tel = tel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String[] getSubject() &#123;</span><br><span class="line">        return subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSubject(String[] subject) &#123;</span><br><span class="line">        this.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Enterprise&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &quot;, tel=&#x27;&quot; + tel + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, subject=&quot; + Arrays.toString(subject) +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BooKController内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/books&quot;)</span><br><span class="line">public class BookController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private Enterprise enterprise;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public String getById(@PathVariable Integer id) &#123;</span><br><span class="line">        System.out.println(enterprise);</span><br><span class="line">        System.out.println(enterprise.getAge());</span><br><span class="line">        System.out.println(enterprise.getName());</span><br><span class="line">        System.out.println(enterprise.getTel());</span><br><span class="line">        return &quot;hello , spring boot!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h1><p>后在工作中，对于开发环境、测试环境、生产环境的配置肯定都不相同，比如我们开发阶段会在自己的电脑上安装  mysql  ，连接自己电脑上的  mysql  即可，但是项目开发完毕后要上线就需要该配置，将环境的配置改为线上环境的。<br>来回的修改配置会很麻烦，而  SpringBoot  给开发者提供了多环境的快捷配置，需要切换环境时只需要改一个配置即可。不同类型的配置文件多环境开发的配置都不相同，接下来对不同类型的配置文件进行说明</p><h2 id="yaml文件"><a href="#yaml文件" class="headerlink" title="yaml文件"></a>yaml文件</h2><p>在  application.yml  中使用  —  来分割不同的配置，内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">## 开发环境</span><br><span class="line">spring:</span><br><span class="line">  profiles: dev ## 给开发环境取的名</span><br><span class="line">server:</span><br><span class="line">  port: 80</span><br><span class="line">---</span><br><span class="line">## 生产环境</span><br><span class="line">spring:</span><br><span class="line">  profiles: pro ## 给生产环境取的名</span><br><span class="line">server:</span><br><span class="line">  port: 81</span><br><span class="line">---</span><br><span class="line">## 测试环境</span><br><span class="line">spring:</span><br><span class="line">  profiles: test ## 给测试环境起的名</span><br><span class="line">server:</span><br><span class="line">  port: 82</span><br></pre></td></tr></table></figure><p>上面配置中  spring.profiles  是用来给不同的配置起名字的。而如何告知  SpringBoot  使用哪段配置呢？可以使用如下配置来启用都一段配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## 设置启用的环境</span><br><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev  ## 表示使用的是开发环境的配置</span><br></pre></td></tr></table></figure><p>整合：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br><span class="line">---</span><br><span class="line">## 开发环境</span><br><span class="line">spring:</span><br><span class="line">  profiles: dev ## 给开发环境取的名</span><br><span class="line">server:</span><br><span class="line">  port: 80</span><br><span class="line">---</span><br><span class="line">## 生产环境</span><br><span class="line">spring:</span><br><span class="line">  profiles: pro ## 给生产环境取的名</span><br><span class="line">server:</span><br><span class="line">  port: 81</span><br><span class="line">---</span><br><span class="line">## 测试环境</span><br><span class="line">spring:</span><br><span class="line">  profiles: test ## 给测试环境起的名</span><br><span class="line">server:</span><br><span class="line">  port: 82</span><br></pre></td></tr></table></figure><p>注意：在上面配置中给不同配置起名字的  spring.profiles  配置项已经过时，但是能用。最新用来起名字的配置项是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## 开发环境</span><br><span class="line">spring:</span><br><span class="line">  config:</span><br><span class="line">    activate:</span><br><span class="line">      on-profile: dev ## 给开发环境取的名</span><br></pre></td></tr></table></figure><h2 id="命令行启动参数设置"><a href="#命令行启动参数设置" class="headerlink" title="命令行启动参数设置"></a>命令行启动参数设置</h2><p>使用  SpringBoot  开发的程序以后都是打成  jar  包，通过  java -jar xxx.jar  的方式启动服务的。那么就存在一个问题，如何切换环境呢？因为配置文件打到的jar包中了。</p><p> SpringBoot  提供了在运行  jar  时设置开启指定的环境的方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">测试</span><br><span class="line">java -jar xxx.jar --spring.profiles.active=test</span><br><span class="line"></span><br><span class="line">临时修改端口号</span><br><span class="line">java -jar xxx.jar --server.port=9421</span><br><span class="line"></span><br><span class="line">指定启用哪个环境配置，又临时指定端口</span><br><span class="line">java -jar xxx.jar -server.port=9421 --spring.profiles.active=pro</span><br></pre></td></tr></table></figure><p>配置的优先级官网已经进行了说明。</p><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config">https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config</a></p><h1 id="配置文件分类"><a href="#配置文件分类" class="headerlink" title="配置文件分类"></a>配置文件分类</h1><p>有这样的场景，我们开发完毕后需要测试人员进行测试，由于测试环境和开发环境的很多配置都不相同，所以测试人员在运行我们的工程时需要临时修改很多配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java –jar springboot.jar –-spring.profiles.active=test --server.port=85 --server.servlet.context-path=/heima --server.tomcat.connection-timeout=-1 …… …… …… …… ……</span><br></pre></td></tr></table></figure><p>针对这种情况， SpringBoot  定义了配置文件不同的放置的位置；而放在不同位置的优先级时不同的。</p><p>SpringBoot中4级配置文件放置位置：</p><ul><li>1级：classpath：application.yml</li><li>2级：classpath：config&#x2F;application.yml</li></ul><p>分界线，以同级为界，上面两个在 jar 包里面，下面两个在 jar 包外</p><ul><li>3级：file ：application.yml</li><li>4级：file ：config&#x2F;application.yml</li></ul><p>说明：级别越高的优先级越高</p><h1 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h1><h2 id="整合Junit"><a href="#整合Junit" class="headerlink" title="整合Junit"></a>整合Junit</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310242218493.png"></p><p>使用  @RunWith  注解指定运行器，使用  @ContextConfiguration  注解来指定配置类或者配置文件。</p><p>而  SpringBoot  整合  junit  特别简单，分为以下三步完成</p><ul><li>在测试类上添加  SpringBootTest  注解</li><li>使用  @Autowired  注入要测试的资源</li><li>定义测试方法进行测试</li></ul><h3 id="SpringBoot整合"><a href="#SpringBoot整合" class="headerlink" title="SpringBoot整合"></a>SpringBoot整合</h3><h4 id="环境准备-1"><a href="#环境准备-1" class="headerlink" title="环境准备"></a>环境准备</h4><ul><li><p>创建一个新的SpringBoot工程</p></li><li><p>在com.blog.service包下创建BookService接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface BookService &#123;</span><br><span class="line">    void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在com.blog.service.impl包下创建BookService接口的实现类，并重写其方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class BookServiceImpl implements BookService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book service is running ..&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="编写测试类"><a href="#编写测试类" class="headerlink" title="编写测试类"></a>编写测试类</h4><p>在  test&#x2F;java  下创建  com.blog  包，在该包下创建测试类，将  BookService  注入到该测试类中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">class Springboot02JunitApplicationTests &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private BookService bookService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void contextLoads() &#123;</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试方法，控制台成功输出</p><p>注意：这里的引导类所在包必须是测试类所在包及其子包。</p><p>例如：</p><ul><li>引导类所在包是  com.blog </li><li>测试类所在包是  com.blog</li></ul><p>如果不满足这个要求的话，就需要在使用  @SpringBootTest  注解时，使用  classes  属性指定引导类的字节码对象。如  @SpringBootTest(classes &#x3D; XxxApplication.class) </p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310242222895.png"></p><h2 id="整合MyBatis"><a href="#整合MyBatis" class="headerlink" title="整合MyBatis"></a>整合MyBatis</h2><h3 id="回顾Spring整合MyBatis"><a href="#回顾Spring整合MyBatis" class="headerlink" title="回顾Spring整合MyBatis"></a>回顾Spring整合MyBatis</h3><p>之前Spring整合MyBatis时，需要定义很多配置类</p><ul><li>SpringConfig配置类</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.blog&quot;)</span><br><span class="line">@PropertySource(&quot;jdbc.properties&quot;)</span><br><span class="line">@Import(&#123;JdbcConfig.class, MyBatisConfig.class&#125;)</span><br><span class="line">public class SpringConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>导入JdbcConfig配置类</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class JdbcConfig &#123;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span><br><span class="line">    private String driver;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.url&#125;&quot;)</span><br><span class="line">    private String url;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.username&#125;&quot;)</span><br><span class="line">    private String username;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.password&#125;&quot;)</span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource() &#123;</span><br><span class="line">        DruidDataSource dataSource = new DruidDataSource();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        return dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>导入MyBatisConfig配置类<ul><li>定义  SqlSessionFactoryBean </li><li>定义映射配置</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class MyBatisConfig &#123;</span><br><span class="line"></span><br><span class="line">    //定义bean，SqlSessionFactoryBean，用于产生SqlSessionFactory对象</span><br><span class="line">    @Bean</span><br><span class="line">    public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource) &#123;</span><br><span class="line">        SqlSessionFactoryBean sqlSessionFactory = new SqlSessionFactoryBean();</span><br><span class="line">        //设置模型类的别名扫描</span><br><span class="line">        sqlSessionFactory.setTypeAliasesPackage(&quot;com.blog.domain&quot;);</span><br><span class="line">        //设置数据源</span><br><span class="line">        sqlSessionFactory.setDataSource(dataSource);</span><br><span class="line">        return sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    //定义bean，返回MapperScannerConfigurer对象</span><br><span class="line">    @Bean</span><br><span class="line">    public MapperScannerConfigurer mapperScannerConfigurer() &#123;</span><br><span class="line">        MapperScannerConfigurer msc = new MapperScannerConfigurer();</span><br><span class="line">        msc.setBasePackage(&quot;com.blog.dao&quot;);</span><br><span class="line">        return msc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringBoot整合MyBatis"><a href="#SpringBoot整合MyBatis" class="headerlink" title="SpringBoot整合MyBatis"></a>SpringBoot整合MyBatis</h3><ul><li><p>创建一个新的模块<br>注意选择技术集的时候，要勾选 MyBatis Framework 和 MySQL Driver </p></li><li><p>建库建表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE springboot_db;</span><br><span class="line">USE springboot_db;</span><br><span class="line"></span><br><span class="line">CREATE TABLE tbl_book</span><br><span class="line">(</span><br><span class="line">    id          INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    `type`      VARCHAR(20),</span><br><span class="line">    `name`      VARCHAR(50),</span><br><span class="line">    description VARCHAR(255)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO `tbl_book`(`id`, `type`, `name`, `description`)</span><br><span class="line">VALUES (1, &#x27;计算机理论&#x27;, &#x27;Spring实战 第五版&#x27;, &#x27;Spring入门经典教程，深入理解Spring原理技术内幕&#x27;),</span><br><span class="line">       (2, &#x27;计算机理论&#x27;, &#x27;Spring 5核心原理与30个类手写实践&#x27;, &#x27;十年沉淀之作，手写Spring精华思想&#x27;),</span><br><span class="line">       (3, &#x27;计算机理论&#x27;, &#x27;Spring 5设计模式&#x27;, &#x27;深入Spring源码刨析Spring源码中蕴含的10大设计模式&#x27;),</span><br><span class="line">       (4, &#x27;计算机理论&#x27;, &#x27;Spring MVC+Mybatis开发从入门到项目实战&#x27;,</span><br><span class="line">        &#x27;全方位解析面向Web应用的轻量级框架，带你成为Spring MVC开发高手&#x27;),</span><br><span class="line">       (5, &#x27;计算机理论&#x27;, &#x27;轻量级Java Web企业应用实战&#x27;, &#x27;源码级刨析Spring框架，适合已掌握Java基础的读者&#x27;),</span><br><span class="line">       (6, &#x27;计算机理论&#x27;, &#x27;Java核心技术 卷Ⅰ 基础知识(原书第11版)&#x27;,</span><br><span class="line">        &#x27;Core Java第11版，Jolt大奖获奖作品，针对Java SE9、10、11全面更新&#x27;),</span><br><span class="line">       (7, &#x27;计算机理论&#x27;, &#x27;深入理解Java虚拟机&#x27;, &#x27;5个纬度全面刨析JVM,大厂面试知识点全覆盖&#x27;),</span><br><span class="line">       (8, &#x27;计算机理论&#x27;, &#x27;Java编程思想(第4版)&#x27;, &#x27;Java学习必读经典，殿堂级著作！赢得了全球程序员的广泛赞誉&#x27;),</span><br><span class="line">       (9, &#x27;计算机理论&#x27;, &#x27;零基础学Java(全彩版)&#x27;, &#x27;零基础自学编程的入门图书，由浅入深，详解Java语言的编程思想和核心技术&#x27;),</span><br><span class="line">       (10, &#x27;市场营销&#x27;, &#x27;直播就这么做:主播高效沟通实战指南&#x27;, &#x27;李子柒、李佳奇、薇娅成长为网红的秘密都在书中&#x27;),</span><br><span class="line">       (11, &#x27;市场营销&#x27;, &#x27;直播销讲实战一本通&#x27;, &#x27;和秋叶一起学系列网络营销书籍&#x27;),</span><br><span class="line">       (12, &#x27;市场营销&#x27;, &#x27;直播带货:淘宝、天猫直播从新手到高手&#x27;, &#x27;一本教你如何玩转直播的书，10堂课轻松实现带货月入3W+&#x27;);</span><br></pre></td></tr></table></figure></li><li><p>定义实体类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class Book &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String type;</span><br><span class="line">    private String name;</span><br><span class="line">    private String description;</span><br><span class="line"></span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getType() &#123;</span><br><span class="line">        return type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setType(String type) &#123;</span><br><span class="line">        this.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDescription() &#123;</span><br><span class="line">        return description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDescription(String description) &#123;</span><br><span class="line">        this.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Book&#123;&quot; +</span><br><span class="line">                &quot;id=&quot; + id +</span><br><span class="line">                &quot;, type=&#x27;&quot; + type + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, description=&#x27;&quot; + description + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义dao接口<br>在com.blog.dao包下定义BookDao接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface BookDao &#123;</span><br><span class="line">    @Select(&quot;select * from tbl_book where id = #&#123;id&#125;&quot;)</span><br><span class="line">    Book getById(Integer id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义测试类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">class Springboot03MybatisApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void contextLoads() &#123;</span><br><span class="line">        Book book = bookDao.getById(1);</span><br><span class="line">        System.out.println(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://localhost:3306/springboot_db?serverTimezone=UTC</span><br><span class="line">    username: root</span><br><span class="line">    password: PASSWORD</span><br></pre></td></tr></table></figure></li><li><p>测试<br>运行测试方法，会报错 No qualifying bean of type ‘com.blog.dao.BookDao’ ，没有类型为“com.blog.dao.BookDao”的限定bean<br>为什么会出现这种情况呢？之前我们在配置MyBatis时，配置了如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public MapperScannerConfigurer mapperScannerConfigurer() &#123;</span><br><span class="line">    MapperScannerConfigurer msc = new MapperScannerConfigurer();</span><br><span class="line">    msc.setBasePackage(&quot;com.blog.dao&quot;);</span><br><span class="line">    return msc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> Mybatis  会扫描接口并创建接口的代码对象交给  Spring  管理，但是现在并没有告诉  Mybatis  哪个是  dao  接口。<br>而我们要解决这个问题需要在 BookDao  接口上使用  @Mapper  ， BookDao  接口修改为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface BookDao &#123;</span><br><span class="line">    @Select(&quot;select * from tbl_book where id = #&#123;id&#125;&quot;)</span><br><span class="line">    Book getById(Integer id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>注意：<br> SpringBoot  版本低于2.4.3(不含)，Mysql驱动版本大于8.0时，需要在url连接串中配置时区  jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;springboot_db?serverTimezone&#x3D;UTC ，或在MySQL数据库端配置时区解决此问题</p><h3 id="更改数据源"><a href="#更改数据源" class="headerlink" title="更改数据源"></a>更改数据源</h3><p>现在我们并没有指定数据源， SpringBoot  有默认的数据源，我们也可以指定使用  Druid  数据源，按照以下步骤实现</p><ul><li><p>导依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.12&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>修改配置文件配置</p><p>在  application.yml  可以通过  spring.datasource.type  来配置使用什么数据源。配置文件内容可以改进为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://localhost:3306/springboot_db?serverTimezone=UTC</span><br><span class="line">    username: root</span><br><span class="line">    password: PASSWORD.</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br></pre></td></tr></table></figure></li></ul><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310250916598.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310250916084.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310250917844.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310250917764.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310250917615.png"></p><h1 id="SSM整合案例"><a href="#SSM整合案例" class="headerlink" title="SSM整合案例"></a>SSM整合案例</h1><h3 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h3><p>创建一个新的SpringBoot工程，注意要勾选 Spring Web ， MyBatis Framework 和 MySQL Driver<br>由于我们工程中使用到了  Druid  ，所以需要导入  Druid  的坐标。druid在parent中没有，这个要加版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.12&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="代码拷贝"><a href="#代码拷贝" class="headerlink" title="代码拷贝"></a>代码拷贝</h3><p>将之前的ssm整合工程的代码拷贝过来，将 com.blog 包下的所有内容拷贝过来，放在对应的位置即可。项目结构如下</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310250932818.png"></p><ul><li>config：原有的配置文件，全被springboot整合简化</li><li>controller：相应web请求</li><li>dao：执行相应的SQL语句，需要添加 @mapper 注册</li><li>domain：定义实体类</li><li>exception：异常处理</li><li>service：添加功能接口和相关实现类</li></ul><p>需要修改的内容如下：</p><ul><li>config：直接删掉，SpringBoot并不需要这些配置类</li><li>dao：添加 @mapper 注册</li><li>将测试类也修改为SpringBoot的</li></ul><h3 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h3><p>把application. properties 改成 application.yml文件，把里面的配置改为 yml 格式</p><ul><li><p>服务的端口号（设为80，这样我们就不用写了）</p></li><li><p>连接数据库的信息（数据库连接四要素）</p></li><li><p>数据源（德鲁伊）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 80</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://localhost:3306/springboot_db?serverTimezone=UTC</span><br><span class="line">    username: root</span><br><span class="line">    password: PASSWORD.</span><br></pre></td></tr></table></figure></li></ul><h3 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h3><p>在  SpringBoot  程序中是没有  webapp  目录的，那么在  SpringBoot  程序中静态资源需要放在什么位置呢？<br>静态资源需要放在  resources  下的  static  下<br>那我们再配置一个默认页面，跳转到我们的增删改页面，新建 index.html ，写入以下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    document.location.href=&quot;/pages/books.html&quot;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这样当我们在浏览器输入localhost，然后直接按回车，就能直接跳转到增删改的页面了，如果以后我们需要频繁测试某一个页面，也可以将上述代码中的地址换为我们要测试的地址，这样就不用老手敲地址了</p><h1 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h1><h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><ol><li><p>创建工程</p><p>创建一个SpringBoot工程</p><p>需要勾选 Spring Web ， MyBatis Framework 和 MySQL Driver </p></li><li><p>SpringBoot整合</p><p>整合MyBatis</p><ul><li>添加Druid数据源依赖</li><li>编写数据库配置文件（application.yml），配置数据库连接四要素</li><li>对于Dao层的包扫描，使用 @Mapper 注解</li></ul><p>整合Junit</p><ul><li>使用 @SpringBootTest 注解</li></ul></li><li><p>功能模块</p><p>创建数据库和表</p><p>根据数据表来创建对应的模型类</p><p>通过 Dao 层完成数据库的增删改</p><p>编写 Service 层（Service接口+实现类）</p><p>编写Controller层</p><ul><li>接收请求  @RequestMapping 、 @GetMapping 、 @PostMapping 、 @PutMapping 、 @DeleteMapping </li><li>接收数据 简单类型、POJO类型、嵌套POJO类型、数组类型、JSON数据类型<ul><li>@RequestParam </li><li>@PathVariable </li><li>@RequestBody</li></ul></li><li>转发业务层<ul><li>使用 @Autowired 自动装配</li></ul></li><li>响应结果<ul><li>@ResponseBody</li></ul></li></ul></li></ol><h2 id="整合配置"><a href="#整合配置" class="headerlink" title="整合配置"></a>整合配置</h2><ul><li><p>步骤一： 创建一个SpringBoot工程<br>  注意要勾选 Spring Web ， MyBatis Framework 和 MySQL Driver </p></li><li><p>步骤二：</p><p>创建项目包结构</p><ul><li>com.blog.controller  编写Controller类</li><li>com.blog.dao  存放的是Dao层的接口，注意要使用 @Mapper 注解</li><li>com.blog.service  存放的是Service层接口，</li><li>com.blog.service.impl  存放的是Service的实现类</li><li>com.blog.domain  存放的是pojo类</li><li>resources&#x2F;static  存放静态资源HTML，CSS，JS等</li><li>test&#x2F;java  存放测试类</li></ul></li><li><p>步骤三： 编写application.yml<br>  导入Druid的坐标，并在配置文件中编写数据库连接四要素</p></li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 80</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://localhost:3306/springboot_db?serverTimezone=UTC</span><br><span class="line">    username: root</span><br><span class="line">    password: YOURPASSWORD.</span><br></pre></td></tr></table></figure><h2 id="功能模块开发"><a href="#功能模块开发" class="headerlink" title="功能模块开发"></a>功能模块开发</h2><ul><li>步骤一： 创建数据库和表</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">create database springboot_db;</span><br><span class="line">use springboot_db;</span><br><span class="line">create table tbl_book</span><br><span class="line">(</span><br><span class="line">    id          int primary key auto_increment,</span><br><span class="line">    type        varchar(20),</span><br><span class="line">    `name`      varchar(50),</span><br><span class="line">    description varchar(255)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">insert into `tbl_book`(`id`, `type`, `name`, `description`)</span><br><span class="line">values (1, &#x27;计算机理论&#x27;, &#x27;Spring实战 第五版&#x27;, &#x27;Spring入门经典教程，深入理解Spring原理技术内幕&#x27;),</span><br><span class="line">       (2, &#x27;计算机理论&#x27;, &#x27;Spring 5核心原理与30个类手写实践&#x27;, &#x27;十年沉淀之作，手写Spring精华思想&#x27;),</span><br><span class="line">       (3, &#x27;计算机理论&#x27;, &#x27;Spring 5设计模式&#x27;, &#x27;深入Spring源码刨析Spring源码中蕴含的10大设计模式&#x27;),</span><br><span class="line">       (4, &#x27;计算机理论&#x27;, &#x27;Spring MVC+Mybatis开发从入门到项目实战&#x27;,</span><br><span class="line">        &#x27;全方位解析面向Web应用的轻量级框架，带你成为Spring MVC开发高手&#x27;),</span><br><span class="line">       (5, &#x27;计算机理论&#x27;, &#x27;轻量级Java Web企业应用实战&#x27;, &#x27;源码级刨析Spring框架，适合已掌握Java基础的读者&#x27;),</span><br><span class="line">       (6, &#x27;计算机理论&#x27;, &#x27;Java核心技术 卷Ⅰ 基础知识(原书第11版)&#x27;,</span><br><span class="line">        &#x27;Core Java第11版，Jolt大奖获奖作品，针对Java SE9、10、11全面更新&#x27;),</span><br><span class="line">       (7, &#x27;计算机理论&#x27;, &#x27;深入理解Java虚拟机&#x27;, &#x27;5个纬度全面刨析JVM,大厂面试知识点全覆盖&#x27;),</span><br><span class="line">       (8, &#x27;计算机理论&#x27;, &#x27;Java编程思想(第4版)&#x27;, &#x27;Java学习必读经典，殿堂级著作！赢得了全球程序员的广泛赞誉&#x27;),</span><br><span class="line">       (9, &#x27;计算机理论&#x27;, &#x27;零基础学Java(全彩版)&#x27;, &#x27;零基础自学编程的入门图书，由浅入深，详解Java语言的编程思想和核心技术&#x27;),</span><br><span class="line">       (10, &#x27;市场营销&#x27;, &#x27;直播就这么做:主播高效沟通实战指南&#x27;, &#x27;李子柒、李佳奇、薇娅成长为网红的秘密都在书中&#x27;),</span><br><span class="line">       (11, &#x27;市场营销&#x27;, &#x27;直播销讲实战一本通&#x27;, &#x27;和秋叶一起学系列网络营销书籍&#x27;),</span><br><span class="line">       (12, &#x27;市场营销&#x27;, &#x27;直播带货:淘宝、天猫直播从新手到高手&#x27;, &#x27;一本教你如何玩转直播的书，10堂课轻松实现带货月入3W+&#x27;);</span><br></pre></td></tr></table></figure><ul><li>步骤二： 编写模型类</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class Book &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String type;</span><br><span class="line">    private String name;</span><br><span class="line">    private String description;</span><br><span class="line"></span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getType() &#123;</span><br><span class="line">        return type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setType(String type) &#123;</span><br><span class="line">        this.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDescription() &#123;</span><br><span class="line">        return description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDescription(String description) &#123;</span><br><span class="line">        this.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Book&#123;&quot; +</span><br><span class="line">                &quot;id=&quot; + id +</span><br><span class="line">                &quot;, type=&#x27;&quot; + type + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, description=&#x27;&quot; + description + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>步骤三： 编写dao接口<br>  注意使用 @Mapper 注解</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface BookDao &#123;</span><br><span class="line">    @Select(&quot;select * from tbl_book where id=#&#123;id&#125;&quot;)</span><br><span class="line">    Book getById(Integer id);</span><br><span class="line"></span><br><span class="line">    @Select(&quot;select * from tbl_book&quot;)</span><br><span class="line">    List&lt;Book&gt; getAll();</span><br><span class="line"></span><br><span class="line">    @Update(&quot;update tbl_book set type=#&#123;type&#125;, `name`=#&#123;name&#125;, `description`=#&#123;description&#125; where id=#&#123;id&#125;&quot;)</span><br><span class="line">    int update(Book book);</span><br><span class="line"></span><br><span class="line">    @Delete(&quot;delete from tbl_book where id=#&#123;id&#125;&quot;)</span><br><span class="line">    int delete(Integer id);</span><br><span class="line"></span><br><span class="line">    @Insert(&quot;insert into tbl_book values (null, #&#123;type&#125;, #&#123;name&#125;, #&#123;description&#125;)&quot;)</span><br><span class="line">    int save(Book book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>步骤四： 编写service接口及其实现类</li></ul><p>  接口：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface BookService &#123;</span><br><span class="line">    boolean save(Book book);</span><br><span class="line"></span><br><span class="line">    boolean update(Book book);</span><br><span class="line"></span><br><span class="line">    boolean delete(Integer id);</span><br><span class="line"></span><br><span class="line">    Book getById(Integer id);</span><br><span class="line"></span><br><span class="line">    List&lt;Book&gt; getAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  实现类：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class BookServiceImpl implements BookService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean save( Book book) &#123;</span><br><span class="line">        int cnt = bookDao.save(book);</span><br><span class="line">        return cnt &gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean update(Book book) &#123;</span><br><span class="line">        int cnt = bookDao.update(book);</span><br><span class="line">        return cnt&gt;0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean delete(Integer id) &#123;</span><br><span class="line">        return bookDao.delete(id) &gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Book getById(Integer id) &#123;</span><br><span class="line">        return bookDao.getById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;Book&gt; getAll() &#123;</span><br><span class="line">        return bookDao.getAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>步骤五： 编写Controller类<br>  注意响应pojo类型要加 @RequestBody 注解，某人忘加了，调试了半天</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/books&quot;)</span><br><span class="line">public class BookController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private BookService bookService;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public Book getById(@PathVariable Integer id) &#123;</span><br><span class="line">        return bookService.getById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping</span><br><span class="line">    public List&lt;Book&gt; getAll() &#123;</span><br><span class="line">        return bookService.getAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping</span><br><span class="line">    public boolean save(@RequestBody Book book) &#123;</span><br><span class="line">        return bookService.save(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PutMapping</span><br><span class="line">    public boolean update(@RequestBody Book book) &#123;</span><br><span class="line">        return bookService.update(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public boolean delete(@PathVariable Integer id) &#123;</span><br><span class="line">        return bookService.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>步骤六： 使用PostMan进行测试<br>  将增删改查全部测试完毕之后，就可以继续往下做了</li></ul><h2 id="统一结果封装"><a href="#统一结果封装" class="headerlink" title="统一结果封装"></a>统一结果封装</h2><ul><li><p>创建一个返回结果类<br>我这里暂时只需要返回的结果，状态码和异常信息，如果还有别的需求，可以自行删改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class Result &#123;</span><br><span class="line">    private Object data;</span><br><span class="line">    private Integer code;</span><br><span class="line">    private String msg;</span><br><span class="line"></span><br><span class="line">    public Object getData() &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Object data) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getCode() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCode(Integer code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getMsg() &#123;</span><br><span class="line">        return msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMsg(String msg) &#123;</span><br><span class="line">        this.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Result&#123;&quot; +</span><br><span class="line">                &quot;data=&quot; + data +</span><br><span class="line">                &quot;, code=&quot; + code +</span><br><span class="line">                &quot;, msg=&#x27;&quot; + msg + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义状态码Code类<br>状态码也可以根据自己的需求来自定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Code &#123;</span><br><span class="line">    public static final Integer SAVE_OK = 20011;</span><br><span class="line">    public static final Integer SAVE_ERR = 20010;</span><br><span class="line"></span><br><span class="line">    public static final Integer UPDATE_OK = 20021;</span><br><span class="line">    public static final Integer UPDATE_ERR = 20020;</span><br><span class="line"></span><br><span class="line">    public static final Integer DELETE_OK = 20031;</span><br><span class="line">    public static final Integer DELETE_ERR = 20030;</span><br><span class="line"></span><br><span class="line">    public static final Integer GET_OK = 20041;</span><br><span class="line">    public static final Integer GET_ERR = 20040;</span><br><span class="line"></span><br><span class="line">    public static final Integer SYSTEM_ERR = 50001;</span><br><span class="line">    public static final Integer SYSTEM_TIMEOUT_ERR = 50002;</span><br><span class="line">    public static final Integer SYSTEM_UNKNOW_ERR = 59999;</span><br><span class="line"></span><br><span class="line">    public static final Integer BUSINESS_ERR = 60001;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改Controller类的返回值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/books&quot;)</span><br><span class="line">public class BookController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private BookService bookService;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public Result getById(@PathVariable Integer id) &#123;</span><br><span class="line">        Book book = bookService.getById(id);</span><br><span class="line">        Integer code = book == null ? Code.GET_ERR : Code.GET_OK;</span><br><span class="line">        String msg = book == null ? &quot;数据查询失败，请重试！&quot; : &quot;&quot;;</span><br><span class="line">        return new Result(code, book, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping</span><br><span class="line">    public Result getAll() &#123;</span><br><span class="line">        List&lt;Book&gt; books = bookService.getAll();</span><br><span class="line">        Integer code = books == null ? Code.GET_ERR : Code.GET_OK;</span><br><span class="line">        String msg = books == null ? &quot;数据查询失败，请重试！&quot; : &quot;&quot;;</span><br><span class="line">        return new Result(code, books, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping</span><br><span class="line">    public Result save(@RequestBody Book book) &#123;</span><br><span class="line">        boolean flag = bookService.save(book);</span><br><span class="line">        return new Result(flag ? Code.SAVE_OK : Code.SAVE_ERR, flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PutMapping</span><br><span class="line">    public Result update(@RequestBody Book book) &#123;</span><br><span class="line">        boolean flag = bookService.update(book);</span><br><span class="line">        return new Result(flag ? Code.UPDATE_OK : Code.UPDATE_ERR, flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public Result delete(@PathVariable Integer id) &#123;</span><br><span class="line">        boolean flag = bookService.delete(id);</span><br><span class="line">        return new Result(flag ? Code.DELETE_OK : Code.DELETE_ERR, flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h2><ul><li><p>将异常进行分类<br>这里只将其划分为了业务异常和系统异常<br>在com.blog.exception包下新建两个异常类</p><p>BusinessException：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class BusinessException extends RuntimeException &#123;</span><br><span class="line">    private Integer code;</span><br><span class="line"></span><br><span class="line">    public Integer getCode() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCode(Integer code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BusinessException(Integer code) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BusinessException(Integer code, String message) &#123;</span><br><span class="line">        super(message);</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BusinessException(Integer code, String message, Throwable cause) &#123;</span><br><span class="line">        super(message, cause);</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SystemException：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class SystemException extends RuntimeException &#123;</span><br><span class="line">    private Integer code;</span><br><span class="line"></span><br><span class="line">    public Integer getCode() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCode(Integer code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SystemException(Integer code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SystemException(Integer code, String message) &#123;</span><br><span class="line">        super(message);</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SystemException(Integer code, String message, Throwable cause) &#123;</span><br><span class="line">        super(message, cause);</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>同时再增加几个状态码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static final Integer SYSTEM_ERR = 50001;</span><br><span class="line">public static final Integer SYSTEM_TIMEOUT_ERR = 50002;</span><br><span class="line">public static final Integer SYSTEM_UNKNOW_ERR = 59999;</span><br><span class="line">public static final Integer BUSINESS_ERR = 60001;</span><br></pre></td></tr></table></figure></li><li><p>编写自定义异常处理类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@RestControllerAdvice</span><br><span class="line">public class ProjectExceptionAdvice &#123;</span><br><span class="line"></span><br><span class="line">    //处理系统异常</span><br><span class="line">    @ExceptionHandler(SystemException.class)</span><br><span class="line">    public Result doSystemException(SystemException exception)&#123;</span><br><span class="line">        return new Result(exception.getCode(),null,exception.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //处理业务异常</span><br><span class="line">    @ExceptionHandler(BusinessException.class)</span><br><span class="line">    public Result doBusinessException(BusinessException exception)&#123;</span><br><span class="line">        return new Result(exception.getCode(),null,exception.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //处理未知异常</span><br><span class="line">    @ExceptionHandler(Exception.class)</span><br><span class="line">    public Result doException(Exception exception)&#123;</span><br><span class="line">        return new Result(Code.SYSTEM_UNKNOW_ERR,null,&quot;系统繁忙，请稍后再试&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试异常<br>可以getById方法中来进行测试，当id为1时，错误码为 BUSINESS_ERR ，错误信息为 不让你瞅 ，当查询其他id时，均为 SYSTEM_UNKNOW_ERR ，错误提示信息为 服务器访问超时，请稍后再试 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class BookServiceImpl implements BookService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean save(Book book) &#123;</span><br><span class="line">        int cnt = bookDao.save(book);</span><br><span class="line">        return cnt &gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean update(Book book) &#123;</span><br><span class="line">        int cnt = bookDao.update(book);</span><br><span class="line">        return cnt &gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean delete(Integer id) &#123;</span><br><span class="line">        return bookDao.delete(id) &gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Book getById(Integer id) &#123;</span><br><span class="line">        if (id == 1)&#123;</span><br><span class="line">            throw new BusinessException(Code.BUSINESS_ERR,&quot;不让你瞅&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            int a = 1 / 0;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new SystemException(Code.SYSTEM_UNKNOW_ERR, &quot;服务器访问超时，请稍后再试&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return bookDao.getById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;Book&gt; getAll() &#123;</span><br><span class="line">        return bookDao.getAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><div class="tabs" id=""><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#-1">1</button></li><li class="tab"><button type="button" data-href="#-2">2</button></li><li class="tab"><button type="button" data-href="#-3">3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="-1"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-2"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-3"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot Spring 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-JDBC</title>
      <link href="/2023/10/16/JavaJDBC/"/>
      <url>/2023/10/16/JavaJDBC/</url>
      
        <content type="html"><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><p>JDBC：Java 提供的一套用于操作数据库的接口 API。Java 程序员只需要面向该接口即可连接任何提供了 JDBC 驱动程序的数据库，完成对数据库的各种操作。不同的数据库厂商，需要针对这套接口提供不同的实现。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310160829019.png"></p><p><strong>JDBC 程序编写步骤（示范）：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/* [1] 注册驱动 */</span><br><span class="line">Driver driver = new com.mysql.cj.jdbc.Driver();</span><br><span class="line"></span><br><span class="line">/* [2] 获取连接 */</span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/melody&quot;;</span><br><span class="line">Properties properties = new Properties();</span><br><span class="line">properties.setProperty(&quot;user&quot;, &quot;root&quot;);</span><br><span class="line">properties.setProperty(&quot;password&quot;, &quot;******&quot;);</span><br><span class="line">Connection connect = driver.connect(url, properties);</span><br><span class="line"></span><br><span class="line">/* [3] 执行语句 */</span><br><span class="line">String sql = &quot;insert into customer (customer_id,name,card_id) values(0004,&#x27;赫尔&#x27;,&#x27;00000000000000000O&#x27;)&quot;;</span><br><span class="line">Statement statement = connect.createStatement();</span><br><span class="line">int rows = statement.executeUpdate(sql);</span><br><span class="line">System.out.println(rows);</span><br><span class="line"></span><br><span class="line">/* [4] 释放资源 */</span><br><span class="line">statement.close();</span><br><span class="line">connect.close();</span><br></pre></td></tr></table></figure><ul><li><p>前置操作：将 <code>mysql-connector-java-8.0.27.jar</code> 该文件拷贝到项目目录下，选中后右键选择 <code>Add as library</code></p></li><li><p>注册驱动：加载 <code>Driver</code> 类</p><p>这里我导入了 <code>com.mysql.cj.jdbc.Driver</code>。根据前面的 <code>jar</code> 包的版本不同，应该导入的路径也会不同。</p><p>旧版本的 <code>jar</code> 包可能应该导入 <code>com.mysql.jdbc.Driver</code> 这个包。</p></li><li><p>获取连接：得到 <code>Connection</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String url = &quot;jdbc:mysql://localhost:3306/test&quot;;</span><br></pre></td></tr></table></figure><p>这里表示进入 <code>test</code> 这个数据库。</p></li><li><p>执行语句：发送 SQL 命令给 MySQL 执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int rows = statement.executeUpdate(sql);</span><br></pre></td></tr></table></figure><p>如果是 dml 语句，这里返回的 rows 是影响的行数。返回 0 表示失败。</p></li><li><p>释放资源：关闭相关连接</p></li></ul><h2 id="连接数据库的-5-种方式"><a href="#连接数据库的-5-种方式" class="headerlink" title="连接数据库的 5 种方式"></a>连接数据库的 5 种方式</h2><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">方法1</button></li><li class="tab"><button type="button" data-href="#test1-2">方法2</button></li><li class="tab"><button type="button" data-href="#test1-3">方法3</button></li><li class="tab"><button type="button" data-href="#test1-4">方法4</button></li><li class="tab"><button type="button" data-href="#test1-5">方法5（推荐）</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p>直接创建 <code>Driver</code>，调用 <code>driver.connet(url, properties);</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Driver driver = new com.mysql.cj.jdbc.Driver();</span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/test&quot;;</span><br><span class="line">Properties properties = new Properties();</span><br><span class="line">properties.setProperty(&quot;user&quot;, &quot;root&quot;);</span><br><span class="line">properties.setProperty(&quot;password&quot;, &quot;111111&quot;);</span><br><span class="line">Connection connect = driver.connect(url, properties);</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p>使用反射加载 <code>Driver</code> 类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; aClass = Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">Driver driver = (Driver) aClass.newInstance();</span><br><span class="line">Properties properties = new Properties();</span><br><span class="line">properties.setProperty(&quot;user&quot;, &quot;root&quot;);</span><br><span class="line">properties.setProperty(&quot;password&quot;, &quot;******&quot;);</span><br><span class="line">Connection connect = driver.connect(url, properties);</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p>使用 <code>DriverManager</code> 替代 <code>Driver</code> 进行统一管理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; aClass = Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">Driver driver = (Driver) aClass.newInstance();</span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/melody&quot;;</span><br><span class="line">String name = &quot;root&quot;;</span><br><span class="line">String password = &quot;******&quot;;</span><br><span class="line">DriverManager.registerDriver(driver);</span><br><span class="line">Connection connection = DriverManager.getConnection(url, name, password);</span><br></pre></td></tr></table></figure><p>这里，<code>DriverManager.getConnetion()</code> 有三种方法。分别是：</p><ul><li><code>getConnetion(url);</code></li><li><code>getConnetion(url, properties);</code></li><li><code>getConnetion(url, name, password);</code></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><p>使用 <code>Class.forName()</code> 自动完成注册驱动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; aClass = Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);</span><br><span class="line">String url = &quot;jdbc:mysql://localhost:3306/melody&quot;;</span><br><span class="line">String name = &quot;root&quot;;</span><br><span class="line">String password = &quot;******&quot;;</span><br><span class="line">Connection connection = DriverManager.getConnection(url, name, password);</span><br></pre></td></tr></table></figure><p><code>Class.forName()</code> 在加载 <code>Driver</code> 类时，会自动完成注册，原理是加载类的时候调用静态代码块</p><p>原理：</p><p><code>Driver</code> 类的源码中有这样一段，这个静态代码块在类加载时会被执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">         DriverManager.registerDriver(new Driver());</span><br><span class="line">     &#125; catch (SQLException var1) &#123;</span><br><span class="line">         throw new RuntimeException(&quot;Can&#x27;t register driver!&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，其实不执行 <code>Class.forName(...);</code> 语句的场合，也能正确获取 <code>Connection</code>。</p><p>这是因为 JDK 1.5 以后使用了 jdbc4。这个场合，系统会自动调用 jar 包下 <code>META-INF\services\java.sql.Driver</code> 这个文件中的类名称去注册。</p><p>打开上述文件看看，里面赫然写着：<code>com.mysql.cj.jdbc.Driver</code></p><blockquote><p>即使如此，还是建议写上 <code>Class.forName(...)</code> 语句！</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-5"><p>在方式 4 的基础上，使用配置文件，连接数据库更灵活。</p><p>这种方式是实际开发最常用的方式。</p><ol><li><p>配置文件（创建 src\mysql.properties）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url=jdbc:mysql://localhost:3306/test</span><br><span class="line">user=root</span><br><span class="line">password=******</span><br><span class="line">driver=com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure></li><li><p>链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Properties pro = new Properties();</span><br><span class="line">pro.load(new FileInputStream(&quot;src\\mysql.properties&quot;))</span><br><span class="line">String url = pro.getProperties(&quot;url&quot;);</span><br><span class="line">String user = pro.getProperties(&quot;user&quot;);</span><br><span class="line">String password = pro.getProperties(&quot;password&quot;);</span><br><span class="line">String driver = pro.getProperties(&quot;driver&quot;);</span><br><span class="line">Class&lt;?&gt; aClass = Class.forName(driver);</span><br><span class="line">Connection connection = DriverManager.getConnection(url, user, password);</span><br></pre></td></tr></table></figure></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="ReaultSet-结果集"><a href="#ReaultSet-结果集" class="headerlink" title="ReaultSet 结果集"></a>ReaultSet 结果集</h2><p>ResultSet：表示数据库结果集的数据表。通常通过执行查询数据库的语句生成。</p><p>ResultSet 对象保持一个光标指向其当前的数据行。该光标的初始位置在第一行之前。调用 next 方法将光标下移，移动到末端的场合会返回 false。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310151520161.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        //通过Properties对象获取配置文件的信息</span><br><span class="line">        Properties properties = new Properties();</span><br><span class="line">        properties.load(new FileInputStream(&quot;src\\mysql.properties&quot;));</span><br><span class="line">        </span><br><span class="line">        //获取相关的值</span><br><span class="line">        String user = properties.getProperty(&quot;user&quot;);</span><br><span class="line">        String password = properties.getProperty(&quot;password&quot;);</span><br><span class="line">        String driver = properties.getProperty(&quot;driver&quot;);</span><br><span class="line">        String url = properties.getProperty(&quot;url&quot;);</span><br><span class="line"></span><br><span class="line">        //1. 注册驱动</span><br><span class="line">        Class.forName(driver);//建议写上</span><br><span class="line"></span><br><span class="line">        //2. 得到连接</span><br><span class="line">        Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">        //3. 得到Statement</span><br><span class="line">        Statement statement = connection.createStatement();</span><br><span class="line">        </span><br><span class="line">        //4. 组织SqL</span><br><span class="line">        String sql = &quot;select id, name , sex, borndate from actor&quot;;</span><br><span class="line">        ResultSet resultSet = statement.executeQuery(sql);</span><br><span class="line">        //执行给定的SQL语句，该语句返回单个 ResultSet对象</span><br><span class="line">        /*</span><br><span class="line">        +----+-----------+-----+---------------------+</span><br><span class="line">        | id | name      | sex | borndate            |</span><br><span class="line">        +----+-----------+-----+---------------------+-------+</span><br><span class="line">        |  4 | 刘德华    | 男  | 1970-12-12 00:00:00 |</span><br><span class="line">        |  5 | jack      | 男  | 1990-11-11 00:00:00 |</span><br><span class="line">        +----+-----------+-----+---------------------+-------+</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        //5. 使用while取出数据</span><br><span class="line">        while (resultSet.next()) &#123; // 让光标向后移动，如果没有更多行，则返回false</span><br><span class="line">            int id  = resultSet.getInt(1); //获取该行的第1列</span><br><span class="line">            //int id1 = resultSet.getInt(&quot;id&quot;); 通过列名来获取值, 推荐</span><br><span class="line">            String name = resultSet.getString(2);//获取该行的第2列</span><br><span class="line">            String sex = resultSet.getString(3);</span><br><span class="line">            Date date = resultSet.getDate(4);</span><br><span class="line"></span><br><span class="line">            System.out.println(id + &quot;\t&quot; + name + &quot;\t&quot; + sex + &quot;\t&quot; + date);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //6. 关闭连接</span><br><span class="line">        resultSet.close();</span><br><span class="line">        statement.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a><code>Statement</code></h2><p>Statement：是个接口，由数据库厂商完成功能的实现</p><p><code>Statment</code> 对象用于执行静态 SQL 语句，并返回其生成的结果的对象</p><p>在连接建立后，需要访问数据库、执行命名或 SQL 语句，有如下方式：</p><ul><li><code>Statment</code>（存在 SQL 注入问题，在实际开发中基本不使用）</li><li><code>PerparedStatement</code>（预处理，从Statement扩展而来）</li><li><code>CallableStatement</code>（存储过程）</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310160834641.png"></p><p>SQL 注入：利用某些系统没有对用户输入的数据进行充分的检查，故意注入非法的 SQL 语句段或命令，恶意攻击数据库。使用 <code>PreparedStatement</code> 可以防范 SQL 注入</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310151533752.png"></p><h3 id="PerparedStatement"><a href="#PerparedStatement" class="headerlink" title="PerparedStatement"></a>PerparedStatement</h3><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310151535379.png"></p><ol><li><p><code>PreparedStatement</code> 执行的 SQL 语句的参数用 <code>?</code> 表示。</p><p>调用方法设置 SQL 语句中的参数，一堆set方法，都有2个参数，第一个是设置的参数的索引（位置），第二个是设置值（参数值）</p></li><li><p><code>executeQuery()</code> ：执行查询方法，返回 <code>ResultSet</code> 对象。</p></li><li><p>executeUpdate()：执行更新，包括增、删、修改</p></li></ol><blockquote><p>PerparedStatement 对SQL语句有一个预处理的过程</p></blockquote><p><strong>预处理的好处</strong></p><ol><li>不再使用拼接语句，增加代码可读性，减少语法错误</li><li>解决了 SQL 注入问题</li><li>大大减少了编译次数，效率提高（保留一个模版，每次传入不同参数执行不同SQL语句）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    //看 PreparedStatement类图</span><br><span class="line"></span><br><span class="line">    Scanner scanner = new Scanner(System.in);</span><br><span class="line"></span><br><span class="line">    //让用户输入管理员名和密码</span><br><span class="line">    System.out.print(&quot;请输入管理员的名字: &quot;);  //next(): 当接收到 空格或者 &#x27;就是表示结束</span><br><span class="line">    String admin_name = scanner.nextLine(); // 老师说明，如果希望看到SQL注入，这里需要用nextLine</span><br><span class="line">    System.out.print(&quot;请输入管理员的密码: &quot;);</span><br><span class="line">    String admin_pwd = scanner.nextLine();</span><br><span class="line"></span><br><span class="line">    //通过Properties对象获取配置文件的信息</span><br><span class="line"></span><br><span class="line">    Properties properties = new Properties();</span><br><span class="line">    properties.load(new FileInputStream(&quot;src\\mysql.properties&quot;));</span><br><span class="line">    //获取相关的值</span><br><span class="line">    String user = properties.getProperty(&quot;user&quot;);</span><br><span class="line">    String password = properties.getProperty(&quot;password&quot;);</span><br><span class="line">    String driver = properties.getProperty(&quot;driver&quot;);</span><br><span class="line">    String url = properties.getProperty(&quot;url&quot;);</span><br><span class="line"></span><br><span class="line">    //1. 注册驱动</span><br><span class="line">    Class.forName(driver);//建议写上</span><br><span class="line"></span><br><span class="line">    //2. 得到连接</span><br><span class="line">    Connection connection = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">    //3. 得到PreparedStatement</span><br><span class="line">    //3.1 组织SqL , Sql 语句的 ? 就相当于占位符</span><br><span class="line">    String sql = &quot;select name , pwd  from admin where name =? and pwd = ?&quot;;</span><br><span class="line">    //3.2 preparedStatement 对象实现了 PreparedStatement 接口的实现类的对象</span><br><span class="line">    PreparedStatement preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">    //3.3 给 ? 赋值</span><br><span class="line">    preparedStatement.setString(1, admin_name);</span><br><span class="line">    preparedStatement.setString(2, admin_pwd);</span><br><span class="line"></span><br><span class="line">    //4. 执行 select 语句使用  executeQuery</span><br><span class="line">    //   如果执行的是 dml(update, insert ,delete) executeUpdate()</span><br><span class="line">    //   这里执行 executeQuery ,不要在写 sql</span><br><span class="line"></span><br><span class="line">    ResultSet resultSet = preparedStatement.executeQuery(sql);</span><br><span class="line">    if (resultSet.next()) &#123; //如果查询到一条记录，则说明该管理存在</span><br><span class="line">        System.out.println(&quot;恭喜， 登录成功&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        System.out.println(&quot;对不起，登录失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //关闭连接</span><br><span class="line">    resultSet.close();</span><br><span class="line">    preparedStatement.close();</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//3. 得到PreparedStatement</span><br><span class="line">        //3.1 组织SqL , Sql 语句的 ? 就相当于占位符</span><br><span class="line">        String sql = &quot;select name , pwd  from admin where name =? and pwd = ?&quot;;</span><br><span class="line">        //3.2 preparedStatement 对象实现了 PreparedStatement 接口的实现类的对象</span><br><span class="line">        PreparedStatement preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">        //3.3 给 ? 赋值</span><br><span class="line">        preparedStatement.setString(1, admin_name);</span><br><span class="line">        preparedStatement.setString(2, admin_pwd);</span><br><span class="line">        </span><br><span class="line"> //4. 执行 select 语句使用  executeQuery</span><br><span class="line">        //   如果执行的是 dml(update, insert ,delete) executeUpdate()</span><br><span class="line">        //   这里执行 executeQuery ,不要在写 sql</span><br><span class="line">        ResultSet resultSet = preparedStatement.executeQuery(sql);</span><br><span class="line">        if (resultSet.next()) &#123; //如果查询到一条记录，则说明该管理存在</span><br><span class="line">            System.out.println(&quot;恭喜， 登录成功&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;对不起，登录失败&quot;);</span><br><span class="line">        &#125;        </span><br></pre></td></tr></table></figure><blockquote><p>注意，执行的时候不要再带参数了，不然就是执行模板了</p></blockquote><p>相关的类及方法：</p><table><thead><tr><th>类 &#x2F; 接口</th><th>方法</th></tr></thead><tbody><tr><td>DriverManager 驱动管理类</td><td>getConnection(url, user, pwd) 获取连接</td></tr><tr><td></td><td>createStatement() 创建 Statement 对象</td></tr><tr><td></td><td>preparedStatement(sql) 生成预处理 PreparedStatement 对象</td></tr><tr><td>Statement 接口</td><td>executeUpdate(sql) 执行 dml 语句，返回影响行数</td></tr><tr><td></td><td>executeQuery(sql) 执行查询语句，返回 ResultSet</td></tr><tr><td></td><td>execute(sql) 执行任意 SQL 语句，返回布尔值</td></tr><tr><td>PreparedStatement 接口</td><td>executeUpdate() 执行 dml 语句，返回影响行数</td></tr><tr><td></td><td>executeQuery() 执行查询语句，返回 ResultSet</td></tr><tr><td></td><td>execute() 执行任意 SQL 语句，返回布尔值</td></tr><tr><td></td><td>setXXX(int, xxx) 设置 SQL 语句中占位符的值</td></tr><tr><td></td><td>setObject(int, xxx) 设置 SQL 语句中占位符的值</td></tr><tr><td>ResultSet 结果集</td><td>next() 向下移动一行。没有下一行的场合返回 false</td></tr><tr><td></td><td>previous() 向上移动一行。没有上一行的场合返回 false</td></tr><tr><td></td><td>getXXX(int)、getXXX(name) 返回 int 列 &#x2F; name 列的值</td></tr><tr><td></td><td>getObject(int)、getObject(name) 返回 int 列 &#x2F; name 列的值</td></tr></tbody></table><h2 id="JDBC-API"><a href="#JDBC-API" class="headerlink" title="JDBC API"></a>JDBC API</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310151613022.png"></p><h2 id="JDBCUtils"><a href="#JDBCUtils" class="headerlink" title="JDBCUtils"></a>JDBCUtils</h2><p>JDBCUtils：JDBC 的工具类</p><p>实际操作中，获取连接 和 释放资源 操作经常使用。可以把这些操作封装成工具类 JDBCUtils</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310151637985.png"></p><h1 id="事务和批处理"><a href="#事务和批处理" class="headerlink" title="事务和批处理"></a>事务和批处理</h1><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务：JDBC 程序中，当一个 <code>Connection</code> 对象创建时，默认情况下会自动提交事务。为了让多个 SQL 语句一体执行，需要使用事务。</p><ol><li>JDBC程序中当一个Connection对象创建时，默认情况下是自动提交事务:每次执行一个SQL语句时，如果执行成功，就会向数据库自动提交，而不能回滚。</li><li>JDBC程序中为了让多个SQL语句作为一个整体执行，需要使用事务</li><li>调用 Connection 的 setAutoCommit ( false ) 可以取消自动提交事务</li><li>在所有的SQL语句都成功执行后，调用 Connection 的 commit() 方法提交事务</li><li>在其中某个操作失败或出现异常时，调用 rollback() 方法回滚事务</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Connection connection = null;</span><br><span class="line">try &#123;</span><br><span class="line">    connection = JDBCUtils.getConnection();</span><br><span class="line">    connection.setAutoCommit(false);//[1] 取消自动提交事务</span><br><span class="line">    String sql = &quot;insert into actor values(9, &#x27;赫尔萝茵&#x27;)&quot;;</span><br><span class="line">    PreparedStatement preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">    preparedStatement.executeUpdate();</span><br><span class="line">    sql = &quot;delete from actor where name = &#x27;萝茵&#x27; and id &gt; (select * from (select min(id) from actor where name = &#x27;萝茵&#x27;) a)&quot;;</span><br><span class="line">    //[2]</span><br><span class="line">    preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">    preparedStatement.executeUpdate();</span><br><span class="line">    connection.commit();//[3] 提交事务</span><br><span class="line">    System.out.println(&quot;complete&quot;);</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">    System.out.println(&quot;fail&quot;);</span><br><span class="line">    System.out.println(e);</span><br><span class="line">    connection.rollback();//[4] 回滚事务</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    connection.close();//[5] 关闭连接</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>取消自动提交事务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection.setAutoCommit(false);</span><br></pre></td></tr></table></figure></li><li><p>这是一个 SQL 语句。表示在 name &#x3D; 萝茵 的数据中只保留 id 最小的一条。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete from actor where name = &#x27;萝茵&#x27; and id &gt; (select * from (select min(id) from actor where name = &#x27;萝茵&#x27;) a)</span><br><span class="line">MYSQL</span><br></pre></td></tr></table></figure><p>正常写法会提示不能同表查询（在 MySQL 中，不能在同一语句中先 select 出同一表中的某些值，再 update 这个表）。使用一个额外的 select 过渡就解决了这个问题。特此记录。</p></li><li><p>提交事务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connection.commit();</span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure></li><li><p>回滚事务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connection.rollback();</span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure><p>写在 catch 里。这样，语句错误抛出异常的场合会执行到这句话。</p></li><li><p>关闭连接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connection.close();</span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure><p>写在 finally 里。这样，执行完语句总会关闭连接。这很好。</p></li></ol><h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><p>批处理：把多条语句一次性提交给数据库进行批量处理。这样做比单独提交更有效率。</p><p>基本介绍：</p><ol><li><p>当需要成批插入或者更新记录时。可以采用Java的批量更新机制，这一机制允</p></li><li><p>许多条语句次性提交给数据库批量处理。通常情况下比单独提交处理更有效率。</p></li><li><p>JDBC的批量处理语句包括下面方法:</p><p>addBatch(:添加需要批量处理的SQL语句或参数</p><p>executeBatch(:执行批量处理语句;</p><p>clearBatch():清空批处理包的语句</p></li><li><p>JDBC连接MySQL时，如果要使用批处理功能，请再url中加参数?rewriteBatchedStatements&#x3D; true</p></li><li><p>批处理往往和PreparedStatement-起搭配使用，可以既减少编译次数，又减少运行次数，效率大大提高</p></li></ol> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//[0] 事前准备</span><br><span class="line">Connection connection = JDBCUtils.getConnection();</span><br><span class="line">String sql = &quot;insert into test1 values(?)&quot;;</span><br><span class="line">PreparedStatement ps = connection.prepareStatement(sql);</span><br><span class="line">for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">ps.setInt(1,i);</span><br><span class="line">ps.addBatch();//[1]</span><br><span class="line">&#125;</span><br><span class="line">ps.executeBatch();//[2]</span><br><span class="line">JDBCUtils.close(connection, ps, null);JAVA</span><br></pre></td></tr></table></figure><ol><li><p>修改配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true</span><br><span class="line">...PROPERTIES</span><br></pre></td></tr></table></figure></li><li><p>添加需要批量处理的 SQL 语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">preparedStatement.addBatch();</span><br></pre></td></tr></table></figure></li><li><p>执行批量处理语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">preparedStatement.executeBatch();</span><br></pre></td></tr></table></figure></li><li><p>（前面的例子里没有这句）清空批处理包的语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">preparedStatement.clearBatch();</span><br></pre></td></tr></table></figure></li></ol><h2 id="批处理源码"><a href="#批处理源码" class="headerlink" title="批处理源码"></a>批处理源码</h2><h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h1><p><strong>传统获取 Connection 方法的问题：</strong></p><ol><li>传统的 JDBC 数据库连接使用 DriverManager 获取，每次建立连接都会把 Connection 载入内存，再进行身份验证。每次连接都会重复验证请求，这样会占用过多系统资源，容易造成服务器崩溃。</li><li>每次连接，使用完毕后必须断开。如果不断开操作，会致使数据库内存泄漏，最终不得不重启数据库。</li><li>传统连接方式不能控制创建的连接数量。连接数量过多的场合，也可能导致内存泄漏，MySQL 崩溃</li></ol><p><strong>因此，需要使用连接池技术</strong></p><p>连接池基本介绍：</p><ol><li>预先在缓冲池放入一定数量的连接。需要建立数据库连接时，从缓冲池中取出一个连接。使用完后，把该连接放回缓冲池。</li><li>数据库连接池负责分配、管理和释放数据库连接。其允许应用程序重复使用一个现有的数据库连接，而非建立新的连接。</li><li>当请求连接的数量超过最大数量，这些连接请求会被加入等待队列。</li></ol><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310151731041.png"></p><p><strong>数据库连接池种类：</strong></p><p>JDBC 数据库连接池使用 javax.sql.DataSource 表示。DataSource 是一个接口，通常由第三方提供实现（提供 jar 包）</p><ul><li>C3P0：速度稍慢，稳定性好，但是速度再慢也不是传统 JDBC 能比得上的</li><li>DBCP：速度稍快，稳定性差</li><li>Proxool：可以监控连接池状态，稳定性稍差</li><li>BoneCP：速度快</li><li>Druid：阿里提供的数据库连接池，集 DBCP、C3P0、Proxool 优点于一身</li></ul><p>数据库连接池只是做了个包装，底层还是需要使用到 driver 驱动</p><h2 id="德鲁伊使用"><a href="#德鲁伊使用" class="headerlink" title="德鲁伊使用"></a>德鲁伊使用</h2><p><strong>使用 Druid 的前置工作：</strong></p><ol><li><p><a href="https://github.com/alibaba/druid">Druid jar 包下载</a></p><p>……这个链接打不开的话，试试 <a href="https://repo1.maven.org/maven2/com/alibaba/druid/">这个</a></p></li><li><p>配置 jar 包</p></li><li><p>加入配置文件</p><p><strong>durid.properties：</strong>配置文件，文件名任意，放在 <code>src/druid.properties</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">driverClassName=com.mysql.cj.jdbc.Driver</span><br><span class="line">url=jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true</span><br><span class="line">username=root</span><br><span class="line">password=123456</span><br><span class="line">initialSize=10</span><br><span class="line">minIdle=5</span><br><span class="line">maxActive=20</span><br><span class="line">maxWait=5000</span><br></pre></td></tr></table></figure><p>minIdle：最小空闲数，一直没有人用的时候至少维持这么多个链接<br>maxActive：最大活跃数，使用链接的上限<br>maxWait：最大等待时间，超过这个时间认为繁忙，放弃这次链接，换下一个</p></li></ol><p>使用 Druid：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* [1] 加载配置文件 */</span><br><span class="line">Properties properties = new Properties();</span><br><span class="line">properties.load(new FileInputStream(&quot;src\\Druid.properties&quot;));</span><br><span class="line">/* [2] 初始化数据池 */</span><br><span class="line">DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">/* [3] 获取连接 */</span><br><span class="line">Connection connection = dataSource.getConnection();</span><br><span class="line">...</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure><ol><li><p>初始化数据池</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);</span><br></pre></td></tr></table></figure></li><li><p>初始化数据池：需要讲一下关闭链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection.close();</span><br></pre></td></tr></table></figure><p><code>Connection</code> 是一个接口，对于方法 <code>close()</code>，不同供应商有不同实现方法。</p><p>原生的 <code>MySQL</code> 的实现方法是关闭连接，而这些连接池的实现方法是取消引用（放回连接池）。</p></li></ol><h2 id="DruidUtils"><a href="#DruidUtils" class="headerlink" title="DruidUtils"></a>DruidUtils</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class JDBCUtilsByDruid &#123;</span><br><span class="line">    private static DataSource ds;</span><br><span class="line">    </span><br><span class="line">    //在静态代码块完成 ds初始化</span><br><span class="line">    static &#123;</span><br><span class="line">        Properties properties = new Properties();</span><br><span class="line">        try &#123;</span><br><span class="line">            properties.load(new FileInputStream(&quot;src\\druid.properties&quot;));</span><br><span class="line">            ds = DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //编写getConnection方法</span><br><span class="line">    public static Connection getConnection() throws SQLException &#123;</span><br><span class="line">        return ds.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //关闭连接, 老师再次强调： 在数据库连接池技术中，close 不是真的断掉连接</span><br><span class="line">    //而是把使用的Connection对象放回连接池</span><br><span class="line">    public static void close(ResultSet resultSet, Statement statement, Connection connection) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (resultSet != null) &#123;</span><br><span class="line">                resultSet.close();</span><br><span class="line">            &#125;</span><br><span class="line">            if (statement != null) &#123;</span><br><span class="line">                statement.close();</span><br><span class="line">            &#125;</span><br><span class="line">            if (connection != null) &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Apache-DbUtils"><a href="#Apache-DbUtils" class="headerlink" title="Apache - DbUtils"></a>Apache - DbUtils</h1><p>JDBC 传统方法的不足：</p><ol><li>结果集和连接是关联的。在连接关闭后，就不能使用结果集。</li><li>结果集只能使用一次，这样不便于数据管理</li><li>使用返回信息不方便</li></ol><p>解决思想：</p><ul><li><p>土方法：创建一个类，其属性与表格的列一一对应。将数据遍历并读取到一个个类对象中，再将这些类对象放置到集合中。这样，就得到了一个与表格数据关联的数据集合。</p></li><li><p>使用 <code>DbUtils</code>：</p><ol><li><p>前置操作：</p><p><a href="https://commons.apache.org/proper/commons-dbutils/download_dbutils.cgi">获取 jar 包</a>，并完成配置</p><p>得到连接 <code>Connection connection</code>，创建数据类（这里是 <code>SQL_Data</code>）</p></li><li><p>执行相关方法，返回结果集</p><ol><li><ul><li><p><code>queryRunner.query</code> 方法：执行 SQL 语句，把得到的 <code>ResultSet</code> 封装到 List 集合。这个方法会自动关闭获得的 <code>ResultSet</code>，所以不会造成资源泄漏</p></li><li><p><code>connection</code>：前置操作中得到的连接</p></li><li><p><code>sql</code>：SQL 语句</p></li><li><p><code>new BeanListHander&lt;&gt;(SQL_Data.class)</code>：利用反射机制，将数据封装到 <code>SQL_Data</code> 对象中</p></li><li><p><code>&quot;id&quot;, 1</code>：给 SQL 语句中的 <code>?</code> 赋值。因为是可变参数，可以写多个，如：<code>queryRunner.query(connection, sql, new BeanListHandler&lt;&gt;(SQL_Data.class), &quot;id&quot;, 1, &quot;name&quot;, &quot;识之律者&quot;);</code></p><p>……这里，可变参数也包含列名的场合，筛选似乎会失效。还不知道原理。特此记录。</p></li></ul></li><li><p>此时只需要关闭 <code>Connection</code></p><p><code>query()</code> 方法已经关闭了 <code>ResultSet</code> 和 <code>PreparedStatement</code></p></li></ol></li></ol></li></ul><p><code>commons-DbUtils</code>：是 Apache 组织提供的一个开源的 JDBC 工具库。它是对 JDBC 的封装。使用 dbutils 能极大简化 JDBC 编码的工作量</p><p><strong>DbUtils 的常用类：</strong></p><ul><li><code>QueryRunner</code> 类：封装了 SQL 的执行。是线程安全的，可以实现增、删、改、查、批处理操作</li><li><code>ResultSetHandler</code> 接口：用于处理 <code>ResultSet</code>，按照需求将数据转化为其他形式</li></ul><p><strong>DbUtils 的常用方法：</strong></p><ul><li>ArrayHandler：把结果集中的第一行数据转成对象数组。</li><li>ArrayListHandler：把结果集中的每一-行数据都转成一 个数组，再存放到List中。</li><li>BeanHandler：将结果集中的第一-行数据封装到- 个对应的JavaBean实例中。</li><li>BeanListHandler：将结果集中的每一行数据都封装到一 个对应的JavaBean实例中，存放到List里。</li><li>ColumnListHandler：将结果集中某一列的数据存放到List中。</li><li>KeyedHandler(name)：将结果集中的每行数据都封装到Map里，再把这些map再存到一个map里，其key为指定的key。</li><li>MapHandler：将结果集中的第一行数据封装到一 个Map里，key是列名， value就是对应的值。</li><li>MapListHandler：将结果集中的每一-行数据都封装到一 个Map里，然后再存放到List</li></ul><h2 id="Apache-DbUtils-常用方法"><a href="#Apache-DbUtils-常用方法" class="headerlink" title="Apache-DbUtils 常用方法"></a>Apache-DbUtils 常用方法</h2><ul><li><p><code>queryRunner.update(connection, sql, ...)</code>：DML 语句。增删改。</p><p>后面传入可变参数，用于给 SQL 语句中的 <code>?</code> 赋值</p><p>返回值 int 代表被影响的行数。</p></li><li><p><code>queryRunner.query(connection, sql, ResultSetHandler, ...)</code>：查询。</p><p>后面传入可变参数，用于给 SQL 语句中的 <code>?</code> 赋值</p><p>关于 <code>ResultSetHandler</code>：</p><ul><li>传入 <code>new BeanListHander&lt;&gt;(SQL_Data.class)</code>：返回多行多列。这个场合，用 <code>List</code> 接收返回值。</li><li>传入 <code>new BeanHandler&lt;&gt;(SQL_Data.class)</code>：返回单行。这个场合，用 <code>SQL_Data data</code> 接收返回值。</li><li>传入 <code>new ScalarHander&lt;&gt;()</code>：返回单行单列。这个场合，用 <code>Object</code> 接收返回值。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310151935013.png"></p><h2 id="表和-JavaBean-的对应关系"><a href="#表和-JavaBean-的对应关系" class="headerlink" title="表和 JavaBean 的对应关系"></a>表和 JavaBean 的对应关系</h2><table><thead><tr><th>表类型</th><th>JavaBean类型</th></tr></thead><tbody><tr><td>int、samllint……</td><td>Integer</td></tr><tr><td>char、varchar……</td><td>String</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>date</td><td>java.util.Date</td></tr></tbody></table><h1 id="BasicDao"><a href="#BasicDao" class="headerlink" title="BasicDao"></a>BasicDao</h1><p>apache- dbutils + Druid简化了JDBC开发，但还有不足:</p><ol><li>SQL语句是固定，不能通过参数传入，通用性不好，需要进行改进，更方便执行增删改查</li><li>对于select操作，如果有返回值，返回类型不能固定，<br> 需要使用泛型</li><li>将来的表很多，业务需求复杂，不可能只靠一个Java类完成</li></ol><p>将这些表的公共部分抽出，集成为BasicDao</p><p>DAO：数据访问对象（data access object）</p><ol><li><p>我们把通用的和数据库交互的操作封装到一个通用类中，称为 BasicDAO。</p></li><li><p>在 BasicDAO 基础上，每张表对应一个特化的 DAO（继承 BasicDAO），从而更好地完成功能。</p><p>比如：Data 表 -&gt; Data.java 类（JavaBean）-&gt; DataDAO.java</p></li></ol><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310152122800.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDBC Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC</title>
      <link href="/2023/10/08/SSM-SpringMVC/"/>
      <url>/2023/10/08/SSM-SpringMVC/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><p>SpringMVC是隶属于Spring框架的一部分，主要是用来进行Web开发，是对Servlet进行了封装。</p><p>SpringMVC是处于Web层的框架，所以其主要作用就是用来接收前段发过来的请求和数据，然后经过处理之后将处理结果响应给前端，所以如何处理情趣和响应是SpringMVC中非常重要的一块内容。</p><p>REST是一种软件架构风格，可以降低开发的复杂性，提高系统的可伸缩性，后期的应用也是非常广泛。</p><p>对于SpringMVC的学习，<code>最终要达成的目标：</code></p><ol><li>掌握基于SpringMVC获取请求参数和响应JSON数据操作</li><li>熟练应用基于REST风格的请求路径设置与参数传递</li><li>能根据实际业务建立前后端开发通信协议，并进行实现</li><li>基于SSM整合技术开发任意业务模块功能</li></ol><h2 id="SpringMVC概述"><a href="#SpringMVC概述" class="headerlink" title="SpringMVC概述"></a>SpringMVC概述</h2><p>随着互联网的发展，性能慢慢的跟不是需求，所以异步调用慢慢的走到了前台，是现在比较流行的一种处理方式。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310081415019.png"></p><ul><li>因为是异步调用，所以后端不需要返回View视图，将其去除</li><li>前端如果通过异步调用的方式进行交互，后端就需要将返回的数据转换成JSON格式进行返回</li><li>SpringMVC主要负责的就是<ul><li>controller如何接收请求和数据</li><li>如何将请求和数据转发给业务层</li><li>如何将响应数据转换成JSON发挥到前端</li></ul></li><li>SpringMVC是一种基于Java实现MVC模型的轻量级Web框架<ul><li>优点<ul><li>使用简单、开发快捷（相比较于Servlet）</li><li>灵活性强</li></ul></li></ul></li></ul><p>这里说的优点，我们通过下面的讲解与联系慢慢体会</p><h2 id="SpringMVC入门案例"><a href="#SpringMVC入门案例" class="headerlink" title="SpringMVC入门案例"></a>SpringMVC入门案例</h2><p>SpringMVC的制作过程和上述流程几乎是一致的，具体的实现流程是什么?</p><ol><li>创建web工程(Maven结构)</li><li>设置tomcat服务器，加载web工程(tomcat插件)</li><li>导入坐标(SpringMVC+Servlet)</li><li>定义处理请求的功能类(UserController)</li><li>设置请求映射(配置映射关系)</li><li>将SpringMVC设定加载到Tomcat容器中</li></ol><p>案例制作:</p><ol><li><p>创建Maven项目</p><p>这里不是空maven了，选用自带的webapp框架</p></li><li><p>导入所需坐标（SpringMVC+Servlet）和 tomcat 插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--servlet--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--springmvc--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">  &lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">      &lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1&lt;/version&gt;</span><br><span class="line">        &lt;configuration&gt;</span><br><span class="line">          &lt;port&gt;80&lt;/port&gt;</span><br><span class="line">          &lt;path&gt;/&lt;/path&gt;</span><br><span class="line">        &lt;/configuration&gt;</span><br><span class="line">      &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">  &lt;/build&gt;</span><br></pre></td></tr></table></figure></li><li><p>创建SpringMVC控制器类（等同于我们前面做的Servlet）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//定义Controller，使用@Controller定义Bean</span><br><span class="line">@Controller</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    //设置当前访问路径，使用@RequestMapping</span><br><span class="line">    @RequestMapping(&quot;/save&quot;)</span><br><span class="line">    //设置当前对象的返回值类型</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String save()&#123;</span><br><span class="line">        System.out.println(&quot;user save ...&quot;);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;SpringMVC&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>初始化SpringMVC环境（同Spring环境），设定SpringMVC加载对应的Bean</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//创建SpringMVC的配置文件，加载controller对应的bean</span><br><span class="line">@Configuration</span><br><span class="line">//</span><br><span class="line">@ComponentScan(&quot;com.blog.controller&quot;)</span><br><span class="line">public class SpringMvcConfig &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>初始化Servlet容器，加载SpringMVC环境，并设置SpringMVC技术处理的请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//定义一个servlet容器的配置类，在里面加载Spring的配置，继承AbstractDispatcherServletInitializer并重写其方法</span><br><span class="line">public class ServletContainerInitConfig extends AbstractDispatcherServletInitializer &#123;</span><br><span class="line">    //加载SpringMvc容器配置</span><br><span class="line">    protected WebApplicationContext createServletApplicationContext() &#123;</span><br><span class="line">        AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();</span><br><span class="line">        context.register(SpringMvcConfig.class);</span><br><span class="line">        return context;</span><br><span class="line">    &#125;</span><br><span class="line">    //设置哪些请求归SpringMvc处理</span><br><span class="line">    protected String[] getServletMappings() &#123;</span><br><span class="line">        //所有请求都交由SpringMVC处理</span><br><span class="line">        return new String[]&#123;&quot;/&quot;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //加载Spring容器配置</span><br><span class="line">    protected WebApplicationContext createRootApplicationContext() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>访问<code>http://localhost:8080/save</code></p></li></ol><p>注意事项</p><ul><li>SpringMVC是基于Spring的，在pom.xml只导入了<code>spring-webmvc</code>jar包的原因是它会自动依赖spring相关坐标</li><li><code>AbstractDispatcherServletInitializer</code>类是SpringMVC提供的快速初始化Web3.0容器的抽象类</li><li>AbstractDispatcherServletInitializer 提供了三个接口方法供用户实现<ul><li><code>createServletApplicationContext</code>方法，创建Servlet容器时，加载SpringMVC对应的bean并放入<code>WebApplicationContext</code>对象范围中，而<code>WebApplicationContext</code>的作用范围为<code>ServletContext</code>范围，即整个web容器范围</li><li><code>getServletMappings</code>方法，设定SpringMVC对应的请求映射路径，即SpringMVC拦截哪些请求</li><li><code>createRootApplicationContext</code>方法，如果创建Servlet容器时需要加载非SpringMVC对应的bean，使用当前方法进行，使用方式和<code>createServletApplicationContext</code>相同。</li></ul></li><li><code>createServletApplicationContext</code>用来加载SpringMVC环境</li><li><code>createRootApplicationContext</code>用来加载Spring环境</li></ul><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>知识点1：<code>@Controller</code></p><table><thead><tr><th align="center">名称</th><th align="center">@Controller</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">类注解</td></tr><tr><td align="center">位置</td><td align="center">SpringMVC控制器类定义上方</td></tr><tr><td align="center">作用</td><td align="center">设定SpringMVC的核心控制器bean</td></tr></tbody></table><p>知识点2：<code>@RequestMapping</code></p><table><thead><tr><th align="center">名称</th><th align="center">@RequestMapping</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">类注解或方法注解</td></tr><tr><td align="center">位置</td><td align="center">SpringMVC控制器类或方法定义上方</td></tr><tr><td align="center">作用</td><td align="center">设置当前控制器方法请求访问路径</td></tr><tr><td align="center">相关属性</td><td align="center">value(默认)，请求访问路径</td></tr></tbody></table><p>知识点3：<code>@ResponseBody</code></p><table><thead><tr><th align="center">名称</th><th align="center">@ResponseBody</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">类注解或方法注解</td></tr><tr><td align="center">位置</td><td align="center">SpringMVC控制器类或方法定义上方</td></tr><tr><td align="center">作用</td><td align="center">设置当前控制器方法响应内容为当前返回值，无需解析</td></tr></tbody></table><h3 id="入门案例小结"><a href="#入门案例小结" class="headerlink" title="入门案例小结"></a>入门案例小结</h3><ul><li>一次性工作<ul><li>创建工程，设置服务器，加载工程</li><li>导入坐标</li><li>创建web容器启动类，加载SpringMVC配置，并设置SpringMVC请求拦截路径</li><li>SpringMVC核心配置类（设置配置类，扫描controller包，加载Controller控制器bean）</li></ul></li><li>多次工作<ul><li>定义处理请求的控制器类</li><li>定义处理请求的控制器方法，并配置映射路径（@RequestMapping）与返回json数据（@ResponseBody）</li></ul></li></ul><h3 id="工作流程解析"><a href="#工作流程解析" class="headerlink" title="工作流程解析"></a>工作流程解析</h3><p>这里将SpringMVC分为两个阶段来分析，分别是<code>启动服务器初始化过程</code>和<code>单次请求过程</code></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310082230497.png"></p><h4 id="启动服务器初始化过程"><a href="#启动服务器初始化过程" class="headerlink" title="启动服务器初始化过程"></a>启动服务器初始化过程</h4><ol><li><p>服务器启动，执行ServletContainerInitConfig类，初始化web容器</p><p>功能类似于web.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ServletContainerInitConfig extends AbstractDispatcherServletInitializer &#123;</span><br><span class="line"></span><br><span class="line">    protected WebApplicationContext createServletApplicationContext() &#123;</span><br><span class="line">        AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();</span><br><span class="line">        context.register(SpringMvcConfig.class);</span><br><span class="line">        return context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected String[] getServletMappings() &#123;</span><br><span class="line">        return new String[]&#123;&quot;/&quot;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected WebApplicationContext createRootApplicationContext() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行createServletApplicationContext方法，创建了WebApplicationContext对象</p><p>该方法加载SpringMVC的配置类SpringMvcConfig来初始化SpringMVC的容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protected WebApplicationContext createServletApplicationContext() &#123;</span><br><span class="line">    AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();</span><br><span class="line">    context.register(SpringMvcConfig.class);</span><br><span class="line">    return context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>加载SpringMvcConfig配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.blog.controller&quot;)</span><br><span class="line">public class SpringMvcConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行@ComponentScan加载对应的bean</p><p>扫描指定包及其子包下所有类上的注解，如Controller类上的<code>@Controller</code>注解</p></li><li><p>加载UserController，每个@RequestMapping的名称对应一个具体的方法</p><p>此时就建立了 <code>/save</code> 和 <code>save()</code>方法的对应关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    @RequestMapping(&quot;/save&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String save()&#123;</span><br><span class="line">        System.out.println(&quot;user save ...&quot;);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;SpringMVC&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行getServletMappings方法，设定SpringMVC拦截请求的路径规则</p><p><code>/</code>代表所拦截请求的路径规则，只有被拦截后才能交给SpringMVC来处理请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected String[] getServletMappings() &#123;</span><br><span class="line">    return new String[]&#123;&quot;/&quot;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="单次请求过程"><a href="#单次请求过程" class="headerlink" title="单次请求过程"></a>单次请求过程</h4><ol><li><p>发送请求<code>http://localhost:8080/save</code></p></li><li><p>web容器发现该请求满足SpringMVC拦截规则，将请求交给SpringMVC处理</p></li><li><p>解析请求路径&#x2F;save</p></li><li><p>由&#x2F;save匹配执行对应的方法save()</p><p>上面的第5步已经将请求路径和方法建立了对应关系，通过<code>/save</code>就能找到对应的<code>save()</code>方法</p></li><li><p>执行<code>save()</code></p></li><li><p>检测到有<code>@ResponseBody</code>直接将<code>save()</code>方法的返回值作为响应体返回给请求方</p></li></ol><h3 id="Bean加载控制"><a href="#Bean加载控制" class="headerlink" title="Bean加载控制"></a>Bean加载控制</h3><p>入门案例的内容已经做完了，在入门案例中我们创建过一个<code>SpringMvcConfig</code>的配置类，在之前学习Spring的时候也创建过一个配置类<code>SpringConfig</code>。这两个配置类都需要加载资源，那么它们分别都需要加载哪些内容?</p><p> 我们先来回顾一下项目结构<br><code>com.blog</code>下有<code>config</code>、<code>controller</code>、<code>service</code>、<code>dao</code>这四个包</p><p>config目录存入的是配置类，写过的配置类有:</p><ul><li>ServletContainersInitConfig</li><li>SpringConfig</li><li>SpringMvcConfig</li><li>JdbcConfig</li><li>MybatisConfig</li></ul><p>controller目录存放的是<code>SpringMVC</code>的<code>controller</code>类</p><p>service目录存放的是<code>service</code>接口和实现类</p><p>dao目录存放的是<code>dao/Mapper</code>接口</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310082239376.png"></p><p>controller、service和dao这些类都需要被容器管理成bean对象，那么到底是该让<code>SpringMVC</code>加载还是让<code>Spring</code>加载呢?</p><ul><li>SpringMVC控制的bean<ul><li>表现层bean,也就是<code>controller</code>包下的类</li></ul></li><li>Spring控制的bean<ul><li>业务bean(<code>Service</code>)</li><li>功能bean(<code>DataSource</code>,<code>SqlSessionFactoryBean</code>,<code>MapperScannerConfigurer</code>等)</li></ul></li></ul><p>分析清楚谁该管哪些bean以后，接下来要解决的问题是如何让<code>Spring</code>和<code>SpringMVC</code>分开加载各自的内容。</p><h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>对于上面的问题，解决方案也比较简单</p><ul><li>加载Spring控制的bean的时候，<code>排除掉</code>SpringMVC控制的bean</li></ul><p>那么具体该如何实现呢？</p><ul><li>方式一：Spring加载的bean设定扫描范围<code>com.blog</code>，排除掉<code>controller</code>包内的bean</li><li>方式二：Spring加载的bean设定扫描范围为精确扫描，具体到<code>service</code>包，<code>dao</code>包等</li><li>方式三：不区分Spring与SpringMVC的环境，加载到同一个环境中(<code>了解即可</code>)</li></ul><h4 id="设置bean加载控制"><a href="#设置bean加载控制" class="headerlink" title="设置bean加载控制"></a>设置bean加载控制</h4><p>运行App运行类，如果Spring配置类扫描到了UserController类，则会正常输出，否则将报错<br>当前配置环境下，将正常输出</p><p>方案一：修改Spring配置类，设定扫描范围为精准范围</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&#123;&quot;com.blog.dao&quot;,&quot;com.blog.service&quot;&#125;)</span><br><span class="line">public class SpringConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行App运行类，报错<code>NoSuchBeanDefinitionException</code>，说明Spring配置类没有扫描到UserController，目的达成</p><p>方案二：修改Spring配置类，设定扫描范围为com.blog，排除掉controller包中的bean</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">@Configuration</span><br><span class="line">@ComponentScan(value = &quot;com.blog&quot;,</span><br><span class="line">    excludeFilters = @ComponentScan.Filter(</span><br><span class="line">            type = FilterType.ANNOTATION,</span><br><span class="line">            classes = Controller.class</span><br><span class="line">    ))</span><br><span class="line">public class SpringConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>excludeFilters属性：设置扫描加载bean时，排除的过滤规则</li><li>type属性：设置排除规则，当前使用按照bean定义时的注解类型进行排除<ul><li>ANNOTATION：按照注解排除</li><li>ASSIGNABLE_TYPE:按照指定的类型过滤</li><li>ASPECTJ:按照Aspectj表达式排除，基本上不会用</li><li>REGEX:按照正则表达式排除</li><li>CUSTOM:按照自定义规则排除</li></ul></li><li>classes属性：设置排除的具体注解类，当前设置排除<code>@Controller</code>定义的bean</li></ul><p>运行程序之前，我们还需要把<code>SpringMvcConfig</code>配置类上的<code>@ComponentScan</code>注解注释掉，否则不会报错，将正常输出</p><ul><li>出现问题的原因是<ul><li>Spring配置类扫描的包是<code>com.blog</code></li><li>SpringMVC的配置类，<code>SpringMvcConfig</code>上有一个<code>@Configuration</code>注解，也会被Spring扫描到</li><li>SpringMvcConfig上又有一个<code>@ComponentScan</code>，把controller类又给扫描进来了</li><li>所以如果不把<code>@ComponentScan</code>注释掉，Spring配置类将Controller排除，但是因为扫描到SpringMVC的配置类，又将其加载回来，演示的效果就出不来</li><li>解决方案，也简单，把SpringMVC的配置类移出Spring配置类的扫描范围即可。</li></ul></li></ul><p>运行程序，同样报错<code>NoSuchBeanDefinitionException</code>，目的达成</p><p>最后一个问题，有了Spring的配置类，要想在tomcat服务器启动将其加载，我们需要修改ServletContainersInitConfig</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class ServletContainerInitConfig extends AbstractDispatcherServletInitializer &#123;</span><br><span class="line">    //加载SpringMvc配置</span><br><span class="line">    protected WebApplicationContext createServletApplicationContext() &#123;</span><br><span class="line">        AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();</span><br><span class="line">        context.register(SpringMvcConfig.class);</span><br><span class="line">        return context;</span><br><span class="line">    &#125;</span><br><span class="line">    //设置哪些请求归SpringMvc处理</span><br><span class="line">    protected String[] getServletMappings() &#123;</span><br><span class="line">        return new String[]&#123;&quot;/&quot;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //加载Spring容器配置</span><br><span class="line">    protected WebApplicationContext createRootApplicationContext() &#123;</span><br><span class="line">        AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();</span><br><span class="line">        context.register(SpringConfig.class);</span><br><span class="line">        return context;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面的<code>ServletContainerInitConfig</code>配置类，Spring还提供了一种更简单的配置方式，可以不用再去创建<code>AnnotationConfigWebApplicationContext</code>对象，不用手动<code>register</code>对应的配置类<br>我们改用继承它的子类<code>AbstractAnnotationConfigDispatcherServletInitializer</code>，然后重写三个方法即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ServletContainerInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer &#123;</span><br><span class="line"></span><br><span class="line">    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        return new Class[]&#123;SpringConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        return new Class[]&#123;SpringMvcConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected String[] getServletMappings() &#123;</span><br><span class="line">        return new String[]&#123;&quot;/&quot;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p>知识点：<code>@ComponentScan</code></p><table><thead><tr><th align="center">名称</th><th align="center">@ComponentScan</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">类注解</td></tr><tr><td align="center">位置</td><td align="center">类定义上方</td></tr><tr><td align="center">作用</td><td align="center">设置spring配置类扫描路径，用于加载使用注解格式定义的bean</td></tr><tr><td align="center">相关属性</td><td align="center">excludeFilters:排除扫描路径中加载的bean,需要指定类别(type)和具体项(classes) includeFilters:加载指定的bean，需要指定类别(type)和具体项(classes)</td></tr></tbody></table><h2 id="请求与响应"><a href="#请求与响应" class="headerlink" title="请求与响应"></a>请求与响应</h2><p>SpringMVC是web层的框架，主要的作用是接收请求、接收数据、响应结果。<br>所以这部分是学习SpringMVC的重点内容，这里主要会讲解四部分内容:</p><ul><li>请求映射路径</li><li>请求参数</li><li>日期类型参数传递</li><li>响应JSON数据</li></ul><h3 id="设置请求映射路径"><a href="#设置请求映射路径" class="headerlink" title="设置请求映射路径"></a>设置请求映射路径</h3><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><ol><li><p>创建一个Maven项目</p></li><li><p>导入坐标，这里暂时只导<code>servlet</code>和<code>springmvc</code>的就行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--servlet--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!--springmvc--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>编写UserController和BookController</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/save&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String save()&#123;</span><br><span class="line">        System.out.println(&quot;user save ..&quot;);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;user save&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/delete&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String delete()&#123;</span><br><span class="line">        System.out.println(&quot;user delete ..&quot;);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;user delete&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class BookController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/save&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String save()&#123;</span><br><span class="line">        System.out.println(&quot;book save ..&quot;);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;book module&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建<code>SpringMvcConfig</code>配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.blog.controller&quot;)</span><br><span class="line">public class SpringMvcConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建<code>ServletContainersInitConfig</code>类，初始化web容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer &#123;</span><br><span class="line">    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        return new Class[0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        return new Class[]&#123;SpringMvcConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected String[] getServletMappings() &#123;</span><br><span class="line">        return new String[]&#123;&quot;/&quot;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>直接启动Tomcat服务器，会报错</p><blockquote><p>com.blog.controller.UserController#save()<br>to { &#x2F;save}: There is already ‘bookController’ bean method<br>com.blog.controller.BookController#save() mapped.</p></blockquote><p>从错误信息可以看出:</p><ul><li><code>UserController</code>有一个save方法，访问路径为<code>http://localhost/save</code></li><li><code>BookController</code>也有一个save方法，访问路径为<code>http://localhost/save</code></li><li>当访问<code>http://localhost/save</code>的时候，到底是访问<code>UserController</code>还是<code>BookController</code>?</li></ul></li></ol><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>团队多人开发，每人设置不同的请求路径，冲突问题该如何解决?</p><ul><li>解决思路:为不同模块设置模块名作为请求路径前置<ul><li>对于Book模块的save,将其访问路径设置<code>http://localhost/book/save</code></li><li>对于User模块的save,将其访问路径设置<code>http://localhost/user/save</code></li></ul></li></ul><p>这样在同一个模块中出现命名冲突的情况就比较少了。</p><h4 id="设置映射路径"><a href="#设置映射路径" class="headerlink" title="设置映射路径"></a>设置映射路径</h4><ol><li><p>修改Controller</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/user/save&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String save()&#123;</span><br><span class="line">        System.out.println(&quot;user save ..&quot;);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;user save&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/user/delete&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String delete()&#123;</span><br><span class="line">        System.out.println(&quot;user delete ..&quot;);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;user delete&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class BookController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/book/save&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String save()&#123;</span><br><span class="line">        System.out.println(&quot;book save ..&quot;);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;book module&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题是解决了，但是每个方法前面都需要进行修改，写起来比较麻烦而且还有很多重复代码，如果&#x2F;user后期发生变化，所有的方法都需要改，耦合度太高。</p></li><li><p>优化路径配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/user&quot;)</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/save&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String save()&#123;</span><br><span class="line">        System.out.println(&quot;user save ..&quot;);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;user save&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/delete&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String delete()&#123;</span><br><span class="line">        System.out.println(&quot;user delete ..&quot;);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;user delete&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/book&quot;)</span><br><span class="line">public class BookController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/save&quot;)s</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String save()&#123;</span><br><span class="line">        System.out.println(&quot;book save ..&quot;);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;book module&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:</p><ul><li>当类上和方法上都添加了<code>@RequestMapping</code>注解，前端发送请求的时候，要和两个注解的value值相加匹配才能访问到。</li><li><code>@RequestMapping</code>注解value属性前面加不加<code>/</code>都可以</li></ul></li></ol><h3 id="五种类型参数传递"><a href="#五种类型参数传递" class="headerlink" title="五种类型参数传递"></a>五种类型参数传递</h3><p>前面我们已经能够使用GET或POST来发送请求和数据，所携带的数据都是比较简单的数据，接下来在这个基础上，我们来研究一些比较复杂的参数传递，常见的参数种类有</p><ul><li>普通类型</li><li>POJO类型参数</li><li>嵌套POJO类型参数</li><li>数组类型参数</li><li>集合类型参数</li></ul><p>下面我们就来挨个学习这五种类型参数如何发送，后台如何接收</p><h4 id="普通类型"><a href="#普通类型" class="headerlink" title="普通类型"></a>普通类型</h4><p>普通参数：url地址传参，地址参数名与形参变量名相同，定义形参即可接收参数。</p><ul><li>发送请求与参数：<code>localhost:8080/user/commonParam?name=Helsing&amp;age=1024</code></li><li>后台接收参数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/user&quot;)</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/commonParam&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String commonParam(String name,int age)&#123;</span><br><span class="line">        System.out.println(&quot;普通参数传递name --&gt; &quot; + name);</span><br><span class="line">        System.out.println(&quot;普通参数传递age --&gt; &quot; + age);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;commonParam&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果形参与地址参数名不一致该如何解决?例如地址参数名为<code>username</code>，而形参变量名为<code>name</code>，因为前端给的是<code>username</code>，后台接收使用的是<code>name</code>,两个名称对不上，会导致接收数据失败</p><p>解决方案：使用@RequestParam注解</p><ul><li><p>发送请求与参数：<code>localhost:8080/user/commonParam?username=Helsing&amp;age=1024</code></p></li><li><p>后台接收参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;/user&quot;)</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/commonParam&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String commonParam(@RequestParam(&quot;username&quot;) String name, int age)&#123;</span><br><span class="line">        System.out.println(&quot;普通参数传递name --&gt; &quot; + name);</span><br><span class="line">        System.out.println(&quot;普通参数传递age --&gt; &quot; + age);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;commonParam&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="POJO数据类型"><a href="#POJO数据类型" class="headerlink" title="POJO数据类型"></a>POJO数据类型</h4><p>“Plain Old Java Object”“简单java对象”。POJO的内在含义是指那些没有从任何类继承、也没有实现任何接口，更没有被其它框架侵入的java对象。</p><p>简单数据类型一般处理的是参数个数比较少的请求，如果参数比较多，那么后台接收参数的时候就比较复杂，这个时候我们可以考虑使用POJO数据类型。</p><ul><li>POJO参数：请求参数名与形参对象属性名相同，定义POJO类型形参即可接收参数</li></ul><p>此时需要使用前面准备好的两个POJO类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public User() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public User(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Address &#123;</span><br><span class="line">    private String province;</span><br><span class="line">    private String city;</span><br><span class="line"></span><br><span class="line">    public String getProvince() &#123;</span><br><span class="line">        return province;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setProvince(String province) &#123;</span><br><span class="line">        this.province = province;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getCity() &#123;</span><br><span class="line">        return city;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCity(String city) &#123;</span><br><span class="line">        this.city = city;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Address() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Address(String province, String city) &#123;</span><br><span class="line">        this.province = province;</span><br><span class="line">        this.city = city;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Address&#123;&quot; +</span><br><span class="line">                &quot;province=&#x27;&quot; + province + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, city=&#x27;&quot; + city + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送请求和参数：<code>localhost:8080/user/pojoParam?name=Helsing&amp;age=1024</code>。后台接收参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//POJO参数：请求参数与形参对象中的属性对应即可完成参数传递</span><br><span class="line">@RequestMapping(&quot;/pojoParam&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String pojoParam(User user)&#123;</span><br><span class="line">    System.out.println(&quot;POJO参数传递user --&gt; &quot; + user);</span><br><span class="line">    return &quot;&#123;&#x27;module&#x27;:&#x27;pojo param&#x27;&#125;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意:</p><ul><li>POJO参数接收，前端GET和POST发送请求数据的方式不变。</li><li>请求参数key的名称要和POJO中属性的名称一致，否则无法封装。</li></ul></blockquote><h4 id="嵌套POJO类型"><a href="#嵌套POJO类型" class="headerlink" title="嵌套POJO类型"></a>嵌套POJO类型</h4><p>我们先将之前写的Address类，嵌套在User类中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    private Address address;</span><br><span class="line"></span><br><span class="line">    public Address getAddress() &#123;</span><br><span class="line">        return address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAddress(Address address) &#123;</span><br><span class="line">        this.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public User() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public User(String name, int age, Address address) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &quot;, address=&quot; + address +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嵌套POJO参数：请求参数名与形参对象属性名相同，按照对象层次结构关系即可接收嵌套POJO属性参数</p><p>发送请求和参数：<code>localhost:8080/user/pojoParam?name=Helsing&amp;age=1024&amp;address.province=Beijing&amp;address.city=Beijing</code></p><p>后台接收参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/pojoParam&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String pojoParam(User user)&#123;</span><br><span class="line">    System.out.println(&quot;POJO参数传递user --&gt; &quot; + user);</span><br><span class="line">    return &quot;&#123;&#x27;module&#x27;:&#x27;pojo param&#x27;&#125;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h4><p>举个简单的例子，如果前端需要获取用户的爱好，爱好绝大多数情况下都是多选，如何发送请求数据和接收数据呢?</p><p>数组参数：请求参数名与形参对象属性名相同且请求参数为多个，定义数组类型即可接收参数</p><p>发送请求和参数：<code>localhost:8080/user/arrayParam?hobbies=sing&amp;hobbies=jump&amp;hobbies=rap&amp;hobbies=basketball</code></p><p>后台接收参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/arrayParam&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String arrayParam(String[] hobbies)&#123;</span><br><span class="line">    System.out.println(&quot;数组参数传递user --&gt; &quot; + Arrays.toString(hobbies));</span><br><span class="line">    return &quot;&#123;&#x27;module&#x27;:&#x27;array param&#x27;&#125;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h4><p>数组能接收多个值，那么集合是否也可以实现这个功能呢?</p><p>发送请求和参数：<code>localhost:8080/user/listParam?hobbies=sing&amp;hobbies=jump&amp;hobbies=rap&amp;hobbies=basketball</code></p><p>后台接收参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/listParam&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String listParam(List hobbies) &#123;</span><br><span class="line">    System.out.println(&quot;集合参数传递user --&gt; &quot; + hobbies);</span><br><span class="line">    return &quot;&#123;&#x27;module&#x27;:&#x27;list param&#x27;&#125;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalArgumentException: Cannot generate variable name for non-typed Collection parameter type</span><br></pre></td></tr></table></figure><p>错误原因：SpringMVC将List看做是一个POJO对象来处理，将其创建一个对象并准备把前端的数据封装到对象中，但是List是一个接口无法创建对象，所以报错。</p><p>解决方案是：使用<code>@RequestParam</code>注解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/listParam&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String listParam(@RequestParam List hobbies) &#123;</span><br><span class="line">    System.out.println(&quot;集合参数传递user --&gt; &quot; + hobbies);</span><br><span class="line">    return &quot;&#123;&#x27;module&#x27;:&#x27;list param&#x27;&#125;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解</p><p>@RequestParam</p><table><thead><tr><th align="center">名称</th><th align="center">@RequestParam</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">形参注解</td></tr><tr><td align="center">位置</td><td align="center">SpringMVC控制器方法形参定义前面</td></tr><tr><td align="center">作用</td><td align="center">绑定请求参数与处理器方法形参间的关系</td></tr><tr><td align="center">相关参数</td><td align="center">required：是否为必传参数 defaultValue：参数默认值</td></tr></tbody></table><h3 id="JSON数据传输参数"><a href="#JSON数据传输参数" class="headerlink" title="JSON数据传输参数"></a>JSON数据传输参数</h3><p>现在比较流行的开发方式为异步调用。前后台以异步方式进行交换，传输的数据使用的是JSON，所以前端如果发送的是JSON数据，后端该如何接收?</p><p>对于JSON数据类型，我们常见的有三种:</p><ul><li>json普通数组（[“value1”,“value2”,“value3”,…]）</li><li>json对象（{key1:value1,key2:value2,…}）</li><li>json对象数组（[{key1:value1,…},{key2:value2,…}]）</li></ul><p>下面我们就来学习以上三种数据类型，前端如何发送，后端如何接收</p><h4 id="JSON普通数组"><a href="#JSON普通数组" class="headerlink" title="JSON普通数组"></a>JSON普通数组</h4><ol><li><p>导入坐标</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>开启SpringMVC注解支持<br>使用<code>@EnableWebMvc</code>，在SpringMVC的配置类中开启SpringMVC的注解支持，这里面就包含了将JSON转换成对象的功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.blog.controller&quot;)</span><br><span class="line">//开启json数据类型自动转换</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class SpringMvcConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>PostMan发送JSON数据</p></li><li><p>后台接收参数，参数前添加<code>@RequestBody</code><br>使用<code>@RequestBody</code>注解将外部传递的json数组数据映射到形参的集合对象中作为数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/jsonArrayParam&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String jsonArrayParam(@RequestBody List&lt;String&gt; hobbies) &#123;</span><br><span class="line">    System.out.println(&quot;JSON数组参数传递hobbies --&gt; &quot; + hobbies);</span><br><span class="line">    return &quot;&#123;&#x27;module&#x27;:&#x27;json array param&#x27;&#125;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="JSON对象"><a href="#JSON对象" class="headerlink" title="JSON对象"></a>JSON对象</h4><p>请求和数据的发送:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;:&quot;菲茨罗伊&quot;,</span><br><span class="line">        &quot;age&quot;:&quot;27&quot;,</span><br><span class="line">        &quot;address&quot;:&#123;</span><br><span class="line">            &quot;city&quot;:&quot;萨尔沃&quot;,</span><br><span class="line">            &quot;province&quot;:&quot;外域&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;:&quot;地平线&quot;,</span><br><span class="line">        &quot;age&quot;:&quot;136&quot;,</span><br><span class="line">        &quot;address&quot;:&#123;</span><br><span class="line">            &quot;city&quot;:&quot;奥林匹斯&quot;,</span><br><span class="line">            &quot;province&quot;:&quot;外域&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>接收请求和参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/jsonPojoListParam&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String jsonPojoListParam(@RequestBody List&lt;User&gt; users) &#123;</span><br><span class="line">    System.out.println(&quot;JSON对象数组参数传递user --&gt; &quot; + users);</span><br><span class="line">    return &quot;&#123;&#x27;module&#x27;:&#x27;json pojo list param&#x27;&#125;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>SpringMVC接收JSON数据的实现步骤为:</p><ol><li>导入jackson包</li><li>开启SpringMVC注解驱动，在配置类上添加<code>@EnableWebMvc</code>注解</li><li>使用PostMan发送JSON数据</li><li>Controller方法的参数前添加<code>@RequestBody</code>注解</li></ol><h4 id="注解-1"><a href="#注解-1" class="headerlink" title="注解"></a>注解</h4><p>知识点1：<code>@EnableWebMvc</code></p><table><thead><tr><th align="center">名称</th><th align="center">@EnableWebMvc</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">配置类注解</td></tr><tr><td align="center">位置</td><td align="center">SpringMVC配置类定义上方</td></tr><tr><td align="center">作用</td><td align="center">开启SpringMVC多项辅助功能</td></tr></tbody></table><p>知识点2：<code>@RequestBody</code></p><table><thead><tr><th align="center">名称</th><th align="center">@RequestBody</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">形参注解</td></tr><tr><td align="center">位置</td><td align="center">SpringMVC控制器方法形参定义前面</td></tr><tr><td align="center">作用</td><td align="center">将请求中请求体所包含的数据传递给请求参数，此注解一个处理器方法只能使用一次</td></tr></tbody></table><p><code>@RequestBody</code>与<code>@RequestParam</code>区别</p><ul><li>区别<ul><li><code>@RequestParam</code>用于接收url地址传参，表单传参【application&#x2F;x-www-form-urlencoded】</li><li><code>@RequestBody</code>用于接收json数据【application&#x2F;json】</li></ul></li><li>应用<ul><li>后期开发中，发送json格式数据为主，<code>@RequestBody</code>应用较广</li><li>如果发送非json格式数据，选用<code>@RequestParam</code>接收请求参数</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 框架 MVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/10/07/SSM-Spring04/"/>
      <url>/2023/10/07/SSM-Spring04/</url>
      
        <content type="html"><![CDATA[<hr><hr><h1 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h1><p>事务作用：在数据层保障一系列的数据库操作同成功同失败</p><p>Spring事务作用：在数据层或业务层保障一系列的数据库操作同成功同失败</p><p>数据层有事务我们可以理解，为什么业务层也需要处理事务呢？举个简单的例子</p><ul><li>转账业务会有两次数据层的调用，一次是加钱一次是减钱</li><li>把事务放在数据层，加钱和减钱就有两个事务</li><li>没办法保证加钱和减钱同时成功或者同时失败</li><li>这个时候就需要将事务放在业务层进行处理。</li></ul><p>Spring为了管理事务，提供了一个平台事务管理器<code>PlatformTransactionManager</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface PlatformTransactionManager extends TransactionManager &#123;</span><br><span class="line">    TransactionStatus getTransaction(@Nullable TransactionDefinition var1) throws TransactionException;</span><br><span class="line"></span><br><span class="line">    void commit(TransactionStatus var1) throws TransactionException;</span><br><span class="line"></span><br><span class="line">    void rollback(TransactionStatus var1) throws TransactionException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>commit是用来提交事务，rollback是用来回滚事务。</p><p>PlatformTransactionManager只是一个接口，Spring还为其提供了一个具体的实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class DataSourceTransactionManager extends AbstractPlatformTransactionManager implements ResourceTransactionManager, InitializingBean &#123;</span><br><span class="line">    @Nullable</span><br><span class="line">    private DataSource dataSource;</span><br><span class="line">    private boolean enforceReadOnly;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从名称上可以看出，我们只需要给它一个DataSource对象，它就可以帮你去在业务层管理事务。其内部采用的是JDBC的事务。所以说如果你持久层采用的是JDBC相关的技术，就可以采用这个事务管理器来管理你的事务。而Mybatis内部采用的就是JDBC的事务，所以后期我们Spring整合Mybatis就采用的这个<code>DataSourceTransactionManager</code>事务管理器。</p><h2 id="转账案例–需求分析"><a href="#转账案例–需求分析" class="headerlink" title="转账案例–需求分析"></a>转账案例–需求分析</h2><p>接下来通过一个案例来学习下Spring是如何来管理事务的。</p><p>先来分析下需求:</p><ul><li>需求: 实现任意两个账户间转账操作</li><li>需求微缩: A账户减钱，B账户加钱</li></ul><p>为了实现上述的业务需求，我们可以按照下面步骤来实现下:</p><ol><li>数据层提供基础操作，指定账户减钱（outMoney），指定账户加钱（inMoney）</li><li>业务层提供转账操作（transfer），调用减钱与加钱的操作</li><li>提供2个账号和操作金额执行转账操作</li><li>基于Spring整合MyBatis环境搭建上述操作</li></ol><h3 id="转账案例–环境搭建"><a href="#转账案例–环境搭建" class="headerlink" title="转账案例–环境搭建"></a>转账案例–环境搭建</h3><ol><li><p>准备数据表<br>Tom和Jerry初始金额都是1000</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE spring_db CHARACTER SET utf8;</span><br><span class="line">USE spring_db;</span><br><span class="line">CREATE TABLE tbl_account(</span><br><span class="line">    id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    NAME VARCHAR(35),</span><br><span class="line">    money DOUBLE</span><br><span class="line">);</span><br><span class="line">INSERT INTO tbl_account(`name`,money) VALUES(&#x27;Tom&#x27;,1000),(&#x27;Jerry&#x27;,1000);</span><br></pre></td></tr></table></figure></li><li><p>创建项目导入jar包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.16&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.5.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.46&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>根据表创建模型类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class Account &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String name;</span><br><span class="line">    private Double money;</span><br><span class="line"></span><br><span class="line">    public Account() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Account(Integer id, String name, Double money) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Double getMoney() &#123;</span><br><span class="line">        return money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMoney(Double money) &#123;</span><br><span class="line">        this.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Account&#123;&quot; +</span><br><span class="line">                &quot;id=&quot; + id +</span><br><span class="line">                &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, money=&quot; + money +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Dao接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface AccountDao &#123;</span><br><span class="line"></span><br><span class="line">    @Update(&quot;update tbl_account set money = money + #&#123;money&#125; where name = #&#123;name&#125;&quot;)</span><br><span class="line">    void inMoney(@Param(&quot;name&quot;) String name,@Param(&quot;money&quot;) Double money);</span><br><span class="line"></span><br><span class="line">    @Update(&quot;update tbl_account set money = money - #&#123;money&#125; where name = #&#123;name&#125;&quot;)</span><br><span class="line">    void outMoney(@Param(&quot;name&quot;) String name, @Param(&quot;money&quot;) Double money);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Service接口和实现类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface AccountService &#123;    </span><br><span class="line">/**     </span><br><span class="line">* 转账操作     </span><br><span class="line">* @param out 转出方     </span><br><span class="line">* @param in 转入方     </span><br><span class="line">* @param money 金额     </span><br><span class="line">*/    </span><br><span class="line">public void transfer(String out,String in,Double money);&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class AccountServiceImpl implements AccountService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    protected AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    public void transfer(String out, String in, Double money) &#123;</span><br><span class="line">        accountDao.outMoney(out, money);</span><br><span class="line">        accountDao.inMoney(in, money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加jdbc.properties文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql://localhost:13306/spring_db?useSSL=false</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=poassword.</span><br></pre></td></tr></table></figure></li><li><p>创建JdbcConfig配置类</p></li></ol>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class JdbcConfig &#123;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span><br><span class="line">    private String driver;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.url&#125;&quot;)</span><br><span class="line">    private String url;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.username&#125;&quot;)</span><br><span class="line">    private String username;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.password&#125;&quot;)</span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource() &#123;</span><br><span class="line">        DruidDataSource dataSource = new DruidDataSource();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        return dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li><p>创建MybatisConfig配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class MyBatisConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource)&#123;</span><br><span class="line">        SqlSessionFactoryBean factory = new SqlSessionFactoryBean();</span><br><span class="line">        factory.setTypeAliasesPackage(&quot;com.blog.domain&quot;);</span><br><span class="line">        factory.setDataSource(dataSource);</span><br><span class="line">        return factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MapperScannerConfigurer mapperScannerConfigurer()&#123;</span><br><span class="line">        MapperScannerConfigurer msc = new MapperScannerConfigurer();</span><br><span class="line">        msc.setBasePackage(&quot;com.blog.dao&quot;);</span><br><span class="line">        return msc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建SpringConfig配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.blog&quot;)</span><br><span class="line">@PropertySource(&quot;jdbc.properties&quot;)</span><br><span class="line">@Import(&#123;JdbcConfig.class, MyBatisConfig.class&#125;)</span><br><span class="line">public class SpringConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写测试类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(classes = SpringConfig.class)</span><br><span class="line">public class AccountServiceTest &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private AccountService accountService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testTransfer() &#123;</span><br><span class="line">        accountService.transfer(&quot;Tom&quot;, &quot;Jerry&quot;, 100D);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="事务管理-1"><a href="#事务管理-1" class="headerlink" title="事务管理"></a>事务管理</h3><p>上述环境，运行单元测试类，会执行转账操作，<code>Tom</code>的账户会减少100，<code>Jerry</code>的账户会加100。</p><p>这是正常情况下的运行结果，但是如果在转账的过程中出现了异常，如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class AccountServiceImpl implements AccountService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    protected AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    public void transfer(String out, String in, Double money) &#123;</span><br><span class="line">        accountDao.outMoney(out, money);</span><br><span class="line">        int a = 1 / 0;</span><br><span class="line">        accountDao.inMoney(in, money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候就模拟了转账过程中出现异常的情况，此时进行转账，<code>Tom</code>的账户会减少100，而<code>Jerry</code>的账户却不会增加100<br>那我们来分析一下刚才的结果</p><ul><li>程序正常执行时，账户金额A减B加，没有问题</li><li>程序出现异常后，转账失败，但是异常之前操作成功，异常之后操作失败，整体业务失败</li></ul><p>当程序出问题后，我们需要让事务进行回滚，而且这个事务应该是加在业务层上，而Spring的事务管理就是用来解决这类问题的。</p><p>Spring事务管理具体的实现步骤如下：</p><ol><li><p>在需要被事务管理的方法上添加<code>@Transactional</code>注解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class AccountServiceImpl implements AccountService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    protected AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public void transfer(String out, String in, Double money) &#123;</span><br><span class="line">        accountDao.outMoney(out, money);</span><br><span class="line">        int a = 1 / 0;</span><br><span class="line">        accountDao.inMoney(in, money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意:<code>@Transactional</code>可以写在接口类上、接口方法上、实现类上和实现类方法上</p><ul><li>写在接口类上，该接口的所有实现类的所有方法都会有事务</li><li>写在接口方法上，该接口的所有实现类的该方法都会有事务</li><li>写在实现类上，该类中的所有方法都会有事务</li><li>写在实现类方法上，该方法上有事务</li><li><code>建议写在实现类或实现类的方法上</code></li></ul></blockquote></li><li><p>在JdbcConfig类中配置事务管理器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class JdbcConfig &#123;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span><br><span class="line">    private String driver;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.url&#125;&quot;)</span><br><span class="line">    private String url;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.username&#125;&quot;)</span><br><span class="line">    private String username;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.password&#125;&quot;)</span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource() &#123;</span><br><span class="line">        DruidDataSource dataSource = new DruidDataSource();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        return dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //配置事务管理器，mybatis使用的是jdbc事务</span><br><span class="line">    @Bean</span><br><span class="line">    public PlatformTransactionManager platformTransactionManager(DataSource dataSource)&#123;</span><br><span class="line">        DataSourceTransactionManager transactionManager = new DataSourceTransactionManager();</span><br><span class="line">        transactionManager.setDataSource(dataSource);</span><br><span class="line">        return transactionManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：事务管理器要根据使用技术进行选择，Mybatis框架使用的是JDBC事务，可以直接使用<code>DataSourceTransactionManager</code></p></blockquote></li><li><p>开启事务注解<code>@EnableTransactionManagement</code></p></li><li><p>运行测试类<br>运行程序之后，我们去数据库查看Tom和Jerry的金额，发现没有变化<br>那么说明在转换的业务出现错误后，事务就可以控制回滚，保证数据的正确性</p></li></ol><h3 id="注解介绍"><a href="#注解介绍" class="headerlink" title="注解介绍"></a>注解介绍</h3><p>知识点1：<code>@EnableTransactionManagement</code></p><table><thead><tr><th align="center">名称</th><th align="center">@EnableTransactionManagement</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">配置类注解</td></tr><tr><td align="center">位置</td><td align="center">配置类定义上方</td></tr><tr><td align="center">作用</td><td align="center">设置当前Spring环境中开启注解式事务支持</td></tr></tbody></table><p>知识点2：<code>@Transactional</code></p><table><thead><tr><th align="center">名称</th><th align="center">@Transactional</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">接口注解 类注解 方法注解</td></tr><tr><td align="center">位置</td><td align="center">业务层接口上方 业务层实现类上方 业务方法上方</td></tr><tr><td align="center">作用</td><td align="center">为当前业务层方法添加事务（如果设置在类或接口上方则类或接口中所有方法均添加事务）</td></tr></tbody></table><h2 id="Spring事务角色"><a href="#Spring事务角色" class="headerlink" title="Spring事务角色"></a>Spring事务角色</h2><p>这部分我们重点要理解两个概念，分别是<code>事务管理员</code>和<code>事务协调员</code>。</p><p>当未开启Spring事务之前</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310072142554.png"></p><p>AccountDao的outMoney因为是修改操作，会开启一个事务T1</p><p>AccountDao的inMoney因为是修改操作，会开启一个事务T2</p><p>AccountService的transfer没有事务，</p><ul><li>运行过程中如果没有抛出异常，则T1和T2都正常提交，数据正确</li><li>如果在两个方法中间抛出异常，T1因为执行成功提交事务，T2因为抛异常不会被执行</li><li>就会导致数据出现错误</li></ul><p>当开启Spring的事务管理后<br><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310072143681.png"></p><p>transfer上添加了@Transactional注解，在该方法上就会有一个事务T</p><p>AccountDao的outMoney方法的事务T1加入到transfer的事务T中</p><p>AccountDao的inMoney方法的事务T2加入到transfer的事务T中</p><p>这样就保证他们在同一个事务中，当业务层中出现异常，整个事务就会回滚，保证数据的准确性。</p><p>通过上面例子的分析，我们就可以得到如下概念:</p><ul><li>事务管理员：发起事务方，在Spring中通常指代业务层开启事务的方法</li><li>事务协调员：加入事务方，在Spring中通常指代数据层方法，也可以是业务层方法</li></ul><blockquote><p>注意：目前的事务管理是基于<code>DataSourceTransactionManager</code>和<code>SqlSessionFactoryBean</code>使用的是同一个数据源。</p></blockquote><h2 id="Spring事务属性"><a href="#Spring事务属性" class="headerlink" title="Spring事务属性"></a>Spring事务属性</h2><p>这部分我们主要学习三部分内容<code>事务配置</code>、<code>转账业务追加日志</code>、<code>事务传播行为</code>。</p><h3 id="事务配置"><a href="#事务配置" class="headerlink" title="事务配置"></a>事务配置</h3><table><thead><tr><th align="center">属性</th><th align="center">作用</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">readOnly</td><td align="center">设置是否为只读事务</td><td align="center">readOnly &#x3D; true 只读事务</td></tr><tr><td align="center">timeout</td><td align="center">设置事务超时时间</td><td align="center">timeout &#x3D; -1(永不超时)</td></tr><tr><td align="center">rollbackFor</td><td align="center">设置事务回滚异常(class)</td><td align="center">rollbackFor{NullPointException.class}</td></tr><tr><td align="center">rollbackForClassName</td><td align="center">设置事务回滚异常（String)</td><td align="center">同上格式为字符串</td></tr><tr><td align="center">noRollbackFor</td><td align="center">设置事务不回滚异常(class)</td><td align="center">noRollbackFor{NullPointExceptior.class}</td></tr><tr><td align="center">noRollbackForClassName</td><td align="center">设置事务不回滚异常(String)</td><td align="center">同上格式为字符串</td></tr><tr><td align="center">isolation</td><td align="center">设置事务隔离级别</td><td align="center">isolation &#x3D; Isolation. DEFAULT</td></tr><tr><td align="center">propagation</td><td align="center">设置事务传播行为</td><td align="center">…</td></tr></tbody></table><p>上面这些属性都可以在<code>@Transactional</code>注解的参数上进行设置。</p><ul><li><p>readOnly：true只读事务，false读写事务，增删改要设为false,查询设为true。</p></li><li><p>timeout:设置超时时间单位秒，在多长时间之内事务没有提交成功就自动回滚，-1表示不设置超时时间。</p></li><li><p>rollbackFor:当出现指定异常进行事务回滚</p></li><li><p>noRollbackFor:当出现指定异常不进行事务回滚</p><ul><li><p>思考:出现异常事务会自动回滚，这个是我们之前就已经知道的</p></li><li><p>noRollbackFor是设定对于指定的异常不回滚，这个好理解</p></li><li><p>rollbackFor是指定回滚异常，对于异常事务不应该都回滚么，为什么还要指定?</p><ul><li><p>事实上Spring的事务只会对<code>Error异常</code>和<code>RuntimeException异常</code>及其子类进行事务回顾，其他的异常类型是不会回滚的，如下面的代码就不会回滚</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class AccountServiceImpl implements AccountService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    protected AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public void transfer(String out, String in, Double money) throws IOException &#123;</span><br><span class="line">        accountDao.outMoney(out, money);</span><br><span class="line">        if (true) throw new IOException();</span><br><span class="line">        accountDao.inMoney(in, money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>有些异常它真不回滚</strong>，此时就可以使用rollbackFor属性来设置出现IOException异常不回滚</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class AccountServiceImpl implements AccountService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    protected AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    @Transactional(rollbackFor = &#123;IOException.class&#125;)</span><br><span class="line">    public void transfer(String out, String in, Double money) throws IOException &#123;</span><br><span class="line">        accountDao.outMoney(out, money);</span><br><span class="line">        if (true) throw new IOException();</span><br><span class="line">        accountDao.inMoney(in, money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>rollbackForClassName等同于rollbackFor,只不过属性为异常的类全名字符串</p></li><li><p>noRollbackForClassName等同于noRollbackFor，只不过属性为异常的类全名字符串</p></li><li><p>isolation设置事务的隔离级别</p><ul><li>DEFAULT :默认隔离级别, 会采用数据库的隔离级别</li><li>READ_UNCOMMITTED : 读未提交</li><li>READ_COMMITTED : 读已提交</li><li>REPEATABLE_READ : 重复读取</li><li>SERIALIZABLE: 串行化</li></ul></li></ul></li></ul></li></ul><p>介绍完上述属性后，还有最后一个事务的传播行为，为了讲解该属性的设置，我们需要完成下面的案例。</p><h3 id="转账业务追加日志案例"><a href="#转账业务追加日志案例" class="headerlink" title="转账业务追加日志案例"></a>转账业务追加日志案例</h3><p> 需求分析</p><ul><li><p>在前面的转账案例的基础上添加新的需求，完成转账后记录日志。</p><ul><li>需求：实现任意两个账户间转账操作，并对每次转账操作在数据库进行留痕</li><li>需求微缩：A账户减钱，B账户加钱，数据库记录日志</li></ul></li><li><p>基于上述的业务需求，我们来分析下该如何实现：</p><ol><li>基于转账操作案例添加日志模块，实现数据库中记录日志</li><li>业务层转账操作（transfer），调用减钱、加钱与记录日志功能</li></ol></li><li><p>需要注意一点就是，我们这个案例的预期效果为:</p><ul><li><strong><code>无论转账操作是否成功，均进行转账操作的日志留痕</code></strong></li></ul></li></ul><p>环境准备：</p><ol><li><p>创建日志表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table tbl_log(</span><br><span class="line">   id int primary key auto_increment,</span><br><span class="line">   info varchar(255),</span><br><span class="line">   createDate datetime</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>添加LogDao接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface LogDao &#123;</span><br><span class="line"></span><br><span class="line">    @Insert(&quot;insert into tbl_log(info, createDate) VALUES (#&#123;info&#125;,now())&quot;)</span><br><span class="line">    void log(String info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加LogService接口和实现类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface LogService &#123;</span><br><span class="line">    void log(String out, String in, Double money);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class LogServiceImpl implements LogService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private LogDao logDao;</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public void log(String out, String in, Double money) &#123;</span><br><span class="line">        logDao.log(out + &quot;向&quot; + in + &quot;转账&quot; + money + &quot;元&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在转账的业务中添加记录日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class AccountServiceImpl implements AccountService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    protected AccountDao accountDao;</span><br><span class="line">    @Autowired</span><br><span class="line">    protected LogService logService;</span><br><span class="line"></span><br><span class="line">    @Transactional(rollbackFor = &#123;IOException.class&#125;)</span><br><span class="line">    public void transfer(String out, String in, Double money) throws IOException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            accountDao.outMoney(out, money);</span><br><span class="line">            accountDao.inMoney(in, money);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            logService.log(out, in, money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行程序</p><ul><li>当程序正常运行，tbl_account表中转账成功，tbl_log表中日志记录成功</li><li>当转账业务之间出现异常(int i &#x3D;1 &#x2F; 0),转账失败，tbl_account成功回滚，但是tbl_log表未添加数据，说明也回滚了</li><li>这个结果和我们想要的不一样，什么原因?该如何解决?<ul><li>失败原因：日志的记录与转账操作隶属同一个事务，同成功同失败（同回滚）</li><li>解决方案：继续往下看</li><li>预期效果：无论转账操作是否成功，日志必须保留</li></ul></li></ul></li></ol><h3 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h3><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310072149242.png"></p><p>对于上述案例的分析:</p><ul><li>log方法、inMoney方法和outMoney方法都属于增删改，分别有事务T1,T2,T3</li><li>transfer因为加了<code>@Transactional</code>注解，也开启了事务T</li><li>前面我们讲过Spring事务会把T1,T2,T3都加入到事务T中</li><li>所以当转账失败后，<code>所有的事务都回滚</code>，导致日志没有记录下来</li><li>这和我们的需求不符，这个时候我们就想能不能让log方法单独是一个事务呢?</li></ul><p>要想解决这个问题，就需要用到事务传播行为，所谓的事务传播行为指的是:</p><ul><li><p>事务传播行为：事务协调员对事务管理员所携带事务的处理态度。</p><ul><li>具体如何解决，就需要用到之前我们没有说的<code>propagation属性</code>。</li></ul></li><li><p>修改logService改变事务的传播行为</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class LogServiceImpl implements LogService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private LogDao logDao;</span><br><span class="line"></span><br><span class="line">    @Transactional(propagation = Propagation.REQUIRES_NEW)</span><br><span class="line">    public void log(String out, String in, Double money) &#123;</span><br><span class="line">        logDao.log(out + &quot;向&quot; + in + &quot;转账&quot; + money + &quot;元&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后，就能实现我们想要的结果，不管转账是否成功，都会记录日志。</p><p>事务传播行为的可选值</p><table><thead><tr><th>传播属性</th><th>事务管理员</th><th>事务协调员</th></tr></thead><tbody><tr><td>REQUIRED(默认)</td><td>开启T</td><td>加入T</td></tr><tr><td>无</td><td>新建T2</td><td></td></tr><tr><td>REQUIRES_NEW</td><td>开启T</td><td>新建T2</td></tr><tr><td>无</td><td>新建T2</td><td></td></tr><tr><td>SUPPORTS</td><td>开启T</td><td>加入T</td></tr><tr><td>无</td><td>无</td><td></td></tr><tr><td>NOT_SUPPORTED</td><td>开启T</td><td>无</td></tr><tr><td>无</td><td>无</td><td></td></tr><tr><td>MANDTORY</td><td>开启T</td><td>加入T</td></tr><tr><td>无</td><td>ERROR</td><td></td></tr><tr><td>NEVER</td><td>开启T</td><td>ERROR</td></tr><tr><td>无</td><td>无</td><td></td></tr><tr><td>NESTED</td><td>设置savePoint,一旦事务回滚，事务将回滚到savePoint处，交由客户响应提交&#x2F;回滚</td><td></td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/10/07/SSM-Spring03/"/>
      <url>/2023/10/07/SSM-Spring03/</url>
      
        <content type="html"><![CDATA[<h1 id="AOP概念"><a href="#AOP概念" class="headerlink" title="AOP概念"></a>AOP概念</h1><p>Spring有两个核心的概念，一个是<code>IOC/DI</code>，一个是<code>AOP</code>。</p><p>AOP(Aspect Oriented Programming)面向切面编程，是一种编程范式，指导开发者如何组织程序结构</p><p>作用：在不惊动原始设计的基础上为其进行功能增强</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Repository</span><br><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        //记录程序当前执行执行（开始时间）</span><br><span class="line">        Long startTime = System.currentTimeMillis();</span><br><span class="line">        //业务执行万次</span><br><span class="line">        for (int i = 0;i&lt;10000;i++) &#123;</span><br><span class="line">            System.out.println(&quot;book dao save ...&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //记录程序当前执行时间（结束时间）</span><br><span class="line">        Long endTime = System.currentTimeMillis();</span><br><span class="line">        //计算时间差</span><br><span class="line">        Long totalTime = endTime-startTime;</span><br><span class="line">        //输出信息</span><br><span class="line">        System.out.println(&quot;执行万次消耗时间：&quot; + totalTime + &quot;ms&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void update()&#123;</span><br><span class="line">        System.out.println(&quot;book dao update ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void delete()&#123;</span><br><span class="line">        System.out.println(&quot;book dao delete ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void select()&#123;</span><br><span class="line">        System.out.println(&quot;book dao select ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当在App类中从容器中获取bookDao对象后，分别执行其<code>save</code>,<code>delete</code>,<code>update</code>和<code>select</code>方法查看打印结果前三个都会计算运行时间</p><blockquote><p>疑问</p><ul><li>对于计算万次执行消耗的时间只有save方法有，为什么delete和update方法也会有呢?</li><li>delete和update方法有，那什么select方法为什么又没有呢?</li></ul></blockquote><p>这个案例中其实就使用了Spring的AOP，在不惊动原有设计的前提下，想给谁添加额外功能就给谁添加。这个也就是Spring的理念：无入侵式&#x2F;无侵入式</p><h2 id="AOP核心概念"><a href="#AOP核心概念" class="headerlink" title="AOP核心概念"></a>AOP核心概念</h2><ol><li>前面一直在强调，Spring的AOP是对一个类的方法在不进行任何修改的前提下实现增强。对于上面的案例中BookServiceImpl中有<code>save</code>,<code>update</code>,<code>delete</code>和<code>select</code>方法,这些方法我们给起了一个名字叫<code>连接点</code></li><li>在BookServiceImpl的四个方法中，<code>update</code>和<code>delete</code>只有打印没有计算万次执行消耗时间，但是在运行的时候已经有该功能，那也就是说<code>update</code>和<code>delete</code>方法都已经被增强，所以对于需要增强的方法我们给起了一个名字叫<code>切入点</code></li><li>执行BookServiceImpl的update和delete方法的时候都被添加了一个计算万次执行消耗时间的功能，将这个功能抽取到一个方法中，换句话说就是存放共性功能的方法，我们给起了个名字叫<code>通知</code></li><li>通知是要增强的内容，会有多个，切入点是需要被增强的方法，也会有多个，那哪个切入点需要添加哪个通知，就需要提前将它们之间的关系描述清楚，那么对于通知和切入点之间的关系描述，我们给起了个名字叫<code>切面</code></li><li>通知是一个方法，方法不能独立存在需要被写在一个类中，这个类我们也给起了个名字叫<code>通知类</code></li></ol><p>总结如下：</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310071525128.png"></p><ul><li>连接点(JoinPoint)：程序执行过程中的任意位置，粒度为执行方法、抛出异常、设置变量等<ul><li>在SpringAOP中，理解为方法的执行</li></ul></li><li>切入点(Pointcut):匹配连接点的式子<ul><li>在SpringAOP中，一个切入点可以描述一个具体方法，也可也匹配多个方法<ul><li>一个具体的方法：如com.blog.dao包下的BookDao接口中的无形参无返回值的save方法</li><li>匹配多个方法：所有的save方法&#x2F;所有的get开头的方法&#x2F;所有以Dao结尾的接口中的任意方法&#x2F;所有带有一个参数的方法</li></ul></li><li>连接点范围要比切入点范围大，是切入点的方法也一定是连接点，但是是连接点的方法就不一定要被增强，所以可能不是切入点。</li></ul></li><li>通知(Advice)：在切入点处执行的操作，也就是共性功能（加强的那部分功能）<ul><li>在SpringAOP中，功能最终以方法的形式呈现</li></ul></li><li>通知类：定义通知的类</li><li>切面(Aspect)：描述通知与切入点的对应关系。</li></ul><p>这部分需要掌握的内容是</p><ul><li>什么是AOP?</li><li>AOP的作用是什么?</li><li>AOP中核心概念分别指的是什么?<ul><li>连接点</li><li>切入点</li><li>通知</li><li>通知类</li><li>切面</li></ul></li></ul><h1 id="AOP入门案例"><a href="#AOP入门案例" class="headerlink" title="AOP入门案例"></a>AOP入门案例</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ol><li><p>创建一个Maven项目</p></li><li><p>pom.xml添加Spring依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>添加BookDao和BookDaoImpl类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface BookDao &#123;</span><br><span class="line">    public void save();</span><br><span class="line">    public void update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Repository</span><br><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void update() &#123;</span><br><span class="line">        System.out.println(&quot;book dao update ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Spring的配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.blog&quot;)</span><br><span class="line">public class SpringConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写App运行类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);</span><br><span class="line">        BookDao bookDao = context.getBean(BookDao.class);</span><br><span class="line">        bookDao.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>说明:</strong></p><ul><li>目前打印save方法的时候，因为方法中有打印系统时间，所以运行的时候是可以看到系统时间</li><li>对于update方法来说，就没有该功能</li><li>我们要使用SpringAOP的方式在不改变update方法的前提下让其具有打印系统时间的功能。</li></ul><h2 id="AOP实现步骤"><a href="#AOP实现步骤" class="headerlink" title="AOP实现步骤"></a>AOP实现步骤</h2><ol><li><p>添加依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.9.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>因为<code>spring-context</code>中已经导入了<code>spring-aop</code>,所以不需要再单独导入<code>spring-aop</code><br>导入AspectJ的jar包,AspectJ是AOP思想的一个具体实现，Spring有自己的AOP实现，但是相比于AspectJ来说比较麻烦，所以我们直接采用Spring整合ApsectJ的方式进行AOP开发。</p></li><li><p>定义接口和实现类<br>准备环境的时候我们已经完成了</p></li><li><p>定义通知类和通知<br>通知就是将共性功能抽取出来后形成的方法，共性功能指的就是当前系统时间的打印。<br>类名和方法名没有要求，可以任意。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class MyAdvice &#123;</span><br><span class="line">    public void method()&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义切入点<br>BookDaoImpl中有两个方法，分别是update()和save()，我们要增强的是update方法，那么该如何定义呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MyAdvice &#123;</span><br><span class="line">    @Pointcut(&quot;execution(void com.blog.dao.impl.BookDaoImpl.update())&quot;)</span><br><span class="line">    private void pt() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void method() &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>切入点定义依托一个不具有实际意义的方法进行，即无参数、无返回值、方法体无实际逻辑。</li><li>execution及后面编写的内容，之后我们会专门去学习。</li></ul></li><li><p>制作切面<br>切面是用来描述通知和切入点之间的关系，如何进行关系的绑定?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MyAdvice &#123;</span><br><span class="line"></span><br><span class="line">    @Pointcut(&quot;execution(void com.blog.dao.BookDao.update())&quot;)</span><br><span class="line">    private void pt()&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    @Before(&quot;pt()&quot;)</span><br><span class="line">    public void method()&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绑定切入点与通知关系，并指定通知添加到原始连接点的具体执行<code>位置</code></p><p>说明：<code>@Before</code>翻译过来是之前，也就是说通知会在切入点方法执行之前执行，除此之前还有其他四种类型，后面会讲。<br>那这里就会在执行update()之前，来执行我们的method()，输出当前毫秒值</p></li><li><p>将通知类配给容器并标识其为切面类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">public class MyAdvice &#123;</span><br><span class="line"></span><br><span class="line">    @Pointcut(&quot;execution(void com.blog.dao.impl.BookDaoImpl.update())&quot;)</span><br><span class="line">    private void pt() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Before(&quot;pt()&quot;)</span><br><span class="line">    public void method() &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开启注解格式AOP功能<br>使用<code>@EnableAspectJAutoProxy</code>注解</p></li><li><p>运行程序</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310071549465.png"></p></li></ol><h2 id="注解讲解"><a href="#注解讲解" class="headerlink" title="注解讲解"></a>注解讲解</h2><p>知识点1：<code>@EnableAspectJAutoProxy</code></p><table><thead><tr><th align="center">名称</th><th align="center">@EnableAspectJAutoProxy</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">配置类注解</td></tr><tr><td align="center">位置</td><td align="center">配置类定义上方</td></tr><tr><td align="center">作用</td><td align="center">开启注解格式AOP功能</td></tr></tbody></table><p>知识点2：<code>@Aspect</code></p><table><thead><tr><th align="center">名称</th><th align="center">@Aspect</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">类注解</td></tr><tr><td align="center">位置</td><td align="center">切面类定义上方</td></tr><tr><td align="center">作用</td><td align="center">设置当前类为AOP切面类</td></tr></tbody></table><p>知识点3：<code>@Pointcut</code></p><table><thead><tr><th align="center">名称</th><th align="center">@Pointcut</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">方法注解</td></tr><tr><td align="center">位置</td><td align="center">切入点方法定义上方</td></tr><tr><td align="center">作用</td><td align="center">设置切入点方法</td></tr><tr><td align="center">属性</td><td align="center">value（默认）：切入点表达式</td></tr></tbody></table><p>知识点4：<code>@Before</code></p><table><thead><tr><th align="center">名称</th><th align="center">@Before</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">方法注解</td></tr><tr><td align="center">位置</td><td align="center">通知方法定义上方</td></tr><tr><td align="center">作用</td><td align="center">设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前运行</td></tr></tbody></table><h1 id="AOP工作流程"><a href="#AOP工作流程" class="headerlink" title="AOP工作流程"></a>AOP工作流程</h1><p>AOP的入门案例已经完成，对于刚才案例的执行过程，我们就得来分析分析，这一节我们主要讲解两个知识点:<code>AOP工作流程</code>和<code>AOP核心概念</code>。其中核心概念是对前面核心概念的补充。</p><h2 id="AOP工作流程-1"><a href="#AOP工作流程-1" class="headerlink" title="AOP工作流程"></a>AOP工作流程</h2><p>由于AOP是基于Spring容器管理的bean做的增强，所以整个工作过程需要从Spring加载bean说起</p><ol><li><p>Spring容器启动</p><ul><li>容器启动就需要去加载bean,哪些类需要被加载呢?</li><li>需要被增强的类，如:BookServiceImpl</li><li>通知类，如:MyAdvice</li><li>注意此时bean对象还没有创建成功</li></ul></li><li><p>读取所有切面配置中的切入点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">public class MyAdvice &#123;</span><br><span class="line">    @Pointcut(&quot;execution(void com.blog.dao.impl.BookDaoImpl.update())&quot;)</span><br><span class="line">    private void ptx() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Pointcut(&quot;execution(void com.blog.dao.impl.BookDaoImpl.update())&quot;)</span><br><span class="line">    private void pt() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Before(&quot;pt()&quot;)</span><br><span class="line">    public void method() &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个例子中有两个切入点的配置，但是第一个<code>ptx()</code>并没有被使用，所以不会被读取。</p></li><li><p>初始化bean，判定bean对应的类中的方法是否匹配到任意切入点</p><ul><li><p>注意第一步在容器启动的时候，bean对象还没有被创建成功。</p></li><li><p>要被实例化bean对象的类中的方法和切入点进行匹配</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310071607428.png"></p><p>匹配失败，创建原始对象，如<code>UserDao</code></p><ul><li>匹配失败说明不需要增强，直接调用原始对象的方法即可。</li></ul><p>匹配成功，创建原始对象（<code>目标对象</code>）的<code>代理</code>对象，如:<code>BookDao</code></p><ul><li>匹配成功说明需要对其进行增强</li><li>对哪个类做增强，这个类对应的对象就叫做目标对象</li><li>因为要对目标对象进行功能增强，而采用的技术是动态代理，所以会为其创建一个代理对象</li><li>最终运行的是代理对象的方法，在该方法中会对原始方法进行功能增强</li></ul></li></ul></li><li><p>获取bean执行方法</p><p>获取的bean是<strong>原始对象</strong>时，调用方法并执行，完成操作</p><p>获取的bean是<strong>代理对象</strong>时，根据代理对象的运行模式运行原始方法与增强的内容，完成操作</p></li></ol><h2 id="AOP核心概念-1"><a href="#AOP核心概念-1" class="headerlink" title="AOP核心概念"></a>AOP核心概念</h2><p>在上面介绍AOP的工作流程中，我们提到了两个核心概念，分别是:</p><ul><li>目标对象(Target)：原始功能去掉共性功能对应的类产生的对象，这种对象是无法直接完成最终工作的</li><li>代理(Proxy)：目标对象无法直接完成工作，需要对其进行功能回填，通过原始对象的代理对象实现</li></ul><p>上面这两个概念比较抽象，简单来说</p><p>目标对象就是要增强的类<code>如:BookServiceImpl类</code>对应的对象，也叫原始对象，不能说它不能运行，只能说它在运行的过程中对于要增强的内容是缺失的。</p><p>SpringAOP是在不改变原有设计(代码)的前提下对其进行增强的，它的底层采用的是代理模式实现的，所以要对原始对象进行增强，就需要对原始对象创建代理对象，在代理对象中的方法把通知<code>如:MyAdvice中的method方法</code>内容加进去，就实现了增强，这就是我们所说的代理(Proxy)。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>下面我们来验证一下容器中是否为代理对象</p><ul><li>如果目标对象中的方法<code>会被增强</code>，那么容器中将存入的是目标对象的<code>代理对象</code></li><li>如果目标对象中的方法<code>不被增强</code>，那么容器中将存入的是目标<code>对象本身</code></li></ul><ol><li><p>修改App运行类，获取类的类型并输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);</span><br><span class="line">        BookDao bookDao = context.getBean(BookDao.class);</span><br><span class="line">        System.out.println(bookDao);</span><br><span class="line">        System.out.println(bookDao.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改MyAdvice类，改为<strong>不增强</strong><br>将定义的切入点改为<code>updatexxx</code>，而BookDaoImpl类中不存在该方法，所以BookDao中的update方法在执行的时候，就不会被增强<br>所以此时容器中的对象应该是目标对象本身。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">public class MyAdvice &#123;</span><br><span class="line">    @Pointcut(&quot;execution(void com.blog.dao.impl.BookDaoImpl.updatexxx())&quot;)</span><br><span class="line">    private void pt() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Before(&quot;pt()&quot;)</span><br><span class="line">    public void method() &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行程序</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310071619767.png"></p></li><li><p>修改MyAdvice类，改为增强<br>将定义的切入点改为<code>update</code>，那么BookDao中的update方法在执行的时候，就会被增强<br>所以容器中的对象应该是目标对象的代理对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">public class MyAdvice &#123;</span><br><span class="line">    @Pointcut(&quot;execution(void com.blog.dao.impl.BookDaoImpl.update())&quot;)</span><br><span class="line">    private void pt() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Before(&quot;pt()&quot;)</span><br><span class="line">    public void method() &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行程序</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310071620875.png"></p></li></ol><p>至此对于刚才的结论，我们就得到了验证，这块我们需要注意的是:<br>不能直接打印对象，从上面两次结果中可以看出，直接打印对象走的是对象的toString方法，不管是不是代理对象，打印的结果都是一样的，原因是内部对toString方法进行了重写。</p><h1 id="AOP配置管理"><a href="#AOP配置管理" class="headerlink" title="AOP配置管理"></a>AOP配置管理</h1><h2 id="AOP切入点表达式（给谁加）"><a href="#AOP切入点表达式（给谁加）" class="headerlink" title="AOP切入点表达式（给谁加）"></a>AOP切入点表达式（给谁加）</h2><p>首先我们先要明确两个概念:</p><ul><li>切入点：要进行增强的方法</li><li>切入点表达式：要进行增强的方法的描述方式</li></ul><p>对于AOP中切入点表达式，我们总共会学习三个内容，分别是<code>语法格式</code>、<code>通配符</code>和<code>书写技巧</code>。</p><p>对于切入点的描述，我们其实是有两中方式的，先来看下前面的例子</p><p>由于BookDaoImpl类实现了BookDao接口，那么有如下两种方式来描述：</p><ol><li><p>执行com.blog.dao包下的BookDao<strong>接口</strong>中的无参数update方法</p></li><li><p>执行com.blog.dao.impl包下的BookDaoImpl<strong>实现类</strong>中的无参数update方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">execution(void com.blog.dao.BookDao.update())</span><br><span class="line">execution(void com.blog.dao.impl.BookDaoImpl.update())</span><br></pre></td></tr></table></figure><p>因为调用接口方法的时候最终运行的还是其实现类的方法，所以上面两种描述方式都是可以的。</p></li></ol><p>对于切入点表达式的语法为:</p><p>切入点表达式标准格式：动作关键字(访问修饰符 返回值 包名.类&#x2F;接口名.方法名(参数) 异常名）<br>对于这个格式，我们不需要硬记，通过一个例子，理解它:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(public User com.blog.service.UserService.findById(int))</span><br></pre></td></tr></table></figure><ul><li>execution：动作关键字，描述切入点的行为动作，例如execution表示执行到指定切入点</li><li>public:访问修饰符,还可以是public，private等，可以省略</li><li>User：返回值，写返回值类型</li><li>com.blog.service：包名，多级包使用点连接</li><li>UserService:类&#x2F;接口名称</li><li>findById：方法名</li><li>int:参数，直接写参数的类型，多个类型用逗号隔开</li><li>异常名：方法定义中抛出指定异常，可以省略</li></ul><p>切入点表达式就是要找到需要增强的方法，所以它就是对一个具体方法的描述，但是方法的定义会有很多，所以如果每一个方法对应一个切入点表达式，想想这块就会觉得将来编写起来会比较麻烦，有没有更简单的方式呢?</p><blockquote><p>使用通配符</p></blockquote><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><ol><li><p><code>*</code>:单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现<br>匹配com.blog包下的任意包中的UserService类或接口中所有find开头的带有一个参数的方法</p></li><li><p><code>..</code>：多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写<br>匹配com包下的任意包中的UserService类或接口中所有名称为findById的方法</p></li><li><p><code>+</code>：专用于匹配子类类型<br>这个使用率较低，描述子类的，<code>*Service+</code>，表示所有以Service结尾的接口的子类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">execution（public * com.blog.*.UserService.find*(*))</span><br><span class="line">execution（public User com..UserService.findById(..))</span><br><span class="line">execution(* *..*Service+.*(..))</span><br></pre></td></tr></table></figure></li></ol><p>例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">匹配接口，能匹配到</span><br><span class="line">execution(void com.blog.dao.BookDao.update())</span><br><span class="line"></span><br><span class="line">匹配实现类，能匹配到</span><br><span class="line">execution(void com.blog.dao.impl.BookDaoImpl.update())</span><br><span class="line"></span><br><span class="line">返回值任意，能匹配到</span><br><span class="line">execution(* com.blog.dao.impl.BookDaoImpl.update())</span><br><span class="line"></span><br><span class="line">返回值任意，但是update方法必须要有一个参数，无法匹配，要想匹配需要在update接口和实现类添加参数</span><br><span class="line">execution(* com.blog.dao.impl.BookDaoImpl.update(*))</span><br><span class="line"></span><br><span class="line">返回值为void,com包下的任意包三层包下的任意类的update方法，匹配到的是实现类，能匹配</span><br><span class="line">execution(void com.*.*.*.*.update())</span><br><span class="line"></span><br><span class="line">返回值为void,com包下的任意两层包下的任意类的update方法，匹配到的是接口，能匹配</span><br><span class="line">execution(void com.*.*.*.update())</span><br><span class="line"></span><br><span class="line">返回值为void，方法名是update的任意包下的任意类，能匹配</span><br><span class="line">execution(void *..update())</span><br><span class="line"></span><br><span class="line">匹配项目中任意类的任意方法，能匹配，但是不建议使用这种方式，影响范围广</span><br><span class="line">execution(* *..*(..))</span><br><span class="line"></span><br><span class="line">匹配项目中任意包任意类下只要以u开头的方法，update方法能满足，能匹配</span><br><span class="line">execution(* *..u*(..))</span><br><span class="line"></span><br><span class="line">匹配项目中任意包任意类下只要以e结尾的方法，update和save方法能满足，能匹配</span><br><span class="line">execution(* *..*e(..))</span><br><span class="line"></span><br><span class="line">返回值为void，com包下的任意包任意类任意方法，能匹配，*代表的是方法</span><br><span class="line">execution(void com..*())</span><br><span class="line"></span><br><span class="line">将项目中所有业务层方法的以find开头的方法匹配</span><br><span class="line">execution(* com.blog.*.*Service.find*(..))</span><br><span class="line"></span><br><span class="line">将项目中所有业务层方法的以save开头的方法匹配</span><br><span class="line">execution(* com.blog.*.*Service.save*(..))</span><br></pre></td></tr></table></figure><h3 id="书写技巧"><a href="#书写技巧" class="headerlink" title="书写技巧"></a>书写技巧</h3><p>对于切入点表达式的编写其实是很灵活的，那么在编写的时候，有没有什么好的技巧让我们用用:</p><ul><li>所有代码按照标准规范开发，否则以下技巧全部失效</li><li>描述切入点通常<code>描述接口</code>，而不描述实现类,如果描述到实现类，就出现紧耦合了</li><li>访问控制修饰符针对接口开发均采用public描述（<code>可省略访问控制修饰符描述</code>）</li><li>返回值类型对于增删改类使用精准类型加速匹配，对于查询类使用<code>*</code>通配快速描述</li><li><code>包名</code>书写尽量不使用<code>..</code>匹配，效率过低，常用<code>*</code>做单个包描述匹配，或精准匹配</li><li><code>接口名/类名</code>书写名称与模块相关的采用<code>*</code>匹配，例如UserService书写成<code>*Service</code>，绑定业务层接口名</li><li>方法名书写以<code>动词</code>进行<code>精准匹配</code>，名词采用<code>*</code>匹配，例如<code>getById</code>书写成<code>getBy*</code>，<code>selectAll</code>书写成<code>selectAll</code></li><li>参数规则较为复杂，根据业务方法灵活调整</li><li>通常<code>不使用异常</code>作为<code>匹配</code>规则</li></ul><h2 id="AOP通知类型（往哪加）"><a href="#AOP通知类型（往哪加）" class="headerlink" title="AOP通知类型（往哪加）"></a>AOP通知类型（往哪加）</h2><p>AOP通知:</p><p>AOP通知描述了抽取的共性功能，根据共性功能抽取的位置不同，最终运行代码时要将其加入到合理的位置</p><p>共提供了5种通知类型</p><ul><li>前置通知 before</li><li>后置通知 after</li><li><code>环绕通知(重点)</code> around</li><li>返回后通知(了解) </li><li>抛出异常后通知(了解)</li></ul><p>知识点1：<code>@After</code></p><table><thead><tr><th align="center">名称</th><th align="center">@After</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">方法注解</td></tr><tr><td align="center">位置</td><td align="center">通知方法定义上方</td></tr><tr><td align="center">作用</td><td align="center">设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法后运行</td></tr></tbody></table><p>知识点2：<code>@AfterReturning</code></p><table><thead><tr><th align="center">名称</th><th align="center">@AfterReturning</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">方法注解</td></tr><tr><td align="center">位置</td><td align="center">通知方法定义上方</td></tr><tr><td align="center">作用</td><td align="center">设置当前通知方法与切入点之间绑定关系，当前通知方法在原始切入点方法正常执行完毕后执行</td></tr></tbody></table><p>知识点3：<code>@AfterThrowing</code></p><table><thead><tr><th align="center">名称</th><th align="center">@AfterThrowing</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">方法注解</td></tr><tr><td align="center">位置</td><td align="center">通知方法定义上方</td></tr><tr><td align="center">作用</td><td align="center">设置当前通知方法与切入点之间绑定关系，当前通知方法在原始切入点方法运行抛出异常后执行</td></tr></tbody></table><p>知识点4：<code>@Around</code></p><table><thead><tr><th align="center">名称</th><th align="center">@Around</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">方法注解</td></tr><tr><td align="center">位置</td><td align="center">通知方法定义上方</td></tr><tr><td align="center">作用</td><td align="center">设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前后运行</td></tr></tbody></table><p>知识点5：<code>@Before</code></p><table><thead><tr><th align="center">名称</th><th align="center">@Before</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">方法注解</td></tr><tr><td align="center">位置</td><td align="center">通知方法定义上方</td></tr><tr><td align="center">作用</td><td align="center">设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前运行</td></tr></tbody></table><p>环绕通知注意事项</p><ol><li>环绕通知必须依赖形参ProceedingJoinPoint才能实现对原始方法的调用，进而实现原始方法调用前后同时添加通知</li><li>通知中如果未使用ProceedingJoinPoint对原始方法进行调用将跳过原始方法的执行</li><li>对原始方法的调用可以不接收返回值，通知方法设置成void即可，如果接收返回值，最好设定为Object类型</li><li>原始方法的返回值如果是void类型，通知方法的返回值类型可以设置成void,也可以设置成Object</li><li>由于无法预知原始方法运行后是否会抛出异常，因此环绕通知方法必须要处理Throwable异常</li></ol><h3 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h3><p>因为环绕通知需要在原始方法的前后进行增强，所以环绕通知就必须要能对原始操作进行调用，具体如何实现?</p><p>在方法参数中添加<code>ProceedingJoinPoint</code>，同时在需要的位置使用<code>proceed()</code>调用原始操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Aspect</span><br><span class="line">public class MyAdvice &#123;</span><br><span class="line">    @Pointcut(&quot;execution(void com.blog.dao.BookDao.update())&quot;)</span><br><span class="line">    private void pt() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Around(&quot;pt()&quot;)</span><br><span class="line">    public void around(ProceedingJoinPoint pjp) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;around before advice ...&quot;);</span><br><span class="line">        //表示对原始操作的调用</span><br><span class="line">        pjp.proceed();</span><br><span class="line">        System.out.println(&quot;around after advice ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学习完这5种通知类型，我们来思考下环绕通知是如何实现其他通知类型的功能的?</p><p>因为环绕通知是可以控制原始方法执行的，所以我们把增强的代码写在调用原始方法的不同位置就可以实现不同的通知类型的功能，如</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310071701617.png"></p><h2 id="AOP通知获取数据"><a href="#AOP通知获取数据" class="headerlink" title="AOP通知获取数据"></a>AOP通知获取数据</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring-Ioc</title>
      <link href="/2023/10/05/SSM-Spring02/"/>
      <url>/2023/10/05/SSM-Spring02/</url>
      
        <content type="html"><![CDATA[<h1 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h1><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><h3 id="bean基础配置"><a href="#bean基础配置" class="headerlink" title="bean基础配置"></a>bean基础配置</h3><p>对于bean的配置中，主要会讲解<code>bean基础配置</code>,<code>bean的别名配置</code>,<code>bean的作用范围配置</code>(重点),这三部分内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>其中，bean标签的功能、使用方式以及id和class属性的作用，我们通过一张图来描述下</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051633132.png"></p><h3 id="bean的name属性"><a href="#bean的name属性" class="headerlink" title="bean的name属性"></a>bean的name属性</h3><p>我们可以在bean标签中配置name属性，来充当别名，下面我们来演示</p><ol><li><p>配置别名<br>打开spring的配置文件<code>applicationContext.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--name:为bean指定别名，别名可以有多个，使用逗号，分号，空格进行分隔--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">name</span>=<span class="string">&quot;service1 service2 service3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>根据名称容器中获取bean对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        //此处根据bean标签的id属性和name属性的任意一个值来获取bean对象</span><br><span class="line">        BookService bookService = (BookService) context.getBean(&quot;service2&quot;);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>注意事项：</p><ul><li>bean依赖注入的ref属性指定bean，必须在容器中存在，而ref的值也可以是name里的别名，不过还是建议用id值来注入</li><li>如果我们在调用getBean(String name)方法时，传入了一个不存在该名称的bean对象，则会报错<code>NoSuchBeanDefinitionException</code>，此时我们要检查一下是哪边写错了（例如bean的id和name都没有service100，而getBean的参数却写了service100）</li></ul><h3 id="bean作用范围"><a href="#bean作用范围" class="headerlink" title="bean作用范围"></a>bean作用范围</h3><p>关于bean的作用范围是bean属性配置的一个重点内容。<br>bean的scope有两个取值：</p><ul><li>singleton：单例（默认）</li><li>prototype：非单例</li></ul><p>验证IOC容器中对象是否为单例：</p><ul><li><p>验证思路：我们只需要对同一个bean创建两个对象，然后打印二者的地址值，看看是否一致</p></li><li><p>代码实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        //我这里使用了别名，其实还是同一个bean</span><br><span class="line">        BookService bookService2 = (BookService) context.getBean(&quot;service2&quot;);</span><br><span class="line">        BookService bookService3 = (BookService) context.getBean(&quot;service3&quot;);</span><br><span class="line">        System.out.println(bookService2);</span><br><span class="line">        System.out.println(bookService3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>那如果我想创建出来非单例的bean对象，该如何实现呢?</p><p>在Spring的配置文件中，修改<code>&lt;bean&gt;</code>的scope属性为prototype</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bookService&quot; name=&quot;service1 service2 service3&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot; scope=&quot;prototype&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>介绍完<code>scope</code>属性以后，我们来思考几个问题:</p><ol><li><p>为什么bean默认为单例?</p><ul><li>bean为单例的意思是在Spring的IOC容器中只会有该类的一个对象</li><li>bean对象只有一个就避免了对象的频繁创建与销毁，达到了bean对象的复用，性能高</li></ul></li><li><p>bean在容器中是单例的，会不会产生线程安全问题?</p><ul><li>如果对象是有状态对象，即该对象有成员变量可以用来存储数据的，</li><li>因为所有请求线程共用一个bean对象，所以会存在线程安全问题。</li><li>如果对象是无状态对象，即该对象没有成员变量没有进行数据存储的，</li><li>因方法中的局部变量在方法调用完成后会被销毁，所以不会存在线程安全问题。</li></ul></li><li><p>哪些bean对象适合交给容器进行管理?</p><ul><li>表现层对象（controller）</li><li>业务层对象（service）</li><li>数据层对象（dao）</li><li>工具对象（util）</li></ul></li><li><p>哪些bean对象不适合交给容器进行管理?</p><p>封装实例的域对象（domain，pojo），因为会引发线程安全问题，所以不适合。</p></li></ol><h2 id="bean实例化"><a href="#bean实例化" class="headerlink" title="bean实例化"></a>bean实例化</h2><p>对象已经能交给Spring的IOC容器来创建了，但是容器是如何来创建对象的呢?</p><ul><li>就需要研究下bean的实例化过程，在这块内容中主要解决两部分内容，分别是<ul><li>bean是如何创建的</li><li>实例化bean的三种方式，<code>构造方法</code>,<code>静态工厂</code>和<code>实例工厂</code></li></ul></li></ul><p>在讲解这三种创建方式之前，我们需要先确认一件事:</p><ul><li>bean本质上就是对象，对象在new的时候会使用构造方法完成，那创建bean也是使用构造方法完成的。<ul><li>基于这个知识点出发，我们来验证spring中bean的三种创建方式，</li></ul></li></ul><h3 id="构造方法实例化（常用）"><a href="#构造方法实例化（常用）" class="headerlink" title="构造方法实例化（常用）"></a>构造方法实例化（常用）</h3><ul><li>在之前的BookDaoImpl类中添加一个无参构造函数，并打印一句话，方便观察结果。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BookDaoImpl() &#123;</span><br><span class="line">        System.out.println(&quot;book dao constructor is running ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，结果如下：</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051848892.png"></p><blockquote><p>特别的，将构造器私有化继续测试，结果仍然如上图，说明内部走的依然是构造函数，能访问到类中的私有构造方法，显而易见Spring底层用的是反射</p></blockquote><p>但是，在构造函数中添加一个参数试试，运行程序，程序会报错<code>NoSuchMethodException</code>，说明Spring底层使用的是类的无参构造方法。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051852774.png"></p><h3 id="静态工厂实例化（了解）"><a href="#静态工厂实例化（了解）" class="headerlink" title="静态工厂实例化（了解）"></a>静态工厂实例化（了解）</h3><p>创建一个工厂类BookDaoFactory并提供一个静态方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//静态工厂创建对象</span><br><span class="line">public class BookDaoFactory &#123;</span><br><span class="line">    public static BookDao getBookDaoImpl()&#123;</span><br><span class="line">        return new BookDaoImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改App运行类，在类中通过工厂获取对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //通过静态工厂创建对象</span><br><span class="line">        BookDao bookDao = BookDaoFactory.getBookDaoImpl();</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后，可以查看到结果</p><p>那我们如何将这种方式交给Spring来管理呢？</p><p>这就要用到Spring中的静态工厂实例化的知识了，具体实现步骤为：</p><ol><li><p>在spring的配置文件<code>application.properties</code>修改bookDao的bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.factory.BookDaoFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getBookDaoImpl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>class：工厂类的类全名<br>factory-mehod：具体工厂类中创建对象的方法名</p></li><li><p>在App运行类，使用从IOC容器中获取bean的方法进行运行测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        BookDao bookDao = (BookDao) context.getBean(&quot;bookDao&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行后，结果如下</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051904580.png"></p><p>与我们自己直接new对象没太大区别，而且还麻烦了，那这种方式的意义是什么呢？</p><p>在工厂的静态方法中，我们除了new对象还可以做其他的一些业务操作，而之前new对象的方式就无法添加其他的业务内容</p><blockquote><p>介绍完静态工厂实例化后，这种方式一般是用来兼容早期的一些老系统，所以<code>了解为主</code>。</p></blockquote></li></ol><h3 id="实例工厂实例化Bean（了解）"><a href="#实例工厂实例化Bean（了解）" class="headerlink" title="实例工厂实例化Bean（了解）"></a>实例工厂实例化Bean（了解）</h3><ol><li><p>在spring配置文件中修改bookDao的bean</p><p>先引入工厂的bean，再引入对象的bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDaoFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.factory.BookDaoFactory&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;bookDaoFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getBookDaoImpl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改工厂和运行类的方法</p><p>改工厂类<code>BookDaoFactory</code>的get方法，注意此处和静态工厂的工厂类不一样的地方是方法<code>不是静态方法</code></p><blockquote><p>因为不是静态方法，所以要有工厂的对象才能使用工厂的方法，所以引入了工厂的bean</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoFactory &#123;</span><br><span class="line">    //唯一的区别就是去掉的static</span><br><span class="line">    public BookDao getBookDaoImpl() &#123;</span><br><span class="line">        System.out.println(&quot;book dao factory setup ...&quot;);//模拟必要的业务操作</span><br><span class="line">        //这里还可以加一大堆业务逻辑</span><br><span class="line">        return new BookDaoImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改App运行类，在类中通过工厂获取对象，由于不是静态方法了，所以我们需要先创建实例工厂对象，然后再用实例工厂对象调用方法</p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建实例工厂对象</span><br><span class="line">        BookDaoFactory bookDaoFactory = new BookDaoFactory();</span><br><span class="line">        //通过实例工厂对象创建对象</span><br><span class="line">        BookDao bookDao = bookDaoFactory.getBookDaoImpl();</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051925495.png"></p><p>实例化工厂运行的顺序是:</p><ul><li>创建实例化工厂对象,对应的是第一行配置</li><li>调用对象中的方法来创建bean，对应的是第二行配置<ul><li>factory-bean:工厂的实例对象</li><li>factory-method:工厂对象中的具体创建对象的方法名</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051926795.png"></p><h3 id="FactoryBean（实用）"><a href="#FactoryBean（实用）" class="headerlink" title="FactoryBean（实用）"></a>FactoryBean（实用）</h3><ol><li>创建一个<code>BookDaoFactoryBean</code>类，实现<code>FactoryBean</code>接口，重写接口方法</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoFactoryBean implements FactoryBean&lt;BookDao&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public BookDao getObject() throws Exception &#123;</span><br><span class="line">        return new BookDaoImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        return BookDao.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>在Spring的配置文件中修改bookDao的bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.factory.BookDaoFactoryBean&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>App运行类不用做任何修改，直接运行</p></li></ol><blockquote><p>这种方式在Spring去整合其他框架的时候会被用到，所以这种方式需要我们理解掌握。</p></blockquote><p>查看源码会发现，FactoryBean接口其实会有三个方法，分别是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">T getObject() throws Exception;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; getObjectType();</span><br><span class="line"></span><br><span class="line">default boolean isSingleton() &#123;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法一：getObject()，被重写后，在方法中进行对象的创建并返回</p><p>方法二：getObjectType(),被重写后，主要返回的是被创建类的Class对象</p><p>方法三：没有被重写，因为它已经给了默认值，从方法名中可以看出其作用是设置对象是否为单例，默认true，这里就不加以验证了</p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>于bean的相关知识还有最后一个是<code>bean的生命周期</code>，对于生命周期，我们主要围绕着<code>bean生命周期控制</code>来讲解</p><p>首先理解下什么是生命周期?</p><ul><li>从创建到消亡的完整过程,例如人从出生到死亡的整个过程就是一个生命周期。</li></ul><p>bean生命周期是什么?</p><ul><li>bean对象从创建到销毁的整体过程。</li></ul><p>bean生命周期控制是什么?</p><ul><li>在bean创建后到销毁前做一些事情。</li></ul><p>现在我们面临的问题是如何在bean的创建之后和销毁之前把我们需要添加的内容添加进去。</p><h3 id="生命周期设置"><a href="#生命周期设置" class="headerlink" title="生命周期设置"></a>生命周期设置</h3><p>具体的控制有两个阶段:</p><ul><li>bean创建之后，想要添加内容，比如用来初始化需要用到资源</li><li>bean销毁之前，想要添加内容，比如用来释放用到的资源</li></ul><ol><li><p>添加初始化和销毁方法<br>针对这两个阶段，我们在BookDaoImpl类中分别添加两个方法，方法名随便取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void init() &#123;</span><br><span class="line">        System.out.println(&quot;init ... &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">        System.out.println(&quot;destroy ... &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置生命周期<br>修改bookDao的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.dao.impl.BookDaoImpl&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>结果如下</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310060953310.png"></p></li></ol><p>从结果中可以看出，init方法执行了，但是destroy方法却未执行，这是为什么呢?</p><ul><li>Spring的IOC容器是运行在JVM中</li><li>运行main方法后,JVM启动,Spring加载配置文件生成IOC容器,从容器获取bean对象，然后调方法执行</li><li>main方法执行完后，JVM退出，这个时候IOC容器中的bean还没有来得及销毁就已经结束了</li><li>所以没有调用对应的destroy方法</li></ul><h4 id="close关闭容器"><a href="#close关闭容器" class="headerlink" title="close关闭容器"></a>close关闭容器</h4><ul><li><p>ApplicationContext中没有close方法，它的子类中有close方法</p></li><li><p>所以需要将ApplicationContext更换成ClassPathXmlApplicationContext，然后调用close方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        BookDao bookDao = (BookDao) context.getBean(&quot;bookDao&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310060956723.png"></p></li></ul><h4 id="注册钩子关闭容器"><a href="#注册钩子关闭容器" class="headerlink" title="注册钩子关闭容器"></a>注册钩子关闭容器</h4><ul><li><p>在容器未关闭之前，提前设置好回调函数，让JVM在退出之前回调此函数来关闭容器</p></li><li><p>调用context的registerShutdownHook()方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        BookDao bookDao = (BookDao) context.getBean(&quot;bookDao&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">        context.registerShutdownHook();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：registerShutdownHook在ApplicationContext中也没有，还是要用其子类</p></blockquote><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310060958804.png"></p></li></ul><p>那两种方式介绍完后，close和registerShutdownHook选哪个?</p><p>相同点：这两种都能用来关闭容器</p><p>不同点：close()是在调用的时候关闭，registerShutdownHook()是在JVM退出前调用关闭。</p><ul><li>那么registerShutdownHook()方法可以在任意位置调用，下面的代码中将其放在了第二行，仍能正常输出，但要是将其换成close()方法，则会报错<code>BeanFactory not initialized or already closed</code>，这里就是already closed</li></ul><p>开发中到底用哪个呢？</p><ul><li>答案是两个都不用</li><li>分析上面的实现过程，会发现添加初始化和销毁方法，即需要编码也需要配置，实现起来步骤比较多也比较乱。</li><li>Spring给我们提供了两个接口来完成生命周期的控制，好处是可以不用再进行配置<code>init-method</code>和<code>destroy-method</code></li></ul><p>接下来在BookServiceImpl完成这两个接口的使用</p><ol><li><p>修改BookServiceImpl类，添加两个接口<code>InitializingBean</code>， <code>DisposableBean</code>并实现接口中的两个方法<code>afterPropertiesSet</code>和<code>destroy</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class BookServiceImpl implements BookService, InitializingBean, DisposableBean &#123;</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBookDao(BookDao bookDao) &#123;</span><br><span class="line">        System.out.println(&quot;set ... &quot;);</span><br><span class="line">        this.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void destroy() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;service destroy ... &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;service init ... &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>BookServiceImpl的bean配置如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bookService&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310061003388.png"></p></li></ol><h3 id="bean生命周期小结"><a href="#bean生命周期小结" class="headerlink" title="bean生命周期小结"></a>bean生命周期小结</h3><ol><li>关于Spring中对bean生命周期控制提供了两种方式:</li></ol><ul><li>在配置文件中的bean标签中添加<code>init-method</code>和<code>destroy-method</code>属性</li><li>类实现<code>InitializingBean</code>与<code>DisposableBean</code>接口</li></ul><ol><li>对于bean的生命周期控制在bean的整个生命周期中所处的位置如下</li></ol><ul><li>初始化容器<ul><li>1.创建对象(内存分配)</li><li>2.执行构造方法</li><li>3.执行属性注入(set操作)（<code>set ...</code>）</li><li>4.执行bean初始化方法（<code>service init ...</code>）</li></ul></li><li>使用bean<ul><li>执行业务操作（<code>book dao save ...</code>）</li></ul></li><li>关闭&#x2F;销毁容器<ul><li>执行bean销毁方法（<code>service destroy ...</code>）</li></ul></li></ul><ol><li>关闭容器的两种方式:</li></ol><ul><li>ConfigurableApplicationContext是ApplicationContext的子类，子类才有下面两种方法<ul><li>close()方法</li><li>registerShutdownHook()方法</li></ul></li></ul><h1 id="DI依赖注入"><a href="#DI依赖注入" class="headerlink" title="DI依赖注入"></a>DI依赖注入</h1><ol><li><p>向一个类中传递数据的方式有几种?</p><ul><li>普通方法(set方法)</li><li>构造方法</li></ul></li><li><p>依赖注入描述了在容器中建立bean与bean之间的依赖关系的过程，如果bean运行需要的是数字或字符串呢?</p><ul><li>引用类型</li><li>简单类型(基本数据类型与String)</li></ul></li></ol><p>Spring就是基于上面这些知识点，为我们提供了两种注入方式，分别是:</p><ol><li><p>setter注入</p><ul><li>简单类型</li><li>引用类型</li></ul></li><li><p>构造器注入</p><ul><li>简单类型</li><li>引用类型</li></ul></li></ol><h2 id="setter注入"><a href="#setter注入" class="headerlink" title="setter注入"></a>setter注入</h2><p>对于setter方式注入引用类型的方式之前已经学习过，快速回顾下:</p><ol><li>在bean中定义引用类型属性，并提供可访问的set方法</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class BookServiceImpl implements BookService &#123;</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line">    public void setBookDao(BookDao bookDao) &#123;</span><br><span class="line">        this.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>配置中使用property标签ref属性注入引用类型对象</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bookService&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>我们再来回顾一下配置中的两个bookDao的含义：</p><p>配置中的两个bookDao的含义是不一样的</p><ul><li>name&#x3D;”bookDao” 中bookDao的作用是让Spring的IOC容器在获取到名称后，将首字母大写，前面加set找对应的setBookDao()方法进行对象注入</li><li>ref&#x3D;”bookDao” 中bookDao的作用是让Spring能在IOC容器中找到id为bookDao的Bean对象给bookService进行注入</li></ul><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ol><li><p>在dao包下新建一个UserDao接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface UserDao &#123;</span><br><span class="line">    public void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后新建一个UserDaoImpl类实现UserDao接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class UserDaoImpl implements UserDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;user dao save ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后修改我们之前的BookDao等类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface BookDao &#123;</span><br><span class="line">    public void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface BookService &#123;</span><br><span class="line">    public void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class BookServiceImpl implements BookService &#123;</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    public void setBookDao(BookDao bookDao) &#123;</span><br><span class="line">        this.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置文件如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.dao.impl.BookDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改App运行类，加载Spring的IOC容器，并从中获取对应的bean对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        BookService bookService = (BookService) context.getBean(&quot;bookService&quot;);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="注入引用数据类型"><a href="#注入引用数据类型" class="headerlink" title="注入引用数据类型"></a>注入引用数据类型</h3><blockquote><p>需求:在bookServiceImpl对象中注入userDao</p><ol><li>在BookServiceImpl中声明userDao属性</li><li>为userDao属性提供setter方法</li><li>在配置文件中使用property标签注入</li></ol></blockquote><ol><li><p>声明userDao属性并提供setter方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class BookServiceImpl implements BookService &#123;</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line">    //声明属性</span><br><span class="line">    private UserDao userDao;</span><br><span class="line">    //提供setter</span><br><span class="line">    public void setUserDao(UserDao userDao) &#123;</span><br><span class="line">        this.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBookDao(BookDao bookDao) &#123;</span><br><span class="line">        this.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在配置文件中注入配置<br>在applicationContext.xml配置文件中使用property标签注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;&gt;&lt;/bean&gt;</span><br><span class="line">    &lt;bean id=&quot;userDao&quot; class=&quot;com.blog.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;bookService&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></li><li><p>运行程序，结果如下，userDao已经成功注入。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310061451595.png"></p></li></ol><h3 id="注入简单数据类型"><a href="#注入简单数据类型" class="headerlink" title="注入简单数据类型"></a>注入简单数据类型</h3><blockquote><p>需求：给BookDaoImpl注入一些简单数据类型的数据<br>参考引用数据类型的注入，我们可以推出具体的步骤为：</p><ol><li>在BookDaoImpl类中声明对应的简单数据类型的属性</li><li>为这些属性提供对应的setter方法</li><li>在applicationContext.xml中配置</li></ol></blockquote><p><strong>思考:</strong></p><ul><li>引用类型使用的是<code>&lt;property name=&quot;&quot; ref=&quot;&quot;/&gt;</code>,简单数据类型还是使用ref吗?</li><li>ref是指向Spring的IOC容器中的另一个bean对象的，对于简单数据类型，没有对应的bean对象，该如何配置呢?使用value来配置<code>&lt;property name=&quot;&quot; value=&quot;&quot;/&gt;</code></li></ul><ol><li><p>声明属性并提供setter方法<br>这里举例就用<code>String dataBaseName</code>和<code>int connectionCount</code>这两个属性，同时在save()方法的输出语句中加上这两个属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    private String dataBaseName;</span><br><span class="line">    private int connectionCount;</span><br><span class="line"></span><br><span class="line">    public void setDataBaseName(String dataBaseName) &#123;</span><br><span class="line">        this.dataBaseName = dataBaseName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setConnectionCount(int connectionCount) &#123;</span><br><span class="line">        this.connectionCount = connectionCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot; + dataBaseName + &quot;,&quot; + connectionCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在配置文件中进行注入配置<br>在applicationContext.xml配置文件中使用property标签注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataBaseName&quot; value=&quot;mysql&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;connectionCount&quot; value=&quot;100&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;bean id=&quot;userDao&quot; class=&quot;com.blog.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;bookService&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>value：后面跟的是简单数据类型，对于参数类型，Spring在注入的时候会自动转换，但是不能写一个错误的类型，例如<code>connectionCount</code>是<code>int</code>类型，你却给他传一个<code>abc</code>，这样的话，spring在将<code>abc</code>转换成int类型的时候就会报错。</p></li><li><p>运行程序，查看输出，两个简单数据类型也成功注入</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310061457970.png"></p></li></ol><h2 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h2><h3 id="环境准备-1"><a href="#环境准备-1" class="headerlink" title="环境准备"></a>环境准备</h3><ol><li><p>修改BookDao、BookDaoImpl、UserDao、UserDaoImpl、BookService和BookServiceImpl类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface BookDao &#123;</span><br><span class="line">    public void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    </span><br><span class="line">    private String databaseName;</span><br><span class="line">    private int connectionNum;</span><br><span class="line">    </span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface UserDao &#123;</span><br><span class="line">    public void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class UserDaoImpl implements UserDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;user dao save ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface BookService &#123;</span><br><span class="line">    public void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class BookServiceImpl implements BookService&#123;</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    public void setBookDao(BookDao bookDao) &#123;</span><br><span class="line">        this.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;bookService&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="构造器注入引用数据类型"><a href="#构造器注入引用数据类型" class="headerlink" title="构造器注入引用数据类型"></a>构造器注入引用数据类型</h3><blockquote><p>需求：将BookServiceImpl类中的bookDao修改成使用构造器的方式注入。</p><ol><li>将bookDao的setter方法删除掉</li><li>添加带有bookDao参数的构造方法</li><li>在applicationContext.xml中配置</li></ol></blockquote><ol><li><p>删除setter方法并提供构造方法</p><p>在BookServiceImpl类中将bookDao的setter方法删除掉,并添加带有bookDao参数的构造方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class BookServiceImpl implements BookService&#123;</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    public BookServiceImpl(BookDao bookDao) &#123;</span><br><span class="line">        this.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置文件中进行配置构造方式注入<br>在applicationContext.xml中配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;bookService&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot;&gt;</span><br><span class="line">        &lt;constructor-arg name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>说明：在标签<code>&lt;constructor-arg&gt;</code>中</p><ul><li>name属性对应的值为构造函数中方法<code>形参的参数名</code>，必须要保持一致。</li><li>ref属性指向的是spring的IOC容器中其他bean对象。</li></ul></li><li><p>运行程序</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310061510539.png"></p></li></ol><h3 id="构造器注入多个引用数据类型"><a href="#构造器注入多个引用数据类型" class="headerlink" title="构造器注入多个引用数据类型"></a>构造器注入多个引用数据类型</h3><blockquote><p>需求：在BookServiceImpl使用构造函数注入多个引用数据类型，比如userDao</p><ol><li>声明userDao属性</li><li>生成一个带有bookDao和userDao参数的构造函数</li><li>在applicationContext.xml中配置注入</li></ol></blockquote><ol><li><p>提供多个属性的构造函数<br>在BookServiceImpl声明userDao并提供多个参数的构造函数，save方法中记得调用userDao.save()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class BookServiceImpl implements BookService &#123;</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line">    private UserDao userDao;</span><br><span class="line"></span><br><span class="line">    public BookServiceImpl(BookDao bookDao, UserDao userDao) &#123;</span><br><span class="line">        this.bookDao = bookDao;</span><br><span class="line">        this.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在配置文件中配置多参数注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;userDao&quot; class=&quot;com.blog.dao.impl.UserDaoImpl&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;bookService&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="构造器注入多个简单数据类型"><a href="#构造器注入多个简单数据类型" class="headerlink" title="构造器注入多个简单数据类型"></a>构造器注入多个简单数据类型</h3><blockquote><p>需求:在BookDaoImpl中，使用构造函数注入databaseName和connectionNum两个参数。<br>参考引用数据类型的注入，我们可以推出具体的步骤为:</p><ol><li>提供一个包含这两个参数的构造方法</li><li>在applicationContext.xml中进行注入配置</li></ol></blockquote><ol><li><p>添加多个简单属性并提供构造方法<br>修改BookDaoImpl类，添加构造方法，同时在save()方法中输出这两个属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line"></span><br><span class="line">    private String databaseName;</span><br><span class="line">    private int connectionNum;</span><br><span class="line"></span><br><span class="line">    public BookDaoImpl(String databaseName, int connectionNum) &#123;</span><br><span class="line">        this.databaseName = databaseName;</span><br><span class="line">        this.connectionNum = connectionNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot; + databaseName + &quot;,&quot; + connectionNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置完成多个属性构造器注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;userDao&quot; class=&quot;com.blog.dao.impl.UserDaoImpl&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;databaseName&quot; value=&quot;mysql&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;connectionNum&quot; value=&quot;100&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;bookService&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><blockquote><p>也是用 VALUE 属性</p></blockquote></li></ol><h3 id="目前存在的问题"><a href="#目前存在的问题" class="headerlink" title="目前存在的问题"></a>目前存在的问题</h3><p><code>&lt;constructor-arg&gt;</code>标签内的name，必须与构造函数中的参数名一致，这两块存在紧耦合。</p><p>那么我们怎么解决这个问题呢？</p><p>在解决这个问题之前，需要提前说明的是，这个参数名发生变化的情况并不多，所以上面的还是比较主流的配置方式，下面介绍的，我们以了解为主。</p><p>方式一：删除name属性，添加type属性，按照类型注入</p><ul><li><p>这种方式可以解决构造函数形参名发生变化带来的耦合问题</p></li><li><p>但是如果构造方法参数中有类型相同的参数，这种方式就不太好实现了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;&gt;</span><br><span class="line">    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;mysql&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;constructor-arg type=&quot;int&quot; value=&quot;9421&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ul><p>方式二：删除type属性，添加index属性，按照索引下标注入，下标从0开始</p><ul><li><p>这种方式可以解决参数类型重复问题</p></li><li><p>但是如果构造方法参数顺序发生变化后，这种方式又带来了耦合问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;&gt;</span><br><span class="line">    &lt;constructor-arg index=&quot;0&quot; value=&quot;mysql&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;constructor-arg index=&quot;1&quot; value=&quot;9421&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ul><p>介绍完两种参数的注入方式，具体我们该如何选择呢?</p><ol><li>强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现<ul><li>强制依赖指对象在创建的过程中必须要注入指定的参数</li></ul></li><li>可选依赖使用setter注入进行，灵活性强<ul><li>可选依赖指对象在创建过程中注入的参数可有可无</li></ul></li><li>Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨</li><li>如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入</li><li>实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入</li><li>自己开发的模块推荐使用setter注入</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这部分主要讲解的是Spring的依赖注入的实现方式:</p><p>setter注入</p><ul><li><p>简单数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">XML</span><br><span class="line">&lt;bean ...&gt;</span><br><span class="line">    &lt;property name=&quot;&quot; value=&quot;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>引用数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">XML</span><br><span class="line">&lt;bean ...&gt;</span><br><span class="line">    &lt;property name=&quot;&quot; ref=&quot;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ul><p>构造器注入</p><ul><li><p>简单数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">XML</span><br><span class="line">&lt;bean ...&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;&quot; index=&quot;&quot; type=&quot;&quot; value=&quot;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>引用数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">XML</span><br><span class="line">&lt;bean ...&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;&quot; index=&quot;&quot; type=&quot;&quot; ref=&quot;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ul><p>依赖注入的方式选择上</p><ul><li>建议使用setter注入</li><li>第三方技术根据情况选择</li></ul><h2 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h2><p>前面花了大量的时间把Spring的注入去学习了下，总结起来就两个字<code>麻烦</code>。</p><ul><li>问:麻烦在哪?<ul><li>答:配置文件的编写配置上。</li></ul></li><li>问:有更简单方式么?<ul><li>答:有，自动配置</li></ul></li></ul><p>什么是依赖自动装配？</p><p>IOC容器根据bean所依赖的资源在容器中<code>自动查找并注入</code>到bean中的过程称为自动装配</p><h3 id="自动装配方式有哪些？"><a href="#自动装配方式有哪些？" class="headerlink" title="自动装配方式有哪些？"></a>自动装配方式有哪些？</h3><ul><li>按类型（常用）</li><li>按名称</li><li>按构造方法</li><li>不启用自动装配</li></ul><h3 id="环境准备-2"><a href="#环境准备-2" class="headerlink" title="环境准备"></a>环境准备</h3><ol><li><p>修改BookDao、BookDaoImpl、UserDao、UserDaoImpl、BookService和BookServiceImpl类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface BookDao &#123;</span><br><span class="line">    public void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    </span><br><span class="line">    private String databaseName;</span><br><span class="line">    private int connectionNum;</span><br><span class="line">    </span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface UserDao &#123;</span><br><span class="line">    public void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class UserDaoImpl implements UserDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;user dao save ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface BookService &#123;</span><br><span class="line">    public void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class BookServiceImpl implements BookService&#123;</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    public void setBookDao(BookDao bookDao) &#123;</span><br><span class="line">        this.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;bookService&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="自动装配实现"><a href="#自动装配实现" class="headerlink" title="自动装配实现"></a>自动装配实现</h3><p>自动装配只需要修改applicationContext.xml配置文件即可:</p><ol><li><p>将<code>&lt;property&gt;</code>标签删除</p></li><li><p>在<code>&lt;bean&gt;</code>标签中添加autowire属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bookService&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot; autowire=&quot;byType&quot;/&gt;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>注意事项：</p><ul><li>需要注入属性的类中对应属性的<code>setter</code>方法不能省略</li><li>被注入的对象必须要被Spring的IOC容器管理</li><li>按照类型在Spring的IOC容器中如果找到多个对象，会报<code>NoUniqueBeanDefinitionException</code></li></ul></blockquote><p>当一个类型在IOC中有多个对象，还想要注入成功，这个时候就需要按照名称注入，配置方式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--这里就有两个同一类型的bean，但是id不一样--&gt;</span><br><span class="line">    &lt;bean id=&quot;bookDao1&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;bookDao2&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;/&gt;</span><br><span class="line">    &lt;bean class=&quot;com.blog.dao.impl.BookDaoImpl&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;bookService&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot; autowire=&quot;byName&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>同时修改BookServiceImpl类汇总的<code>setBookDao</code>方法，将其重命名为<code>setBookDao1</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class BookServiceImpl implements BookService&#123;</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    public void setBookDao1(BookDao bookDao) &#123;</span><br><span class="line">        this.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么刚刚修改的是setBookDao的方法名，而不是将bookDao属性修改为bookDao1呢？按照名称注入中的名称指的是什么?</p><ul><li>因为bookDao是private修饰的，外部类无法直接访问</li><li>所以外部类只能通过属性的set方法进行访问</li><li>对外部类来说，setBookDao方法名，去掉set后首字母小写是其属性名<ul><li>为什么是去掉set首字母小写?</li><li>这个规则是set方法生成的<code>默认规则</code>，set方法的生成是把属性名首字母大写前面加set形成的方法名</li></ul></li><li>所以按照名称注入，其实是和对应的set方法有关，但是如果按照标准起名称，属性名和set对应的名是一致的</li></ul><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul><li>如果按照名称去找对应的bean对象，找不到则注入Null（空指针）</li><li>当某一个类型在IOC容器中有多个对象，按照名称注入只找其指定名称对应的bean对象，不会报错</li><li>两种方式介绍完后，以后用的更多的是<code>按照类型</code>注入。</li><li>最后对于依赖注入，需要注意一些其他的配置特征:<ol><li>自动装配用于引用类型依赖注入，不能对简单类型进行操作</li><li>使用按类型装配时（byType）必须保障容器中相同类型的bean唯一，推荐使用</li><li>使用按名称装配时（byName）必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用</li><li>自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效</li></ol></li></ul><h2 id="集合注入"><a href="#集合注入" class="headerlink" title="集合注入"></a>集合注入</h2><p>前面我们已经能完成引入数据类型和简单数据类型的注入，但是还有一种数据类型<code>集合</code>，集合中既可以装简单数据类型也可以装引用数据类型，对于集合，在Spring中该如何注入呢?</p><p>先来回顾下，常见的集合类型有哪些?</p><ul><li>数组</li><li>List</li><li>Set</li><li>Map</li><li>Properties</li></ul><p>针对不同的集合类型，实现注入</p><h4 id="注入数组类型"><a href="#注入数组类型" class="headerlink" title="注入数组类型"></a>注入数组类型</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;array&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>100<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>200<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>300<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="注入List类型"><a href="#注入List类型" class="headerlink" title="注入List类型"></a>注入List类型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;list&quot;&gt;</span><br><span class="line">    &lt;list&gt;</span><br><span class="line">        &lt;value&gt;张三&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;ABC&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;123&lt;/value&gt;</span><br><span class="line">    &lt;/list&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><h4 id="注入Set类型"><a href="#注入Set类型" class="headerlink" title="注入Set类型"></a>注入Set类型</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;set&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>100<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>200<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>ABC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>ABC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="注入Map类型"><a href="#注入Map类型" class="headerlink" title="注入Map类型"></a>注入Map类型</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;探路者&quot;</span> <span class="attr">value</span>=<span class="string">&quot;马文&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;次元游记兵&quot;</span> <span class="attr">value</span>=<span class="string">&quot;恶灵&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;易位窃贼&quot;</span> <span class="attr">value</span>=<span class="string">&quot;罗芭&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="注入Properties类型"><a href="#注入Properties类型" class="headerlink" title="注入Properties类型"></a>注入Properties类型</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;暴雷&quot;</span>&gt;</span>沃尔特·菲茨罗伊<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;寻血猎犬&quot;</span>&gt;</span>布洛特·亨德尔<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;命脉&quot;</span>&gt;</span>阿杰·切<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>property标签表示setter方式注入，构造方式注入constructor-arg标签内部也可以写<code>&lt;array&gt;</code>、<code>&lt;list&gt;</code>、<code>&lt;set&gt;</code>、<code>&lt;map&gt;</code>、<code>&lt;props&gt;</code>标签</li><li>List的底层也是通过数组实现的，所以<code>&lt;list&gt;</code>和<code>&lt;array&gt;</code>标签是可以混用</li><li>集合中要添加引用类型，只需要把<code>&lt;value&gt;</code>标签改成<code>&lt;ref&gt;</code>标签，这种方式用的比较少</li></ul><h2 id="IOC-x2F-DI配置管理第三方bean"><a href="#IOC-x2F-DI配置管理第三方bean" class="headerlink" title="IOC&#x2F;DI配置管理第三方bean"></a>IOC&#x2F;DI配置管理第三方bean</h2><p>前面所讲的知识点都是基于我们自己写的类，现在如果有需求让我们去管理第三方jar包中的类，该如何管理?</p><h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><p>前面已经完成bean与依赖注入的相关知识学习，接下来我们主要学习的是IOC容器中的<code>核心容器</code>。</p><p>这里所说的核心容器，我们可以把它简单的理解为<code>ApplicationContext</code>，前面虽然已经用到过，但是并没有系统的学习，接下来我们从以下几个问题入手来学习下容器的相关知识:</p><ul><li>如何创建容器?</li><li>创建好容器后，如何从容器中获取bean对象?</li><li>容器类的层次结构是什么?</li><li>BeanFactory是什么?</li></ul><h2 id="环境准备-3"><a href="#环境准备-3" class="headerlink" title="环境准备"></a>环境准备</h2><p>创建一个Maven项目</p><p>pom.xml添加Spring的依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">XML</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>resources下添加applicationContext.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">XML</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;</span><br><span class="line">            http://www.springframework.org/schema/beans</span><br><span class="line">            http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        &quot;&gt;</span><br><span class="line">    &lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>添加BookDao和BookDaoImpl类</p><ul><li>BookDao</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public interface BookDao &#123;</span><br><span class="line">    public void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>BookDaoImpl</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot; );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建运行类App</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        BookDao bookDao = (BookDao) ctx.getBean(&quot;bookDao&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="容器的创建方式"><a href="#容器的创建方式" class="headerlink" title="容器的创建方式"></a>容器的创建方式</h2><p>案例中创建<code>ApplicationContext</code>的方式如下</p><p>这种方式翻译为：类路径下的XML配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br></pre></td></tr></table></figure><p>除了上面这种方式，Spring还提供了另外一种创建方式</p><p>这种方式翻译为：文件系统下的XML配置文件，路径需要写绝对路径</p><p>这种方式虽能实现，但是当项目的位置发生变化后，代码也需要跟着改，耦合度高，不推荐使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = new FileSystemXmlApplicationContext(&quot;D:\xxx/xxx\applicationContext.xml&quot;);</span><br></pre></td></tr></table></figure><h3 id="获取bean的三种方式"><a href="#获取bean的三种方式" class="headerlink" title="获取bean的三种方式"></a>获取bean的三种方式</h3><p>方式一，就是我们之前用的方式</p><ul><li>这种方式存在的问题是每次获取的时候都需要进行类型转换，有没有更简单的方式呢?</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BookDao bookDao = (BookDao) ctx.getBean(&quot;bookDao&quot;);</span><br></pre></td></tr></table></figure><p>方式二</p><ul><li>这种方式可以解决类型强转问题，但是参数又多加了一个，相对来说没有简化多少。</li><li>前面是名称，后面是类型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BookDao bookDao = ctx.getBean(&quot;bookDao&quot;，BookDao.class);</span><br></pre></td></tr></table></figure><p>方式三</p><ul><li>这种方式就类似我们之前所学习依赖注入中的按类型注入。必须要确保IOC容器中该类型对应的bean对象只能有一个。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BookDao bookDao = ctx.getBean(BookDao.class);</span><br></pre></td></tr></table></figure><h3 id="BeanFactory的使用"><a href="#BeanFactory的使用" class="headerlink" title="BeanFactory的使用"></a>BeanFactory的使用</h3><p>容器的最上级的父接口为<code>BeanFactory</code>，使用<code>BeanFactory</code>也可以创建IOC容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class AppForBeanFactory &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Resource resources = new ClassPathResource(&quot;applicationContext.xml&quot;);</span><br><span class="line">        BeanFactory bf = new XmlBeanFactory(resources);</span><br><span class="line">        BookDao bookDao = bf.getBean(BookDao.class);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了更好的看出<code>BeanFactory</code>和<code>ApplicationContext</code>之间的区别，在BookDaoImpl添加如下构造函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    public BookDaoImpl() &#123;</span><br><span class="line">        System.out.println(&quot;constructor&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot; );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不去获取bean对象，打印会发现：</p><ul><li>BeanFactory是延迟加载，只有在获取bean对象的时候才会去创建</li><li>ApplicationContext是立即加载，容器加载的时候就会创建bean对象</li><li>ApplicationContext要想成为延迟加载，只需要将lazy-init设为true</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;</span><br><span class="line">            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">    &lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;  lazy-init=&quot;true&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h3 id="核心容器总结"><a href="#核心容器总结" class="headerlink" title="核心容器总结"></a>核心容器总结</h3><h4 id="容器相关"><a href="#容器相关" class="headerlink" title="容器相关"></a>容器相关</h4><p>BeanFactory是IoC容器的顶层接口，初始化BeanFactory对象时，加载的bean延迟加载</p><p>ApplicationContext接口是Spring容器的核心接口，初始化时bean立即加载</p><p>ApplicationContext接口提供基础的bean操作相关方法，通过其他接口扩展其功能</p><p>ApplicationContext接口常用初始化类</p><ul><li>ClassPathXmlApplicationContext(常用)</li><li>FileSystemXmlApplicationContext</li></ul><h4 id="bean相关"><a href="#bean相关" class="headerlink" title="bean相关"></a>bean相关</h4><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310061634303.png"></p><h4 id="依赖注入相关"><a href="#依赖注入相关" class="headerlink" title="依赖注入相关"></a>依赖注入相关</h4><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310061634580.png"></p><h1 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h1><p>Spring的IOC&#x2F;DI对应的配置开发就已经讲解完成，但是使用起来相对来说还是比较复杂的，复杂的地方在<code>配置文件</code>。<br>Spring到底是如何简化代码开发的呢?<br>要想真正简化开发，就需要用到Spring的注解开发，Spring对注解支持的版本历程:</p><ul><li>2.0版开始支持注解</li><li>2.5版注解功能趋于完善</li><li>3.0版支持纯注解开发</li></ul><p>关于注解开发，这里会讲解两块内容<code>注解开发定义bean</code>和<code>纯注解开发</code>。<br>注解开发定义bean用的是2.5版提供的注解，纯注解开发用的是3.0版提供的注解。</p><blockquote><p><strong>项目环境和依赖注入处相同</strong></p></blockquote><h2 id="注解开发定义bean"><a href="#注解开发定义bean" class="headerlink" title="注解开发定义bean"></a>注解开发定义bean</h2><ol><li><p>删除原有的XML配置<br>将配置文件中的bean标签删除掉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;/&gt;</span><br></pre></td></tr></table></figure></li><li><p>在Dao上添加注解<br>在BookDaoImpl类上添加<code>@Component</code>注解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Component(&quot;bookDao&quot;)</span><br><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：@Component注解不可以添加在接口上，因为接口是无法创建对象的。</p></blockquote><p>Service上添加注解<br>在BookServiceImpl类上也添加<code>@Component</code>交给Spring框架管理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class BookServiceImpl implements BookService &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置Spring的注解包扫描<br>为了让Spring框架能够扫描到写在类上的注解，需要在配置文件上进行包扫描</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;</span><br><span class="line">            http://www.springframework.org/schema/beans</span><br><span class="line">            http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">            http://www.springframework.org/schema/context</span><br><span class="line">            http://www.springframework.org/schema/context/spring-context.xsd</span><br><span class="line">        &quot;&gt;</span><br><span class="line">    &lt;context:component-scan base-package=&quot;com.blog&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>说明：component-scan</p><ul><li>component:组件,Spring将管理的bean视作自己的一个组件</li><li>scan:扫描<br>base-package指定Spring框架扫描的包路径，它会扫描指定包及其子包中的所有类上的注解。</li><li>包路径越多<code>如:com.blog.dao.impl</code>，扫描的范围越小速度越快</li><li>包路径越少<code>如:com.blog</code>,扫描的范围越大速度越慢</li><li>一般扫描到项目的组织名称即Maven的groupId下<code>如:com.blog</code>即可</li></ul></li><li><p>运行程序</p><p>在App类中，从IOC容器中获取对应的bean对象</p><p>因为注解的不同，获取方式也不同，分为<strong>名称</strong>和<strong>类型</strong></p><ul><li>BookServiceImpl类没有起名称，所以在App中是按照类型来获取bean对象</li><li><code>@Component</code>注解如果不起名称，会有一个默认值就是<code>当前类名首字母小写</code>，所以也可以按照名称获取</li></ul><p>对于@Component注解，还衍生出了其他三个注解<code>@Controller</code>、<code>@Service</code>、<code>@Repository</code><br>通过查看源码会发现：这三个注解和@Component注解的作用是一样的，为什么要衍生出这三个呢?<br>这是方便我们后期在编写类的时候能很好的区分出这个类是属于<code>表现层</code>、<code>业务层</code>还是<code>数据层</code>的类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        //按照名称获取bean</span><br><span class="line">        BookDao bookDao = (BookDao) context.getBean(&quot;bookDao&quot;);</span><br><span class="line">        //按照类型获取bean</span><br><span class="line">        BookService bookService = context.getBean(BookService.class);</span><br><span class="line">        bookDao.save();</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310061642263.png"></p></li></ol><h2 id="纯注解开发模式"><a href="#纯注解开发模式" class="headerlink" title="纯注解开发模式"></a>纯注解开发模式</h2><p>上面已经可以使用注解来配置bean,但是依然有用到配置文件，在配置文件中对包进行了扫描，Spring在3.0版已经支持纯注解开发，使用Java类替代配置文件，开启了Spring快速开发赛道，那么具体如何实现?</p><p>实现思路为：将配置文件applicationContext.xml删掉，用类来替换</p><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol><li><p>创建配置类<br>创建一个配置类SpringConfig，标识该类为配置类</p></li><li><p>在配置类上面加一个<code>@Configuration</code>注解，将其标识为一个配置类，用于替换掉<code>applicationContext.XML</code></p></li><li><p>用注解替换包扫描配置<br>在配置类上添加包扫描注解<code>@ComponentScan</code>替换<code>&lt;context:component-scan base-package=&quot;&quot;/&gt;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.blog&quot;)</span><br><span class="line">public class SpringConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建运行类并执行<br>创建一个新的运行类<code>AppForAnnotation</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class AppForAnnotation &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);</span><br><span class="line">        BookDao bookDao = (BookDao) context.getBean(&quot;bookDao&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">        BookService bookService = context.getBean(BookService.class);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行AppForAnnotation，可以看到两个对象依然被获取成功</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310061714330.png"></p></li></ol><p>至此，纯注解开发的方式就已经完成了，主要内容包括：</p><ul><li><p>Java类替换Spring核心配置文件</p><ul><li><code>@Configuration</code>注解用于设定当前类为配置类</li><li><code>@ComponentScan</code>注解用于设定扫描路径，此注解只能添加一次，多个数据请用数组格式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@ComponentScan(&#123;com.blog.service&quot;,&quot;com.blog.dao&quot;&#125;)</span><br></pre></td></tr></table></figure></li><li><p>读取Spring核心配置文件初始化容器对象切换为读取Java配置类初始化容器对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310061715496.png"></p><p>知识点：<code>@Configuration</code></p><table><thead><tr><th align="center">名称</th><th align="center">@Configuration</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">类注解</td></tr><tr><td align="center">位置</td><td align="center">类定义上方</td></tr><tr><td align="center">作用</td><td align="center">设置该类为spring配置类</td></tr><tr><td align="center">属性</td><td align="center">value（默认）：定义bean的id</td></tr></tbody></table><p>知识点：<code>@ComponentScan</code></p><table><thead><tr><th align="center">名称</th><th align="center">@ComponentScan</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">类注解</td></tr><tr><td align="center">位置</td><td align="center">类定义上方</td></tr><tr><td align="center">作用</td><td align="center">设置spring配置类扫描路径，用于加载使用注解格式定义的bean</td></tr><tr><td align="center">属性</td><td align="center">value（默认）：扫描路径，此路径可以逐层向下扫描</td></tr></tbody></table><h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>这部分要重点掌握的是使用注解完成Spring的bean管理，需要掌握的内容为:</p><ul><li>记住<code>@Component</code>、<code>@Controller</code>、<code>@Service</code>、<code>@Repository</code>这四个注解</li><li>applicationContext.xml中<code>&lt;context:component-san/&gt;</code>的作用是指定扫描包路径，注解为<code>@ComponentScan</code></li><li><code>@Configuration</code>标识该类为配置类，使用类替换<code>applicationContext.xml</code>文件</li><li><code>ClassPathXmlApplicationContext</code>是加载XML配置文件</li><li><code>AnnotationConfigApplicationContext</code>是加载配置类</li></ul><h2 id="注解开发bean的作用范围和生命周期"><a href="#注解开发bean的作用范围和生命周期" class="headerlink" title="注解开发bean的作用范围和生命周期"></a>注解开发bean的作用范围和生命周期</h2><p>使用注解已经完成了bean的管理，接下来按照前面所学习的内容，将通过配置实现的内容都换成对应的注解实现，包含两部分内容:<code>bean作用范围(scope)</code>和<code>bean生命周期(init和destroy)</code>。</p><h3 id="bean的作用范围"><a href="#bean的作用范围" class="headerlink" title="bean的作用范围"></a>bean的作用范围</h3><p>修改<code>AppForAnnotation</code>类，并运行查看结果</p><ul><li><p>默认情况下bean是单例</p></li><li><p>要想将BookDaoImpl变成非单例，只需要在其类上添加<code>@scope</code>注解</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class AppForAnnotation &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);</span><br><span class="line">        BookDao bookDao1 = (BookDao) context.getBean(&quot;bookDao&quot;);</span><br><span class="line">        BookDao bookDao2 = (BookDao) context.getBean(&quot;bookDao&quot;);</span><br><span class="line">        System.out.println(bookDao1);</span><br><span class="line">        System.out.println(bookDao2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Component(&quot;bookDao&quot;)</span><br><span class="line">@Scope(&quot;prototype&quot;)</span><br><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知识点：<code>@scope</code></p><table><thead><tr><th align="center">名称</th><th align="center">@Scope</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">类注解</td></tr><tr><td align="center">位置</td><td align="center">类定义上方</td></tr><tr><td align="center">作用</td><td align="center">设置该类创建对象的作用范围，可用于设置创建出的bean是否为单例对象</td></tr><tr><td align="center">属性</td><td align="center">value（默认）：定义bean作用范围，默认值singleton（单例），可选值prototype（非单例）</td></tr></tbody></table><h3 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h3><p>在BookDaoImpl中添加两个方法，<code>init</code>和<code>destroy</code>，方法名可以任意，再添加一个构造方法</p><ul><li><p>如何对方法进行标识，哪个是初始化方法，哪个是销毁方法?<br>只需要在对应的方法上添加<code>@PostConstruct</code>和<code>@PreDestroy</code>注解即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Component(&quot;bookDao&quot;)</span><br><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line"></span><br><span class="line">    public BookDaoImpl() &#123;</span><br><span class="line">        System.out.println(&quot;construct ... &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostConstruct  // 在构造方法之后执行，替换 init-method</span><br><span class="line">    public void init() &#123;</span><br><span class="line">        System.out.println(&quot;init ... &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PreDestroy // 在销毁方法之前执行,替换 destroy-method</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">        System.out.println(&quot;destroy ... &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>要想看到两个方法执行，需要注意的是<code>destroy</code>只有在容器关闭的时候，才会执行，所以需要修改App的类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class AppForAnnotation &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);</span><br><span class="line">        BookDao bookDao = (BookDao) context.getBean(&quot;bookDao&quot;);</span><br><span class="line">        System.out.println(bookDao);</span><br><span class="line">        context.registerShutdownHook();//关闭容器</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意：JDK8版本以上，如果找不到<code>@PostConstruct</code>和<code>@PreDestroy</code>注解，需要导入下面的jar包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">XML</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;javax.annotation&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.3.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>找不到的原因是，从JDK9以后jdk中的javax.annotation包被移除了，这两个注解刚好就在这个包中。</p></blockquote><p>知识点<code>@PostConstruct</code></p><table><thead><tr><th align="center">名称</th><th align="center">@PostConstruct</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">方法注解</td></tr><tr><td align="center">位置</td><td align="center">方法上</td></tr><tr><td align="center">作用</td><td align="center">设置该方法为初始化方法</td></tr><tr><td align="center">属性</td><td align="center">无</td></tr></tbody></table><p>知识点<code>PreDestroy</code></p><table><thead><tr><th align="center">名称</th><th align="center">@PreDestroy</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">方法注解</td></tr><tr><td align="center">位置</td><td align="center">方法上</td></tr><tr><td align="center">作用</td><td align="center">设置该方法为销毁方法</td></tr><tr><td align="center">属性</td><td align="center">无</td></tr></tbody></table><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>配置文件中的bean标签中的<br><code>id</code>对应<code>@Component(&quot;&quot;)</code>，<code>@Controller(&quot;&quot;)</code>，<code>@Service(&quot;&quot;)</code>，<code>@Repository(&quot;&quot;)</code><br><code>scope</code>对应<code>@scope()</code><br><code>init-method</code>对应<code>@PostConstruct</code><br><code>destroy-method</code>对应<code>@PreDestroy</code></p><h2 id="注解开发依赖注入"><a href="#注解开发依赖注入" class="headerlink" title="注解开发依赖注入"></a>注解开发依赖注入</h2><p>Spring为了使用注解简化开发，并没有提供<code>构造函数注入</code>、<code>setter注入</code>对应的注解，只提供了自动装配的注解实现。</p><h3 id="环境准备-4"><a href="#环境准备-4" class="headerlink" title="环境准备"></a>环境准备</h3><ol><li>创建一个Maven项目</li><li>pom.xml添加Spring的依赖</li><li>添加一个配置类<code>SpringConfig</code></li><li>添加BookDao、BookDaoImpl、BookService、BookServiceImpl类</li><li>创建运行类AppForAnnotation</li><li>环境准备好后，直接运行App类会有问题，因为还没有提供配置注入BookDao的，所以bookDao对象为Null,调用其save方法就会报<code>控指针异常</code>。</li></ol><h3 id="注解实现按照类型注入"><a href="#注解实现按照类型注入" class="headerlink" title="注解实现按照类型注入"></a>注解实现按照类型注入</h3><p>在BookServiceImpl类的bookDao属性上添加<code>@Autowired</code>注解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">@Service</span><br><span class="line">public class BookServiceImpl implements BookService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line"></span><br><span class="line">//    public void setBookDao(BookDao bookDao) &#123;</span><br><span class="line">//        this.bookDao = bookDao;</span><br><span class="line">//    &#125;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li><p><code>@Autowired</code>可以写在属性上，也可也写在setter方法上，最简单的处理方式是<code>写在属性上并将setter方法删除掉</code></p></li><li><p><code>@Autowired</code>是按照类型注入，那么对应BookDao接口如果有多个实现类，比如添加BookDaoImpl2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Repository</span><br><span class="line">public class BookDaoImpl2 implements BookDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候再次运行App，就会报错<code>NoUniqueBeanDefinitionException</code><br>此时，按照类型注入就无法区分到底注入哪个对象，解决方案:<code>按照名称注入</code></p><ul><li><p>先给两个Dao类分别起个名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Repository(&quot;bookDao&quot;)</span><br><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot; );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@Repository(&quot;bookDao2&quot;)</span><br><span class="line">public class BookDaoImpl2 implements BookDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...2&quot; );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>此时就可以注入成功，但是得思考个问题:</p><ul><li>@Autowired是按照类型注入的，给BookDao的两个实现起了名称，它还是有两个bean对象，为什么不报错?</li><li>@Autowired默认按照类型自动装配，如果IOC容器中同类的Bean找到多个，就按照变量名和Bean的名称匹配。因为变量名叫<code>bookDao</code>而容器中也有一个<code>booDao</code>，所以可以成功注入。</li></ul></li><li><p>为什么setter方法可以删除呢?</p><ul><li>自动装配基于反射设计创建对象并通过<code>暴力反射</code>为私有属性进行设值</li><li>普通反射只能获取public修饰的内容</li><li>暴力反射除了获取public修饰的内容还可以获取private修改的内容</li><li>所以此处无需提供setter方法</li></ul></li></ul><h3 id="注解实现按照名称注入"><a href="#注解实现按照名称注入" class="headerlink" title="注解实现按照名称注入"></a>注解实现按照名称注入</h3><p>当根据类型在容器中找到多个bean，注入参数的属性名又和容器中bean的名称不一致，这个时候该如何解决，就需要使用到<code>@Qualifier</code>来指定注入哪个名称的bean对象。<code>@Qualifier</code>注解后的值就是需要注入的bean的名称。</p><p>当根据类型在容器中找到多个bean,注入参数的属性名又和容器中bean的名称不一致，这个时候该如何解决，就需要使用到<code>@Qualifier</code>来指定注入哪个名称的bean对象。<code>@Qualifier</code>注解后的值就是需要注入的bean的名称。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class BookServiceImpl implements BookService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    @Qualifier(&quot;bookDao1&quot;)</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line">    </span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@Qualifier不能独立使用，必须和@Autowired一起使用</p></blockquote><h3 id="简单数据类型注入"><a href="#简单数据类型注入" class="headerlink" title="简单数据类型注入"></a>简单数据类型注入</h3><p>引用类型看完，简单类型注入就比较容易懂了。简单类型注入的是基本数据类型或者字符串类型，下面在<code>BookDaoImpl</code>类中添加一个<code>name</code>属性，用其进行简单类型注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Repository</span><br><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot; + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据类型换了，对应的注解也要跟着换，这次使用<code>@Value</code>注解，将值写入注解的参数中就行了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Repository</span><br><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    @Value(&quot;Stephen&quot;)</span><br><span class="line">    private String name;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot; + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意数据格式要匹配，如将”abc”注入给int值，这样程序就会报错。</p></blockquote><p>介绍完后，会有一种感觉就是这个注解好像没什么用，跟直接赋值是一个效果，还没有直接赋值简单，所以这个注解存在的意义是什么?继续往下看</p><h3 id="注解读取properties配置文件"><a href="#注解读取properties配置文件" class="headerlink" title="注解读取properties配置文件"></a>注解读取properties配置文件</h3><p><code>@Value</code>一般会被用在从properties配置文件中读取内容进行使用，具体如何实现?</p><ol><li><p>在resource下准备一个properties文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=Stephen</span><br></pre></td></tr></table></figure></li><li><p>使用注解加载properties配置文件，在配置类上添加<code>@PropertySource</code>注解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.blog&quot;)</span><br><span class="line">@PropertySource(&quot;jdbc.properties&quot;)</span><br><span class="line">public class SpringConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用@Value读取配置文件中的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Repository</span><br><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    @Value(&quot;$&#123;name&#125;&quot;)</span><br><span class="line">    private String name;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot; + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行程序</p></li></ol><p><strong>注意:</strong></p><ul><li>如果读取的properties配置文件有多个，可以使用<code>@PropertySource</code>的属性来指定多个</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@PropertySource(&#123;&quot;jdbc.properties&quot;,&quot;xxx.properties&quot;&#125;)</span><br></pre></td></tr></table></figure><ul><li><code>@PropertySource</code>注解属性中不支持使用通配符<code>*</code>,运行会报错</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@PropertySource(&#123;&quot;*.properties&quot;&#125;)</span><br></pre></td></tr></table></figure><ul><li><code>@PropertySource</code>注解属性中可以把<code>classpath:</code>加上,代表从当前项目的根路径找文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@PropertySource(&#123;&quot;classpath:jdbc.properties&quot;&#125;)</span><br></pre></td></tr></table></figure><p>知识点1：<code>@Autowired</code></p><table><thead><tr><th align="center">名称</th><th align="center">@Autowired</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">属性注解 或 方法注解（了解） 或 方法形参注解（了解）</td></tr><tr><td align="center">位置</td><td align="center">属性定义上方 或 标准set方法上方 或 类set方法上方 或 方法形参前面</td></tr><tr><td align="center">作用</td><td align="center">为引用类型属性设置值</td></tr><tr><td align="center">属性</td><td align="center">required：true&#x2F;false，定义该属性是否允许为null</td></tr></tbody></table><p>知识点2：<code>@Qualifier</code></p><table><thead><tr><th align="center">名称</th><th align="center">@Qualifier</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">属性注解 或 方法注解（了解）</td></tr><tr><td align="center">位置</td><td align="center">属性定义上方 或 标准set方法上方 或 类set方法上方</td></tr><tr><td align="center">作用</td><td align="center">为引用类型属性指定注入的beanId</td></tr><tr><td align="center">属性</td><td align="center">value（默认）：设置注入的beanId</td></tr></tbody></table><p>知识点3：<code>@Value</code></p><table><thead><tr><th align="center">名称</th><th align="center">@Value</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">属性注解 或 方法注解（了解）</td></tr><tr><td align="center">位置</td><td align="center">属性定义上方 或 标准set方法上方 或 类set方法上方</td></tr><tr><td align="center">作用</td><td align="center">为 基本数据类型 或 字符串类型 属性设置值</td></tr><tr><td align="center">属性</td><td align="center">value（默认）：要注入的属性值</td></tr></tbody></table><p>知识点4：<code>@PropertySource</code></p><table><thead><tr><th align="center">名称</th><th align="center">@PropertySource</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">类注解</td></tr><tr><td align="center">位置</td><td align="center">类定义上方</td></tr><tr><td align="center">作用</td><td align="center">加载properties文件中的属性值</td></tr><tr><td align="center">属性</td><td align="center">value（默认）：设置加载的properties文件对应的文件名或文件名组成的数组</td></tr></tbody></table><h2 id="注解开发总结"><a href="#注解开发总结" class="headerlink" title="注解开发总结"></a>注解开发总结</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310061950274.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring入门-相关概念</title>
      <link href="/2023/10/05/SSM-Spring01/"/>
      <url>/2023/10/05/SSM-Spring01/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring相关概念"><a href="#Spring相关概念" class="headerlink" title="Spring相关概念"></a>Spring相关概念</h1><h2 id="初识Spring"><a href="#初识Spring" class="headerlink" title="初识Spring"></a>初识Spring</h2><h3 id="Spring家族"><a href="#Spring家族" class="headerlink" title="Spring家族"></a>Spring家族</h3><ul><li><p>官网：<a href="https://spring.io/">https://spring.io</a>， 从官网我们可以大概了解到：</p><ul><li>Spring能做什么:用以开发web、微服务以及分布式系统等,光这三块就已经占了JavaEE开发的九成多。</li><li>Spring并不是单一的一个技术，而是一个大家族，可以从官网的<code>Projects</code>中查看其包含的所有技术。</li></ul></li><li><p>Spring发展到今天已经形成了一种开发的生态圈,Spring提供了若干个项目,每个项目用于完成特定的功能。</p><ul><li>Spring已形成了完整的生态圈，也就是说我们可以完全使用Spring技术完成整个项目的构建、设计与开发。</li><li>Spring有若干个项目，可以根据需要自行选择，把这些个项目组合起来，起了一个名称叫Spring全家桶，如下图所示</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051453970.png"></p></li></ul><p><strong>说明</strong>：</p><p>图中的图标都代表什么含义，可以进入 <a href="https://spring.io/projects">https://spring.io/projects</a> 网站进行对比查看。<br>这些技术并不是所有的都需要学习，额外需要重点关注<code>Spring Framework</code>、<code>SpringBoot</code>和<code>SpringCloud</code>:</p><ul><li>Spring Framework：Spring框架，是Spring中最早最核心的技术，也是所有其他技术的基础。</li><li>SpringBoot：Spring是来简化开发，而SpringBoot是来帮助Spring在简化的基础上能更快速进行开发。</li><li>SpringCloud：这个是用来做分布式之微服务架构的相关开发。</li></ul><p>除了上面的这三个技术外，还有很多其他的技术，也比较流行，如SpringData，SpringSecurity等，这些都可以被应用在我们的项目中。我们这里所学习的Spring其实指的是Spring Framework。</p><h2 id="Spring系统架构"><a href="#Spring系统架构" class="headerlink" title="Spring系统架构"></a>Spring系统架构</h2><h4 id="系统架构图"><a href="#系统架构图" class="headerlink" title="系统架构图"></a>系统架构图</h4><ul><li><p>Spring Framework是Spring生态圈中最基础的项目，是其他项目的根基。</p></li><li><p>Spring Framework的发展也经历了很多版本的变更，每个版本都有相应的调整</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051458839.png"></p></li><li><p>Spring Framework的5版本目前没有最新的架构图，而最新的是4版本，所以接下来主要研究的是4的架构图</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051459609.png"></p></li></ul><ol><li>核心层<ul><li>Core Container：核心容器，这个模块是Spring最核心的模块，其他的都需要依赖该模块</li></ul></li><li>AOP层<ul><li>AOP(Aspect Oriented Programming)：面向切面编程，它依赖核心层容器，目的是在不改变原有代码的前提下对其进行功能增强</li><li>Aspects：AOP是思想，Aspects是对AOP思想的具体实现</li></ul></li><li>数据层<ul><li>Data Access：数据访问，Spring全家桶中有对数据访问的具体实现技术</li><li>Data Integration：数据集成，Spring支持整合其他的数据层解决方案，比如Mybatis</li><li>Transactions：事务，Spring中事务管理是Spring AOP的一个具体实现，也是后期学习的重点内容</li></ul></li><li>Web层<ul><li>这一层的内容将在SpringMVC框架具体学习</li></ul></li><li>Test层<ul><li>Spring主要整合了Junit来完成单元测试和集成测试</li></ul></li></ol><h4 id="课程学习路线"><a href="#课程学习路线" class="headerlink" title="课程学习路线"></a>课程学习路线</h4><p>介绍完Spring的体系结构后，从中我们可以得出对于Spring的学习主要包含四部分内容，分别是:</p><ol><li>Spring的 IOC &#x2F; DI</li><li>Spring的 AOP</li><li>AOP的具体应用，事务管理</li><li>IOC &#x2F; DI的具体应用，整合 Mybatis</li></ol><h2 id="Spring核心概念"><a href="#Spring核心概念" class="headerlink" title="Spring核心概念"></a>Spring核心概念</h2><p>在Spring核心概念这部分内容中主要包含<code>IOC/DI</code>、<code>IOC容器</code>和<code>Bean</code>,那么问题就来了，这些都是什么呢?</p><h3 id="目前项目中的问题"><a href="#目前项目中的问题" class="headerlink" title="目前项目中的问题"></a>目前项目中的问题</h3><p>要想解答这个问题，就需要先分析下目前咱们代码在编写过程中遇到的问题</p><ol><li><p>业务层需要调用数据层的方法，就需要在业务层new数据层的对象</p></li><li><p>如果数据层的实现类发生变化，那么业务层的代码也需要跟着改变，发生变更后，都需要进行编译打包和重部署</p></li><li><p>所以，现在代码在编写的过程中存在的问题是：耦合度偏高</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051516237.png"></p></li></ol><p>我们就想，如果不new对象，只声明一下，不就可以降低依赖了吗，但是又会引入新的问题，去掉以后程序能运行吗?</p><ul><li><p>答案显然是不行的，因为bookDao没有赋值为Null，强行运行就会出空指针异常。<br>所以现在的问题就是，业务层不想new对象，运行的时候又需要这个对象，该咋办呢?</p></li><li><p>针对这个问题，Spring就提出了一个解决方案:</p><ul><li><p>使用对象时，在程序中不要主动使用new产生对象，转换为由外部提供对象</p></li><li><p>这种实现思就是Spring的一个核心概念</p></li></ul></li></ul><h3 id="IOC、IOC容器、Bean、DI"><a href="#IOC、IOC容器、Bean、DI" class="headerlink" title="IOC、IOC容器、Bean、DI"></a>IOC、IOC容器、Bean、DI</h3><p>IOC(Inversion of Control)控制反转</p><ul><li>那什么是控制反转呢？<ul><li>使用对象时，由主动new产生对象转换为由<code>外部</code>提供对象，此过程中对象创建控制权由程序转移到外部，此思想称为控制反转。</li><li>业务层要用数据层的类对象，以前是自己<code>new</code>的</li><li>现在自己不new了，交给<code>别人[外部]</code>来创建对象</li><li><code>别人[外部]</code>就反转控制了数据层对象的创建权</li><li>这种思想就是控制反转</li><li>别人[外部]指的是什么呢?继续往下看</li></ul></li><li>Spring和IOC之间的关系是什么呢?<ul><li>Spring技术对IOC思想进行了实现</li><li>Spring提供了一个容器，称为<code>IOC容器</code>，用来充当IOC思想中的”外部”</li><li>IOC思想中的<code>别人[外部]</code>指的就是Spring的IOC容器</li></ul></li><li>IOC容器的作用以及内部存放的是什么?<ul><li>IOC容器负责对象的创建、初始化等一系列工作，其中包含了数据层和业务层的类对象</li><li>被创建或被管理的对象在IOC容器中统称为Bean</li><li>IOC容器中放的就是一个个的Bean对象</li></ul></li><li>当IOC容器中创建好service和dao对象后，程序能正确执行么?<ul><li>不行，因为service运行需要依赖dao对象</li><li>IOC容器中虽然有service和dao对象</li><li>但是service对象和dao对象没有任何关系</li><li>需要把dao对象交给service,也就是说要绑定service和dao对象之间的关系</li><li>像这种在容器中建立对象与对象之间的绑定关系就要用到DI(Dependency Injection)依赖注入.</li></ul></li></ul><p>DI(Dependency Injection)依赖注入</p><ul><li>什么是依赖注入呢?<ul><li>在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入<ul><li>业务层要用数据层的类对象，以前是自己<code>new</code>的</li><li>现在自己不new了，靠<code>别人[外部其实指的就是IOC容器]</code>来给注入进来</li><li>这种思想就是依赖注入</li></ul></li></ul></li><li>IOC容器中哪些bean之间要建立依赖关系呢?<ul><li>这个需要程序员根据业务需求提前建立好关系，如业务层需要依赖数据层，service就要和dao建立依赖关系</li></ul></li><li>介绍完Spring的IOC和DI的概念后，我们会发现这两个概念的最终目标就是:充分解耦，具体实现靠:<ul><li>使用IOC容器管理bean（IOC)</li><li>在IOC容器内将有依赖关系的bean进行关系绑定（DI）</li><li>最终结果为:使用对象时不仅可以直接从IOC容器中获取，并且获取到的bean已经绑定了所有的依赖关系.</li></ul></li></ul><h3 id="核心概念小结"><a href="#核心概念小结" class="headerlink" title="核心概念小结"></a>核心概念小结</h3><p>重点要理解<code>什么是IOC/DI思想</code>、<code>什么是IOC容器</code>和<code>什么是Bean</code>：</p><ol><li>什么IOC&#x2F;DI思想?</li></ol><ul><li>IOC:控制反转，控制反转的是对象的创建权</li><li>DI:依赖注入，绑定对象与对象之间的依赖关系</li></ul><ol><li>什么是IOC容器?</li></ol><ul><li>Spring创建了一个容器用来存放所创建的对象，这个容器就叫IOC容器</li></ul><ol><li>什么是Bean?</li></ol><ul><li>容器中所存放的一个个对象就叫Bean或Bean对象</li></ul><p><a href="https://zhuanlan.zhihu.com/p/33492169">浅谈控制反转与依赖注入</a></p><p>从前有个人叫小明，小明有三大爱好，逛知乎，打游戏，抢红包，但是小明作为一个人类，无法仅靠自己就完成上述功能，他必须<code>依赖</code>一部手机，所以他买了一台iPhone6</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Ming extends Person</span><br><span class="line">&#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    void read()&#123;</span><br><span class="line">        <span class="operator">/</span><span class="operator">/</span>逛知乎</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void play()&#123;</span><br><span class="line">        <span class="operator">/</span><span class="operator">/</span>打游戏</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void grab()&#123;</span><br><span class="line">        <span class="operator">/</span><span class="operator">/</span>抢红包</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class iPhone6 extends Iphone</span><br><span class="line">&#123;</span><br><span class="line">    void read(String name) &#123;</span><br><span class="line">        System.out.println(name <span class="operator">+</span> &quot;打开了知乎然后编了一个故事&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void play(String name) &#123;</span><br><span class="line">        System.out.println(name <span class="operator">+</span> &quot;打开了Apex并开始白给&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void grab(String name) &#123;</span><br><span class="line">        System.out.println(name <span class="operator">+</span> &quot;开始抢红包却只抢不发&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小明很珍惜自己买的新手机，每天把它牢牢控制在手心,于是小明变成了这样</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Ming extends Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    public Ming(String name, <span class="type">int</span> age) &#123;</span><br><span class="line">        this.name <span class="operator">=</span> name;</span><br><span class="line">        this.age <span class="operator">=</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void read() &#123;</span><br><span class="line">        <span class="operator">/</span><span class="operator">/</span>逛知乎</span><br><span class="line">        <span class="keyword">new</span> iPhone6().read(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void play() &#123;</span><br><span class="line">        <span class="operator">/</span><span class="operator">/</span>打游戏</span><br><span class="line">        <span class="keyword">new</span> iPhone6().play(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void grab() &#123;</span><br><span class="line">        <span class="operator">/</span><span class="operator">/</span>抢红包</span><br><span class="line">        <span class="keyword">new</span> iPhone6().grab(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>今天是周六，小明不用上班，于是他起床，并依次逛起了知乎，打起了游戏，并抢了个红包。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ming ming <span class="operator">=</span> <span class="keyword">new</span> Ming(&quot;小明&quot;, <span class="number">18</span>);  <span class="operator">/</span><span class="operator">/</span>小明起床</span><br><span class="line">ming.read();</span><br><span class="line">ming.play();</span><br><span class="line">ming.grab();</span><br></pre></td></tr></table></figure><p>这个时候，我们可以在命令行里看到输出如下</p><blockquote><p>小明打开了知乎然后编了一个故事<br>小明打开了Apex并开始白给<br>小明开始抢红包却只抢不发</p></blockquote><p>但随着时间的推移，手机越来越卡顿，电池寿命也越来越短，到了冬天还会冻关机了，小明很难过，他意识到他需要换一部手机了。</p><p>为了获得更好的使用体验，小明一咬牙一跺脚，买了一台iPhone14 Pro Max，但他现在遇到了一个问题，他之前太过依赖那台iPhone6了，他们已经深深的耦合在一起了，如果要换手机，他必须要拿螺丝刀改造自己，将自己体内所有方法中的iPhone6换成iPhone14。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Ming extends Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    public Ming(String name, <span class="type">int</span> age) &#123;</span><br><span class="line">        this.name <span class="operator">=</span> name;</span><br><span class="line">        this.age <span class="operator">=</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void read() &#123;</span><br><span class="line">        <span class="operator">/</span><span class="operator">/</span>逛知乎</span><br><span class="line">        <span class="keyword">new</span> iPhone14().read(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void play() &#123;</span><br><span class="line">        <span class="operator">/</span><span class="operator">/</span>打游戏</span><br><span class="line">        <span class="keyword">new</span> iPhone14().play(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void grab() &#123;</span><br><span class="line">        <span class="operator">/</span><span class="operator">/</span>抢红包</span><br><span class="line">        <span class="keyword">new</span> iPhone14().grab(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然过程很辛苦，但小明觉得自己是值得的。随后在晚高峰挤地铁的时候，小明的手机被偷了。为了应急，小明只好重新使用那部刚刚被遗弃的iphone6，但是一想到那漫长的改造过程，小明的心里就说不出的委屈</p><p>他觉得自己过于依赖手机了，为什么每次手机出什么问题他都要去改造他自己，这不仅仅是过度耦合，简直是本末倒置，他向天空大喊，我不要再控制我的手机了。</p><p>天空中的造物主，也就是作为程序员的我，听到了他的呐喊，我告诉他，你不用再控制你的手机了，交给我来管理，把控制权交给我。这就叫做控制反转。</p><p>小明听到了我的话，他既高兴，又有一点害怕，他跪下来磕了几个头，虔诚地说到：“原来您就是传说中的造物主。我听到您刚刚说了 <code>控制反转</code> 四个字，就是把手机的控制权从我的手里交给你，但这只是您的想法，是一种思想罢了，要用什么办法才能实现控制反转，又可以让我继续使用手机呢？”</p><p>“呵“，身为造物主的我在表现完不屑以后，扔下了四个大字，“依赖注入！”</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Ming extends Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private <span class="type">int</span> age;</span><br><span class="line">    private Phone phone;</span><br><span class="line"></span><br><span class="line">    public Ming(String name, <span class="type">int</span> age, Phone phone) &#123;</span><br><span class="line">        this.name <span class="operator">=</span> name;</span><br><span class="line">        this.age <span class="operator">=</span> age;</span><br><span class="line">        this.phone <span class="operator">=</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void read() &#123;</span><br><span class="line">        <span class="operator">/</span><span class="operator">/</span>逛知乎</span><br><span class="line">        this.phone.read(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void play() &#123;</span><br><span class="line">        <span class="operator">/</span><span class="operator">/</span>打游戏</span><br><span class="line">        this.phone.play(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void grab() &#123;</span><br><span class="line">        <span class="operator">/</span><span class="operator">/</span>抢红包</span><br><span class="line">        this.phone.grab(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后我们来模拟小明的一天</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Phont phone <span class="operator">=</span> <span class="keyword">new</span> Iphone14();   <span class="operator">/</span><span class="operator">/</span>创建一个iphone14的实例</span><br><span class="line">if(phone.isBroken() <span class="operator">=</span><span class="operator">=</span> <span class="literal">true</span>)&#123;   <span class="operator">/</span><span class="operator">/</span>如果iphone14不可用，则使用旧版手机</span><br><span class="line">    phone <span class="operator">=</span> <span class="keyword">new</span> Iphone6();</span><br><span class="line">&#125;</span><br><span class="line">Ming ming <span class="operator">=</span> <span class="keyword">new</span> Ming(&quot;小明&quot;,<span class="number">18</span>,phone);    <span class="operator">/</span><span class="operator">/</span>小明不用关心是什么手机，他只要玩就行了。</span><br><span class="line">ming.read();</span><br><span class="line">ming.play();</span><br><span class="line">ming.grab();</span><br></pre></td></tr></table></figure><p>我们先看一下iphone14 是否可以使用，如果不可以使用，则直接换成iphone6,然后唤醒小明，并把手机塞到他的手里，换句话说，把他所依赖的手机直接注入到他的身上，他不需要关心自己拿的是什么手机，他只要直接使用就可以了。</p><p>这就是<code>依赖注入</code>。</p><h1 id="IOC入门案例"><a href="#IOC入门案例" class="headerlink" title="IOC入门案例"></a>IOC入门案例</h1><h2 id="入门案例思路分析"><a href="#入门案例思路分析" class="headerlink" title="入门案例思路分析"></a>入门案例思路分析</h2><ol><li><p>Spring是使用容器来管理bean对象的，那么管什么?</p><p>主要管理项目中所使用到的类对象，比如(Service和Dao)</p></li><li><p>如何将被管理的对象告知IOC容器?</p><p>使用配置文件</p></li><li><p>被管理的对象交给IOC容器，要想从容器中获取对象，就先得思考如何获取到IOC容器?</p><p>Spring框架提供相应的接口</p></li><li><p>IOC容器得到后，如何从容器中获取bean?</p><p>调用Spring框架提供对应接口中的方法</p></li><li><p>使用Spring导入哪些坐标?</p><p>用别人的东西，就需要在pom.xml添加对应的依赖</p></li></ol><h2 id="入门案例代码实现"><a href="#入门案例代码实现" class="headerlink" title="入门案例代码实现"></a>入门案例代码实现</h2><p>需求分析:将BookServiceImpl和BookDaoImpl交给Spring管理，并从容器中获取对应的bean对象进行方法调用。</p><ol><li><p>创建Maven的java项目</p></li><li><p>pom.xml添加Spring的依赖jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051557093.png"></p></li><li><p>创建BookDao，BookDao，BookService和BookServiceImpl四个类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface BookDao &#123;</span><br><span class="line">    public void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface BookService &#123;</span><br><span class="line">    public void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   public class BookServiceImpl implements BookService &#123;</span><br><span class="line">       private BookDao bookDao = new BookDaoImpl();</span><br><span class="line">       public void save() &#123;</span><br><span class="line">           System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">           bookDao.save();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">4. 创建 **applicationContext.xml** 文件</span><br><span class="line"></span><br><span class="line">   &gt; 右键 -&gt; 新建 -&gt; XML配置文件 -&gt; Spring配置</span><br><span class="line"></span><br><span class="line">5. 在配置文件中完成bean的配置</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   &gt; 注意事项：bean定义时id属性在同一个上下文中(配置文件)不能重复</span><br><span class="line"></span><br><span class="line">6. 获取IOC容器</span><br><span class="line">   使用Spring提供的接口完成IOC容器的创建，创建App类，编写main方法</span><br><span class="line"></span><br><span class="line">   ```App</span><br><span class="line">   public class App &#123;</span><br><span class="line">       public static void main(String[] args) &#123;</span><br><span class="line">           ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">   </span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>从容器中获取对象进行方法调用<br>使用getBean(String name)方法，其name参数就是我们在bean配置的id，通过这个id来造对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //获取IOC容器</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        //获取bean</span><br><span class="line">        BookService bookService = (BookService) context.getBean(&quot;bookService&quot;);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行程序<br>测试结果如下</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051614881.png"></p></li></ol><p>至此，Spring的IOC入门案例已经完成，但是在<code>BookServiceImpl</code>的类中依然存在<code>BookDaoImpl</code>对象的new操作，它们之间的耦合度还是比较高，这块该如何解决，就需要用到下面的<code>DI(依赖注入)</code>。</p><h1 id="DI入门案例"><a href="#DI入门案例" class="headerlink" title="DI入门案例"></a>DI入门案例</h1><h2 id="入门案例思路分析-1"><a href="#入门案例思路分析-1" class="headerlink" title="入门案例思路分析"></a>入门案例思路分析</h2><ol><li><p>要想实现依赖注入，必须要基于IOC管理Bean</p><p>DI的入门案例要依赖于前面的IOC入门案例</p></li><li><p>Service中使用new形式创建的Dao对象是否保留？</p><p>不保留，这样才能解耦合，最终要使用IOC容器中的bean对象</p></li><li><p>Service中需要的Dao对象如何进入到Service中？</p><p>在Service中提供一个方法（例如提供一个set方法），让Spring的IOC容器可以通过该方法传入bean对象，也就达到了不是自己new，而是外部提供</p></li><li><p>Service与Dao之间的关系如何描述？</p><p>使用配置文件</p></li></ol><h2 id="入门案例代码实现-1"><a href="#入门案例代码实现-1" class="headerlink" title="入门案例代码实现"></a>入门案例代码实现</h2><p>需求：基于IOC入门案例，在BookServiceImpl类中删除new对象的方式，使用Spring的DI完成Dao层的注入</p><ol><li><p>删除业务层中使用new的方式创建的dao对象</p></li><li><p>在业务层提供BookDao的setter方法<br>我们在set方法中加一条输出语句，看看是否被调用了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//private BookDao bookDao = new BookDaoImpl();</span><br><span class="line">private BookDao bookDao;</span><br><span class="line">public void setBookDao(BookDao bookDao) &#123;</span><br><span class="line">    this.bookDao = bookDao;</span><br><span class="line">    System.out.println(&quot;set方法被调用啦&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void save() &#123;</span><br><span class="line">    System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">    bookDao.save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在配置文件中添加依赖注入的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--主要变化在这里--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置server与dao的关系--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            property标签表示配置当前bean的属性</span></span><br><span class="line"><span class="comment">            name属性表示配置哪一个具体的属性(这里是配置bookService的bookDao属性)</span></span><br><span class="line"><span class="comment">            ref属性表示参照哪一个bean(参照当前配置文件中的bookDao)</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意:配置中的两个bookDao的含义是不一样的</p><ul><li>name&#x3D;”bookDao”中<code>bookDao</code>的作用是让Spring的IOC容器在获取到名称后，将首字母大写，前面加set找对应的<code>setBookDao()</code>方法进行对象注入</li><li>ref&#x3D;”bookDao”中<code>bookDao</code>的作用是让Spring能在IOC容器中找到id为<code>bookDao</code>的Bean对象给<code>bookService</code>进行注入</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051625296.png"></p></li><li><p>运行程序调用方法<br>测试结果如下</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051626803.png"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-接口</title>
      <link href="/2023/10/05/mysql%E8%BF%9B%E9%98%B6/"/>
      <url>/2023/10/05/mysql%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>视图（view）是一种虚拟存在的表。视图中的数据并不存在数据库中实际存在，行和列数据来自定义视图的查询中使用过的表，并且是在使用视图时动态生成的（视图的数据不是唯一的，而是随着表的数据变化而变化）</p><p>通俗的讲，<strong>视图只保存了查询的SQL逻辑，不保存查询的结果</strong>。所以我们在创建视图的时候，主要的工作就落在创建这条SQL语句上。</p><ol><li><p>创建</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">or</span> replace] <span class="keyword">view</span> 视图名称[(列名列表)] <span class="keyword">as</span> <span class="keyword">select</span>语句 [<span class="keyword">with</span>[<span class="keyword">cascaded</span><span class="operator">|</span><span class="keyword">local</span>] <span class="keyword">check</span> option]</span><br><span class="line"></span><br><span class="line"><span class="comment">--创建视图</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_v_1 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">where</span> id<span class="operator">&lt;</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查看创建视图语句</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">view</span> 视图名称;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查看视图数据(可以将视图理解为表的查询使用)</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 视图名称....;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">view</span> stu_v_1;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu_v_1;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu_v_1 <span class="keyword">where</span> id<span class="operator">&lt;</span><span class="number">5</span>;</span><br></pre></td></tr></table></figure></li><li><p>修改</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--方式一</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> 视图名称[(列名列表)] <span class="keyword">as</span> <span class="keyword">select</span>语句 [<span class="keyword">with</span>[<span class="keyword">cascaded</span><span class="operator">|</span><span class="keyword">local</span>]<span class="keyword">check</span> option]</span><br><span class="line"></span><br><span class="line"><span class="comment">--方式二</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> 视图名称[(列名列表)] <span class="keyword">as</span> <span class="keyword">select</span>语句 [<span class="keyword">with</span>[<span class="keyword">cascaded</span><span class="operator">|</span><span class="keyword">local</span>] <span class="keyword">check</span> option]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace stu_v_1 <span class="keyword">as</span> <span class="keyword">select</span> id,name,<span class="keyword">no</span> <span class="keyword">from</span> student <span class="keyword">where</span> id<span class="operator">&lt;=</span><span class="number">10</span>;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> stu_v_1 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">where</span> id<span class="operator">&lt;=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> [if <span class="keyword">exists</span>] 视图名称[,视图名称]</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> if <span class="keyword">exists</span> stu_v_1;</span><br></pre></td></tr></table></figure></li></ol><h2 id="检查选项"><a href="#检查选项" class="headerlink" title="检查选项"></a>检查选项</h2><p>当使用**<code>WITH CHECK OPTION</code>**子句创建视图时，MySQL会通过试图检查正在更改的每个行，例如 插入、更新、删除，以使其符合视图的定义。MySQL允许基于另一个视图创建视图，他还会检查依赖视图中的规则来保持一致性。为了确定检查的范围，MySQL提供了两个选项：cascaded和local，默认值为cascaded</p><h3 id="cascaded"><a href="#cascaded" class="headerlink" title="cascaded"></a>cascaded</h3><p>用继承帮助理解。使用这个关键字，不管父类有没有用**<code>WITH CHECK OPTION</code><strong>，都会检查父类的</strong><code>where</code>**条件。但是不管子类。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">创建视图</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v1 <span class="keyword">as</span> <span class="keyword">select</span> id,namd <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span><span class="number">20</span> <span class="keyword">with</span> <span class="keyword">cascaded</span> <span class="keyword">check</span> option;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v2 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> v1 <span class="keyword">where</span> id <span class="operator">&gt;=</span><span class="number">10</span> <span class="keyword">with</span> <span class="keyword">cascaded</span> <span class="keyword">check</span> option;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v3 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> v2 <span class="keyword">where</span> id<span class="operator">&lt;</span><span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">插入测试</span><br><span class="line"><span class="comment">--1</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_v_1 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">where</span> id<span class="operator">&lt;=</span><span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--2, 可以正常运行，但是数据添加在 student 表中，而不是在视图中。视图可以查看到</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_1 <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--3，可以正常运行，不报错，但是数据添加在 student 表中，而不是在视图中。视图中不存在这条数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_1 <span class="keyword">values</span>(<span class="number">25</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--4</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_v_2 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> stu_v_1 <span class="keyword">where</span> id<span class="operator">&gt;=</span><span class="number">10</span> <span class="keyword">with</span> <span class="keyword">cascaded</span> <span class="keyword">check</span> option;</span><br><span class="line"></span><br><span class="line"><span class="comment">--5 报错，因为不满足 id&gt;=10 的条件</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_2 <span class="keyword">values</span>(<span class="number">7</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--6 报错，因为不满足 v1视图 的id &lt;=20 条件</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_2 <span class="keyword">values</span>(<span class="number">26</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--7 可以正常运行，首先判断 是否满足4中 id&gt;=10 的条件，其次检查是否满足1中 id&lt;=20 的条件</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_2 <span class="keyword">values</span>(<span class="number">15</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--8 </span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_v_3 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> stu_v_2 <span class="keyword">where</span> id<span class="operator">&lt;=</span><span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--9 可以正常运行，因为满足v3中id&lt;=15，v2中id&gt;=10, v1&lt;=20 的条件</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_3 <span class="keyword">values</span>(<span class="number">11</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--10 可以正常运行，v3视图没有with cascaede check option,所以不会检查是否 &lt;=15,</span></span><br><span class="line"><span class="comment">--   然后检查v2视图条件，满足 id&gt;=10</span></span><br><span class="line"><span class="comment">--   因为v2视图含有with cascaede check option，检查v1视图条件 id&lt;=20</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_3 <span class="keyword">values</span>(<span class="number">17</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--11 报错，v3视图没有with cascaede check option,所以不会检查是否 &lt;=15,</span></span><br><span class="line"><span class="comment">--   然后检查v2视图条件，满足 id&gt;=10</span></span><br><span class="line"><span class="comment">--   因为v2视图含有with cascaede check option，检查v1视图条件 id&lt;=20，不满足，报错</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_3 <span class="keyword">values</span>(<span class="number">28</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="local"><a href="#local" class="headerlink" title="local"></a>local</h3><p>用继承帮助理解。使用这个关键字，如果父类使用**<code>WITH CHECK OPTION</code><strong>，才检查父类的</strong><code>where</code><strong>条件，没有</strong><code>WITH CHECK OPTION</code>**就不加条件。同样不管子类。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">创建视图</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_v_4 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">where</span> id<span class="operator">&lt;=</span><span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">插入测试</span><br><span class="line"><span class="comment">--2, 可以正常运行，但是数据添加在 student 表中，而不是在视图中。视图可以查看到</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_4 <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--3，可以正常运行，不报错，但是数据添加在 student 表中，而不是在视图中。视图中不存在这条数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_4 <span class="keyword">values</span>(<span class="number">16</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--4</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_v_5 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> stu_v_4 <span class="keyword">where</span> id<span class="operator">&gt;=</span><span class="number">10</span> <span class="keyword">with</span> <span class="keyword">local</span> <span class="keyword">check</span> option;</span><br><span class="line"></span><br><span class="line"><span class="comment">--5 可以正常运行，不报错，，因为满足v5的id&gt;=10，且v4的id&lt;=15不检查(没有local) 的条件</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_5 <span class="keyword">values</span>(<span class="number">13</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--6 可以正常运行，不报错，因为满足v5的id&gt;=10，且v4的id&lt;=15不检查(没有local) 的条件</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_5 <span class="keyword">values</span>(<span class="number">17</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--7 </span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_v_6 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> stu_v_5 <span class="keyword">where</span> id<span class="operator">&lt;=</span><span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--8 可以正常运行，因为满足v5的id&gt;=10，且v4的id&lt;=15和v6的id&lt;=20不检查(没有local) 的条件</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_6 <span class="keyword">values</span>(<span class="number">14</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="视图的更新和作用"><a href="#视图的更新和作用" class="headerlink" title="视图的更新和作用"></a>视图的更新和作用</h2><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一项，则该视图不可更新：</p><ol><li>聚合函数或者函窗口函数（sum(), min(), max(), count()等）</li><li>distinct 去重</li><li>group by 分组</li><li>having 过滤</li><li>union 或者 union all 合并查询结果</li></ol><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li><p>简单</p><p>视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件</p></li><li><p>安全</p><p>数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能看到的数据</p></li><li><p>数据独立</p><p>视图可以帮助用户屏蔽真实表结构变化带来的影响</p></li></ol><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310041019321.png"></p><ol><li><p>为了保证数据库表的安全性，开发人员在操作tb_user表时，只能看到的用户的基本字段，屏蔽手机号和邮箱两个字段。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> tb_user_view <span class="keyword">as</span> <span class="keyword">select</span> id,name,profession,age,gender,status <span class="keyword">from</span> tb_user;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user_view;</span><br></pre></td></tr></table></figure></li><li><p>查询每个学生所选修的课程（三张表联查），这个功能在很多业务中都有使用到，为了简化操作，定义一个视图</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">多表联查</span><br><span class="line"><span class="keyword">select</span> s.name,s.no,c.name <span class="keyword">from</span> student s,stuent_course sc,course c <span class="keyword">where</span> s.id <span class="operator">=</span> sc.studentid <span class="keyword">and</span> c.id <span class="operator">=</span> sc.courseid;</span><br><span class="line"></span><br><span class="line">根据联查创建视图</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> tb_stu_course_view <span class="keyword">as</span> selest s.name,s.no,c.name <span class="keyword">from</span> student s,stuent_course sc,course c <span class="keyword">where</span> s.id <span class="operator">=</span> sc.studentid <span class="keyword">and</span> c.id <span class="operator">=</span> sc.courseid;</span><br><span class="line"></span><br><span class="line">这一步大概率报错，说叫name的太多了，要起别名</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> tb_stu_course_view <span class="keyword">as</span> selest s.name student_name,s.no student_no,c.name course_name <span class="keyword">from</span> student s,stuent_course sc,course c <span class="keyword">where</span> s.id <span class="operator">=</span> sc.studentid <span class="keyword">and</span> c.id <span class="operator">=</span> sc.courseid;</span><br></pre></td></tr></table></figure></li></ol><h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><p>存储过程是事先经过编译并存储在数据库中的一段sql语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的</p><p>存储过程思想很简单，就是把数据库SQL语言层面的代码封装与重用</p><p><strong>特点：</strong>封装、复用；可以接受参数，也可以返回数据；减少网络交互，效率提升</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>创建</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名称([参数列表])</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  若干<span class="keyword">sql</span>语句</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>调用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> 名称([参数])</span><br></pre></td></tr></table></figure><p>查看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查询指定数据库的存储过程及状态信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.routines <span class="keyword">where</span> routine_schema<span class="operator">=</span><span class="string">&#x27;xxx&#x27;</span>;  </span><br><span class="line"></span><br><span class="line">查询某个存储过程的定义</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名称;</span><br></pre></td></tr></table></figure><p>删除</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> [if <span class="keyword">exists</span>] 存储过程名称;</span><br></pre></td></tr></table></figure><p>例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">存储过程基本语法</span><br><span class="line"></span><br><span class="line">创建</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p1()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> student;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">调用</span><br><span class="line"><span class="keyword">call</span> p1();</span><br><span class="line"></span><br><span class="line">查看  (查看itcast数据库的所有存储过程)</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.ROUTINES <span class="keyword">where</span> ROUTINE_SCHEMA<span class="operator">=</span><span class="string">&#x27;itcast&#x27;</span></span><br><span class="line">(查看存储过程p1的创建语句)</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">procedure</span> p1;</span><br><span class="line"></span><br><span class="line">删除</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> if <span class="keyword">exists</span> p1; </span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310041105910.png"></p><p>报错，因为命令行看见 ; 就认为结束了，打断正确语法</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310041106783.png"></p><blockquote><p><strong>注意：在命令行中，执行创建存储过程的SQL时，需要通过关键词delimiter指定SQL语句的结束符（见上图）</strong></p></blockquote><blockquote><p>delimiter：更改结束符号，如上图改为$$，避免提前结束。但是效果是持久的，要么改回来，要么j就用改的</p></blockquote><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310041117993.png"></p><h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><p>是MySQL服务器提供的，不是用户定义的，属于服务器层面。分为全局变量（GLOBAL）、会话变量（SESSION），默认会话变量</p><blockquote><p>类似浏览器页面，一个页面就是一个会话</p></blockquote><p>查看系统变量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">查看所有系统变量</span><br><span class="line"><span class="keyword">show</span> [session<span class="operator">|</span><span class="keyword">global</span>] variables; </span><br><span class="line"></span><br><span class="line">可以通过<span class="keyword">like</span>模糊匹配方式查找变量</span><br><span class="line"><span class="keyword">show</span> [session<span class="operator">|</span><span class="keyword">global</span>] variables <span class="keyword">like</span> <span class="string">&#x27;xxxx&#x27;</span>;</span><br><span class="line"></span><br><span class="line">查看指定变量的值</span><br><span class="line"><span class="keyword">select</span> @@[session<span class="operator">|</span><span class="keyword">global</span>] 系统变量名;</span><br></pre></td></tr></table></figure><p>设置系统变量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> [session<span class="operator">|</span><span class="keyword">global</span>] 系统变量名<span class="operator">=</span>值;</span><br><span class="line"><span class="keyword">set</span> @@[session<span class="operator">|</span><span class="keyword">global</span>] 系统变量名<span class="operator">=</span>值;</span><br></pre></td></tr></table></figure><blockquote><p>如果没有指定session、global，默认是session级别，会话变量</p><p>MySQL服务重新启动之后，所设置的全局参数会失效，想要不失效，可以在&#x2F;etc&#x2F;my.cnf中配置</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--  变量：系统变量</span></span><br><span class="line"><span class="comment">--  查看系统变量</span></span><br><span class="line"><span class="keyword">show</span> session variables;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> session variables <span class="keyword">like</span> <span class="string">&#x27;auto%&#x27;</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;auto%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@autocommit</span>;</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@global</span>.autocommit;   <span class="comment">--查看global级别的autocommit变量值1</span></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@session</span>.autocommit;  <span class="comment">--查看session级别的autocommit变量值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--  设置系统变量</span></span><br><span class="line"><span class="keyword">set</span> session autocommit <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> autocommit<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="用户自定义变量"><a href="#用户自定义变量" class="headerlink" title="用户自定义变量"></a>用户自定义变量</h3><p>是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用”@变量名”使用就可以。其作用域为当前连接（session级别）</p><blockquote><p>@@ 是系统变量</p><p>@    是用户自定义变量 </p></blockquote><p>赋值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="variable">@var</span>_name <span class="operator">=</span> expr [,<span class="variable">@var</span>_name2 <span class="operator">=</span> expr]...;</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@var</span>_name :<span class="operator">=</span> expr [,<span class="variable">@var</span>_name2 :<span class="operator">=</span> expr]...;</span><br><span class="line"></span><br><span class="line">推荐 :<span class="operator">=</span> ，用以区分等于运算符</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="variable">@var</span>_name :<span class="operator">=</span>expr[,<span class="variable">@var</span>_name2:<span class="operator">=</span>expr]...;</span><br><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">into</span> <span class="variable">@var</span>_name <span class="keyword">from</span> 表名；</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="variable">@var</span>_name;</span><br></pre></td></tr></table></figure><blockquote><p>用户定义的变量无需对其进行声明或初始化，只不过获取到的值为null</p></blockquote><p>例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--变量：用户变量</span></span><br><span class="line"><span class="comment">--赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="variable">@myname</span> <span class="operator">=</span> <span class="string">&#x27;itcast&#x27;</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@myage</span> :<span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@mygender</span> :<span class="operator">=</span><span class="string">&#x27;男&#x27;</span>,<span class="variable">@myhobby</span>:<span class="operator">=</span><span class="string">&#x27;java&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="variable">@mycolor</span> :<span class="operator">=</span> <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">into</span> <span class="variable">@mycount</span> <span class="keyword">from</span> tb_user;</span><br><span class="line"></span><br><span class="line"><span class="comment">--使用</span></span><br><span class="line"><span class="keyword">select</span> <span class="variable">@myname</span>,<span class="variable">@myage</span>,<span class="variable">@mygender</span>,<span class="variable">@myhobby</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@mycolor</span>,<span class="variable">@mycount</span>;</span><br></pre></td></tr></table></figure><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>局部变量是根据需要定义的在局部生效的变量，访问之前，需要declare声明。可以作存储过程内的局部变量和输入参数，局部变量的范围是在其内部声明的<code>begin ... end</code>块中有效，超出则无效。</p><p>声明</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> 变量名 数据类型 [<span class="keyword">default</span> 默认值];</span><br><span class="line"></span><br><span class="line">变量的数据类型就是数据库字段类型：<span class="type">int</span>, <span class="type">bigint</span>, <span class="type">char</span>, <span class="type">varchar</span>, <span class="type">date</span>, <span class="type">time</span>等</span><br></pre></td></tr></table></figure><p>赋值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--赋值</span></span><br><span class="line"><span class="keyword">set</span> 变量名 :<span class="operator">=</span> 值;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">into</span> 变量名 <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure><h2 id="if条件判断"><a href="#if条件判断" class="headerlink" title="if条件判断"></a>if条件判断</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if 条件<span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">....</span><br><span class="line">elseif 条件<span class="number">2</span> <span class="keyword">then</span></span><br><span class="line">....</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">....</span><br><span class="line"><span class="keyword">end</span> if; 用来结束if</span><br></pre></td></tr></table></figure><p>例：</p><p>定义存储过程，完成如下需求</p><p>根据定义的分数score变量，判断当前分数对应的分数等级</p><ol><li>score&gt;&#x3D;85,等级为优秀</li><li>score&gt;&#x3D;60分 且 score &lt;85分，等级为及格</li><li>score&lt;60分，等级为不及格</li></ol><p>缺点：</p><ol><li>当前数据写死，要改为由变量传递数值</li><li>当前结果只是展示，需要实现返回</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p1()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> scoure <span class="type">int</span> <span class="keyword">default</span> <span class="number">58</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">result</span> <span class="type">varchar</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">if score <span class="operator">&gt;=</span><span class="number">85</span> <span class="keyword">then</span>     <span class="comment">--情况1</span></span><br><span class="line">      <span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;优秀&#x27;</span>;</span><br><span class="line">elseif score<span class="operator">&gt;=</span><span class="number">60</span> <span class="keyword">then</span>  <span class="comment">--情况2 </span></span><br><span class="line">  <span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;及格&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span>                   <span class="comment">--余下情况    </span></span><br><span class="line">      <span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;不及格&#x27;</span>;</span><br><span class="line"><span class="keyword">end</span> if;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">result</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h2 id="参数（IN，OUT，INOUT）"><a href="#参数（IN，OUT，INOUT）" class="headerlink" title="参数（IN，OUT，INOUT）"></a>参数（IN，OUT，INOUT）</h2><table><thead><tr><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>IN（默认值）</td><td>该类参数作为输入，也就是需要调用时传入值</td></tr><tr><td>OUT</td><td>该类参数作为输出，也就是该参数可以作为返回值</td></tr><tr><td>INOUT</td><td>既可以作为参数，也可以作为输出参数</td></tr></tbody></table><p>用法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名称([<span class="keyword">IN</span><span class="operator">/</span><span class="keyword">OUT</span><span class="operator">/</span><span class="keyword">INOUT</span> 参数名 参数类型])</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">sql</span>语句</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>例</p><ol><li><p>根据传入参数score，判断当前分数对应的分数等级，并返回</p></li><li><ol><li>score&gt;&#x3D;85分，等级为优秀</li><li>score&gt;&#x3D;60 且score&lt;85分，等级为及格</li><li>score&lt;60分，等级为不及格</li></ol></li><li><p>&#96;&#96;&#96;sql<br>create procedure p1(in score int,out result varchar(10))<br>begin<br>  if score &gt;&#x3D; 85 then<br>set result :&#x3D; ‘优秀’;<br>  elseif score &gt;&#x3D; 60 then<br>set result :&#x3D; ‘及格’;<br>  else<br>set result :&#x3D; ‘不及格’;<br>  end if;<br>end;</p><p>call p1(66,@result)<br>select @result;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. </span><br><span class="line"></span><br><span class="line">## case</span><br><span class="line"></span><br><span class="line">![](https://raw.githubusercontent.com/icyhalo/picgo/main/202310041516564.png)</span><br><span class="line"></span><br><span class="line">```sql</span><br><span class="line">--case</span><br><span class="line">--根据传入的月份，判断月份所属的季节（要求采用case结构）</span><br><span class="line">--1-3月份，为第一季度</span><br><span class="line">--4-6月份，为第二季度</span><br><span class="line">--7-9月份，为第三季度</span><br><span class="line">--10-12月份，为第四季度</span><br><span class="line"></span><br><span class="line">create procedure p6(in month int)</span><br><span class="line">begin</span><br><span class="line">  declare result varchar(10);</span><br><span class="line">  case </span><br><span class="line">when month&gt;=1 and month&lt;=3 then </span><br><span class="line">set result:=&#x27;第一季度&#x27;;</span><br><span class="line">      when month&gt;=4 and month&lt;=6 then </span><br><span class="line">    set result:=&#x27;第二季度&#x27;;</span><br><span class="line">when month&gt;=7 and month&lt;=9 then </span><br><span class="line">set result:=&#x27;第三季度&#x27;;</span><br><span class="line">      when month&gt;=10 and month&lt;=12 then </span><br><span class="line">    set result:=&#x27;第四季度&#x27;;</span><br><span class="line">else </span><br><span class="line">set result:=&#x27;非法参数&#x27;;</span><br><span class="line">end case;</span><br><span class="line">  select concat(&#x27;您输入的月份为&#x27;,month,&#x27;,所属的季度为：&#x27;,result);</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">call p6(4);</span><br></pre></td></tr></table></figure></li></ol><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p>while循环是有条件的循环控制语句。满足条件后，再执行循环体中的SQL语句。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">先判断条件，如果条件为<span class="literal">true</span>，则执行逻辑，否则不执行逻辑</span><br><span class="line">while 条件 do</span><br><span class="line">sql...</span><br><span class="line"><span class="keyword">end</span> while;</span><br></pre></td></tr></table></figure><p>例：</p><p>计算从1累加到n的值，n为传入的参数值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p7(<span class="keyword">in</span> n <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> total <span class="type">int</span> defult <span class="number">0</span>;</span><br><span class="line">while n<span class="operator">&gt;</span><span class="number">0</span> do</span><br><span class="line">  <span class="keyword">set</span> total :<span class="operator">=</span> total <span class="operator">+</span> n;</span><br><span class="line">  <span class="keyword">set</span> n :<span class="operator">=</span> n<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> p7(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h3><p>repeat是有条件的循环控制语句，当满足条件的时候退出循环。</p><blockquote><p>至少执行一次，其余和 while 相反</p></blockquote><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#先执行一次逻辑，然后判断逻辑是否满足，如果满足，则退出。如果不满足，则继续下一次循环</span><br><span class="line">repeat</span><br><span class="line">    <span class="keyword">sql</span>逻辑</span><br><span class="line">    until条件</span><br><span class="line"><span class="keyword">end</span> repeat;</span><br></pre></td></tr></table></figure><p>例：</p><p>计算从1累加到n的值，n为传入的参数值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--A，定义局部变量，记录累加之后的值</span></span><br><span class="line"><span class="comment">--B，每循环一次，就会对n进行减1，如果n减到0，则退出循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p8(<span class="keyword">in</span> n <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line">    <span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    repeat</span><br><span class="line">        <span class="keyword">set</span> total <span class="operator">=</span> total <span class="operator">+</span> n;</span><br><span class="line">        <span class="keyword">set</span> n <span class="operator">=</span> n<span class="number">-1</span>;</span><br><span class="line">        until n<span class="operator">&lt;=</span><span class="number">0</span></span><br><span class="line">    <span class="keyword">end</span> repeat;</span><br><span class="line">    <span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> p8(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">call</span> p8(<span class="number">11</span>);</span><br></pre></td></tr></table></figure><h3 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h3><p>loop实现简单的循环，如果不在SQL逻辑中增加退出循环的条件，可以用其来实现简单的死循环。loop可以配合以下两个语句使用：</p><ul><li>leave：配合循环使用，退出循环</li><li>iterate：必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--[begin_label]的意思是标记一个名字为 [begin_label] 的循环</span></span><br><span class="line"></span><br><span class="line">[begin_label]loop</span><br><span class="line">    <span class="keyword">sql</span>逻辑</span><br><span class="line"><span class="keyword">end</span> loop [end_label]</span><br><span class="line"></span><br><span class="line">leave label;    <span class="comment">--退出指定标记的循环体，label 循环的标识</span></span><br><span class="line">iterate label;  <span class="comment">--直接进入下一次循环</span></span><br></pre></td></tr></table></figure><p>例：</p><ol><li>计算从1累加到n的值，n为传入的参数值</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p9()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    sum:loop                       <span class="comment">-- sum:loop 意思是：创建一个名字为sum的loop循环，从此处开始</span></span><br><span class="line">        if n<span class="operator">&lt;=</span><span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">            leave sum;             <span class="comment">-- leave sum 意思是：如果满足if的条件，则结束sum整这个循环</span></span><br><span class="line">        <span class="keyword">end</span> if;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">set</span> total <span class="operator">=</span> total <span class="operator">+</span> n;</span><br><span class="line">        <span class="keyword">set</span> n <span class="operator">=</span> n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">end</span> loop sum;                  <span class="comment">-- end loop sum 意思是：结束loop循环</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> p9(<span class="number">10</span>)  ;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>计算从1到n之间的偶数累加的值，n为传入的参数值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--分析问题，解决思路</span></span><br><span class="line"><span class="comment">--A，定义局部变量，记录累加之后的值</span></span><br><span class="line"><span class="comment">--B，每循环一次，就会对n进行-1，如果n减到0，则退出循环  -----&gt; leave xxx</span></span><br><span class="line"><span class="comment">--C，如果当次累加的数据是奇数，则直接进入下一次循环     -----&gt; iterate xxx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p10(<span class="keyword">in</span> n <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    sum:loop</span><br><span class="line">        if n<span class="operator">&lt;=</span><span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">            leave sum;</span><br><span class="line">        <span class="keyword">end</span> if;</span><br><span class="line">        </span><br><span class="line">        if n<span class="operator">%</span><span class="number">2</span> <span class="operator">=</span><span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">set</span> n<span class="operator">=</span> n<span class="number">-1</span>;</span><br><span class="line">            iterate sum;</span><br><span class="line">        <span class="keyword">end</span> if;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">set</span> total <span class="operator">=</span> total <span class="operator">+</span> n;</span><br><span class="line">        <span class="keyword">set</span> n<span class="operator">=</span>n<span class="number">-1</span>；</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">end</span> loop sum;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> p10(<span class="number">100</span>);</span><br></pre></td></tr></table></figure></li></ol><h2 id="游标-cursor"><a href="#游标-cursor" class="headerlink" title="游标 cursor"></a>游标 cursor</h2><p>游标（cursor）是用来存储查询结果集的数据类型，在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括游标的声明、open、fetch、close</p><p>声明</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> 游标名称 <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> 查询语句;</span><br></pre></td></tr></table></figure><p>open</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">OPEN</span> 游标名称;  </span><br></pre></td></tr></table></figure><p>fetch</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FETCH</span> 游标名称 <span class="keyword">INTO</span> 变量[，变量];</span><br></pre></td></tr></table></figure><p>close</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CLOSE</span> 游标名称;</span><br></pre></td></tr></table></figure><p>例.</p><p>根据传入的参数uage，来查询用户表tb_user中，所有的用户年龄小于等于uage的用户姓名(name)和专业(profession),并将用户的姓名和专业插入到所创建的一张新表(id,name,profession)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--逻辑</span></span><br><span class="line"><span class="comment">--A,声明游标，存储查询结果集</span></span><br><span class="line"><span class="comment">--B，准备：创建表结构</span></span><br><span class="line"><span class="comment">--C，开启游标</span></span><br><span class="line"><span class="comment">--D，获取游标中的记录</span></span><br><span class="line"><span class="comment">--E，插入数据到新表中</span></span><br><span class="line"><span class="comment">--F，关闭游标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p11(<span class="keyword">in</span> uage <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> uname <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">declare</span> upro <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">declare</span> u_cursor <span class="keyword">cursor</span> <span class="keyword">for</span> <span class="keyword">select</span> name,profession <span class="keyword">from</span> tb_user <span class="keyword">where</span> age<span class="operator">&lt;=</span>uage;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> tb_user_pro;</span><br><span class="line">    <span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> tb_user_pro(</span><br><span class="line">        id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">        name <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">        profession <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">open</span> u_cursor;</span><br><span class="line">    while ture do</span><br><span class="line">        <span class="keyword">fetch</span> u_cursor <span class="keyword">into</span> uname,upro;</span><br><span class="line">        <span class="keyword">insert</span> <span class="keyword">into</span> ub_user_pro <span class="keyword">values</span>(<span class="keyword">null</span>, uname,upro);</span><br><span class="line">    <span class="keyword">end</span> while;</span><br><span class="line">    <span class="keyword">close</span> u_cursor;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><p>触发器是与表有关的数据库对象，指在insert&#x2F;update&#x2F;delete之前或之后，触发并执行触发器中定义的SQL语句集合。<strong>触发器的这种特性可以协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作。</strong></p><p>使用别名OLD或者NEW来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还支持行级触发（触发几次就执行几次），不支持语句级触发（针对这一个语句只触发一次）。</p><p><strong>查看触发器有没有触发只需要去日志表中查看有无数据即可。</strong></p><table><thead><tr><th>类型</th><th>old 和 new</th></tr></thead><tbody><tr><td>insert型</td><td>new表示将要或者已经新增的数据</td></tr><tr><td>update型</td><td>old表示修改之前的数据，new表示将要或已经修改后的数据</td></tr><tr><td>delete型</td><td>old表示修改之前的数据,，new表示将要或已经修改后的数据</td></tr></tbody></table><p>创建触发器</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> 触发器名称</span><br><span class="line">before<span class="operator">/</span>after <span class="keyword">insert</span><span class="operator">/</span><span class="keyword">update</span><span class="operator">/</span><span class="keyword">delete</span> <span class="comment">--前后触发 和 类型</span></span><br><span class="line"><span class="keyword">on</span> 表名 <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span>  <span class="comment">--行级触发器</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    trigger_stmt;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>查看触发器</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> triggers;</span><br></pre></td></tr></table></figure><p>删除触发器</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">trigger</span> 表名.触发器名;  <span class="comment">--如果不指定表名，默认为当前数据库</span></span><br></pre></td></tr></table></figure><h3 id="例-insert触发器"><a href="#例-insert触发器" class="headerlink" title="例.insert触发器"></a>例.insert触发器</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">创建触发器</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tb_user_insert_trigger</span><br><span class="line">after <span class="keyword">update</span> <span class="keyword">on</span> tb_user <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> user_logs(id, operation, operation_time, operation_id, operate_params) <span class="keyword">values</span></span><br><span class="line">    (<span class="keyword">null</span>, <span class="string">&#x27;insert&#x27;</span>, now(), new.id, concat(<span class="string">&#x27;插入的数据内容为：id=&#x27;</span>, new.id,<span class="string">&#x27;,name=&#x27;</span>,new.name,<span class="string">&#x27;,phone=&#x27;</span>,new.phone,<span class="string">&#x27;,email=&#x27;</span>,new.eamil,<span class="string">&#x27;,profession=&#x27;</span>,new.profession))</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">查看触发器</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">trigger</span>;</span><br><span class="line"></span><br><span class="line">删除触发器</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">trigger</span> tb_user_insert_trigger;</span><br><span class="line"></span><br><span class="line">验证tb_user_insert_trigger触发器效果</span><br><span class="line"><span class="comment">--1.先插入数据到tb_user</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_user(id,name,phone,email,profession,age,gender,status,createtime)</span><br><span class="line"><span class="keyword">values</span>(<span class="number">25</span>,<span class="string">&#x27;二皇子&#x27;</span>,<span class="string">&#x27;18809091212&#x27;</span>,<span class="string">&#x27;erhuangzi@163.com&#x27;</span>,<span class="string">&#x27;软件工程&#x27;</span>,<span class="number">23</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,now());</span><br><span class="line"></span><br><span class="line"><span class="comment">--2.查看日志表是否含有新插入的数据</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user_logs;</span><br><span class="line"></span><br><span class="line"><span class="comment">--3.再插入一条数据到tb_user</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_user(id,name,phone,email,profession,age,gender,status,createtime)</span><br><span class="line"><span class="keyword">values</span>(<span class="number">26</span>,<span class="string">&#x27;三皇子&#x27;</span>,<span class="string">&#x27;18809091212&#x27;</span>,<span class="string">&#x27;erhuangzi@163.com&#x27;</span>,<span class="string">&#x27;软件工程&#x27;</span>,<span class="number">23</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,now());</span><br><span class="line"></span><br><span class="line"><span class="comment">--4.再次查看日志表是否含有新插入的数据</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user_logs;</span><br></pre></td></tr></table></figure><h3 id="例-update触发器"><a href="#例-update触发器" class="headerlink" title="例.update触发器"></a>例.update触发器</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--1.创建update类型的触发器</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tb_user_update_trigger</span><br><span class="line">after <span class="keyword">update</span> <span class="keyword">on</span> tb_user <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> user_logs(id, operation, operation_time, operation_id, operation_param) <span class="keyword">values</span></span><br><span class="line">    (<span class="keyword">null</span>,<span class="string">&#x27;update&#x27;</span>,now(),new.id, </span><br><span class="line">        concat(<span class="string">&#x27;更新之前的数据：id=&#x27;</span>,old.id,<span class="string">&#x27;,name=&#x27;</span>,<span class="string">&#x27;,name=&#x27;</span>,old.name,<span class="string">&#x27;,phone=&#x27;</span>,old.phone,<span class="string">&#x27;,email=&#x27;</span>,old.eamil,<span class="string">&#x27;,profession=&#x27;</span>,old.profession,</span><br><span class="line">        <span class="string">&#x27;| 更新之后的数据：id=&#x27;</span>,new.id,<span class="string">&#x27;,name=&#x27;</span>,new.name,<span class="string">&#x27;,phone=&#x27;</span>,new.phone,<span class="string">&#x27;,email=&#x27;</span>,new.eamil,<span class="string">&#x27;,profession=&#x27;</span>,new.profession)</span><br><span class="line">    );</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--2.更新tb_user表中的数据</span></span><br><span class="line"><span class="keyword">update</span> tb_user <span class="keyword">set</span> profession <span class="operator">=</span><span class="string">&#x27;会计&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span><span class="number">23</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--3.验证tb_user_update_trigger触发器是否有作用，查看user_logs表数据</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>  user_logs;  </span><br></pre></td></tr></table></figure><h3 id="例-delete触发器"><a href="#例-delete触发器" class="headerlink" title="例.delete触发器"></a>例.delete触发器</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--1，创建删除触发器</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tb_user_delete_trigger</span><br><span class="line">after <span class="keyword">delete</span> <span class="keyword">on</span> tb_user <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> user_logs(id, operation, operation_time, operation_id, operation_param) <span class="keyword">values</span></span><br><span class="line">    (<span class="keyword">null</span>,<span class="string">&#x27;update&#x27;</span>,now(),new.id, </span><br><span class="line">        concat(<span class="string">&#x27;删除之前的数据：id=&#x27;</span>,old.id,<span class="string">&#x27;,name=&#x27;</span>,<span class="string">&#x27;,name=&#x27;</span>,old.name,<span class="string">&#x27;,phone=&#x27;</span>,old.phone,<span class="string">&#x27;,email=&#x27;</span>,old.eamil,<span class="string">&#x27;,profession=&#x27;</span>,old.profession));</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--2，删除tb_user表中的数据</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> id<span class="operator">=</span><span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--3,验证删除触发器是否执行，查询user_logs表中是否有删除的记录数据</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user_logs;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310041710156.png"></p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源(CPU、RAM、I&#x2F;O)的争用以外，数据也是一种供多个用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，针对数据库而言显得尤为重要，也更加复杂。</p><p>MySQL中的锁，按照锁的粒度分，分为以下三类：</p><ol><li>全局锁：锁定数据库中的所有表</li><li>表级锁：每次操作锁住整张表</li><li>行级锁：每次操作锁住对应的行数据</li></ol><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。</p><p>其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性的视图，保证数据的完整性。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--1.添加全局锁</span></span><br><span class="line">mysql<span class="operator">&gt;</span> flush tables <span class="keyword">with</span> read lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">--2.备份表,直接在cmd命令中执行</span></span><br><span class="line">CMD: mysqldump <span class="operator">-</span>h ip <span class="operator">-</span>u用户名 <span class="operator">-</span>p密码 数据库名 <span class="operator">&gt;</span> 磁盘路径<span class="operator">/</span>文件名.<span class="keyword">sql</span></span><br><span class="line">CMD: mysqldump <span class="operator">-</span>h <span class="number">192.168</span><span class="number">.200</span><span class="number">.202</span> <span class="operator">-</span>uroot <span class="operator">-</span>p1234 db01 <span class="operator">&gt;</span> D:<span class="operator">/</span>db01.sql</span><br><span class="line"></span><br><span class="line"><span class="comment">--3.释放锁</span></span><br><span class="line">mysql<span class="operator">&gt;</span> unlook tables;</span><br></pre></td></tr></table></figure><ul><li>特点</li></ul><p>数据库中加全局锁，是一个比较中的操作，存在以下问题：</p><ol><li>如果在主库中备份，那么在备份期间都不能执行更新，业务基本上就得停摆</li><li>如果在从库中备份，那么在备份期间从库不能执行主库同步过来的二进制日志(binlog)，会导致主从延迟</li></ol><p> 在InnoDB引擎中，我们可以在备份时加上参数 –single-transaction 参数来完成不加锁的一致性数据备份</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="comment">--single-transaction -uroot -p1234 itcast &gt; itcast.sql</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310041718267.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310041722798.png"></p><blockquote><p>此时只能查询，其他语句都无效</p></blockquote><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310041726659.png"></p><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>表级锁，每次操作锁住整张锁。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中</p><p>对于表级锁，主要分为以下三类：</p><ol><li>表锁</li><li>元数据锁（meta data lock, MDL）</li><li>意向锁</li></ol><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>对于表锁，分为两类：</p><ol><li>表共享读锁 &#x2F; 读锁（read lock）</li><li>表独占写锁 &#x2F; 写锁（write lock）</li></ol><p>语法</p><ol><li>加锁：lock tables 表名 …… read&#x2F;write;</li><li>释放锁：unlock tables&#x2F; 客户端断开连接</li></ol><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310042151317.png"></p><blockquote><p>加读锁，其他进程能读不能写</p><p>加写锁，其他进程能读不能写也不能读</p></blockquote><h3 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h3><p>MDL（meta data lock）加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与DDL冲突(增删改查和修改表结构语句的冲突)，保证读写的正确性。</p><p>在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁（共享）；当对表结构进行变更操作的时候，加MDL写锁（排他）</p><blockquote><p>元数据简单理解就是 表结构</p></blockquote><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310042155630.png"></p><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查<br><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310042202748.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310042203183.png"></p><ol><li>意向共享锁（IS）：与表锁共享锁(read)兼容，与表锁排它锁（write）互斥。由语句select ….. Lock in share mode添加</li><li>意向排它锁（IX）：与表锁共享锁(read)及排他锁（write）都互斥。意向锁之间不会互斥。由insert、update、delete、select…..for update 添加</li></ol><p>线程A执行：首先begin开启事务，执行update的时候会将指定行的加上行锁，紧接着会对整张表加上一个意向锁</p><p>线程B执行的之前，会检查这张表得到意向锁情况，能否加上线程B的锁取决于对意向锁的判断。如果线程B添加的表锁和线程A的意向锁兼容，则可以加锁。如果不兼容，则线程B处于阻塞状态，阻塞状态随着线程A事务的commit提交，释放意向锁和行锁之后，线程B才能加表锁。</p><p>可以通过以下SQL，查看意向锁及行锁的加锁情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> object_schema, object_name, index_name, lock_type, lock_mode, lock_data </span><br><span class="line"><span class="keyword">from</span> performance_schema.data_locks;</span><br></pre></td></tr></table></figure><h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。</p><p>InnoDB的数据是基于索引组织的，行锁的通过对索引上的索引项来加锁实现的，而不是对记录加的锁。对于行级锁，主要分为三类：</p><ol><li>行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此进行update和delete。在Read Commit、Read Repeatable隔离级别下都支持</li><li>间隙锁（Gap Lock ）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RP隔离级别下都支持</li><li>临键锁（Next-key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RP隔离级别下支持</li></ol><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310042035102.png"></p><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p>InnoDB实现了以下两种类型的行锁</p><ol><li>共享锁（S）：运行一个事务去读一行，阻止其他事务获得相同数据集的排他锁</li><li>排他锁（X）：运行获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁</li></ol><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310042037218.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310042043978.png"></p><h4 id="行锁演示"><a href="#行锁演示" class="headerlink" title="行锁演示"></a>行锁演示</h4><p>默认情况下，InnoDB在Repeatable Read事务隔离级别运行，在InnoDB使用next-key锁进行搜索和索引扫描，以防止幻读</p><ol><li>针对唯一索引进行检索时，对已存在的记录进行等值匹配，将会自动优化为行锁</li><li>InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会升级为表锁。</li></ol><p>可以通过以下SQL，查看意向锁及行锁的加锁情况</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> object<span class="operator">-</span>schema, object_name, index_name, lock_type, lock_mode, lock_data</span><br><span class="line"><span class="keyword">from</span> performance_schema.data_locks;</span><br></pre></td></tr></table></figure><h3 id="间隙锁、临键锁"><a href="#间隙锁、临键锁" class="headerlink" title="间隙锁、临键锁"></a>间隙锁、临键锁</h3><p>默认情况下，InnoDB在RepeatableRead事务隔离级别运行，InnoDB使用next-key锁进行搜索和索引扫描，以防止幻读</p><ol><li>索引上的等值查询（唯一索引），给不存在的记录加锁时，优化为间隙锁</li><li>索引上的等值查询（普通索引），向右遍历时最后一个值不满足查询需求时，next-key lock退化为间隙锁</li><li>索引上的范围查询（唯一索引），会访问到不满足条件的第一个值为止</li></ol><blockquote><p>间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一个间隙上采用间隙锁。</p><p>间隙锁不包含边界，只包含间隙范围 ()</p><p>临键锁包含边界数据和间隙范围 []</p></blockquote><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310042133775.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310042207350.png"></p><h1 id="InnoDB引擎"><a href="#InnoDB引擎" class="headerlink" title="InnoDB引擎"></a>InnoDB引擎</h1><h2 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310050937462.png"></p><p><strong>表空间（idb文件）</strong>：一个MySQL实例可以对应多个表空间，用来存储记录、索引等数据</p><p><strong>段</strong>：分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段（Rollback segment）、InnoDB是索引组织表，数据段就是B+树的叶子节点，索引段即为B+树的非叶子节点。段用来管理多个Extent（区）</p><p><strong>区</strong>：表空间的单元结构，每个区的大小为1M。默认情况下，InnoDB存储引擎页大小为16K，即一个区中一共有64个连续的页。</p><p><strong>页</strong>：是InnoDB存储引擎磁盘管理的最小单元，每个页的大小默认为16KB。为了保证页的连续性，InnoDB存储引擎每次从磁盘申请4–5个区</p><p><strong>行</strong>：InnoDB存储引擎数据是按行进行存放的。</p><p>Trx_id：每次对某条记录进行改动时，都会把对应的事务Id赋值给Tri_id隐藏列</p><p>Roll_pointer：每次对某条记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310050940962.png"></p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>MySQL5.5版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发中使用非常广泛。下面是InnoDB架构图，左侧为内存结构，右侧为磁盘结构</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310050942995.png"></p><h3 id="内存架构"><a href="#内存架构" class="headerlink" title="内存架构"></a>内存架构</h3><h4 id="Buffer-Pool：缓冲池"><a href="#Buffer-Pool：缓冲池" class="headerlink" title="Buffer Pool：缓冲池"></a>Buffer Pool：缓冲池</h4><p>缓冲池是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度。</p><p>缓冲池以Page页为单位，底层采用链表数据结构管理Page。根据状态，将Page分为三种类型（上图中不同颜色的方块表示）</p><ul><li>Free page：空闲page，未被使用</li><li>Clean page：被使用page，数据没有被修改过</li><li>Dirty page：脏页，被使用page，数据被修改过，页中数据与磁盘的数据产生了不一致。</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310050943396.png"></p><h4 id="Change-Buffer：更改缓冲区"><a href="#Change-Buffer：更改缓冲区" class="headerlink" title="Change Buffer：更改缓冲区"></a>Change Buffer：更改缓冲区</h4><p>Change buffer：更改缓冲区（针对于非唯一二级索引页），在执行DML语句时，如果这些数据Page没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区Change Buffer中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中</p><p><strong>Change Buffer的意义是什么？</strong></p><p>与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量得到磁盘IO。有了Change Buffer之后，我们可以在缓冲池中进行合并处理，减少磁盘IO</p><h4 id="Adaptive-hash-Index：自适应哈希索引"><a href="#Adaptive-hash-Index：自适应哈希索引" class="headerlink" title="Adaptive hash Index：自适应哈希索引"></a>Adaptive hash Index：自适应哈希索引</h4><p>自适应hash索引，用于优化对BufferPool数据的查询。InnoDB存储引擎会监控对表上各索引页的查询，如果观察到hash索引可以提升速度，则建立Hash索引，称之为自适应hash索引</p><p>自适应哈希索引，无需人工干预，是系统根据情况自动完成的</p><p>参数：adaptive_hash_index</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%hash_index%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--on 表示开启</span></span><br></pre></td></tr></table></figure><h4 id="Log-Buffer：日志缓存区"><a href="#Log-Buffer：日志缓存区" class="headerlink" title="Log Buffer：日志缓存区"></a>Log Buffer：日志缓存区</h4><p>用来保存要写入到磁盘中的log日志数据（redo log、undo log），默认大小为16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或者删除许多行的事务，增加日志缓冲区的大小可以节省磁盘I&#x2F;O</p><p>参数： innodb_log_buffer_size：缓冲区大小</p><p> innodb_flush_log_at_trx_commit：日志刷新到磁盘时机。 </p><p>0：每秒将日志写入并刷新到磁盘一次</p><p>1：日志在每次事务提交时写入并刷新到磁盘（默认值）</p><p>2：日志在每次事务提交后写入，并每秒刷新到磁盘一次</p><h3 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h3><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310050950558.png"></p><h4 id="System-Tablespace"><a href="#System-Tablespace" class="headerlink" title="System Tablespace"></a>System Tablespace</h4><p>系统表空间是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建的，它也可能包含表和索引数据。（在MySQL5.x版本中还包含InnoDB数据字典、undolog等）</p><p>参数：innodb_data_file_path</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310050952666.png"></p><h4 id="File-Per-Tablespaces"><a href="#File-Per-Tablespaces" class="headerlink" title="File-Per-Tablespaces"></a>File-Per-Tablespaces</h4><p>每个表的文件表空间包含单个InnoDB表的数据和索引，并存储在文件系统上的单个数据文件中</p><p>参数：innodb_file_per_table。</p><p>on表示每一张表都会生成一个表空间文件。下图 .idb 结尾的文件就是表空间文件。每个表空间文件中存储的是这个表的表结构、数据、索引</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310050953194.png"></p><h4 id="General-Tablespace"><a href="#General-Tablespace" class="headerlink" title="General Tablespace"></a>General Tablespace</h4><p>通用表空间，需要通过CREATE TABLESPACE语法创建通用表空间，在创建表时，可以指定该表空间</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--创建通用表空间语法</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span>space xxx <span class="keyword">add</span> datafile <span class="string">&#x27;文件名&#x27;</span> engine <span class="operator">=</span> 引擎名称;</span><br><span class="line"></span><br><span class="line"><span class="comment">--实操案例，创建表空间</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span>space ts_itheima <span class="keyword">add</span> datafile <span class="string">&#x27;myitheima.idb&#x27;</span> engin <span class="operator">=</span> innodb;</span><br><span class="line"></span><br><span class="line">use itcast;</span><br><span class="line"></span><br><span class="line"><span class="comment">--创建表，指定这个表的表空间为ts_itheima </span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> a(id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment, name <span class="type">varchar</span>(<span class="number">20</span>))engine<span class="operator">=</span>innodb tablespace ts_itheima;</span><br></pre></td></tr></table></figure><h4 id="Undo-Tablespace"><a href="#Undo-Tablespace" class="headerlink" title="Undo Tablespace"></a>Undo Tablespace</h4><p>撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间（初始化大小16M），用于存储undo log日志</p><h4 id="Temporary-Tablespace"><a href="#Temporary-Tablespace" class="headerlink" title="Temporary Tablespace"></a>Temporary Tablespace</h4><p>InnoDB使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据</p><h4 id="Doublewrite-Buffer-Files"><a href="#Doublewrite-Buffer-Files" class="headerlink" title="Doublewrite Buffer Files"></a>Doublewrite Buffer Files</h4><p>双写缓冲区，innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入到双写缓冲区文件中，便于系统异常时恢复数据</p><h4 id="Redo-log"><a href="#Redo-log" class="headerlink" title="Redo log"></a>Redo log</h4><p>重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲(在内存中，redo log buffer)以及重做日志文件(在磁盘中，redo log)。当事务提交之后会把所有修改信息都会存到该日志中，用于在刷新脏页到磁盘时，发生错误时，进行数据恢复使用。</p><p>以循环方式写入重做日志文件，涉及两个文件：ib_logfile0 , ib_logfile1</p><h3 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h3><p>后台线程的作用就是在合适的时机将InnoDB存储引擎缓冲池的数据刷新到磁盘文件当中。</p><p>后台线程有4种：</p><ol><li><p>Master Thread  </p><p>核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中，保持数据的一致性，还包括脏页的刷新、合并插入缓存、undo页的回收</p></li><li><p>IO Thread  </p><p>在InnoDB存储引擎中大量使用了AIO(异步IO)来处理IO请求，这样可以极大的提高数据库的性能，而IO Thread主要负责这些IO请求的回调</p></li></ol><table><thead><tr><th>线程类型</th><th>默认个数</th><th>职责</th></tr></thead><tbody><tr><td>Read thread</td><td>4</td><td>负责读操作</td></tr><tr><td>Write thread</td><td>4</td><td>负责写操作</td></tr><tr><td>Log thread</td><td>1</td><td>负责将日志缓冲区刷新到磁盘</td></tr><tr><td>Insert buffer thread</td><td>1</td><td>负责将写缓冲区内容刷新到磁盘</td></tr></tbody></table><ol start="3"><li><p>Purge Thread</p><p>主要用于回收事务已经提交了undo log，在事务提交之后，undo log可能不用了 ，就用此线程来回收</p></li><li><p>Page Cleaner Thread</p><p>协助Master Thread刷新脏页到磁盘的线程，他可以减轻Master Thread的工作压力，减少阻塞。</p></li></ol><h2 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h2><h3 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a><strong>什么是事务？</strong></h3><p>是一组操作的集合，他是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败</p><h3 id="事务的特点"><a href="#事务的特点" class="headerlink" title="事务的特点"></a><strong>事务的特点</strong></h3><ul><li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败</li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li><li>持久性（Durability）：事务一旦提交或回滚，它对数据库的数据的改变就是永久的</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051012233.png"></p><h3 id="Redo-log-–-持久性"><a href="#Redo-log-–-持久性" class="headerlink" title="Redo log – 持久性"></a>Redo log – 持久性</h3><p>重做日志，记录的是事务提交时数据页的物理修改，<strong>是用来实现事务的持久性</strong>。</p><p>该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file）,前者是在内存中，后者是在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中，用于在刷新脏页到磁盘，发生错误时，进行数据恢复使用</p><p>正常执行的先后顺序是1234，当4（缓冲池的数据刷新到磁盘时）发生了错误，此时redo log的两份日志文件会将数据正确的同步到相应操作受影响的表空间(.ibd文件)中</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051017488.png"></p><h3 id="Undo-log-–-原子性"><a href="#Undo-log-–-原子性" class="headerlink" title="Undo log – 原子性"></a>Undo log – 原子性</h3><p> 回滚日志，用于记录数据被修改前的信息，作用包含两个：提供回滚和MVCC（多版本并发控制）</p><p>Undo log（逻辑日志）和 redo log（物理日志）不一样。可以认为当delete一条数据时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚</p><p>Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC</p><p>Undo log存储：undo log采用段的方式进行管理和记录，存放在前面介绍的rollback segment回滚段中，内部包含1024个undo log segment</p><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><ul><li><strong>当前读</strong></li></ul><p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如select … Lock in share mode(共享锁),select … For update、update、insert、delete（排他锁）都是一种当前读。</p><ul><li><strong>快照读</strong></li></ul><p>简单的select（不加锁）就是快照读，快照读读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。</p><ul><li><p>Read Committted：每次select，都生成一个快照读</p></li><li><p>Repeatable Read：开始事务后第一个select语句才是快照读的地方</p></li><li><p>Serializable：快照读会退化为当前读。</p></li><li><p><strong>MVCC</strong></p></li></ul><p>全称Muti-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySql实现MVCC提供一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库中的三个隐式字段、undo log日志、readView</p><h3 id="MVCC–实现原理"><a href="#MVCC–实现原理" class="headerlink" title="MVCC–实现原理"></a>MVCC–实现原理</h3><h4 id="记录中的隐藏字段"><a href="#记录中的隐藏字段" class="headerlink" title="记录中的隐藏字段"></a>记录中的隐藏字段</h4><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051031987.png"></p><p>如图所示，当创建表的字段有 id age name的时候，MySQL会创建 DB_TRX_ID，DB_ROLL_PTR，DB_ROW_ID这三个隐藏字段</p><table><thead><tr><th>隐藏字段</th><th>含义</th></tr></thead><tbody><tr><td>DB_TRX_ID</td><td>最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID</td></tr><tr><td>DB_ROLL_PTR</td><td>回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版本</td></tr><tr><td>DB_ROW_ID</td><td>隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查看表空间文件，表空间文件中可以查看表的详细信息，比如数据库的版本号，表的所有字段（包括隐藏字段）</span><br><span class="line">ibd2sdi xxx.ibd</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051033402.png"></p><h4 id="Undo-log版本链"><a href="#Undo-log版本链" class="headerlink" title="Undo log版本链"></a>Undo log版本链</h4><ul><li><p>Undo log</p><p>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志</p><p>当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。</p><p>而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会被立即删除。</p></li><li><p>Undo log 版本链</p><p>不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条记录版本链表，链表的头部是最新的旧纪录，链表尾部是最早的旧纪录。</p><p>那么我执行一条查询语句，数据库给我反馈的数据到底是哪个版本，是谁控制决定的呢？看下面ReadView</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051039486.png" alt="初始"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051039179.png"></p></li></ul><h4 id="Readview"><a href="#Readview" class="headerlink" title="Readview"></a>Readview</h4><p>ReadView(读视图)是快照读SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id.</p><p>readview中包含了四个核心字段：</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>m_ids</td><td>当前活跃的事务ID集合</td></tr><tr><td>min_trx_id</td><td>最小活跃事务ID</td></tr><tr><td>max_trx_id</td><td>预分配事务ID，当前最大事务ID+1（因为事务ID是自增的）</td></tr><tr><td>create_trx_id</td><td>ReadView创建者的事务ID</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051044061.png"></p><p><strong>不同的隔离级别，生成ReadView的时机不同：</strong></p><ul><li><strong>READ COMMITTED：在事务中每一次执行快照读时生成ReadView</strong></li><li><strong>REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView</strong></li></ul><h3 id="MVCC–原理分析"><a href="#MVCC–原理分析" class="headerlink" title="MVCC–原理分析"></a>MVCC–原理分析</h3><p>RC读已提交隔离级别下，在事务中每一次执行快 照读时生成ReadView。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051048472.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051055787.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051055429.png"></p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051055494.png"></p><h1 id="MySQL管理"><a href="#MySQL管理" class="headerlink" title="MySQL管理"></a>MySQL管理</h1><h2 id="系统数据库介绍"><a href="#系统数据库介绍" class="headerlink" title="系统数据库介绍"></a>系统数据库介绍</h2><p>MySQL数据库安装完成后，自带了以下四个数据库（8.0之后），具体作用如下：</p><table><thead><tr><th>数据库</th><th>含义</th></tr></thead><tbody><tr><td>mysql</td><td>存储MySQL服务器正常运行所需要的各种信息（时区、主从、用户、权限等）</td></tr><tr><td>information_schema</td><td>提供了访问数据库元数据的各种表和视图，包含数据库、表、字段类型及访问权限</td></tr><tr><td>performance_schema</td><td>为MySQL服务器运行时状态提供了一个底层监控功能，主要用于收集数据库服务器性能参数</td></tr><tr><td>sys</td><td>包含了一系列方便DBA和开发人员利用performance_schema性能数据库进行性能调优和诊断的视图</td></tr></tbody></table><h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h2><h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><p>该mysql不是指mysql服务，而是指mysql的客户端工具</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--语法</span></span><br><span class="line">mysql [options] [database]</span><br><span class="line"></span><br><span class="line"><span class="comment">--选项</span></span><br><span class="line"><span class="operator">-</span>u, <span class="comment">--user=name         #指定用户名</span></span><br><span class="line"><span class="operator">-</span>p, <span class="comment">--password[=name]   #指定密码</span></span><br><span class="line"><span class="operator">-</span>h, <span class="comment">--host=name         #指定服务器IP或域名</span></span><br><span class="line"><span class="operator">-</span>P, <span class="comment">--port=port         #指定连接端口</span></span><br><span class="line"><span class="operator">-</span>e, <span class="comment">--execute=name      #执行SQL语句并退出</span></span><br></pre></td></tr></table></figure><p>-e选项可以在MySQL客户端执行SQL语句，而不用连接到MySQL数据库再执行，对于一些批处理脚本，这种方式尤其方便，实例如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">-</span>uroot <span class="operator">-</span>p123456 db01 <span class="operator">-</span>e &quot;select * from stu&quot;;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051116745.png"></p><h3 id="mysqladmin"><a href="#mysqladmin" class="headerlink" title="mysqladmin"></a>mysqladmin</h3><p>mysqladmin是一个执行管理操作的客户端程序。可以用它来检查服务器的配置和当前状态、创建并删除数据库等</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--通过帮助文档查看选项</span></span><br><span class="line">mysqladmin <span class="comment">--help</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--示例</span></span><br><span class="line">mysqladmin <span class="operator">-</span>uroot <span class="operator">-</span>p123456 <span class="keyword">drop</span> <span class="string">&#x27;test01&#x27;</span>;   <span class="comment">--删除数据库test01</span></span><br><span class="line"></span><br><span class="line">mysqladmin <span class="operator">-</span>uroot <span class="operator">-</span>p123456 version;         <span class="comment">--查看数据库版本信息</span></span><br></pre></td></tr></table></figure><h3 id="mysqlbinlog"><a href="#mysqlbinlog" class="headerlink" title="mysqlbinlog"></a>mysqlbinlog</h3><p>由于服务器生成的二进制日志文件以二进制格式保存，所以如果想要检查这些文本的文本格式，就会使用到mysqlbinlog日志管理工具</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">mysqlbinlog [options] log<span class="operator">-</span>files1 log<span class="operator">-</span>files2......</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line"><span class="operator">-</span>d, <span class="comment">--database=name                 指定数据库名称，只列出指定的数据库相关操作</span></span><br><span class="line"><span class="operator">-</span>o, <span class="comment">--offser=#                              忽略掉日志中的前n行命令</span></span><br><span class="line"><span class="operator">-</span>r, <span class="comment">--result-file=name                   将输出的文本格式日志输出到指定文件</span></span><br><span class="line"><span class="operator">-</span>s, <span class="comment">--short-form                           显示简单格式，省略掉一些信息</span></span><br><span class="line"><span class="comment">--start-datatime=data1  --stop-datatime=data2     指定日期间隔内的所有日志</span></span><br><span class="line"><span class="comment">--start-position=pos1  --stop-position=pos2          指定位置间隔内的所有日志</span></span><br></pre></td></tr></table></figure><h3 id="mysqlshow"><a href="#mysqlshow" class="headerlink" title="mysqlshow"></a>mysqlshow</h3><p>mysqlshow客户端对象查找工具，用来很快的查找存在哪些数据库、数据库中的表、表中的列、或者索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">Mysqlshow [options] [db_name [table_name[column_name]]]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line"><span class="comment">--count     显示数据库及表的统计信息（数据库，表均可不指定）</span></span><br><span class="line"><span class="operator">-</span>i              显示指定数据库或者指定表的状态信息</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">\#查询每个数据库的表的数量及表中记录的数量</span><br><span class="line">mysqlshow <span class="operator">-</span>uroot <span class="operator">-</span>p123456 <span class="comment">--count</span></span><br><span class="line">\#查询test数据库中每个表中的字段数，及行数</span><br><span class="line">mysqlshow <span class="operator">-</span>uroot <span class="operator">-</span>p123456 test <span class="comment">--count</span></span><br><span class="line">\#查询test数据库中book表的详细情况</span><br><span class="line">mysqlshow <span class="operator">-</span>uroot <span class="operator">-</span>p123456 test book <span class="comment">--count</span></span><br></pre></td></tr></table></figure><h3 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h3><p>mysqldump客户端工具用来被封数据库或在不同数据库之间进行数据迁移。备份内容包含创建表，及插入表的SQL语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">语法</span><br><span class="line">Mysqldump [options] db_name [tables]</span><br><span class="line">Mysqldump [options] <span class="comment">--database / -B db1 [db2 db3...]</span></span><br><span class="line">Mysqldump [options] <span class="comment">--all -databases /-A</span></span><br><span class="line"></span><br><span class="line">连接选项：</span><br><span class="line"><span class="operator">-</span>u，<span class="comment">--user=name              指定用户名</span></span><br><span class="line"><span class="operator">-</span>p，<span class="comment">--password[=name]    指定密码</span></span><br><span class="line"><span class="operator">-</span>h，<span class="comment">--host=name               指定服务器ip或域名</span></span><br><span class="line"><span class="operator">-</span>P，<span class="comment">--port=#                      指定连接端口</span></span><br><span class="line"></span><br><span class="line">输出选项：</span><br><span class="line"><span class="comment">--add-drop-database         在每个数据库创建语句前加上drop database语句</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java异常</title>
      <link href="/2023/09/18/Java.%E5%BC%82%E5%B8%B8/"/>
      <url>/2023/09/18/Java.%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>在 Java 语言中，将程序执行中发生的不正常情况称为 “异常”（开发过程中的语法错误和逻辑错误不是异常）</p><p>这些 异常事件 可分为两类：</p><ol><li><p>Error（错误）：Java 虚拟机无法解决的严重问题。</p><p>如：JVM 系统内部错误，资源耗尽等严重情况。Error 是严重错误，程序会崩溃。</p></li><li><p>Exception（异常）：其他因编程错误或偶然的外部因素导致的一般性问题，可以使用针对性的代码进行处理。</p><p>如：空指针访问，试图读取不存在的文件，网络中断等等。</p><p>Exception 又分为两大类：</p><ul><li>运行时异常（程序运行时，发生的异常）</li><li>编译时异常（编程时，编译器检查出的异常，会爆红）</li></ul></li></ol><h2 id="异常体系图"><a href="#异常体系图" class="headerlink" title="异常体系图"></a>异常体系图</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/%25E5%25BC%2582%25E5%25B8%25B8%25E4%25BD%2593%25E7%25B3%25BB%25E5%259B%25BE_11.1.webp"></p><p>异常分为两大类：运行时异常 和 编译时异常</p><ul><li><p>运行时异常，编译器不要求强制处置的异常。一般是指编程的逻辑错误，是程序员应该避免其出现的异常。</p><p>java.lang.RuntimeException 类及它的子类都是运行时异常</p><p>对于运行时异常，可以不做处理。因为这类异常很普遍，若全处理会对程序的可读性和运行效率产生影响</p></li><li><p>编译时异常，是编译器要求必须处置的异常</p></li></ul><h2 id="常见的运行时异常"><a href="#常见的运行时异常" class="headerlink" title="常见的运行时异常"></a>常见的运行时异常</h2><p>常见的运行时异常（RuntimeException）包括</p><ol><li><p>NullPointerException：空指针异常</p><ul><li><p>当应用程序试图在需要对象的地方使用 null 时，抛出该异常</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = null;</span><br><span class="line">int n = str.length;//这里，出现了 空指针异常</span><br></pre></td></tr></table></figure></li></ul></li><li><p>ArithmeticException：数学运算异常</p><ul><li><p>当出现异常的运算条件时，抛出该异常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double n = 100 / 0;//这里，出现了 数学运算异常</span><br></pre></td></tr></table></figure></li></ul></li><li><p>ArrayIndexOutOfBoundsException：数组下标越界异常</p><ul><li><p>用非法索引（为负或超出范围）访问数组时，抛出该异常</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] nums = &#123;0, 0, 0, 0&#125;;</span><br><span class="line">nums[-50] = 100;//这里，出现了 数组下标越界异常</span><br></pre></td></tr></table></figure></li></ul></li><li><p>ClassCastException：类型转换异常</p><ul><li><p>当试图把对象强制转换为不是实例的子类时，抛出该异常</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Example &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        A a1 = new A1();</span><br><span class="line">        A2 a1 = (A2)a1;//这里，出现了 类型转换异常</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class A &#123;&#125;</span><br><span class="line">class A1 extends A &#123;&#125;</span><br><span class="line">class A2 extends A &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>NumberFormatException：数学格式异常</p><ul><li><p>当应用程序试图将字符串转成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;ABC&quot;;</span><br><span class="line">int num = Integer.parseInt(str);//这里，出现了 数字格式不正确异常</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="常见的编译异常"><a href="#常见的编译异常" class="headerlink" title="常见的编译异常"></a>常见的编译异常</h2><p>常见的编译异常：一般发生在网络、文件、数据库操作中。</p><ul><li>SQLException：操作数据库时，查询表可能发生异常</li><li>IOException：操作文件时，发生的异常</li><li>FileNotFoundException：操作一个不存在的文件时，发生的异常</li><li>ClassNotFoundException：加载类，而该类不存在时，发生的异常</li><li>EOFException：操作文件，到文档末尾，发生的异常</li><li>IllegalArguementException：参数异常</li></ul><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>异常发生时，对异常的处理方式。如果没有显式异常处理，默认处理方式是 <code>throws</code></p><blockquote><ul><li><code>try - chatch - finally</code>：程序员在代码中捕获发生的异常，自行处理</li><li><code>throws</code>：将发生的异常抛出，交给调用者（方法）来处理。最顶级的处理者就是 JVM</li></ul></blockquote><h2 id="try-chatch-finally"><a href="#try-chatch-finally" class="headerlink" title="try - chatch - finally"></a>try - chatch - finally</h2><p>Java 提供 try 和 catch 块 来处理异常。try 块用于包含可能出错的代码，catch 块用于处理 try 块中的异常。可以根据需要在程序中有多个 <code>try - catch</code> 块。</p><p>基本语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">//可疑代码</span><br><span class="line">//将异常生成对应的异常对象，传递给 catch 块</span><br><span class="line">&#125; catch(Exception e) &#123;</span><br><span class="line">//如果发生异常，执行这些代码</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    //无论是否异常，都执行这些代码</span><br><span class="line">    //finally 块可以不写</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h4><ol><li><p>如果异常发生了，则异常发生后面的代码块都不执行，直接进入 catch 块</p></li><li><p>如果异常未发生，则顺序执行 try 代码块，catch 块不执行</p></li><li><p>如果希望不管是否异常，都执行一些代码，则使用 finally</p></li><li><p>可以有多个 catch 捕获不同的异常。要求 子类异常在前，父类异常在后。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">...</span><br><span class="line">&#125; catch (NullPointerException e) &#123;</span><br><span class="line">...</span><br><span class="line">&#125; catch (ArithmeticException e) &#123;</span><br><span class="line">...</span><br><span class="line">&#125; catch (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">...</span><br><span class="line">&#125; catch (Exception e)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以进行 try - finally 配合使用（不写 catch）。这种用法相当于没有捕获异常，此时程序如果出错会直接退出。</p><p>应用场景，就是写一段代码，不管是否发生异常，都必须执行某个业务逻辑。</p></li><li><p>如果没有出现异常，执行 try 中所有语句，不执行 catch 语句，最后执行 finally 语句</p></li><li><p>如果出现异常，则 try 块异常发生后，剩余语句不执行。之后执行 catch 语句，最后，执行 finally 语句。</p></li></ol><p>例子：如果用户输入的不是一个整数，就提示他反复输入，直到输入一个整数为止</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package org.example;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        int num;</span><br><span class="line">        String str = new String();</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            System.out.println(&quot;请输入&quot;);</span><br><span class="line">            str = scanner.next();</span><br><span class="line">            try&#123;</span><br><span class="line">                num = Integer.parseInt(str);</span><br><span class="line">                break;</span><br><span class="line">            &#125;catch (NumberFormatException e)&#123;</span><br><span class="line">                System.out.println(&quot;warring&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h2><p>如果一个方法可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显式地声明抛出异常，表明该方法将不对这些异常进行处理，而由调用者负责处理</p><p>在方法中声明 <code>throws</code> 语句可以声明抛出异常的列表。<code>throws</code> 后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void metord() throws FileNontFoundException ,NullPointerException &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309181432554.png"></p><blockquote><p>除了JVM层，每一层都能选择使用try还是throws，到JVM就直接报红错误。</p><p>下面层中，每一层二选一处理。</p></blockquote><p>使用细节：</p><ol><li>对于 <strong>编译异常</strong>，程序中必须处理。</li><li>对于 <strong>运行异常</strong>，程序中诺没有处理，默认处理是 <code>throws</code></li><li>子类 重写 父类方法时，子类方法抛出的异常类型必须和父类一致，或者是父类抛出异常类型的子类型。</li><li>如果有 <code>try - catch</code> 就不必 <code>throws</code> 了</li></ol><h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><p>当程序中出现了某些 “错误”，但该信息并未在 <code>Throwable</code> 子类中描述处理，这时候可以自己设计异常类，用于描述该错误信息</p><p>过程：</p><ol><li>定义类：自定义异常类名，继承 RuntimeException 或 Exception</li><li>如果继承 Exception，属于 编译异常。</li><li>如果继承 RuntimeException，属于 运行异常。（一般来说，选这个。这样利用了默认处理机制throws，更方便）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Metords &#123;</span><br><span class="line">   public void method() &#123;</span><br><span class="line">       int n = 10;</span><br><span class="line">       if(n &gt; 100)&#123;</span><br><span class="line">           throw new CustomException(&quot;不能大于100&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CustomException extends RuntimeException &#123;</span><br><span class="line">public CustomException(String message) &#123;</span><br><span class="line">super(message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="throw-和-throws"><a href="#throw-和-throws" class="headerlink" title="throw 和 throws"></a>throw 和 throws</h1><table><thead><tr><th></th><th>意义</th><th>位置</th><th>后面跟的东西</th></tr></thead><tbody><tr><td><code>throws</code></td><td>异常处理的一种方式</td><td>方法声明时</td><td>异常类型</td></tr><tr><td><code>throw</code></td><td>手动生成异常对象关键字</td><td>方法体中</td><td>异常对象</td></tr></tbody></table><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="编程小技巧"><a href="#编程小技巧" class="headerlink" title="编程小技巧"></a>编程小技巧</h3><p>老韩曰：编写异常时，先确定正确的情况，然后取反。这样写，你的思路就不乱。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java字符串</title>
      <link href="/2023/09/18/Java%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2023/09/18/Java%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h1><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309171056678.png"></p><ol><li><p><code>String</code> 对象用于保存字符串，也就是一组字符序列</p></li><li><p>字符串常量对象是用双引号扩起的字符序列。例如 <code>&quot;你好&quot;</code></p></li><li><p>字符串的字符使用 Unicode 字符编码。一个字符（不论字母汉字）占 2 字节</p></li><li><p>常用构造器：</p><ul><li><p><code>String str1 = new String();</code></p></li><li><p><code>String str2 = new String(String original);</code></p></li><li><p><code>String str3 = new String(char[] a);</code></p></li><li><p><code>String str4 = new String(char[] a, int startIndex, int count);</code></p><p>这句意思是：<code>char[]</code> 从 <code>startIndex</code> 起的 <code>count</code> 个字符</p></li></ul></li><li><p><code>String</code> 实现了接口 <code>Serializable</code> 和 <code>Comparable</code> ，可以 串行化和 比较大小</p><blockquote><p><strong>串行化：即，可以被网络传输，也能保存到文件</strong></p></blockquote></li><li><p><code>String</code> 是 <code>final</code> 类，不能被继承</p></li><li><p><code>String</code> 有属性 <code>private final char[] value;</code> 用于存放字符串内容。</p><p><code>value</code> 是 <code>final</code> 属性。其在栈中的地址不能修改，但内容可以修改</p></li></ol><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309171101558.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309171103557.png"></p><h2 id="String创建对象"><a href="#String创建对象" class="headerlink" title="String创建对象"></a>String创建对象</h2><p>两种创建String对象的区别（JVM中有讲解）</p><ol><li><p>直接赋值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;你干嘛，哎呦~&quot;</span><br></pre></td></tr></table></figure><p>方式一：先从常量池查看是否有**”你干嘛，哎呦~”**数据空间，如果有，直接指向；如果没有则重新创建，然后指向。s最终指向的是常量池的空间地址</p></li><li><p>调用构造器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str1 = new String();</span><br></pre></td></tr></table></figure><p>方式二：先在堆中创建空间，里面维护了value属性，指向常量池的**”你干嘛，哎呦<del>“<strong>空间。如果常量池没有</strong>“你干嘛，哎呦</del>“**，重新创建，如果有，直接通过value指向。 最终指向的是堆中的空间地址。</p></li></ol><h3 id="画出两种方式的内存分布图"><a href="#画出两种方式的内存分布图" class="headerlink" title="画出两种方式的内存分布图"></a>画出两种方式的内存分布图</h3><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309180850664.png"></p><h3 id="String对象比较"><a href="#String对象比较" class="headerlink" title="String对象比较"></a>String对象比较</h3><blockquote><p>JVM中有一部分讲这个的，比Java部分的更加全面</p></blockquote><p>引用类型怎么比较？默认比较地址，重写方法可能比较内容。</p><ol><li><p>**&#x3D;&#x3D;**：比较二者的地址，内容不一样的话肯定不一样。内容一样的话如果都是new的，由于new的特性，也不一样。</p></li><li><p>equals：String中重写了方法，比较的是值是否相同，区分大小写。</p></li><li><p>常量相加比较：由于构造器自身优化，池会自动创建一个相加后的常量</p></li><li><p>变量相加比较：是在堆中调用Stringbuilder类通过append和toString方法生成一个新对象，二者不一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb = new StringBuilder();</span><br><span class="line">sb.append(a);</span><br><span class="line">sb.append(b);</span><br><span class="line">str2 = sb.toString();//sb.toString()：return new String(value, 0, count);</span><br></pre></td></tr></table></figure></li></ol><h2 id="String对象特性"><a href="#String对象特性" class="headerlink" title="String对象特性"></a>String对象特性</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String e = &quot;你干嘛&quot; + &quot;哎呦&quot;;//创建了几个对象？</span><br></pre></td></tr></table></figure><p>1个：由于构造器自身优化，池会自动创建一个相加后的常量，相当于直接 e &#x3D; “你干嘛哎呦”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String a = &quot;你干嘛&quot;; //创建 a对象</span><br><span class="line">String b = &quot;哎呦&quot;;//创建 b对象</span><br><span class="line"> String c = a + b;</span><br></pre></td></tr></table></figure><p>3个：</p><ol><li>先 创建一个 StringBuilder sb &#x3D; StringBuilder()</li><li>执行  sb.append(“你干嘛”);</li><li>sb.append(“哎呦”);</li><li>String c&#x3D; sb.toString()<br>最后其实是 c 指向堆中的对象(String) value[] -&gt; 池中 “你干嘛哎呦”</li></ol><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309180941489.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String a = &quot;hello&quot;; //创建 a对象</span><br><span class="line">String b = &quot;abc&quot;;//创建 b对象</span><br><span class="line">String c = a + b;//e指向堆</span><br><span class="line">String d = &quot;helloabc&quot;;</span><br><span class="line">System.out.println(c == d);//真还是假? 是false</span><br><span class="line">String e = &quot;hello&quot; + &quot;abc&quot;;//直接看池， e指向常量池</span><br><span class="line">System.out.println(d == e);//真还是假? 是true</span><br></pre></td></tr></table></figure><h2 id="String-的常用方法"><a href="#String-的常用方法" class="headerlink" title="String 的常用方法"></a>String 的常用方法</h2><p>以下方法不需死记硬背，手熟自然牢记</p><ul><li><p><code>boolean equals(String s)</code>：区分大小写，判断内容是否相等</p><p><code>boolean equalsIgnoreCase(String s)</code>：判断内容是否相等（忽略大小写）</p></li><li><p><code>boolean empty()</code>：返回是否为空</p></li><li><p><code>int charAt(int index)</code>：获取某索引处的字符（代码单元）。</p><p>必须用 <code>char c = str.charAt(15);</code>，不能用 <code>char c = str[15];</code></p><p><code>int codePointAt(int index)</code></p><p><code>int length()</code>：获取字符（<strong>代码单元</strong>）的个数</p><p><code>IntStream codePoints()</code>：返回字符串中全部码点构成的流</p><p><code>long codePoints().count()</code>：返回真正长度（码点数量）</p></li><li><p><code>int indexOf(String str)</code>：获取字符（串）在字符串中第一次出现的索引。如果找不到，返回 -1</p><p><code>int indexOf(int char)</code> 参数也可以传入一个 int。由于自动类型转换的存在，也能填入 char</p><p><code>int indexOf(String str, int index)</code>：从 index 处（包含）开始查找指定字符（串）</p><p><code>int lastIndexOf(String str)</code>：获取字符在字符串中最后一次出现的索引。如果找不到，返回 -1</p></li><li><p><code>String substring(int start, int end)</code>：返回截取指定范围 [start, end) 的 <strong>新</strong> 字符串</p><p><code>String substring(int index)</code>：截取 index（包含）之后的部分</p></li><li><p><code>String trim()</code>：返回去前后空格的新字符串</p></li><li><p><code>String toUperCase()</code>：返回字母全部转为大写的新字符串</p><p><code>String toLowerCase()</code>：返回字母全部转为小写的新字符串</p></li><li><p><code>String concat(String another)</code>：返回拼接字符串</p></li><li><p><code>String replace(char oldChar, char newChar)</code>：替换字符串中的元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;Foolish cultists&quot;;</span><br><span class="line">String str2 = str1.replace(&quot;cultists&quot;, &quot;believers&quot;);//str1不变，str2为改变的值JAVA</span><br></pre></td></tr></table></figure></li><li><p><code>String[] split(String regex)</code>：分割字符串。</p><p>对于某些分割字符，我们需要转义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;aaa,bbb,ccc&quot;;</span><br><span class="line">String[] strs1 = str1.split(&quot;,&quot;);//这个场合，strs = &#123;&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;&#125;;4</span><br><span class="line">String str2 = &quot;aaa\bbb\ccc&quot;;</span><br><span class="line">String[] strs2 = str2.split(&quot;\\&quot;);//&quot;\&quot; 是特殊字符，需要转义为 &quot;\\&quot;JAVA</span><br></pre></td></tr></table></figure></li><li><p><code>int compareTo(String another)</code>：按照字典顺序比较两个字符串（的大小）。</p><p>返回出现第一处不同的字符的编号差。前面字符相同，长度不同的场合，返回那个长度差。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;ccc&quot;;</span><br><span class="line">String str2 = &quot;ca&quot;;</span><br><span class="line">String str3 = &quot;ccc111abc&quot;;</span><br><span class="line">int n1 = str1.compareTo(str2);//此时 n1 = &#x27;c&#x27; - &#x27;a&#x27; = 2</span><br><span class="line">int n2 = str1.compareTo(str3);//此时 n2 = str1,length - str3.length = -6</span><br><span class="line">int n3 = str1.compareTo(str1);//此时 n3 = 0JAVA</span><br></pre></td></tr></table></figure></li><li><p><code>char[] toCharArray()</code>：转换成字符数组</p><p><code>byte[] getBytes()</code>：字符串转为字节数组</p></li><li><p><code>String String.format(String format, Object... args)</code>：（静态方法）格式字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String name = &quot;Roin&quot;;</span><br><span class="line">String age = &quot;1M&quot;;</span><br><span class="line">String state = &quot;computer&quot;;</span><br><span class="line">String formatStr = &quot;I am %s, I am %s old, I am a %s&quot;;</span><br><span class="line">String str = String.format(formatStr, name, age, state);</span><br><span class="line">//其中 %s 是占位符。此时，str = &quot;I am Roin, I am 1M old, I am a computer&quot;;</span><br><span class="line">//%s 表示字符串替换；%d 表示整数替换；#.2f 表示小数（四舍五入保留2位）替换；%c 表示字符替换JAVA</span><br></pre></td></tr></table></figure></li><li><p><code>String join(deli, ele...)</code>：拼接字符串（<code>ele...</code>），以 <code>deli</code> 间隔。</p></li><li><p><code>boolean startsWith(str)</code>：测试 str 是否为当前字符串的前缀</p></li><li><p><code>String repeat(int n)</code>：返回该字符串重复 n 次的结果</p></li></ul><h1 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h1><p>StringBuffer代表可变的字符序列。可以对字符串内容进行增删。</p><p>很多方法和 String 相同，但 StringBuffer 是可变长度。同时，StringBuffer 是一个容器</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309180952088.png"></p><ol><li><code>StringBuffer</code> 的直接父类是 <code>AbstractStringBuffer</code></li><li><code>StringBuffer</code> 实现了 <code>Serialiazable</code>，可以串行化</li><li>在父类中，<code>AbstractStringBuffer</code> 有属性 <code>char[] value</code> 不是 <code>final</code></li><li><code>StringBuffer</code> 是一个 <code>final</code> 类，不能被继承</li><li>StringBuffer的字符内容存放在char[] value中，不用每次都更换地址(不是每次创建新对象)，所以效率高于 String</li></ol><h2 id="String-对比-StringBuffer"><a href="#String-对比-StringBuffer" class="headerlink" title="String 对比 StringBuffer"></a>String 对比 StringBuffer</h2><ul><li><code>String</code> 保存字符串常量，其中的值不能更改。每次更新实际上是更改地址，效率较低</li><li><code>StringBuffer</code> 保存字符串变量，里面的值可以更改。每次更新是更新内容，不用每次更新地址</li></ul><h2 id="StringBuffer-构造方法"><a href="#StringBuffer-构造方法" class="headerlink" title="StringBuffer 构造方法"></a>StringBuffer 构造方法</h2><ol><li><p>无参构造</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer strb1 = new StringBuffer();</span><br></pre></td></tr></table></figure><blockquote><p>创造一个 16 位容量（默认容量）的空 <code>StringBuffer</code></p></blockquote></li><li><p>传入字符串构造</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;abcabc&quot;;</span><br><span class="line">StringBuffer strb2 = new StringBuffer(str1);</span><br></pre></td></tr></table></figure><blockquote><p>（上例）创造一个 str1.length + 16 容量的 <code>StringBuffer</code></p></blockquote></li><li><p>指定容量构造</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer strb3 = new StringBuffer(3);</span><br></pre></td></tr></table></figure><blockquote><p>（上例）创造一个 3 容量的空 <code>StringBuffer</code></p></blockquote></li></ol><h2 id="String-和-StringBuffer的转换"><a href="#String-和-StringBuffer的转换" class="headerlink" title="String 和 StringBuffer的转换"></a>String 和 StringBuffer的转换</h2><ol><li><p>转 StringBuffer</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;abcabc&quot;;</span><br><span class="line">StringBuffer strb1 = new StringBuffer(str1);//方法1（构造器）</span><br><span class="line">StringBuffer strb1 = new StringBuffer();</span><br><span class="line">strb1 = strb1.append(str1);//方法2（先空再append）</span><br></pre></td></tr></table></figure></li><li><p>转 String</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str2 = strb1.toString();//方法1（toString）</span><br><span class="line">String str3 = new String(strb1);//方法2（构造器）</span><br></pre></td></tr></table></figure></li></ol><h2 id="StringBuffer常用方法"><a href="#StringBuffer常用方法" class="headerlink" title="StringBuffer常用方法"></a>StringBuffer常用方法</h2><ul><li><p><code>append(char c)</code>：增加</p><p><code>append(String s)</code> 参数也能是字符串</p><p>特别的，<code>append(null);</code> 的场合，等同于 <code>append(&quot;null&quot;);</code></p></li><li><p><code>append(String s)</code> 参数也能是字符串</p><p>特别的，<code>append(null);</code> 的场合，等同于 <code>append(&quot;null&quot;);</code></p></li><li><p><code>delete(start, end)</code>：删减 [start, end) 的内容</p></li><li><p><code>replace(start, end, string)</code>：将 start 与 end 间的内容替换为 string</p></li><li><p><code>indexOf</code>：查找指定字符串第一次出现时的索引。没找到的场合返回 -1</p></li><li><p><code>insert</code>：在指定索引位置之前插入指定字符串</p></li><li><p><code>length()</code>：返回字符长度</p><p><code>capacity()</code>：返回当前的容量</p><p>String 类对象分配内存时，按照对象中所含字符个数等量分配。</p><p>StringBuffer 类对象分配内存时，除去字符所占空间外，会另加 16 字符大小的缓冲区。</p><p>对于 <code>length()</code> 方法，返回的是字符串长度。对于 <code>capacity()</code> 方法，返回的是 字符串 + 缓冲区 的大小。</p></li></ul><h1 id="StringBuilder-类"><a href="#StringBuilder-类" class="headerlink" title="StringBuilder 类"></a>StringBuilder 类</h1><p>一个可变的字符序列。此类提供一个与 <code>StringBuffer</code> 兼容的 API，但不保证同步（<strong>有线程安全问题</strong>）。该类被设计成 <code>StringBuffer</code> 的一个简易替换，<strong>用在字符串缓冲区被单个线程使用的时候</strong>，建议优先使用该类。在大多数实现中，它比起 <code>StringBuffer</code> 要快。</p><p>在 <code>StringBuilder</code> 是的主要操作是 <code>append</code> 和 <code>insert</code> 方法。可以重载这些方法，以接受任意类型的数据。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309181028471.png"></p><ol><li><code>StringBuilder</code> 也继承了 <code>AbstractStringBuffer</code></li><li><code>StringBuilder</code> 也实现了 <code>Serialiazable</code>，可以串行化</li><li>仍然是在父类中有属性 <code>char[] value</code> ，而且不是 <code>final</code></li><li><code>StringBuilder</code> 也是一个 <code>final</code> 类，不能被继承</li><li><code>StringBuilder</code> 的方法，没有做互斥的处理（没有 <code>synchronize</code>），故而存在线程安全问题</li></ol><h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><ol><li><code>StringBuilder</code> 和 <code>StringBuffer</code> 类似，均代表可变字符序列，而且方法也一样</li><li><code>String</code>：不可变字符序列，效率低，但复用率高</li><li><code>StringBuffer</code>：可变字符序列，效率较高，线程安全（多线程用）</li><li><code>StringBuilder</code>：可变字符序列，效率最高，存在线程安全问题（单线程用）</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java常用类</title>
      <link href="/2023/09/17/Java%E5%B8%B8%E7%94%A8%E7%B1%BB/"/>
      <url>/2023/09/17/Java%E5%B8%B8%E7%94%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Wrapper类-x2F-包装类"><a href="#Wrapper类-x2F-包装类" class="headerlink" title="Wrapper类&#x2F;包装类"></a>Wrapper类&#x2F;包装类</h1><p>包装类（Wrapper）：针对<strong>八种基本数据类型</strong>相应的 引用类型。有了类的特点，就可以调用类中的方法</p><p>理解了继承体系才知道有哪些方法能用，继承体系如下</p><table><thead><tr><th>基本数据类型</th><th>包装类</th><th>父类</th></tr></thead><tbody><tr><td>boolean</td><td>Boolean</td><td>Object</td></tr><tr><td>char</td><td>Character</td><td>Object</td></tr><tr><td>int</td><td>Integer</td><td>Number</td></tr><tr><td>float</td><td>Float</td><td>Number</td></tr><tr><td>double</td><td>Double</td><td>Number</td></tr><tr><td>long</td><td>Long</td><td>Number</td></tr><tr><td>short</td><td>Short</td><td>Number</td></tr><tr><td>byte</td><td>Byte</td><td>Number</td></tr><tr><td>void</td><td>Void</td><td>Object</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309161838462.png" alt="boolean"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309161838778.png" alt="char"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309161839328.png" alt="数字类都能看这个图"></p><h2 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h2><p>以int为例，其他的类似</p><p>装箱：int转为Interger</p><p>拆箱：interger转为Int</p><h3 id="手动装箱和拆箱（JDK-5-以前）"><a href="#手动装箱和拆箱（JDK-5-以前）" class="headerlink" title="手动装箱和拆箱（JDK 5 以前）"></a>手动装箱和拆箱（JDK 5 以前）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int n1 = 100;</span><br><span class="line">Integer integer = new Integer(n1);// 手动装箱</span><br><span class="line">Integer integer2 = Integer.valueOf(n1);// 手动装箱</span><br><span class="line">int i = integer.intValue();// 手动拆箱</span><br></pre></td></tr></table></figure><h3 id="自动装箱和拆箱（JDK-5-以后）"><a href="#自动装箱和拆箱（JDK-5-以后）" class="headerlink" title="自动装箱和拆箱（JDK 5 以后）"></a>自动装箱和拆箱（JDK 5 以后）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n2 = 200;</span><br><span class="line">Integer integer3 = n2;// 自动装箱，底层用的是valueOf()</span><br><span class="line">int j = integer3;// 自动拆箱，底层用的是intValue()</span><br></pre></td></tr></table></figure><p>虽然可以自动装箱、拆箱，但使用 &#x3D;&#x3D; 直接比较两个包装类时，仍然是比较其地址。以下比较通常会失败：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer ia = 1000;</span><br><span class="line">Integer ib = 1000;</span><br><span class="line">System.out.print(ia == ib);// false</span><br></pre></td></tr></table></figure><p>但是，Byte、Boolean 以及 Short、Integer 中 [-128, 127] 间的值已被包装到固定的对象中。对他们的比较可以成功。</p><blockquote><p>底层存了一个256大小的数组，如果值在 [-128, 127]中，直接用这个数组的地址，不用额外创建对象</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer ia = 127;</span><br><span class="line">Integer ib = 127;</span><br><span class="line">System.out.print(ia == ib);// true</span><br></pre></td></tr></table></figure><p>由此可见，使用 &#x3D;&#x3D; 直接比较两个包装类会带来不确定性。<strong>尽量使用 equals 方法对包装类进行比较。</strong></p><p>装箱与拆箱是 <strong>编译器</strong> 的工作。在生成可执行的字节码文件时，编译器已经插入了必要的方法调用。</p><h2 id="包装类和-String-的相互转换"><a href="#包装类和-String-的相互转换" class="headerlink" title="包装类和 String 的相互转换"></a>包装类和 <code>String</code> 的相互转换</h2><p>包装类转 <code>String</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer integer = 100;</span><br><span class="line">String str1 = integer + &quot;&quot;;//方法1（自动拆箱）</span><br><span class="line">String str2 = integer.toString();//方法2（toString方法）</span><br><span class="line">String str3 = String.valueOf(integer);//方法3（自动拆箱）</span><br></pre></td></tr></table></figure><p><code>String</code> 转包装类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str4 = &quot;100&quot;;</span><br><span class="line">Integer integer2 = Integer.parseInt(str4);//方法1（自动装箱）</span><br><span class="line">Integer integer3 = new Integer(str4);//方法2（构造器）</span><br></pre></td></tr></table></figure><h2 id="包装类的常用方法"><a href="#包装类的常用方法" class="headerlink" title="包装类的常用方法"></a>包装类的常用方法</h2><ul><li><p><code>Integer.MIN_VALUE</code>：返回最大值</p></li><li><p><code>Double.MAX_VALUE</code>：返回最小值</p></li><li><p><code>byteValue()</code>、<code>doubleValue()</code>、<code>floatValue()</code>、<code>intValue()</code>、<code>longValue()</code></p><p>按各种基本数据类型返回该对象的值</p></li><li><p><code>Character.isDigit(int)</code>：判断是不是数字</p><p><code>Character.isLetter(int)</code>：判断是不是字母</p><p><code>Character.isUpperCase(int)</code>：判断是不是大写字母</p><p><code>Character.isLowerCase(int)</code>：判断是不是小写字母</p><p><code>Characher.isWhitespace(int)</code>：判断是不是空格</p></li><li><p><code>Character.toUpperCase(int)</code>：转成大写字母</p><p><code>Character.toLowerCase(int)</code>：转成小写字母</p></li><li><p><code>Integer.parseInt(string)</code>：将 String 内容转为 int</p><p>double等同理</p></li></ul><h2 id="Interger创建机制"><a href="#Interger创建机制" class="headerlink" title="Interger创建机制"></a>Interger创建机制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">        if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        return new Integer(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309162137184.png"></p><p>值在[-128,127]中，直接从IntegerCache中取出，用IntegerCache的地址，不在这个范围里面的才用new新建对象。</p><p>但是如果直接用new创建对象，一定不一样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer i1 = new Integer(127);</span><br><span class="line">        Integer i2 = new Integer(127);</span><br><span class="line">        System.out.print(&quot;i1 == i2&quot;);</span><br><span class="line">        System.out.println(i1 == i2);</span><br><span class="line">        Integer i3 = new Integer(128);</span><br><span class="line">        Integer i4 = new Integer(128);</span><br><span class="line">        System.out.print(&quot;i3 == i4&quot;);</span><br><span class="line">        System.out.println(i3 == i4);</span><br><span class="line">        Integer i5 = 127;</span><br><span class="line">        Integer i6 = 127;</span><br><span class="line">        System.out.print(&quot;i5 == i6&quot;);</span><br><span class="line">        System.out.println(i5 == i6);</span><br><span class="line">        Integer i7 = 128;</span><br><span class="line">        Integer i8 = 128;</span><br><span class="line">        System.out.print(&quot;i7 == i8&quot;);</span><br><span class="line">        System.out.println(i7 == i8);</span><br><span class="line">        Integer a5 = 127;</span><br><span class="line">        Integer a6 = new Integer(127);</span><br><span class="line">        System.out.print(&quot;a5 == a6&quot;);</span><br><span class="line">        System.out.println(a5 == a6);</span><br><span class="line">        Integer a7 = 128;</span><br><span class="line">        int a8 = 128;</span><br><span class="line">        System.out.print(&quot;a7 == a8&quot;);</span><br><span class="line">        System.out.println(a7 == a8);</span><br><span class="line">        Integer a9 = 127;</span><br><span class="line">        int a0 = 127;</span><br><span class="line">        System.out.print(&quot;a9 == a0&quot;);</span><br><span class="line">        System.out.println(a9 == a0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h1><p>数学类，是静态类，封装了一堆数学方法，直接<strong>类名.方法</strong>调用</p><p>常用方法：</p><ol><li><p><code>Math.multiplyExact(int n1, int n2)</code>：进行乘法运算，返回运算结果</p><p>通常的乘法 <code>n1 * n2</code> 在结果大于那个数据类型存储上限时，可能返回错误的值。</p><p>使用此方法，结果大于那个数据类型存储上限时，会抛出异常</p><p><code>Math.addExact(int n1, int n2)</code>：加法</p><p><code>Math.subtractExact(int n1, int n2)</code>：减法</p><p><code>Math.incrementExact(int n1)</code>：自增</p><p><code>Math.decrementExact(int n1)</code>：自减</p><p><code>Math.negateExact(int n1, int n2)</code>：改变符号</p></li><li><p><code>Math.abs(n)</code>：求绝对值，返回 |n1|</p></li><li><p><code>Math.pow(n, i)</code>：求幂，返回 n3 ^ i</p></li><li><p><code>Math.ceil(n)</code>：向上取整，返回 &gt;&#x3D; n3 的最小整数（转成double）</p></li><li><p><code>Math.floor(n)</code>：向下取整，返回 &lt;&#x3D;n4 的最小整数（转成double）</p></li><li><p><code>Math.floorMod(int n1, int n2)</code>：返回 n1 除以 n2 的余数</p><p><code>n1 % n2</code> 的场合，返回的可能是负数，而不是数学意义上的余数</p></li><li><p><code>Math.round(n)</code>：四舍五入，相当于 <code>Math.floor(n5 + 0.5)</code></p></li><li><p><code>Math.sqrt(n)</code>：求开方。负数的场合，返回 <code>NaN</code></p></li><li><p><code>Math.random()</code>：返回一个 [0, 1) 区间的随机小数</p></li><li><p><code>Math.sin(n)</code>：正弦函数</p><p><code>Math.cos(n)</code>：余弦函数</p><p><code>Math.tan(n)</code>、<code>Math.atan(n)</code>、<code>Math.atan2(n)</code></p><p>要注意，上述方法传入的参数是 <strong>弧度值</strong>。</p><p>要得到一个角度的弧度值，应使用：<code>Math.toRadians(n)</code></p></li><li><p><code>Math.exp(n)</code>：e 的 n 次幂</p><p><code>Math.log10(n)</code>：10 为底的对数</p><p><code>Math.log()</code>：自然对数</p></li><li><p><code>Math.PI</code>：圆周率的近似值</p><p><code>Math.E</code>：e 的近似值</p></li></ol><h1 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h1><p><code>Arrays.toString()</code>：返回数组的字符串形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] nums = &#123;0, 1, 33&#125;;</span><br><span class="line">String str = Array.toString(nums);//此时，str = &quot;[0, 1, 33]&quot;</span><br></pre></td></tr></table></figure><blockquote><p>特别的，输入为 null 时返回 “null”</p></blockquote><p><code>Arrays.sort(arr)</code>：排序</p><blockquote><p>因为数组是引用类型，使用 sort 排序后，会直接影响到实参</p></blockquote><p><code>Arrays.sort(arr, Comparator c)</code>：按照传入的比较器决定排序方法，可以改变是升序还是降序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Integer[] nums;</span><br><span class="line">...</span><br><span class="line">Comparator&lt;Integer, Integer&gt; c = new Comparator&lt;Integer, Integer&gt;()&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Integer o1, Integer o2)&#123;</span><br><span class="line">        return n2 - n1;// 这个场合，变成从大到小排序</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Arrays.sort(nums, c);</span><br></pre></td></tr></table></figure><p><code>Arrays.binarySearch(array, num)</code>：通过二分搜索法查找。前提是必须先排序。找不到的场合，返回 - (low + 1)。即，其应该在的位置的负值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] nums2 = &#123;-10, -5, -2, 0, 4, 5, 9&#125;;</span><br><span class="line">int index = Arrays.binarySearch(nums2, 7);// 此时 index = -7</span><br><span class="line">// 如果 7 存在，应该在第 7 个位置</span><br></pre></td></tr></table></figure><p><code>Arrays.copyOf(arr, n)</code>：从 <code>arr</code> 中，复制 n 个元素（成为新的数组）。</p><p>n &gt; arr.length 的场合，在多余的位置添加 <code>null</code>。n &lt; 0 的场合，抛出异常。</p><p>该方法的底层使用的是 <code>System.arraycopy</code></p><p><code>Arrays.fill(arr, o)</code>：用 o 填充 <code>num</code> 的所有元素。</p><p><code>Arrays.equals(arr1, arr2)</code>：比较两个数组元素是否完全一致（<code>true</code>&#x2F;<code>false</code>）</p><p><code>Arrays.asList(a, b, c, d)</code>：将输入数据转成一个 <code>List</code> 集合</p><h1 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h1><ul><li><p><code>System.exit(0)</code>：退出当前程序。0 表示一个状态，正常状态是 0</p></li><li><p><code>System.arraycopy(arr, 0, newArr, 0 ,3)</code>：复制数组元素。</p><p>上例是：arr 自下标 0 起开始，向 newArr 自下标 0 开始，依次拷贝 3 个值</p><p>这个方法比较适合底层调用。我们一般使用 <code>Arrays.copyOf</code> 来做</p></li><li><p><code>System.currentTimeMillis</code>：返回当前时间距离 1970 - 1 - 1 的毫秒数</p></li><li><p><code>System.gc</code>：运行垃圾回收机制</p></li></ul><h1 id="BigInteger-和-BigDecimal-类"><a href="#BigInteger-和-BigDecimal-类" class="headerlink" title="BigInteger 和 BigDecimal 类"></a>BigInteger 和 BigDecimal 类</h1><p>BigInteger：适合保存更大的整数</p><p>BigDecimal：适合保存精度更大的浮点数</p><p><strong>构造方法：</strong></p><ul><li><p><code>new BigInteger(String intStr)</code>：通过一个字符串构建大数</p><blockquote><p>直接用数值会报错，用字符串倒是没问题</p></blockquote></li><li><p><code>BigInteger BigInteger.valueOf(1)</code>：通过静态方法，让整数类型转成大数</p></li></ul><p>在对 <code>BigInteger</code> 和 <code>BigDecimal</code> 进行加减乘除的时候，需要使用对应方法，不能直接用 <code>+</code> <code>-</code> <code>*</code> <code>/</code></p><ul><li><p><code>BigInteger add(BigInteger)</code>：加法运算。返回新的大数</p></li><li><p><code>BigInteger subtract(BigInteger)</code>：减法</p></li><li><p><code>BigInteger multiply(BigInteger)</code>：乘法</p></li><li><p><code>BigInteger divide(BigInteger)</code>：除法运算</p><p>该方法可能抛出异常。因为可能产生是无限长度小数。</p><p>解决方法（保留分子精度）：<code>bigDecimal.divide(bD3, BigDecimal.ROUND_CELLING)</code></p></li></ul><p>一些常量：</p><p><code>BigInteger.ONE</code>、<code>BigInteger.ZERO</code>、<code>BigInteger.TEN</code> 分别是 1、0、10</p><h1 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h1><h2 id="第一代日期类Date"><a href="#第一代日期类Date" class="headerlink" title="第一代日期类Date"></a>第一代日期类Date</h2><p>Date：精确到毫秒，代表特定瞬间。需要导入 java.util.Date</p><p>SimpleDateFormat：格式和解析日期的类。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309170944323.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Date d1 = new Date(); //获取当前系统时间</span><br><span class="line">System.out.println(&quot;当前日期=&quot; + d1);</span><br><span class="line">Date d2 = new Date(9234567); //通过指定毫秒数得到时间</span><br><span class="line">System.out.println(&quot;d2=&quot; + d2); //获取某个时间对应的毫秒数</span><br></pre></td></tr></table></figure><p>默认输出日期格式是国外的格式，因此通常需要进行格式转换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy.MM.dd HH.mm.ss&quot;);</span><br><span class="line">String dateFormated = sdf.(d1);//日期转成指定格式。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Date d1 = new Date(); //获取当前系统时间</span><br><span class="line">System.out.println(&quot;当前日期=&quot; + d1);</span><br><span class="line">Date d2 = new Date(9234567); //通过指定毫秒数得到时间</span><br><span class="line">System.out.println(&quot;d2=&quot; + d2); //获取某个时间对应的毫秒数</span><br><span class="line">//1. 创建 SimpleDateFormat 对象，可以指定相应的格式</span><br><span class="line">//2. 这里的格式使用的字母是规定好，不能乱写</span><br><span class="line">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy 年 MM 月 dd 日 hh:mm:ss E&quot;);</span><br><span class="line">String format = sdf.format(d1); // format:将日期转换成指定格式的字符串</span><br><span class="line">System.out.println(&quot;当前日期=&quot; + format);</span><br><span class="line">//1. 可以把一个格式化的 String 转成对应的 Date</span><br><span class="line">//2. 得到 Date 仍然在输出时，还是按照国外的形式，如果希望指定格式输出，需要转换</span><br><span class="line">//3. 在把 String -&gt; Date ， 使用的 sdf 格式需要和你给的 String 的格式一样，否则会抛出转换异常</span><br><span class="line">String s = &quot;1996 年 01 月 01 日 10:20:30 星期一&quot;;</span><br><span class="line">Date parse = sdf.parse(s);</span><br><span class="line">System.out.println(&quot;parse=&quot; + sdf.format(parse));</span><br></pre></td></tr></table></figure><h2 id="第二代日期类Calendar"><a href="#第二代日期类Calendar" class="headerlink" title="第二代日期类Calendar"></a>第二代日期类Calendar</h2><p>Calendar：构造器是私有的，要通过 getInstance 方法获取实例</p><ol><li><p>Calendar 是一个抽象类，其构造器私有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Calendar c1 = Calendar.genInstance();//获取实例的方法</span><br></pre></td></tr></table></figure></li><li><p>提供大量方法和字段提供给程序员使用</p><ul><li><p><code>c1.get(Calendar.YEAR)</code>：获取年份数</p></li><li><p><code>c1.get(Calendar.MONTH)</code>：获取月份数</p><blockquote><p>特别的，实际月份是 返回值 +1。因为 Calendar 的月份是从 0 开始编号的</p></blockquote></li><li><p><code>c1.get(Calendar.DAY_OF_MONTH)</code>：获取日数</p></li><li><p><code>c1.get(Calendar.HOUR)</code>：获取小时数（12小时制）</p><p><code>c1.get(Calendar.HOUR_OF_DATE)</code>：获取小时数（24小时制）</p></li><li><p><code>c1.get(Calendar.MINUTE)</code>：获取分钟数</p></li><li><p><code>c1.get(Calendar.SECOND)</code>：获取秒数</p></li></ul><p>Calendar 没有专门的格式化方法，需要程序员自己组合来显示</p><p>Calendar 也存在不足：</p><ol><li>可变性：像日期和实际这样的类应该是不可改变的</li><li>偏移性：年份都是从 1900 年开始，月份都是从 0 开始</li><li>格式化：只对 Date 有用，对 Calendar 没用</li><li>其他问题：如不能保证线程安全，不能处理闰秒（每隔 2 天多 1 秒）等</li></ol></li></ol><h2 id="第三代日期类"><a href="#第三代日期类" class="headerlink" title="第三代日期类"></a>第三代日期类</h2><p>在 JDK 8 加入了以下新日期类：</p><ul><li>LocalDate：只包含 日期（年月日），可以获取 日期字段</li><li>LocalTime：只包含 时间（时分秒），可以获取 时间字段</li><li>LocalDateTime：包含 日期 + 时间，可以获取 日期 + 时间字段</li><li>DateTimeFormatter：格式化日期</li><li>Instant：时间戳</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309171027031.png"></p><ol><li><ul><li><p>使用 <code>now()</code> 方法返回当前时间的对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime ldt = LocalDateTime.now();//获取当前时间</span><br></pre></td></tr></table></figure></li></ul></li><li><p>获取各字段方法：</p><ul><li><p><code>ldt.getYear();</code>：获取年份数</p></li><li><p><code>ldt.getMonth();</code>：获取月份数（英文）</p><p><code>ldt.getMonthValue();</code>：获取月份数（数字）</p></li><li><p><code>ldt.getDayOfMonth();</code>：获取日数</p></li><li><p><code>LocalDateTime ldt2 = ldt.plusDays(100);</code>：获取 ldt 时间 100 天后的时间实例</p></li><li><p><code>LocalDateTime ldt3 = ldt.minusHours(100);</code>：获取 ldt 时间 100 小时前的时间实例</p></li></ul></li><li><p>格式化日期：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter dtf = new DateTimeFormatter(&quot;yyyy.MM.dd HH.mm.ss&quot;);</span><br><span class="line">String date = dtf.format(ldt);//获取格式化字符串</span><br></pre></td></tr></table></figure></li><li><p><code>Instant</code> 和 <code>Date</code> 类似</p><ul><li>获取当前时间戳：<code>Instant instant = Instant.now();</code></li><li>转换为 <code>Date</code>：<code>Date date = Date.form(instant);</code></li><li>由 <code>Date</code> 转换：<code>Instant instant = date.toInstant;</code></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 内置类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-泛型</title>
      <link href="/2023/09/16/Java.%E6%B3%9B%E5%9E%8B/"/>
      <url>/2023/09/16/Java.%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="泛型引入"><a href="#泛型引入" class="headerlink" title="泛型引入"></a>泛型引入</h2><p>泛型（generic）：又称 参数化类型。是JDK 5 出现的新特性。解决数据类型的安全性问题。在类声明或实例化时只要制定好需要的具体类型即可。</p><p>例1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Properties&lt;Person&gt; prop = <span class="keyword">new</span> <span class="title class_">Properties</span>&lt;Person&gt;();</span><br></pre></td></tr></table></figure><ul><li>上例表示存放到 <code>prop</code> 中的必须是 <code>Person</code> 类型。如果编译器发现添加类型不符合要求，即报错。</li><li>遍历时，直接取出 <code>Person</code> 而非 <code>Object</code></li></ul><p>例2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.base;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">chapter15</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        arrayList.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;旺财&quot;</span>, <span class="number">10</span>));</span><br><span class="line">        arrayList.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;发财&quot;</span>, <span class="number">1</span>));</span><br><span class="line">        arrayList.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;小黄&quot;</span>, <span class="number">5</span>));</span><br><span class="line"><span class="comment">//假如我们的程序员，不小心，添加了一只猫</span></span><br><span class="line">        arrayList.add(<span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;招财猫&quot;</span>, <span class="number">8</span>));</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Object o : arrayList) &#123;</span><br><span class="line"><span class="comment">//向下转型 Object -&gt;Dog</span></span><br><span class="line">            <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) o;</span><br><span class="line">            System.out.println(dog.getName() + <span class="string">&quot;-&quot;</span> + dog.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> &#123; <span class="comment">//Cat 类</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309160944609.png"></p><p>使用传统方法的问题分析</p><ol><li>不能对加入到集合ArrayList中的数据类型进行约束(猫猫狗狗都能发，不加以约束，但是用的时候就有要求了，不安全)</li><li>遍历的时候，需要进行类型转换，如果集合中的数据量较大，对效率有影响（虽然放的就是dog类对象但是就是要用object接受，语法不支持）</li></ol><p>使用泛型好处</p><ol><li>编译时，检查添加元素的类型。可以保证如果编译时没发出警告，运行就不会产生ClassCastException 异常。提高了安全性，使代码更加简洁、健壮。</li><li>也减少了转换的次数，遍历的时候直接取出对象，不用向下转型，提高了效率。</li><li>泛型的作用是：可以在类声明是通过一个标识表示类中某个属性的类型，或某个方法返回值的类型，或参数类型。</li></ol><p>例3：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Javabase.chapter;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">improve</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//使用传统的方法来解决===&gt; 使用泛型</span></span><br><span class="line"><span class="comment">//老韩解读</span></span><br><span class="line"><span class="comment">//1. 当我们 ArrayList&lt;Dog&gt; 表示存放到 ArrayList 集合中的元素是 Dog 类型 (细节后面说...)</span></span><br><span class="line"><span class="comment">//2. 如果编译器发现添加的类型，不满足要求，就会报错</span></span><br><span class="line"><span class="comment">//3. 在遍历的时候，可以直接取出 Dog 类型而不是 Object</span></span><br><span class="line"><span class="comment">//4. public class ArrayList&lt;E&gt; &#123;&#125; E 称为泛型,那么 Dog-&gt;E</span></span><br><span class="line">        ArrayList&lt;Dog&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Dog&gt;();</span><br><span class="line">        arrayList.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;旺财&quot;</span>, <span class="number">10</span>));</span><br><span class="line">        arrayList.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;发财&quot;</span>, <span class="number">1</span>));</span><br><span class="line">        arrayList.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;小黄&quot;</span>, <span class="number">5</span>));</span><br><span class="line"><span class="comment">//假如我们的程序员，不小心，添加了一只猫</span></span><br><span class="line">        <span class="comment">//arrayList.add(new Cat(&quot;招财猫&quot;, 8));</span></span><br><span class="line">        System.out.println(<span class="string">&quot;===使用泛型====&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Dog dog : arrayList) &#123;</span><br><span class="line">            System.out.println(dog.getName() + <span class="string">&quot;-&quot;</span> + dog.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> &#123; <span class="comment">//Cat 类</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>类型不对，直接报错</p></blockquote><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309160947413.png"></p><h2 id="泛型介绍"><a href="#泛型介绍" class="headerlink" title="泛型介绍"></a>泛型介绍</h2><p>泛(广泛)型(类型) &#x3D;&gt; Integer, String,Dog（泛型只能应用于 <strong>引用类型</strong>，int等基本类型要换为Integer等包装类）</p><ol><li>泛型又称参数化类型，是Jdk5.0 出现的新特性，解决数据类型的安全性问题</li><li>在类声明或实例化时只要指定好需要的具体的类型即可。</li><li>Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。 同时，代码更加简洁、健壮</li><li>泛型的作用是：可以在类声明时通过一个标识表示类中某个属性的类型，或者是某个方<br>法的返回值的类型，或者是参数类型。</li></ol><blockquote><p>泛型可以理解为表示数据类型的数据类型</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class P&lt;E&gt; &#123;            //实例化时指定 E 的类型，编译时上例所有 E 会被编译器替换为那个指定类型</span><br><span class="line">E e;//E 表示 e 的数据类型，在定义P类时指定。在编译期间即确认类型</span><br><span class="line">public P(E e)&#123;//可作为参数类型</span><br><span class="line">this.e = e;</span><br><span class="line">&#125;</span><br><span class="line">public E f()&#123;    //可作为返回类型</span><br><span class="line">return this.e;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>&lt;&gt;中是什么类型，运行就是什么类型</p></blockquote><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309161012445.png"></p><h2 id="泛型语法"><a href="#泛型语法" class="headerlink" title="泛型语法"></a>泛型语法</h2><h3 id="泛型的声明"><a href="#泛型的声明" class="headerlink" title="泛型的声明"></a>泛型的声明</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">interface 接口 &lt;T&gt;&#123;&#125;</span><br><span class="line">class 类 &lt;K,V&gt;&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>KTV不代表值，而是表示类型。任意字母都可以。常用T表示，是Type的缩写</p></blockquote><h3 id="实例化泛型"><a href="#实例化泛型" class="headerlink" title="实例化泛型"></a>实例化泛型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strList = new ArrayList&lt;String&gt;();</span><br><span class="line">Iterator&lt;Integer&gt; iterator = vector.interator&lt;Integer&gt;();</span><br></pre></td></tr></table></figure><blockquote><p>类名后面指定类型参数的值</p></blockquote><p><strong>注意细节：</strong></p><ol><li><p>泛型只能是引用类型</p></li><li><p>指定泛型具体类型后，可以传入该类型或其子类类型（向上转型：父类引用指向子类对象）</p></li><li><p>在实际开发中往往简写泛型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strList = new ArrayList&lt;&gt;();//前面写了，后面可以不用写</span><br></pre></td></tr></table></figure></li><li><p>实例化不写泛型的场合，相当于默认泛型为 <code>Object</code>（所有类型的总父类）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list = new ArrayList();</span><br><span class="line">//等价于</span><br><span class="line">ArrayList&lt;&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">//等价于</span><br><span class="line">ArrayList&lt;Object&gt; list = new ArrayList&lt;Object&gt;();</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309161053877.png"></p></li></ol><p>例题1：</p><ol><li>创建3个学生对象</li><li>放入到HashSet中学生对象</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//学生类</span><br><span class="line">class student&#123;</span><br><span class="line">    public String name;</span><br><span class="line">    public int age;</span><br><span class="line"></span><br><span class="line">    public student(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;student&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//main方法</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        HashSet&lt;Student&gt; students = new HashSet&lt;&gt;();</span><br><span class="line">        students.add(new Student(&quot;张三&quot;,11));</span><br><span class="line">        students.add(new Student(&quot;李四&quot;,11));</span><br><span class="line">        students.add(new Student(&quot;王五&quot;,11));</span><br><span class="line">        for (Student student: students) &#123;</span><br><span class="line">            System.out.println(student);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>例题2：</p><h2 id="自定义泛型类"><a href="#自定义泛型类" class="headerlink" title="自定义泛型类"></a>自定义泛型类</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class 类名 &lt;T,R...&gt; &#123; 成员 &#125;  //T、R是泛型标识符，可有多个，一般是单个大写字母表示</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li><p>普通成员（属性、方法）可以使用泛型</p></li><li><p>泛型类的类型，是在创建对象时确定的，创建对象时需要指明类型。</p><p>静态方法中不能使用类的泛型；因为静态是和类相关的，在类加载时，对象还没有创建，所以，如果静态方法和静态属性使用了泛型，JVM 就无法完成初始化</p></li><li><p>使用泛型的数组，也不能初始化，</p><p>因为数组在 new 不能确定 T 的类型，就无法在内存开空间。</p></li><li><p>创建对象时不指定的场合，默认 Object。建议还是写上 <code>&lt;Object&gt;</code></p></li></ol><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">class Tiger&lt;T, R, M&gt; &#123;</span><br><span class="line">    String name;</span><br><span class="line">    R r; //属性使用到泛型</span><br><span class="line">    M m; //属性使用到泛型</span><br><span class="line">    T t; //属性使用到泛型</span><br><span class="line">    //因为数组在 new 不能确定 T 的类型，就无法在内存开空间</span><br><span class="line">    T[] ts;</span><br><span class="line">    public Tiger(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public Tiger(R r, M m, T t) &#123;//构造器使用泛型</span><br><span class="line">        this.r = r;</span><br><span class="line">        this.m = m;</span><br><span class="line">        this.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">    public Tiger(String name, R r, M m, T t) &#123;//构造器使用泛型</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.r = r;</span><br><span class="line">        this.m = m;</span><br><span class="line">        this.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">    //</span><br><span class="line">// &#125;</span><br><span class="line">//方法使用泛型</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public R getR() &#123;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setR(R r) &#123;//方法使用到泛型</span><br><span class="line">        this.r = r;</span><br><span class="line">    &#125;</span><br><span class="line">    public M getM() &#123;//返回类型可以使用泛型.</span><br><span class="line">        return m;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setM(M m) &#123;</span><br><span class="line">        this.m = m;</span><br><span class="line">    &#125;</span><br><span class="line">    public T getT() &#123;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setT(T t) &#123;</span><br><span class="line">        this.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Tiger&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, r=&quot; + r +</span><br><span class="line">                &quot;, m=&quot; + m +</span><br><span class="line">                &quot;, t=&quot; + t +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义泛型接口"><a href="#自定义泛型接口" class="headerlink" title="自定义泛型接口"></a>自定义泛型接口</h2><p>泛型定义在接口上</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">interface 接口名 &lt;T,R...&gt;&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意细节：</p><ol><li>接口中，静态成员也不能使用泛型(这个和泛型类规定一样)</li><li>泛型接口的类型，在<strong>继承接口</strong>或者<strong>实现接口</strong>时确定</li><li>没有指定类型，默认为Object</li></ol><h2 id="自定义泛型方法"><a href="#自定义泛型方法" class="headerlink" title="自定义泛型方法"></a>自定义泛型方法</h2><p>泛型定义在方法上</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;&gt; 返回值 方法名（参数列表）&#123;&#125;</span><br></pre></td></tr></table></figure><p>细节：</p><ol><li>泛型方法，可以定义在普通类中，也可以定义在泛型类里面</li><li>当泛型方法被调用时，类型会确定</li><li>public void eat(E e) {}， 修饰符后没有&lt;TR..&gt; ，该方法不是泛型方法，而是使用了泛型</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Car1&lt;T,R&gt;&#123;</span><br><span class="line">    public void hi(T t) &#123;//这里没问题，因为T我在类里面就声明了</span><br><span class="line">    &#125;</span><br><span class="line">    //泛型方法，可以使用类声明的泛型，也可以使用自己声明泛型</span><br><span class="line">    public&lt;K&gt; void hello(R r, K k) &#123;</span><br><span class="line">        System.out.println(r.getClass());//ArrayList</span><br><span class="line">        System.out.println(k.getClass());//Float</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Car2&#123;</span><br><span class="line">    public void hi(T t) &#123;//这里会报错，不知道T是什么</span><br><span class="line">    &#125;</span><br><span class="line">    //泛型方法，可以使用类声明的泛型，也可以使用自己声明泛型</span><br><span class="line">    public&lt;K,R&gt; void hello(R r, K k) &#123;//这里没问题，RK在方法里面声明</span><br><span class="line">        System.out.println(r.getClass());//ArrayList</span><br><span class="line">        System.out.println(k.getClass());//Float</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309161756763.png"></p><p>  例题来喽~</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309161800666.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package org.example;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Apple&lt;String, Integer, Double&gt; apple = new Apple&lt;&gt;();</span><br><span class="line">        apple.fly(10);//10 会被自动装箱 Integer10, 输出 Integer</span><br><span class="line">        apple.fly(new Dog());//new出来的，Dog类型</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Apple&lt;T, R, M&gt; &#123;//自定义泛型类</span><br><span class="line">    public &lt;E&gt; void fly(E e) &#123; //泛型方法</span><br><span class="line">        System.out.println(e.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    //public void eat(U u) &#123;&#125;//错误，因为 U 没有声明</span><br><span class="line">    public void run(M m) &#123;</span><br><span class="line">    &#125; //ok</span><br><span class="line">&#125;</span><br><span class="line">class Dog &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型继承和通配符"><a href="#泛型继承和通配符" class="headerlink" title="泛型继承和通配符"></a>泛型继承和通配符</h2><ol><li><p>泛型不具备继承性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; list = new ArrayList &lt;String&gt; 0;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309161827820.png"></p></li><li><?> :支持任意泛型类型</li><li><? extends A>:支持A类以及A类的子类，规定了泛型的上限</li><li><? super A>:支持A类以及A类的父类，不限于直接父类，规定了泛型的下限</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring入门</title>
      <link href="/2023/09/12/Spring%E5%85%A5%E9%97%A8.1/"/>
      <url>/2023/09/12/Spring%E5%85%A5%E9%97%A8.1/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring相关概念"><a href="#Spring相关概念" class="headerlink" title="Spring相关概念"></a>Spring相关概念</h1><h2 id="Spring家族"><a href="#Spring家族" class="headerlink" title="Spring家族"></a>Spring家族</h2><p>官网：<a href="https://spring.io,/">https://spring.io，</a> 从官网我们可以大概了解到：</p><ul><li><p>Spring能做什么:用以开发web、微服务以及分布式系统等,光这三块就已经占了JavaEE开发的九成多。</p></li><li><p>Spring并不是单一的一个技术，而是一个大家族，可以从官网的<code>Projects</code>中查看其包含的所有技术。</p></li><li><p>Spring发展到今天已经形成了一种开发的生态圈,Spring提供了若干个项目,每个项目用于完成特定的功能。</p><ul><li>Spring已形成了完整的生态圈，也就是说我们可以完全使用Spring技术完成整个项目的构建、设计与开发。</li><li>Spring有若干个项目，可以根据需要自行选择，把这些个项目组合起来，起了一个名称叫Spring全家桶</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309122209999.png"></p><p>重点关注<code>Spring Framework</code>、<code>SpringBoot</code>和<code>SpringCloud</code></p><ul><li>Spring Framework：Spring框架，是Spring中最早最核心的技术，也是所有其他技术的基础。</li><li>SpringBoot：Spring是来简化开发，而SpringBoot是来帮助Spring在简化的基础上能更快速进行开发。</li><li>SpringCloud：这个是用来做分布式之微服务架构的相关开发。</li></ul><p>Spring Framework架构图以4的架构图</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309122211853.png"></p><ol><li>核心层<ul><li>Core Container：核心容器，这个模块是Spring最核心的模块，其他的都需要依赖该模块</li></ul></li><li>AOP层<ul><li>AOP(Aspect Oriented Programming)：面向切面编程，它依赖核心层容器，目的是在不改变原有代码的前提下对其进行功能增强</li><li>Aspects：AOP是思想，Aspects是对AOP思想的具体实现</li></ul></li><li>数据层<ul><li>Data Access：数据访问，Spring全家桶中有对数据访问的具体实现技术</li><li>Data Integration：数据集成，Spring支持整合其他的数据层解决方案，比如Mybatis</li><li>Transactions：事务，Spring中事务管理是Spring AOP的一个具体实现，也是后期学习的重点内容</li></ul></li><li>Web层<ul><li>这一层的内容将在SpringMVC框架具体学习</li></ul></li><li>Test层<ul><li>Spring主要整合了Junit来完成单元测试和集成测试</li></ul></li></ol><h2 id="Spring核心概念"><a href="#Spring核心概念" class="headerlink" title="Spring核心概念"></a>Spring核心概念</h2><p>在Spring核心概念这部分内容中主要包含<code>IOC/DI</code>、<code>IOC容器</code>和<code>Bean</code></p><h3 id="IOC-Inversion-of-Control-控制反转"><a href="#IOC-Inversion-of-Control-控制反转" class="headerlink" title="IOC(Inversion of Control)控制反转"></a>IOC(Inversion of Control)控制反转</h3><ul><li>什么是控制反转<ul><li>使用对象时，由主动new产生对象转换为由<code>外部</code>提供对象，此过程中对象创建控制权由程序转移到外部，此思想称为控制反转。</li><li>业务层要用数据层的类对象，以前是自己<code>new</code>的</li><li>现在自己不new了，交给<code>别人[外部]</code>来创建对象</li><li><code>别人[外部]</code>就反转控制了数据层对象的创建权</li><li>这种思想就是控制反转</li><li>别人[外部]指的是什么呢?继续往下看</li></ul></li><li>Spring和IOC之间的关系是什么呢?<ul><li>Spring技术对IOC思想进行了实现</li><li>Spring提供了一个容器，称为<code>IOC容器</code>，用来充当IOC思想中的”外部”</li><li>IOC思想中的<code>别人[外部]</code>指的就是Spring的IOC容器</li></ul></li><li>IOC容器的作用以及内部存放的是什么?<ul><li>IOC容器负责对象的创建、初始化等一系列工作，其中包含了数据层和业务层的类对象</li><li>被创建或被管理的对象在IOC容器中统称为Bean</li><li>IOC容器中放的就是一个个的Bean对象</li></ul></li><li>当IOC容器中创建好service和dao对象后，程序能正确执行么?<ul><li>不行，因为service运行需要依赖dao对象</li><li>IOC容器中虽然有service和dao对象</li><li>但是service对象和dao对象没有任何关系</li><li>需要把dao对象交给service,也就是说要绑定service和dao对象之间的关系</li><li>像这种在容器中建立对象与对象之间的绑定关系就要用到DI(Dependency Injection)依赖注入.</li></ul></li></ul><h3 id="DI-Dependency-Injection-依赖注入"><a href="#DI-Dependency-Injection-依赖注入" class="headerlink" title="DI(Dependency Injection)依赖注入"></a>DI(Dependency Injection)依赖注入</h3><ul><li>什么是依赖注入呢?<ul><li>在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入<ul><li>业务层要用数据层的类对象，以前是自己<code>new</code>的</li><li>现在自己不new了，靠<code>别人[外部其实指的就是IOC容器]</code>来给注入进来</li><li>这种思想就是依赖注入</li></ul></li></ul></li><li>IOC容器中哪些bean之间要建立依赖关系呢?<ul><li>这个需要程序员根据业务需求提前建立好关系，如业务层需要依赖数据层，service就要和dao建立依赖关系</li></ul></li><li>介绍完Spring的IOC和DI的概念后，我们会发现这两个概念的最终目标就是:充分解耦，具体实现靠:<ul><li>使用IOC容器管理bean（IOC)</li><li>在IOC容器内将有依赖关系的bean进行关系绑定（DI）</li><li>最终结果为:使用对象时不仅可以直接从IOC容器中获取，并且获取到的bean已经绑定了所有的依赖关系.</li></ul></li></ul><p><a href="https://zhuanlan.zhihu.com/p/33492169">理解文章</a></p><p>重点要理解<code>什么是IOC/DI思想</code>、<code>什么是IOC容器</code>和<code>什么是Bean</code>：</p><ol><li>什么IOC&#x2F;DI思想?<ul><li>IOC:控制反转，控制反转的是对象的创建权</li><li>DI:依赖注入，绑定对象与对象之间的依赖关系</li></ul></li><li>什么是IOC容器?<ul><li>Spring创建了一个容器用来存放所创建的对象，这个容器就叫IOC容器</li></ul></li><li>什么是Bean?<ul><li>容器中所存放的一个个对象就叫Bean或Bean对象</li></ul></li></ol><h1 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h1><h2 id="IOC入门案例"><a href="#IOC入门案例" class="headerlink" title="IOC入门案例"></a>IOC入门案例</h2><h3 id="入门案例思路分析"><a href="#入门案例思路分析" class="headerlink" title="入门案例思路分析"></a>入门案例思路分析</h3><ol><li>Spring是使用容器来管理bean对象的，那么管什么?<ul><li>主要管理项目中所使用到的类对象，比如(Service和Dao)</li></ul></li><li>如何将被管理的对象告知IOC容器?<ul><li>使用配置文件</li></ul></li><li>被管理的对象交给IOC容器，要想从容器中获取对象，就先得思考如何获取到IOC容器?<ul><li>Spring框架提供相应的接口</li></ul></li><li>IOC容器得到后，如何从容器中获取bean?<ul><li>调用Spring框架提供对应接口中的方法</li></ul></li><li>使用Spring导入哪些坐标?<ul><li>用别人的东西，就需要在pom.xml添加对应的依赖</li></ul></li></ol><h3 id="入门案例实现"><a href="#入门案例实现" class="headerlink" title="入门案例实现"></a>入门案例实现</h3><ul><li>需求分析:将BookServiceImpl和BookDaoImpl交给Spring管理，并从容器中获取对应的bean对象进行方法调用。</li></ul><ol><li><p>创建Maven的java项目</p></li><li><p>pom.xml添加Spring的依赖jar包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>创建BookDao，BookDaoImpl，BookService和BookServiceImpl四个类</p><ul><li>BookDao</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface BookDao &#123;</span><br><span class="line">    public void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>BookDaoImpl</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>BookService</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface BookService &#123;</span><br><span class="line">    public void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>BookServiceImpl</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class BookServiceImpl implements BookService &#123;</span><br><span class="line">    private BookDao bookDao = new BookDaoImpl();</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>resources下添加spring配置文件</p><p>右键 -&gt; 新建 -&gt; XML配置文件 -&gt; Spring配置</p></li><li><p>在配置文件中完成bean的配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">XML</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">      &lt;!--</span><br><span class="line">      bean标签标示配置bean</span><br><span class="line">      id属性标示给bean起名字</span><br><span class="line">      class属性表示给bean定义类型，</span><br><span class="line">      得是具体的实现类而不是接口，要靠这个造对象的</span><br><span class="line">      --&gt;</span><br><span class="line">    &lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;bookService&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>注意事项：bean定义时id属性在同一个上下文中(配置文件)不能重复</p></li><li><p>获取IOC容器<br>使用Spring提供的接口完成IOC容器的创建，创建App类，编写main方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>从容器中获取对象进行方法调用<br>使用getBean(String name)方法，其name参数就是我们在bean配置的id，通过这个id来造对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        BookService bookService = (BookService) context.getBean(&quot;bookService&quot;);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行程序</p></li></ol><h2 id="DI入门案例"><a href="#DI入门案例" class="headerlink" title="DI入门案例"></a>DI入门案例</h2><p>对于DI的入门案例，我们依然先<code>分析思路</code>然后再<code>代码实现</code></p><h3 id="入门案例思路分析-1"><a href="#入门案例思路分析-1" class="headerlink" title="入门案例思路分析"></a>入门案例思路分析</h3><ol><li>要想实现依赖注入，必须要基于IOC管理Bean<ul><li>DI的入门案例要依赖于前面的IOC入门案例</li></ul></li><li>Service中使用new形式创建的Dao对象是否保留？<ul><li>不保留，这样才能解耦合，最终要使用IOC容器中的bean对象</li></ul></li><li>Service中需要的Dao对象如何进入到Service中？<ul><li>在Service中提供一个方法（例如提供一个set方法），让Spring的IOC容器可以通过该方法传入bean对象，也就达到了不是自己new，而是外部提供</li></ul></li><li>Service与Dao之间的关系如何描述？<ul><li>使用配置文件</li></ul></li></ol><h3 id="入门案例实现-1"><a href="#入门案例实现-1" class="headerlink" title="入门案例实现"></a>入门案例实现</h3><p>需求：基于IOC入门案例，在BookServiceImpl类中删除new对象的方式，使用Spring的DI完成Dao层的注入</p><ol><li><p>删除业务层中使用new的方式创建的dao对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class BookServiceImpl implements BookService &#123;</span><br><span class="line">    //private BookDao bookDao = new BookDaoImpl();</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在业务层提供BookDao的setter方法</p><p>我们在set方法中加一条输出语句，看看是否被调用了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class BookServiceImpl implements BookService &#123;</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBookDao(BookDao bookDao) &#123;</span><br><span class="line">        this.bookDao = bookDao;</span><br><span class="line">        System.out.println(&quot;set方法被调用啦&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在配置文件中添加依赖注入的配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">XML</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">    &lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--主要变化在这里--&gt;</span><br><span class="line">    &lt;bean id=&quot;bookService&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot;&gt;</span><br><span class="line">        &lt;!--配置server与dao的关系--&gt;</span><br><span class="line">        &lt;!--</span><br><span class="line">            property标签表示配置当前bean的属性</span><br><span class="line">            name属性表示配置哪一个具体的属性(这里是配置bookService的bookDao属性)</span><br><span class="line">            ref属性表示参照哪一个bean(参照当前配置文件中的bookDao)</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>注意:配置中的两个bookDao的含义是不一样的</p><ul><li>name&#x3D;”bookDao”中<code>bookDao</code>的作用是让Spring的IOC容器在获取到名称后，将首字母大写，前面加set找对应的<code>setBookDao()</code>方法进行对象注入</li><li>ref&#x3D;”bookDao”中<code>bookDao</code>的作用是让Spring能在IOC容器中找到id为<code>bookDao</code>的Bean对象给<code>bookService</code>进行注入</li></ul></li></ol><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309122236452.png"></p><ol start="4"><li>运行程序调用方法</li></ol><h1 id="IOC相关内容"><a href="#IOC相关内容" class="headerlink" title="IOC相关内容"></a>IOC相关内容</h1><p>通过前面两个案例，已经学习了<code>bean如何定义配置</code>，<code>DI如何定义配置</code>以及<code>容器对象如何获取</code>的内容，接下来主要是把这三块内容展开进行详细的讲解，深入的学习下这三部分的内容，首先是bean基础配置。</p><h2 id="bean基础配置"><a href="#bean基础配置" class="headerlink" title="bean基础配置"></a>bean基础配置</h2><p>对于bean的配置中，主要会讲解<code>bean基础配置</code>,<code>bean的别名配置</code>,<code>bean的作用范围配置</code>(重点),这三部分内容</p><h3 id="id与class"><a href="#id与class" class="headerlink" title="id与class"></a>id与class</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;&quot; class=&quot;&quot;/&gt;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309122242661.png"></p><h3 id="name别名"><a href="#name别名" class="headerlink" title="name别名"></a>name别名</h3><p>在bean标签中配置name属性，来充当别名</p><p>注意事项：</p><ul><li>bean依赖注入的ref属性指定bean，必须在容器中存在，而ref的值也可以是name里的别名，不过还是建议用id值来注入</li><li>如果我们在调用getBean(String name)方法时，传入了一个不存在该名称的bean对象，则会报错<code>NoSuchBeanDefinitionException</code>，此时我们要检查一下是哪边写错了（例如bean的id和name都没有service100，而getBean的参数却写了service100）</li></ul><h3 id="scope作用范围"><a href="#scope作用范围" class="headerlink" title="scope作用范围"></a>scope作用范围</h3><p>关于bean的作用范围是bean属性配置的一个重点内容。<br>bean的scope有两个取值：</p><ul><li>singleton：单例（默认），对象都是同一个，节省内存空间和时间</li><li>prototype：非单例，对象都是新的</li></ul><h4 id="验证IOC容器中对象是否为单例"><a href="#验证IOC容器中对象是否为单例" class="headerlink" title="验证IOC容器中对象是否为单例"></a>验证IOC容器中对象是否为单例</h4><ul><li>验证思路：我们只需要对同一个bean创建两个对象，然后打印二者的地址值，看看是否一致</li></ul><p>如果我想创建出来非单例的bean对象，该如何实现呢</p><ul><li>配置bean的scope属性为prototype</li></ul><h3 id="介绍完scope属性以后，我们来思考几个问题"><a href="#介绍完scope属性以后，我们来思考几个问题" class="headerlink" title="介绍完scope属性以后，我们来思考几个问题:"></a>介绍完<code>scope</code>属性以后，我们来思考几个问题:</h3><ul><li>为什么bean默认为单例?<ul><li>bean为单例的意思是在Spring的IOC容器中只会有该类的一个对象</li><li>bean对象只有一个就避免了对象的频繁创建与销毁，达到了bean对象的复用，性能高</li></ul></li><li>bean在容器中是单例的，会不会产生线程安全问题?<ul><li>如果对象是有状态对象，即该对象有成员变量可以用来存储数据的，</li><li>因为所有请求线程共用一个bean对象，所以会存在线程安全问题。</li><li>如果对象是无状态对象，即该对象没有成员变量没有进行数据存储的，</li><li>因方法中的局部变量在方法调用完成后会被销毁，所以不会存在线程安全问题。</li></ul></li><li>哪些bean对象适合交给容器进行管理?<ul><li>表现层对象（controller）</li><li>业务层对象（service）</li><li>数据层对象（dao）</li><li>工具对象（util）</li></ul></li><li>哪些bean对象不适合交给容器进行管理?<ul><li>封装实例的域对象（domain，pojo），因为会引发线程安全问题，所以不适合。</li></ul></li></ul><h1 id="bean实例化"><a href="#bean实例化" class="headerlink" title="bean实例化"></a>bean实例化</h1><p>对象已经能交给Spring的IOC容器来创建了，但是容器是如何来创建对象的呢?</p><ul><li>就需要研究下bean的实例化过程，在这块内容中主要解决两部分内容，分别是<ul><li>bean是如何创建的</li><li>实例化bean的三种方式，<code>构造方法</code>,<code>静态工厂</code>和<code>实例工厂</code></li></ul></li></ul><p>在讲解这三种创建方式之前，我们需要先确认一件事:</p><ul><li>bean本质上就是对象，对象在new的时候会使用构造方法完成，那创建bean也是使用构造方法完成的。<ul><li>基于这个知识点出发，我们来验证spring中bean的三种创建方式，</li></ul></li></ul><p>构造方法实例化</p><ol><li><p>在之前的BookDaoImpl类中添加一个无参构造函数，并打印一句话，方便观察结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line"> public void save() &#123;</span><br><span class="line">     System.out.println(&quot;book dao save ...&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public BookDaoImpl() &#123;</span><br><span class="line">     System.out.println(&quot;book dao constructor is running ...&quot;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行程序</p></li><li><p>若将构造器私有化继续测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private BookDaoImpl() &#123;</span><br><span class="line">        System.out.println(&quot;book dao constructor is running ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行程序，能执行成功，说明内部走的依然是构造函数，能访问到类中的私有构造方法，显而易见Spring底层用的是反射</p></li><li><p>若将构造器添加参数继续测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BookDaoImpl(int i) &#123;</span><br><span class="line">        System.out.println(&quot;book dao constructor is running ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行程序，程序会报错<code>NoSuchMethodException</code>，说明Spring底层使用的是类的无参构造方法</p></li></ol><h3 id="静态工厂实例化"><a href="#静态工厂实例化" class="headerlink" title="静态工厂实例化"></a>静态工厂实例化</h3><ol><li><p>创建一个工厂类BookDaoFactory并提供一个静态方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//静态工厂创建对象</span><br><span class="line">public class BookDaoFactory &#123;</span><br><span class="line">    public static BookDao getBookDaoImpl()&#123;</span><br><span class="line">        return new BookDaoImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改App运行类，在类中通过工厂获取对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //通过静态工厂创建对象</span><br><span class="line">        BookDao bookDao = BookDaoFactory.getBookDaoImpl();</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行后，可以查看到结果</p></li></ol><ul><li>那我们如何将这种方式交给Spring来管理呢？</li><li>这就要用到Spring中的静态工厂实例化的知识了，具体实现步骤为:</li></ul><ol><li><p>在spring的配置文件application.properties修改bookDao的bean</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.factory.BookDaoFactory&quot; factory-method=&quot;getBookDaoImpl&quot;/&gt;</span><br></pre></td></tr></table></figure><p>class:工厂类的类全名</p><p>factory-mehod:具体工厂类中创建对象的方法名</p></li><li><p>在App运行类，使用从IOC容器中获取bean的方法进行运行测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        BookDao bookDao = (BookDao) context.getBean(&quot;bookDao&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行后，结果如下，与我们自己直接new对象没太大区别，而且还麻烦了，那这种方式的意义是什么呢</p></li><li><p>原因</p><p>在工厂的静态方法中，我们除了new对象还可以做其他的一些业务操作，而之前new对象的方式就无法添加其他的业务内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class BookDaoFactory &#123;</span><br><span class="line">    public static BookDao getBookDaoImpl() &#123;</span><br><span class="line">        System.out.println(&quot;book dao factory setup ...&quot;);//模拟必要的业务操作</span><br><span class="line">        //这里还可以加一大堆业务逻辑</span><br><span class="line">        return new BookDaoImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li></ol><p>介绍完静态工厂实例化后，这种方式一般是用来兼容早期的一些老系统，所以<code>了解为主</code></p><h3 id="实例工厂与FactoryBean"><a href="#实例工厂与FactoryBean" class="headerlink" title="实例工厂与FactoryBean"></a>实例工厂与FactoryBean</h3><ol><li><p>修改工厂类<code>BookDaoFactory</code>的get方法，注意此处和静态工厂的工厂类不一样的地方是方法<code>不是静态方法</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoFactory &#123;</span><br><span class="line">    //唯一的区别就是去掉的static</span><br><span class="line">    public BookDao getBookDaoImpl() &#123;</span><br><span class="line">        System.out.println(&quot;book dao factory setup ...&quot;);//模拟必要的业务操作</span><br><span class="line">        //这里还可以加一大堆业务逻辑</span><br><span class="line">        return new BookDaoImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改App运行类，在类中通过工厂获取对象，由于不是静态方法了，所以我们需要先创建实例工厂对象，然后再用实例工厂对象调用方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建实例工厂对象</span><br><span class="line">        BookDaoFactory bookDaoFactory = new BookDaoFactory();</span><br><span class="line">        //通过实例工厂对象创建对象</span><br><span class="line">        BookDao bookDao = bookDaoFactory.getBookDaoImpl();</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行结果</p></li></ol><ul><li>那么对于上面这种实例工厂的方式如何交给Spring管理呢?</li></ul><ol><li><p>在spring配置文件中修改bookDao的bean</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bookDaoFactory&quot; class=&quot;com.blog.factory.BookDaoFactory&quot;/&gt;</span><br><span class="line">&lt;bean id=&quot;bookDao&quot; factory-bean=&quot;bookDaoFactory&quot; factory-method=&quot;getBookDaoImpl&quot;/&gt;</span><br></pre></td></tr></table></figure><p>实例化工厂运行的顺序是:</p><ul><li>创建实例化工厂对象,对应的是第一行配置</li><li>调用对象中的方法来创建bean，对应的是第二行配置<ul><li>factory-bean:工厂的实例对象</li><li>factory-method:工厂对象中的具体创建对象的方法名</li></ul></li></ul></li><li><p>在App运行类，使用从IOC容器中获取bean的方法进行运行测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        BookDao bookDao = (BookDao) context.getBean(&quot;bookDao&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行</p></li></ol><p>实例工厂实例化的方式就配置的过程还是比较复杂，要写两行配置，而且这两行还是高耦合的，所以Spring为了简化这种配置方式就提供了一种叫<code>FactoryBean</code>的方式来简化开发</p><h4 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h4><ol><li><p>创建一个BookDaoFactoryBean类，实现FactoryBean接口，重写接口方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoFactoryBean implements FactoryBean&lt;BookDao&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public BookDao getObject() throws Exception &#123;</span><br><span class="line">        return new BookDaoImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        return BookDao.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在Spring的配置文件中修改bookDao的bean</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.factory.BookDaoFactoryBean&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>App运行类不用做任何修改，直接运行</p></li></ol><p>这种方式在Spring去整合其他框架的时候会被用到，所以这种方式需要我们理解掌握。</p><ul><li><p>查看源码会发现，FactoryBean接口其实会有三个方法，分别是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">T getObject() throws Exception;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; getObjectType();</span><br><span class="line"></span><br><span class="line">default boolean isSingleton() &#123;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法一:getObject()，被重写后，在方法中进行对象的创建并返回</p></li><li><p>方法二:getObjectType()，被重写后，主要返回的是被创建类的Class对象</p></li><li><p>方法三:没有被重写，因为它已经给了默认值，从方法名中可以看出其作用是设置对象是否为单例，默认true</p></li></ul><h3 id="bean实例化小结"><a href="#bean实例化小结" class="headerlink" title="bean实例化小结"></a>bean实例化小结</h3><ul><li><p>bean是如何创建的呢?</p><ul><li>通过构造方法</li></ul></li><li><p>Spring的IOC实例化对象的三种方式分别是:</p><ul><li><p>构造方法(常用)</p></li><li><p>静态工厂(了解)</p></li><li><p>实例工厂(了解)</p><ul><li><p>FactoryBean(实用)</p><p>这些方式中，重点掌握构造方法和FactoryBean即可。</p></li></ul></li></ul></li></ul><blockquote><p>需要注意的一点是，构造方法在类中默认会提供，但是如果重写了构造方法，默认的就会消失，在使用的过程中需要注意，如果需要重写构造方法，最好把默认的构造方法也重写下。</p></blockquote><h2 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h2><p>关于bean的相关知识还有最后一个是<code>bean的生命周期</code>，对于生命周期，我们主要围绕着<code>bean生命周期控制</code>来讲解</p><ul><li>首先理解下什么是生命周期?<ul><li>从创建到消亡的完整过程,例如人从出生到死亡的整个过程就是一个生命周期。</li></ul></li><li>bean生命周期是什么?<ul><li>bean对象从创建到销毁的整体过程。</li></ul></li><li>bean生命周期控制是什么?<ul><li>在bean创建后到销毁前做一些事情。</li></ul></li><li>现在我们面临的问题是如何在bean的创建之后和销毁之前把我们需要添加的内容添加进去。</li></ul><h3 id="生命周期设置"><a href="#生命周期设置" class="headerlink" title="生命周期设置"></a>生命周期设置</h3><p>具体的控制有两个阶段:</p><ul><li>bean创建之后，想要添加内容，比如用来初始化需要用到资源</li><li>bean销毁之前，想要添加内容，比如用来释放用到的资源</li></ul><ol><li><p>添加初始化和销毁方法<br>针对这两个阶段，我们在BookDaoImpl类中分别添加两个方法，方法名随便取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void init() &#123;</span><br><span class="line">        System.out.println(&quot;init ... &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">        System.out.println(&quot;destroy ... &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置生命周期，修改bookDao的配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot; init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>运行程序</p></li></ol><p>从结果中可以看出，init方法执行了，但是destroy方法却未执行，这是为什么呢?</p><ul><li>Spring的IOC容器是运行在JVM中</li><li>运行main方法后,JVM启动,Spring加载配置文件生成IOC容器,从容器获取bean对象，然后调方法执行</li><li>main方法执行完后，JVM退出，这个时候IOC容器中的bean还没有来得及销毁就已经结束了</li><li>所以没有调用对应的destroy方法</li></ul><h3 id="close关闭容器"><a href="#close关闭容器" class="headerlink" title="close关闭容器"></a>close关闭容器</h3><ul><li>ApplicationContext中没有close方法，它的子类中有close方法</li><li>所以需要将ApplicationContext更换成ClassPathXmlApplicationContext，然后调用close方法就好啦</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        BookDao bookDao = (BookDao) context.getBean(&quot;bookDao&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行程序，输出如下，可以看到destroy正常输出</li></ul><h3 id="注册钩子关闭容器"><a href="#注册钩子关闭容器" class="headerlink" title="注册钩子关闭容器"></a>注册钩子关闭容器</h3><ul><li><p>在容器未关闭之前，提前设置好回调函数，让JVM在退出之前回调此函数来关闭容器</p></li><li><p>调用context的registerShutdownHook()方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        BookDao bookDao = (BookDao) context.getBean(&quot;bookDao&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">        context.registerShutdownHook();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>那两种方式介绍完后，close和registerShutdownHook选哪个?</p><ul><li>相同点:这两种都能用来关闭容器</li><li>不同点:close()是在调用的时候关闭，registerShutdownHook()是在JVM退出前调用关闭。<ul><li>那么registerShutdownHook()方法可以在任意位置调用，下面的代码中将其放在了第二行，仍能正常输出，但要是将其换成close()方法，则会报错<code>BeanFactory not initialized or already closed</code>，这里就是already closed</li></ul></li></ul><p>开发中到底用哪个呢？</p><ul><li>答案是两个都不用</li><li>分析上面的实现过程，会发现添加初始化和销毁方法，即需要编码也需要配置，实现起来步骤比较多也比较乱。</li><li>Spring给我们提供了两个接口来完成生命周期的控制，好处是可以不用再进行配置<code>init-method</code>和<code>destroy-method</code></li></ul><p>接下来在BookServiceImpl完成这两个接口的使用</p><ul><li><p>修改BookServiceImpl类，添加两个接口<code>InitializingBean</code>， <code>DisposableBean</code>并实现接口中的两个方法<code>afterPropertiesSet</code>和<code>destroy</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class BookServiceImpl implements BookService, InitializingBean, DisposableBean &#123;</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBookDao(BookDao bookDao) &#123;</span><br><span class="line">        System.out.println(&quot;set ... &quot;);</span><br><span class="line">        this.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void destroy() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;service destroy ... &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;service init ... &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>BookServiceImpl的bean配置如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bookService&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>重新运行App类</p></li></ul><p>小细节</p><ul><li><p>对于InitializingBean接口中的afterPropertiesSet方法，翻译过来为<code>属性设置之后</code>。</p></li><li><p>对于BookServiceImpl来说，bookDao是它的一个属性</p></li><li><p>setBookDao方法是Spring的IOC容器为其注入属性的方法</p></li><li><p>思考:afterPropertiesSet和setBookDao谁先执行?</p><ul><li><p>从方法名分析，猜想应该是setBookDao方法先执行</p></li><li><p>验证思路，在setBookDao方法中添加一局输出语句，看看谁先输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void setBookDao(BookDao bookDao) &#123;</span><br><span class="line">    System.out.println(&quot;set ... &quot;);</span><br><span class="line">    this.bookDao = bookDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重新运行</p></li></ul></li></ul><h3 id="bean生命周期小结"><a href="#bean生命周期小结" class="headerlink" title="bean生命周期小结"></a>bean生命周期小结</h3><ol><li>关于Spring中对bean生命周期控制提供了两种方式:<ul><li>在配置文件中的bean标签中添加<code>init-method</code>和<code>destroy-method</code>属性</li><li>类实现<code>InitializingBean</code>与<code>DisposableBean</code>接口</li></ul></li><li>对于bean的生命周期控制在bean的整个生命周期中所处的位置如下<ul><li>初始化容器<ul><li>1.创建对象(内存分配)</li><li>2.执行构造方法</li><li>3.执行属性注入(set操作)（<code>set ...</code>）</li><li>4.执行bean初始化方法（<code>service init ...</code>）</li></ul></li><li>使用bean<ul><li>执行业务操作（<code>book dao save ...</code>）</li></ul></li><li>关闭&#x2F;销毁容器<ul><li>执行bean销毁方法（<code>service destroy ...</code>）</li></ul></li></ul></li><li>关闭容器的两种方式:<ul><li>ConfigurableApplicationContext是ApplicationContext的子类，子类才有下面两种方法<ul><li>close()方法</li><li>registerShutdownHook()方法</li></ul></li></ul></li></ol><h1 id="DI相关内容"><a href="#DI相关内容" class="headerlink" title="DI相关内容"></a>DI相关内容</h1><p>向一个类中传递数据的方式有几种?</p><ul><li>普通方法(set方法)</li><li>构造方法</li></ul><p>依赖注入描述了在容器中建立bean与bean之间的依赖关系的过程，如果bean运行需要的是数字或字符串呢?</p><ul><li>引用类型</li><li>简单类型(基本数据类型与String)</li></ul><p>Spring就是基于上面这些知识点，为我们提供了两种注入方式，分别是：</p><ul><li>&#96;&#96;&#96;<br>setter注入<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 简单类型</span><br><span class="line">  - 引用类型</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  构造器注入</span><br></pre></td></tr></table></figure><ul><li>简单类型</li><li>引用类型</li></ul></li></ul><h2 id="setter注入"><a href="#setter注入" class="headerlink" title="setter注入"></a>setter注入</h2><p>对于setter方式注入引用类型的方式之前已经学习过，快速回顾下：</p><ul><li><p>在bean中定义引用类型属性，并提供可访问的set方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class BookServiceImpl implements BookService &#123;</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line">    public void setBookDao(BookDao bookDao) &#123;</span><br><span class="line">        this.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置中使用property标签ref属性注入引用类型对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bookService&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>我们再来回顾一下配置中的两个bookDao的含义</p><p>配置中的两个bookDao的含义是不一样的</p><ul><li>name&#x3D;”bookDao”中bookDao的作用是让Spring的IOC容器在获取到名称后，将首字母大写，前面加set找对应的setBookDao()方法进行对象注入</li><li>ref&#x3D;”bookDao”中bookDao的作用是让Spring能在IOC容器中找到id为bookDao的Bean对象给bookService进行注入</li></ul></li></ul><h2 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ul><li><p>修改BookDao、BookDaoImpl、UserDao、UserDaoImpl、BookService和BookServiceImpl类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface BookDao &#123;</span><br><span class="line">    public void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line">    </span><br><span class="line">    private String databaseName;</span><br><span class="line">    private int connectionNum;</span><br><span class="line">    </span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface UserDao &#123;</span><br><span class="line">    public void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class UserDaoImpl implements UserDao &#123;</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;user dao save ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface BookService &#123;</span><br><span class="line">    public void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class BookServiceImpl implements BookService&#123;</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    public void setBookDao(BookDao bookDao) &#123;</span><br><span class="line">        this.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;bookService&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><ul><li>运行类</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main( String[] args ) &#123;</span><br><span class="line">        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        BookService bookService = (BookService) ctx.getBean(&quot;bookService&quot;);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="构造器注入引用数据类型"><a href="#构造器注入引用数据类型" class="headerlink" title="构造器注入引用数据类型"></a>构造器注入引用数据类型</h3><p>接下来，在上面这个环境中来完成构造器注入：</p><p>将BookServiceImpl类中的bookDao修改成使用构造器的方式注入。</p><ol><li>将bookDao的setter方法删除掉</li><li>添加带有bookDao参数的构造方法</li><li>在applicationContext.xml中配置</li></ol><ul><li><p><code>步骤一：</code>删除setter方法并提供构造方法<br>在BookServiceImpl类中将bookDao的setter方法删除掉,并添加带有bookDao参数的构造方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class BookServiceImpl implements BookService&#123;</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    public BookServiceImpl(BookDao bookDao) &#123;</span><br><span class="line">        this.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>步骤二：</code>配置文件中进行配置构造方式注入<br>在applicationContext.xml中配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;bookService&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot;&gt;</span><br><span class="line">        &lt;constructor-arg name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>说明：在标签<code>&lt;constructor-arg&gt;</code>中</p><ul><li>name属性对应的值为构造函数中方法<code>形参的参数名</code>，必须要保持一致。</li><li>ref属性指向的是spring的IOC容器中其他bean对象。</li></ul></li><li><p><code>步骤三：</code>运行程序</p></li></ul><h3 id="构造器注入多个引用数据类型"><a href="#构造器注入多个引用数据类型" class="headerlink" title="构造器注入多个引用数据类型"></a>构造器注入多个引用数据类型</h3><p>需求：在BookServiceImpl使用构造函数注入多个引用数据类型，比如userDao</p><ol><li>声明userDao属性</li><li>生成一个带有bookDao和userDao参数的构造函数</li><li>在applicationContext.xml中配置注入</li></ol><ul><li><p><code>步骤一：</code>提供多个属性的构造函数<br>在BookServiceImpl声明userDao并提供多个参数的构造函数，save方法中记得调用userDao.save()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class BookServiceImpl implements BookService &#123;</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line">    private UserDao userDao;</span><br><span class="line"></span><br><span class="line">    public BookServiceImpl(BookDao bookDao, UserDao userDao) &#123;</span><br><span class="line">        this.bookDao = bookDao;</span><br><span class="line">        this.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>步骤二：</code>在配置文件中配置多参数注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">XML</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;userDao&quot; class=&quot;com.blog.dao.impl.UserDaoImpl&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;bookService&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot;&gt;</span><br><span class="line">        &lt;constructor-arg name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;</span><br><span class="line">        &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>步骤三：</code>运行程序</p></li></ul><h3 id="构造器注入多个简单数据类型"><a href="#构造器注入多个简单数据类型" class="headerlink" title="构造器注入多个简单数据类型"></a>构造器注入多个简单数据类型</h3><p>需求：在BookDaoImpl中，使用构造函数注入databaseName和connectionNum两个参数。<br>参考引用数据类型的注入，我们可以推出具体的步骤为：</p><ol><li>提供一个包含这两个参数的构造方法</li><li>在applicationContext.xml中进行注入配置</li></ol><ul><li><p><code>步骤一：</code>添加多个简单属性并提供构造方法<br>修改BookDaoImpl类，添加构造方法，同时在save()方法中输出这两个属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line"></span><br><span class="line">    private String databaseName;</span><br><span class="line">    private int connectionNum;</span><br><span class="line"></span><br><span class="line">    public BookDaoImpl(String databaseName, int connectionNum) &#123;</span><br><span class="line">        this.databaseName = databaseName;</span><br><span class="line">        this.connectionNum = connectionNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot; + databaseName + &quot;,&quot; + connectionNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>步骤二：</code>配置完成多个属性构造器注入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;userDao&quot; class=&quot;com.blog.dao.impl.UserDaoImpl&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;&gt;</span><br><span class="line">        &lt;constructor-arg name=&quot;databaseName&quot; value=&quot;mysql&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">        &lt;constructor-arg name=&quot;connectionNum&quot; value=&quot;100&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;bean id=&quot;bookService&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot;&gt;</span><br><span class="line">        &lt;constructor-arg name=&quot;bookDao&quot; ref=&quot;bookDao&quot;/&gt;</span><br><span class="line">        &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>步骤三：</code>运行程序</p></li></ul><h3 id="目前存在的问题"><a href="#目前存在的问题" class="headerlink" title="目前存在的问题"></a>目前存在的问题</h3><ul><li><p><code>&lt;constructor-arg&gt;</code>标签内的name，必须与构造函数中的参数名一致，这两块存在紧耦合。</p></li><li><p>那么我们怎么解决这个问题呢？</p></li><li><p>在解决这个问题之前，需要提前说明的是，这个参数名发生变化的情况并不多，所以上面的还是比较主流的配置方式，下面介绍的，我们以了解为主。</p></li><li><p>方式一：删除name属性，添加type属性，按照类型注入</p><ul><li><p>这种方式可以解决构造函数形参名发生变化带来的耦合问题</p></li><li><p>但是如果构造方法参数中有类型相同的参数，这种方式就不太好实现了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;&gt;</span><br><span class="line">    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;mysql&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;constructor-arg type=&quot;int&quot; value=&quot;9421&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>方式二：删除type属性，添加index属性，按照索引下标注入，下标从0开始</p><ul><li><p>这种方式可以解决参数类型重复问题</p></li><li><p>但是如果构造方法参数顺序发生变化后，这种方式又带来了耦合问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;&gt;</span><br><span class="line">    &lt;constructor-arg index=&quot;0&quot; value=&quot;mysql&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;constructor-arg index=&quot;1&quot; value=&quot;9421&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>介绍完两种参数的注入方式，具体我们该如何选择呢?</p><ol><li>强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现<ul><li>强制依赖指对象在创建的过程中必须要注入指定的参数</li></ul></li><li>可选依赖使用setter注入进行，灵活性强<ul><li>可选依赖指对象在创建过程中注入的参数可有可无</li></ul></li><li>Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨</li><li>如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入</li><li>实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入</li><li>自己开发的模块推荐使用setter注入</li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>这部分主要讲解的是Spring的依赖注入的实现方式:</p><ul><li><p>setter注入</p><ul><li><p>简单数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean ...&gt;</span><br><span class="line">    &lt;property name=&quot;&quot; value=&quot;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>引用数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean ...&gt;</span><br><span class="line">    &lt;property name=&quot;&quot; ref=&quot;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>构造器注入</p><ul><li><p>简单数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean ...&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;&quot; index=&quot;&quot; type=&quot;&quot; value=&quot;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>引用数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean ...&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;&quot; index=&quot;&quot; type=&quot;&quot; ref=&quot;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>依赖注入的方式选择上</p><ul><li>建议使用setter注入</li><li>第三方技术根据情况选择</li></ul></li></ul><h2 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h2><p>前面花了大量的时间把Spring的注入去学习了下，总结起来就两个字<code>麻烦</code>。</p><ul><li>问:麻烦在哪?<ul><li>答:配置文件的编写配置上。</li></ul></li><li>问:有更简单方式么?<ul><li>答:有，自动配置</li></ul></li></ul><p>所以什么是自动配置以及如何实现自动配置，就是接下来要学习的内容</p><h3 id="什么是依赖自动装配？"><a href="#什么是依赖自动装配？" class="headerlink" title="什么是依赖自动装配？"></a>什么是依赖自动装配？</h3><p>IOC容器根据bean所依赖的资源在容器中<code>自动查找并注入</code>到bean中的过程称为自动装配</p><h3 id="自动装配方式有哪些？"><a href="#自动装配方式有哪些？" class="headerlink" title="自动装配方式有哪些？"></a>自动装配方式有哪些？</h3><ul><li>按类型（常用）</li><li>按名称</li><li>按构造方法</li><li>不启用自动装配</li></ul><h3 id="完成自动装配的配置"><a href="#完成自动装配的配置" class="headerlink" title="完成自动装配的配置"></a>完成自动装配的配置</h3><p>自动装配只需要修改applicationContext.xml配置文件即可:</p><ol><li><p>将<code>&lt;property&gt;</code>标签删除</p></li><li><p>在<code>&lt;bean&gt;</code>标签中添加autowire属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--    &lt;bean id=&quot;bookDao&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;/&gt;--&gt;</span><br><span class="line">&lt;!--    既然是按类型注入了，那么id写不写都无所谓了--&gt;</span><br><span class="line">    &lt;bean class=&quot;com.blog.dao.impl.BookDaoImpl&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;bookService&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot; autowire=&quot;byType&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></li></ol><p>注意事项：</p><ul><li>需要注入属性的类中对应属性的<code>setter</code>方法不能省略</li><li>被注入的对象必须要被Spring的IOC容器管理</li><li>按照类型在Spring的IOC容器中如果找到多个对象，会报<code>NoUniqueBeanDefinitionException</code></li></ul><p>当一个类型在IOC中有多个对象，还想要注入成功，这个时候就需要按照名称注入，配置方式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--这里就有两个同一类型的bean，但是id不一样--&gt;</span><br><span class="line">    &lt;bean id=&quot;bookDao1&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;bookDao2&quot; class=&quot;com.blog.dao.impl.BookDaoImpl&quot;/&gt;</span><br><span class="line">    &lt;bean class=&quot;com.blog.dao.impl.BookDaoImpl&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;bookService&quot; class=&quot;com.blog.service.impl.BookServiceImpl&quot; autowire=&quot;byName&quot;/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>同时修改BookServiceImpl类汇总的<code>setBookDao</code>方法，将其重命名为<code>setBookDao1</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao1</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>疑惑：为什么刚刚修改的是setBookDao的方法名，而不是将bookDao属性修改为bookDao1呢？按照名称注入中的名称指的是什么?</p></blockquote><blockquote><p>解惑：</p><ul><li>因为bookDao是private修饰的，外部类无法直接访问</li><li>所以外部类只能通过属性的set方法进行访问</li><li>对外部类来说，setBookDao方法名，去掉set后首字母小写是其属性名<ul><li>为什么是去掉set首字母小写?</li><li>这个规则是set方法生成的<code>默认规则</code>，set方法的生成是把属性名首字母大写前面加set形成的方法名</li></ul></li><li>所以按照名称注入，其实是和对应的set方法有关，但是如果按照标准起名称，属性名和set对应的名是一致的</li></ul></blockquote><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul><li>如果按照名称去找对应的bean对象，找不到则注入Null</li><li>当某一个类型在IOC容器中有多个对象，按照名称注入只找其指定名称对应的bean对象，不会报错</li><li>两种方式介绍完后，以后用的更多的是<code>按照类型</code>注入。</li><li>最后对于依赖注入，需要注意一些其他的配置特征:<ol><li>自动装配用于引用类型依赖注入，不能对简单类型进行操作</li><li>使用按类型装配时（byType）必须保障容器中相同类型的bean唯一，推荐使用</li><li>使用按名称装配时（byName）必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用</li><li>自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效</li></ol></li></ul><h2 id="集合注入"><a href="#集合注入" class="headerlink" title="集合注入"></a>集合注入</h2><p>前面我们已经能完成引入数据类型和简单数据类型的注入，但是还有一种数据类型<code>集合</code>，集合中既可以装简单数据类型也可以装引用数据类型，对于集合，在Spring中该如何注入呢?</p><p>先来回顾下，常见的集合类型有哪些?</p><ul><li>数组</li><li>List</li><li>Set</li><li>Map</li><li>Properties</li></ul><h3 id="注入数组类型"><a href="#注入数组类型" class="headerlink" title="注入数组类型"></a>注入数组类型</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;array&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>100<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>200<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>300<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="注入List类型"><a href="#注入List类型" class="headerlink" title="注入List类型"></a>注入List类型</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>ABC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>123<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="注入Set类型"><a href="#注入Set类型" class="headerlink" title="注入Set类型"></a>注入Set类型</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;set&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>100<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>200<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>ABC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>ABC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="注入Map类型"><a href="#注入Map类型" class="headerlink" title="注入Map类型"></a>注入Map类型</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;探路者&quot;</span> <span class="attr">value</span>=<span class="string">&quot;马文&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;次元游记兵&quot;</span> <span class="attr">value</span>=<span class="string">&quot;恶灵&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;易位窃贼&quot;</span> <span class="attr">value</span>=<span class="string">&quot;罗芭&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="注入Properties类型"><a href="#注入Properties类型" class="headerlink" title="注入Properties类型"></a>注入Properties类型</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;暴雷&quot;</span>&gt;</span>沃尔特·菲茨罗伊<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;寻血猎犬&quot;</span>&gt;</span>布洛特·亨德尔<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;命脉&quot;</span>&gt;</span>阿杰·切<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>property标签表示setter方式注入，构造方式注入constructor-arg标签内部也可以写<code>&lt;array&gt;</code>、<code>&lt;list&gt;</code>、<code>&lt;set&gt;</code>、<code>&lt;map&gt;</code>、<code>&lt;props&gt;</code>标签</li><li>List的底层也是通过数组实现的，所以<code>&lt;list&gt;</code>和<code>&lt;array&gt;</code>标签是可以混用</li><li>集合中要添加引用类型，只需要把<code>&lt;value&gt;</code>标签改成<code>&lt;ref&gt;</code>标签，这种方式用的比较少</li></ul><h1 id="核心容器"><a href="#核心容器" class="headerlink" title="核心容器"></a>核心容器</h1><p>前面已经完成bean与依赖注入的相关知识学习，接下来我们主要学习的是IOC容器中的<code>核心容器</code>。</p><p>这里所说的核心容器，我们可以把它简单的理解为<code>ApplicationContext</code>，前面虽然已经用到过，但是并没有系统的学习，接下来我们从以下几个问题入手来学习下容器的相关知识:</p><ul><li>如何创建容器?</li><li>创建好容器后，如何从容器中获取bean对象?</li><li>容器类的层次结构是什么?</li><li>BeanFactory是什么?</li></ul><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="容器的创建方式"><a href="#容器的创建方式" class="headerlink" title="容器的创建方式"></a>容器的创建方式</h3><ul><li>案例中创建<code>ApplicationContext</code>的方式如下</li><li>这种方式翻译为：类路径下的XML配置文件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>除了上面这种方式，Spring还提供了另外一种创建方式</li><li>这种方式翻译为：文件系统下的XML配置文件，路径需要写绝对路径</li><li>这种方式虽能实现，但是当项目的位置发生变化后，代码也需要跟着改，耦合度高，不推荐使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(<span class="string">&quot;D:\xxx/xxx\applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="获取bean的三种方式"><a href="#获取bean的三种方式" class="headerlink" title="获取bean的三种方式"></a>获取bean的三种方式</h3><ul><li><p>方式一，就是我们之前用的方式</p></li><li><p>这种方式存在的问题是每次获取的时候都需要进行类型转换，有没有更简单的方式呢?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>方式二<br>这种方式可以解决类型强转问题，但是参数又多加了一个，相对来说没有简化多少。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> ctx.getBean(<span class="string">&quot;bookDao&quot;</span>，BookDao.class);</span><br></pre></td></tr></table></figure></li><li><p>方式三</p></li><li><p>这种方式就类似我们之前所学习依赖注入中的按类型注入。必须要确保IOC容器中该类型对应的bean对象只能有一个。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BookDao bookDao = ctx.getBean(BookDao.class);</span><br></pre></td></tr></table></figure></li></ul><h3 id="BeanFactory的使用"><a href="#BeanFactory的使用" class="headerlink" title="BeanFactory的使用"></a>BeanFactory的使用</h3><p>容器的最上级的父接口为<code>BeanFactory</code>，使用<code>BeanFactory</code>也可以创建IOC容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForBeanFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Resource</span> <span class="variable">resources</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BeanFactory</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanFactory</span>(resources);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> bf.getBean(BookDao.class);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了更好的看出<code>BeanFactory</code>和<code>ApplicationContext</code>之间的区别，在BookDaoImpl添加如下构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookDaoImpl</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不去获取bean对象，打印会发现：</p><ul><li>BeanFactory是延迟加载，只有在获取bean对象的时候才会去创建</li><li>ApplicationContext是立即加载，容器加载的时候就会创建bean对象</li><li>ApplicationContext要想成为延迟加载，只需要将lazy-init设为true</li></ul><h2 id="核心容器总结"><a href="#核心容器总结" class="headerlink" title="核心容器总结"></a>核心容器总结</h2><h3 id="容器相关"><a href="#容器相关" class="headerlink" title="容器相关"></a>容器相关</h3><ul><li>BeanFactory是IoC容器的顶层接口，初始化BeanFactory对象时，加载的bean延迟加载</li><li>ApplicationContext接口是Spring容器的核心接口，初始化时bean立即加载</li><li>ApplicationContext接口提供基础的bean操作相关方法，通过其他接口扩展其功能</li><li>ApplicationContext接口常用初始化类<ul><li>ClassPathXmlApplicationContext(常用)</li><li>FileSystemXmlApplicationContext</li></ul></li></ul><h3 id="bean相关"><a href="#bean相关" class="headerlink" title="bean相关"></a>bean相关</h3><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/631070e616f2c2beb1536517.jpg"></p><h3 id="依赖注入相关"><a href="#依赖注入相关" class="headerlink" title="依赖注入相关"></a>依赖注入相关</h3><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/631070f716f2c2beb1536fa3.jpg"></p><h1 id="IOC-x2F-DI注解开发"><a href="#IOC-x2F-DI注解开发" class="headerlink" title="IOC&#x2F;DI注解开发"></a>IOC&#x2F;DI注解开发</h1><p>Spring的IOC&#x2F;DI对应的配置开发就已经讲解完成，但是使用起来相对来说还是比较复杂的，复杂的地方在<code>配置文件</code>。<br>Spring到底是如何简化代码开发的呢?<br>要想真正简化开发，就需要用到Spring的注解开发，Spring对注解支持的版本历程:</p><ul><li>2.0版开始支持注解</li><li>2.5版注解功能趋于完善</li><li>3.0版支持纯注解开发</li></ul><p>关于注解开发，这里会讲解两块内容<code>注解开发定义bean</code>和<code>纯注解开发</code>。<br>注解开发定义bean用的是2.5版提供的注解，纯注解开发用的是3.0版提供的注解。</p><p><code>步骤一：</code>删除原有的XML配置<br>将配置文件中的bean标签删除掉</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><code>步骤二：</code>在Dao上添加注解<br>在BookDaoImpl类上添加<code>@Component</code>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;bookDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：@Component注解不可以添加在接口上，因为接口是无法创建对象的。</p></blockquote><p><code>步骤三：</code>配置Spring的注解包扫描<br>为了让Spring框架能够扫描到写在类上的注解，需要在配置文件上进行包扫描</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">            http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        &quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.blog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>说明：component-scan<ul><li>component:组件,Spring将管理的bean视作自己的一个组件</li><li>scan:扫描<br>base-package指定Spring框架扫描的包路径，它会扫描指定包及其子包中的所有类上的注解。</li><li>包路径越多<code>如:com.blog.dao.impl</code>，扫描的范围越小速度越快</li><li>包路径越少<code>如:com.blog</code>,扫描的范围越大速度越慢</li><li>一般扫描到项目的组织名称即Maven的groupId下<code>如:com.blog</code>即可。</li></ul></li></ul><p><code>步骤四：</code>运行程序</p><p><code>步骤五：</code>Service上添加注解<br>在BookServiceImpl类上也添加<code>@Component</code>交给Spring框架管理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>步骤六：</code>运行程序<br>在App类中，从IOC容器中获取BookServiceImpl对应的bean对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//按照名称获取bean</span></span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) context.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        <span class="comment">//按照类型获取bean</span></span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> context.getBean(BookService.class);</span><br><span class="line">        bookDao.save();</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li><p>BookServiceImpl类没有起名称，所以在App中是按照类型来获取bean对象</p></li><li><p><code>@Component</code>注解如果不起名称，会有一个默认值就是<code>当前类名首字母小写</code>，所以也可以按照名称获取，如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BookService bookService = (BookService) context.getBean(&quot;bookServiceImpl&quot;);</span><br></pre></td></tr></table></figure></li></ul><p>对于@Component注解，还衍生出了其他三个注解<code>@Controller</code>、<code>@Service</code>、<code>@Repository</code><br>这三个注解和@Component注解的作用是一样的，这是方便我们后期在编写类的时候能很好的区分出这个类是属于<code>表现层</code>、<code>业务层</code>还是<code>数据层</code>的类。</p><h2 id="纯注解开发模式"><a href="#纯注解开发模式" class="headerlink" title="纯注解开发模式"></a>纯注解开发模式</h2><p>上面已经可以使用注解来配置bean,但是依然有用到配置文件，在配置文件中对包进行了扫描，Spring在3.0版已经支持纯注解开发，使用Java类替代配置文件</p><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>实现思路为：将配置文件applicationContext.xml删掉，用类来替换</p><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ul><li><p><code>步骤一：</code>创建配置类<br>创建一个配置类SpringConfig</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class SpringConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>步骤二：<code>标识该类为配置类  在配置类上面加一个</code>@Configuration<code>注解，将其标识为一个配置类，用于替换掉</code>applicationContext.XML</p></li></ul> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SpringConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>步骤三：<code>用注解替换包扫描配置 在配置类上添加包扫描注解</code>@ComponentScan<code>替换</code>&lt;context:component-scan base-package&#x3D;””&#x2F;&gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.blog&quot;)</span><br><span class="line">public class SpringConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>步骤四：<code>创建运行类并执行 创建一个新的运行类</code>AppForAnnotation</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  public class AppForAnnotation &#123;</span><br><span class="line">      public static void main(String[] args) &#123;</span><br><span class="line">          AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);</span><br><span class="line">          BookDao bookDao = (BookDao) context.getBean(&quot;bookDao&quot;);</span><br><span class="line">          bookDao.save();</span><br><span class="line">          BookService bookService = context.getBean(BookService.class);</span><br><span class="line">          bookService.save();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">运行AppForAnnotation,可以看到两个对象依然被获取成功</span><br><span class="line"></span><br><span class="line">至此，纯注解开发的方式就已经完成了，主要内容包括：</span><br><span class="line"></span><br><span class="line">- Java类替换Spring核心配置文件</span><br><span class="line"></span><br><span class="line">  - `@Configuration`注解用于设定当前类为配置类</span><br><span class="line"></span><br><span class="line">  - `@ComponentScan`注解用于设定扫描路径，此注解只能添加一次，多个数据请用数组格式</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  @ComponentScan({com.blog.service”,”com.blog.dao”})</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 读取Spring核心配置文件初始化容器对象切换为读取Java配置类初始化容器对象</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  AnnotationConfigApplicationContext context &#x3D; new AnnotationConfigApplicationContext(SpringConfig.class);<br>  &#96;&#96;&#96;</p></li></ul><ul><li>知识点：<code>@Configuration</code></li></ul><table><thead><tr><th align="center">名称</th><th align="center">@Configuration</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">类注解</td></tr><tr><td align="center">位置</td><td align="center">类定义上方</td></tr><tr><td align="center">作用</td><td align="center">设置该类为spring配置类</td></tr><tr><td align="center">属性</td><td align="center">value（默认）：定义bean的id</td></tr></tbody></table><ul><li>知识点：<code>@ComponentScan</code></li></ul><table><thead><tr><th align="center">名称</th><th align="center">@ComponentScan</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">类注解</td></tr><tr><td align="center">位置</td><td align="center">类定义上方</td></tr><tr><td align="center">作用</td><td align="center">设置spring配置类扫描路径，用于加载使用注解格式定义的bean</td></tr><tr><td align="center">属性</td><td align="center">value（默认）：扫描路径，此路径可以逐层向下扫描</td></tr></tbody></table><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>这部分要重点掌握的是使用注解完成Spring的bean管理，需要掌握的内容为:</p><ul><li>记住<code>@Component</code>、<code>@Controller</code>、<code>@Service</code>、<code>@Repository</code>这四个注解</li><li>applicationContext.xml中<code>&lt;context:component-san/&gt;</code>的作用是指定扫描包路径，注解为<code>@ComponentScan</code></li><li><code>@Configuration</code>标识该类为配置类，使用类替换<code>applicationContext.xml</code>文件</li><li><code>ClassPathXmlApplicationContext</code>是加载XML配置文件</li><li><code>AnnotationConfigApplicationContext</code>是加载配置类</li></ul><h2 id="注解开发bean的作用范围和生命周期"><a href="#注解开发bean的作用范围和生命周期" class="headerlink" title="注解开发bean的作用范围和生命周期"></a>注解开发bean的作用范围和生命周期</h2><p>使用注解已经完成了bean的管理，接下来按照前面所学习的内容，将通过配置实现的内容都换成对应的注解实现，包含两部分内容:<code>bean作用范围(scope)</code>和<code>bean生命周期(init和destroy)</code>。</p><h3 id="bean的作用范围"><a href="#bean的作用范围" class="headerlink" title="bean的作用范围"></a>bean的作用范围</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM内存结构</title>
      <link href="/2023/09/12/JVM.%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
      <url>/2023/09/12/JVM.%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p>Java Virtual Machine ，Java 程序的<strong>运行环境</strong>（Java 二进制字节码的运行环境）</p><p>JVM好处</p><ul><li>一次编译，处处执行</li><li>自动的内存管理，垃圾回收机制</li><li>数组下标越界检查</li></ul><p>JVM、JRE、JDK 的关系如下图所示</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309122015679.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309122016720.png"></p><p>ClassLoader：Java 代码编译成二进制后，会经过类加载器，这样才能加载到 JVM 中运行。<br>Method Area：类是放在方法区中。<br>Heap：类的实例对象。<br>当类调用方法时，会用到 JVM Stack、PC Register、本地方法栈。<br>方法执行时的每行代码是有执行引擎中的解释器逐行执行，方法中的热点代码频繁调用的方法，由 JIT 编译器优化后执行，GC 会对堆中不用的对象进行回收。需要和操作系统打交道就需要使用到本地方法接口</p><h1 id="程序计数器（PC）"><a href="#程序计数器（PC）" class="headerlink" title="程序计数器（PC）"></a>程序计数器（PC）</h1><p>Program Counter Register 程序计数器（寄存器）</p><p>定义：</p><ul><li>JVM中的程序计数器(Program Counter Register)是一块较小的内存空间，它用来保存当前线程下一条要执行的指令的地址。每个线程都有自己独立的程序计数器，它是线程私有的，生命周期与线程相同。程序计数器是JVM中的一种轻量级的内存区域，因为它不会发生内存溢出（OutOfMemoryError）的情况。</li><li>程序计数器也是唯一一个在Java虚拟机规范中没有规定任何<code>OutOfMemoryError（内存溢出）</code>情况的区域。因为程序计数器是线程私有的，所以它所占用的内存空间非常小，一般不会导致内存溢出的问题。</li></ul><p>作用：</p><ul><li><p>是记录下一条 jvm 指令的执行地址行号。（下一条指令一定由PC指出）</p><blockquote><p>因为在Java虚拟机的多线程环境下，为了支持线程切换后能够恢复到正确的执行位置，每个线程都需要有一个独立的程序计数器，否则就会出现线程切换后执行位置混乱的问题。</p></blockquote></li></ul><p>特点：</p><ul><li><p>是线程私有的</p></li><li><p>不会存在内存溢出</p></li><li><p>Java源代码首先编译成二进制字节码，然后交由解释器解释成机器码，最终由CPU执行机器码</p><ul><li>程序计数器在其中的作用就是记住下一条JVM指令的执行地址，解释器从程序计数器取到下一条指令地址</li></ul></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>程序计数器</p><ul><li>作用：保存当前线程下一条要执行的指令的地址</li><li>特点：<ul><li>线程私有</li><li>不存在内存溢出</li></ul></li></ul><h1 id="虚拟机栈（Stack）"><a href="#虚拟机栈（Stack）" class="headerlink" title="虚拟机栈（Stack）"></a>虚拟机栈（Stack）</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>Java虚拟机栈（Java Virtual Machine Stacks）是Java虚拟机为每个线程分配的一块内存区域，用于存储线程的方法调用和局部变量等信息。</li><li>每个线程在运行时都有自己的Java虚拟机栈，线程开始时会创建一个新的栈帧（Stack Frame），用于存储该线程的方法调用信息。当方法调用完成后，该栈帧会被弹出，回到上一次方法调用的位置。每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法。</li></ul><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>Java虚拟机栈</p><ol><li>每个线程运行是所需的内存，就称为虚拟机栈</li><li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时占用的内存</li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li></ol><div class="tabs" id="问题1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#问题1-1">问题1 1</button></li><li class="tab"><button type="button" data-href="#问题1-2">问题1 2</button></li><li class="tab"><button type="button" data-href="#问题1-3">问题1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="问题1-1"><p>垃圾回收是否涉及栈内存？</p><p>垃圾回收通常不涉及栈内存。栈内存是在程序运行时自动分配和释放的，因此不需要垃圾回收来处理。相反，垃圾回收主要关注堆内存中的对象，以及这些对象是否还在被引用。垃圾回收器通常会扫描堆内存中的对象，并标记哪些对象仍然被引用，哪些对象可以被清理。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="问题1-2"><p>栈内存分配越大越好吗？</p><ul><li>栈内存的分配大小应该根据实际需要来确定。栈内存的分配是由操作系统负责的。栈内存划的越大，会让线程数变少，因为物理内存大小是一定的。栈内存划分大了，通常只是能够进行更多次的方法递归调用，而不会增强运行效率，反而会使线程数量变少，一般采用系统默认的栈内存就好</li></ul><ul><li>栈内存的分配大小应该根据实际需要来确定。栈内存的分配是由操作系统负责的<ul><li>Linux&#x2F;x64（64 位）：1024 KB</li><li>macOS（64 位）：1024 KB</li><li>Oracle Solaris&#x2F;x64（64 位）：1024 KB</li><li>Windows：默认值取决于虚拟内存</li></ul></li><li>当然我们也可以手动设置线程堆栈大小为1024kb</li></ul><blockquote><p>K M G T 在这里都是能直接用的</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Xss1m</span><br><span class="line">-Xss1024k</span><br><span class="line">-Xss1048576</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="问题1-3"><p>方法内的局部变量是否线程安全？</p><p>方法内的局部变量通常是线程安全的，因为它们只能在方法内部访问。每个线程都有自己的栈帧，栈帧包含方法的参数、局部变量和返回值等信息，因此不同的线程可以在不相互干扰的情况下同时访问相同的方法。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="栈内存溢出"><a href="#栈内存溢出" class="headerlink" title="栈内存溢出"></a>栈内存溢出</h2><p>栈内存溢出有两种情况</p><ol><li><p>栈帧过多导致栈内存溢出</p><ul><li>死循环递归</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    static int count = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            method();</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void method() &#123;</span><br><span class="line">        count++;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>栈帧过多导致栈内存溢出</p><ul><li>下面这个例子中，Emp中引入了Dept，而Dept中又引入了Emp，他们现在在循环引用，导致json解析时会出现StackOverFlow</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import com.fasterxml.jackson.annotation.JsonIgnore;</span><br><span class="line">import com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line">import com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Demo_03 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws JsonProcessingException &#123;</span><br><span class="line">        Dept d = new Dept();</span><br><span class="line">        d.setName(&quot;Market&quot;);</span><br><span class="line"></span><br><span class="line">        Emp e1 = new Emp();</span><br><span class="line">        e1.setName(&quot;zhang&quot;);</span><br><span class="line">        e1.setDept(d);</span><br><span class="line"></span><br><span class="line">        Emp e2 = new Emp();</span><br><span class="line">        e2.setName(&quot;li&quot;);</span><br><span class="line">        e2.setDept(d);</span><br><span class="line"></span><br><span class="line">        d.setEmps(Arrays.asList(e1, e2));</span><br><span class="line"></span><br><span class="line">        // &#123; name: &#x27;Market&#x27;, emps: [&#123; name:&#x27;zhang&#x27;, dept:&#123; name:&#x27;&#x27;, emps: [ &#123;&#125;]&#125; &#125;,] &#125;</span><br><span class="line">        ObjectMapper mapper = new ObjectMapper();</span><br><span class="line">        System.out.println(mapper.writeValueAsString(d));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Emp &#123;</span><br><span class="line">    private String name;</span><br><span class="line">//    @JsonIgnore</span><br><span class="line">    private Dept dept;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Dept getDept() &#123;</span><br><span class="line">        return dept;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDept(Dept dept) &#123;</span><br><span class="line">        this.dept = dept;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dept &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private List&lt;Emp&gt; emps;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;Emp&gt; getEmps() &#123;</span><br><span class="line">        return emps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setEmps(List&lt;Emp&gt; emps) &#123;</span><br><span class="line">        this.emps = emps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><ul><li>本地方法<ul><li><code>本地方法</code>是指由非Java语言编写的代码，如C或C++，并被编译为本地二进制代码。</li></ul></li><li>因为<code>JAVA</code>没法直接和操作系统底层交互，所以需要用到本地方法栈来调用本地的C或C++的方法</li><li>例如Object类的源码中就有本地方法，用<strong>native</strong>关键字修饰本地方法<ul><li>本地方法只有函数声明，没有函数体，因为函数体是C或C++写的，通常是通过JNI（Java Native Interface）技术来实现的。</li></ul></li></ul><h1 id="堆-heap"><a href="#堆-heap" class="headerlink" title="堆(heap)"></a>堆(heap)</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><ul><li>JVM的堆（Heap）是Java虚拟机（JVM）在内存中用来存放对象的区域，是Java程序中最大的一块内存区域。JVM的堆被所有线程共享，在JVM启动时就已经被创建，并且一直存在于JVM的整个生命周期中。</li><li>堆可以被分成两部分：新生代（Young Generation）和老年代（Old Generation）。新生代又被进一步分为Eden空间、幸存区From空间和幸存区To空间。</li><li>新生代是用来存放新创建的对象的，其中大部分对象都很快就会被垃圾回收掉。当堆空间不足时，JVM会触发垃圾回收机制（GC），对新生代的对象进行清理。清理过程一般是将存活的对象移到老年代或幸存区，而其余的对象则被回收。</li><li>老年代是用来存放生命周期较长的对象的，这些对象一般是从新生代晋升而来，或者是本身就比较大的对象。老年代的对象存活时间较长，因此垃圾回收的频率比新生代低得多。</li><li>JVM堆的大小可以通过启动JVM时的参数进行调整，如-Xms和-Xmx参数分别控制堆的初始大小和最大大小。如果应用程序需要创建大量的对象，而堆空间不足，则会抛出OutOfMemoryError异常。</li></ul><p>特点：</p><ul><li><p>通过new关键字创建的对象都会使用堆空间</p></li><li><p>它是线程共享的，堆空间内的对象都需要考虑线程安全的问题</p></li><li><p>有垃圾回收机制（GC Garbage Collection）</p></li></ul><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><ul><li>Heap堆<ul><li>通过new关键字创建的对象都会使用堆空间</li></ul></li><li>特点<ul><li>它是线程共享的，堆空间内的对象都需要考虑线程安全的问题</li><li>有垃圾回收机制</li></ul></li></ul><h2 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 演示堆内存溢出：java.lang.OutOfMemoryError: Java heap space</span><br><span class="line"> */</span><br><span class="line">public class Demo_04 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        try &#123;</span><br><span class="line">            ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); //Hello, HelloHello, HelloHelloHelloHello ···</span><br><span class="line">            String a = &quot;Hello&quot;;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                list.add(a);</span><br><span class="line">                a = a + a;  // HelloHelloHelloHello</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>list对象的作用域是在try块中，list对象是通过new出来的，所以占用的是堆空间。</li><li>由于a的字符串长度是指数增长的，所以堆空间很快就会不足，此时会触发垃圾回收机制，尝试清理新生代对象，但由于list对象一直处于存活状态，无法释放，最终导致堆内存溢出，最终我这里输出的i为<code>27</code></li><li>但是由于堆空间很大，所以有些堆内存溢出的情况可能不是很容易能诊断出来，所以我们可以通过添加JVM参数，将堆空间修改的小一些来进行测试，此时最终输出的i为<code>17</code></li></ul><h2 id="堆内存诊断"><a href="#堆内存诊断" class="headerlink" title="堆内存诊断"></a>堆内存诊断</h2><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">jps工具</button></li><li class="tab"><button type="button" data-href="#test1-2">jmap工具</button></li><li class="tab"><button type="button" data-href="#test1-3">jconsole工具</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p>查看当前系统中有哪些Java进程</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p>查看堆内存占用情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap 进程id ## 进程id就是jps查出来的进程</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p>图形化界面的多功能监测工具，可以连续监测</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309122058984.png"></p><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><ul><li>在JVM中，方法区是一块用于存储类信息、常量、静态变量、即时编译器编译后的代码等数据的内存区域，它是Java虚拟机规范中的一个概念。<code>Java SE 7</code>及之前版本中，方法区被称为<code>永久代</code>，但在<code>Java SE 8</code>之后的版本中，<code>永久代</code>被废弃了，被<code>元空间</code>所替代。</li><li>元空间是JVM在<code>Java SE 8</code>之后引入的一个新的概念，它与永久代类似，都是用于存储类信息、常量、静态变量、即时编译器编译后的代码等数据的内存区域，但元空间的实现方式与永久代有所不同。</li><li>与永久代不同的是，元空间使用的是<code>本地内存（Native Memory）</code>，而不是<code>虚拟机内存（堆内存）</code>，这样就避免了OutOfMemoryError错误，因为在使用本地内存时，可以动态地调整大小，而且可以使用操作系统的虚拟内存机制，使得Java应用程序不会被限制在固定的内存大小中。</li><li>此外，元空间还引入了一些新的概念和机制，例如MetaspaceSize、MaxMetaspaceSize、CompressedClassSpaceSize等，这些概念和机制都是为了更好地管理元空间的内存使用和性能。</li></ul><h3 id="方法区内存溢出"><a href="#方法区内存溢出" class="headerlink" title="方法区内存溢出"></a>方法区内存溢出</h3><p>1.8之后会导致源空间内存溢出，测试代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import jdk.internal.org.objectweb.asm.ClassWriter;</span><br><span class="line">import jdk.internal.org.objectweb.asm.Opcodes;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 演示元空间内存溢出 java.lang.OutOfMemoryError: Metaspace</span><br><span class="line"> * -XX:MaxMetaspaceSize=50m</span><br><span class="line"> */</span><br><span class="line">public class Demo_07 extends ClassLoader &#123; // 可以用来加载类的二进制字节码</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int j = 0;</span><br><span class="line">        try &#123;</span><br><span class="line">            Demo_07 test = new Demo_07();</span><br><span class="line">            for (int i = 0; i &lt; 100000; i++, j++) &#123;</span><br><span class="line">                // ClassWriter 作用是生成类的二进制字节码</span><br><span class="line">                ClassWriter cw = new ClassWriter(0);</span><br><span class="line">                // 版本号， public， 类名, 包名, 父类， 接口</span><br><span class="line">                cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, &quot;Class&quot; + i, null, &quot;java/lang/Object&quot;, null);</span><br><span class="line">                // 返回 byte[]</span><br><span class="line">                byte[] code = cw.toByteArray();</span><br><span class="line">                // 执行了类的加载</span><br><span class="line">                test.defineClass(&quot;Class&quot; + i, code, 0, code.length); // Class 对象</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加VM参数<code>-XX:MaxMetaspaceSize=50m</code>，然后运行上面的代码，结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">70801</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Metaspace</span><br><span class="line">at java.lang.ClassLoader.defineClass1(Native Method)</span><br><span class="line">at java.lang.ClassLoader.defineClass(ClassLoader.java:756)</span><br><span class="line">at java.lang.ClassLoader.defineClass(ClassLoader.java:635)</span><br><span class="line">at com.demo.Demo_07.main(Demo_07.java:23)</span><br></pre></td></tr></table></figure><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>常量池就是一行表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息</p><p>我们先来编写一个简单的HelloWorld类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;Hello, World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过命令将编译后的.class文件反汇编成可读的Java代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">$ javap -v D:/Workspace/JVM/demo/target/classes/com/demo/HelloWorld.class</span><br><span class="line">Classfile /D:/Workspace/JVM/demo/target/classes/com/demo/HelloWorld.class</span><br><span class="line">  Last modified 2023-3-30; size 553 bytes</span><br><span class="line">  MD5 checksum a920c142d5bb891e2b9fc1ff43b55128                                               </span><br><span class="line">  Compiled from &quot;HelloWorld.java&quot;                                                             </span><br><span class="line">public class com.demo.HelloWorld                                                              </span><br><span class="line">  minor version: 0                                                                            </span><br><span class="line">  major version: 52                                                                           </span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER                                                                </span><br><span class="line">Constant pool:                                                                                </span><br><span class="line">   #1 = Methodref          #6.#20         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V                    </span><br><span class="line">   #2 = Fieldref           #21.#22        // java/lang/System.out:Ljava/io/PrintStream;       </span><br><span class="line">   #3 = String             #23            // Hello, World!                                    </span><br><span class="line">   #4 = Methodref          #24.#25        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = Class              #26            // com/demo/HelloWorld                              </span><br><span class="line">   #6 = Class              #27            // java/lang/Object                                 </span><br><span class="line">   #7 = Utf8               &lt;init&gt;                                                             </span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Lcom/demo/HelloWorld;</span><br><span class="line">  #14 = Utf8               main</span><br><span class="line">  #15 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #16 = Utf8               args</span><br><span class="line">  #17 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #18 = Utf8               SourceFile</span><br><span class="line">  #19 = Utf8               HelloWorld.java</span><br><span class="line">  #20 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #21 = Class              #28            // java/lang/System</span><br><span class="line">  #22 = NameAndType        #29:#30        // out:Ljava/io/PrintStream;</span><br><span class="line">  #23 = Utf8               Hello, World!</span><br><span class="line">  #24 = Class              #31            // java/io/PrintStream</span><br><span class="line">  #25 = NameAndType        #32:#33        // println:(Ljava/lang/String;)V</span><br><span class="line">  #26 = Utf8               com/demo/HelloWorld</span><br><span class="line">  #27 = Utf8               java/lang/Object</span><br><span class="line">  #28 = Utf8               java/lang/System</span><br><span class="line">  #29 = Utf8               out</span><br><span class="line">  #30 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #31 = Utf8               java/io/PrintStream</span><br><span class="line">  #32 = Utf8               println</span><br><span class="line">  #33 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  public com.demo.HelloWorld();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom/demo/HelloWorld;</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3                  // String Hello, World!</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 5: 0</span><br><span class="line">        line 6: 8</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       9     0  args   [Ljava/lang/String;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;HelloWorld.java&quot;</span><br></pre></td></tr></table></figure><p>上面的结果中主要包含三部分</p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">类的基本信息</button></li><li class="tab"><button type="button" data-href="#test1-2">常量池</button></li><li class="tab"><button type="button" data-href="#test1-3">类的方法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Classfile /D:/Workspace/JVM/demo/target/classes/com/demo/HelloWorld.class</span><br><span class="line">  Last modified 2023-3-30; size 553 bytes</span><br><span class="line">  MD5 checksum a920c142d5bb891e2b9fc1ff43b55128                                               </span><br><span class="line">  Compiled from &quot;HelloWorld.java&quot;                                                             </span><br><span class="line">public class com.demo.HelloWorld                                                              </span><br><span class="line">  minor version: 0                                                                            </span><br><span class="line">  major version: 52                                                                           </span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER        </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:                                                                                </span><br><span class="line">   #1 = Methodref          #6.#20         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V                    </span><br><span class="line">   #2 = Fieldref           #21.#22        // java/lang/System.out:Ljava/io/PrintStream;       </span><br><span class="line">   #3 = String             #23            // Hello, World!                                    </span><br><span class="line">   #4 = Methodref          #24.#25        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = Class              #26            // com/demo/HelloWorld                              </span><br><span class="line">   #6 = Class              #27            // java/lang/Object                                 </span><br><span class="line">   #7 = Utf8               &lt;init&gt;                                                             </span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Lcom/demo/HelloWorld;</span><br><span class="line">  #14 = Utf8               main</span><br><span class="line">  #15 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #16 = Utf8               args</span><br><span class="line">  #17 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #18 = Utf8               SourceFile</span><br><span class="line">  #19 = Utf8               HelloWorld.java</span><br><span class="line">  #20 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #21 = Class              #28            // java/lang/System</span><br><span class="line">  #22 = NameAndType        #29:#30        // out:Ljava/io/PrintStream;</span><br><span class="line">  #23 = Utf8               Hello, World!</span><br><span class="line">  #24 = Class              #31            // java/io/PrintStream</span><br><span class="line">  #25 = NameAndType        #32:#33        // println:(Ljava/lang/String;)V</span><br><span class="line">  #26 = Utf8               com/demo/HelloWorld</span><br><span class="line">  #27 = Utf8               java/lang/Object</span><br><span class="line">  #28 = Utf8               java/lang/System</span><br><span class="line">  #29 = Utf8               out</span><br><span class="line">  #30 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #31 = Utf8               java/io/PrintStream</span><br><span class="line">  #32 = Utf8               println</span><br><span class="line">  #33 = Utf8               (Ljava/lang/String;)V</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:                                                                                </span><br><span class="line">   #1 = Methodref          #6.#20         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V                    </span><br><span class="line">   #2 = Fieldref           #21.#22        // java/lang/System.out:Ljava/io/PrintStream;       </span><br><span class="line">   #3 = String             #23            // Hello, World!                                    </span><br><span class="line">   #4 = Methodref          #24.#25        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = Class              #26            // com/demo/HelloWorld                              </span><br><span class="line">   #6 = Class              #27            // java/lang/Object                                 </span><br><span class="line">   #7 = Utf8               &lt;init&gt;                                                             </span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Lcom/demo/HelloWorld;</span><br><span class="line">  #14 = Utf8               main</span><br><span class="line">  #15 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #16 = Utf8               args</span><br><span class="line">  #17 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #18 = Utf8               SourceFile</span><br><span class="line">  #19 = Utf8               HelloWorld.java</span><br><span class="line">  #20 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #21 = Class              #28            // java/lang/System</span><br><span class="line">  #22 = NameAndType        #29:#30        // out:Ljava/io/PrintStream;</span><br><span class="line">  #23 = Utf8               Hello, World!</span><br><span class="line">  #24 = Class              #31            // java/io/PrintStream</span><br><span class="line">  #25 = NameAndType        #32:#33        // println:(Ljava/lang/String;)V</span><br><span class="line">  #26 = Utf8               com/demo/HelloWorld</span><br><span class="line">  #27 = Utf8               java/lang/Object</span><br><span class="line">  #28 = Utf8               java/lang/System</span><br><span class="line">  #29 = Utf8               out</span><br><span class="line">  #30 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #31 = Utf8               java/io/PrintStream</span><br><span class="line">  #32 = Utf8               println</span><br><span class="line">  #33 = Utf8               (Ljava/lang/String;)V</span><br></pre></td></tr></table></figure><p>其中如下内容就表示虚拟机的指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">复制成功0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">3: ldc           #3                  // String Hello, World!    </span><br><span class="line">5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">8: return                            </span><br></pre></td></tr></table></figure><p>解释器去翻译虚拟机指令的时候，看到的只有这些</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">getstatic     #2</span><br><span class="line">ldc           #3</span><br><span class="line">invokevirtual #4</span><br></pre></td></tr></table></figure><p>解释器在解释的时候，就是拿着#2、#3、#4去查表翻译，查的就是常量池中的内容</p><ul><li>用#2举例，查表内容如下</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">getstatic     #2                        // 获取静态变量System.out</span><br><span class="line">#2 = Fieldref            #21.#22        // java/lang/System.out:Ljava/io/PrintStream;     </span><br><span class="line">#21 = Class              #28            // java/lang/System</span><br><span class="line">#28 = Utf8               java/lang/System</span><br><span class="line">#22 = NameAndType        #29:#30        // out:Ljava/io/PrintStream;</span><br><span class="line">#29 = Utf8               out</span><br><span class="line">#30 = Utf8               Ljava/io/PrintStream;</span><br></pre></td></tr></table></figure><ul><li>用#3举例，查表内容如下</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">ldc           #3                        // 加载参数Hello, World!</span><br><span class="line">#3 = String              #23            // Hello, World!        </span><br><span class="line">#23 = Utf8               Hello, World!</span><br></pre></td></tr></table></figure><ul><li>用#4举例，查表内容如下</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">invokevirtual #4                        // 执行虚方法调用，调用println，输出Hello, World!</span><br><span class="line">#4 = Methodref           #24.#25        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">#24 = Class              #31            // java/io/PrintStream</span><br><span class="line">#31 = Utf8               java/io/PrintStream</span><br><span class="line">#25 = NameAndType        #32:#33        // println:(Ljava/lang/String;)V</span><br><span class="line">#32 = Utf8               println</span><br><span class="line">#33 = Utf8               (Ljava/lang/String;)V</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p><strong>常量池</strong>：<br>就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息<br><strong>运行时常量池</strong>：<br>常量池是 *.class 文件中的，当该类被加载以后，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</p><h2 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h2><ul><li>常量池中的字符串仅是符号，只有在被用到时才会转化为对象</li><li>利用串池的机制，来避免重复创建字符串对象</li><li>字符串变量拼接的原理是StringBuilder</li><li>字符串常量拼接的原理是编译器优化</li><li>可以使用intern方法，主动将串池中还没有的字符串对象放入串池中</li></ul><h3 id="intern方法"><a href="#intern方法" class="headerlink" title="intern方法"></a><strong>intern方法</strong></h3><p>调用字符串对象的 intern 方法，会将该字符串对象尝试放入到串池中</p><ul><li>如果串池中没有该字符串对象，则放入成功</li><li>如果有该字符串对象，则放入失败</li><li>无论放入是否成功，都会返回串池中的字符串对象</li></ul><p>注意：此时如果调用 intern 方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个对象</p><h3 id="StringTable-的位置"><a href="#StringTable-的位置" class="headerlink" title="StringTable 的位置"></a>StringTable 的位置</h3><ul><li>在 <code>JDK 1.6</code> 中，字符串常量池（也就是 StringTable）是位于<code>永久代</code>中的。而在 <code>JDK 1.8</code> 中，永久代已经被移除，取而代之的是元空间（Metaspace），而字符串常量池也随之移动到了<code>堆</code>中。这意味着在 JDK 1.8 中，字符串常量池中的字符串也可以被垃圾回收器回收，而在 JDK 1.6 中则不行。</li></ul><h3 id="StringTable-垃圾回收"><a href="#StringTable-垃圾回收" class="headerlink" title="StringTable 垃圾回收"></a>StringTable 垃圾回收</h3><ul><li><p>指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-Xmx10m 指定堆内存大小</span><br><span class="line">-XX:+PrintStringTableStatistics 打印字符串常量池信息</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-verbose:gc 打印 gc 的次数，耗费时间等信息</span><br></pre></td></tr></table></figure></li></ul><ul><li>在 Java 8 及更高版本中，字符串常量池位于堆中，而堆是 JVM 中的一部分，因此字符串常量池中的字符串可以被垃圾回收器回收。具体来说，只有当字符串没有被任何对象引用时，它才能被垃圾回收。当字符串被回收时，它的存储空间将被释放并可以被重新利用。</li></ul><h3 id="StringTable性能调优"><a href="#StringTable性能调优" class="headerlink" title="StringTable性能调优"></a>StringTable性能调优</h3><p>JVM内部，字符串常量池就是通过哈希表（数组 + 链表）实现的。</p><ul><li><p>添加VM参数-XX:StringTableSize&#x3D;1024，实际上设置的是哈希表的大小（数组的数量）。较小的哈希表意味着更多的哈希冲突。这会增加查找字符串的开销，因为需要在链表中进行顺序搜索才能找到一个字符串。因此，这将会导致字符串查找速度变慢。</p></li><li><p>如果应用需要存储大量字符串常量信息，而且这些字符串常量包含大量重复内容，可以使用Java中的字符串常量池机制，通过调用intern()方法将常量放入常量池中，以节省内存空间并提高性能。</p></li><li><p>实际应用：</p><ul><li>根据推特的工程师们所说，推特在存储用户地址信息时采用了字符串常量池的方法。推特上有大量的用户地址信息，而这些信息中有大量的重复内容，如街道名称、城市、州等。通过将这些常见的地址信息存储在字符串常量池中，推特可以节省大量的内存空间。</li><li>推特使用了Guava库中的Interners工具类来实现字符串常量池。该工具类提供了线程安全的字符串常量池实现，支持不同的策略和配置，例如并发级别、最大容量等。推特选择了使用一个全局的、不限容量的字符串常量池来存储用户地址信息。在存储用户信息时，推特使用了String.intern()方法来将地址信息存储在字符串常量池中，而不是直接使用新的字符串对象。这样，推特可以确保相同的地址信息只会在内存中存在一份拷贝，从而减少内存的占用。</li><li>通过这种方法，推特成功地实现了在存储大量用户信息时，有效地减少了内存占用。</li></ul></li></ul><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>如果我们需要存储大量字符串常量信息，而且这些字符串常量包含大量重复内容，可以使用Java中的字符串常量池机制，通过调用intern()方法将常量放入常量池中，以节省内存空间并提高性能。</p><h1 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h1><p><strong>定义：</strong></p><ul><li>JVM的直接内存是指JVM中的一个内存区域，也被称为NIO直接缓冲区。和Java堆不同，直接内存并不是由JVM自动管理的，而是由操作系统直接管理的。直接内存的访问速度比Java堆要快，因为它们可以利用操作系统提供的一些优化机制来提高I&#x2F;O的效率。</li><li>在Java程序中，可以通过ByteBuffer.allocateDirect()方法来创建直接缓冲区。当调用该方法创建直接缓冲区时，JVM会向操作系统申请一块直接内存，用于存储该缓冲区的数据。这个过程不会像在Java堆中创建对象一样，需要进行垃圾回收和堆内存分配的操作，因此创建直接缓冲区的效率要高于在Java堆中创建对象。</li><li>需要注意的是，直接内存是不受JVM的内存管理机制控制的，因此如果使用不当，可能会导致内存泄漏等问题。此外，因为直接内存的访问速度快，但申请和释放直接内存的开销较大，因此需要谨慎使用，避免频繁创建和销毁直接缓冲区。</li></ul><p>特点：</p><ol><li>常见于NIO操作时，用于数据缓冲区</li><li>分配回收成本较高，但读写性能高</li><li>不收JVM内存回收管理</li></ol><h2 id="为什么使用它"><a href="#为什么使用它" class="headerlink" title="为什么使用它"></a>为什么使用它</h2><p>使用直接内存比传统IO快</p><p>原因是直接内存使用的是操作系统的文件映射机制，而传统IO则需要将文件内容读取到内存中再进行操作。直接内存可以避免将文件数据复制到Java堆内存中的过程，减少了不必要的数据复制，从而提高了效率。</p><ul><li>传统IO，将文件读取到系统缓冲区中，但是Java代码不能直接读取系统缓冲区，所以需要在堆内存中分配一块Java缓冲区，将数据从系统缓冲区读取到Java缓冲区后，才能进行写操作</li><li>直接内存的Direct Memory对Java堆内存和系统内存是共享的一块内存区，那么磁盘文件就可以直接读取到Direct Memory，而Java堆内存也可以直接访问Direct Memory</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310252201792.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310252202817.png"></p><h2 id="直接内存溢出"><a href="#直接内存溢出" class="headerlink" title="直接内存溢出"></a>直接内存溢出</h2><ul><li>直接内存（Direct Memory）是一种Java NIO中用于高性能I&#x2F;O操作的内存分配方式，与Java虚拟机中的Java堆不同，它不会受到Java堆大小的限制。直接内存是通过操作系统的内存来分配和释放，因此它不会受到Java堆大小限制的影响，可以更加灵活地使用。</li><li>然而，如果过度使用直接内存，也可能会导致直接内存溢出。直接内存的使用需要手动进行管理，如果不注意及时释放已经使用的直接内存，或者申请过多的直接内存，就会导致直接内存溢出。</li><li>当直接内存溢出时，通常会抛出java.lang.OutOfMemoryError异常。为了避免直接内存溢出，建议在使用完直接内存后及时进行释放</li></ul><h2 id="分配和回收原理"><a href="#分配和回收原理" class="headerlink" title="分配和回收原理"></a>分配和回收原理</h2><p>直接内存不受JVM的管理，所以垃圾回收gc()对直接内存无效，那么直接内存是如何分配和回收的呢？</p><ul><li>Java里有一个非常底层的类<code>Unsafe</code>，它可以分配直接内存和释放直接内存，但是一般不建议我们直接使用Unsafe类，都是JDK内部自己去使用这个类的。</li></ul><ul><li><p>所以对于直接内存需要使用<code>Unsafe</code>对象完成直接内存的分配回收，并且回收需要主动调用<code>freeMemory</code>方法</p></li><li><p>ByteBuffer.allocateDirect()的底层实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Allocates a new direct byte buffer.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt; The new buffer&#x27;s position will be zero, its limit will be its</span><br><span class="line"> * capacity, its mark will be undefined, and each of its elements will be</span><br><span class="line"> * initialized to zero.  Whether or not it has a</span><br><span class="line"> * &#123;@link #hasArray backing array&#125; is unspecified.</span><br><span class="line"> *</span><br><span class="line"> * @param  capacity</span><br><span class="line"> *         The new buffer&#x27;s capacity, in bytes</span><br><span class="line"> *</span><br><span class="line"> * @return  The new byte buffer</span><br><span class="line"> *</span><br><span class="line"> * @throws  IllegalArgumentException</span><br><span class="line"> *          If the &lt;tt&gt;capacity&lt;/tt&gt; is a negative integer</span><br><span class="line"> */</span><br><span class="line">public static ByteBuffer allocateDirect(int capacity) &#123;</span><br><span class="line">    return new DirectByteBuffer(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>找到<code>DirectByteBuffer</code>对象的源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// Primary constructor</span><br><span class="line">//</span><br><span class="line">DirectByteBuffer(int cap) &#123;                   // package-private</span><br><span class="line">    super(-1, 0, cap, cap);</span><br><span class="line">    boolean pa = VM.isDirectMemoryPageAligned();</span><br><span class="line">    int ps = Bits.pageSize();</span><br><span class="line">    long size = Math.max(1L, (long)cap + (pa ? ps : 0));</span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">    long base = 0;</span><br><span class="line">    try &#123;</span><br><span class="line">        base = unsafe.allocateMemory(size);</span><br><span class="line">    &#125; catch (OutOfMemoryError x) &#123;</span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        throw x;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.setMemory(base, size, (byte) 0);</span><br><span class="line">    if (pa &amp;&amp; (base % ps != 0)) &#123;</span><br><span class="line">        // Round up to page boundary</span><br><span class="line">        address = base + ps - (base &amp; (ps - 1));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    cleaner = Cleaner.create(this, new Deallocator(base, size, cap));</span><br><span class="line">    att = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>从底层源码中我们可以看到，这里就是使用Unsafe对象对直接内存的分配，但是却没有看到回收方法<code>freeMemory</code></li></ul><ul><li><p>其实释放的方法是在Deallocator()这个回调方法中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private static class Deallocator</span><br><span class="line">    implements Runnable</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    private static Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line">    private long address;</span><br><span class="line">    private long size;</span><br><span class="line">    private int capacity;</span><br><span class="line"></span><br><span class="line">    private Deallocator(long address, long size, int capacity) &#123;</span><br><span class="line">        assert (address != 0);</span><br><span class="line">        this.address = address;</span><br><span class="line">        this.size = size;</span><br><span class="line">        this.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        if (address == 0) &#123;</span><br><span class="line">            // Paranoia</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        unsafe.freeMemory(address);</span><br><span class="line">        address = 0;</span><br><span class="line">        Bits.unreserveMemory(size, capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>而它是由Cleaner调用的， Cleaner（虚引用类型）是用来监测<code>ByteBuffer</code>对象的，一旦<code>ByteBuffer</code>对象被垃圾<code>回收</code>，那么就会由<code>ReferenceHandler</code>线程通过<code>Cleaner</code>的<code>clean</code>方法调用<code>freeMemory</code>来释放直接内存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void clean() &#123;</span><br><span class="line">    if (remove(this)) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            this.thunk.run();</span><br><span class="line">        &#125; catch (final Throwable var2) &#123;</span><br><span class="line">            AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                public Void run() &#123;</span><br><span class="line">                    if (System.err != null) &#123;</span><br><span class="line">                        (new Error(&quot;Cleaner terminated abnormally&quot;, var2)).printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.exit(1);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="禁用垃圾回收对直接内存的影响"><a href="#禁用垃圾回收对直接内存的影响" class="headerlink" title="禁用垃圾回收对直接内存的影响"></a>禁用垃圾回收对直接内存的影响</h2><ul><li>由于垃圾回收是一个相对昂贵的操作，需要消耗CPU时间和系统资源。频繁调用System.gc()可能会导致性能下降，并且在某些情况下可能会造成应用程序的不稳定性。</li><li>所以为了避免有些程序员老是手动调用垃圾回收，我们一般会进制显式手动垃圾回收，添加VM参数<code>-XX:+DisableExplicitGC</code>禁用显式的垃圾回收</li><li>那么加上这个参数以后，可能就会影响到我们的直接内存的回收机制，例如下面的代码中，执行完System.gc()后（被禁用，相当于没执行），由于内存很充裕，所以ByteBuffer对象并不会被回收，那么ByteBuffer对象对应的那块直接内存，也不会被回收</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Demo_16 &#123;</span><br><span class="line">    static int _1GB = 1024 * 1024 * 1024;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1GB);</span><br><span class="line">        System.out.println(&quot;分配完毕&quot;);</span><br><span class="line">        byteBuffer = null;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(&quot;释放完毕&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM 内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java数组</title>
      <link href="/2023/09/10/Java.%E6%95%B0%E7%BB%84/"/>
      <url>/2023/09/10/Java.%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组：可以存放多个<strong>同一类型</strong>的数据。数组也是一种数据，是<strong>引用类型</strong>。数组本身存放的是一个地址。</p><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><p>数组可以是多个相同类型数据的组合，实现对这些数据的统一管理。数组中的元素可以是任何数据类型。包括基本类型和引用类型。</p><p>数组的下标从 0 开始。且必须在指定范围内使用，否则报错。</p><p>数组属于 引用类型，数组型数据是 对象（Object）</p><p>数组创建后，如果没有赋值，有默认值：</p><table><thead><tr><th>int</th><th>0</th></tr></thead><tbody><tr><td>short</td><td>0</td></tr><tr><td>byte</td><td>0</td></tr><tr><td>long</td><td>0L</td></tr><tr><td>float</td><td>0.0F</td></tr><tr><td>double（</td><td>0.0</td></tr><tr><td>char</td><td>\u0000</td></tr><tr><td>boolean</td><td>false</td></tr><tr><td>String</td><td>null</td></tr><tr><td>Object</td><td>null</td></tr></tbody></table><p>使用数组的步骤：</p><ol><li>声明数组并开辟空间 </li><li>给数组各个元素赋值 </li><li>使用数组</li></ol><p><strong>数组的构造方法</strong></p><ul><li><p>构造方式1：动态初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[] ints = new int[5];// 创建了数组 name，存放5个int</span><br><span class="line">int ints2[] = new int[1];// 这种写法也行</span><br><span class="line">ints[2] = 15;// 访问数组第3个数</span><br></pre></td></tr></table></figure></li><li><p>构造方式2：动态初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char[] chars;// 先声明数组 name，此时数组是 null</span><br><span class="line">chars = new char[2];// 分配内存空间，可以存放数据了</span><br><span class="line">chars[1] = &#x27;\t&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>构造方式3：静态初始化</p></li></ul><blockquote><p>确切知道数组每个元素的场合可以用这个方法。</p></blockquote>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boolean[] bools = &#123;true, false, true, false&#125;;</span><br><span class="line">String[] strs = new String[]&#123;&quot;a&quot;, &quot;b&quot;&#125;;</span><br></pre></td></tr></table></figure><p><strong>数组的使用方法：</strong></p><ul><li><p>访问数组元素：<code>数组名[元素下标]</code></p><p>其中，元素下标从 0 开始编号。如：访问 strs 数组的第一个元素 <code>strs[0]</code></p></li><li><p>数组长度：<code>数组名.length</code></p><p>是一个 int 值。不能通过试图改变该值来改变数组容量</p></li></ul><h2 id="数组赋值机制"><a href="#数组赋值机制" class="headerlink" title="数组赋值机制"></a>数组赋值机制</h2><p><strong>基本数据类型</strong>：赋值方式是值拷贝。这个值就是具体的数据，且互不影响。</p><p><strong>引用数据类型</strong>：赋值方式是地址拷贝。赋的值是地址，赋值方式为引用传达。</p><p>数组在默认情况下是引用传递，赋的值是地址，赋值方式为引用传达。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[] array1 = &#123;0, 0, 0&#125;;</span><br><span class="line">int[] array2 = array1;</span><br><span class="line">array2[0] = 100;</span><br></pre></td></tr></table></figure><p>因为数组在 JVM 的栈里是一个地址，指向 堆 里的一个空间。这两个数组在此时指向同一空间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int[] array1 = &#123;0, 0, 0&#125;;</span><br><span class="line">int[] array2 = new int[array1.length];</span><br><span class="line">for (int i = 0;i &lt; array1.length;i++) &#123;</span><br><span class="line">    array2[i] = array1[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，2个数组都是new出来的，二者地址独立，内容相同。</p><h2 id="数组的扩容"><a href="#数组的扩容" class="headerlink" title="数组的扩容"></a>数组的扩容</h2><p>数组的大小生成时固定，当数组达到上限时，创建一个容量更大的新数组。将旧数组的元素依次放入，之后替换旧数组。</p><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>二维数组实际是由多个一维数组组成的，它的各个元素的长度可以相同，也可以不同。数组是一个对象，所以二维数组的元素存放的是一维数组的地址。</p><p><strong>二维数组构造方法：</strong></p><ul><li><p>构造方法1：动态初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[][] many_ints = new int[3][4]// 创建 有3个 包含4个元素的一维数组 的二维数组</span><br></pre></td></tr></table></figure></li><li><p>构造方法2：动态初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double[][] many_doubles;// 先声明变量</span><br><span class="line">many_doubles = new double[3][4];// 再开辟空间</span><br></pre></td></tr></table></figure></li><li><p>构造方法3：动态初始化-列数不确定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char[][] many_chars = new char[3][];// 创建一个三行列数不确定的二维数组</span><br><span class="line">for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">    many_chars[i] = new char[i + 1];// 此时，每个数组空间依次增大</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造方法4：静态初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[][] many_many = &#123;&#123;1, 3&#125;, &#123;4, 10, 2&#125;, &#123;95&#125;&#125;;</span><br></pre></td></tr></table></figure></li></ul><p><strong>二维数组使用方法：</strong></p><ul><li><code>ints.length</code>：该二维数组的长度</li><li><code>ints[0]</code>：该二维数组的第一个一维数组</li><li><code>ints[x].length</code>：该二维数组的第 X 个子数组的长度</li><li><code>ints[1][0]</code>：该二维数组第二个子数组的第一个元素的值</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven基础</title>
      <link href="/2023/09/09/maven%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/09/09/maven%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Maven简介"><a href="#Maven简介" class="headerlink" title="Maven简介"></a>Maven简介</h1><h2 id="Maven是什么"><a href="#Maven是什么" class="headerlink" title="Maven是什么"></a>Maven是什么</h2><p>在Javaweb开发中，需要使用大量的jar包，我们手动去导入；如何能够让一个东西自动帮我导入和配置这个jar包。由此，Maven诞生了</p><ul><li>Maven的本质是一个项目管理工具，将项目开发和管理过程抽象成-一个项目对象模型(POM)</li><li>Maven是用Java语言编写的。他管理的东西统统以面向对象的形式进行设计，最终它把一个项目看成一个对象，而这个对象叫做<strong>POM</strong>(project object model)，即项目对象模型</li><li>POM (Project Object Model) :项目对象模型</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309091528718.png"></p><p>图中蓝色部分为核心，其余部分都是可以替换的。</p><p>Maven通过<strong>依赖管理</strong>进行项目资源管理的。这也是它的第二个核心！</p><ul><li>所谓依赖管理就是maven对项目所有依赖资源的一种管理，它和项目之间是一种双向关系，即当我们做项目的时候maven的依赖管理可以帮助你去管理你所需要的其他资源，当其他的项目需要依赖我们项目的时候，maven也会把我们的项目当作一种资源去进行管理，这就是一种双向关系。</li><li>那maven的依赖管理它管理的这些资源存在哪儿呢？主要有三个位置：本地仓库，私服，中央仓库</li><li>本地仓库顾名思义就是存储在本地的一种资源仓库，如果本地仓库中没有相关资源，可以去私服上获取，私服也是一个资源仓库，只不过不在本地，是一种远程仓库，如果私服上也没有相关资源，可以去中央仓库去获取，中央仓库也是一种远程仓库。</li><li>Maven除了帮我们管理项目资源之外还能帮助我们对项目进行构建，管理项目的整个生命周期，当然它的这些功能需要使用一些相关的插件来完成，当然整个生命周期过程中插件是需要配合使用的，单独一个无法完成完整的生命周期。</li></ul><h2 id="Maven的作用"><a href="#Maven的作用" class="headerlink" title="Maven的作用"></a>Maven的作用</h2><ul><li>项目构建:提供标准的、跨平台的自动化项目构建方式</li><li>依赖管理:方便快捷的管理项目依赖的资源(jar包) ， 避免资源间的版本冲突问题</li><li>统一开发结构:提供标准的、统-的项目结构</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309091536970.png"></p><p>各目录存放资源类型说明：</p><p>src&#x2F;main&#x2F;java：项目java源码</p><p>src&#x2F;main&#x2F;resources：项目的相关配置文件（比如mybatis配置，xml映射配置，自定义配置文件等）</p><p>src&#x2F;main&#x2F;webapp：web资源（比如html，css，js等）</p><p>src&#x2F;test&#x2F;java：测试代码</p><p>src&#x2F;test&#x2F;resources：测试相关配置文件</p><p>src&#x2F;pom.xml：项目pom文件</p><h1 id="Maven安装"><a href="#Maven安装" class="headerlink" title="Maven安装"></a>Maven安装</h1><p><a href="https://maven.apache.org/">官网</a></p><p>maven是一个绿色软件，解压即安装。</p><p>配置环境变量：</p><ul><li>依赖Java，需要配置JAVA_ HOME</li><li>设置MAVEN自身的运行环境，需要配置MAVEN_ HOME</li></ul><p>环境变量配置好之后需要测试环境配置结果，我们需要在DOS命令窗口下输入以下命令查看输出，如果能够看到输出的maven的版本信息代表配置成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn -v</span><br></pre></td></tr></table></figure><h1 id="Maven概念"><a href="#Maven概念" class="headerlink" title="Maven概念"></a>Maven概念</h1><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>用于存储资源，主要是各种jar包</p><p>关于仓库，有三种：本地仓库，私服，中央仓库，其中私服和中央仓库都属于远程仓库</p><p><strong>中央仓库</strong>：maven团队自身维护的仓库，属于开源的，包含几乎全部的jar包</p><p><strong>私服</strong>：各公司&#x2F;部门等小范围内存储资源的仓库，私服也可以从中央仓库获取资源，私服中有公司自己的未开源的jar包，也加快了速度</p><p><strong>本地仓库</strong>：开发者自己电脑上存储资源的仓库，也可从远程仓库获取资源</p><p><img src="C:\Users\CWL25\AppData\Roaming\Typora\typora-user-images\image-20230909154543369.png" alt="image-20230909154543369"></p><h2 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h2><p>maven中的坐标用于描述仓库中资源的位置</p><p>maven坐标的主要组成如下：</p><ul><li>groupId：定义当前资源隶属组织名称（通常是域名反写，如：org.mybatis；com.itheima）</li><li>artifactId：定义当前资源的名称（通常是项目或模块名称，如：crm，sms）</li><li>version：定义当前资源的版本号</li><li>packaging：定义资源的打包方式，取值一般有如下三种<ul><li>jar：该资源打成jar包，默认是jar java工程打包为jar</li><li>war：该资源打成war包 web工程打包为war</li><li>pom：该资源是一个父资源（表明使用maven分模块管理），打包时只生成一个pom.xml不生成jar或其他包结构</li></ul></li></ul><h1 id="Maven项目创建"><a href="#Maven项目创建" class="headerlink" title="Maven项目创建"></a>Maven项目创建</h1><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309121920416.png"></p><h1 id="Maven依赖管理"><a href="#Maven依赖管理" class="headerlink" title="Maven依赖管理"></a>Maven依赖管理</h1><h2 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a>依赖配置</h2><p>依赖是指在当前项目中运行所需的jar，依赖配置的格式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--设置当前项目所依赖的所有jar--&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!--设置具体的依赖--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;!--依赖所属群组id--&gt;</span><br><span class="line">        &lt;groupId&gt;Junit&lt;/groupId&gt;</span><br><span class="line">        &lt;!--依赖所属项目id--&gt;</span><br><span class="line">        &lt;artifactId&gt;Junit&lt;/artifactId&gt;</span><br><span class="line">        &lt;!--依赖版本号--&gt;</span><br><span class="line">        &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h2 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a><strong>依赖传递</strong></h2><p>依赖具有传递性，分两种</p><ol><li>直接依赖：在当前项目中通过依赖配置建立的依赖关系</li><li>间接依赖：被依赖的资源如果依赖其他资源，则表明当前项目间接依赖其他资源</li></ol><p>可选依赖：可选依赖指的是对外隐藏当前所依赖的资源（不让别人看）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;Junit&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;Junit&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">        &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><blockquote><p>加一个<code>&lt;optional&gt;</code> <strong>标签</strong></p></blockquote><h2 id="依赖传递冲突"><a href="#依赖传递冲突" class="headerlink" title="依赖传递冲突"></a>依赖传递冲突</h2><p>在依赖传递过程中产生了冲突，我们有三种优先法则</p><ol><li>路径优先：当依赖中出现相同资源时，层级越深，优先级越低，反之则越高</li><li>声明优先：当资源在相同层级被依赖时，配置顺序靠前的覆盖靠后的</li><li>特殊优先：当同级配置了相同资源的不同版本时，后配置的覆盖先配置的</li></ol><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309121927528.png"></p><p>以一个项目为根，直接依赖称为1度资源，直接依赖的直接依赖称为2度资源，直接依赖的直接依赖的直接依赖称为3度资源。</p><h2 id="排除依赖"><a href="#排除依赖" class="headerlink" title="排除依赖"></a>排除依赖</h2><p>排除依赖指主动断开依赖的资源，被排除的资源无需指定版本，使用一个大依赖，排除中间的一个小依赖。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;Junit&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;Junit&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">        &lt;exclusions&gt;</span><br><span class="line">            &lt;exclusion&gt;</span><br><span class="line">                &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">            &lt;/exclusion&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h2 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h2><p>依赖的jar默认情况可以在任何地方可用，可以通过scope标签设定其作用范围</p><p>这里的范围主要是指以下三种范围</p><ol><li>主程序范围有效（src&#x2F;main目录范围内）</li><li>测试程序范围内有效（src&#x2F;test目录范围内）</li><li>是否参与打包（package指令范围内）</li></ol><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309121932057.png"></p><h1 id="Maven生命周期与插件"><a href="#Maven生命周期与插件" class="headerlink" title="Maven生命周期与插件"></a>Maven生命周期与插件</h1><p>Maven对项目构建的生命周期划分为3套</p><ol><li>clear：清理工作</li><li>default：核心工作，例如编译、测试、打包、部署等</li><li>site：产生报告、发布站点等</li></ol><h2 id="clear生命周期"><a href="#clear生命周期" class="headerlink" title="clear生命周期"></a>clear生命周期</h2><p>clean：清理工作</p><ul><li>pre-clean：执行一些在clean之前的工作</li><li>clean：移除上一次构建产生的所有文件</li><li>post-clean：执行一些在clean之后立刻完成的工作</li></ul><h2 id="default生命周期"><a href="#default生命周期" class="headerlink" title="default生命周期"></a>default生命周期</h2><p>default：核心工作，例如编译，测试，打包，部署等</p><p><strong>对于default生命周期，每个事件在执行之前都会将之前的所有事件依次执行一遍</strong></p><p><img src="C:\Users\CWL25\AppData\Roaming\Typora\typora-user-images\image-20230912193439258.png" alt="image-20230912193439258"></p><h2 id="site生命周期"><a href="#site生命周期" class="headerlink" title="site生命周期"></a>site生命周期</h2><ul><li>site：产生报告，发布站点等</li><li>pre-site：执行一些在生成站点文档之前的工作</li><li>site：生成项目的站点文档</li><li>post-site：执行一些在生成站点文档之后完成的工作，为部署做准备</li><li>site-deploy：将生成的站点文档部署到特定的服务器上</li></ul><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><ul><li>插件与生命周期内的阶段绑定，在执行到对应生命周期时执行对应的插件</li><li>maven默认在各个生命周期上都绑定了预先设定的插件来完成相应功能</li><li>插件还可以完成一些自定义功能</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.2.1&lt;/version&gt;</span><br><span class="line">            &lt;executions&gt;</span><br><span class="line">                &lt;excution&gt;</span><br><span class="line">                    &lt;goals&gt;</span><br><span class="line">                        &lt;!--当goal属性的值为test-jar时，是对测试代码打包--&gt;</span><br><span class="line">                        &lt;goal&gt;jar&lt;/goal&gt;</span><br><span class="line">                    &lt;/goals&gt;</span><br><span class="line">                    &lt;phase&gt;generate-test-resources&lt;/phase&gt;</span><br><span class="line">                &lt;/excution&gt;</span><br><span class="line">            &lt;/executions&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p>如果配置成功，在IDEA右侧<code>maven-project</code>操作面板上可以看到</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309121941120.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java流程结构</title>
      <link href="/2023/09/07/Java.%E7%BB%93%E6%9E%84/"/>
      <url>/2023/09/07/Java.%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="程序控制结构"><a href="#程序控制结构" class="headerlink" title="程序控制结构"></a>程序控制结构</h1><p>程序运行的流程控制决定程序是如何执行的。主要分为：顺序控制、分支控制、循环控制</p><h2 id="顺序控制"><a href="#顺序控制" class="headerlink" title="顺序控制"></a>顺序控制</h2><p>程序从上到下逐行执行，中间没有任何判断和跳转（默认的控制顺序）</p><p>语句：Java 中最小的执行单位。语句分为 单语句 和 复合语句。</p><ul><li><p>单语句：通常意义的一条语句。语句间以分号 <code>;</code> 分隔。</p></li><li><p>复合语句：一对大括号括起来的语句组。也称为 “块”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    语句1; </span><br><span class="line">    语句2;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>块中可以有多条语句。块后没有分号 <code>;</code></p></li></ul><h2 id="分支控制"><a href="#分支控制" class="headerlink" title="分支控制"></a>分支控制</h2><p>让程序有选择的执行。主要分为：单分支控制、双分支控制</p><h3 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h3><p><strong>单分支控制</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (条件表达式) 语句;</span><br><span class="line">或者，把代码块（复合语句）作为语句的场合也能这样写：</span><br><span class="line">if (条件表达式) &#123;</span><br><span class="line"> 执行代码块;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当条件表达式为 <code>true</code>，就会执行 <code>&#123;执行代码块;&#125;</code>；如果为 <code>false</code> 则不执行。特别地：如果 <code>&#123;执行代码块;&#125;</code> 中只有一条代码，也可以不写 <code>&#123; &#125;</code></p><p><strong>双分支控制</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (条件表达式) &#123;</span><br><span class="line"> 执行代码块;</span><br><span class="line">&#125; else &#123;</span><br><span class="line"> 执行代码块2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当条件表达式为 <code>ture</code>，就会执行 <code>&#123;执行代码块1;&#125;</code>；如果为 <code>false</code> 则执行 <code>&#123;执行代码块2;&#125;</code></p><p><strong>多分支控制</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (条件表达式) &#123;</span><br><span class="line"> 执行代码块;</span><br><span class="line">&#125; else if (条件表达式2) &#123;</span><br><span class="line"> 执行代码块2;</span><br><span class="line">&#125; else if (条件表达式3) &#123;</span><br><span class="line"> 执行代码块3;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">else &#123;</span><br><span class="line"> 执行代码块n；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别地：多分支可以没有 <code>else</code>。此时如果条件都不成立，则无执行入口</p><h3 id="嵌套分支"><a href="#嵌套分支" class="headerlink" title="嵌套分支"></a>嵌套分支</h3><p>在一个分支结构中又完整嵌套了另一个完整的分支结构。里面的分支称为内层分支，外面的分支称为外层分支。</p><p>Java 规定，else 子句属于逻辑上距其最近，且没有匹配 else 的 if 语句：</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int n = 0;</span><br><span class="line">if (n &gt; 0) n++;</span><br><span class="line">if (n &gt; 1) n++;</span><br><span class="line">else n--;//属于上面这个 if 语句</span><br></pre></td></tr></table></figure><p>这个场合，这个 else 语句属于上面的 <code>if (n &gt; 1)</code> 这个语句</p></blockquote><p>要想改变那个匹配关系，要使用 <code>&#123; &#125;</code> 改变语句结构：</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int n = 0;</span><br><span class="line">if (n &gt; 0) &#123;</span><br><span class="line">    n++;</span><br><span class="line">if (n &gt; 1) n++;  </span><br><span class="line">&#125; else n--;</span><br></pre></td></tr></table></figure></blockquote><p><strong>规范：嵌套尽量不超过 3 层（可读性不好）</strong></p><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">switch(表达式)&#123;</span><br><span class="line">case 常量1:</span><br><span class="line">语句块1;</span><br><span class="line">break;//break 语句可选</span><br><span class="line">case 常量2:</span><br><span class="line">语句块2;</span><br><span class="line">break;//break 语句可选</span><br><span class="line">...</span><br><span class="line">default://default 语句可选</span><br><span class="line">default语句块;</span><br><span class="line">break;//break 语句可选</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>switch</code> 关键字，表示 switch 分支。</li><li><code>表达式</code> 对应一个值。<strong>该值必须是 int 或 char</strong>（char 可以转化为 int）。是 byte 或 short 的场合，要提升为 int。不允许 long、double 或 float</li><li><code>case 常量1;</code> 表示：当 <code>表达式</code> 的值等于 <code>常量1</code> ，则执行 <code>语句块1</code>。</li><li><code>break;</code> 表示退出 switch 分支。</li><li>当 <code>表达式</code> 的值匹配 <code>常量1</code> ，则执行 <code>语句块1</code>，如果不匹配，则继续匹配 <code>常量2</code> ，以此类推。</li><li>如果全都不匹配，则执行 <code>default</code>。</li><li>如果不写 <code>break;</code> ，则会发生<strong>穿透</strong>，即不进行判断而继续执行下一语句块。</li></ol><p><strong>使用细节</strong></p><ol><li><code>表达式;</code> 数据类型，应和 <code>case</code> 后的 <code>常量</code> 类型一致，或者是可以自动转换成可以比较的类型。如：输入的是 <code>char</code> 而 <code>常量</code> 是 <code>int</code></li><li>switch 中 <code>表达式</code> 的返回值必须是：<code>byte</code> <code>short</code> <code>int</code> <code>char</code> <code>enum</code> <code>String</code></li><li><code>case</code> 语句中的值必须是 常量 或 常量表达式，不能是 变量。</li><li><code>default</code> 是可选的。没有就不执行。</li><li><code>break;</code> 用来跳出 switch 分支。如果不写，会持续执行语句，直到分支结束或遇到下一个 <code>break;</code></li></ol><h2 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h2><h3 id="普通for循环"><a href="#普通for循环" class="headerlink" title="普通for循环"></a>普通for循环</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(循环变量初始化;循环条件;循环变量迭代)&#123;</span><br><span class="line">循环操作（代码块）;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>for</code> 关键字，表示循环控制</li><li>四个要素：1. 循环变量初始化 2. 循环的条件 3. 循环的操作 4. 循环变量迭代</li></ul><p>所有循环开始前仅一次进行初始化。直到循环条件变为 false 前，执行循环操作。每轮循环结束后，进行循环变量迭代。</p><ul><li>循环操作可以有多条语句</li><li>如果循环操作只有一条语句，可以省略 <code>&quot;&#123;&#125;&quot;</code>，但建议不省略</li></ul><p><strong>使用细节</strong></p><ol><li><p>循环条件是返回一个 boolean 值（<code>ture</code> 或 <code>false</code>）的公式。</p><p>循环条件可以为空。这个场合，默认为真（true）</p></li><li><p><code>for(;循环条件;)&#123; &#125;</code> 其中的初始化和变量迭代可以写在别处，但 <code>;</code> 不能省略。如果不写在别处，那个 <code>循环变量初始化</code> 中声明的变量只能在该 for 循环中使用。</p></li><li><p>控制台用 ctrl + c 强制结束一个流程</p></li><li><p>循环初始值可以有多条初始化语句，但要求类型一样，并用 <code>,</code> 隔开。</p><p>变量迭代也可以有多条代码，用 <code>,</code> 隔开</p></li></ol><h3 id="for-each（泛型-for-循环）"><a href="#for-each（泛型-for-循环）" class="headerlink" title="for each（泛型 for 循环）"></a>for each（泛型 for 循环）</h3><p>泛型 for 循环（增强 for 循环）能用来依次处理数组、集合中的每个元素，而不必考虑下标值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(int i : nums)&#123;//其中 nums 是一个一维 int 数组</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型 for 循环适用于数组或一个实现了 Iterable 接口的对象。泛型 for 循环的本质是一个 Iterator（迭代器）</p><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while(循环条件)&#123;</span><br><span class="line"> 循环体(代码块);</span><br><span class="line"> 循环变量迭代;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>while</code> 也有四要素，只是位置和 <code>for</code> 不同</p><p><strong>使用细节</strong></p><ol><li><p>循环条件是返回一个 boolean 值（<code>ture</code> 或 <code>false</code>）的公式。</p><p>while 循环中，循环条件不能为空。</p></li><li><p><code>while</code> 循环是先判断再执行语句</p></li></ol><h3 id="do-while"><a href="#do-while" class="headerlink" title="do..while"></a>do..while</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">循环体;</span><br><span class="line">循环变量迭代;</span><br><span class="line">&#125;while(循环条件);</span><br></pre></td></tr></table></figure><ol><li><code>do</code> <code>while</code> 是关键字</li><li>也有四要素，位置不同</li><li>先执行，再判断。也就是说，一定会至少执行一次</li><li><strong>最后有一个 <code>;</code></strong></li><li><code>while</code> 与 <code>do..while</code> 区别：“要账”</li></ol><p><strong>使用细节</strong></p><ol><li>循环条件是返回一个 boolean 值（<code>ture</code> 或 <code>false</code>）的公式。</li><li><code>do..while</code> 循环是先执行再判断的语句。因此至少执行一次。</li></ol><h3 id="多重循环控制"><a href="#多重循环控制" class="headerlink" title="多重循环控制"></a>多重循环控制</h3><p>将一个循环放在另一个循环体内，就形成了嵌套循环。建议一般使用两层，最多不超过三层。</p><p>嵌套循环 是把 内层循环 当成 外层循环 的 循环体。只有内层 <code>false</code> 时才可能结束当层循环。</p><p>若内层执行 n 次，外层 m 次，则合计会循环 n*m 次</p><h2 id="跳转控制语句"><a href="#跳转控制语句" class="headerlink" title="跳转控制语句"></a>跳转控制语句</h2><p>跳转控制语句用于分支或循环中，以便程序员更好控制程序执行方向</p><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a:&#123;</span><br><span class="line">b:&#123;</span><br><span class="line">c:&#123;</span><br><span class="line">   ...</span><br><span class="line"> berak b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>a:</code> <code>b:</code> <code>c:</code> 是标签，名字由程序员指定</li><li><code>break</code> 后指定哪个标签就退出到哪里</li><li><strong>实际开发中，尽量不要使用标签</strong></li></ol><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>用于中止一个语句块的执行</p><p>语法：<code>break;</code></p><p>break 可以被用在三种场合中</p><ul><li><p>switch 语句中，以跳出判断（结束穿透）</p></li><li><p>for、while、do…while 循环语句中，以跳出循环</p></li><li><p>语句块中，以跳过本块中所有剩余语句</p></li></ul><blockquote><p><code>break</code> 语句出现在多层嵌套的语句块中时，可以通过 <strong>标签</strong> 指明要终止的时哪一层语句块。</p></blockquote><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>在循环中出现。用于结束本次循环，继续下一次循环</p><p>语法：<code>continue;</code></p><p>进行下次循环前，仍会判断循环条件是否满足</p><p>在多层嵌套循环中，可以通过标签指出跳出哪次循环（同 <code>break</code>）</p><h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><p>用于方法。表示跳出所在的方法</p><p>语法：<code>return;</code></p><p>方法有返回值的场合，将返回值写在 return 后：<code>return 值;</code></p><p>如果写在主方法 则跳出程序。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 流程结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-运算符、输入输出</title>
      <link href="/2023/09/07/Java.%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
      <url>/2023/09/07/Java.%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>运算符：一种特殊的符号，用于表示数据的运算、赋值和比较等。</p><h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><p>算术运算符是对数值类型的变量进行运算的运算符，在 Java 程序中使用得非常多。其运算结果是一个数值量。</p><ul><li><p><code>+</code> ; <code>-</code> ; <code>*</code> ; <code>/</code> ：加（正）、减（负）、乘、除</p></li><li><p><code>%</code> ：取模（求余数），结果和被取模数同号。</p></li><li><p><code>++</code> ：自增。</p><p><code>++i</code> 先自增后赋值；<code>i++</code> 先赋值后自增</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i = 10;</span><br><span class="line">int j = ++i; //等价于 i = i + 1; j = i; 此时 i = 10; j = 10`</span><br><span class="line">int k = i++; //等价于 k = i; i = i + 1; 此时 i = 11; k = 10`</span><br><span class="line">i = i++; //系统会先后执行 int temp = i;     i = i + 1;     i = temp</span><br><span class="line">i = ++i; //系统会先后执行 i = i + 1;     int temp = i;     i = tempJAVA</span><br></pre></td></tr></table></figure></li><li><p><code>--</code> ：自减。和 <code>++</code> 同理。</p></li><li><p><code>+</code> ：字符串相加，数字遇到字符串的 + 会转为字符串类型</p></li></ul><h2 id="关系运算符（比较运算符）"><a href="#关系运算符（比较运算符）" class="headerlink" title="关系运算符（比较运算符）"></a>关系运算符（比较运算符）</h2><p>关系运算符结果都为 <code>boolean</code> 型，要么是 <code>true</code> 要么是 <code>false</code>。其关系表达式经常用在 <code>if</code> 结构的条件中或循环结构的条件中。</p><ul><li><code>==</code> ：相等于。<code>8 == 7</code> 结果 <code>false</code></li><li><code>!=</code> ：不等于</li><li><code>&lt;</code> <code>&gt;</code> ：小于、大于</li><li><code>&lt;=</code> <code>&gt;=</code> ：小于等于、大于等于</li><li><code>instanceof</code> ：检查是否是类的对象。<code>&quot;a&quot; istanceof String</code> 结果 <code>true</code></li></ul><h3 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h3><ol><li>关系运算符结果都是 <code>boolean</code> 型，要么是 <code>true</code> ，要么是 <code>false</code></li><li>关系运算符的表达式，称为<em>关系表达式</em></li><li>比较运算符 <code>==</code> 不要误写为 <code>=</code></li><li>Java 允许将 <code>==</code>、<code>!=</code> 两种运算用于任何数据类型</li></ol><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>用于连接多个条件（多个关系表达式），最终的结果也是一个 <code>boolean</code> 值。</p><ul><li><p><code>&amp;&amp;</code> ：短路与。<code>a</code> <code>b</code> 同时为 <code>true</code>，则结果为 <code>true</code>，否则为 <code>false</code>。</p></li><li><p><code>&amp;</code> ：逻辑与。<code>a</code> <code>b</code> 同时为 <code>true</code>，则结果为 <code>true</code>，否则为 <code>false</code>。</p><p><code>&amp;&amp;</code> 与 <code>&amp;</code> 的区别，在于 <code>a &amp;&amp; b</code> 的场合，<code>a = false</code> 时，则 <code>b</code> 不判断。而 <code>&amp;</code> 会2个都判断。开发中多用 <code>&amp;&amp;</code> ，因为其效率更高。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">int b = 1;</span><br><span class="line"></span><br><span class="line">if (a++ &gt; 1 &amp;&amp; ++b &lt; 1) System.out.println(&quot;Nothing happened&quot;);</span><br><span class="line">/*</span><br><span class="line">此时 a 经历了先判断后自增，返回 false 并且 a = 2</span><br><span class="line">但此时 b = 1; 因为 a = false; 所以 ++b 不执行。</span><br><span class="line">*/JAVA</span><br></pre></td></tr></table></figure></li><li><p><code>||</code> ：短路或。<code>a</code> <code>b</code> 任一为 <code>true</code>，则结果为 <code>true</code>，否则为 <code>false</code>。</p></li><li><p><code>|</code> ：逻辑或。<code>a</code> <code>b</code> 任一为 <code>true</code>，则结果为 <code>true</code>，否则为 <code>false</code>。</p><blockquote><p>两者的区别和<code>&amp;&amp;</code> 与 <code>&amp;</code> 相似，若第一个为 <code>true</code> ，则 <code>||</code> 不会判断第二个。</p></blockquote></li><li><p><code>!</code> ：取反。<code>a</code> 为 <code>true</code>，则结果为 <code>false</code>。反之为 <code>true</code>。</p></li><li><p><code>^</code>：逻辑异或。<code>a</code> <code>b</code> 不同时，结果为 <code>true</code>，否则为 <code>false</code>。</p></li></ul><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><blockquote><p>将某个运算后的值，赋给指定变量</p></blockquote><ul><li><p>基本赋值运算符：<code>=</code></p></li><li><p>符合赋值运算符：<code>+=</code> ; <code>-=</code> ; <code>*=</code> ; <code>/=</code> ; <code>%=</code> 等</p><blockquote><p><code>a += b</code> 等价于 <code>a = a + b</code>。其余同理。</p></blockquote></li></ul><h3 id="使用细节-1"><a href="#使用细节-1" class="headerlink" title="使用细节"></a>使用细节</h3><ol><li><p>运算顺序从右往左。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int num = a + b + c;// 先运行(a + b + c)，再结算int num </span><br></pre></td></tr></table></figure></li><li><p>运算符左边只能是变量，右边可以是变量、表达式、常量值。</p></li><li><p>复合赋值运算符会进行类型转换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte b = 2; b += 3;// 此时 b += 3 等价于 b = (byte)(b + 3)</span><br><span class="line">b++;// 同理</span><br></pre></td></tr></table></figure></li></ol><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>基本语法：<code>条件表达式 ? 表达式1 : 表达式2;</code></p><p>运算规则：如果条件表达式为 <code>ture</code> ，运算的结果是表达式1；反之为表达式2。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">int b = 11;</span><br><span class="line">int result = (a == b ? a++ : b++);// 此时 a = 10  result = 11  b = 12</span><br></pre></td></tr></table></figure><h3 id="使用细节-2"><a href="#使用细节-2" class="headerlink" title="使用细节"></a>使用细节</h3><ol><li>表达式1 和 表达式2 要为可以赋给接受变量的类型（或可以自动转换，或进行强制转换）</li><li>三元运算符可以转成 <code>if--else</code></li><li>三元运算符是一个整体。</li></ol><blockquote><p>例： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj = true ? new Integer(1) : new Double(2.2);</span><br><span class="line">System.out.print(obj)</span><br></pre></td></tr></table></figure><p>系统将会输出 <code>1.0</code>，因为 三元运算符 是一个整体，所以 发生了类型转换</p></blockquote><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><table><thead><tr><th>运算符（优先级从高到低）</th><th>结核性</th></tr></thead><tbody><tr><td><code>[]</code>、<code>()</code> 方法调用</td><td>从左向右</td></tr><tr><td><code>!</code>、<code>~</code>、<code>++</code>、<code>--</code>、<code>+</code>（一元运算）、<code>-</code>（一元运算）、强制类型转换、new</td><td>从右向左</td></tr><tr><td><code>*</code>、<code>/</code>、<code>%</code></td><td>从左向右</td></tr><tr><td><code>+</code>、<code>-</code></td><td>从左向右</td></tr><tr><td><code>&lt;&lt;</code>、<code>&gt;&gt;</code>、<code>&gt;&gt;&gt;</code></td><td>从左向右</td></tr><tr><td><code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code>、instanceof</td><td>从左向右</td></tr><tr><td><code>==</code>、<code>!=</code></td><td>从左向右</td></tr><tr><td><code>&amp;</code></td><td>从左向右</td></tr><tr><td><code>^</code></td><td>从左向右</td></tr><tr><td><code>&amp;&amp;</code></td><td>从左向右</td></tr><tr><td><code>?:</code>（三元运算符）</td><td>从右向左</td></tr><tr><td><code>=</code>、<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>&amp;=</code>、<code>%=</code>、<code>^=</code>、&#96;</td><td>&#x3D;<code>、</code>&lt;&lt;&#x3D;<code>、</code>&gt;&gt;&#x3D;<code>、</code>&gt;&gt;&gt;&#x3D;&#96;</td></tr></tbody></table><ol><li>运算符有不同优先级。优先级高的总是优先于低的。</li><li>只有单目运算符、赋值运算符是从右向左运算的。</li></ol><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>Java 对各种变量、方法和类等命名时使用的字符序列称为标识符，凡是自己可以起名字的地方都叫标识符 </p><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><ol><li>标识符由 26 个大、小写英文字母，0 - 9 阿拉伯数字，_ 或 $ 符号组成。</li><li><strong>数字不能开头</strong>。</li><li>不能是关键字和保留字。</li><li>严格区分大小写，长度无限制。</li><li>不能包含空格。</li><li>与多数编程语言不同。Java 可以用任何 Unicode 字符（特殊字符除外）作为标识符，包括中文。但不推荐这么做。</li></ol><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><ol><li>包名：多单词组成时所有字母都小写：aaa.bbb.ccc</li><li>类名、接口名：多单词组成时，采用大驼峰法，所有单词的首字母大写：XxxYyyZzz</li><li>变量名、方法名：多单词组成时，采小驼峰法（驼峰法），第一个单词首字母小写，第二个开始每个单词首字母大写：xxxYyyZzz</li><li>常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ</li></ol><h1 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h1><p>为满足读取用户输入、输出的需求，Java 提供了几个基本类，通过 util 包导入</p><h3 id="输入-x2F-Scanner-类"><a href="#输入-x2F-Scanner-类" class="headerlink" title="输入&#x2F;Scanner 类"></a>输入&#x2F;Scanner 类</h3><p>在编程中，需要接收用户输入的数据，就可以使用键盘输入语句来获取。<code>Input.java</code> ，需要一个 扫描器（对象），就是 Scanner</p><p>使用过程：</p><ol><li>导入该类所在的包 import java.util.Scanner;</li><li>创建该类对象（声明变量）Scanner scanner &#x3D; new Scanner(System.in);</li><li>调用里面的功能，接收用户输入</li></ol><p>构造方法：</p><ul><li><code>new Scanner(System.in)</code>：该方法接收一个参数（输入源）。其中 <code>System.in</code> 代表标准输入流。默认情况指键盘。</li></ul><p>常用方法：</p><ul><li><p><code>String next()</code>：读取下一个输入对象</p><p>Scanner 对象用空白（空格、水平制表符或回车换行符）作为输入的分隔元素</p></li><li><p><code>Double nextDouble()</code>：读取下一个 double</p><p><code>Int nextInt()</code>：读取下一个 int</p></li><li><p><code>String nextLine()</code>：读入当前行的所有输入，直到行尾</p></li><li><p><code>boolean hasNext()</code>：输入中是否还有其他单词</p><p><code>boolean hasNextInt()</code>、<code>boolean hasNextDouble()</code></p></li></ul><h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><blockquote><p>System.out 标准输出流。调用该流方法以输出内容至控制台窗口</p></blockquote><ul><li><code>println()</code>：输出字符，结束后换行</li><li><code>print()</code>：输出字符，结束后不换行</li><li><code>printf(String format, Object ... args)</code>：格式化输出</li></ul><p>以 % 开头的 <em>格式说明符</em> 都用相应参数替换。格式说明符尾部的转换符表示要格式化的数值类型</p><table><thead><tr><th>转换符</th><th>类型</th><th>转换符</th><th>类型</th></tr></thead><tbody><tr><td>%d</td><td>十进制整数</td><td>%s</td><td>字符串</td></tr><tr><td>%x</td><td>十六进制整数</td><td>%c</td><td>字符</td></tr><tr><td>%o</td><td>八进制整数</td><td>%b</td><td>布尔值</td></tr><tr><td>%f</td><td>定点浮点数</td><td>%h</td><td>散列码</td></tr><tr><td>%e</td><td>指数浮点数</td><td>%tx</td><td>日期时间（T强制大写）</td></tr><tr><td>%g</td><td>通用浮点数</td><td>%%</td><td>百分号</td></tr><tr><td>%a</td><td>十六进制浮点数</td><td>%n</td><td>行分隔符</td></tr></tbody></table><p>也能指定控制格式化输出外观的各种标志</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 运算符 输入输出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java变量、数据类型</title>
      <link href="/2023/09/07/Java.%E5%8F%98%E9%87%8F/"/>
      <url>/2023/09/07/Java.%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><p>变量是程序的基本组成单位</p><p>变量的三个基本要素：类型 + 名称 + 值</p><blockquote><p>示例：<code>int a = 1</code>;  类型 int 名称 a 值 1</p></blockquote><p><strong>声明变量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方法1：</span><br><span class="line">int a;</span><br><span class="line">a = 100;</span><br><span class="line">方法2：</span><br><span class="line">int b = 100;</span><br></pre></td></tr></table></figure><h2 id="变量使用注意事项"><a href="#变量使用注意事项" class="headerlink" title="变量使用注意事项"></a>变量使用注意事项</h2><ol><li>变量表示内存中的一个存储区域。不同变量，不同类型，占用的空间大小不同。如 <code>int</code> 有 4 byte，而 <code>double</code> 有 8 byte。</li><li>该区域有自己的名称 <code>变量名</code> 和类型 <code>数据类型</code></li><li>变量必须先声明，后使用。</li><li>变量在同一作用域内不能重名。</li><li>该区域的数据 · 值可以在同一类型范围内变化。</li><li>变量的三个基本要素：类型 + 名称 + 值</li></ol><h1 id="Java-数据类型"><a href="#Java-数据类型" class="headerlink" title="Java 数据类型"></a>Java 数据类型</h1><h4 id="基本数据类型（8个）"><a href="#基本数据类型（8个）" class="headerlink" title="基本数据类型（8个）"></a>基本数据类型（8个）</h4><ul><li><strong>数值型</strong><ul><li>整数类型：<ul><li>byte：占用 1 字节</li><li>short：占用 2 字节</li><li>int：占用 4 字节</li><li>long：占用 8 字节</li></ul></li><li>浮点（小数）类型：<ul><li>float：占用 4 字节</li><li>double：占用 8 字节</li></ul></li></ul></li><li><strong>字符型</strong><ul><li>char：存放单个字符，占用 2 字节</li></ul></li><li><strong>布尔型</strong><ul><li>boolean：存放 true（真），false（假）。占用 1 字节</li></ul></li></ul><h4 id="引用数据类型（复合数据类型）"><a href="#引用数据类型（复合数据类型）" class="headerlink" title="引用数据类型（复合数据类型）"></a>引用数据类型（复合数据类型）</h4><ul><li><strong>类</strong>：class</li><li><strong>接口</strong>：interface</li><li><strong>数组</strong>：<code>[]</code></li></ul><p>引用数据类型存储一个地址，通过这个地址去内存中找值。</p><h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><blockquote><p>用于存放整数值</p></blockquote><ul><li><code>byte</code> 占用 1 字节，范围 -128 ~ 127</li><li><code>short</code> 占用 2 字节，范围 -2<sup>15</sup> ~ 2^15 - 1</li><li><code>int</code> 占用 4 字节，范围 -2^31 ~ 2^31 - 1</li><li><code>long</code> 占用 8 字节，范围 -2^63 ~ 2^63 - 1</li></ul><p><strong>使用细节：</strong></p><ol><li>Java 各整数类型有固定的范围和字符长度，不受具体 OS（操作系统）影响，以保证 Java 程序的可移植性。（Java 由 JVM实现运算，结构统一）</li><li>Java 默认整型常量为 <code>int</code> ，要声明 <code>long</code> 型常量必须后加 <code>l</code> 或 <code>L</code>。</li><li>从 Java 7 开始，加上前缀 <code>0b</code> 或 <code>0B</code> 就可以写二进制数。</li><li>从 Java 7 开始，可以为数字字面添加下划线。这不会影响数字的值，只是为了方便阅读。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int n = 0b0010;</span><br><span class="line">n = 0b001;</span><br><span class="line">n = 100_0_000000;</span><br><span class="line">n = 0B0000_0010_1100;</span><br><span class="line">float f = 1.0F;JAVA</span><br></pre></td></tr></table></figure><p>如果基本的整数、浮点类型不能满足范围、精度的需求，可以使用 “大数”</p><h2 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h2><blockquote><p>可以表示一个小数</p></blockquote><ul><li><code>float</code> 单精度（6 ~ 7 位有效数字），占用 4 字节，范围约 -3.403E38 ~ 3.403E38</li><li><code>double</code> 双精度（15 位有效数字），占用 8 字节，范围约 -1.798E308 ~ 1.798E308</li></ul><p><em>浮点数在机器中存放形式为：浮点数 &#x3D; 符号位 + 指数位 + 尾数位</em></p><p><em><strong>因此，尾数部分可能丢失，造成精度损失。换言之，小数都是近似值</strong></em></p><h3 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h3><ol><li><p>与整数类型相似，有固定的范围和字符长度，不受具体 OS（操作系统）影响。</p></li><li><p>Java 默认浮点常量为 <code>double</code> ，要声明 <code>float</code> 型常量必须后加 ”f“ 或 ”F“</p></li><li><p>浮点型常量有两种表示形式</p><blockquote><p>十进制数形式：<code>5.13</code>、<code>315.4F</code>、<code>.414</code></p><p>科学计数法：<code>5.12e2</code> 即[5.12 × 102]、<code>5.12E-2</code> 即[5.12 &#x2F; 102]</p></blockquote></li><li><p>通常情况下，应该使用 <code>double</code> 类型，以其更为精确。</p></li><li><p>浮点数使用陷阱：当我们对运算结果是小数的进行相对判断时，要小心。（因为<em><strong>小数都是近似值</strong></em>）</p><p>正确方法是：<strong>以两个数差值的绝对值，在某个精度范围内判断</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (Math.abs(num1 - num2) &lt; 0.00001) &#123;</span><br><span class="line">System.out.println(&quot;插值范围内认为相等&quot;);</span><br><span class="line">&#125;JAVA</span><br></pre></td></tr></table></figure></li><li><p>特殊的浮点类型常量</p><ul><li><p>正无穷大：<code>Float.POSITIVE_INFINITY</code>、<code>Double.POSITIVE_INFINITY</code></p><p>（浮点数运算中）一个正数除以 0，会得到该值</p></li><li><p>负无穷大：<code>Float.NEGATIVE_INFINITY</code>、<code>Double.NEGATIVE_INFINITY</code></p><p>（浮点数运算中）一个负数除以 0，会得到该值</p></li><li><p>0 &#x2F; 0：<code>Float.NaN</code>、<code>Double.NaN</code></p><p>（浮点数运算中）0 除以 0，会得到该值</p></li><li><p>最大、最小值：<code>Float.MAX_VALUE</code>、<code>Double.MIN_VALUE</code></p></li></ul></li><li><p>不能用运算符来比较特殊值，而要用特别的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">double num = 0.0 / 0;</span><br><span class="line">System.out.println(num == Double.NaN);// &lt;——— 始终为 false。不能如此比较</span><br><span class="line">System.out.println(Double.isNaN(num));// &lt;——— 判断是否是 NaN</span><br><span class="line">num = 1.0 / 0;</span><br><span class="line">System.out.println(Double.isInfinite(num));// &lt;——— 是否是无穷大JAVA</span><br></pre></td></tr></table></figure></li><li><p>由于不同处理器寄存浮点数的策略可能不同，浮点数运算的结果也可能不同。</p></li></ol><h2 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h2><blockquote><p>可以表示单个字符。（可以存放一个数字，因为其字符是数字编号的。输出时会输出数字对应的字符。”编码的概念“）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char c1 = &#x27;a&#x27;;` `char c2 = &#x27;\t&#x27;;` `char c3 = &#x27;字&#x27;;` `char c4 = 99;</span><br></pre></td></tr></table></figure></blockquote><h3 id="使用细节-1"><a href="#使用细节-1" class="headerlink" title="使用细节"></a>使用细节</h3><ol><li><p>字符常量用单引号括起 ‘字’</p></li><li><p><code>char</code> 的本质是一个整数，输出时，输出的是 unicode 码对应的字符</p><p>要输出那个整数，用 <code>int</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char c1 = &#x27;a&#x27;;</span><br><span class="line">System.out.println((int)c1);JAVA</span><br></pre></td></tr></table></figure></li><li><p><code>char</code> 是可以进行运算的，其相当于一个整数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 注：(int)&#x27;a&#x27; = 97</span><br><span class="line">char c1 = &#x27;a&#x27; + 1;// 相当于 char c1 = &#x27;b&#x27;</span><br><span class="line">System.out.println(&#x27;a&#x27; + 1);// 这个代码输出 98</span><br><span class="line">System.out.println(&quot;a&quot; + 1);// 这个代码输出 a1JAVA</span><br></pre></td></tr></table></figure></li><li><p>字符允许使用转义符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char c = &#x27;\u0041&#x27;;</span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure><p><strong>转义序列 \u 能出现在引号外。所有这些转义序列会在解析代码前得到处理</strong></p><ul><li><p>以下字符串是空串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;\u0022+\u0022&quot;;</span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure><p>因为 \u0022 表示引号。该代码等同于以下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;&quot; + &quot;&quot;;</span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure></li><li><p>以下注释会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// \u000A is a newline</span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure><p>因为 \u000A 是换行符。在解析前会得到处理。在程序看来，上述注释等于以下写法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// </span><br><span class="line">is a newlineJAVA</span><br></pre></td></tr></table></figure></li><li><p>以下注释也会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// look inside c:\users</span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure><p>因为程序认为，\users 不是一个合法的转义字符</p></li><li><p>在某些场合下这种写法似乎也能实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int\u005B\u005D a;// int[] a; 一个数组</span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="字符本质与编码表"><a href="#字符本质与编码表" class="headerlink" title="字符本质与编码表"></a>字符本质与编码表</h3><ul><li><p>字符类型的本质，是把字符对应的码值编程二进制，存储。显示时将二进制代码转化为码值，找到对应的字符。</p></li><li><p>字符与码值的对应关系是字符编码表规定的。</p><blockquote><p>ASCII 编码表，占用 1 byte，共有 128 个字符。</p><p>Unicode 编码表，占用 2 byte，字母汉字都占用 2 byte，这样可能浪费空间。0 - 127 的字符与 ASCII 相同，所以兼容 ASCII。</p><p>UTF-8 编码表，根据不同符号大小可变（1 - 6 byte），字母占用 1 byte，汉字占用 3 byte。是 Unicode 的改进，是互联网上使用最广的 Unicode 实现方式。</p><p>GBK 编码表，可以表示汉字，字母占用 1 byte，汉字占用 2 byte。</p><p>GB2312 编码表，可以表示汉字（GB2312 &lt; GBK）</p><p>BIG5 编码表，可以存放繁体中文（香港，台湾）</p></blockquote></li><li><p>UTF-16 编码采用不同长度的编码表示所有 Unicode 码点。包含从 U+0000 到 U+FFFF 的经典 Unicode 代码（16位，1 个代码单元），以及 U+10000 到 U+10FFFF 的辅助字符（32位，2 个代码单元）</p></li><li><p>在 Java 中，char 类型描述的是 UTF-16 编码中的 1 个代码单元。</p><p>字符串中的一个辅助字符（如 🎶）可能占用 2 个代码单元。这个场合，使用 char 可能会导致错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;🎶Melody🎶&quot;;</span><br><span class="line">char c = str.charAt(1);// &lt;———— 这个场合，c 是 🎶 符号的第二个代码单元而非 &#x27;M&#x27;JAVA</span><br></pre></td></tr></table></figure><p><strong>因此，一般不建议在程序中使用 char 类型</strong></p></li></ul><h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><blockquote><p><code>boolean</code> 只允许取值 <code>ture</code> 或 <code>false</code> ，没有 <code>null</code>。适用于逻辑运算，通常用于程序流程控制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if` `while` `do-while` `for</span><br></pre></td></tr></table></figure></blockquote><p><strong>使用细节：</strong></p><ol><li>不可以用 0 或 非0 的整数替代 <code>false</code> 或 <code>ture</code> 。这点和 C语言 不同。</li><li>不能让布尔类型转换为其他类型。如需转换，请使用如下方法：</li></ol><h1 id="基本数据类型转换"><a href="#基本数据类型转换" class="headerlink" title="基本数据类型转换"></a>基本数据类型转换</h1><h2 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h2><p>自动类型转换：Java 在进行赋值或运算时，精度（容量）小的类型自动转换为精度（容量）大的类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char &gt; int &gt; long &gt; float &gt; double</span><br><span class="line">byte &gt; short &gt; int &gt; long &gt; float &gt; double</span><br></pre></td></tr></table></figure><blockquote><p>例：<code>int a = &#39;c&#39;</code> 或者 <code>double b = 80</code></p></blockquote><p><strong>使用细节</strong></p><ol><li><p>有多种类型数据混合运算时，系统会将所有数据转换成容量最大的那种，再进行运算。</p></li><li><p>如若把大精度（容量）数据赋值给小精度（容量）类型，就会报错（小数由于精度原因，大赋小会丢失精度，必不可用。但整数大赋小时：1.赋予具体数值时，判断范围。2.变量赋值时，判断类型。反之进行自动类型转换。</p></li><li><p><code>byte</code> <code>short</code> <code>char</code> 三者不会相互自动转换，但可以计算。计算时首先转化为 <code>int</code>。</p><blockquote><p><code>byte a = 1;</code></p><p><code>byte b = 1;</code></p><p><code>a + b</code> 结果是 <code>int</code> 类型</p></blockquote></li><li><p><code>boolean</code> 类型不参与自动转换</p></li><li><p>自动提升原则：表达式结果的类型自动提升为操作数中最大的类型</p></li></ol><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>强制类型转换：自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时加上强制转换符 <code>( )</code> ，但<strong>可能造成精度降低或溢出</strong>，要格外注意。</p><blockquote><p>例：int a &#x3D; (int)(3 * 2.5 + 1.1 * 6);</p></blockquote><p> <strong>使用细节</strong></p><ol><li>当进行数据从大到小转换时，用强制转换。</li><li>强制转换只能对最近的操作数有效，往往会使用 <code>( )</code> 提升优先级。</li><li><code>char</code> 可以保留 <code>int</code> 的常量值，但不能保存其变量值。此时需要强制类型转换。</li><li><code>byte</code> <code>short</code> <code>char</code> 在进行运算时，当作 <code>int</code> 处理。</li></ol><h2 id="基本数据类型和-String-的转换"><a href="#基本数据类型和-String-的转换" class="headerlink" title="基本数据类型和 String 的转换"></a>基本数据类型和 <code>String</code> 的转换</h2><ol><li>基本类型转 <code>String</code>：基本数据类型加上 <code>&quot; &quot;</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int n1 = 100;</span><br><span class="line">String s = n1 + &quot;&quot;;</span><br><span class="line">System.out.println(n1 + &quot;&quot; + n1 + &quot;&quot; + n1 + &quot;&quot;);</span><br></pre></td></tr></table></figure><ol start="2"><li><code>String</code> 转基本数据类型：通过基本数据类型的包装类调用 <code>parseXX</code> 方法。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;100&quot;;</span><br><span class="line">int n1 = Interger parseInt(s);</span><br></pre></td></tr></table></figure><ol start="3"><li>特别的，把 <code>String</code> 转换为 <code>char</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char c = s.charAt(0);// 得到 s 字符串中的第一个字符。</span><br><span class="line">charAt（a）库函数，得到位序为a的字符</span><br></pre></td></tr></table></figure><h4 id="使用细节-2"><a href="#使用细节-2" class="headerlink" title="使用细节"></a>使用细节</h4><ol><li>将 <code>String</code> 转成基本数据类型时，要保证其能转换为有效数据。即不能把 <code>&quot;Hello&quot;</code> 转换成 <code>int</code>。</li><li>如果格式不正确，会抛出异常，程序会中止。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 变量 数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>丁奇MySql</title>
      <link href="/2023/09/05/%E4%B8%81%E5%A5%87MySql/"/>
      <url>/2023/09/05/%E4%B8%81%E5%A5%87MySql/</url>
      
        <content type="html"><![CDATA[<h1 id="Day1-讲基础架构：一条SQL查询语句是如何执行的"><a href="#Day1-讲基础架构：一条SQL查询语句是如何执行的" class="headerlink" title="Day1-讲基础架构：一条SQL查询语句是如何执行的"></a>Day1-讲基础架构：一条SQL查询语句是如何执行的</h1><p>平时我们使用数据库，看到的通常都是一个整体。比如，你有个最简单的表，表里只有一个ID字段，在执行下面这个查询语句时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from T where ID=10；</span><br></pre></td></tr></table></figure><p>我们看到的只是输入一条语句，返回一个结果，却不知道这条语句在MySQL内部的执行过程。</p><p>今天把MySQL拆解一下，看看里面都有哪些“零件”，</p><p>下面我给出的是MySQL的基本架构示意图，从中你可以清楚地看到SQL语句在MySQL的各个功能模块中的执行过程。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310081010377.png"></p><p>大体来说，MySQL可以分为<strong>Server层</strong>和<strong>存储引擎层</strong>两部分。</p><p>Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p><p>存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认存储引擎。</p><p>也就是说，你执行create table建表的时候，如果不指定引擎类型，默认使用的就是InnoDB。也可以通过指定存储引擎的类型来选择别的引擎，比如在create table语句中使用engine&#x3D;memory, 来指定使用内存引擎创建表。不同存储引擎的表数据存取方式不同，支持的功能也不同。</p><blockquote></blockquote><p>从图中不难看出，不同的存储引擎共用一个<strong>Server层</strong>，也就是从连接器到执行器的部分。</p><p>结合开头提到的那条SQL语句，走一遍整个执行流程，依次看下每个组件的作用。</p><h2 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h2><p>第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h$ip -P$port -u$user -p</span><br></pre></td></tr></table></figure><p>输完命令之后，你就需要在交互对话里面输入密码。虽然密码也可以直接跟在-p后面写在命令行中，但这样可能会导致你的密码泄露。如果你连的是生产服务器，强烈建议你不要这么做。</p><p>连接命令中的mysql是客户端工具，用来跟服务端建立连接。在完成经典的TCP握手后，连接器就要开始认证身份，这个时候用的就是你输入的用户名和密码。</p><ul><li>如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。</li><li>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</li></ul><p>这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限（当前链接）。修改完成后，只有再<strong>新建的连接</strong>才会使用新的权限设置。</p><p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在show processlist命令中看到它。文本中这个图是show processlist的结果，其中的Command列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310081037347.png"></p><p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数wait_timeout控制的，默认值是8小时。</p><p>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。</p><ul><li>长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。</li><li>短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</li></ul><p>建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。</p><p>但是全部使用长连接后，你可能会发现，有些时候MySQL占用内存涨得特别快，这是因为MySQL在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是MySQL异常重启了。</p><p>怎么解决这个问题呢？你可以考虑以下两种方案。</p><ol><li><p>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</p></li><li><p>如果你用的是MySQL 5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</p><p>造成影响如下：</p><ol><li>回滚活跃的事务并重新设置自动提交模式</li><li>释放所有表锁</li><li>关闭或删除所有的临时表</li><li>重新初始化会话的系统变量值</li><li>丢失用户定义的设置变量</li><li>释放prepare语句</li><li>关闭handler变量</li><li>将last_insert_id()值设置为0</li><li>释放get_lock（）获取的锁</li><li>清空通过mysql_bind_param()调用定义的当前查询属性</li></ol></li></ol><h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><blockquote><p>MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有这个功能了。</p></blockquote><p>连接建立完成后，你就可以执行select语句了。执行逻辑就会来到第二步：查询缓存。</p><p>MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端。（计网中也有类似的东西）</p><p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。</p><p><strong>但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。</strong></p><p>查询缓存的<strong>失效非常频繁</strong>，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。</p><p>很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。<strong>除非你的业务就是有一张静态表，很长时间才会更新一次</strong>。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p><p>好在MySQL也提供了这种“按需使用”的方式。你可以将参数query_cache_type设置成DEMAND，这样对于默认的SQL语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用SQL_CACHE显式指定，像下面这个语句一样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select SQL_CACHE * from T where ID=10；</span><br></pre></td></tr></table></figure><h2 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h2><p>如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL需要知道你要做什么，因此需要对SQL语句做解析。</p><p>分析器先会做“<strong>词法分析</strong>”。你输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么。</p><p>MySQL从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名T”，把字符串“ID”识别成“列ID”。</p><p>做完了这些识别以后，就要做“<strong>语法分析</strong>”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。</p><p>如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，比如下面这个语句select少打了开头的字母“s”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; elect * from t where ID=1;</span><br><span class="line"></span><br><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;elect * from t where ID=1&#x27; at line 1</span><br></pre></td></tr></table></figure><p>一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。</p><h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>经过了分析器，MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。</p><p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的join：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;</span><br></pre></td></tr></table></figure><ul><li>既可以先从表t1里面取出c&#x3D;10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。</li><li>也可以先从表t2里面取出d&#x3D;20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。</li></ul><p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</p><p>优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等等，后面的文章中单独展开说明优化器的内容。</p><h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。</p><p>开始执行的时候，要先判断一下你对这个表T有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示(在工程实现上，如果命中查询缓存，会在查询缓存放回结果的时候，做权限验证。查询也会在优化器之前调用precheck验证权限)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from T where ID=10;</span><br><span class="line"></span><br><span class="line">ERROR 1142 (42000): SELECT command denied to user &#x27;b&#x27;@&#x27;localhost&#x27; for table &#x27;T&#x27;</span><br></pre></td></tr></table></figure><p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</p><p>比如我们这个例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的：</p><ol><li>调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；</li><li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li><li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li></ol><p>至此，这个语句就执行完成了。</p><p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。</p><p>你会在数据库的慢查询日志中看到一个rows_examined的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。</p><p>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此<strong>引擎扫描行数跟rows_examined并不是完全相同的。</strong>我们后面会专门有一篇文章来讲存储引擎的内部机制，里面会有详细的说明。</p><h2 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h2><p>如果表T中没有字段k，而你执行了这个语句 select * from T where k&#x3D;1, 那肯定是会报“不存在这个列”的错误： “Unknown column ‘k’ in ‘where clause’”。你觉得这个错误是在我们上面提到的哪个阶段报出来的呢？</p><p>分析器</p><ol><li>MySQL的框架有几个组件, 各是什么作用?</li><li>Server层和存储引擎层各是什么作用?</li><li>you have an error in your SQL syntax 这个保存是在词法分析里还是在语法分析里报错?</li><li>对于表的操作权限验证在哪里进行?</li><li>执行器的执行查询语句的流程是什么样的?</li></ol><h1 id="D2-讲日志系统：一条SQL更新语句是如何执行的"><a href="#D2-讲日志系统：一条SQL更新语句是如何执行的" class="headerlink" title="D2-讲日志系统：一条SQL更新语句是如何执行的"></a>D2-讲日志系统：一条SQL更新语句是如何执行的</h1><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310081010377.png"></p><p>MySQL可以恢复到半个月内任意一秒的状态，这是怎样做到的呢？</p><p>我们还是从一个表的一条更新语句说起，下面是这个表的创建语句，这个表有一个主键ID和一个整型字段c：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T(ID int primary key, c int);</span><br></pre></td></tr></table></figure><p>如果要将ID&#x3D;2这一行的值加1，SQL语句就会这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update T set c=c+1 where ID=2;</span><br></pre></td></tr></table></figure><p>前面我有跟你介绍过SQL语句基本的执行链路，这里我再把那张图拿过来，你也可以先简单看看这个图回顾下。首先，可以确定的说，查询语句的那一套流程，更新语句也是同样会走一遍。</p><p>执行语句前要先连接数据库，这是连接器的工作。</p><p>前面我们说过，在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表T上所有缓存结果都清空。这也就是我们一般不建议使用查询缓存的原因。</p><p>接下来，分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用ID这个索引。然后，执行器负责具体执行，找到这一行，然后更新。</p><p>与查询流程不一样的是，更新流程还涉及两个重要的日志模块，它们正是我们今天要讨论的主角：redo log（重做日志）和 binlog（归档日志）。如果接触MySQL，那这两个词肯定是绕不过的，我后面的内容里也会不断地和你强调。不过话说回来，redo log和binlog在设计上有很多有意思的地方，这些设计思路也可以用到你自己的程序里。</p><h2 id="重要的日志模块：redo-log"><a href="#重要的日志模块：redo-log" class="headerlink" title="重要的日志模块：redo log"></a>重要的日志模块：redo log</h2><p>《孔乙己》这篇文章，酒店掌柜有一个粉板，专门用来记录客人的赊账记录。如果赊账的人不多，那么他可以把顾客名和账目写在板上。但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。</p><p>如果有人要赊账或者还账的话，掌柜一般有两种做法：</p><ul><li>一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉；</li><li>另一种做法是先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。</li></ul><p>在生意红火柜台很忙时，掌柜一定会选择后者，因为前者操作实在是太麻烦了。首先，你得找到这个人的赊账总额那条记录。你想想，密密麻麻几十页，掌柜要找到那个名字，可能还得带上老花镜慢慢找，找到之后再拿出算盘计算，最后再将结果写回到账本上。</p><p>这整个过程想想都麻烦。相比之下，还是先在粉板上记一下方便。你想想，如果掌柜没有粉板的帮助，每次记账都得翻账本，效率是不是低得让人难以忍受？</p><p>同样，在MySQL里也有这个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。为了解决这个问题，MySQL的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。</p><p>而粉板和账本配合的整个过程，其实就是MySQL里经常说到的WAL技术，WAL的全称是Write-Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。</p><p>具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。</p><p>InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么这块“粉板”总共就可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310081324101.png"></p><ul><li><p>write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p></li><li><p>write pos和checkpoint之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果write pos追上checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把checkpoint推进一下。</p></li></ul><p>有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<strong>crash-safe</strong>。</p><p>要理解crash-safe这个概念，可以想想我们前面赊账记录的例子。只要赊账记录记在了粉板上或写在了账本上，之后即使掌柜忘记了，比如突然停业几天，恢复生意后依然可以通过账本和粉板上的数据明确赊账账目。</p><h2 id="重要的日志模块：binlog"><a href="#重要的日志模块：binlog" class="headerlink" title="重要的日志模块：binlog"></a>重要的日志模块：binlog</h2><p>MySQL整体来看，其实就有两块：</p><ol><li>一块是Server层，它主要做的是MySQL功能层面的事情；</li><li>还有一块是引擎层，负责存储相关的具体事宜。</li></ol><p>上面我们聊到的粉板redo log是InnoDB引擎特有的日志，而Server层也有自己的日志，称为binlog（归档日志）。</p><p>我想你肯定会问，为什么会有两份日志呢？</p><p>因为最开始MySQL里并没有InnoDB引擎。MySQL自带的引擎是MyISAM，但是MyISAM没有crash-safe的能力，binlog日志只能用于归档。而InnoDB是另一个公司以插件形式引入MySQL的，既然只依靠binlog是没有crash-safe能力的，所以InnoDB使用另外一套日志系统——也就是redo log来实现crash-safe能力。</p><p>这两种日志有以下三点不同。</p><ol><li><p>redo log是InnoDB引擎特有的；</p><p>binlog是MySQL的Server层实现的，所有引擎都可以使用。</p></li><li><p>redo log是物理日志，记录的是“<strong>在某个数据页上做了什么修改</strong>”；</p><p>binlog是逻辑日志，记录的是这个<strong>语句的原始逻辑</strong>，比如“给ID&#x3D;2这一行的c字段加1 ”。</p></li><li><p>redo log是循环写的，空间固定会用完；</p><p>binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</p></li></ol><p>有了对这两个日志的概念性理解，我们再来看执行器和InnoDB引擎在执行这个简单的update语句时的内部流程。</p><ol><li>执行器先找引擎取 ID&#x3D;2 这一行。ID是主键，引擎直接用树搜索找到这一行。如果 ID&#x3D;2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li><li>执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li><li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。</li><li>执行器生成这个操作的binlog，并把binlog写入磁盘。</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。</li></ol><p>这里我给出这个update语句的执行流程图，图中浅色框表示是在InnoDB内部执行的，深色框表示是在执行器中执行的。</p><p><img src="https://static001.geekbang.org/resource/image/2e/be/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png"></p><p>你可能注意到了，最后三步看上去有点“绕”，将redo log的写入拆成了两个步骤：prepare和commit，这就是”两阶段提交”。</p><h2 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h2><p>为什么必须有“两阶段提交”呢？这是为了让两份日志之间的逻辑一致。要说明这个问题，我们得从文章开头的那个问题说起：<strong>怎样让数据库恢复到半个月内任意一秒的状态？</strong></p><p>binlog会记录所有的逻辑操作，并且是采用“追加写”的形式。如果你的DBA承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有binlog，同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。</p><p>当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做：</p><ul><li>首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库；</li><li>然后，从备份的时间点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时刻。</li></ul><p>这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去。</p><p>好了，说完了数据恢复过程，我们回来说说，为什么日志需要“两阶段提交”。这里不妨用反证法来进行解释。</p><p>由于redo log和binlog是两个独立的逻辑，如果不用两阶段提交，要么就是先写完redo log再写binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。</p><p>仍然用前面的update语句来做例子。假设当前ID&#x3D;2的行，字段c的值是0，再假设执行update语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了crash，会出现什么情况呢？</p><ol><li><strong>先写redo log后写binlog</strong>。假设在redo log写完，binlog还没有写完的时候，MySQL进程异常重启。由于我们前面说过的，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行c的值是1。<br>但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份日志的时候，存起来的binlog里面就没有这条语句。<br>然后你会发现，如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同。</li><li><strong>先写binlog后写redo log</strong>。如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日志。所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是1，与原库的值不同。</li></ol><p>可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。</p><p>你可能会说，这个概率是不是很低，平时也没有什么动不动就需要恢复临时库的场景呀？</p><p>其实不是的，不只是误操作后需要用这个过程来恢复数据。当你需要扩容的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用binlog来实现的，这个“不一致”就会导致你的线上出现主从数据库不一致的情况。</p><p>简单说，redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>今天，我介绍了MySQL里面最重要的两个日志，即物理日志redo log和逻辑日志binlog。</p><p>redo log用于保证crash-safe能力。innodb_flush_log_at_trx_commit这个参数设置成1的时候，表示每次事务的redo log都直接持久化到磁盘。这个参数我建议你设置成1，这样可以保证MySQL异常重启之后数据不丢失。</p><p>sync_binlog这个参数设置成1的时候，表示每次事务的binlog都持久化到磁盘。这个参数我也建议你设置成1，这样可以保证MySQL异常重启之后binlog不丢失。</p><p>我还跟你介绍了与MySQL日志系统密切相关的“两阶段提交”。两阶段提交是跨系统维持数据逻辑一致性时常用的一个方案，即使你不做数据库内核开发，日常开发中也有可能会用到。</p><p>文章的最后，我给你留一个思考题吧。前面我说到定期全量备份的周期“取决于系统重要性，有的是一天一备，有的是一周一备”。那么在什么场景下，一天一备会比一周一备更有优势呢？或者说，它影响了这个数据库系统的哪个指标？</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-物理层</title>
      <link href="/2023/06/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.4/"/>
      <url>/2023/06/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.4/</url>
      
        <content type="html"><![CDATA[<h1 id="物理层的基本概念"><a href="#物理层的基本概念" class="headerlink" title="物理层的基本概念"></a>物理层的基本概念</h1><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230606155648.png"></p><p>传输方式：在计算机网络中，用来连接各种网络设备的传输媒体种类众多，大致分为两类</p><ol><li>导引型传输媒体</li><li>非导引型传输媒体</li></ol><p>物理层协议的主要任务:</p><ol><li><p>机械特性</p><p>指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置。</p></li><li><p>电气特性</p><p>指明在接口电缆的各条线上出现的电压的范围。</p></li><li><p>功能特性</p><p>指明某条线上出现的某一电平的电压表示何种意义。</p></li><li><p>过程特性</p><p>指明对于不同功能的各种可能事件的出现顺序。</p></li></ol><p>物理连接方式：点对点，广播连接等。物理层协议种类比较多，每种物理层协议都包含了上述四个任务的具体内容。</p><blockquote><p>物理层考虑的是怎样才能在连接各种计算机的传输媒体,上传输数据比特流。</p></blockquote><p>物理层为数据链路层屏蔽了各种传输媒体的差异，使数据链路层只需要考虑如何完成本层的协议和服务,而不必考虑网络具体的传输媒体是什么。</p><h1 id="物理层下面的传输媒体"><a href="#物理层下面的传输媒体" class="headerlink" title="物理层下面的传输媒体"></a>物理层下面的传输媒体</h1><p>传输媒体大致分为两类</p><ol><li>导引型传输媒体</li><li>非导引型传输媒体</li></ol><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230606160834.png"></p><h2 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h2><h3 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h3><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230606161056.png"></p><ul><li>基带同轴电缆( 50 Ω )：数字传输，过去用于局域网</li><li>宽带同轴电缆( 75 Ω )：模拟传输，目前主要用于有线电视</li></ul><p>同轴电缆价格较贵且布线不够灵活和方便，随着集线器的出现，在局域网领域基本上都是采用双绞线作为传输媒体。</p><h3 id="双绞线（网线）"><a href="#双绞线（网线）" class="headerlink" title="双绞线（网线）"></a>双绞线（网线）</h3><p>把两根相互绝缘的铜导线并排放在一起。然后按照一定规则绞合起来就构成了双绞线</p><p>绞合的作用：</p><ol><li>抵御部分来自外界的电磁波干扰</li><li>减少相邻导线的电磁干扰</li></ol><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230606161428.png"></p><h3 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h3><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230606161524.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230606162348.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230606162429.png"></p><p>工作原理：当光从高折射率的媒体射向低折射率的媒体时，其折射角将大于入射角;因此，如果入射角足够大，就会出现全反射，即光碰到包层时，就会反射回纤芯。</p><p>纤芯直径：</p><ol><li>多模光纤：50微米，62.5微米</li><li>单模光纤：9微米</li></ol><p>工作波长：</p><ol><li>0.85微米</li><li>1.3 微米</li><li>1.55微米</li></ol><p>光纤优点：</p><ol><li>通信容量大(25000~ 30000GHz的带宽)</li><li>传输损耗小，远距离传输时更加经济。</li><li>抗雷电和电磁子扰性能好。这在大电流脉冲抗雷电和电磁子扰性能好。这在大电流脉冲</li><li>无串音干扰，保密性好，不易被窃听。</li><li>体积小，重量轻。</li></ol><p>光纤缺点：</p><ol><li>割接需要专用设备</li><li>光电接口贵</li></ol><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230606162621.png"></p><p>多模光纤：</p><p>由于色散(模式、材料、波导色散)， 光在多模光纤中传输一定距离后必然产生信号失真(脉冲展宽)</p><p>因此，多模光纤只适合近距离传输(建筑物内)</p><p>发送光源:发光二极管;接收检测:光电二极管</p><p>单模光纤：</p><p>没有模式色散，在1 .31微米波长附近材料色散和波导色散大小相等符号相反，两者正好抵消。</p><p>单模光纤适合长距离传输且衰减小，但其制造成本高，对光源要求高。</p><p>发送光源:发光二极管;接收检测:光电二极管</p><h3 id="电力线"><a href="#电力线" class="headerlink" title="电力线"></a>电力线</h3><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230606163002.png"></p><p>应用电力线传输信号的实例最早是电力线电话。</p><h2 id="非导引型传输媒体"><a href="#非导引型传输媒体" class="headerlink" title="非导引型传输媒体"></a>非导引型传输媒体</h2><h3 id="微波"><a href="#微波" class="headerlink" title="微波"></a>微波</h3><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230606163144.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230606163313.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230606163449.png"></p><p>微波是直线传播，一般只有五十公里左右，为了实现远距离通信，必须在一条微波通信信道的两个终端之间建立若干个中继站。中继站将前一站送来的信号经过放大后再发送到下一站。称为“接力”。传播时延大</p><h3 id="红外线"><a href="#红外线" class="headerlink" title="红外线"></a>红外线</h3><p>红外线属于点对点无线传输，直线传输，中间不能有障碍物，传输距离短，传输速率低(4Mb&#x2F;s~ 16Mb&#x2F;s)。</p><h3 id="可见光"><a href="#可见光" class="headerlink" title="可见光"></a>可见光</h3><p>LIFI：一种新型光传播方式，还在实验阶段。</p><h1 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h1><p>串行传输：是一个比特一个比特传输，因此发送端和传输端之间<strong>只需要一条数据传输线路</strong>即可。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230606164310.png"></p><p>并行传输：是指一次性传输多个比特，而不是一个比特。接发收端<strong>有 n 条传输线路</strong>。速度是串行传输的n倍，但是成本高。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230606164452.png"></p><p><strong>计算机内部</strong>常采用<strong>并行传输</strong>的方式（总线）</p><p>计算机之间常采用<strong>串行传输</strong>的方式</p><blockquote><p>远距离传输是串行传输，计算机内部传输是并行传输，常见的数据总线宽度有 8 位，16位，32 位和 64 位。</p></blockquote><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230606164650.png"></p><p>同步传输：发送端发送连续不间断的信号，接收端按照时钟频率进行接收，因为接发收端频率不同步，所以会产生一定的时钟误差，那么要需要一些方式来使时钟保持同步。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230606164918.png"></p><p>由于不同设备的时钟频率存在一定差异，在传输大量数据的过程中，肪产生的判别刻的累计误差会导致接收端对批特信导的判别错位。</p><p>实现收发双方时钟同步的方法：</p><ol><li><p>外同步：两条信号线，一条接收数据信号，一条接收时钟频率信号。</p></li><li><p>内同步：发送端将时钟同步信号编码和发送数据一同发送（传统以太网所采用的就是曼彻斯特编码。）</p></li></ol><p>异步传输：发送数据是有间隔不联系的，接收端仅在每个字节的起始处对字节内的比特实现同步。为此，通常要在每个字节前后分别加上起始位和结束位</p><p><img src="C:\Users\CWL25\AppData\Roaming\Typora\typora-user-images\image-20230606165209094.png" alt="image-20230606165209094"></p><p>异步：字节之间异步(字节之间的时间间隔不固定)，字节中的每个比特仍然要同步(各比特的持续时间是相同的)</p><p>单向通信(单工)：通信双方只有一个数据传输方向。只需要一条信道</p><p>例如。无线电广播采用的就是这种通信方式。</p><p>双向交替通信(半双工)：通信双方可以相互传输数据。但不能同时进行。需要两条信道，来去各一条</p><p>例如。对讲机采用的就是这种通信方式</p><p>双向同时通信(全双工)：通信双方可以同时发送和接收信息。需要两条信道，来去各一条</p><p>例如。 电话采用的就是这种通信方式</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230606171651.png"></p><h1 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h1><p>计算机需要处理和传输用户的文字。图片。音频和视频。它们可以统称为消息。</p><p>信导是数据的电磁表现。由信源发出的原始电信导称为基带信号。</p><p>基带信导可分为两类：</p><ol><li>数字基带信号。例如，计算机内部CPU与内存之间传输的信导。</li><li>模拟基带信号。例如，麦克风收到声音局产生的音频信号</li></ol><p>信号需要在信道中进行传输。</p><p>信道可分为数字信道和模拟信道两种。</p><p>在不改变信导性质的前提下，仅对数字基带信的波开形进行变换。称为编码。编码后产生的信号仍为数字信导，可以在数字信道中传输。</p><p>把数字基带信号的频率范围，搬移到较高的频段。并转换为模拟信导，称为调制。调制后产生的信导是模拟信号，可以在模拟信道中传输。</p><p>例如。WIF使用补码键控、直接序列扩频、正交频分复用等调制方法。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230606172637.png"></p><p>传输媒体和信道不能直接划等号。对于单工传输，传输媒体中只包含一个信道。要么是发送信道，要么是接收信道。对于半双工和全双工传输。传输媒体中要包含两个信道。一个是发送信道，咼个是接收信道。如果使用信道复用技术。一条传输媒体还可以包含多个信道。</p><p>码元：在使用时间域的波形表示数字信号时,代表不同离散数值的基本波形。</p><h2 id="编码与调制-1"><a href="#编码与调制-1" class="headerlink" title="编码与调制"></a>编码与调制</h2><h3 id="常用编码"><a href="#常用编码" class="headerlink" title="常用编码"></a>常用编码</h3><p>不归零编码：不归零，就是指在整个码元时间肉，电平不会出现零电平</p><p>归零编码</p><p>曼彻斯特编码</p><p>差分曼彻斯特编码</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230606173840.png"></p><h3 id="基本调制方法"><a href="#基本调制方法" class="headerlink" title="基本调制方法"></a>基本调制方法</h3><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230606174456.png"></p><p>因为频率和相位是相关的，即频率是相位随时间的变化率。所以一次只能调制频率和相位两个中的-一个。</p><p>通常情况下，相位和振幅可以结合起来一起调制， 称为正交振幅调制QAM。</p><p>正交振幅调制QAM：</p><p>QAM-16：12种相位，每种相位有1或2种振幅可选，可以调制出16种码元(波形)，每种码元可以对应表示4个比特，每个码元与4个比特的对应关系不能随便定义。码元与4个比特的对应关系采用格雷码</p><h1 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h1><p>码间串扰：信号在传输过程中或受到各种因素的影响，一个数字信号通过实际的信道后，波形会产生失真，在失真不严重时，在输出端还可根据已失真的波形还原出发送的码元。在失真严重时，很难判断这个信号是什么时候是 1，什么时候是 0，信号波形失去了码元之间的清晰界限。</p><p>失真因素：</p><ol><li><p>码元传输速率</p></li><li><p>信号传输距离</p></li><li><p>噪声干扰</p></li><li><p>传输媒体质量</p></li></ol><p>奈氏准则：在假定的理想条件下，为了避免码间串扰，码元传输速率是有上限的。</p><p>理想低通信道的最高码元传输速率&#x3D; 2W Baud &#x3D; 2W 码元&#x2F;秒</p><p>理想带通信道的最高码元传输速率&#x3D; W Baud &#x3D; W 码元&#x2F;秒</p><p>W ：信道带宽(单位为Hz)</p><p>Baud ：波特，即码元&#x2F;秒</p><p>码元传输速率又称为波特率、调制速率、波形速率或符号速率。它与比特率有一定关系:</p><ol><li>当1个码元只携带1比特的信息量时，则波特率(码元&#x2F;秒)与比特率(此特&#x2F;秒)在数值上是相等的;</li><li>当1个码元携带n比特的信息量时，则波特率转换成比特率时,数值要乘以n。</li></ol><p>要提高信息传输速率(比特率)，就必须设法使每一个码元能携带更多个比特的信息量。这需要采用多元制。</p><p>实际的信道所能传输的最高码元速率，要明显低于奈氏准则给出的这个，上限数值。</p><p><strong>香农公式</strong>：带宽受限且有高斯白噪声干扰的信道的极限信息传输速率。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230606182307.png"><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230606182141.png"></p><p>信道带宽或信道中信噪比越大，信息的极限传输速率越高。</p><p>在实际信道上能够达到的信息传输速率要比该公式的极限传输速率低不少。这是因为在实际信道中，信号还要受到其他些损伤，如各种脉冲干扰、信号在传输中的衰减和失真些损伤，如各种脉冲干扰、信号在传输中的衰减和失真</p><p>在信道带宽一定的情况下， 根据奈氏准则和香农公式，要想提高信息的传输速率就必须采用多元制(更好的调制方法)和努力提高信道中的信噪比。</p><p>自从香农公式发表后，各种新的信号处理和调制方法就不断出现，其目的都是为了尽可能地接近香农公式给出的传输速率极限。</p><p>不管题目给出的调制技术多么“牛或对于我们而言有多陌生，这都不会影响我们解题。我们只需关心这种调制技术可以调制我们只需关心这种调制技术可以调制</p><h1 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h1><p>复用(Multiplexing) 就是在一条传输媒体.上同时传输多路用户的信号。</p><p>当一条传输媒体的传输容量大于多条信道传输的总容量时，就可以通过复用技术，在这条传输媒体上建立多条通信信道,以便充分利用传输媒体的带宽。</p><p>尽管实现信道复用会增加通信成本(需要复用器、分用器以及费用较高的大容量共享信道) ,但如果复用的信道数量较大，还是比较划算的。</p><h2 id="常见的信道复用技术"><a href="#常见的信道复用技术" class="headerlink" title="常见的信道复用技术"></a>常见的信道复用技术</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230606183608.png"></p><p>FDM：将传输媒体的总频带划分成多个子频带，每个子频带作为一个通信子信道，每对用户使用其中的一个子信道进行通信，各子信道之间需要留出隔离频带，以免造成子信道间的干扰，频分复用的所有用户同时占用不同的频带资源发送数据 。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230606183758.png"></p><p>频分复用的所有用户同时占用不同的频带资源发送数据</p><p>TDM：将时间划分为一段段等长的时隙，每一个时分复用的用户，在其相应时隙内，独占传输媒体的资源进行通信，时分复用的各用户所对应的时隙就构成了时分复用帧。每个用户占用的时隙是周期性的，其周期就是 TDM 帧的长度。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230606183925.png"></p><blockquote><p>TDM帧实际上是一段固定长度的时间，它与数据链路层对等实体间逻辑通信的”帧”是完全不同的概念。</p></blockquote><p>时分复用的所有用户在不同的时间占用同样的频带进行通信</p><p>WDM：就是光的频分复用，由频分复用的设计思想，可在一根光纤上同时传输多个频率（波长）相近的光载波信号，实现基于光纤的频分复用技术。</p><blockquote><p>目前可以在一根光纤上复用 80 路或更多路的光载波信号。因此，这种复用技术也称为密集波复用 DWDM。</p></blockquote><p>下图是其物理意义</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230606184142.png"></p><p>铺设光缆的工程耗资巨大，应尽量在一根光缆中放入尽可能多的光纤，然后对每一根光纤使用密集波分复用技术。</p><p>CDM：它是在扩频通信技术的基础上发展起来的一种无线通信技术。与<strong>频分复用</strong>和<strong>时分复用</strong>不同，码分多址的每个用户可以<strong>在相同的时间使用相同的频带进行通信</strong>。</p><p>码分多址最初用于军事通信，这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。随着技术的进步，码分多址设备的价格和体积都大幅度下降，因而现在已广泛用于民用的移动通信中。</p><p>码分多址将每个比特时间划分成为 m 个更短的时间片，称为<strong>码片</strong>。M 的取值通常为 64 或 128.为了简单起见，在后续的举例中，我们假设 m 分取值为 8。码分多址中的每个站点都被指派一个唯一的 <strong>m 比特码片序列。</strong>某个站要<strong>发送比特 1</strong>，则发送它自己的 <strong>m 比特码片序列</strong>。某个站要发送<strong>比特 0</strong>，则发送它自己的 <strong>m 比特码片序列的反码</strong>。</p><p>如果有两个或多个站同时发送数据，则信道中的信号就是这些站各自所发送一系列码片序列或码片序列反码的叠加，为了从信道中分离出每个站的信号，给每个站指派码片序列时，必须遵循以下原则：</p><ol><li>分配给每个站的<strong>码片序列必须各不相同</strong>，实际常采用伪随机码序列。</li><li>分配给每个站的<strong>码片序列必须相互正交</strong>，即各码片序列相应的码片向量之间的<strong>规格化内积为 0</strong></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-线性表</title>
      <link href="/2023/06/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.2/"/>
      <url>/2023/06/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.2/</url>
      
        <content type="html"><![CDATA[<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="线性表定义"><a href="#线性表定义" class="headerlink" title="线性表定义"></a>线性表定义</h2><p>线性表是具有<strong>相同数据类型</strong>的n (n≥0) 个数据元素的有限序列，其中n为表长，当n&#x3D; 0时线性表是一个空表。若用L命名线性表，则其一般表示为：L &#x3D; （a1 ,a2 ,a3 …  ,an ,）</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230624160546.png"></p><p>ai是线性表中的“第i个”元素线性表中的位序,a1是表头元素 ,an 是表尾元素</p><p>除第一个元素外，每个元素有且仅有一个直接前驱:除最后一个元素外，每个元素有且仅有一个直接后继</p><h2 id="线性表基本操作"><a href="#线性表基本操作" class="headerlink" title="线性表基本操作"></a>线性表基本操作</h2><p>InitList(&amp;L):初始化表。构造-一个空的线性表L，分配内存空间。</p><p>DestroyList(&amp;L);销毁操作。销毁线性表，并释放线性表L所占用的内存空间。</p><p>ListInsert(&amp;L,i,e):插入操作。在表L中的第i个位置上插入指定元素e。</p><p>ListDelete(&amp;L,&amp;e):删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。</p><p>LocateElem():按值查找操作。在表L中查找具有给定关键字值的元素。</p><p>GetElem(,):按位查找操作。获取表L中第1个位置的元素的值。</p><p>其他常用操作:</p><p>Length(L):求表长。返回线性表L的长度，即L中数据元素的个数。</p><p>PrintList(L):输出操作。按前后顺序输出线性表L的所有元素值。</p><p>Empty(L):判空操作。若l为空表，则返回true,否则返回false.</p><blockquote><p>对数据的操作(记忆思路)：创销、增删改查</p></blockquote><h2 id="线性表实现-顺序表（顺序存储）"><a href="#线性表实现-顺序表（顺序存储）" class="headerlink" title="线性表实现-顺序表（顺序存储）"></a>线性表实现-顺序表（顺序存储）</h2><p>顺序表：用顺序存储的方式实现线性表</p><blockquote><p>顺序存储：把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。</p></blockquote><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230624160546.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230624163153.png"></p><h3 id="顺序表的实现"><a href="#顺序表的实现" class="headerlink" title="顺序表的实现"></a>顺序表的实现</h3><p>静态分配</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230624164126.png"></p><p>动态分配</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230625125620.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230625125704.png"></p><p>顺序表特点</p><ol><li>随机访问，即可以在0(1)时间内找到第i个元素</li><li>存储密度高，每个节颜存储数据元素</li><li>拓展容量不方便(即便采用动态分配的方式实现，拓展长度的时间复杂度也比较高)</li><li>插入、删除操作不方便，需要移动大量元素</li></ol><h2 id="线性表实现-链表（链式存储）"><a href="#线性表实现-链表（链式存储）" class="headerlink" title="线性表实现-链表（链式存储）"></a>线性表实现-链表（链式存储）</h2>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-绪论</title>
      <link href="/2023/06/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.1/"/>
      <url>/2023/06/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.1/</url>
      
        <content type="html"><![CDATA[<h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><h2 id="数据-Data"><a href="#数据-Data" class="headerlink" title="数据(Data)"></a>数据(Data)</h2><p>数据：是能输入计算机且能被计算机处理的各种符号的集合</p><p>包括:</p><ol><li>数值型的数据:整数、实数等</li><li>非数值型的数据:文字、图像、图形、声音</li></ol><h2 id="数据元素-Data-Element"><a href="#数据元素-Data-Element" class="headerlink" title="数据元素(Data Element)"></a>数据元素(Data Element)</h2><p>数据元素：是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理。也简称为<strong>元素</strong>，或称为<strong>记录</strong>、结点或<strong>顶点</strong>。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230605180351.png"></p><h2 id="数据项-Data-Item"><a href="#数据项-Data-Item" class="headerlink" title="数据项(Data Item)"></a>数据项(Data Item)</h2><p>数据项：构成数据元素的不可分割的最小单位。</p><blockquote><p>数据、数据元素、数据项三者之间的关系：</p><p>数据 &gt; 数据元素 &gt; 数据项</p></blockquote><h2 id="数据对象-Data-Object"><a href="#数据对象-Data-Object" class="headerlink" title="数据对象(Data Object)"></a>数据对象(Data Object)</h2><p>数据对象：是性质相同的数据元素的集合，是数据的一个子集。</p><p>例如:</p><ul><li>整数数据对象是集合N&#x3D;{0， +1， +2， …</li><li>字母字符数据对象是集合C&#x3D;{‘A’，’B’，’Z’}</li><li>学籍表也可看作一个数据对象</li></ul><p>数据元素：组成数据的基本单位</p><p>与数据的关系:是集合的个体</p><p>数据对象：性质相同的数据元素的集合</p><p>与数据的关系是:集合的子集</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>数据元素不是孤立存在的，它们之间存在着某种关系，<strong>数据元素相互之间的关系称为结构</strong>( Structure )<br>，是指<strong>相互之间存在一种或多种特定关系</strong>的数据元素集合。或者说，数据结构是<strong>带结构的</strong>数据元素的集合</p><p>数据结构包括以下三个方面的内容:</p><ol><li>数据元素之间的<strong>逻辑关系</strong>，也称为<strong>逻辑结构</strong>。</li><li>数据元素及其关系在<strong>计算机内存中的表示</strong>(又称为<strong>映像</strong>)， 称为数据的<strong>物理结构</strong>或数据的<strong>存储结构</strong>。</li><li>数据的<strong>运算和实现</strong>，即对数据元素可以施加的操作以及这些操作在相应的存储结构上的实现。</li></ol><p>逻辑结构</p><ul><li>描述数据元素之间的逻辑关系</li><li>与数据的存储无关，独立于计算机</li><li>是从具体问题抽象出来的数学模型</li></ul><p>物理结构</p><ul><li>数据元素及其关系在计算机存储器中的结构(存储方式)</li><li>是数据结构在计算机中的表示</li></ul><p>逻辑结构与存储结构的关系:</p><ul><li>存储结构是逻辑关系的映象与元素本身的映象。</li><li>逻辑结构是数据结构的抽象，存储结构是数据结构的实现</li></ul><h2 id="逻辑结构的种类"><a href="#逻辑结构的种类" class="headerlink" title="逻辑结构的种类"></a>逻辑结构的种类</h2><p>划分一：</p><ol><li>线性结构（一对一）</li></ol><p>有且仅有一一个开始和一个终端结点，并且所有结点都最多只有一个直接前趋和一个直接后继。<br>例如：线性表、栈、队列、串</p><ol start="2"><li>非线性结构（一对多  多对多）</li></ol><p>一个个结点可能有多个直接前趋和直接后继<br>例如:树、图</p><p>划分方式二一四类基本逻辑结构</p><ol><li>集合结构:结构中的数据元素之间除了同属于一个集合的关系外，无任何其它关系。</li><li>线性结构:结构中的数据元素之间存在着一对一的线性关系。</li><li>树形结构:结构中的数据元素之间存在着一对多的层次关系。</li><li>图状结构或网状结构:结构中的数据元素之间存在着多对多的任意关系。</li></ol><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230605180429.png"></p><h2 id="存储结构的种类"><a href="#存储结构的种类" class="headerlink" title="存储结构的种类"></a>存储结构的种类</h2><p>四种基本的存储结构:</p><ol><li><p>顺序存储结构<br>用一组连续的存储单元依次存储数据元素，数据元素之间的逻辑关系由元素的存储位置来表示。</p></li><li><p>链式存储结构<br>用一组任意的存储单元存储数据元素，数据元素之间的逻辑关系用指针来表示。</p></li><li><p>索引存储结构<br>在存储结点信息的同时，还建立附加的索引表。</p></li><li><p>散列存储结构<br>根据结点的关键字直接计算出该结点的存储地址。</p></li></ol><h1 id="数据类型和抽象数据类型"><a href="#数据类型和抽象数据类型" class="headerlink" title="数据类型和抽象数据类型"></a>数据类型和抽象数据类型</h1><p>在使用高级程序设计语言编写程序时，必须对程序中出现的每个变量、常量或表达式，明确说明它们所属的数据类型。</p><p>一些最基本数据结构可以用数据类型来实现，如数组、字符串等;而另一些常用的数据结构，如栈、队列、树、图等，不能直接用数据类型来表示。</p><p>高级语言中的数据类型明显地或隐含地规定了在程序执行期间变量和表达的所有可能的取值范围，以及在这些数值范围上所允许进行的操表达的所有可能的取值范围，以及在这些数值范围上所允许进行的操作。</p><ul><li>例如，C语言中定义变量i为int类型，就表示i是[-min,max]范围的整数，在这个整数集上可以进行+、一、*、\、 %等操作</li></ul><p>数据类型的作用：</p><ol><li>约束变量或常量的取值范围。</li><li>约束变量或常量的操作。</li></ol><h2 id="数据类型-Data-Type"><a href="#数据类型-Data-Type" class="headerlink" title="数据类型(Data Type)"></a>数据类型(Data Type)</h2><p>定义:数据类型是一组性质相同的值的集合以及定义于这个值集合上的一组操作的总称。</p><p><strong>数据类型 &#x3D; 值的集合 + 值集合上的一组操作</strong></p><h2 id="抽象数据类型-Abstract-Data-Type-ADT"><a href="#抽象数据类型-Abstract-Data-Type-ADT" class="headerlink" title="抽象数据类型(Abstract Data Type, ADT)"></a>抽象数据类型(Abstract Data Type, ADT)</h2><p>是指一个数学模型以及定义在此数学模型.上的一-组操作。</p><p>包括：</p><ol><li>由用户定义，从问题抽象出数据模型(逻辑结构)</li><li>还包括定义在数据模型上的一组抽象运算(相关操作)</li><li>不考虑计算机内的具体存储结构与运算的具体实现算法</li></ol><h3 id="抽象数据类型的形式定义"><a href="#抽象数据类型的形式定义" class="headerlink" title="抽象数据类型的形式定义"></a>抽象数据类型的形式定义</h3><p>抽象数据类型可用(D, S, P)三元组表示</p><ol><li>D 是数据对象</li><li>S是 D 上的关系集</li><li>P是对 D 的基本操作集</li></ol><h1 id="算法和算法分析"><a href="#算法和算法分析" class="headerlink" title="算法和算法分析"></a>算法和算法分析</h1><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/Snipaste_2023-06-04_16-03-53.png"></p><p>算法的定义：</p><p>对特定问题求解方法和步骤的一种描述，它是指令的有限序列。其中每个指令表示一个或多个操作。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/Snipaste_2023-06-04_16-05-06.png"></p><p>算法的描述</p><ol><li>自然语言：英语、中文</li><li>流程图：传统流程图、NS流程图</li><li>伪代码：类语言：C语言（最常见）</li><li>程序代码: C语言程序、JAVA语言程….</li></ol><p>算法与程序：</p><ul><li>算法是解决问题的一种方法或一个过程， 考虑如何将输入转换成输出,一个问题可以有多种算法。</li><li>程序是用某种程序设计语言对算法的具体实现。</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/Snipaste_2023-06-04_16-07-46.png"></p><h2 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h2><p>一个算法必须具备以下五个重要特性：</p><ol><li>有穷性：一个算法必须总是在执行有穷步之后结束，且每一步都在有穷时间内完成。</li><li>确定性：算法中的每一条指令必须有确切的含义，没有二_义性，在任何条件下，只有唯一的一条执行路径，即对于相同的输入只能得到相同的输出。</li><li>可行性：算法是可执行的，算法描述的操作可以通过已经实现的基本操作执行有限次来实现。</li><li>输入：一个算法有零个或多个输入。</li><li>输出：一个算法有一个戴多个输出。</li></ol><h2 id="算法设计的要求"><a href="#算法设计的要求" class="headerlink" title="算法设计的要求"></a>算法设计的要求</h2><ol><li>正确性(Correctness)<br><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/Snipaste_2023-06-04_16-10-15.png"></li><li>可读性(Readability)<br><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/Snipaste_2023-06-04_16-10-36.png"></li><li>健壮性(Robustness)<br><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/Snipaste_2023-06-04_16-10-53.png"></li><li>高效性(Efficiency)<br><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/Snipaste_2023-06-04_16-11-42.png"></li></ol><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>一个好的算法首先要具备正确性，然后是健壮性，可读性，在几个方面都满足的情况下，主要考虑算法的效率，通过算法的效率高低来评判不同算法的优劣程度。</p><p>算法效率以下两个方面来考虑：</p><ol><li><p>时间效率:指的是算法所耗费的时间;</p></li><li><p>空间效率:指的是算法执行过程中所耗费的存储空间。</p></li></ol><blockquote><p>时间效率和空间效率有时候是矛盾的。</p></blockquote><h3 id="算法时间效率的度量"><a href="#算法时间效率的度量" class="headerlink" title="算法时间效率的度量"></a>算法时间效率的度量</h3><p>算法时间效率可以用依据该算法编制的程序在计算机上执行所消耗的时间来度量。</p><p>两种度量方法：</p><ol><li>事后统计：将算法实现,测算其时间和空间开销。</li><li>事前分析：对算法所消耗资源的一种估算方法。</li></ol><h4 id="事前分析方法"><a href="#事前分析方法" class="headerlink" title="事前分析方法"></a>事前分析方法</h4><p>一个算法的运行时间是指一个算法在计算机上运行所耗费的时间大致可以等于计算机执行一种简单的操作(如赋值、比较、移动等)所需的时间与算法中进行的简单操作次数乘积。</p><p><strong>算法运行时间 &#x3D; 一个简单操作所需的时间 x 简单操作次数</strong></p><p>也即算法中每条语句的执行时间之和</p><p>算法运行时间 &#x3D; ∑ 每条语句的执行次数（语句频度） x 该语句执行一次所需的时间</p><p>我们把算法所耗费的时间定文为该算法中每条语句的频度之和，算法的时间消耗记为 T(n)</p><p>为了便于比较不同算法的时间效率，我们仅比较它们的<strong>数量级</strong>。记作T(n)&#x3D;O(f(n))，称O(f(n))为算法的<strong>渐进时间复杂度</strong> (O是数量级的符号)，简称<strong>时间复杂度</strong>。</p><p>最坏时间复杂度:指在最坏情况下，算法的时间复杂度。</p><p>平均时间复杂度:指在所有可能输入实例在等概率出现的情况下，算法的期望运行时间。</p><p>最好时间复杂度:指在最好情况下，算法的时间复杂度。</p><blockquote><p>一般总是考虑在最坏情况下的时间复杂度，以保证算法的运行时间不会比它更长。</p></blockquote><p>对于复杂的算法，可以将它分成几个容易估算的部分，然后利用大O 加法法则和乘法法则，计算算法的时间复杂度: </p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/Snipaste_2023-06-04_16-30-41.png"></p><h3 id="渐进空间复杂度"><a href="#渐进空间复杂度" class="headerlink" title="渐进空间复杂度"></a>渐进空间复杂度</h3><p>空间复杂度:算法所需存储空间的度量，</p><p>记作：S(n)&#x3D;O(f(n))  其中n为问题的规模(或大小) </p><p>算法要占据的空间：</p><ol><li>算法本身要占据的空间，输入&#x2F;输出，指令，常数，变量等</li><li>算法要使用的辅助空间</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-运输层</title>
      <link href="/2023/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.3/"/>
      <url>/2023/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.3/</url>
      
        <content type="html"><![CDATA[<h1 id="数据传输过程"><a href="#数据传输过程" class="headerlink" title="数据传输过程"></a>数据传输过程</h1><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514152751.png"></p><p>数据沿图中止下多次的虚线方向传送的</p><p>运输层直接为应用进程间的逻辑通信提供服务</p><p>运输层向高层用户屏蔽了下面网络核心的细节(如网络拓扑、所采用的路由选择协议等) ，它使应用进看见的就好像是在两个运输层实体之间有一条端到端的逻辑通信信道。根据应用需求的不同，因特网的运输层为应用层提供了两种不同的运输协议，即<strong>面向连接的TCP</strong>和<strong>无连接的UDP</strong>，这两种协议就是本章要讨论的主要内容。</p><h1 id="TCP-x2F-IP-体系结构"><a href="#TCP-x2F-IP-体系结构" class="headerlink" title="TCP&#x2F;IP 体系结构"></a>TCP&#x2F;IP 体系结构</h1><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230520181329.png"></p><p>网络接口层并没有规定什么具体内容，这是为了可以使用各种不同的网络接口，这是 TCP&#x2F;IP体系结构网际层中的协议。</p><p>网际协议 IP 是网际层中的核心协议，它可以互连不同的网络接口，也就是互连各种异构型网络，并为其上层提供无连接，不可靠的数据报传输服务。</p><p>应用层中，包含有大量的应用层协议，其中有些应用层协议需要使用可靠传输服务，有些应用层协议使用不可靠传输协议。</p><p>TCP&#x2F;IP 体系结构运输层的主要任务就是使用端口号，为运行再不同主机上的应用进程，提供逻辑通信服务，使用 TCP 协议为应用层中那些需要使用可靠传输服务的协议，提供可靠传输服务，另外使用 UDP 协议为应用层中那些使用不可靠传输服务的协议提供不可靠传输服务。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230520182140.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230520182241.png"></p><h1 id="运输层端口号"><a href="#运输层端口号" class="headerlink" title="运输层端口号"></a>运输层端口号</h1><p>运行在计算机上的进程使用进程标识符PID来标志。因特网_上的计算机并不是使用统- -的操作系统，不同的操作系统(windows, Linux, Mac OS)又使用不同格式的进程标识符。为了使运行不同操作系统的计算机的应用进程之间能够进行网络通信，就必须使用统- -的方法对TCP&#x2F;IP体系的应用进程进行标识。</p><p>TCP&#x2F;IP体系的运输层使用端口号来区分应用层的不同应用进程。端口号使用16比特表示，取值范围0~65535;</p><ol><li>熟知端口号: 0~1023, IANA把这些端口号指派给了TCP&#x2F;IP体系中最重要的一些应用协议，例如:FTP使用21&#x2F;20, HTTP使用80, DNS使用53.</li><li>登记端口号: 1024~49151,为没有熟知端口号的应用程序使用。使用这类端口号必须在IANA按照规定的手续登记，以防止重复。例如: Microsoft RDP微软远程桌面使用的端口是3389。</li><li>短暂端口号: 49152~65535, 留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。</li></ol><blockquote><p>端口号只具有本地意义，即端口号只是为了标识本计算机应用层中的各进程，在因特网中,不同计算机中的相同端口号是没有联系的。</p></blockquote><h1 id="发送方的复用和接收方的分用"><a href="#发送方的复用和接收方的分用" class="headerlink" title="发送方的复用和接收方的分用"></a>发送方的复用和接收方的分用</h1><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230520183055.png"></p><p>发送方的某些应用进程所发送的不同应用报文，在运输层使 UDP 协议进行封装，称为 UDP复用</p><p>一些应用进程所发送的不同应用报文，在运输层使用 TCP 协议进行封装，这称为 TCP 复用</p><p>运输层使用端口号来区分不同的应用进程，不管是使用运输层的 UDP 协议封装成的 UDP 用户数据报，还是使用 TCP 协议封装成的 TCP 报文段，在网络层都需要使用 IP协议封装成 IP 数据报，这称为 IP 复用</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230520183256.png"></p><h1 id="UDP和TCP"><a href="#UDP和TCP" class="headerlink" title="UDP和TCP"></a>UDP和TCP</h1><p>UDP和TCP是TCP&#x2F;IP体系结构运输层中的两个重要协议</p><h2 id="二者对比"><a href="#二者对比" class="headerlink" title="二者对比"></a>二者对比</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230520184351.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230520183623.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230520183731.png"></p><p><img src="C:\Users\CWL25\AppData\Roaming\Typora\typora-user-images\image-20230520184044122.png" alt="image-20230520184044122"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230520184244.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230520184312.png"></p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>为了实现可靠传输，TCP采用了<strong>面向字节流</strong>的方式。但TCP在发送数据时，是从发送缓存取出一-部分或全部字节并给其添加一个首部使之成为<strong>TCP报文段</strong>后进行发送。</p><p>一个TCP报文段由首部和数据载荷两部分构成。</p><h3 id="TCP首部"><a href="#TCP首部" class="headerlink" title="TCP首部"></a>TCP首部</h3><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230520184619.png"></p><p>源端口：占16比特，写入源端口号，用来标识发送该TCP报文段的应用进程。</p><p>目的端口：占16比特，写入目的端口号，用来标识接收该TCP报文段的应用进程。</p><p>序号:占32比特，序号增加到最后一个后，下一个序号就又回到0，指出本TCP报文段数据载荷的第一个字节的序号.</p><p>确认号：占32比特，确认号增加到最后-一个后，下一一个确认号就又回到0，指出期望收到对方下一个TCP报文段的数据载荷的第一个字节的序号，同时也是对之前收到的所有数据的确认。若确认号&#x3D;n,则表明到序号n-1为止的所有数据都已正确接收，期望接收序号为n的数据。</p><p>数据偏移：占4比特，并以4字节为单位。用来指出TCP报文段的数据载荷部分的起始处距离TCP报文段的起始处有多远。这个字段实际，上是指出了TCP报文段的首部长度。首部固定长度为20字节，因此数据偏移字段的最小值为(0101)2首部最大长度为60字节，因此数据偏移字段的最大值为(1111)2</p><p>保留:占6比特，保留为今后使用，但目前应置为0。</p><p>紧急标志位URG:取值为1时紧急指针字段有效;取值为0时紧急指针字段无效。</p><p>确认标志位ACK:取值为1时确认号字段才有效;取值为0时确认号字段无效。</p><p>推送标志位PSH:接收方的TCP收到该标志位为1的报文段会尽快上交应用进程,而不必等到接收缓存都填满后再向上交付。</p><p>复位标志位RST:用来复位TCP连接。当RST&#x3D;1时，表明TCP连接出现了异常，必须释放连接，然后再重新建立连接。RST置1还用来拒绝-一个非法的报文段或拒绝打开- -个TCP连接。</p><p>同步标志位SYN:在TCP连接建立时用来同步序号。</p><p>终止标志位FIN:用来释放TCP连接。</p><p>窗口:占16比特，以字节为单位。指出发送本报文段的- -方的接收窗口。窗口值作为接收方让发送方设置其发送窗口的依据。</p><p>校验和:占16比特，检查范围包括TCP报文段的首部和数据载荷两部分。在计算校验和时，要在TCP报文段的前面加上12字节的伪首部。</p><p>紧急指针:占16比特，以字节为单位，用来指明紧急数据的长度。</p><p>选项：</p><ol><li>最大报文段长度MSS选项: TCP报文段数据载荷部分的最大长度。</li><li>窗口扩大选项:为了扩大窗口(提高吞吐率)。</li><li>时间戳选项: 用来计算往返时间RTT，用于处理序号超范围的情况， 又称为防止序号绕回PAWS。</li><li>选择确认选项</li></ol><p>填充:由于选项的长度可变，因此使用填充来确保报文段首部能被4整除(因为数据偏移字段,也就是首部长度字段，是以4字节为单位的)</p><h3 id="TCP连接建立"><a href="#TCP连接建立" class="headerlink" title="TCP连接建立"></a>TCP连接建立</h3><p>TCP是面向连接的协议，它基于运输连接来传送TCP报文段。TCP运输连接的建立和释放是每一次面向连接的通信中必不可少的过程。</p><p>TCP运输连接有以下三个阶段:</p><ol><li>建立TCP连接（三握手）</li><li>数据传送</li><li>释放TCP连接（四挥手）</li></ol><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230520192534.png"></p><p>TCP的连接建立要解决以下三个问题:</p><ol><li>使TCP双方能够确知对方的存在;</li><li>使TCP双方能够协商- 些参数(如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等) ;</li><li>使TCP双方能够对运输实体资源 (如缓存大小、连接表中的项目等)进行分配。</li></ol><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230520201746.png"></p><p>三握手过程：</p><ol><li>TCP服务器进程首先创建传输控制块。用来存储TCP连接中的一些重要信息。就准备接受TCP客户进程的连接请求。此时，TCP服务器进程就进入监听状态。</li><li>TCP客户进程也是首先创建传输控制块。在打算建立TCP连接时向TCP服务器迸程发送TCP连接请求报文段并进入同步已发送状态。</li><li>TCP服务器进程则向TCP客户进程发送TCP连接清求确认报文段。并进入同步已接收状态。</li><li>TCP客户进程收到TCP连接清求确认报文段后。还要向TCP服务器进程发送一个普通的TCP确认报文段。并进入连接已建立状态。</li><li>TCP服务器进程收到该确认报文段后也进入连接已建立状态。</li></ol><p>注意: TCP规定SYN被设置为1的报文段不能携带数据。但要消耗掉一个序号。</p><p>为什么是三握手而不能简化为两握手：</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230520202001.png"></p><p>如上图，TCP客户进程发送一个连接请求，但该报文段在某些网络结点长时间滞留了。这必然会造成该报文段的超时重传。假设重传的报文段被TCP服务器进程常接收。TCP服务器迸程给TCP客户进程发送一个TCP连接请求确认报文段并进入连接已建立状态。一段时间后，之前滞留在网络中的那个失效的 TCP 连接请求报文段，到达了 TCP 服务器进程。TCP 服务器进程会误认为这是 TCP 客户进程又发起了一个新的 TCP连接请求。于是给 TCP 客户进程发送 TCP 连接请求确认报文段，并进入连接已建立状态。由于 TCP 客户进程并没有发起新的 TCP 连接请求，并且处于关闭状态，因此不会理会该报文段。但 TCP 服务器已进入连接已建立状态，它认为新的 TCP连接已建立好了，并一直等待 TCP 客户进程发来数据，这将白白浪费 TCP 服务器进程所在主机的很多资源。</p><h3 id="TCP连接释放"><a href="#TCP连接释放" class="headerlink" title="TCP连接释放"></a>TCP连接释放</h3><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230520212350.png">四挥手过程：</p><p>1. </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-应用层</title>
      <link href="/2023/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.2/"/>
      <url>/2023/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.2/</url>
      
        <content type="html"><![CDATA[<h1 id="应用层概述"><a href="#应用层概述" class="headerlink" title="应用层概述"></a>应用层概述</h1><p>应用层是计算机网络体系结构的最顶层，是设计和建立计算机网络的最终目的，也是计算机网络中发展最快的部分。</p><ul><li>早期基于文本的应用(电子邮件、远程登录、文件传输、新闻组)。</li><li>20世纪90年代将因特网带入干家万户的万维网WWW。</li><li>当今流行的即时通信、P2P文件共享及各种音视频应用。</li><li>计算设备的小型化和“无处不在”，宽带住宅接入和无线接入的日益普及和迅速发展，为未来更多<br>的新型应用提供了广阔的舞台。</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514132852.png"></p><h1 id="应用进程通信方式"><a href="#应用进程通信方式" class="headerlink" title="应用进程通信方式"></a>应用进程通信方式</h1><p>网络应用程序运行在处于网络边缘的不同的端系统上,通过彼此间的通信来共同完成某项任务。</p><p>开发一种新的网络应用首先要考虑的问题就是网络应用程序在各种端系统上的组织方式和它们之间的关系。<br>目前流行的主要有以下两种:</p><h2 id="客户-x2F-服务器方式"><a href="#客户-x2F-服务器方式" class="headerlink" title="客户&#x2F;服务器方式"></a>客户&#x2F;服务器方式</h2><p>应用层的许多协议是基于C&#x2F;S方式，例如，在移动互联网环境下，每个应用APP都是一个客户端。</p><p>客户&#x2F;服务器方式特点：</p><ul><li>客户(client)和服务器(server)是指通信中所涉及的2个应用进程</li><li>客户&#x2F;服务器方式描述的是应用进程之间服务和被服务的关系</li><li>客户是服务请求方(主动请求服务，被服务)</li><li>服务器是服务提供方(被动接受服务请求提供服务)</li><li>服务器总是处于运行状态，并等待客户的服务请求。服务器具有固定端口号(例如HTTP服务<br>器的默认端口号为80) ，而运行服务器的主机也具有固定的IP地址。</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514133535.png"></p><p>主机 A 中运行的是客户程序，正在运行的客户程序称为客户进程，也可简称为客户。主机 A 应称为客户计算机，也可简称为客户。</p><p>主机 B 中运行的是服务器程序，正在运行的服务器程序称为服务器进程，也可简称为服务器。主机 B 应称为服务器计算机，也可简称为服务器。</p><p>C&#x2F;S方式是因特网上传统的、同时也是最成熟的方式，很多我们熟悉的网络应用采用的都是C&#x2F;S方式。包括万维网WWW.电子邮件、文件传输FTP等。</p><p>基于C&#x2F;S方式的应用服务通常是服务集中型的，即应用服务集中在网络中比客户计算机少得多的服务器计算机上。</p><p>由于一台服务器计算机要为多个客户机提供服务,在C&#x2F;S应用中，常会出现服务器计算机跟不上众多客户机请求的情况。</p><p>为此，在C&#x2F;S应用中，常用计算机群集(或服务器场)构建一个强大的虚拟服务器。</p><h2 id="浏览器-x2F-服务器方式"><a href="#浏览器-x2F-服务器方式" class="headerlink" title="浏览器&#x2F;服务器方式"></a>浏览器&#x2F;服务器方式</h2><ul><li>B&#x2F;S方式可以看做C&#x2F;S方式的特例，即客户软件改为浏览器了</li><li>B&#x2F;S方式采取浏览器请求、服务器响应的工作模式</li><li>在B&#x2F;S方式下，用户界面完全通过Web浏览器实现，一部分事务逻辑在前端实现，但主要的事务逻辑在服务器端实现</li></ul><p>B&#x2F;S方式通常采取3层架构实现</p><ol><li>数据层:由数据库服务器承担数据处理逻辑，其任务是接受Web服务器对数据库服务器提出的数据操作请求，然后由数据库服务器进行数据处理并把处理结果返回给web服务器</li><li>处理层:由Web服务器承担业务处理逻辑和页面存储管理，接受客户浏览器的任务请求，执行<br>相应的事务处理</li><li>表现层:浏览器仅承担网页信息的浏览功能，以，超文本格式实现信息的输入和浏览</li></ol><blockquote><p>实际部署时也可以把数据库服务器和web服务器部署在同一台设备上</p></blockquote><p>B&#x2F;S方式的特点：</p><ul><li>界面统- -, 使用简单。客户端只需要安装浏览器软件</li><li>易于维护。对应用系统升级时，只需更新服务器端的软件，减轻了系统维护和升级的成本</li><li>可扩展性好。采用标准的TCP&#x2F;IP和HTTP协议，具有良好的扩展性</li><li>信息共享度高。HTML是数据格式的一个开放标准，目前大多数流行的软件均支持HTML</li><li>需要注意的是，在- -种浏览器环境下开发的界面在另一种浏览器环境下可能有不完全适配的情况，这时需要安装对应的浏览器</li></ul><h2 id="对等方式"><a href="#对等方式" class="headerlink" title="对等方式"></a>对等方式</h2><p>在P2P方式中，没有固定的服务请求者和服务提供者,分布在网络边缘各端系统中的应用进程是对等<br>的，被称为对等方。对等方相互之间直接通信，每个对等方既是服务的请求者，又是服务的提供者。</p><p>目前，在因特网.上流行的P2P应用主要包括P2P文件共享、即时通信、P2P流媒体、分布式存储等</p><p>基于P2P的应用是服务分散型的，因为服务不是集中在少数几个服务器计算机中,而是分散在大量对等计算机中，这些计算机并不为服务提供商所有，而是为个人控制的桌面计算机和笔记本电脑，它们通常位于住宅、校园和办公室中。</p><p>P2P方式的最突出特性之一就是它的可扩展性。 因为系统每增加一一个对等方,不仅增加的是服务的请求者，同时也增加了服务的提供者，系统性能不会因规模的增大而降低。</p><p>P2P方式具有成本上的优势，因为它通常不需要庞大的服务器设施和服务器带宽。为了降低成本,服务提供商对于将P2P方式用于应用的兴趣越来越大。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514134619.png"></p><p>对比：</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514134649.png"></p><h1 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h1><p>域名系统DNS作用：方便用户记忆，但IP地址和域名的映射关系并非永久不变</p><h2 id="层次树状结构的域名结构"><a href="#层次树状结构的域名结构" class="headerlink" title="层次树状结构的域名结构"></a>层次树状结构的域名结构</h2><p>早在1983年，因特网就开始采用层次结构的命名树作为主机的名字(即域名)并使用分布式的域名系统DNS。<strong>DNS使大多数域名都在本地解析，仅少量解析需要在因特网上通信，因此系统效率很高</strong>。</p><p>域名的结构由若干个分量组成，各分量之间用“点”隔开,分别代表不同级别的域名</p><ol><li>每一级的域名都由英文字母和数字组成，不超过63个字符，不区分大小写字母。</li><li>级别最低的域名写在最左边，而级别最高的顶级域名写在最右边。</li><li>完整的域名不超过255个字符。</li></ol><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514142044.png"></p><p>域名系统既不规定一个域名需要包含多少个下级域名， 也不规定每一级的域名代表什么意思。</p><p>各级域名由其上一级的域名管理机构管理，而最高的顶级域名则由因特网名称与数字地址分配机构ICANN进行管理。</p><h2 id="顶级域名TLD"><a href="#顶级域名TLD" class="headerlink" title="顶级域名TLD"></a>顶级域名TLD</h2><p>顶级域名TLD分为3类：</p><ol><li>国家顶级域名nTLD：采用ISO 3166的规定。如cn表示中国</li><li>通用顶级域名gTLD：最常见的通用顶级域名有七个，即: com (公司企业)、net (网络服务机构)、org (非营利性组织)、int (国际组织)、edu (美国教育结构)、gov (美国政府部门)、mil (美国军事部门)</li><li>反向域arpa：用于反向域名解析，即IP地址反向解析为域名。</li></ol><h2 id="二级域名"><a href="#二级域名" class="headerlink" title="二级域名"></a>二级域名</h2><p>在国家顶级域名下注册的二级域名均由该国家自行确定。我国则将二级域名划分为以下两类:</p><ol><li>类别域名：共七个: ac (科研机构)、com (工、商、金融等企业)、edu (教育机构) .gov (政府部门) . net (提供网络服务的机构)、mil (军事机构)和org (非营利性组织)。</li><li>行政区域名：共34个，适用于我国的各省、自治区、直辖市。</li></ol><blockquote><p>需要注意的是，名称相同的域名其登记未必相同。例如，com 是通用顶级域名，但我国顶级</p><p>域名 cn 下也有一个名称为 com 的二级域名</p></blockquote><h2 id="因特网的域名空间"><a href="#因特网的域名空间" class="headerlink" title="因特网的域名空间"></a>因特网的域名空间</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514142622.png"></p><p>这种按等级管理的命名方法便于维护名字的唯一性， 并且也容易设计出一种高效的域名查询机制。需要注意的是，域名只是个逻辑概念，并不代表计算机所在的物理地点。MAC才是物理地址</p><h2 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h2><p>域名和IP地址的映射关系必须保存在域名服务器中,供所有其他应用查询。显然不能将所有信息都储存在一台域名服务器中。DNS使用分布在各地的域名服务器来实现域名到IP地址的转换。</p><p>域名服务器可以划分为以下四种不同的类型：</p><ol><li><p>根域名服务器：</p><p>根域名服务器是<strong>最高层次的域名服务器</strong>。<strong>每个根域名服务器都知道所有的顶级域名服务器的域名及其IP地址</strong>。因特网上共有13个不同IP地址的根域名服务器。尽管我们将这13个根域名服务器中的每一个都视为单个的服务器, 但“每台服务器”实际上是由许多分布在世界各地的计算机构成的服务器群集。<strong>当本地域名服务器向根域名服务器发出查询请求时，路由器就把查询请求报文转发到离这个DNS客户最近的-一个根域名服务器。这就加快了DNS的查询过程</strong>，同时也更合理地利用了因特网的资源。<strong>根域名服务器通常并不直接对域名进行解析，而是返回该域名所属顶级域名的顶级域名服务器的IP地址</strong>。</p></li><li><p>顶级域名服务器：</p><p>这些域名服务器<strong>负责管理在该顶级域名服务器注册的所有二级域名</strong>。当收到DNS查询请求时就给出相应的回答(可能是最后的结果，也可能是下一级权限域名服务器的IP地址)。</p></li><li><p>权限域名服务器：</p><p>这些域名服务器<strong>负责管理某个区的域名</strong>。每一个主机的域名都必须在某个权限域名服务器处注册登记。因此权限域名服务器知道其管辖的域名与IP地址的映射关系。另外,权限域名服务器还知道其下级域名服务器的地址。</p></li><li><p>本地域名服务器：</p><p>本地域名服务器<strong>不属于上述的域名服务器的等级结构</strong>。当一个主机发出DNS请求报文时,这个报文就首先被送往该主机的本地域名服务器。<strong>本地域名服务器起着代理的作用</strong>，会将该报文转发到上述的域名服务器的等级结构中。每一个因特网服务提供者ISP, 一个大学,甚至一个大学里的学院，都可以拥有一个本地域名服务器，<strong>它有时也称为默认域名服务器</strong>。本地域名服务器离用户较近，一般不超过几个路由器的距离，也有可能就在同-一个局域网中。<strong>本地域名服务器的IP地址需要直接配置在需要域名解析的主机中</strong>。</p></li></ol><blockquote><p>上述服务器分别管理下一级的域名和其IP地址</p></blockquote><h2 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h2><p>域名解析的过程有<strong>递归</strong>和<strong>迭代</strong>2种查询方式</p><p>递归查询：每一个服务器都进行一次查询过程，递归查询对于被查询的域名服务器负担太大</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514143555.png"></p><p>迭代查询：通常采用从请求主机到本地域名服务器的查询是递归查询，而其余的查询是迭代查询。减轻服务器负担</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514143729.png"></p><p>为了提高DNS的查询效率,并减轻根域名服务器的负荷和减少因特网上的DNS查询报文数量,在域名服务器中广泛地使用了<strong>高速缓存</strong>。高速缓存用来存放最近查询过的域名以及从何处获得域名映射信息的记录。</p><p>例题</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514144530.png"></p><h1 id="文件传送协议-FTP"><a href="#文件传送协议-FTP" class="headerlink" title="文件传送协议 FTP"></a><strong>文件传送协议 FTP</strong></h1><p>将某台计算机中的文件通过网络传送到可能相距很远的另-台计算机中，是一项基本的网络应用，即<strong>文件传送</strong>。</p><p>文件传送协议FTP (File Transfer Protocol)是因特网上使用得最广泛的文件传送协议。</p><p>FTP<strong>提供交互式的访问</strong>，<strong>允许客户指明文件的类型与格式</strong>(如指明是否使用ASCII码) 并<strong>允许文件具有存取权限</strong>(如访问文件的用户必须经过授权，并输入有效的口令)。</p><p>FTP<strong>屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算机之间传送文件</strong>。</p><p>常见用途：</p><ol><li>FTP的常见用途是在计算机之间传输文件，尤其是用于批量传输文件。</li><li>FTP的另一个常见用途是让网站设计者将构成网站内容的大量文件批量.上传到他们的Web服务器。</li></ol><h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514145258.png"></p><p>FTP传送分<strong>主动模式</strong>和<strong>被动模式</strong></p><p>主动模式：</p><p>被动模式：</p><h1 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h1><p>电子邮件(E-mail) 是因特网上最早流行的一种应用，并且仍然是当今因特网上最重要、最实用的应用之一。</p><p>电子邮件与邮政系统的寄信相似。特点：</p><ol><li>发件人将邮件发送到自己使用的邮件服务器;</li><li>发件人的邮件服务器将收到的邮件按其目的地址转发到收件人邮件服务器中的收件人邮箱;</li><li>收件人在方便的时候访问收件人邮件服务器中自己的邮箱，获取收到的电子邮件。</li></ol><p>电子邮件系统采用<strong>客户&#x2F;服务器</strong>方式。</p><h2 id="电子邮件格式"><a href="#电子邮件格式" class="headerlink" title="电子邮件格式"></a>电子邮件格式</h2><p>电子邮件的信息格式并不是由SMTP定义的，而是在RFC 822中单独定义的。这个RFC文档已在2008年更新为RFC 5322。一个电子邮件有<strong>信封和内容</strong>两部分。而内容又由<strong>首部和主体</strong>两部分构成。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514150512.png"></p><h2 id="电子邮件系统构件"><a href="#电子邮件系统构件" class="headerlink" title="电子邮件系统构件"></a>电子邮件系统构件</h2><p>电子邮件系统的三个主要组成构件：<strong>用户代理、邮件服务器、电子邮件所需的协议</strong>。</p><p>用户代理：用户代理是用户与电子邮件系统的接口，又称为电子邮件客户端软件。</p><p>邮件服务器：邮件服务器是电子邮件系统的基础设施。因特网.上所有的ISP都有邮件服务器，其功能是发送和接收邮件,同时还要负责维护用户的邮箱。</p><p>电子邮件所需的协议：协议包括邮件发送协议(例如SMTP)和邮件读取协议(例如POP3，IMAP)。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514150049.png"></p><h2 id="发送协议"><a href="#发送协议" class="headerlink" title="发送协议"></a>发送协议</h2><p>简单邮件传送协议SMTP（Simple Mail Transfer Protocol）</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514150315.png"></p><p>SMTP协议<strong>只能传送ASCII码文本数据</strong>，不能传送可执行文件或其他的二进制对象。</p><p>SMTP不能满足传送多媒体邮件(例如带有图片、音频或视频数据)的需要。并且许多其他非英语国家的文字(例如中文、俄文、甚至带有重音符号的法文或德文)也无法用SMTP传送。<strong>为解决SMTP传送非ASCII码文本的问题，提出了多用途因特网邮件扩展MIME</strong> (Multipurpose Intemet Mail Extensions)</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514150654.png"></p><h2 id="读取协议"><a href="#读取协议" class="headerlink" title="读取协议"></a>读取协议</h2><p>常用的邮件读取协议有以下两个：**POP **和 <strong>IMAP</strong></p><p>邮局协议POP (Post Office Protocol)，POP3是其第3三个版本,是因特网正式标准。非常简单、功能有限的邮件读取协议。用户<strong>只能以下载并删除方式或下载并保留方式</strong>从邮件服务器下载邮件到用户方计算机。<strong>不允许用户在邮件服务器上管理自己的邮件</strong>。(例如创建文件夹, 对邮件进行分类管理等)。</p><p>因特网邮件访问协议IMAP (Internet Message Access Protocol)，IMAP4是其第四个版本，目前还只是因特网建议标准。功能比POP3强大的邮件读取协议。用<strong>户在自己的计算机上就可以操控邮件服务器中的邮箱</strong>，就像在本地操控一样，因此IMAP是  一个联机协议。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514150926.png"></p><p>POP3和IMAP4<strong>都采用基于TCP连接的客户&#x2F;服务器方式</strong>。POP3使用熟知端口110, IMAP4使用熟知端口143。</p><h1 id="万维网"><a href="#万维网" class="headerlink" title="万维网"></a>万维网</h1><p>万维网WWW (World Wide Web)<strong>并非某种特殊的计算机网络</strong>。它是一-个大规模的、联机式的信息储藏所，<strong>是运行在因特网上的一个分布式应用</strong>。万维网<strong>利用网页之间的超链接将不同网站的网页链接成一-张逻辑上的信息网</strong>。</p><p>万维网使用<strong>统一资源定位符URL</strong>来指明因特网上任何种类“资源”的位置。</p><p>URL的一般形式由以下四个部分组成:</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514151340.png"></p><h2 id="超文本传输协议-HTTP"><a href="#超文本传输协议-HTTP" class="headerlink" title="超文本传输协议 HTTP"></a>超文本传输协议 HTTP</h2><p>HTTP&#x2F;1.0采用<strong>非持续连接方式</strong>。在该方式下，每次浏览器要请求-个文件都要与服务器建立TCP连接,当收到响应后就立即关闭连接。</p><p>问题：<strong>每请求一个文档就要有两倍的RTT的开销</strong>。若-个网页上有很多引用对象(例如图片等)，那么请求每一个对象都需要花费2RTT的时间。<strong>为了减小时延，浏览器通常会建立多个并行的TCP连接同时请求多个对象</strong>。<strong>但是,这会大量占用万维网服务器的资源</strong>，特别是万维网服务器往往要同时服务于大量客户的请求，这会使其负担很重。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514151610.png"></p><p>HTTP&#x2F;1.1采用<strong>持续连接方式</strong>。在该方式下，万维网服务器在发送响应后仍然保持这条连接，使同一个客户(浏览器)和该服务器可以继续在这条连接上传送后续的HTTP请求报文和响应报文。<strong>这并不局限于传送同一个页面上引用的对象，而是只要这些文档都在同一个服务器上就行</strong>。</p><p>为了进一步提高效率， HTTP&#x2F;1.1 的持续连接还可以使用<strong>流水线</strong>方式工作，即浏览器在收到HTTP的响应报文之前就能够连续发送多个请求报文。这样的一个接一个的请求报文到达服务器后，服务器就发回一个接一个的响应报文。这样就节省了很多个RTT时间，使TCP连接中的空闲时间减少,提高了下载文档的效率。</p><h2 id="HTTP的报文格式"><a href="#HTTP的报文格式" class="headerlink" title="HTTP的报文格式"></a>HTTP的报文格式</h2><p>HTTP是面向文本的，其报文中的每一个字段都是-些ASCII码串, 并且每个字段的长度都是不确定的。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514151938.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514152013.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514152047.png"></p><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>使用Cookie在服务器上记录用户信息</p><p>早期的万维网应用非常简单，仅仅是用户查看存放在不同服务器上的各种静态的文档。因此HTTP被设计为一种无状态的协议。这样可以简化服务器的设计。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 408 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-引言</title>
      <link href="/2023/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.1/"/>
      <url>/2023/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.1/</url>
      
        <content type="html"><![CDATA[<h1 id="因特网简介"><a href="#因特网简介" class="headerlink" title="因特网简介"></a>因特网简介</h1><h2 id="网络，互联网与因特网的区别于关系"><a href="#网络，互联网与因特网的区别于关系" class="headerlink" title="网络，互联网与因特网的区别于关系"></a>网络，互联网与因特网的区别于关系</h2><p>网络：使用有线链路的简单网络</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514115621.png"></p><p>互联网：若干网络通过路由器互联形成互联网</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514115639.png"></p><p>因特网：最大的互联网，日常生活中，人们口中的互联网指因特网</p><p>Internet 与 internet对比：</p><p>Internet：专用名词，必须使用 TCP&#x2F;IP 协议族，叫做因特网</p><p>internet：通用名词，可以使用任意的协议，叫互联网</p><h2 id="因特网发展的三个阶段"><a href="#因特网发展的三个阶段" class="headerlink" title="因特网发展的三个阶段"></a>因特网发展的三个阶段</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514120308.png"></p><p>ISP：internet service provider，因特网服务提供者</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514120513.png"></p><p>因特网已发展成为基于ISP的多层次结构的互连网络，三层ISP结构互联网示意图</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514120708.png"></p><h2 id="因特网标准化工作"><a href="#因特网标准化工作" class="headerlink" title="因特网标准化工作"></a>因特网标准化工作</h2><p>因特网的标准化工作是面向公众的,其任何一个建议标准在成为因特网标准之前都以RFC技术文档的形式在因特网上发表。<br>RFC (Request For Comments)的意思是“请求评论”。任何人都可以从因特网上免费下载RFC文档(<a href="http://ww.etf.org/rfc.html">http://ww.etf.org/rfc.html</a>) ，并随时对某个RFC文档发表意见和建议。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514121151.png"></p><h2 id="因特网的管理机构"><a href="#因特网的管理机构" class="headerlink" title="因特网的管理机构"></a>因特网的管理机构</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514121239.png"></p><h2 id="因特网组成"><a href="#因特网组成" class="headerlink" title="因特网组成"></a>因特网组成</h2><p>因特网由<strong>核心部分</strong>和<strong>边缘部分</strong>组成</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514121431.png"></p><p>核心部分：大量异构网络和连接这些网络搭建服务器组成，为边缘部分提供连通性和数据交换服务</p><p>边缘部分：由各个用户设备组成，这些设备称为主机，直接由用户使用，为用户提供网络服务</p><p>核心部分中起特殊作用的是路由器，用来实现分组交换，分组交换是网络核心部分最重要的功能</p><h1 id="数据交换方式"><a href="#数据交换方式" class="headerlink" title="数据交换方式"></a>数据交换方式</h1><p>数据交换有：<strong>电路交换，分组交换，报文交换</strong></p><h2 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514122122.png"></p><p>电路交换过程由于链路一直存在，占用资源，导致线路传输效率一般都会很低</p><h2 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h2><p>采用报文的方式，将长数据分解成一段段的带首部的短数据。分组交换网中的节点先缓存短数据，然后从首部中提取出目的的地址，按照目的地址查找自己的转发表，找到相应的转发接口后，将分组转发出去把分组交给下一个转发节点，经过多个节点的存储转发后，分组最终转发到目的主机。主机接收到数据后，去掉首部，将各数据段组合还原出原始报文</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514123235.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514123408.png"></p><h2 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h2><p>报文交换是<strong>分组交换的前身</strong>，在报文交换中， <strong>报文被整个地发送</strong>，而不是拆分成若干个分组进行发送。交换节点将报文<strong>整体接收完成后才能查找转发表</strong>，将整个报文转发到下一个节点。因此，报文交换比分组交换带来的<strong>转发时延要长很多</strong>，需要交换节点具有的<strong>缓存空间也大很多</strong>。</p><h2 id="三种交换方式的对比"><a href="#三种交换方式的对比" class="headerlink" title="三种交换方式的对比"></a>三种交换方式的对比</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514123725.png"></p><p>若要连续传送大量的数据，并且数据传送时间远大于建立连接的时间，则使用电路交换可以有较高的传输效率。然而计算机的数据传送往往是突发式的，采用电路交换时通信线路的利用率会很低。</p><p>报文交换和分组交换都不需要建立连接(即预先分配通信资源) ，在传送计算机的突发数据时可以提高通信线路的利用率。</p><p>将报文构造成若干个更小的分组进行分组交换，比将整个报文进行报文交换的时延要小，并且还可以避免太长的报文长时间占用链路，有利于差错控制，同时具有更好的灵活性。</p><h1 id="计算机网络定义和分类"><a href="#计算机网络定义和分类" class="headerlink" title="计算机网络定义和分类"></a>计算机网络定义和分类</h1><h2 id="计算机网络定义"><a href="#计算机网络定义" class="headerlink" title="计算机网络定义"></a>计算机网络定义</h2><p><strong>早期</strong>计算机网络定义：一些互联的、自治的、计算机集合</p><p>互联：可通过有线或无线的方式进行数据通信</p><p>自治：独立的计算机有自己的硬件和软件，可独立运行</p><p>计算机集合：至少2台及以上的计算机</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514124344.png"></p><p><strong>现阶段</strong>计算机网络定义：计算机网络主要是由一些通用的、可编程的硬件互连而成的，而这些硬件并非专门用来实现某一特定目的(例如，传送数据或视频信号)这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。</p><p>可编程的硬件：不限于计算机，而是包括了智能手机、具有网络功能的传感器以及智能家电等智能硬件，这些硬件一定包含有中央处理单元(CPU)</p><p>各类应用：计算机网络并非只用来传送数据，而是能够基于数据传送进而实现各种各样的应用，包括今后可能出现的各种应用。</p><h2 id="计算机网络分类"><a href="#计算机网络分类" class="headerlink" title="计算机网络分类"></a>计算机网络分类</h2><p>交换方式：可分为<strong>电路交换、报文交换、分组交换</strong></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514123725.png">使用者：可分为<strong>公用网、专用网</strong></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514124819.png"></p><p>传输介质：</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514124937.png"></p><p>覆盖范围：</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514124954.png"></p><p>拓扑：</p><p>总线型：使用单根传输线把计算机连接起来<br>星型<br>环型<br>网状型</p><h1 id="计算机网络性能指标"><a href="#计算机网络性能指标" class="headerlink" title="计算机网络性能指标"></a>计算机网络性能指标</h1><p>从不同方面度量计算机网络的性能：常用的八个计算机网络的性能指标</p><h2 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h2><p>速率是指<strong>数据的传送速率(即每秒传送多少个比特)<strong>，也称为</strong>数据率</strong>(Data Rate) 或<strong>比特率</strong>(Bit Rate)</p><p>速率的基本单位是比特秒（bit&#x2F;s）, 可简记为 b&#x2F;s ,有时也记为bps,即bit per second) 。速率的常用单位有千比特秒(kb&#x2F;s或kbps) 、兆比特秒(Mb&#x2F;s或Mbps) 、吉比特秒(Gb&#x2F;s或Gbps) 以及太比特秒<br>(Tb&#x2F;s或Tbps)。<img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514125655.png"></p><p>比特(bit, 记为小写b)是计算机中数据量的基本单位，一个比特就是二进制数字中的一个1或0。</p><p>数据量的常用单位有字节(byte， 记为大写B)、干字节(KB)、兆字节(MB)、吉字节(GB)以及太字节(TB) 。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514125632.png"></p><blockquote><p>做题时注意字母代表的数字是多少进制，注意看是 B 还是 b</p></blockquote><h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514125906.png"></p><p>带宽：用来表示网络的通信线路所能传送数据的能力，即在单位时间内，能传送的最高数据率，单位与速度相同</p><p>数据传送速率&#x3D; min [主机接口速率,线路带宽,交换机或路由器的接口速率]</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514130228.png"></p><h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>吞吐量：单位时间内通过某个网络或接口的实际数据量，受带宽限制</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514130409.png"></p><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>时延：数据从网络的一端传送到另一端所耗费的时间，也称为延迟或迟延。</p><p>总时延 &#x3D; 发送时延 + 传播时延 + 处理时延 + 排队时延</p><p>发送时延</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514130629.png"></p><p>传播时延</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514130653.png"></p><p>处理时延、排队时延不便计算，一般给出或不计</p><p>电磁波传播速度：</p><p>自由空间：3.0x10^8</p><p>铜线：2.3x10^8</p><p>光纤：2.0x10^8</p><blockquote><p>选光纤是因为光纤带宽大</p></blockquote><p>例题.多段路由器下时延计算通用公式</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514131839.png"></p><p>电路交换：时延&#x3D;2x建立连接时间+报文发送时间+报文传输时间(连接释放时间与其重叠）</p><p>分组交换：报文发送时间+传播时间+中间结点转发时间</p><h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><p>时延带宽积 &#x3D; 传播时延 x 带宽</p><p>链路的时延带宽积又称为以比特为单位的链路长度。</p><h2 id="往返时间"><a href="#往返时间" class="headerlink" title="往返时间"></a>往返时间</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514132134.png"></p><h2 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h2><p>信道利用率：用来表示某信道有百分之几的时间是被利用的(有数据通过)。<br>网络利用率：全网络的信道利用率的加权平均。</p><p>根据排队论，当某信道的利用率增大时，该信道引起的时延也会迅速增加。因此，<strong>信道利用率并非越高越好</strong></p><p>如果令D0表示网络空闲时的时延，D表示网络当前的时延，那么在适当的假定条件下，可以用下面的简单公式来表示D、D0和利用率U之间的关系:</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514132402.png"></p><h2 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h2><p>丢包率即分组丢失率,是指在一定的时间范围内，传输过程中丢失的分组数量与总分组数量的比率。</p><p>丢包率具体可分为接口丢包率、结点丢包率、链路丢包率、路径丢包率、网络丢包率等。</p><p>丢包率是网络运维人员非常关心的一个网络性能指标,但对于普通用户来说往往并不关心这个指标，因为他们通常意识不到网络丢包。</p><p>分组丢失主要有两种情况:</p><ol><li>分组在传输过程中出现误码，被结点丢弃。</li><li>分组到达一台队列已满的分组交换机时被丢弃;在通信量较大时就可能造成网络拥塞。</li></ol><p>因此，丢包率反映了网络的拥塞情况:</p><p>无拥塞时路径丢包率为0，轻度拥塞时路径丢包率为1%<del>4%，严重拥塞时路径丢包率为5%</del>15%</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 408 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BOM</title>
      <link href="/2023/04/22/JS.4/"/>
      <url>/2023/04/22/JS.4/</url>
      
        <content type="html"><![CDATA[<h1 id="js组成"><a href="#js组成" class="headerlink" title="js组成"></a>js组成</h1><p>JavaScript的组成：</p><ol><li>ECMAScript:</li></ol><ul><li>规定了js基础语法核心知识。</li><li>比如：变量、分支语句、循环语句、对象等等</li></ul><ol start="2"><li>Web APIs :</li></ol><ul><li>DOM   文档对象模型， 定义了一套操作HTML文档的API</li><li>BOM   浏览器对象模型，定义了一套操作浏览器窗口的API</li></ul><p> ![67604738945](E:&#x2F;BaiduNetdiskDownload&#x2F;web APIs第五天&#x2F;04-笔记&#x2F;assets&#x2F;1676047389456.png)</p><h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><h2 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h2><p><strong>BOM</strong> (Browser Object Model ) 是浏览器对象模型</p><ul><li>window对象是一个全局对象，也可以说是JavaScript中的顶级对象，window则是BOM的核心对象</li><li>像document、alert()、console.log()这些都是window的属性，基本BOM的属性和方法都是window的，可以说<strong>BOM包含了DOM</strong></li><li>所有通过var定义在全局作用域中的变量、函数都会变成window对象的属性和方法</li><li>window对象下的属性和方法调用的时候可以省略window</li></ul><p> ![67604743636](E:&#x2F;BaiduNetdiskDownload&#x2F;web APIs第五天&#x2F;04-笔记&#x2F;assets&#x2F;1676047436362.png)</p><h2 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h2><p>location 的数据类型是对象，它拆分并保存了 URL 地址的各个组成部分</p><table><thead><tr><th>属性&#x2F;方法</th><th>说明</th></tr></thead><tbody><tr><td>href()</td><td>属性，获取完整的 URL 地址，赋值时用于地址的跳转</td></tr><tr><td>search()</td><td>属性，获取地址中携带的参数，符号 ？后面部分</td></tr><tr><td>hash()</td><td>属性，获取地址中的啥希值，符号 # 后面部分</td></tr><tr><td>reload()</td><td>方法，用来刷新当前页面，传入参数 true 时表示强制刷新</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;search&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">button</span>&gt;</span>搜索<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/music&quot;</span>&gt;</span>音乐<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/download&quot;</span>&gt;</span>下载<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;reload&quot;</span>&gt;</span>刷新页面<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// location 对象  </span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 1. href属性 （重点） 得到完整地址，赋值则是跳转到新地址</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">href</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// location.href = &#x27;http://www.itcast.cn&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 2. search属性  得到 ? 后面的地址 </span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">search</span>)  <span class="comment">// ?search=笔记本</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 3. hash属性  得到 # 后面的地址</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(location.<span class="property">hash</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 4. reload 方法  刷新页面</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.reload&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// location.reload() // 页面刷新</span></span></span><br><span class="line"><span class="language-javascript">      location.<span class="title function_">reload</span>(<span class="literal">true</span>) <span class="comment">// 强制页面刷新 ctrl+f5</span></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h2><p>navigator的数据类型是对象，该对象下记录了浏览器自身的相关信息</p><p>常用属性和方法：通过 userAgent 检测浏览器的版本及平台</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检测 userAgent（浏览器信息）</span></span><br><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> userAgent = navigator.<span class="property">userAgent</span></span><br><span class="line">  <span class="comment">// 验证是否为Android或iPhone</span></span><br><span class="line">  <span class="keyword">const</span> android = userAgent.<span class="title function_">match</span>(<span class="regexp">/(Android);?[\s\/]+([\d.]+)?/</span>)</span><br><span class="line">  <span class="keyword">const</span> iphone = userAgent.<span class="title function_">match</span>(<span class="regexp">/(iPhone\sOS)\s([\d_]+)/</span>)</span><br><span class="line">  <span class="comment">// 如果是Android或iPhone，则跳转至移动站点</span></span><br><span class="line">  <span class="keyword">if</span> (android || iphone) &#123;</span><br><span class="line">    location.<span class="property">href</span> = <span class="string">&#x27;http://m.itcast.cn&#x27;</span></span><br><span class="line">  &#125;&#125;)();</span><br></pre></td></tr></table></figure><h2 id="histroy对象"><a href="#histroy对象" class="headerlink" title="histroy对象"></a>histroy对象</h2><p>history 的数据类型是对象，主要管理历史记录， 该对象与浏览器地址栏的操作相对应，如前进、后退、历史记录等</p><p><strong>使用场景</strong></p><p>history对象一般在实际开发中比较少用，但是会在一些OA 办公系统中见到。</p><p> ![67604783479](E:&#x2F;BaiduNetdiskDownload&#x2F;web APIs第五天&#x2F;04-笔记&#x2F;assets&#x2F;1676047834796.png)</p><p>常见方法：</p><p>![67604784659](E:&#x2F;BaiduNetdiskDownload&#x2F;web APIs第五天&#x2F;04-笔记&#x2F;assets&#x2F;1676047846593.png)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;back&quot;</span>&gt;</span>←后退<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;forward&quot;</span>&gt;</span>前进→<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// histroy对象</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 1.前进</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> forward = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.forward&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    forward.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// history.forward() </span></span></span><br><span class="line"><span class="language-javascript">      history.<span class="title function_">go</span>(<span class="number">1</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 2.后退</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> back = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.back&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    back.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// history.back()</span></span></span><br><span class="line"><span class="language-javascript">      history.<span class="title function_">go</span>(-<span class="number">1</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h2><p>本地存储：将数据存储在本地浏览器中</p><p>常见的使用场景：</p><p><a href="https://todomvc.com/examples/vanilla-es6/">https://todomvc.com/examples/vanilla-es6/</a>    页面刷新数据不丢失</p><p>处：</p><p>1、页面刷新或者关闭不丢失数据，实现数据持久化</p><p>2、容量较大，sessionStorage和 localStorage 约 5M 左右</p><h3 id="localStorage（重点）"><a href="#localStorage（重点）" class="headerlink" title="localStorage（重点）"></a>localStorage（重点）</h3><p><strong>作用:</strong> 数据可以长期保留在本地浏览器中，刷新页面和关闭页面，数据也不会丢失</p><p><strong>特性：</strong>以键值对的形式存储，并且存储的是字符串， 省略了window</p><p>![67604963508](E:&#x2F;BaiduNetdiskDownload&#x2F;web APIs第五天&#x2F;04-笔记&#x2F;assets&#x2F;1676049635087.png)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>本地存储-localstorage<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 本地存储 - localstorage 存储的是字符串 </span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 1. 存储</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;age&#x27;</span>, <span class="number">18</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 2. 获取</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;age&#x27;</span>))</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 3. 删除</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&#x27;age&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="sessionStorage（了解）"><a href="#sessionStorage（了解）" class="headerlink" title="sessionStorage（了解）"></a>sessionStorage（了解）</h3><p>特性：</p><ul><li>用法跟localStorage基本相同</li><li>区别是：当页面浏览器被关闭时，存储在 sessionStorage 的数据会被清除</li></ul><p>存储：sessionStorage.setItem(key,value)</p><p>获取：sessionStorage.getItem(key)</p><p>删除：sessionStorage.removeItem(key)</p><h3 id="localStorage-存储复杂数据类型"><a href="#localStorage-存储复杂数据类型" class="headerlink" title="localStorage 存储复杂数据类型"></a>localStorage 存储复杂数据类型</h3><p><strong>问题：</strong>本地只能存储字符串,无法存储复杂数据类型.</p><p><strong>解决：</strong>需要将复杂数据类型转换成 JSON字符串,在存储到本地</p><p><strong>语法：</strong>JSON.stringify(复杂数据类型)</p><p>JSON字符串：</p><ul><li>首先是1个字符串</li><li>属性名使用双引号引起来，不能单引号</li><li>属性值如果是字符串型也必须双引号</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 本地存储复杂数据类型</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> goods = &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">name</span>: <span class="string">&#x27;小米&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">price</span>: <span class="number">1999</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// localStorage.setItem(&#x27;goods&#x27;, goods)</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// console.log(localStorage.getItem(&#x27;goods&#x27;))</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 1. 把对象转换为JSON字符串  JSON.stringify</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;goods&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(goods))</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// console.log(typeof localStorage.getItem(&#x27;goods&#x27;))</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>问题：</strong>因为本地存储里面取出来的是字符串，不是对象，无法直接使用</p><p>**解决： **把取出来的字符串转换为对象</p><p><strong>语法：</strong>JSON.parse(JSON字符串)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 本地存储复杂数据类型</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> goods = &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">name</span>: <span class="string">&#x27;小米&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">price</span>: <span class="number">1999</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// localStorage.setItem(&#x27;goods&#x27;, goods)</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// console.log(localStorage.getItem(&#x27;goods&#x27;))</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 1. 把对象转换为JSON字符串  JSON.stringify</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;goods&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(goods))</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// console.log(typeof localStorage.getItem(&#x27;goods&#x27;))</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 2. 把JSON字符串转换为对象  JSON.parse</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;goods&#x27;</span>)))</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="JS任务执行机制"><a href="#JS任务执行机制" class="headerlink" title="JS任务执行机制"></a>JS任务执行机制</h1><p>JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事，为了解决这个问题，利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程。于是，JS 中出现了同步和异步</p><h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>同步：前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的</p><p>异步：前一个任务执行过程中执行其他任务</p><blockquote><p><strong>本质区别： 这条流水线上各个流程的执行顺序不同</strong></p></blockquote><p><strong>同步任务</strong>：同步任务都在主线程上执行，形成一个<strong>执行栈</strong></p><p><img src="C:\Users\CWL25\AppData\Roaming\Typora\typora-user-images\image-20230421225440578.png" alt="image-20230421225440578"></p><p><strong>异步任务</strong>：JS 的异步是通过回调函数实现的，异步任务相关添加到<strong>任务队列</strong>中，（任务队列也称为消息队列）</p><p>一般而言，异步任务有以下三种类型：</p><ul><li>普通事件，如 click、resize 等</li><li>资源加载，如 load、error 等</li><li>定时器，包括 setInterval、setTimeout 等</li></ul><p><img src="C:\Users\CWL25\AppData\Roaming\Typora\typora-user-images\image-20230421225640123.png" alt="image-20230421225640123"></p><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><ol><li>先执行执行栈中的同步任务</li><li>异步任务放入任务队列中</li><li>一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行</li></ol><p><img src="C:\Users\CWL25\AppData\Roaming\Typora\typora-user-images\image-20230421230503488.png" alt="image-20230421230503488"></p><p><img src="C:\Users\CWL25\AppData\Roaming\Typora\typora-user-images\image-20230421230512471.png" alt="image-20230421230512471"></p><p>由于主线程不断的重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为事件循环（ event loop ）</p><h1 id="JS垃圾回收机制"><a href="#JS垃圾回收机制" class="headerlink" title="JS垃圾回收机制"></a>JS垃圾回收机制</h1><p>垃圾回收机制(Garbage Collection) ，简称 GC</p><p>JS中内存的分配和回收都是自动完成的，内存在不使用的时候会被垃圾回收器自动回收，不再用到的内存，没有及时释放，就叫做内存泄漏</p><h2 id="1-内存的生命周期"><a href="#1-内存的生命周期" class="headerlink" title="1 内存的生命周期"></a>1 内存的生命周期</h2><p>JS环境中分配的内存, 一般有如下生命周期：</p><ol><li>内存分配：声明变量、函数、对象的时候，系统会自动为他们分配内存</li><li>内存使用：即读写内存，也就是使用变量、函数等</li><li>内存回收：使用完毕，由垃圾回收自动回收不再使用的内存</li></ol><p>说明：</p><ul><li>全局变量一般不会回收(关闭页面回收)</li><li>一般情况下局部变量的值, 不用了, 会被自动回收掉</li></ul><h2 id="2-内存回收算法"><a href="#2-内存回收算法" class="headerlink" title="2 内存回收算法"></a>2 内存回收算法</h2><p>堆栈空间分配区别：</p><ul><li>栈（操作系统）: 由操作系统自动分配释放函数的参数值、局部变量等，基本数据类型放到栈里面</li><li>堆（操作系统）: 一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。复杂数据类型放到堆里面</li></ul><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>IE采用的引用计数算法, 定义“内存不再使用”，就是看一个对象是否有指向它的引用，没有引用了就回收对象</p><p>算法：</p><ol><li>跟踪记录被引用的次数</li><li>如果被引用了一次，那么就记录次数1，多次引用会加1</li><li>如果减少一个引用就减1</li><li>如果引用次数是0 ，则释放内存</li></ol><p>存在问题：<strong>嵌套引用</strong>（循环引用），如果两个对象相互引用，尽管他们已不再使用，但他们的引用次数永远不会是0，垃圾回收器不会进行回收，导致内存泄露</p><h3 id="标记清除法"><a href="#标记清除法" class="headerlink" title="标记清除法"></a>标记清除法</h3><p>现代浏览器通用的大多是基于标记清除算法的某些改进算法，总体思想都是一致的</p><p>算法：</p><ol><li>标记清除算法将“不再使用的对象”定义为“无法达到的对象”</li><li>就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。 凡是能从根部到达的对象，都是还需要使用的</li><li>那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>作用域、函数、数组进阶</title>
      <link href="/2023/04/20/JS.5/"/>
      <url>/2023/04/20/JS.5/</url>
      
        <content type="html"><![CDATA[<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>作用域（scope）规定了变量能够被访问的“范围”，离开了这个“范围”变量便不能被访问，作用域分为<strong>全局作用域</strong>和<strong>局部作用域</strong></p><h2 id="1-局部作用域"><a href="#1-局部作用域" class="headerlink" title="1 局部作用域"></a>1 局部作用域</h2><p>局部作用域分为<strong>函数作用域</strong>和<strong>块作用域</strong></p><h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><p>在函数内部声明的变量只能在函数内部被访问，外部无法直接访问</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 声明 counter 函数</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">counter</span>(<span class="params">x, y</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 函数内部声明的变量</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> s = x + y</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(s) <span class="comment">// 18</span></span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 设用 counter 函数</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">counter</span>(<span class="number">10</span>, <span class="number">8</span>)</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 访问变量 s</span></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(s)<span class="comment">// 报错</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>函数内部声明的变量，在函数外部无法被访问</li><li>函数的参数也是函数内部的局部变量</li><li>不同函数内部声明的变量无法互相访问</li><li>函数执行完毕后，函数内部的变量实际被清空了</li></ol><h3 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h3><p>在 JavaScript 中使用 <code>&#123; &#125;</code> 包裹的代码称为代码块，如 if、for中的（），代码块内部声明的变量外部将<strong>有可能</strong>无法被访问</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// age 只能在该代码块中被访问</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> age = <span class="number">18</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// 正常</span></span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 超出了 age 的作用域</span></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(age) <span class="comment">// 报错</span></span></span><br><span class="line"><span class="language-javascript">  </span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> flag = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">if</span>(flag) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// str 只能在该代码块中被访问</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> str = <span class="string">&#x27;hello world!&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(str); <span class="comment">// 正常</span></span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 超出了 str 的作用域</span></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(str); <span class="comment">// 报错</span></span></span><br><span class="line"><span class="language-javascript">  </span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">for</span>(<span class="keyword">let</span> t = <span class="number">1</span>; t &lt;= <span class="number">6</span>; t++) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// t 只能在该代码块中被访问</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(t); <span class="comment">// 正常</span></span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 超出了 t 的作用域</span></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(t); <span class="comment">// 报错</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-全局作用域"><a href="#2-全局作用域" class="headerlink" title="2 全局作用域"></a>2 全局作用域</h2><p><code>&lt;script&gt;</code> 标签和 <code>.js</code> 文件的【最外层】就是所谓的全局作用域，在此声明的变量在函数内部也可以被访问</p><p>全局作用域中声明的变量，任何其它作用域都可以被访问，如下代码所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 全局变量 name</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> name = <span class="string">&#x27;小明&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  </span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 函数作用域中访问全局</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 此处为局部</span></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;你好&#x27;</span> + name)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 全局变量 flag 和 x</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> flag = <span class="literal">true</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> x = <span class="number">10</span></span></span><br><span class="line"><span class="language-javascript">  </span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 块作用域中访问全局</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span>(flag) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> y = <span class="number">5</span></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(x + y) <span class="comment">// x 是全局的</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>为 <code>window</code> 对象动态添加的属性默认也是全局的，<strong>不推荐</strong></li><li>函数中未使用任何关键字声明的变量为全局变量，<strong>不推荐</strong></li><li>尽可能少的声明全局变量，防止全局变量被污染</li></ol><p>JavaScript 中的作用域是程序被执行时的底层机制，了解这一机制有助于规范代码书写习惯，避免因作用域导致的语法错误</p><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>作用域链本质上是底层的变量查找机制。在函数被执行时，会<strong>优先查找当前函数作用域</strong>，如果当前作用域查找不到则会<strong>依次逐级查找父级作用域直到全局作用域</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 全局作用域</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> a = <span class="number">1</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> b = <span class="number">2</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 局部作用域</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> c</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 局部作用域</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">g</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> d = <span class="string">&#x27;yo&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>函数内部允许创建新的函数，<code>f</code> 函数内部创建的新函数 <code>g</code>，会产生新的函数作用域，由此可知作用域产生了嵌套的关系。父子关系的作用域关联在一起形成了链状的结构，作用域链的名字也由此而来。</p><p>总结：</p><ol><li>嵌套关系的作用域串联起来形成了作用域链</li><li>相同作用域链中按着从小到大的规则查找变量</li><li>子作用域能够访问父作用域，父级作用域无法访问子级作用域</li></ol><h2 id="3-变量提升"><a href="#3-变量提升" class="headerlink" title="3 变量提升"></a>3 变量提升</h2><p>变量提升是 JavaScript 中比较“奇怪”的现象，它允许在变量声明之前即被访问</p><p>变量提升流程：</p><ol><li>先把var 变量提升到当前作用域于最前面</li><li>只提升变量声明， 不提升变量赋值</li><li>然后依次执行代码</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 访问变量 str</span></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(str + <span class="string">&#x27;world!&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 声明变量 str</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> str = <span class="string">&#x27;hello &#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>变量在未声明即被访问时会报语法错误</li><li>变量在声明之前即被访问，变量的值为 <code>undefined</code></li><li><code>let</code> 声明的变量不存在变量提升，推荐使用 <code>let</code></li><li>变量提升出现在相同作用域当中</li><li>实际开发中推荐先声明再访问变量</li></ol><p>注：关于变量提升的原理分析会涉及较为复杂的词法分析等知识，而开发中使用 <code>let</code> 可以轻松规避变量的提升</p><h2 id="4-闭包"><a href="#4-闭包" class="headerlink" title="4 闭包"></a>4 闭包</h2><p>闭包是一种比较特殊和函数，使用闭包能够访问函数作用域中的变量。</p><p>简单理解：<strong>闭包 &#x3D;  内层函数 + 外层函数的变量</strong></p><p>如下代码所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 1. 闭包 : 内层函数 + 外层函数变量</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// function outer() &#123;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//   const a = 1</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//   function f() &#123;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//     console.log(a)</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//   &#125;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//   f()</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// &#125;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// outer()</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 2. 闭包的应用： 实现数据的私有。统计函数的调用次数</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// let count = 1</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// function fn() &#123;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//   count++</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//   console.log(`函数被调用$&#123;count&#125;次`)</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// &#125;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 3. 闭包的写法  统计函数的调用次数</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> count = <span class="number">1</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        count++</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`函数被调用<span class="subst">$&#123;count&#125;</span>次`</span>)</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> fn</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> re = <span class="title function_">outer</span>()</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// const re = function fn() &#123;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//   count++</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//   console.log(`函数被调用$&#123;count&#125;次`)</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// &#125;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">re</span>()</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">re</span>()</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// const fn = function() &#123; &#125;  函数表达式</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 4. 闭包存在的问题： 可能会造成内存泄漏</span></span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>总结：</p><p>1.怎么理解闭包？</p><ul><li>闭包 &#x3D; 内层函数 + 外层函数的变量</li></ul><p>2.闭包的作用？</p><ul><li>封闭数据，实现数据私有，外部也可以访问函数内部的变量</li><li>闭包很有用，因为它允许将函数与其所操作的某些数据（环境）关联起来</li></ul><p>3.闭包可能引起的问题？</p><ul><li>内存泄漏</li></ul><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="1-函数提升"><a href="#1-函数提升" class="headerlink" title="1 函数提升"></a>1 函数提升</h2><p>函数提升与变量提升比较类似，是指函数在声明之前即可被调用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 调用函数</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">foo</span>()</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 声明函数</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;声明之前即被调用...&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 不存在提升现象</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">bar</span>()  <span class="comment">// 错误</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> bar = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;函数表达式不存在提升现象...&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>函数提升能够使函数的声明调用更灵活</li><li>函数表达式不存在提升的现象</li><li>函数提升出现在相同作用域当中</li></ol><h2 id="2-函数参数"><a href="#2-函数参数" class="headerlink" title="2 函数参数"></a>2 函数参数</h2><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 设置参数默认值</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params">name=<span class="string">&quot;小明&quot;</span>, age=<span class="number">18</span></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">`&lt;p&gt;大家好，我叫<span class="subst">$&#123;name&#125;</span>，我今年<span class="subst">$&#123;age&#125;</span>岁了。&lt;/p&gt;`</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 调用函数</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">sayHi</span>();</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">sayHi</span>(<span class="string">&#x27;小红&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">sayHi</span>(<span class="string">&#x27;小刚&#x27;</span>, <span class="number">21</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>声明函数时为形参赋值即为参数的默认值</li><li>如果参数未自定义默认值时，参数的默认值为 <code>undefined</code></li><li>调用函数时没有传入对应实参时，参数的默认值被当做实参传入</li></ol><h3 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h3><p><code>arguments</code> 是函数内部内置的伪数组变量，它包含了调用函数时传入的所有实参，只存在函数中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 求生函数，计算所有参数的和</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// console.log(arguments)</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> s = <span class="number">0</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span></span><br><span class="line"><span class="language-javascript">      s += <span class="variable language_">arguments</span>[i]</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(s)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 调用求和函数</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">sum</span>(<span class="number">5</span>, <span class="number">10</span>)<span class="comment">// 两个参数</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>) <span class="comment">// 两个参数</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>总结：</p><ol><li><code>arguments</code> 是一个伪数组</li><li><code>arguments</code> 的作用是动态获取函数的实参</li></ol><h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><p>剩余参数允许我们将一个不定数量的参数表示为一个数组</p><p>剩余参数：</p><ol><li><code>...</code> 是语法符号，置于最末函数形参之前，用于获取多余的实参</li><li>借助<code>...</code>获取的剩余实参，是个真数组</li><li>开发中，<strong>提倡多使用剩余参数</strong></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">config</span>(<span class="params">baseURL, ...other</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(baseURL) <span class="comment">// 得到 &#x27;http://baidu.com&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(other)  <span class="comment">// other  得到 [&#x27;get&#x27;, &#x27;json&#x27;]</span></span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 调用函数</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">config</span>(<span class="string">&#x27;http://baidu.com&#x27;</span>, <span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;json&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p>箭头函数是一种声明函数的简洁语法，它与普通函数并无本质的区别，差异性更多体现在语法格式上。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// const fn = function () &#123;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//   console.log(123)</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// &#125;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 1. 箭头函数 基本语法</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// const fn = () =&gt; &#123;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//   console.log(123)</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// &#125;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// fn()</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// const fn = (x) =&gt; &#123;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//   console.log(x)</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// &#125;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// fn(1)</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 2. 只有一个形参的时候，可以省略小括号</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// const fn = x =&gt; &#123;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//   console.log(x)</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// &#125;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// fn(1)</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// // 3. 只有一行代码的时候，我们可以省略大括号</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// const fn = x =&gt; console.log(x)</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// fn(1)</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 4. 只有一行代码的时候，可以省略return</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// const fn = x =&gt; x + x</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// console.log(fn(1))</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 5. 箭头函数可以直接返回一个对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// const fn = (uname) =&gt; (&#123; uname: uname &#125;)</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// console.log(fn(&#x27;刘德华&#x27;))</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>箭头函数属于表达式函数，因此不存在函数提升</li><li>箭头函数只有一个参数时可以省略圆括号 <code>()</code></li><li>箭头函数函数体只有一行代码时可以省略花括号 <code>&#123;&#125;</code>，并自动做为返回值被返回</li></ol><h4 id="箭头函数参数"><a href="#箭头函数参数" class="headerlink" title="箭头函数参数"></a>箭头函数参数</h4><p>箭头函数中没有 <code>arguments</code>，只能使用 <code>...</code> 动态获取实参</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 1. 利用箭头函数来求和</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> <span class="title function_">getSum</span> = (<span class="params">...arr</span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> sum = <span class="number">0</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span></span><br><span class="line"><span class="language-javascript">        sum += arr[i]</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> sum</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> result = <span class="title function_">getSum</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result) <span class="comment">// 9</span></span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="箭头函数-this"><a href="#箭头函数-this" class="headerlink" title="箭头函数 this"></a>箭头函数 this</h4><p>箭头函数不会创建自己的this,它只会从自己的作用域链的上一层沿用this。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">// 以前this的指向：  谁调用的这个函数，this 就指向谁</span></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">// console.log(this)  // window</span></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">// // 普通函数</span></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">// function fn() &#123;</span></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">//   console.log(this)  // window</span></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">// &#125;</span></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">// window.fn()</span></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">// // 对象方法里面的this</span></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">// const obj = &#123;</span></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">//   name: &#x27;andy&#x27;,</span></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">//   sayHi: function () &#123;</span></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">//     console.log(this)  // obj</span></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">//   &#125;</span></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">// &#125;</span></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">// obj.sayHi()</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">// 2. 箭头函数的this  是上一层作用域的this 指向</span></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">// const fn = () =&gt; &#123;</span></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">//   console.log(this)  // window</span></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">// &#125;</span></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">// fn()</span></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">// 对象方法箭头函数 this</span></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">// const obj = &#123;</span></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">//   uname: &#x27;pink老师&#x27;,</span></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">//   sayHi: () =&gt; &#123;</span></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">//     console.log(this)  // this 指向谁？ window</span></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">//   &#125;</span></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">// &#125;</span></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">// obj.sayHi()</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   <span class="keyword">const</span> obj = &#123;</span></span><br><span class="line"><span class="language-javascript">     <span class="attr">uname</span>: <span class="string">&#x27;pink老师&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">     <span class="attr">sayHi</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)  <span class="comment">// obj</span></span></span><br><span class="line"><span class="language-javascript">       <span class="keyword">let</span> i = <span class="number">10</span></span></span><br><span class="line"><span class="language-javascript">       <span class="keyword">const</span> <span class="title function_">count</span> = (<span class="params"></span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)  <span class="comment">// obj </span></span></span><br><span class="line"><span class="language-javascript">       &#125;</span></span><br><span class="line"><span class="language-javascript">       <span class="title function_">count</span>()</span></span><br><span class="line"><span class="language-javascript">     &#125;</span></span><br><span class="line"><span class="language-javascript">   &#125;</span></span><br><span class="line"><span class="language-javascript">   obj.<span class="title function_">sayHi</span>()</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"> </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DOM 事件</title>
      <link href="/2023/04/03/JS.3/"/>
      <url>/2023/04/03/JS.3/</url>
      
        <content type="html"><![CDATA[<h1 id="一、事件监听"><a href="#一、事件监听" class="headerlink" title="一、事件监听"></a>一、事件监听</h1><p>事件：在编程时系统内发生的动作或者发生的事情</p><p>事件监听：就是让程序检测是否有事件产生，一旦有事件触发，就立即调用一个函数做出响应，也称为<strong>注册事件</strong></p><p>事件监听三要素：</p><ol><li><strong>事件源：</strong> 那个 dom 元素被事件触发了，要获取 dom 元素</li><li><strong>事件类型：</strong> 用什么方式触发，事件类型要加引号</li><li><strong>事件调用的函数：</strong> 要做什么事</li></ol><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 1. 获取 button 对应的 DOM 对象</span><br><span class="line">const btn = document.querySelector(&#x27;#btn&#x27;)</span><br><span class="line">// 2. 添加事件监听</span><br><span class="line">元素对象.addEventListener(&#x27;事件类型&#x27;, 函数 () &#123;&#125;)</span><br></pre></td></tr></table></figure><p><code>addEventListener</code> 是 DOM 对象专门用来添加事件监听的方法，它的两个参数分别为<strong>事件类型</strong>和<strong>事件回调</strong></p><p>完成事件监听分成4个步骤：</p><ol><li>获取<strong>事件对象</strong> （ DOM 元素 ）</li><li>通过 <code>addEventListener</code> 方法为 DOM 对象添加事件监听</li><li>等待事件触发，如用户点击了某个按钮时便会触发 <code>click</code> 事件类型</li><li>事件触发后，相对应的回调函数会被执行</li></ol><h2 id="1-事件类型"><a href="#1-事件类型" class="headerlink" title="1 事件类型"></a>1 事件类型</h2><p>事件类型：决定了事件被触发的方式，将众多的事件类型分类可分为：鼠标事件、键盘事件、表单事件、焦点事件等</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230403164222.png"></p><p>阻止默认行为：</p><blockquote><p>e.preventDefault ( )</p></blockquote><h2 id="2-事件对象"><a href="#2-事件对象" class="headerlink" title="2 事件对象"></a>2 事件对象</h2><p>任意事件类型被触发时与事件相关的信息会被以对象的形式记录下来，我们称这个对象为事件对象。</p><p>获取事件对象：</p><ol><li>事件回调函数的<strong>第1个参数</strong>即所谓的事件对象，</li><li>通常习惯性的将这个对数命名为 <code>event</code>、<code>ev</code> 、<code>ev</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">元素对象.addEventListener(&#x27;事件类型&#x27;, 函数 (事件对象) &#123;&#125;)</span><br></pre></td></tr></table></figure><p>对象具有属性和方法，如：</p><ol><li><code>ev.type</code> 当前事件的类型</li><li><code>ev.clientX/Y</code> 光标相对浏览器窗口的位置</li><li><code>ev.offsetX/Y</code> 光标相于当前 DOM 元素的位置</li><li><code>key</code>用户按下的键盘键的值</li></ol><blockquote><p>在事件回调函数内部通过 window.event 同样可以获取事件对象</p></blockquote><h2 id="3-环境对象"><a href="#3-环境对象" class="headerlink" title="3 环境对象"></a>3 环境对象</h2><p>环境对象：指的是函数内部特殊的变量 <code>this</code> ，它代表着当前函数运行时所处的环境，弄清楚this的指向，可以让我们代码更简洁</p><p><strong>谁调用， this 就是谁</strong>是判断 this 指向的粗略规则</p><blockquote><p>直接调用函数，其实相当于是 window.函数，所以 this 指代 window</p></blockquote><h2 id="4-回调函数"><a href="#4-回调函数" class="headerlink" title="4 回调函数"></a>4 回调函数</h2><p>如果将函数 A 做为参数传递给函数 B 时，我们称函数 A 为回调函数，当一个函数当做参数来传递给另外一个函数的时候，这个函数就是回调函数</p><p>间歇函数 <code>setInterval</code>：使用匿名函数做为回调函数比较常见</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">function fn() &#123;</span><br><span class="line">    console.log(&#x27;我是回调函数...&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">  // 调用定时器</span><br><span class="line">  setInterval(fn, 1000);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><code>fn</code> 函数做为参数传给了 <code>setInterval</code> ，这便是回调函数的一个应用了，这个应用还有另一种更常见写法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  // 调用定时器，匿名函数做为参数</span><br><span class="line">  setInterval(function () &#123;</span><br><span class="line">    console.log(&#x27;我是回调函数...&#x27;);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&lt;/script&gt;`</span><br></pre></td></tr></table></figure><blockquote><p>回调函数本质还是函数，只不过把它当成参数使用</p></blockquote><h1 id="二、事件流"><a href="#二、事件流" class="headerlink" title="二、事件流"></a>二、事件流</h1><p>事件流是对事件执行过程的描述，了解事件的执行过程有助于加深对事件的理解，提升开发实践中对事件运用的灵活度</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230408161833.png"></p><p>任意事件被触发时总会经历两个阶段：</p><ul><li>捕获阶段</li><li>冒泡阶段</li></ul><p>如果事件是在冒泡阶段执行的，我们称为冒泡模式，它会先执行子盒子事件再去执行父盒子事件，默认是冒泡模式</p><p>如果事件是在捕获阶段执行的，我们称为捕获模式，它会先执行父盒子事件再去执行子盒子事件</p><p>简单来说：捕获阶段是 从父到子 冒泡阶段是从子到父，<strong>实际工作都是使用事件冒泡为主</strong></p><h2 id="1-捕获与冒泡"><a href="#1-捕获与冒泡" class="headerlink" title="1 捕获与冒泡"></a>1 捕获与冒泡</h2><p>事件捕获：从DOM的根元素开始去执行对应的事件 (从外到里)</p><p>事件捕获需要写对应代码才能看到效果</p><blockquote><p>DOM.addEventListener(‘事件’, function () {}, 是否使用捕获机制)</p></blockquote><p>事件冒泡：从DOM的叶元素开始去执行对应的事件 (从里到外)</p><p>说明：</p><ol><li>addEventListener 第三个参数传入 true 代表是捕获阶段触发（很少使用）</li><li>若传入false代表冒泡阶段触发，默认就是false</li><li>事件流只会在父子元素具有<strong>相同事件类型</strong>时才会产生影响</li></ol><h2 id="2-阻止冒泡"><a href="#2-阻止冒泡" class="headerlink" title="2 阻止冒泡"></a>2 阻止冒泡</h2><p>阻止冒泡：阻止冒泡是指阻断事件的流动，保证事件只在当前元素被执行，而不再去影响到其对应的祖先元素</p><p>语法：</p><blockquote><p>事件对象.stopPropagation ( )</p></blockquote><p><strong>注意：</strong>此方法可以阻断事件流动传播，不光在冒泡阶段有效，捕获阶段也有效</p><h2 id="3-解绑事件"><a href="#3-解绑事件" class="headerlink" title="3 解绑事件"></a>3 解绑事件</h2><p>on事件方式，直接使用null覆盖偶就可以实现事件的解绑</p><blockquote><p>对象.onclick &#x3D; null</p></blockquote><p>addEventListener方式，必须使用：</p><blockquote><p>对象.removeEventListener(事件类型, 事件处理函数, [获取捕获或者冒泡阶段])</p></blockquote><p><strong>注意：匿名函数无法被解绑</strong></p><h1 id="三、事件委托"><a href="#三、事件委托" class="headerlink" title="三、事件委托"></a>三、事件委托</h1><p>事件委托：事件的的冒泡模式总是会将事件流向其父元素的，如果父元素监听了相同的事件类型，那么父元素的事件就会被触发并执行，正是利用这一特征对上述代码进行优化</p><p>优点：减少注册次数，可以提高程序性能</p><p>原理：事件委托其实是利用事件冒泡的特点，<strong>给父元素注册事件</strong>，当我们触发子元素的时候，会冒泡到父元素身上，从而触发父元素的事件</p><p>实现：<strong>事件对象.target.tagName</strong> 可以获得真正触发事件的元素</p><h1 id="四、其他事件"><a href="#四、其他事件" class="headerlink" title="四、其他事件"></a>四、其他事件</h1><h2 id="1-页面加载事件"><a href="#1-页面加载事件" class="headerlink" title="1 页面加载事件"></a>1 页面加载事件</h2><p>为什么要学：</p><ol><li>加载外部资源（如图片、外联CSS和JavaScript等）加载完毕时触发的事件，有些时候需要等页面资源全部处理完了做一些事情</li><li>老代码喜欢把 script 写在 head 中，这时候直接找 dom 元素找不到</li></ol><h3 id="load"><a href="#load" class="headerlink" title="load"></a>load</h3><p>事件名：load</p><p>加载外部资源（如图片、外联CSS和JavaScript等）加载完毕时触发的事件</p><p>注意：不光可以监听整个页面资源加载完毕，也可以针对某个资源绑定load事件</p><h3 id="DOMContentLoaded"><a href="#DOMContentLoaded" class="headerlink" title="DOMContentLoaded"></a>DOMContentLoaded</h3><p>事件名：DOMContentLoaded</p><p>当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像等完全加载</p><h2 id="2-元素滚动事件"><a href="#2-元素滚动事件" class="headerlink" title="2 元素滚动事件"></a>2 元素滚动事件</h2><p>事件名：scroll</p><p>滚动条在滚动的时候持续触发的事件</p><p>监听整个页面滚动：</p><blockquote><p>window.addEventListener(‘scroll’,function(){})</p></blockquote><p>监听某个元素的内部滚动直接给某个元素加即可：</p><blockquote><p>元素.addEventListener(‘scroll’,function(){})</p></blockquote><p>使用场景：很多网页需要检测用户把页面滚动到某个区域后做一些处理， 比如固定导航栏，比如返回顶部</p><h3 id="2-1-页面滚动事件-获取位置"><a href="#2-1-页面滚动事件-获取位置" class="headerlink" title="2.1 页面滚动事件-获取位置"></a>2.1 页面滚动事件-获取位置</h3><p>scrollLeft和scrollTop：</p><ul><li>获取被卷去的大小</li><li>获取元素内容往左、往上滚出去看不到的距离</li><li>这两个值是可<strong>读写</strong>的</li><li>尽量在scroll事件里面获取被卷去的距离</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230408185526.png"></p><p>开发中，我们经常检测页面滚动的距离，比如页面滚动100像素，就可以显示一个元素，或者固定一个元素</p><h3 id="2-2-页面滚动事件-滚动到指定的坐标"><a href="#2-2-页面滚动事件-滚动到指定的坐标" class="headerlink" title="2.2 页面滚动事件-滚动到指定的坐标"></a>2.2 页面滚动事件-滚动到指定的坐标</h3><p>scrollTo()：可把内容滚动到指定的坐标</p><p>语法：</p><blockquote><p>元素.scrollTo(x, y)</p></blockquote><h2 id="3-页面尺寸事件"><a href="#3-页面尺寸事件" class="headerlink" title="3 页面尺寸事件"></a>3 页面尺寸事件</h2><p>事件名：resize</p><p>会在窗口尺寸改变的时候触发事件</p><p>检测屏幕宽度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#x27;resize&#x27;, function() &#123;</span><br><span class="line">    let w = document.documentElement.clientWidth</span><br><span class="line">    console.log(w)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="3-1-页面尺寸事件-获取元素宽高"><a href="#3-1-页面尺寸事件-获取元素宽高" class="headerlink" title="3.1 页面尺寸事件-获取元素宽高"></a>3.1 页面尺寸事件-获取元素宽高</h3><p>获取宽高：获取元素的可见部分宽高（不包含边框，margin，滚动条等）</p><p>clientWidth：可见宽，返回值是数字类型</p><p>clientHeight：可见高，返回值是数字类型</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230408190738.png"></p><h1 id="五、元素尺寸于位置"><a href="#五、元素尺寸于位置" class="headerlink" title="五、元素尺寸于位置"></a>五、元素尺寸于位置</h1><p>使用场景：通过js的方式，得到元素在页面中的位置，帮助页面滚动到这个位置</p><p>获取宽高：获取元素的自身宽高，包含元素自身设置的宽高、padding、border</p><blockquote><p>注意: 获取的是可视宽高, 如果盒子是隐藏的,获取的结果是0</p></blockquote><p>获取位置：获取元素距离自己定位父级元素的左、上距离，如果都没有则以<strong>文档左上角</strong>为准</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230408193143.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DOM</title>
      <link href="/2023/03/31/JS.2/"/>
      <url>/2023/03/31/JS.2/</url>
      
        <content type="html"><![CDATA[<h1 id="Web-APIs-介绍"><a href="#Web-APIs-介绍" class="headerlink" title="Web APIs 介绍"></a>Web APIs 介绍</h1><p>ECMAScript 简称 ES 它提供了一套语言标准规范，如变量、数据类型、表达式、语句、函数等语法规则都是由 ECMAScript 规定的。浏览器将 ECMAScript 大部分的规范加以实现，并且在此基础上又扩展一些实用的功能，这些被扩展出来的内容我们称为 Web APIs</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230331200257.png"></p><p>ECMAScript 运行在浏览器中然后再结合 Web APIs 才是真正的 JavaScript，Web APIs 的核心是 <strong>DOM</strong> 和 <strong>BOM</strong></p><p>作用: 就是使用 JS 去操作 html 和浏览器</p><p>分类：DOM (文档对象模型)、BOM（浏览器对象模型）</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230401142525.png"></p><h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><p>DOM（ Document Object Model——文档对象模型 ）是用来呈现以及与任意 HTML 或 XML文档交互的API，DOM是浏览器提供的一套专门用来 <strong>操作网页内容</strong> 的功能</p><p>作用：开发网页内容特效和实现用户交互</p><h2 id="1-DOM-树"><a href="#1-DOM-树" class="headerlink" title="1 DOM 树"></a>1 DOM 树</h2><p>如下图所示，将 HTML 文档以树状结构直观的表现出来，我们称之为文档树或 DOM 树，</p><p>作用：文档树直观的体现了标签与标签之间的关系</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230331201548.png"></p><h2 id="2-DOM-对象"><a href="#2-DOM-对象" class="headerlink" title="2 DOM 对象"></a>2 DOM 对象</h2><p><strong>节点</strong>是文档树的组成部分，每一个节点都是一个 <strong>DOM 对象</strong>，主要分为<strong>元素节点</strong>、<strong>属性节点</strong>、<strong>文本节点</strong>等。</p><p>节点类型：</p><ol><li>元素节点：就是 HTML 标签，如上图中 <code>head</code>、<code>div</code>、<code>body</code> 等都属于元素节点。</li><li>属性节点：是指 HTML 标签中的属性，如上图中 <code>a</code> 标签的 <code>href</code> 属性、<code>div</code> 标签的 <code>class</code> 属性。</li><li>文本节点：是指 HTML 标签的文字内容，如 <code>title</code> 标签中的文字。</li><li>根节点：特指 <code>html</code> 标签</li></ol><p>DOM对象：浏览器根据html标签生成的 JS对象，所有的标签属性都可以在这个对象上面找到，修改这个对象的属性会自动映射到标签身上</p><p>DOM的核心思想：把网页内容当做对象来处理</p><h2 id="3-document"><a href="#3-document" class="headerlink" title="3 document"></a>3 document</h2><p><code>document</code> 是 JavaScript 内置的专门用于 DOM 的对象，该对象包含了若干的属性和方法，它提供的属性和方法都是<strong>用来访问和操作网页内容的</strong>，网页所有内容都在document里面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  // document 是内置的对象</span><br><span class="line">  // console.log(typeof document);</span><br><span class="line">  // 1. 通过 document 获取根节点</span><br><span class="line">  console.log(document.documentElement); // 对应 html 标签</span><br><span class="line">  </span><br><span class="line">  // 2. 通过 document 节取 body 节点</span><br><span class="line">  console.log(document.body); // 对应 body 标签</span><br><span class="line">  </span><br><span class="line">  // 3. 通过 document.write 方法向网页输出内容</span><br><span class="line">  document.write(&#x27;Hello World!&#x27;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="4-获取DOM对象"><a href="#4-获取DOM对象" class="headerlink" title="4 获取DOM对象"></a>4 获取DOM对象</h2><h3 id="4-1-变量声明"><a href="#4-1-变量声明" class="headerlink" title="4.1 变量声明"></a>4.1 变量声明</h3><p>声明变量可以用 let 和 const，建议 const 优先，尽量使用const，如果发现它后面是要被修改的，再改为let</p><blockquote><p>const 声明的值不能更改，而且 const 声明变量的时候需要里面进行初始化</p></blockquote><p>JavaScript 中，改变<strong>数组</strong>和<strong>对象</strong>中的内容不影响对其定位，变量仍然指向该变量，可以用 const 定义数组和对象</p><blockquote><p>对于引用数据类型，const声明的变量，里面存的不是值，不是值，不是值，是<strong>地址</strong></p></blockquote><h3 id="4-2-根据CSS选择器来获取DOM元素"><a href="#4-2-根据CSS选择器来获取DOM元素" class="headerlink" title="4.2 根据CSS选择器来获取DOM元素"></a>4.2 根据CSS选择器来获取DOM元素</h3><p><strong>查找元素DOM元素就是利用 JS 选择页面中标签元素</strong></p><ol><li>选择匹配的第一个元素</li></ol><p><strong>语法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const p = document.querySelector(&#x27;p&#x27;)  // 获取第一个 p 元素</span><br></pre></td></tr></table></figure><p><strong>参数</strong>：包含一个或多个有效的CSS选择器 <strong>字符串</strong>（字符串输入要加引号）</p><p><strong>返回值</strong>：CSS选择器匹配的第一个元素，一个 HTMLElement对象，如果没有匹配到，则返回null</p><p>可以直接使用变量修改</p><ol start="2"><li>选择匹配的多个元素</li></ol><p><strong>语法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const lis = document.querySelectorAll(&#x27;li&#x27;)  // 获取第一个 li 元素</span><br></pre></td></tr></table></figure><p><strong>参数</strong>：包含一个或多个有效的CSS选择器 <strong>字符串</strong>（字符串输入要加引号）</p><p><strong>返回值</strong>：CSS选择器匹配的NodeList 对象集合，返回伪数组</p><p>不可以直接使用变量修改，变量接受的是一个伪数组，只能通过遍历的方式一次给里面的元素做修改</p><h3 id="4-3-其他获取DOM元素方法"><a href="#4-3-其他获取DOM元素方法" class="headerlink" title="4.3 其他获取DOM元素方法"></a>4.3 其他获取DOM元素方法</h3><h2 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h2><p>DOM 树中的任意节点都不是孤立存在的，它们要么是父子关系，要么是兄弟关系，不仅如此，我们可以依据节点之间的关系查找节点</p><p>父节点查找：</p><ul><li>子元素.parentNode</li><li>返回最近一级的父节点 找不到返回为null</li></ul><p>子节点查找：</p><ol><li>父元素.childNodes：获得所有子节点、包括文本节点（空格、换行）、注释节点等</li><li>父元素.children：仅获得所有元素节点，返回的还是一个<strong>伪数组</strong></li></ol><p>兄弟关系查找：</p><ol><li>下一个兄弟节点：nextElementSibling</li><li>上一个兄弟节点：previousElementSibling</li></ol><p>结论：</p><ul><li><code>childNodes</code> 获取全部的子节点，回车换行会被认为是空白文本节点</li><li><code>children</code> 只获取元素类型节点</li><li><code>parentNode</code> 获取父节点，以相对位置查找节点，实际应用中非常灵活</li><li><code>previousSibling</code> 获取前一个节点，以相对位置查找节点，实际应用中非常灵活。</li><li><code>nextSibling</code> 获取后一个节点，以相对位置查找节点，实际应用中非常灵活</li></ul><h2 id="增加节点"><a href="#增加节点" class="headerlink" title="增加节点"></a>增加节点</h2><ol><li><p>创建节点</p></li><li><p>插入节点</p></li></ol><p>在已有的 DOM 节点中插入新的 DOM 节点时，需要关注两个关键因素：首先要得到新的 DOM 节点，其次在哪个位置插入这个节点</p><p>结论：</p><ul><li><p><code>createElement</code> 动态创建任意 DOM 节点</p></li><li><p><code>cloneNode</code> 复制现有的 DOM 节点，传入参数 true 会复制所有子节点</p></li><li><p><code>appendChild</code> 在末尾（结束标签前）插入节点</p></li><li><p><code>insertBefore</code> 在父节点中任意子节点之前插入新节点</p></li></ul><h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><p>在 JavaScript 原生DOM操作中，要删除元素<strong>必须通过父元素删除</strong></p><p>删除现有的 DOM 节点，也需要关注两个因素：首先由父节点删除子节点，其次是要删除哪个子节点。</p><p>父元素.removeChild（要删除的元素）</p><p>结论：<code>removeChild</code> 删除节点时一定是由父子关系</p><h2 id="5-操作元素内容"><a href="#5-操作元素内容" class="headerlink" title="5 操作元素内容"></a>5 操作元素内容</h2><p>通过修改 DOM 的文本内容，动态改变网页的内容</p><p><code>innerText</code> 将文本内容添加&#x2F;更新到任意标签位置，文本中包含的<strong>标签不会被解析</strong></p><p><code>innerHTML</code> 将文本内容添加&#x2F;更新到任意标签位置，文本中包含的<strong>标签会被解析</strong></p><blockquote><p>如果文本内容中包含 <code>html</code> 标签时推荐使用 <code>innerHTML</code>，否则建议使用 <code>innerText</code> 属性</p></blockquote><p>获取对象后修改内容属性生效</p><h2 id="6-操作元素属性"><a href="#6-操作元素属性" class="headerlink" title="6 操作元素属性"></a>6 操作元素属性</h2><h3 id="6-1-常用属性修改"><a href="#6-1-常用属性修改" class="headerlink" title="6.1 常用属性修改"></a>6.1 常用属性修改</h3><p>直接能过属性名修改，最简洁的语法</p><p>最常见的属性比如： href、title、src 等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 1. 获取 DOM 元素</span><br><span class="line">const pic = document.querySelector(&#x27;.pic&#x27;)</span><br><span class="line">// 2. 修改属性</span><br><span class="line">// 对象.属性 = 值</span><br><span class="line">pic.src = &#x27;./images&#x27;</span><br><span class="line">pic.alt = &#x27;图片不见了...&#x27;</span><br></pre></td></tr></table></figure><h3 id="6-2-样式属性修改"><a href="#6-2-样式属性修改" class="headerlink" title="6.2 样式属性修改"></a>6.2 样式属性修改</h3><h4 id="6-2-1-通过-style-修改样式"><a href="#6-2-1-通过-style-修改样式" class="headerlink" title="6.2.1 通过 style 修改样式"></a>6.2.1 通过 style 修改样式</h4><p>通过修改行内样式 <strong>style</strong> 属性，实现对样式的动态修改</p><blockquote><p>通过元素节点获得的 <code>style</code> 属性本身的数据类型也是对象</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 1. 获取 DOM 节点</span><br><span class="line">const box = document.querySelector(&#x27;.intro&#x27;)</span><br><span class="line">// 2. 修改属性</span><br><span class="line">//赋值的时候，需要的时候不要忘记加css单位</span><br><span class="line">box.style.width = &#x27;300px&#x27;</span><br><span class="line">// css 属性的 - 连接符与 JavaScript 的 减运算符</span><br><span class="line">// 冲突，所以要改成驼峰法</span><br><span class="line">box.style.backgroundColor = &#x27;pink&#x27;</span><br></pre></td></tr></table></figure><p>任何标签都有 <code>style</code> 属性，通过 <code>style</code> 属性可以动态更改网页标签的样式，如要遇到 <code>css</code> 属性中包含字符 <code>-</code> 时，要将 <code>-</code> 去掉并将其后面的字母改成大写，如 <code>background-color</code> 要写成 <code>box.style.backgroundColor</code></p><blockquote><p>样式属性，一定别忘记，大部分数字后面都需要加单位，加单位的是字符串类型，要加引号</p></blockquote><h4 id="6-2-2-通过-className-修改样式"><a href="#6-2-2-通过-className-修改样式" class="headerlink" title="6.2.2 通过 className 修改样式"></a>6.2.2 通过 className 修改样式</h4><p>如果修改的样式比较多，直接通过style属性修改比较繁琐，我们可以通过借助于css类名的形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 获取 DOM 节点</span><br><span class="line">const box = document.querySelector(&#x27;.intro&#x27;)</span><br><span class="line">//给类对象重新赋值，更改类（覆盖更改）</span><br><span class="line">box.className = &#x27;pink&#x27;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>由于class是关键字，所以使用className去代替</li><li>className是使用新值换旧值，如果需要添加一个类，需要保留之前的类名</li><li>可以使用多类来保留之前的类，多个类共同作用</li></ol><h4 id="6-2-3-classList"><a href="#6-2-3-classList" class="headerlink" title="6.2.3 classList"></a>6.2.3 classList</h4><p>为了解决className 容易覆盖以前的类名，我们可以通过classList方式追加和删除类名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 获取 DOM 对象</span><br><span class="line">const box = document.querySelector(&#x27;.intro&#x27;)</span><br><span class="line">//给类对象追加一个类</span><br><span class="line">box.classList.add（&#x27;类名&#x27;）</span><br><span class="line">//给类对象删除一个类</span><br><span class="line">box.classList.remove（&#x27;类名&#x27;）</span><br><span class="line">//给类对象切换一个类</span><br><span class="line">box.classList.toggle（&#x27;类名&#x27;）</span><br></pre></td></tr></table></figure><blockquote><p>切换相当于取非，之前没有就加，有就删除</p></blockquote><p>使用 className 和classList的区别</p><ol><li>修改大量样式的更方便</li><li>修改不多样式的时候方便</li><li>classList 是追加和删除不影响以前类名</li></ol><h3 id="6-3-操作表单元素属性"><a href="#6-3-操作表单元素属性" class="headerlink" title="6.3 操作表单元素属性"></a>6.3 操作表单元素属性</h3><p>表单属性中添加就有效果,移除就没有效果,一律使用布尔值表示 如果为true 代表添加了该属性 如果是false 代表移除了该属性，比如： disabled、checked、selected</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//获取 DOM 对象，DOM对象.属性名</span><br><span class="line">const uname = document.querySelector(&#x27;input&#x27;)</span><br><span class="line">//修改属性值，DOM对象.属性名 = 新值</span><br><span class="line">uname.type = &#x27;password&#x27;</span><br></pre></td></tr></table></figure><h3 id="6-4-自定义属性"><a href="#6-4-自定义属性" class="headerlink" title="6.4 自定义属性"></a>6.4 自定义属性</h3><p>标准属性: 标签天生自带的属性 比如class id title等, 可以直接使用点语法操作比如： disabled、checked、selected</p><p>自定义属性：在html5中推出来了专门的data-自定义属性 ，在标签上一律以 <strong>data-</strong> 开头，在DOM对象上一律以 <strong>dataset</strong> 对象方式获取</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 1. 获取元素</span><br><span class="line">let div = document.querySelector(&#x27;div&#x27;)</span><br><span class="line">// 2. 获取自定义属性值</span><br><span class="line">console.log(div.dataset.id)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基础</title>
      <link href="/2023/03/25/JS.1/"/>
      <url>/2023/03/25/JS.1/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript介绍"><a href="#JavaScript介绍" class="headerlink" title="JavaScript介绍"></a>JavaScript介绍</h1><p>JavaScript 是一种运行在客户端（浏览器）的编程语言，实现人机交互效果</p><p>是一种弱类型语言</p><p>JavaScript 可以实现：</p><ul><li>网页特效 (监听用户的一些行为让网页作出对应的反馈) </li><li>表单验证 (针对表单数据的合法性进行判断)</li><li>数据交互(获取后台的数据,渲染到前端)</li><li>服务端编程(node.js)</li></ul><p>有什么：</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230325192917.png"></p><p>ECMAScript：规定了js基础语法核心知识。比如：变量、分支语句、循环语句、对象等等</p><p>Web APIs :</p><ul><li>DOM 操作文档，比如对页面元素进行移动、大小、添加删除等操作</li><li>BOM 操作浏览器，比如页面弹窗，检测窗口宽度、存储数据到浏览器等等</li></ul><p><strong>JavaScript权威网站：</strong> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript</a></p><h1 id="JavaScript-引入"><a href="#JavaScript-引入" class="headerlink" title="JavaScript 引入"></a>JavaScript 引入</h1><p>JavaScript 程序不能独立运行，它需要被嵌入 HTML 中，然后浏览器才能执行 JavaScript 代码。通过 <code>script</code> 标签将 JavaScript 代码引入到 HTML 中。和 CSS 一样有三种引入方式</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230325193445.png"></p><p>内部 JavaScript：直接写在html文件里，用script标签包住，写在 &lt; &#x2F;body&gt; 上面</p><p>外部 JavaScript：代码写在以.js结尾的文件里，通过script标签，引入到html页面中</p><p>内联 JavaScript：代码写在标签内部，后面vue框架会用这种模式</p><h1 id="JavaScript-输入输出语法"><a href="#JavaScript-输入输出语法" class="headerlink" title="JavaScript 输入输出语法"></a>JavaScript 输入输出语法</h1><h2 id="1-输出语法"><a href="#1-输出语法" class="headerlink" title="1. 输出语法"></a>1. 输出语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">语法1</span><br><span class="line">document.write(&quot;要输出的内容&quot;)</span><br><span class="line">语法2</span><br><span class="line">alert(&quot;要输出的内容&quot;)</span><br><span class="line">语法3</span><br><span class="line">console.log(&quot;要输出的内容&quot;)</span><br></pre></td></tr></table></figure><p>输出可以使用 <code>+</code> 连接数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prompt(&quot;要打印的内容1&quot; + &quot;要打印的内容2&quot;)</span><br></pre></td></tr></table></figure><p>输出变量：使用  <code>$&#123;变量名&#125;</code> 来快速输出变量值</p><h2 id="2-输入语法"><a href="#2-输入语法" class="headerlink" title="2. 输入语法"></a>2. 输入语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prompt(&quot;要打印的内容&quot;)</span><br></pre></td></tr></table></figure><p><strong>作用：</strong>显示一个弹窗，弹窗中包含一条文字信息，用来提示用户输入文字</p><h1 id="JavaScript数据"><a href="#JavaScript数据" class="headerlink" title="JavaScript数据"></a>JavaScript数据</h1><h2 id="1-变量"><a href="#1-变量" class="headerlink" title="1 变量"></a>1 变量</h2><p>变量：计算机中用来<strong>存储数据</strong>的“容器”，变量不是数据本身，它们仅仅是一个用于存储数值的容器</p><h3 id="1-1-变量的声明"><a href="#1-1-变量的声明" class="headerlink" title="1.1 变量的声明"></a>1.1 变量的声明</h3><p>声明(定义)变量有两部分构成：声明关键字、变量名（标识）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let 变量名</span><br></pre></td></tr></table></figure><h3 id="1-2-变量的赋值"><a href="#1-2-变量的赋值" class="headerlink" title="1.2 变量的赋值"></a>1.2 变量的赋值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名 = 变量值</span><br></pre></td></tr></table></figure><h3 id="1-3-关键字"><a href="#1-3-关键字" class="headerlink" title="1.3 关键字"></a>1.3 关键字</h3><p>JavaScript 使用专门的关键字 <code>let</code> 和 <code>var</code> 来声明（定义）变量，在使用时需要注意一些细节：</p><p>以下是使用 <code>let</code> 时的注意事项：</p><ol><li>允许声明和赋值同时进行</li><li>不允许重复声明</li><li>允许同时声明多个变量并赋值</li><li>JavaScript 中内置的一些关键字不能被当做变量名</li></ol><p>以下是使用 <code>var</code> 时的注意事项：</p><ol><li>允许声明和赋值同时进行</li><li>允许重复声明</li><li>允许同时声明多个变量并赋值</li></ol><p>大部分情况使用 <code>let</code> 和 <code>var</code> 区别不大，但是 <code>let</code> 相较 <code>var</code> 更严谨，因此推荐使用 <code>let</code></p><h3 id="1-4-变量名命名规则"><a href="#1-4-变量名命名规则" class="headerlink" title="1.4 变量名命名规则"></a>1.4 变量名命名规则</h3><p>关于变量的名称（标识符）有一系列的规则需要遵守：</p><ol><li>只能是字母、数字、下划线、$，且不能能数字开头</li><li>字母区分大小写，如 Age 和 age 是不同的变量</li><li>JavaScript 内部已占用于单词（关键字或保留字）不允许使用</li><li>尽量保证变量具有一定的语义，见字知义</li><li>小驼峰规则</li></ol><p>注：所谓关键字是指 JavaScript 内部使用的词语，如 <code>let</code> 和<code>var</code>，保留字是指 JavaScript 内部目前没有使用的词语，但是将来可能会使用词语。</p><h2 id="2-常量"><a href="#2-常量" class="headerlink" title="2 常量"></a>2 常量</h2><p>使用 const 声明的变量称为“常量”</p><p>命名规范：和变量一致</p><blockquote><p>注意： 常量不允许重新赋值,声明的时候必须赋值（初始化）</p></blockquote><h2 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3 数据类型"></a>3 数据类型</h2><p>计算机程序可以处理大量的数据，为了方便数据的管理，将数据分成了不同的类型</p><p>JS 数据类型整体分为两大类：<strong>基本数据类型</strong>和<strong>引用数据类型</strong></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230325203020.png"></p><p><strong>数字类型</strong>：</p><p>即我们数学中学习到的数字，可以是整数、小数、正数、负数</p><p><strong>字符串类型</strong>：</p><p>通过单引号（ <code>&#39;&#39;</code>） 、双引号（ <code>&quot;&quot;</code>）或反引号（<code>``</code>）包裹的数据都叫字符串，单引号和双引号没有本质上的区别，推荐使用单引号。</p><p>注意事项：</p><ul><li>无论单引号或是双引号必须成对使用</li><li>单引号&#x2F;双引号可以互相嵌套，但是不以自已嵌套自已</li><li>必要时可以使用转义符 <code>\</code>，输出单引号或双引号</li></ul><p><strong>布尔类型</strong>：</p><p>表示肯定或否定时在计算机中对应的是布尔类型数据，它有两个固定的值 <code>true</code> 和 <code>false</code>，表示肯定的数据用 <code>true</code>，表示否定的数据用 <code>false</code></p><p><strong>undefined</strong>：</p><p>未定义是比较特殊的类型，只有一个值 undefined，只声明变量，不赋值的情况下，变量的默认值为 undefined，一般很少直接为某个变量赋值为 undefined</p><p><strong>null</strong>：</p><p>null 仅仅是一个代表“无”、“空”或“值未知”的特殊值</p><p><strong>null 和 undefined 区别：</strong></p><ul><li><p>undefined 表示没有赋值</p></li><li><p>null 表示赋值了，但是内容为空</p></li></ul><blockquote><p>注：JavaScript 中变量的值决定了变量的数据类型，弱类型语言</p></blockquote><h2 id="4-数据类型检测"><a href="#4-数据类型检测" class="headerlink" title="4 数据类型检测"></a>4 数据类型检测</h2><p>通过 <strong>typeof</strong> 关键字检测数据类型</p><p>typeof 运算符可以返回被检测的数据类型。它支持两种语法形式：</p><ol><li><p>作为运算符： typeof x （常用的写法）</p></li><li><p>函数形式： typeof(x)</p></li></ol><h2 id="5-类型转换"><a href="#5-类型转换" class="headerlink" title="5 类型转换"></a>5 类型转换</h2><p>在 JavaScript 中数据被分成了不同的类型，如数值、字符串、布尔值、undefined，在实际编程的过程中，不同数据类型之间存在着转换的关系</p><h3 id="5-1-隐式转换"><a href="#5-1-隐式转换" class="headerlink" title="5.1 隐式转换"></a>5.1 隐式转换</h3><p>某些运算符被执行时，系统内部自动将数据类型进行转换，这种转换称为隐式转换</p><blockquote><p>注：数据类型的隐式转换是 JavaScript 的特征，后续学习中还会遇到，目前先需要理解什么是隐式转换</p></blockquote><p>规则：</p><ul><li>+ 号两边只要有一个是字符串，都会把另外一个转成字符串</li><li>除了+以外的算术运算符 比如 - * &#x2F; 等都会把数据转成数字类型</li></ul><h3 id="5-2-显式转换"><a href="#5-2-显式转换" class="headerlink" title="5.2 显式转换"></a>5.2 显式转换</h3><p>转换为数字型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Number(内容)</span><br></pre></td></tr></table></figure><p>如果字符串内容是纯数字，转成数字类型；如果字符串内容里有非数字，转换失败时结果为 NaN（</p><p>Not a Number）即不是一个数字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parseInt(数据)</span><br></pre></td></tr></table></figure><p>只保留整数（ Int ）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parseFloat(数据)</span><br></pre></td></tr></table></figure><p>可以保留小数（Float）</p><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1 算术运算符"></a>1 算术运算符</h2><p>数字是用来计算的，比如：乘法 * 、除法 &#x2F; 、加法 + 、减法 - 等等，所以经常和算术运算符一起。</p><p>算术运算符：也叫数学运算符，主要包括加、减、乘、除、取余（求模）等</p><table><thead><tr><th>运算符</th><th>作用</th></tr></thead><tbody><tr><td>+</td><td>求和</td></tr><tr><td>-</td><td>求差</td></tr><tr><td>*</td><td>求积</td></tr><tr><td>&#x2F;</td><td>求商</td></tr><tr><td><strong>%</strong></td><td>取模（取余数），开发中经常用于作为某个数字是否被整除</td></tr></tbody></table><blockquote><p>注意：在计算失败时，显示的结果是 NaN （not a number）</p></blockquote><h2 id="2-赋值运算符"><a href="#2-赋值运算符" class="headerlink" title="2 赋值运算符"></a>2 赋值运算符</h2><p>赋值运算符：对变量进行赋值的运算符</p><p> &#x3D;     将等号右边的值赋予给左边, 要求左边必须是一个容器</p><table><thead><tr><th>运算符</th><th>作用</th></tr></thead><tbody><tr><td>+&#x3D;</td><td>加法赋值</td></tr><tr><td>-+</td><td>减法赋值</td></tr><tr><td>*&#x3D;</td><td>乘法赋值</td></tr><tr><td>&#x2F;&#x3D;</td><td>除法赋值</td></tr><tr><td>%&#x3D;</td><td>取余赋值</td></tr></tbody></table><h2 id="3-自增-x2F-自减运算符"><a href="#3-自增-x2F-自减运算符" class="headerlink" title="3 自增&#x2F;自减运算符"></a>3 自增&#x2F;自减运算符</h2><table><thead><tr><th>符号</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>++</td><td>自增</td><td>变量自身的值加1，例如: x++</td></tr><tr><td>–</td><td>自减</td><td>变量自身的值减1，例如: x–</td></tr></tbody></table><ol><li>++在前和++在后在单独使用时二者并没有差别，而且一般开发中我们都是独立使用</li><li>++在后（后缀式）我们会使用更多</li></ol><blockquote><p>注意：</p><ol><li>只有变量能够使用自增和自减运算符</li><li>++、– 可以在变量前面也可以在变量后面，比如: x++  或者  ++x</li></ol></blockquote><h2 id="4-比较运算符"><a href="#4-比较运算符" class="headerlink" title="4 比较运算符"></a>4 比较运算符</h2><p>使用场景：比较两个数据大小、是否相等，根据比较结果返回一个布尔值（true &#x2F; false）</p><table><thead><tr><th>运算符</th><th>作用</th></tr></thead><tbody><tr><td>&gt;</td><td>左边是否大于右边</td></tr><tr><td>&lt;</td><td>左边是否小于右边</td></tr><tr><td>&gt;&#x3D;</td><td>左边是否大于或等于右边</td></tr><tr><td>&lt;&#x3D;</td><td>左边是否小于或等于右边</td></tr><tr><td>&#x3D;&#x3D;&#x3D;</td><td>左右两边是否<code>类型</code>和<code>值</code>都相等（重点）</td></tr><tr><td>&#x3D;&#x3D;</td><td>左右两边<code>值</code>是否相等</td></tr><tr><td>!&#x3D;</td><td>左右值不相等</td></tr><tr><td>!&#x3D;&#x3D;</td><td>左右两边是否不全等</td></tr></tbody></table><h2 id="5-逻辑运算符"><a href="#5-逻辑运算符" class="headerlink" title="5 逻辑运算符"></a>5 逻辑运算符</h2><p>使用场景：可以把多个布尔值放到一起运算，最终返回一个布尔值</p><table><thead><tr><th>符号</th><th>名称</th><th>日常读法</th><th>特点</th><th>口诀</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>逻辑与</td><td>并且</td><td>符号两边有一个假的结果为假</td><td>一假则假</td></tr><tr><td>||</td><td>逻辑或</td><td>或者</td><td>符号两边有一个真的结果为真</td><td>一真则真</td></tr><tr><td>!</td><td>逻辑非</td><td>取反</td><td>true变false  false变true</td><td>真变假，假变真</td></tr></tbody></table><blockquote><p>逻辑运算符优先级： ！&gt; &amp;&amp; &gt;  ||  </p></blockquote><h2 id="6-展开运算符"><a href="#6-展开运算符" class="headerlink" title="6 展开运算符"></a>6 展开运算符</h2><p><code> ...</code>：将一个数组进行展开，不会修改原数组</p><p><strong>典型运用场景： 求数组最大值(最小值)、合并数组等</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1,2,3,4,5]</span><br><span class="line">console.log(...arr)</span><br></pre></td></tr></table></figure><h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><h2 id="1-表达式和语句"><a href="#1-表达式和语句" class="headerlink" title="1 表达式和语句"></a>1 表达式和语句</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230329110922.png"></p><h2 id="2-分支语句"><a href="#2-分支语句" class="headerlink" title="2 分支语句"></a>2 分支语句</h2><p>分支语句可以根据条件判定真假，来选择性的执行想要的代码</p><p>分支语句包含：</p><h3 id="2-1-if-分支语句"><a href="#2-1-if-分支语句" class="headerlink" title="2.1 if 分支语句"></a>2.1 if 分支语句</h3><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式) &#123;</span><br><span class="line">  <span class="comment">// 满足条件要执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小括号内的条件结果是布尔值，为 true 时，进入大括号里执行代码；为false，则不执行大括号里面代码</p><p>小括号内的结果若不是布尔类型时，会发生类型转换为布尔值，类似Boolean()</p><p>如果有两个条件的时候，可以使用 if else 双分支语句：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件表达式)&#123;</span><br><span class="line">  <span class="comment">// 满足条件要执行的语句</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 不满足条件要执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="if-多分支语句"><a href="#if-多分支语句" class="headerlink" title="if 多分支语句"></a>if 多分支语句</h4><p>使用场景： 适合于有多个条件的时候（多个 else if ）</p><h3 id="2-2-三元运算符（三元表达式）"><a href="#2-2-三元运算符（三元表达式）" class="headerlink" title="2.2 三元运算符（三元表达式）"></a>2.2 三元运算符（三元表达式）</h3><p><strong>使用场景</strong>： 一些简单的双分支，可以使用  三元运算符（三元表达式），写起来比 if  else双分支 更简单</p><p><strong>符号</strong>：? 与 : 配合使用</p><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">条件 ? 表达式<span class="number">1</span> ： 表达式<span class="number">2</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 三元运算符（三元表达式）</span><br><span class="line">// 1. 语法格式</span><br><span class="line">// 条件 ? 表达式1 : 表达式2 </span><br><span class="line">// 2. 执行过程 </span><br><span class="line">// 2.1 如果条件为真，则执行表达式1</span><br><span class="line">// 2.2 如果条件为假，则执行表达式2</span><br></pre></td></tr></table></figure><h3 id="2-3-switch语句"><a href="#2-3-switch语句" class="headerlink" title="2.3 switch语句"></a>2.3 switch语句</h3><p>使用场景： 适合于有多个条件的时候，也属于分支语句，大部分情况下和 if多分支语句 功能相同</p><p>注意：</p><ol><li>switch case语句一般用于等值判断, if适合于区间判断</li><li>switchcase一般需要配合break关键字使用 没有break会造成case穿透</li><li>if 多分支语句开发要比switch更重要，使用也更多</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  switch (2) &#123;</span><br><span class="line">    case 1:</span><br><span class="line">    console.log(&#x27;您选择的是1&#x27;)</span><br><span class="line">    break  // 退出switch</span><br><span class="line">    case 2:</span><br><span class="line">    console.log(&#x27;您选择的是2&#x27;)</span><br><span class="line">    break  // 退出switch</span><br><span class="line">    case 3:</span><br><span class="line">    console.log(&#x27;您选择的是3&#x27;)</span><br><span class="line">    break  // 退出switch</span><br><span class="line">    default:</span><br><span class="line">    console.log(&#x27;没有符合条件的&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>if 多分支语句和 switch的区别：</strong></p><ol><li><p>共同点</p><ul><li>都能实现多分支选择， 多选1 </li><li>大部分情况下可以互换</li></ul></li><li><p>区别：</p><ul><li>switch…case语句通常处理case为比较<strong>确定值</strong>的情况，而if…else…语句更加灵活，通常用于<strong>范围判断</strong>(大于，等于某个范围)。</li><li>switch 语句进行判断后直接执行到程序的语句，效率更高，而if…else语句有几种判断条件，就得判断多少次</li><li>switch 一定要注意 必须是 &#x3D;&#x3D;&#x3D;  全等，一定注意 数据类型，同时注意break否则会有穿透效果</li><li>结论：<ul><li>当分支比较少时，if…else语句执行效率高。</li><li>当分支比较多时，switch语句执行效率高，而且结构更清晰。</li></ul></li></ul></li></ol><h2 id="3-循环语句"><a href="#3-循环语句" class="headerlink" title="3 循环语句"></a>3 循环语句</h2><p>使用场景：重复执行 指定的一段代码</p><h3 id="3-1-while循环"><a href="#3-1-while循环" class="headerlink" title="3.1 while循环"></a>3.1 while循环</h3><p>while :  在…. 期间， 所以 while循环 就是在满足条件期间，重复执行某些代码。</p><p><strong>语法：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (条件表达式) &#123;</span><br><span class="line">   <span class="comment">// 循环体    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环三要素：</p><ol><li><p>初始值 （经常用变量）</p></li><li><p>终止条件</p></li><li><p>变量的变化量</p></li></ol><h4 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h4><p>1.while(true) 来构造“无限”循环，需要使用break退出循环。（常用）</p><p>2.for(;;) 也可以来构造“无限”循环，同样需要使用break退出循环。</p><h3 id="3-2-for-循环"><a href="#3-2-for-循环" class="headerlink" title="3.2 for 循环"></a>3.2 for 循环</h3><p><strong>语法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  // 1. 语法格式</span><br><span class="line">  // for(起始值; 终止条件; 变化量) &#123;</span><br><span class="line">  //   // 要重复执行的代码</span><br><span class="line">  // &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>循环三要素：</p><ol><li><p>初始值 （经常用变量）</p></li><li><p>终止条件</p></li><li><p>变量的变化量</p></li></ol><p>变化量和死循环，<code>for</code> 循环和 <code>while</code> 一样，如果不合理设置增量和终止条件，便会产生死循环</p><p>跳出和终止循环</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 1. continue </span><br><span class="line">    for (let i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">        if (i === 3) &#123;</span><br><span class="line">            continue  // 结束本次循环，继续下一次循环</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(i)</span><br><span class="line">    &#125;</span><br><span class="line">    // 2. break</span><br><span class="line">    for (let i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">        if (i === 3) &#123;</span><br><span class="line">            break  // 退出结束整个循环</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(i)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>结论：</p><ul><li><code>JavaScript</code> 提供了多种语句来实现循环控制，但无论使用哪种语句都离不开循环的3个特征，即起始值、变化量、终止条件，做为初学者应着重体会这3个特征，不必过多纠结三种语句的区别。</li><li>起始值、变化量、终止条件，由开发者根据逻辑需要进行设计，规避死循环的发生。</li><li>当如果明确了循环的次数的时候推荐使用<code>for</code>循环,当不明确循环的次数的时候推荐使用<code>while</code>循环</li><li><code>for</code> 的语法结构更简洁，故 <code>for</code> 循环的使用频次会更多</li></ul><h3 id="3-3-中止循环"><a href="#3-3-中止循环" class="headerlink" title="3.3 中止循环"></a>3.3 中止循环</h3><p><code>break</code>   中止整个循环，一般用于结果已经得到, 后续的循环不需要的时候可以使用（提高效率）  </p><p><code>continue</code>  中止本次循环，一般用于排除或者跳过某一个选项的时候</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 1. continue </span><br><span class="line">    for (let i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">        if (i === 3) &#123;</span><br><span class="line">            continue  // 结束本次循环，继续下一次循环</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(i)</span><br><span class="line">    &#125;</span><br><span class="line">    // 2. break</span><br><span class="line">    for (let i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">        if (i === 3) &#123;</span><br><span class="line">            break  // 退出结束整个循环</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(i)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="3-4-循环嵌套"><a href="#3-4-循环嵌套" class="headerlink" title="3.4 循环嵌套"></a>3.4 循环嵌套</h3><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230329114311.png"></p><p>记住，外层循环循环一次，里层循环循环全部</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p><strong>数组：</strong>(Array)是一种可以按顺序保存数据的数据类型</p><p><strong>使用场景：</strong>如果有多个数据可以用数组保存起来，然后放到一个变量中，管理非常方便</p><blockquote><p>数组在 JavaScript 中并不是新的数据类型，它属于对象类型。</p></blockquote><h2 id="1-数组使用"><a href="#1-数组使用" class="headerlink" title="1 数组使用"></a>1 数组使用</h2><p><strong>定义数组</strong>：数组用 [ ] 定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  // 1. 语法，使用 [] 来定义一个空数组</span><br><span class="line">  // 定义一个空数组，然后赋值给变量 classes</span><br><span class="line">  // let classes = [];</span><br><span class="line"></span><br><span class="line">  // 2. 定义非空数组</span><br><span class="line">  let classes = [&#x27;小明&#x27;, &#x27;小刚&#x27;, &#x27;小红&#x27;, &#x27;小丽&#x27;, &#x27;小米&#x27;]</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>通过 <code>[]</code> 定义数组，数据中可以存放真正的数据，如小明、小刚、小红等这些都是数组中的数据，我们这些数据称为数组单元，数组单元之间使用英文逗号分隔。</p><p><strong>访问数组和数组索引</strong>：数组通过下表寻找</p><p>JavaScript 为数组中的每一个数据单元都编了号，通过数据单元在数组中的编号便可以轻松访问到数组中的数据单元了，我们将<strong>数据单元在数组中的编号</strong>称为<strong>索引值</strong>，或称其为<strong>下标</strong>。下标由0开始计算</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230329122437.png"></p><p><strong>数据单元值类型</strong>：数组做为数据的集合，它的单元值可以是任意数据类型</p><h4 id="数组长度属性"><a href="#数组长度属性" class="headerlink" title="数组长度属性"></a>数组长度属性</h4><p>数组长度可以调用 <strong>length</strong> 函数直接查询</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 定义一个数组</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> arr = [<span class="string">&#x27;html&#x27;</span>, <span class="string">&#x27;css&#x27;</span>, <span class="string">&#x27;javascript&#x27;</span>]</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 数组对应着一个 length 属性，它的含义是获取数组的长度</span></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="property">length</span>) <span class="comment">// 3</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-操作数组"><a href="#2-操作数组" class="headerlink" title="2 操作数组"></a>2 操作数组</h2><p>数组做为对象数据类型，不但有 <code>length</code> 属性可以使用，还提供了许多方法：</p><ol><li>push 动态向数组的尾部添加一个单元</li><li>unshit 动态向数组头部添加一个单元</li><li>pop 删除最后一个单元</li><li>shift 删除第一个单元</li><li>splice 动态删除任意单元</li></ol><p>使用以上4个方法时，都是直接在原数组上进行操作，即成功调任何一个方法，原数组都跟着发生相应的改变。并且在添加或删除单元时 <code>length</code> 并不会发生错乱</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  // 定义一个数组</span><br><span class="line">  let arr = [&#x27;html&#x27;, &#x27;css&#x27;, &#x27;javascript&#x27;]</span><br><span class="line"></span><br><span class="line">  // 1. push 动态向数组的尾部添加一个单元</span><br><span class="line">  arr.push(&#x27;Nodejs&#x27;)</span><br><span class="line">  console.log(arr)</span><br><span class="line">  arr.push(&#x27;Vue&#x27;)</span><br><span class="line"></span><br><span class="line">  // 2. unshit 动态向数组头部添加一个单元</span><br><span class="line">  arr.unshift(&#x27;VS Code&#x27;)</span><br><span class="line">  console.log(arr)</span><br><span class="line"></span><br><span class="line">  // 3. splice 动态删除任意单元</span><br><span class="line">  arr.splice(2, 1) // 从索引值为2的位置开始删除1个单元</span><br><span class="line">  console.log(arr)</span><br><span class="line"></span><br><span class="line">  // 4. pop 删除最后一个单元</span><br><span class="line">  arr.pop()</span><br><span class="line">  console.log(arr)</span><br><span class="line"></span><br><span class="line">  // 5. shift 删除第一个单元</span><br><span class="line">  arr.shift()</span><br><span class="line">  console.log(arr)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="3-伪数组"><a href="#3-伪数组" class="headerlink" title="3 伪数组"></a>3 伪数组</h2><p>有长度有索引号的数组，但是没有 pop() push() 等数组方法，</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="1-声明和调用"><a href="#1-声明和调用" class="headerlink" title="1 声明和调用"></a>1 声明和调用</h2><p>声明（定义）一个完整函数包括关键字、函数名、形式参数、函数体、返回值5个部分</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230329125141.png"></p><p>调用：声明（定义）的函数必须调用才会真正被执行，使用 <code>()</code> 调用函数</p><blockquote><p>注：函数名的命名规则与变量是一致的，并且尽量保证函数名的语义。</p></blockquote><h2 id="2-参数"><a href="#2-参数" class="headerlink" title="2 参数"></a>2 参数</h2><p>通过向函数传递参数，可以让函数更加灵活多变，参数可以理解成是一个变量。</p><p>声明（定义）一个功能为打招呼的函数</p><ul><li>传入数据列表</li><li>声明这个函数需要传入几个数据</li><li>多个数据用逗号隔开</li></ul><p><strong>形参</strong>：声明函数时写在函数名右边小括号里的叫形参（形式上的参数）</p><p><strong>实参</strong>：调用函数时写在函数名右边小括号里的叫实参（实际上的参数）</p><p>形参可以理解为是在这个函数内声明的变量（比如 num1 &#x3D; 10）实参可以理解为是给这个变量赋值</p><p>开发中尽量保持形参和实参个数一致</p><h2 id="3-返回值"><a href="#3-返回值" class="headerlink" title="3 返回值"></a>3 返回值</h2><p>函数的本质是封装（包裹），函数体内的逻辑执行完毕后，需要通过 <code>return</code> 这个关键字，将内部执行结果传递到函数外部，这个被传递到外部的结果就是返回值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  // 定义求和函数</span><br><span class="line">  function count(a, b) &#123;</span><br><span class="line">    let s = a + b</span><br><span class="line">    // s 即为 a + b 的结果</span><br><span class="line">    // 通过 return 将 s 传递到外部</span><br><span class="line">    return s</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 调用函数，如果一个函数有返回值</span><br><span class="line">  // 那么可将这个返回值赋值给外部的任意变量</span><br><span class="line">  let total = count(5, 12)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>在函数体中使用return 关键字能将内部的执行结果交给函数外部使用</li><li>函数内部只能出现1 次 return，并且 return 下一行代码不会再被执行，所以return 后面的数据不要换行写</li><li>return会立即结束当前函数</li><li>函数可以没有return，这种情况默认返回值为 undefined</li></ol><h2 id="4-作用域"><a href="#4-作用域" class="headerlink" title="4 作用域"></a>4 作用域</h2><p>通常来说，一段程序代码中所用到的名字并不总是有效和可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。</p><p>作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突。</p><p><strong>全局作用域</strong></p><p>作用于所有代码执行的环境(整个 script 标签内部)或者一个独立的 js 文件</p><p>处于全局作用域内的变量，称为全局变量</p><p><strong>局部作用域</strong></p><p>作用于函数内的代码环境，就是局部作用域。 因为跟函数有关系，所以也称为函数作用域。</p><p>处于局部作用域内的变量称为局部变量</p><blockquote><p>如果函数内部，变量没有声明，直接赋值，也当全局变量看，但是强烈不推荐</p><p>但是有一种情况，函数内部的形参可以看做是局部变量。</p></blockquote><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="1-声明"><a href="#1-声明" class="headerlink" title="1 声明"></a>1 声明</h2><p>对象： JavaScript 数据类型的一种，对象数据类型可以被理解成是一种数据集合。它由属性和方法两部分构成</p><p>声明一个对象类型的变量与之前声明一个数值或字符串类型的变量没有本质上的区别，使用 { } 声明</p><p><strong>null</strong>：也是 JavaScript 中数据类型的一种，通常只用它来表示不存在的对象。使用 typeof 检测类型它的类型时，结果为 <code>object</code></p><h2 id="2-属性"><a href="#2-属性" class="headerlink" title="2 属性"></a>2 属性</h2><p>数据描述性的信息称为属性，如人的姓名、身高、年龄、性别等，一般是名词性的。</p><ol><li>属性都是成 对出现的，包括属性名和值，它们之间使用英文 <code>:</code> 分隔</li><li>多个属性之间使用英文 <code>,</code> 分隔</li><li>属性就是依附在对象上的变量</li><li>属性名可以使用 <code>&quot;&quot;</code> 或 <code>&#39;&#39;</code>，一般情况下省略，除非名称遇到特殊符号如空格、中横线等</li></ol><p><strong>属性访问</strong>：声明对象，并添加了若干属性后，可以使用 <code>.</code> 或 <code>[]</code> 获得对象中属性对应的值，称之为属性访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  // 通过对象描述一个人的数据信息</span><br><span class="line">  // person 是一个对象，它包含了一个属性 name</span><br><span class="line">  // 属性都是成对出现的，属性名 和 值，它们之间使用英文 : 分隔</span><br><span class="line">  let person = &#123;</span><br><span class="line">    name: &#x27;小明&#x27;, // 描述人的姓名</span><br><span class="line">    age: 18, // 描述人的年龄</span><br><span class="line">    stature: 185, // 描述人的身高</span><br><span class="line">    gender: &#x27;男&#x27;, // 描述人的性别</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  // 访问人的名字</span><br><span class="line">  console.log(person.name) // 结果为 小明</span><br><span class="line">  // 访问人性别</span><br><span class="line">  console.log(person.gender) // 结果为 男</span><br><span class="line">  // 访问人的身高</span><br><span class="line">  console.log(person[&#x27;stature&#x27;]) // 结果为 185</span><br><span class="line"> // 或者</span><br><span class="line">  console.log(person.stature) // 结果同为 185</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>扩展</strong>：也可以动态为对象添加属性，动态添加与直接定义是一样的，只是语法上更灵活</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> &lt;script&gt;</span><br><span class="line">   // 声明一个空的对象（没有任何属性）</span><br><span class="line">let user = &#123;&#125;</span><br><span class="line">   // 动态追加属性</span><br><span class="line">   user.name = &#x27;小明&#x27;</span><br><span class="line">   user[&#x27;age&#x27;] = 18</span><br><span class="line">   // 动态添加与直接定义是一样的，只是语法上更灵活</span><br><span class="line"> &lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="3-方法"><a href="#3-方法" class="headerlink" title="3 方法"></a>3 方法</h2><p>数据行为性的信息称为方法，如跑步、唱歌等，一般是动词性的，其本质是函数。</p><ol><li>方法是由方法名和函数两部分构成，它们之间使用 : 分隔</li><li>多个属性之间使用英文 <code>,</code> 分隔</li><li>方法是依附在对象中的函数</li><li>方法名可以使用 <code>&quot;&quot;</code> 或 <code>&#39;&#39;</code>，一般情况下省略，除非名称遇到特殊符号如空格、中横线等</li></ol><p><strong>方法调用</strong>：声明对象，并添加了若干方法后，可以使用 <code>.</code> 或 <code>[]</code> 调用对象中函数，称之为方法调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  // 方法是依附在对象上的函数</span><br><span class="line">  let person = &#123;</span><br><span class="line">    name: &#x27;小红&#x27;,</span><br><span class="line">    age: 18,</span><br><span class="line">    // 方法是由方法名和函数两部分构成，它们之间使用 : 分隔</span><br><span class="line">    singing: function () &#123;</span><br><span class="line">      console.log(&#x27;两只老虎，两只老虎，跑的快，跑的快...&#x27;)</span><br><span class="line">    &#125;,</span><br><span class="line">    run: function () &#123;</span><br><span class="line">      console.log(&#x27;我只要急支糖浆&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 调用对象中 singing 方法</span><br><span class="line">  person.singing()</span><br><span class="line">  // 调用对象中的 run 方法</span><br><span class="line">  person.run()</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>扩展</strong>：也可以动态为对象添加方法，动态添加与直接定义是一样的，只是语法上更灵活</p><blockquote><p>注：无论是属性或是方法，同一个对象中出现名称一样的，后面的会覆盖前面的</p></blockquote><h2 id="4-内置对象"><a href="#4-内置对象" class="headerlink" title="4 内置对象"></a>4 内置对象</h2><p><code>console</code>其实就是 JavaScript 中内置的对象，该对象中存在一个方法叫 <code>log</code>，然后调用 <code>log</code> 这个方法，即 <code>console.log()</code>。</p><p>除了 <code>console</code> 对象外，JavaScritp 还有其它的内置的对象</p><h2 id="日期对象"><a href="#日期对象" class="headerlink" title="日期对象"></a>日期对象</h2><p>掌握 Date 日期对象的使用，动态获取当前计算机的时间。</p><p>ECMAScript 中内置了获取系统时间的对象 Date，使用 Date 时与之前学习的内置对象 console 和 Math 不同，它需要借助 new 关键字才能使用。</p><h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 实例化</span></span><br><span class="line"><span class="comment">// const date = new Date(); // 系统默认时间</span></span><br><span class="line"><span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2020-05-01&#x27;</span>) <span class="comment">// 指定时间</span></span><br><span class="line"><span class="comment">// date 变量即所谓的时间对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> date)</span><br></pre></td></tr></table></figure><h3 id="日期对象方法"><a href="#日期对象方法" class="headerlink" title="日期对象方法"></a>日期对象方法</h3> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 1. 实例化</span></span><br><span class="line"><span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="comment">// 2. 调用时间对象方法</span></span><br><span class="line"><span class="comment">// 通过方法分别获取年、月、日，时、分、秒</span></span><br><span class="line"><span class="keyword">const</span> year = date.<span class="title function_">getFullYear</span>(); <span class="comment">// 四位年份</span></span><br><span class="line"><span class="keyword">const</span> month = date.<span class="title function_">getMonth</span>(); <span class="comment">// 0 ~ 11</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>方法</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>getFullYear()</td><td>获得年份</td><td>获取四位年份</td></tr><tr><td>getMonth()</td><td>获得月份</td><td>取值为 0 ~ 11</td></tr><tr><td>getDate()</td><td>获取月份中的每一天</td><td>不同月份取值也不相同</td></tr><tr><td>getDay()</td><td>获取星期</td><td>取值为 0 ~ 6</td></tr><tr><td>getHours()</td><td>获取小时</td><td>取值为 0 ~ 23</td></tr><tr><td>getMinutes()</td><td>获取分钟</td><td>取值为 0 ~ 59</td></tr><tr><td>getSeconds()</td><td>获取秒</td><td>取值为 0 ~ 59</td></tr></tbody></table><h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><p>时间戳是指1970年01月01日00时00分00秒起至现在的总秒数或毫秒数，它是一种特殊的计量时间的方式。</p><p><strong>使用场景：</strong> 如果计算倒计时效果，前面方法无法直接计算，需要借助于时间戳完成</p><p><strong>算法：</strong></p><ul><li>将来的时间戳 - 现在的时间戳 &#x3D; 剩余时间毫秒数</li><li>剩余时间毫秒数 转换为 剩余时间的 年月日时分秒 就是 倒计时时间</li></ul><p>注：ECMAScript 中时间戳是以毫秒计的。</p><p><strong>获取时间戳</strong></p><ol><li><p>使用 getTime() 方法</p></li><li><p>简写方式 +new Date()</p></li><li><p>使用 Date.now()</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 1. 实例化</span></span><br><span class="line">  <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">  <span class="comment">// 2. 获取时间戳</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">getTime</span>())</span><br><span class="line"><span class="comment">// 还有一种获取时间戳的方法</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(+<span class="keyword">new</span> <span class="title class_">Date</span>())</span><br><span class="line">  <span class="comment">// 还有一种获取时间戳的方法</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>())</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>获取时间戳的方法，分别为 getTime 和 Date.now 和  +new Date()</p><h3 id="间歇函数"><a href="#间歇函数" class="headerlink" title="间歇函数"></a>间歇函数</h3><p><code>setInterval</code> 是 JavaScript 中内置的函数，它的作用是间隔固定的时间自动重复执行另一个函数，也叫定时器函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 1. 定义一个普通函数</span><br><span class="line">    function repeat() &#123;</span><br><span class="line">        console.log(&#x27;不知疲倦的执行下去....&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    // 2. 使用 setInterval 调用 repeat 函数</span><br><span class="line">    // 间隔 1000 毫秒，重复调用 repeat</span><br><span class="line">    setInterval(repeat, 1000)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>开启定时器</strong></p><p>作用：每隔一段时间调用这个函数，间隔时间单位是毫秒</p><p>返回值：定时器返回的是一个 <strong>id 数字</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 1. 定义一个普通函数</span><br><span class="line">function repeat() &#123;</span><br><span class="line">console.log(&#x27;不知疲倦的执行下去..&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">// 2. 使用 setInterval 调用 repeat 函数</span><br><span class="line">// 间隔 1000 毫秒，重复调用 repeat</span><br><span class="line">setInterval(repeat, 1000)</span><br></pre></td></tr></table></figure><blockquote><p>函数名字<strong>不需要加括号</strong></p></blockquote><p><strong>关闭定时器</strong></p><p>作用：关闭定时器，一般不会刚创建就停止，而是满足一定条件再停止</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// setInterval(函数名, 间隔时间) 函数名不要加小括号</span><br><span class="line">let n = setInterval(fn, 1000)&#123;</span><br><span class="line">一定条件</span><br><span class="line">&#125;</span><br><span class="line">// 关闭定时器</span><br><span class="line">clearInterval(n)</span><br></pre></td></tr></table></figure><h3 id="定时器-延迟函数"><a href="#定时器-延迟函数" class="headerlink" title="定时器-延迟函数"></a>定时器-延迟函数</h3><p>JavaScript 内置的一个用来让代码延迟执行的函数，叫 setTimeout</p><p><strong>语法：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(回调函数, 延迟时间)</span><br></pre></td></tr></table></figure><p>setTimeout 仅仅只执行一次，所以可以理解为就是把一段代码延迟执行, 平时省略window</p><p>间歇函数 setInterval : 每隔一段时间就执行一次， , 平时省略window</p><p>清除延时函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">clearTimeout</span>(timerId)</span><br></pre></td></tr></table></figure><blockquote><p>注意点</p><ol><li>延时函数需要等待,所以后面的代码先执行</li><li>返回值是一个正整数，表示定时器的编号</li></ol></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 定时器之延迟函数</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 1. 开启延迟函数</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> timerId = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我只执行一次&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;, <span class="number">3000</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 1.1 延迟函数返回的还是一个正整数数字，表示延迟函数的编号</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(timerId)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 1.2 延迟函数需要等待时间，所以下面的代码优先执行</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 2. 关闭延迟函数</span></span></span><br><span class="line"><span class="language-javascript">    <span class="built_in">clearTimeout</span>(timerId)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 浮动、定位</title>
      <link href="/2023/03/23/CSS.4/"/>
      <url>/2023/03/23/CSS.4/</url>
      
        <content type="html"><![CDATA[<h1 id="一、float-浮动"><a href="#一、float-浮动" class="headerlink" title="一、float 浮动"></a>一、float 浮动</h1><h2 id="1-传统网页布局的三种方式"><a href="#1-传统网页布局的三种方式" class="headerlink" title="1. 传统网页布局的三种方式"></a>1. 传统网页布局的三种方式</h2><p>CSS 提供了三种传统布局方式(简单说,就是盒子如何进行排列顺序)：</p><ul><li><p>普通流（标准流）</p></li><li><p>浮动</p></li><li><p>定位</p></li></ul><p>这三种布局方式都是用来摆放盒子的，盒子摆放到合适位置，布局自然就完成了。</p><p>注意：实际开发中，一个页面基本都包含了这三种布局方式</p><h2 id="2-为什么需要浮动"><a href="#2-为什么需要浮动" class="headerlink" title="2. 为什么需要浮动"></a>2. 为什么需要浮动</h2><p>有很多的布局效果，标准流没有办法完成，此时就可以利用浮动完成布局。 因为浮动可以改变元素标签默认的排列方式.</p><p>浮动最典型的应用：可以让多个块级元素一行内排列显示</p><p>网页布局第一准则：<strong>多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动</strong></p><h2 id="3-什么是浮动"><a href="#3-什么是浮动" class="headerlink" title="3. 什么是浮动"></a>3. 什么是浮动</h2><p>float 属性用于创建浮动框，将其移动到一边，直到左边缘或右边缘触及包含块或另一个浮动框的边缘</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择器 &#123; float: 属性值; &#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230323211914.png"></p><h2 id="4-浮动特性"><a href="#4-浮动特性" class="headerlink" title="4. 浮动特性"></a>4. 浮动特性</h2><ol><li>浮动元素会脱离标准流(脱标：浮动的盒子不再保留原先的位置)</li></ol><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230323212004.png"></p><ol start="2"><li>浮动的元素会一行内显示并且元素顶部对齐</li></ol><p>注意： </p><blockquote><p>浮动的元素是互相贴靠在一起的（不会有缝隙），如果父级宽度装不下这些浮动的盒子，多出的盒子会另起一行对齐</p></blockquote><ol start="3"><li>浮动的元素会具有行内块元素的特性</li></ol><ul><li>浮动元素的大小根据内容来决定</li><li>浮动的盒子中间是没有缝隙的</li></ul><h2 id="5-浮动元素经常和标准流父级搭配使用"><a href="#5-浮动元素经常和标准流父级搭配使用" class="headerlink" title="5. 浮动元素经常和标准流父级搭配使用"></a>5. 浮动元素经常和标准流父级搭配使用</h2><p>为了约束浮动元素位置, 我们网页布局一般采取的策略是:</p><p>先用标准流父元素排列上下位置, 之后内部子元素采取浮动排列左右位置.  符合网页布局第一准侧</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230323212215.png"></p><h2 id="6-浮动布局注意点"><a href="#6-浮动布局注意点" class="headerlink" title="6. 浮动布局注意点"></a>6. 浮动布局注意点</h2><ul><li>浮动和标准流的父盒子搭配，先用标准流的父元素排列上下位置, 之后内部子元素采取浮动排列左右位置</li><li>一个元素浮动了，理论上其余的兄弟元素也要浮动，一个盒子里面有多个子盒子，如果其中一个盒子浮动了，其他兄弟也应该浮动，以防止引起问题。</li><li>浮动的盒子只会影响浮动盒子后面的标准流,不会影响前面的标准流</li></ul><h1 id="二、清除浮动"><a href="#二、清除浮动" class="headerlink" title="二、清除浮动"></a>二、清除浮动</h1><h2 id="1-为什么需要清除浮动"><a href="#1-为什么需要清除浮动" class="headerlink" title="1. 为什么需要清除浮动"></a>1. 为什么需要清除浮动</h2><p>由于父级盒子很多情况下，不方便给高度，但是子盒子浮动又不占有位置，最后父级盒子高度为 0 时，就会影响下面的标准流盒子</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230323212445.png"></p><h2 id="2-清除浮动本质"><a href="#2-清除浮动本质" class="headerlink" title="2. 清除浮动本质"></a>2. 清除浮动本质</h2><p>清除浮动的本质是<strong>清除浮动元素脱离标准流</strong>造成的影响：浮动的子标签无法撑开父盒子的高度</p><p>注意：</p><ul><li>如果父盒子本身有高度，则不需要清除浮动</li><li>清除浮动之后，父级就会根据浮动的子盒子自动检测高度。</li><li>父级有了高度，就不会影响下面的标准流了</li></ul><h2 id="3-清除浮动样式"><a href="#3-清除浮动样式" class="headerlink" title="3. 清除浮动样式"></a>3. 清除浮动样式</h2><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择器&#123;<span class="attribute">clear</span>:属性值;&#125; </span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230323213202.png"></p><p>清除浮动的策略是:  闭合浮动</p><h2 id="4-清除浮动的多种方式"><a href="#4-清除浮动的多种方式" class="headerlink" title="4. 清除浮动的多种方式"></a>4. 清除浮动的多种方式</h2><h3 id="额外标签法"><a href="#额外标签法" class="headerlink" title="额外标签法"></a>额外标签法</h3><p>额外标签法也称为隔墙法，是 W3C 推荐的做法。</p><p>使用方式：额外标签法会在浮动元素末尾添加一个空的标签</p><p>例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>优点： 通俗易懂，书写方便</p><p>缺点： 添加许多无意义的标签，结构化较差</p><blockquote><p>注意： 要求这个新的空标签必须是块级元素</p></blockquote><h3 id="父级添加-overflow-属性"><a href="#父级添加-overflow-属性" class="headerlink" title="父级添加 overflow 属性"></a>父级添加 overflow 属性</h3><p>可以给父级添加 overflow 属性，将其属性值设置为 hidden、 auto 或 scroll</p><p>例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">overflow</span>:hidden | auto | scroll;</span><br></pre></td></tr></table></figure><p>优点：代码简洁</p><p>缺点：无法显示溢出的部分</p><p>注意：是给父元素添加代码</p><h3 id="父级添加after伪元素"><a href="#父级添加after伪元素" class="headerlink" title="父级添加after伪元素"></a>父级添加after伪元素</h3><p>:after 方式是额外标签法的升级版，给父元素添加：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;  </span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>; </span><br><span class="line">  <span class="attribute">display</span>: block; </span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>; </span><br><span class="line">  <span class="attribute">clear</span>: both; </span><br><span class="line">  <span class="attribute">visibility</span>: hidden;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;  <span class="comment">/* IE6、7 专有 */</span> </span><br><span class="line">  *zoom: <span class="number">1</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>优点：没有增加标签，结构更简单</p><p>缺点：照顾低版本浏览器</p><p>代表网站： 百度、淘宝网、网易等</p><h3 id="父级添加双伪元素"><a href="#父级添加双伪元素" class="headerlink" title="父级添加双伪元素"></a>父级添加双伪元素</h3><p>给父元素添加</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:before</span>,<span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>:<span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">display</span>:table; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">   *zoom:<span class="number">1</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>优点：代码更简洁</p><p>缺点：照顾低版本浏览器</p><p>代表网站：小米、腾讯等</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>为什么需要清除浮动？</p><ol><li>父级没高度</li><li>子盒子浮动了</li><li><strong>影响下面布局了，我们就应该清除浮动了</strong></li></ol><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230323214213.png"></p><h1 id="三、position-定位"><a href="#三、position-定位" class="headerlink" title="三、position 定位"></a>三、position 定位</h1><h2 id="1-定位组成"><a href="#1-定位组成" class="headerlink" title="1. 定位组成"></a>1. 定位组成</h2><p><strong>定位</strong>：将盒子<strong>定</strong>在某一个位置，所以<strong>定位也是在摆放盒子， 按照定位的方式移动盒子</strong></p><p>定位也是用来布局的，它有两部分组成：<strong>定位 &#x3D; 定位模式 + 边偏移</strong>  </p><ul><li><p><strong>定位模式</strong> 用于指定一个元素在文档中的定位方式</p></li><li><p><strong>边偏移</strong>则决定了该元素的最终位置</p></li></ul><h3 id="1-1-定位模式-position"><a href="#1-1-定位模式-position" class="headerlink" title="1.1 定位模式 (position)"></a>1.1 定位模式 (position)</h3><p>在 CSS 中，通过 <code>position</code> 属性定义元素的<strong>定位模式</strong>，语法如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">选择器 &#123; </span><br><span class="line">    <span class="attribute">position</span>: 属性值; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定位模式是有不同分类的，在不同情况下，我们用到不同的定位模式。</p><p>定位模式决定元素的定位方式 ，它通过 CSS 的 position 属性来设置，其值可以分为四个：</p><table><thead><tr><th>值</th><th align="center">语义</th></tr></thead><tbody><tr><td><code>static</code></td><td align="center"><strong>静态</strong>定位</td></tr><tr><td><code>relative</code></td><td align="center"><strong>相对</strong>定位</td></tr><tr><td><code>absolute</code></td><td align="center"><strong>绝对</strong>定位</td></tr><tr><td><code>fixed</code></td><td align="center"><strong>固定</strong>定位</td></tr></tbody></table><h4 id="1-1-1-静态定位-static-了解"><a href="#1-1-1-静态定位-static-了解" class="headerlink" title="1.1.1.  静态定位(static) - 了解"></a>1.1.1.  静态定位(static) - 了解</h4><ul><li><p><strong>静态定位</strong>是元素的<strong>默认</strong>定位方式，<strong>无定位的意思</strong>。它相当于 border 里面的none，静态定位static，不要定位的时候用。</p></li><li><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">选择器 &#123; </span><br><span class="line">    position: static; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>静态定位 按照标准流特性摆放位置，它没有边偏移。</p></li><li><p>静态定位在布局时我们几乎不用的</p></li></ul><h4 id="1-1-2-相对定位-relative-重要"><a href="#1-1-2-相对定位-relative-重要" class="headerlink" title="1.1.2. 相对定位(relative) - 重要"></a>1.1.2. 相对定位(relative) - 重要</h4><ul><li><strong>相对定位</strong>是元素在移动位置的时候，是相对于它自己<strong>原来的位置</strong>来说的（自恋型）。</li><li>语法：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">选择器 &#123; </span><br><span class="line">position: relative; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>相对定位的特点：（务必记住）</p><ul><li><p>它是相对于自己原来的位置来移动的（移动位置的时候参照点是自己原来的位置）。</p></li><li><p>在标准流的<strong>原来位置</strong>继续占有，后面的盒子仍然以标准流的方式对待它。</p><p>因此，<strong>相对定位并没有脱标</strong>。它最典型的应用是给绝对定位当爹的（子绝父相）</p></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230323221508.png"></p><h4 id="1-1-3-绝对定位-absolute-重要"><a href="#1-1-3-绝对定位-absolute-重要" class="headerlink" title="1.1.3. 绝对定位(absolute) - 重要"></a>1.1.3. 绝对定位(absolute) - 重要</h4><p><strong>绝对定位</strong>是元素在移动位置的时候，是相对于它<strong>祖先元素</strong>来说的</p><ul><li><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">选择器 &#123; </span><br><span class="line">position: absolute; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>注意：</p><ul><li><strong>完全脱标</strong> —— 完全不占位置</li><li><strong>父元素没有定位</strong>，则以<strong>浏览器</strong>为准定位（Document 文档）</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230323221929.png"></p><ul><li><strong>父元素要有定位</strong>，元素将依据最近的已经定位（绝对、固定或相对定位）的父元素（祖先）进行定位</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230323221939.png"></p><h4 id="1-1-4-固定定位-fixed-重要"><a href="#1-1-4-固定定位-fixed-重要" class="headerlink" title="1.1.4. 固定定位(fixed) - 重要"></a>1.1.4. 固定定位(fixed) - 重要</h4><p><strong>固定定位</strong>是元素<strong>固定于浏览器可视区的位置</strong>。</p><p>主要使用场景： 可以在浏览器页面滚动时元素的位置不会改变。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">选择器 &#123; </span><br><span class="line">position: fixed; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>固定定位的特点：</p><ul><li>以浏览器的可视窗口为参照点移动元素</li><li>跟父元素没有任何关系</li></ul><ul><li><p>不随滚动条滚动。</p></li><li><p>固定定位也是<strong>脱标</strong>的，其实<strong>固定定位也可以看做是一种特殊的绝对定位</strong></p><ul><li><strong>完全脱标</strong>—— 完全不占位置；</li><li>只认<strong>浏览器的可视窗口</strong> —— <code>浏览器可视窗口 + 边偏移属性</code> 来设置元素的位置；</li></ul></li></ul><h4 id="1-1-5-粘性定位-sticky-了解"><a href="#1-1-5-粘性定位-sticky-了解" class="headerlink" title="1.1.5 粘性定位(sticky) - 了解"></a>1.1.5 粘性定位(sticky) - 了解</h4><p><strong>粘性定位</strong>可以被认为是相对定位和固定定位的混合。 Sticky  粘性的 </p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">选择器 &#123; </span><br><span class="line">    position: sticky; </span><br><span class="line">    top: 10px; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>粘性定位的特点：</p><ul><li>以浏览器的可视窗口为参照点移动元素（固定定位特点）</li><li>粘性定位占有原先的位置（相对定位特点）</li><li>必须添加 top 、left、right、bottom <strong>其中一个</strong>才有效</li><li>跟页面滚动搭配使用。 兼容性较差，IE 不支持。</li></ul><h3 id="1-2-边偏移（方位名词）"><a href="#1-2-边偏移（方位名词）" class="headerlink" title="1.2 边偏移（方位名词）"></a>1.2 边偏移（方位名词）</h3><p><strong>边偏移</strong> 就是定位的盒子移动到最终位置。有 top、bottom、left 和 right  4 个属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">选择器 &#123; </span><br><span class="line">    边偏移: 具体值; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>边偏移属性</th><th align="left">示例</th><th>描述</th></tr></thead><tbody><tr><td><code>top</code></td><td align="left"><code>top: 80px</code></td><td><strong>顶端</strong>偏移量，定义元素相对于其父元素<strong>上边线的距离</strong>。</td></tr><tr><td><code>bottom</code></td><td align="left"><code>bottom: 80px</code></td><td><strong>底部</strong>偏移量，定义元素相对于其父元素<strong>下边线的距离</strong>。</td></tr><tr><td><code>left</code></td><td align="left"><code>left: 80px</code></td><td><strong>左侧</strong>偏移量，定义元素相对于其父元素<strong>左边线的距离</strong>。</td></tr><tr><td><code>right</code></td><td align="left"><code>right: 80px</code></td><td><strong>右侧</strong>偏移量，定义元素相对于其父元素<strong>右边线的距离</strong></td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230323220910.png"></p><h3 id="1-3-定位总结"><a href="#1-3-定位总结" class="headerlink" title="1.3 定位总结"></a>1.3 定位总结</h3><table><thead><tr><th><strong>定位模式</strong></th><th><strong>是否脱标</strong></th><th><strong>移动位置</strong></th><th><strong>是否常用</strong></th></tr></thead><tbody><tr><td>static   静态定位</td><td>否</td><td>不能使用边偏移</td><td>很少</td></tr><tr><td><strong>relative 相对定位</strong></td><td><strong>否 (占有位置)</strong></td><td><strong>相对于自身位置移动</strong></td><td><strong>基本单独使用</strong></td></tr><tr><td><strong>absolute绝对定位</strong></td><td><strong>是（不占有位置）</strong></td><td><strong>带有定位的父级</strong></td><td><strong>要和定位父级元素搭配使用</strong></td></tr><tr><td><strong>fixed 固定定位</strong></td><td><strong>是（不占有位置）</strong></td><td><strong>浏览器可视区</strong></td><td><strong>单独使用，不需要父级</strong></td></tr><tr><td>sticky 粘性定位</td><td>否   (占有位置)</td><td>浏览器可视区</td><td>当前阶段少</td></tr></tbody></table><ul><li><p>一定记住 相对定位、固定定位、绝对定位 两个大的特点： 1. 是否占有位置（脱标否） 2. 以谁为基准点移动位置。</p></li><li><p>学习定位重点学会子绝父相。</p></li><li><p>注意：</p></li></ul><ol><li><strong>边偏移</strong>需要和<strong>定位模式</strong>联合使用，<strong>单独使用无效</strong>；</li><li><code>top</code> 和 <code>bottom</code> 不要同时使用；</li><li><code>left</code> 和 <code>right</code> 不要同时使用。</li></ol><h2 id="2-定位-position-的应用"><a href="#2-定位-position-的应用" class="headerlink" title="2.  定位(position)的应用"></a>2.  定位(position)的应用</h2><h3 id="2-1-固定定位小技巧：-固定在版心左侧位置"><a href="#2-1-固定定位小技巧：-固定在版心左侧位置" class="headerlink" title="2.1 固定定位小技巧： 固定在版心左侧位置"></a>2.1 固定定位小技巧： 固定在版心左侧位置</h3><p>算法：</p><ol><li><p>让固定定位的盒子 left：50%.  走到浏览器可视区（也可以看做版心） 的一半位置。</p></li><li><p>让固定定位的盒子 margin-left：版心宽度的一半距离。多走版心宽度的一半位置就可以让固定定位的盒子<strong>贴着版心右侧对齐</strong>了</p></li></ol><h3 id="2-2-绝对定位的盒子居中"><a href="#2-2-绝对定位的盒子居中" class="headerlink" title="2.2 绝对定位的盒子居中"></a>2.2 绝对定位的盒子居中</h3><p>加了<strong>绝对定位&#x2F;固定定位的盒子</strong>不能通过设置 <code>margin: auto</code> 设置<strong>水平居中</strong>,但是可以通过计算方法实现水平和垂直居中</p><ol><li><code>left: 50%;</code>：让<strong>盒子的左侧</strong>移动到<strong>父级元素的水平中心位置</strong>；</li><li><code>margin-left: -100px;</code>：让盒子<strong>向左</strong>移动<strong>自身宽度的一半</strong>。</li></ol><h2 id="3-堆叠顺序（z-index）"><a href="#3-堆叠顺序（z-index）" class="headerlink" title="3. 堆叠顺序（z-index）"></a>3. 堆叠顺序（z-index）</h2><p>在使用<strong>定位</strong>布局时，可能会<strong>出现盒子重叠的情况</strong>。此时，可以使用 <strong>z-index</strong> 来控制盒子的前后次序 (z轴)</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">选择器 &#123; </span><br><span class="line">z-index: 1; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>z-index</code> 的特性如下：</p><ol><li><strong>属性值</strong>：<strong>正整数</strong>、<strong>负整数</strong>或 <strong>0</strong>，默认值是 0，数值越大，盒子越靠上；</li><li>如果<strong>属性值相同</strong>，则按照书写顺序，<strong>后来居上</strong>；</li><li>数字后面<strong>不能加单位</strong>。</li></ol><p><strong>注意</strong>：<code>z-index</code> 只能应用于<strong>相对定位</strong>、<strong>绝对定位</strong>和<strong>固定定位</strong>的元素，其他<strong>标准流</strong>、<strong>浮动</strong>和<strong>静态定位</strong>无效。</p><h2 id="4-定位-position-的拓展"><a href="#4-定位-position-的拓展" class="headerlink" title="4. 定位(position)的拓展"></a>4. 定位(position)的拓展</h2><h3 id="4-1-定位特殊特性"><a href="#4-1-定位特殊特性" class="headerlink" title="4.1 定位特殊特性"></a>4.1 定位特殊特性</h3><p>绝对定位和固定定位也和浮动类似。</p><ul><li><p>行内元素添加绝对或者固定定位，可以直接设置高度和宽度。</p></li><li><p>块级元素添加绝对或者固定定位，如果不给宽度或者高度，默认大小是内容的大小。</p></li></ul><p>display 是 显示模式， 可以改变显示模式有以下方式:</p><ul><li>可以用inline-block  转换为行内块</li><li>可以用浮动 float 默认转换为行内块（类似，并不完全一样，因为浮动是脱标的）</li><li>绝对定位和固定定位也和浮动类似， 默认转换的特性 转换为行内块。</li></ul><p>所以说， 一个行内的盒子，如果加了<strong>浮动</strong>、<strong>固定定位</strong>和<strong>绝对定位</strong>，不用转换，就可以给这个盒子直接设置宽度和高度等。</p><h3 id="4-2-脱标的盒子不会触发外边距塌陷"><a href="#4-2-脱标的盒子不会触发外边距塌陷" class="headerlink" title="4.2 脱标的盒子不会触发外边距塌陷"></a>4.2 脱标的盒子不会触发外边距塌陷</h3><p>浮动元素、<strong>绝对定位(固定定位）</strong>元素的都不会触发外边距合并的问题。 （我们以前是用padding border overflow解决的）</p><p>也就是说，我们给盒子改为了浮动或者定位，就不会有垂直<strong>外边距合并的问题</strong>了。</p><h3 id="4-3-绝对定位（固定定位）会完全压住盒子"><a href="#4-3-绝对定位（固定定位）会完全压住盒子" class="headerlink" title="4.3 绝对定位（固定定位）会完全压住盒子"></a>4.3 绝对定位（固定定位）会完全压住盒子</h3><p>浮动元素不同，只会压住它下面标准流的盒子，但是不会压住下面标准流盒子里面的文字（图片）</p><p>但是绝对定位（固定定位） 会压住下面标准流所有的内容。</p><p>浮动之所以不会压住文字，因为浮动产生的目的最初是为了做文字环绕效果的。 文字会围绕浮动元素</p><h1 id="四、元素的显示与隐藏"><a href="#四、元素的显示与隐藏" class="headerlink" title="四、元素的显示与隐藏"></a>四、元素的显示与隐藏</h1><p>本质：让一个元素在页面中消失或者显示出来</p><h2 id="4-1-display-显示"><a href="#4-1-display-显示" class="headerlink" title="4.1 display 显示"></a>4.1 display 显示</h2><p>display 设置或检索对象是否及如何显示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">display: none 隐藏对象</span><br><span class="line"></span><br><span class="line">display：block 除了转换为块级元素之外，同时还有显示元素的意思。</span><br></pre></td></tr></table></figure><p>display 隐藏元素后，<strong>不再占</strong>有原来的位置</p><h2 id="4-2-visibility-可见性"><a href="#4-2-visibility-可见性" class="headerlink" title="4.2 visibility 可见性"></a>4.2 visibility 可见性</h2><p>visibility 属性用于指定一个元素应可见还是隐藏</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">visibility：visible ; 　元素可视</span><br><span class="line"></span><br><span class="line">visibility：hidden; 　  元素隐藏</span><br></pre></td></tr></table></figure><p>visibility 隐藏元素后，继续占有原来的位置</p><h2 id="4-3-overflow-溢出"><a href="#4-3-overflow-溢出" class="headerlink" title="4.3 overflow 溢出"></a>4.3 overflow 溢出</h2><p>overflow 属性指定了如果内容溢出一个元素的框（超过其指定高度及宽度） 时，会发生什么</p><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td><strong>visible</strong></td><td>不剪切内容也不添加滚动条</td></tr><tr><td><strong>hidden</strong></td><td>不显示超过对象尺寸的内容，超出的部分隐藏掉</td></tr><tr><td><strong>scroll</strong></td><td>不管超出内容否，总是显示滚动条</td></tr><tr><td><strong>auto</strong></td><td>超出自动显示滚动条，不超出不显示滚动条</td></tr></tbody></table><p>一般情况下，我们都不想让溢出的内容显示出来，因为溢出的部分会影响布局</p><p>如果有定位的盒子，慎用 overflow : hidden  因为它会隐藏多余的部分</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th>属性</th><th>区别</th><th>用途</th></tr></thead><tbody><tr><td><strong>display 显示     （重点）</strong></td><td>隐藏对象，不保留位置</td><td>配合后面js做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛</td></tr><tr><td><strong>visibility 可见性 （了解）</strong></td><td>隐藏对象，保留位置</td><td>使用较少</td></tr><tr><td><strong>overflow 溢出（重点）</strong></td><td>只是隐藏超出大小的部分</td><td>可以清除浮动  <br>保证盒子里面的内容不会超出该盒子范围</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS三大特性、盒子模型</title>
      <link href="/2023/03/16/CSS.3/"/>
      <url>/2023/03/16/CSS.3/</url>
      
        <content type="html"><![CDATA[<h1 id="一、CSS三大特性"><a href="#一、CSS三大特性" class="headerlink" title="一、CSS三大特性"></a>一、CSS三大特性</h1><h2 id="1-层叠性"><a href="#1-层叠性" class="headerlink" title="1 层叠性"></a>1 层叠性</h2><p>​相同选择器给设置相同的样式，此时一个样式就会覆盖（层叠）另一个冲突的样式。层叠性主要解决样式冲突的问题</p><p>层叠性原则:</p><ul><li>样式冲突，遵循的原则是就近原则，哪个样式离结构近，就执行哪个样式</li><li>样式不冲突，不会层叠</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230316133724.png"></p><h2 id="2-继承性"><a href="#2-继承性" class="headerlink" title="2 继承性"></a>2 继承性</h2><p>​CSS中的继承: 子标签会继承父标签的某些样式，如文本颜色和字号。恰当地使用继承可以简化代码，降低 CSS 样式的复杂性。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230316133811.png"></p><p>子元素可以继承父元素的样式</p><blockquote><p>text-，font-，line-这些元素开头的可以继承，以及color属性</p></blockquote><p><strong>行高的继承性：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font</span>:<span class="number">12px</span>/<span class="number">1.5</span> Microsoft YaHei；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>行高可以跟单位也可以不跟单位</li><li>如果子元素没有设置行高，则会继承父元素的行高为 1.5</li><li>此时子元素的行高是：当前子元素的文字大小 * 1.5</li><li>body 行高 1.5  这样写法最大的优势就是里面子元素可以根据自己文字大小自动调整行高</li></ul><h2 id="3-优先级"><a href="#3-优先级" class="headerlink" title="3 优先级"></a>3 优先级</h2><p>当同一个元素指定多个选择器，就会有优先级的产生。</p><ul><li>选择器相同，则执行层叠性</li><li>选择器不同，则根据选择器权重执行</li></ul><table><thead><tr><th>选择器</th><th>选择器权重</th></tr></thead><tbody><tr><td>继承或者 *</td><td>0,0,0,0</td></tr><tr><td>元索选择器</td><td>0,0,0,1</td></tr><tr><td>类选择器，伪类选择器</td><td>0,0,1,0</td></tr><tr><td>ID选择器</td><td>0,1,0,0</td></tr><tr><td>行内样式 style</td><td>1,0,0,0</td></tr><tr><td>！important</td><td>无穷大</td></tr></tbody></table><p><strong>优先级注意点:</strong></p><ol><li><p>权重是有4组数字组成,但是不会有进位。</p></li><li><p>可以理解为类选择器永远大于元素选择器, id选择器永远大于类选择器,以此类推..</p></li><li><p>等级判断从左向右，如果某一位数值相同，则判断下一位数值。</p></li><li><p>可以简单记忆法:  通配符和继承权重为0, 标签选择器为1,类(伪类)选择器为 10, id选择器 100, 行内样式表为 1000, !important 无穷大.</p></li><li><p>继承的权重是0， 如果该元素没有直接选中，不管父元素权重多高，子元素得到的权重都是 0。</p></li></ol><p><strong>权重叠加</strong>：如果是复合选择器，则会有权重叠加，需要计算权重，<strong>不会有进位</strong>，比较高位</p><h1 id="二、盒子模型"><a href="#二、盒子模型" class="headerlink" title="二、盒子模型"></a>二、盒子模型</h1><h2 id="1-网页布局的本质"><a href="#1-网页布局的本质" class="headerlink" title="1 网页布局的本质"></a>1 网页布局的本质</h2><p>网页布局的核心本质： 就是利用 CSS 摆盒子。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230316204419.png"></p><p>网页布局过程：</p><ol><li>先准备好相关的网页元素，网页元素基本都是盒子 Box 。</li><li>利用 CSS 设置好盒子样式，然后摆放到相应位置。</li><li>往盒子里面装内容</li></ol><h2 id="2-盒子模型（Box-Model）组成"><a href="#2-盒子模型（Box-Model）组成" class="headerlink" title="2 盒子模型（Box Model）组成"></a>2 盒子模型（Box Model）组成</h2><p>​盒子模型：把 HTML 页面中的布局元素看作是一个矩形的盒子，也就是一个盛装内容的容器。</p><p>​CSS 盒子模型本质上是一个盒子，封装周围的 HTML 元素，它包括：<strong>边框</strong>、<strong>外边距</strong>、<strong>内边距</strong>、和 <strong>实际内容</strong></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230316204449.png"></p><h2 id="3-边框（border）"><a href="#3-边框（border）" class="headerlink" title="3 边框（border）"></a>3 边框（border）</h2><h3 id="3-1-边框的使用"><a href="#3-1-边框的使用" class="headerlink" title="3.1 边框的使用"></a>3.1 边框的使用</h3><p>边框有三部分组成：边框宽度(粗细) 边框样式  边框颜色；</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border</span> : border-width || border-style || border-color;   </span><br></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>border-width</td><td>边框粗细</td></tr><tr><td>border-style</td><td>边框的样式</td></tr><tr><td>border-color</td><td>边框颜色</td></tr></tbody></table><p>边框样式 border-style 可以设置如下值：</p><ul><li>none：没有边框即忽略所有边框的宽度（默认值）</li><li>solid：边框为单实线(最为常用的)</li><li>dashed：边框为虚线  </li><li>dotted：边框为点线</li></ul><p>边框简写：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid red;  </span><br></pre></td></tr></table></figure><blockquote><p>边框简写不分顺序</p></blockquote><p>边框分开写法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-top</span>: <span class="number">1px</span> solid red;  <span class="comment">/* 只设定上边框， 其余同理 */</span>   </span><br></pre></td></tr></table></figure><blockquote><p>某一边单独写注意覆盖问题</p></blockquote><h3 id="3-2-表格的细线边框"><a href="#3-2-表格的细线边框" class="headerlink" title="3.2 表格的细线边框"></a>3.2 表格的细线边框</h3><p>border-collapse 属性控制浏览器绘制表格边框的方式。它控制相邻单元格的边框。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-collapse</span>:collapse; </span><br></pre></td></tr></table></figure><p>collapse 单词是合并的意思</p><p>border-collapse: collapse; 表示相邻边框合并在一起</p><h3 id="3-3-边框会影响盒子实际大小"><a href="#3-3-边框会影响盒子实际大小" class="headerlink" title="3.3 边框会影响盒子实际大小"></a>3.3 边框会影响盒子实际大小</h3><p>边框会额外增加盒子的实际大小。因此我们有两种方案解决：</p><ul><li>测量盒子大小的时候,不量边框。</li><li>如果测量的时候包含了边框,则需要 width&#x2F;height 减去边框宽度</li></ul><h2 id="4-内边距（padding）"><a href="#4-内边距（padding）" class="headerlink" title="4 内边距（padding）"></a>4 内边距（padding）</h2><h3 id="4-1-内边距的使用方式"><a href="#4-1-内边距的使用方式" class="headerlink" title="4.1 内边距的使用方式"></a>4.1 内边距的使用方式</h3><p>padding 属性用于设置内边距，即边框与内容之间的距离。</p><p>语法：</p><p>合写属性：</p><table><thead><tr><th>值的个数</th><th>表达意思</th></tr></thead><tbody><tr><td>padding: 5px;</td><td>1个值，代表上下左右都是5像索内边距</td></tr><tr><td>padding: 5px 10px;</td><td>2个值，代表上下内边距是5像素，左右内边距是10像索</td></tr><tr><td>padding: 5px 10px 20px;</td><td>3个值，代表上内边距5像素，左右内边距10像素，下内边距20像素</td></tr><tr><td>padding: 5px 10px 20px 30px;</td><td>4个值，上是5像素，右10像素，下20像素，左是30像素，顺时针</td></tr></tbody></table><p>分写属性：</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>padding-left</td><td>左内边距</td></tr><tr><td>padding-right</td><td>右内边距</td></tr><tr><td>padding-top</td><td>上内边距</td></tr><tr><td>padding- bottom</td><td>下内边距</td></tr></tbody></table><h3 id="4-2-内边距会影响盒子实际大小"><a href="#4-2-内边距会影响盒子实际大小" class="headerlink" title="4.2 内边距会影响盒子实际大小"></a>4.2 内边距会影响盒子实际大小</h3><p>当我们给盒子指定 padding 值之后，发生了 2 件事情：</p><ol><li>内容和边框有了距离，添加了内边距。</li><li>padding影响了盒子实际大小。</li></ol><p>内边距对盒子大小的影响：</p><ul><li>如果盒子已经有了宽度和高度，此时再指定内边框，会撑大盒子。</li><li>如何盒子本身没有指定width&#x2F;height属性, 则此时padding不会撑开盒子大小。</li></ul><p>解决方案：如果保证盒子跟效果图大小保持一致，则让 width&#x2F;height 减去多出来的内边距大小即可。</p><h2 id="5-外边距（margin）"><a href="#5-外边距（margin）" class="headerlink" title="5 外边距（margin）"></a>5 外边距（margin）</h2><h3 id="5-1-外边距的使用方式"><a href="#5-1-外边距的使用方式" class="headerlink" title="5.1 外边距的使用方式"></a>5.1 外边距的使用方式</h3><p>margin 属性用于设置外边距，即控制盒子和盒子之间的距离。</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>margin-left</td><td>左外边距</td></tr><tr><td>margin-right</td><td>右外边距</td></tr><tr><td>margin-top</td><td>上外边距</td></tr><tr><td>margin-bottom</td><td>下外边距</td></tr></tbody></table><h3 id="5-2-外边距典型应用"><a href="#5-2-外边距典型应用" class="headerlink" title="5.2 外边距典型应用"></a>5.2 外边距典型应用</h3><p>外边距可以让块级盒子水平居中的两个条件：</p><ul><li>盒子必须指定了宽度（width）。</li><li>盒子左右的外边距都设置为 auto 。</li></ul><p>常见的写法，以下三种都可以：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">margin-left</span>: auto;   <span class="attribute">margin-right</span>: auto;</span><br><span class="line"><span class="attribute">margin</span>: auto;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br></pre></td></tr></table></figure><blockquote><p>注意：以上方法是让块级元素水平居中，行内元素或者行内块元素水平居中给其父元素添加 text-align : center 即可。</p></blockquote><h3 id="5-3-外边距合并"><a href="#5-3-外边距合并" class="headerlink" title="5.3 外边距合并"></a>5.3 外边距合并</h3><p>使用 margin 定义块元素的垂直外边距时，可能会出现外边距的合并。</p><p>主要有两种情况:</p><ol><li>相邻块元素垂直外边距的合并</li></ol><p>​当上下相邻的两个块元素（兄弟关系）相遇时，如果上面的元素有下外边距 margin-bottom，下面的元素有上外边距 margin-top ，则他们之间的垂直间距不是 margin-bottom 与 margin-top 之和。取两个值中的较大者这种现象被称为相邻块元素垂直外边距的合并。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230316205753.png"></p><p>解决方案：尽量只给一个盒子添加 margin 值。</p><ol start="2"><li>嵌套块元素垂直外边距的塌陷</li></ol><p>​        对于两个嵌套关系（父子关系）的块元素，父元素有上外边距同时子元素也有上外边距，此时父元素会塌陷较大的外边距值。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230316205909.png"></p><p>解决方案：</p><ul><li>可以为父元素定义上边框。</li><li>可以为父元素定义上内边距。</li><li>可以为父元素添加 overflow : hidden</li></ul><h3 id="5-4-清除内外边距"><a href="#5-4-清除内外边距" class="headerlink" title="5.4 清除内外边距"></a>5.4 清除内外边距</h3><p>网页元素很多都带有默认的内外边距，而且不同浏览器默认的也不一致。因此我们在布局前，首先要清除下网页元素的内外边距。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">   <span class="attribute">padding</span>:<span class="number">0</span>;   <span class="comment">/* 清除内边距 */</span></span><br><span class="line">   <span class="attribute">margin</span>:<span class="number">0</span>;    <span class="comment">/* 清除外边距 */</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：行内元素为了照顾兼容性，尽量只设置左右内外边距，不要设置上下内外边距。但是转换为块级和行内块元素就可以了</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>emmet语法、CSS简介、引入</title>
      <link href="/2023/03/15/CSS.0/"/>
      <url>/2023/03/15/CSS.0/</url>
      
        <content type="html"><![CDATA[<h1 id="一、emmet语法"><a href="#一、emmet语法" class="headerlink" title="一、emmet语法"></a>一、emmet语法</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>​        Emmet语法的前身是Zen coding,它使用缩写,来提高html&#x2F;css的编写速度, Vscode内部已经集成该语法。</p><ul><li>快速生成HTML结构语法</li><li>快速生成CSS样式语法</li></ul><h2 id="2-快速生成HTML结构语法"><a href="#2-快速生成HTML结构语法" class="headerlink" title="2 快速生成HTML结构语法"></a>2 快速生成HTML结构语法</h2><ul><li>生成标签 直接输入标签名 按tab键即可   比如  div   然后tab 键， 就可以生成 &lt; div&gt;&lt;&#x2F; div&gt;</li><li>如果想要生成多个相同标签  加上 * 就可以了 比如   div*3  就可以快速生成3个div</li><li>如果有父子级关系的标签，可以用 &gt;  比如   ul &gt; li就可以了</li><li>如果有兄弟关系的标签，用  +  就可以了 比如 div+p  </li><li>如果生成带有类名或者id名字的，  直接写  .demo  或者  #two   tab 键就可以了</li><li>如果生成的div 类名是有顺序的， 可以用 自增符号  $ </li><li>如果想要在生成的标签内部写内容可以用  { }  表示</li></ul><h2 id="3-快速生成CSS样式语法"><a href="#3-快速生成CSS样式语法" class="headerlink" title="3 快速生成CSS样式语法"></a>3 快速生成CSS样式语法</h2><p>CSS 基本采取简写形式即可，如：</p><ul><li>w200   按tab  可以 生成  width: 200px;</li><li>lh26px   按tab  可以生成  line-height: 26px;</li></ul><h1 id="二、-CSS简介"><a href="#二、-CSS简介" class="headerlink" title="二、 CSS简介"></a>二、 CSS简介</h1><p><strong>CSS 的主要使用场景就是布局网页，美化页面的。</strong></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230311153410.png"></p><h2 id="1-HTML的局限性"><a href="#1-HTML的局限性" class="headerlink" title="1 HTML的局限性"></a>1 HTML的局限性</h2><p>HTML 只关注内容的语义，虽然 HTML 可以做简单的样式，但是带来的是无尽的臃肿、繁琐和难以维护……</p><h2 id="2-CSS作用"><a href="#2-CSS作用" class="headerlink" title="2 CSS作用"></a>2 CSS作用</h2><p>CSS 是 <code>层叠样式表</code> 的简称。有时我们也会称之为 <code>CSS样式表</code> 或 <code>级联样式表</code>。CSS 也是一种 <code>标记语言</code>。</p><p>CSS 主要用于设置：</p><ul><li>HTML 页面中的文本样式（字体、大小、颜色、对齐方式……）</li><li>图片样式（宽高、边框样式、边距……）</li><li>以及版面的布局和外观显示样式。</li></ul><p>CSS 让我们的网页更加丰富多彩，布局更加灵活自如，简单理解：CSS 可以美化 HTML，让 HTML 更漂亮，同时让页面布局更简单。</p><p><strong>总结：</strong></p><ul><li>HTML 搭建结构，填入元素内容</li><li>CSS 美化 HTML，布局网页元素</li><li>CSS 最大价值：由 HTML 专注去做结构呈现，样式交给 CSS，即：<strong>结构与样式分离</strong></li></ul><h2 id="3-CSS语法规范"><a href="#3-CSS语法规范" class="headerlink" title="3 CSS语法规范"></a>3 CSS语法规范</h2><p>使用 HTML 时，需要遵从一定的规范，CSS 也是如此，要想熟练地使用 CSS 对网页进行修饰，首先需要了解 CSS 样式规则。</p><p>CSS 规则由两个主要的部分构成：<code>选择器</code> 以及 <code>一条或多条声明</code>。</p><ul><li><code>选择器</code> 是用于选出需要设置 CSS 样式的 HTML 标签，选择器后跟的<strong>花括号</strong>内是对该对象设置的具体样式</li><li><code>属性</code> 和 <code>属性值</code> 以 “键值对” 的形式出现 <code>属性: 属性值;</code></li><li>属性是对指定的对象设置的样式属性，例如：字体大小、文本颜色等</li><li>属性和属性值之间用英文 <code>:</code> 分开</li><li>多个 “键值对” 之间用英文 <code>;</code> 进行区分（末尾的键值对可以不加 <code>;</code>）</li></ul><p>所有的样式，都包含在 <code>&lt;style&gt;</code> 标签内，表示是样式表。</p><p><code>&lt;style&gt;</code> 一般写到 <code>&lt;/head&gt;</code> 里。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">h4</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: bule;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-size</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：<code>&lt;style&gt;</code> 标签可以写到其他标签内部并作用与该标签区域内，但是强烈不推荐这种写法！</p><blockquote><p>目前 <code>type=&quot;text/css&quot;</code> 可以省略。</p></blockquote><h2 id="4-CSS代码风格"><a href="#4-CSS代码风格" class="headerlink" title="4 CSS代码风格"></a>4 CSS代码风格</h2><h3 id="4-1-样式格式书写"><a href="#4-1-样式格式书写" class="headerlink" title="4.1 样式格式书写"></a>4.1 样式格式书写</h3><ul><li>紧凑格式（不推荐）</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h3</span> &#123; <span class="attribute">color</span>: deeppink; <span class="attribute">font-size</span>: <span class="number">20px</span>; &#125;</span><br></pre></td></tr></table></figure><ul><li>展开格式（<strong>推荐</strong>）</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: deeppink;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>强烈推荐第二种格式，因为更直观！不用担心占用空间，因为后期可以通过代码压缩工具来压缩代码。</p><h3 id="4-2-样式大小书写"><a href="#4-2-样式大小书写" class="headerlink" title="4.2 样式大小书写"></a>4.2 样式大小书写</h3><ul><li>大写（不推荐）</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">H3</span> &#123;</span><br><span class="line">    <span class="attribute">COLOR</span>: PINK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>小写（<strong>推荐</strong>）</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>强烈推荐样式选择器，属性名，属性值关键字<strong>全部使用小写字母</strong>，特殊情况除外。</p><blockquote><p>凡是你不确定是否用大写的都一律用小写就对了！</p></blockquote><h3 id="4-3-空格规范"><a href="#4-3-空格规范" class="headerlink" title="4.3 空格规范"></a>4.3 空格规范</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h3</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>属性值前面</strong>，<strong>冒号后面</strong>，保留一个空格</li><li><strong>选择器（标签）和前花括号中间</strong>，保留一个空格</li></ul><h1 id="三、CSS引入方式"><a href="#三、CSS引入方式" class="headerlink" title="三、CSS引入方式"></a>三、CSS引入方式</h1><h2 id="1-CSS的三种引入方式"><a href="#1-CSS的三种引入方式" class="headerlink" title="1 CSS的三种引入方式"></a>1 CSS的三种引入方式</h2><p>按照 CSS 样式书写的位置（或者引入的方式），CSS 样式表可以分为三大类：</p><ul><li><strong>内嵌式</strong>：CSS 写在style标签中</li></ul><blockquote><p>style标签虽然可以写在页面任意位置，但是通常约定写在 head 标签中</p></blockquote><ul><li><strong>外联式</strong>：CSS 写在一个单独的.css文件中</li></ul><blockquote><p>需要通过link标签在网页中引入</p></blockquote><ul><li><strong>行内式</strong>：CSS 写在标签的style属性中</li></ul><blockquote><p>配合js使用</p></blockquote><table><thead><tr><th>引入方式</th><th>书写位置</th><th>作用范围</th><th>使用场景</th></tr></thead><tbody><tr><td>内嵌式</td><td>CSS写在style标签中</td><td>当前页面</td><td>小案例</td></tr><tr><td>外联式</td><td>CSS写在单独的css文件中，通过link标签引入</td><td>多个页面</td><td>项目中</td></tr><tr><td>行内式</td><td>CSS写在标签的style属性中</td><td>当前标签</td><td>配合js使用</td></tr></tbody></table><h2 id="2-内嵌式"><a href="#2-内嵌式" class="headerlink" title="2 内嵌式"></a>2 内嵌式</h2><p>内部样式表（嵌入样式表）时写到 HTML 页面内部，是将所有的 CSS 代码抽取出来，单独放到一个 <code>&lt;style&gt;</code> 标签中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">font-size</span>: <span class="number">12px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;style&gt;</code> 标签理论上可以放在 HTML 文档的任何地方，但一般会放到文档的 <code>&lt;head&gt;</code> 标签中</li><li>目前的浏览器已经支持<strong>省略</strong> <code>type</code> <strong>属性</strong></li><li>通过此种方式，可以方便控制当前整个页面中的元素样式设置</li><li>代码结构清晰，但是并没有实现结构与样式完全分离</li><li>使用内部样式表设定 CSS，通常也被称为 <code>嵌入式引入</code>，这种方式是我们练习时常用的方式</li></ul><h2 id="3-外联式"><a href="#3-外联式" class="headerlink" title="3 外联式"></a>3 外联式</h2><p>实际开发都是外部样式表，适合于样式比较多的情况，核心是：样式单独写到 CSS 文件中，之后把 CSS 文件引入到 HTML 页面中使用。</p><p>引入外部样式表分为两步：</p><ul><li>新建一个后缀名为：<code>.css</code> 的样式文件，把所有的 CSS 代码都放入此文件中</li><li>在 HTML 页面中，使用 <code>&lt;link&gt;</code> 标签引入这个文件</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css文件路径&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td><code>rel</code></td><td>定义当前文档与被链接文档之间的关系，在这里**需要指定为 “stylesheet”**，表示被链接的文档是一个样式表文件</td></tr><tr><td><code>type</code></td><td>定义被链接文档的 MIME 类型，该属性最常见的 MIME 类型是 “text&#x2F;css”，该类型描述样式表，目前的浏览器<strong>已经支持省略 “type” 属性</strong></td></tr><tr><td><code>href</code></td><td>定义所链接外部样式表文件的 URL，可以是相对路径，也可以是绝对路径</td></tr></tbody></table><blockquote><p><strong>注意：</strong>使用外部样式表设定 CSS，通常也被称为 <code>外链式</code> 或 <code>链接式引入</code>，这种方式是开发中常用的方式。</p></blockquote><h2 id="4-行内式"><a href="#4-行内式" class="headerlink" title="4 行内式"></a>4 行内式</h2><p>行内样式表（内联样式表）是在元素标签内部的 style 属性中设定 CSS 样式，适合于修改简单样式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;color: red; font-size: 12px;&quot;</span>&gt;</span></span><br><span class="line">    内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>style</code> 其实就是标签的属性</li><li>在双引号中间，写法要符合 CSS 规范</li><li>可以控制当前的标签设置样式</li><li>由于书写繁琐，并且没有体现出结构与样式相分离的思想，所以不推荐大量使用，只有对当前元素添加简单样式的时候，可以考虑使用</li><li>使用行内样式表设定 CSS，通常也被称为 <code>行内式引入</code></li></ul><h1 id="四、CSS-的元素显示模式"><a href="#四、CSS-的元素显示模式" class="headerlink" title="四、CSS 的元素显示模式"></a>四、CSS 的元素显示模式</h1><h2 id="1-什么是元素显示模式"><a href="#1-什么是元素显示模式" class="headerlink" title="1 什么是元素显示模式"></a>1 什么是元素显示模式</h2><p><strong>作用：</strong>网页的标签非常多，在不同地方会用到不同类型的标签，了解他们的特点可以更好的布局我们的网页。</p><p><code>元素显示模式</code> 就是元素（标签）以什么方式进行显示，比如 <code>&lt;div&gt;</code> 自己占一行，比如一行可以放多个 <code>&lt;span&gt;</code>。</p><p>HTML 元素一般分为 <code>块元素</code> 和 <code>行内元素</code> 两种类型。</p><h2 id="2-块元素"><a href="#2-块元素" class="headerlink" title="2 块元素"></a>2 块元素</h2><p>常见的块元素有 <code>&lt;h1&gt; ~ &lt;h6&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;div&gt;</code>、<code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;li&gt;</code>、<code>&lt;dl&gt;</code>、<code>&lt;dt&gt;</code>、<code>&lt;dd&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;thead&gt;</code>、<code>&lt;tbody&gt;</code>、<code>&lt;tr&gt;</code>、<code>&lt;form&gt;</code> 等，其中 <code>&lt;div&gt;</code> 标签是最典型的块元素。</p><p><strong>块级元素的特点：</strong></p><ul><li>比较霸道，自己独占一行</li><li>高度，宽度、外边距以及内边距都可以控制</li><li>宽度默认是容器（父级宽度）的 100%</li><li>是一个容器及盒子，里面可以放行内或者块级元素</li></ul><p><strong>注意：</strong></p><ul><li>文字类的块级元素内不能放置块级元素，会发生语法错误</li><li><code>&lt;p&gt;</code> 标签主要用于存放文字，因此 <code>&lt;p&gt;</code> 里面不能放块级元素，特别是不能放 <code>&lt;div&gt;</code></li><li>同理， <code>&lt;h1&gt; ~ &lt;h6&gt;</code> 等都是文字类块级标签，里面也不能放其他块级元素</li></ul><h2 id="3-行内元素"><a href="#3-行内元素" class="headerlink" title="3 行内元素"></a>3 行内元素</h2><p>常见的行内元素有 <code>&lt;a&gt;</code>、<code>&lt;span&gt;</code>、<code>&lt;em&gt;</code>、<code>&lt;strong&gt;</code> 等，其中 <code>&lt;span&gt;</code> 标签是最典型的行内元素，有的地方也将行内元素称为内联元素。</p><p><strong>行内元素的特点：</strong></p><ul><li><p>相邻行内元素在一行上，一行可以显示多个</p></li><li><p>高、宽直接设置是无效的</p></li><li><p>默认宽度就是它本身内容的宽度</p></li><li><p>行内元素只能容纳文本或其他行内元素（a 除外）</p></li></ul><p><strong>注意：</strong></p><ul><li>链接里面不能再放链接</li><li>特殊情况链接 <code>&lt;a&gt;</code> 里面可以放块级元素，但是给 <code>&lt;a&gt;</code> 转换一下块级模式最安全</li></ul><h2 id="4-行内块元素"><a href="#4-行内块元素" class="headerlink" title="4 行内块元素"></a>4 行内块元素</h2><p>在行内元素中有几个特殊的标签：<code>&lt;img&gt;</code>、<code>&lt;input&gt;</code>、<code>&lt;th&gt;</code>、<code>&lt;td&gt;</code>，它们同时具有 <code>块元素</code> 和 <code>行内元素</code> 的特点，有些资料称它们为 <code>行内块元素</code>。</p><p><strong>行内块元素的特点：</strong></p><ul><li>和相邻行内元素（行内块）在一行上，一行可以显示多个（行内元素特点），但是他们之间会有空白缝隙。</li><li>默认宽度就是它本身内容的宽度（行内元素特点）</li><li>高度，行高、外边距以及内边距都可以控制（块级元素特点）</li></ul><h2 id="5-元素显示模式总结"><a href="#5-元素显示模式总结" class="headerlink" title="5 元素显示模式总结"></a>5 元素显示模式总结</h2><table><thead><tr><th>元素模式</th><th>元素排列</th><th>设置样式</th><th>默认宽度</th><th>包含</th></tr></thead><tbody><tr><td>块级元素</td><td>一行只能放一个块级元素</td><td>可以设置宽度和高度</td><td>容器的 100%</td><td>容量级可以包含任何标签</td></tr><tr><td>行内元素</td><td>一行可以放多个行内元素</td><td>不可以直接设置宽度和高度</td><td>它本身内容的宽度</td><td>容纳文本或其他行内元素</td></tr><tr><td>行内块元素</td><td>一行放多个行内块元素</td><td>可以设置宽度和高度</td><td>它本身内容的宽度</td><td>容纳文本或其他行内元素</td></tr></tbody></table><p>学习元素显示模式的主要目的是分清它们各自的特点，当我们网页布局的时候，在合适的地方用合适的标签元素。</p><h2 id="6-元素显示模式转换"><a href="#6-元素显示模式转换" class="headerlink" title="6 元素显示模式转换"></a>6 元素显示模式转换</h2><p>特殊情况下，我们需要元素模式的转换，简单理解: 一个模式的元素需要另外一种模式的特性</p><p>比如：想要增加链接 <code>&lt;a&gt;</code> 的触发范围。</p><ul><li>转换为块元素：<code>display: block;</code>（由于经常需要设置宽高，所以通常会将行内元素转换为块元素）</li><li>转换为行内元素：<code>display: inline;</code>（不常用）</li><li>转换为行内块：<code>display: inline-block;</code>（常用）</li></ul><h2 id="7-小技巧：单行文字垂直居中"><a href="#7-小技巧：单行文字垂直居中" class="headerlink" title="7 小技巧：单行文字垂直居中"></a>7 小技巧：单行文字垂直居中</h2><p>CSS 没有给我们提供文字垂直居中的代码，这里我们可以使用一个小技巧来实现。</p><p><strong>解决方案：</strong>让 <code>文字的行高</code> 等于 <code>盒子的高度</code> 就可以让文字在当前盒子内垂直居中。</p><p><strong>简单理解：</strong>行高的上空隙和下空隙把文字挤到中间了，如果行高小于盒子高度，文字会偏上，如果行高大于盒子高度，则文字偏下。</p><h2 id="8-一个注意点：块级元素不会自动换行"><a href="#8-一个注意点：块级元素不会自动换行" class="headerlink" title="8 一个注意点：块级元素不会自动换行"></a>8 一个注意点：块级元素不会自动换行</h2><p>当块级元素的宽度超过其父元素宽度时，其不会发生换行。</p><h1 id="五、CSS属性书写顺序"><a href="#五、CSS属性书写顺序" class="headerlink" title="五、CSS属性书写顺序"></a>五、CSS属性书写顺序</h1><p>建议遵循以下顺序：</p><ol><li><strong>布局定位属性</strong>：display &#x2F; position &#x2F; float &#x2F; clear &#x2F; visibility &#x2F; overflow（建议 display 第一个写，毕竟关系到模式）</li><li><strong>自身属性</strong>：width &#x2F; height &#x2F; margin &#x2F; padding &#x2F; border &#x2F; background</li><li><strong>文本属性</strong>：color &#x2F; font &#x2F; text-decoration &#x2F; text-align &#x2F; vertical-align &#x2F; white- space &#x2F; break-word</li><li><strong>其他属性</strong>：content &#x2F; cursor &#x2F; border-radius &#x2F; box-shadow &#x2F; text-shadow &#x2F; background:linear-gradient</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 元素显示模式、背景</title>
      <link href="/2023/03/15/CSS.2/"/>
      <url>/2023/03/15/CSS.2/</url>
      
        <content type="html"><![CDATA[<h1 id="一、CSS字体属性"><a href="#一、CSS字体属性" class="headerlink" title="一、CSS字体属性"></a>一、CSS字体属性</h1><p>CSS Fonts（字体）属性用于定义：<code>字体系列</code>、<code>大小</code>、<code>粗细</code>、和 <code>文字样式</code>（如：斜体）。</p><h2 id="1-字体系列"><a href="#1-字体系列" class="headerlink" title="1 字体系列"></a>1 字体系列</h2><p>CSS 使用 font-family 属性定义文本的字体系列。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123; <span class="attribute">font-family</span>: <span class="string">&quot;Microsoft YaHei&quot;</span>; &#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123; <span class="attribute">font-family</span>: Arial, <span class="string">&quot;Microsoft YaHei&quot;</span>; &#125;</span><br></pre></td></tr></table></figure><ul><li>各种字体之间必须使用英文状态下的逗号隔开</li><li>一般情况下，如果有空格隔开的多个单词组成的字体，加引号，如 ‘Microsoft YaHei ‘</li><li>尽量使用系统默认自带字体，保证在任何用户的浏览器中都能正确显示</li><li>最常用的字体：<code>body &#123;font-family: &quot;Microsoft YaHei&quot;, tahoma, arial, sans-serif, &quot;Hiragino Sans GB&quot;;&#125;</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 浏览器会从第一个字体开始进行适配，如果本机可以适配的话，那么就使用该字体，否则看下一个字体，</span></span></span><br><span class="line"><span class="comment"><span class="language-css">       如果都不可以，那么浏览器会使用自带的默认字体，所以实际开发中一般建议使用比较标准化的字体 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">font-family</span>: <span class="string">&quot;Microsoft YaHei&quot;</span>, Arial, sans-serif;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">font-family</span>: <span class="string">&quot;Times New Roman&quot;</span>, Times, serif;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">···</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>测试内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：浏览器字体是依据用户操作系统来调用的，所以这里介绍一种 Windows 系统安装字体的方法。</p><blockquote><p>当然实际开发中通常浏览器请求时，会把字体文件随 HTML CSS JS 等一同传送到客服端。</p></blockquote><h2 id="2-字体大小"><a href="#2-字体大小" class="headerlink" title="2 字体大小"></a>2 字体大小</h2><p>CSS 使用 font-size 属性定义字体大小。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>px（像素）大小是我们网页的最常用的单位（不加 px 无效）</li><li>谷歌浏览器默认的文字大小为：16px</li><li>不同浏览器可能默认显示的字号大小不一致，我们尽量给一个明确值大小，不要默认大小</li><li>可以给 body 指定整个页面文字的大小4.3 字体粗细</li></ul><h2 id="3-字体粗细"><a href="#3-字体粗细" class="headerlink" title="3 字体粗细"></a>3 字体粗细</h2><p>CSS 使用 font-weight 属性设置文本字体的粗细。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td><code>normal</code></td><td>默认值（不加粗的）</td></tr><tr><td><code>bold</code></td><td>定义粗体（加粗的）</td></tr><tr><td><code>100-900</code></td><td>400 等同于 normal，而 700 等同于 bold，其它值一般不使用，注意这个数字后面不跟单位，取整百值</td></tr></tbody></table><ul><li>学会让加粗标签（比如 h 和 strong 等）变为不加粗，或者让其他标签加粗</li><li>实际开发时，我们更喜欢用数字表示粗细</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.bold</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">font-weight</span>: <span class="number">700</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 使文字不加粗 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">h2</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="comment">/* font-weight: normal; */</span></span></span><br><span class="line"><span class="language-css">        <span class="attribute">font-weight</span>: <span class="number">400</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">···</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>测试内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-文字样式"><a href="#4-文字样式" class="headerlink" title="4 文字样式"></a>4 文字样式</h2><p>CSS 使用 font-style 属性设置文本的风格。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">font-style</span>: italic; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>作用</th></tr></thead><tbody><tr><td><code>normal</code></td><td>默认值，浏览器会显示标准的字体样式 font-style: normal;</td></tr><tr><td><code>italic</code></td><td>浏览器会显示斜体的字体样式</td></tr></tbody></table><p><strong>注意：</strong>平时我们很少给文字加斜体，反而要给斜体标签 (em、i) 改为不倾斜字体。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 让不倾斜的字体倾斜 */</span></span></span><br><span class="line"><span class="language-css">        <span class="attribute">font-style</span>: italic;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">em</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 让倾斜的字体不倾斜 */</span></span></span><br><span class="line"><span class="language-css">        <span class="attribute">font-style</span>: normal;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">···</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>上课时候的你<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">em</span>&gt;</span>下课时候的你<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="5-字体复合属性"><a href="#5-字体复合属性" class="headerlink" title="5 字体复合属性"></a>5 字体复合属性</h2><p>字体属性可以把以上文字样式综合来写，这样可以更节约代码。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#模板</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font</span>: font-style font-weight font-size/line-height font-family;</span><br><span class="line">&#125;</span><br><span class="line">#例</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font</span>: normal <span class="number">400</span> font-size/line-height <span class="string">&quot;Microsoft YaHei&quot;</span>, Arial, sans-serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 font 属性时，<strong>必须按上面语法格式中的顺序书写，不能更换顺序</strong>，并且各个属性间以空格隔开</li><li>不需要设置的属性可以省略（取默认值），但必须保留 font-size 和 font-family 属性，否则 font 属性将不起作用</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 想要 div 文字变倾斜、加粗、字号设置为 16 像素，并且是微软雅黑 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 复合属性：简写的方式，里面的顺序不能打乱 以空格隔开 */</span></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* font: font-style font-weight font-size/line-height font-family; */</span></span></span><br><span class="line"><span class="language-css">        <span class="attribute">font</span>: italic <span class="number">700</span> <span class="number">16px</span>/<span class="number">20px</span> <span class="string">&#x27;Microsoft YaHei&#x27;</span>;</span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 注意：不需要设置的属性可以省略（取默认值），但必须保留 font-size 和 font-family 属性，否则 font 属性将不起作用 */</span></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* font: 20px &#x27;Microsoft YaHei&#x27;； */</span></span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">···</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>三生三世十里桃花，一心一意百行代码<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6-字体属性总结"><a href="#6-字体属性总结" class="headerlink" title="6 字体属性总结"></a>6 字体属性总结</h2><table><thead><tr><th>属性</th><th>表示</th><th>注意点</th></tr></thead><tbody><tr><td><code>font-size</code></td><td>字号</td><td>我们通常用的单位是 px 像素，一定要跟上单位</td></tr><tr><td><code>font-family</code></td><td>字体</td><td>实际工作中按照团队约定来写字体</td></tr><tr><td><code>font-weight</code></td><td>字体属性</td><td>记住加粗是 700 或者 bold 不加粗 是 normal 或者 400 记住数字不要跟单位</td></tr><tr><td><code>font-style</code></td><td>字体样式</td><td>记住倾斜是 italic 不倾斜是 normal 工作中我们最常用 normal</td></tr><tr><td><code>font</code></td><td>字体连写</td><td>1、字体连写是有顺序的不能随意换位置，2、其中字号和字体必须同时出现</td></tr></tbody></table><h1 id="二、CSS文本属性"><a href="#二、CSS文本属性" class="headerlink" title="二、CSS文本属性"></a>二、CSS文本属性</h1><p>CSS Text（文本）属性可定义文本的 <code>外观</code>，比如：<code>文本颜色</code>、<code>文本对齐</code>、<code>文本装饰</code>、<code>文本缩进</code>、<code>行间距</code> 等。</p><h2 id="1-文本颜色"><a href="#1-文本颜色" class="headerlink" title="1 文本颜色"></a>1 文本颜色</h2><p><code>color</code> 属性用于定义文本的颜色。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#EE0000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>表示方式</th><th>属性值</th></tr></thead><tbody><tr><td>预定义的颜色值</td><td>red，green，blue，black，white，gray</td></tr><tr><td>十六进制</td><td>#FF0000，#66CCFF，#EE82EE</td></tr><tr><td>RGB 代码</td><td>rgb(255, 0, 0) 或 rgb(100%, 0%, 0%)</td></tr></tbody></table><blockquote><p> <strong>注意：</strong>开发中最常用的是十六进制。 </p></blockquote><blockquote><p>颜色直接吸取，不用记</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="comment">/* color: deeppink; */</span></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* color: #FF1493; 最常用 */</span></span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">255</span>, <span class="number">20</span>, <span class="number">147</span>);</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">···</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>pink<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-文本对齐"><a href="#2-文本对齐" class="headerlink" title="2 文本对齐"></a>2 文本对齐</h2><p><code>text-align</code> 属性用于设置元素内文本内容的水平对齐方式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>解释</th></tr></thead><tbody><tr><td>left</td><td>左对齐（默认值）</td></tr><tr><td>right</td><td>右对齐</td></tr><tr><td>center</td><td>居中对齐</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">h1</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 本质是让 h1 盒子里面的文字水平居中对齐 */</span></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* text-align: center; */</span></span></span><br><span class="line"><span class="language-css">        <span class="attribute">text-align</span>: right;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">···</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>右对齐的标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>text-align</code> 属性只能作用于 <code>块级元素</code>，并让该块级元素内的 <code>行内元素</code> 实现居中（不一定是文字）。</p></blockquote><h2 id="3-文本装饰"><a href="#3-文本装饰" class="headerlink" title="3 文本装饰"></a>3 文本装饰</h2><p><code>text-decoration</code> 属性规定添加到文本的修饰，可以给文本添加 <code>下划线</code>、<code>删除线</code>、<code>上划线</code> 等。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: underline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td><code>none</code></td><td>默认，没有装饰线（<strong>最常用</strong>）</td></tr><tr><td><code>underline</code></td><td>下划线，链接 a 自带下划线（常用）</td></tr><tr><td><code>overline</code></td><td>上划线（几乎不用）</td></tr><tr><td><code>line-through</code></td><td>删除线（不常用）</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">text-decoration</span>: underline;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">a</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">text-decoration</span>: none;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>: <span class="number">#66CCFF</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">···</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>粉红色的回忆<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://jerry-z-j-r.github.io&quot;</span>&gt;</span>JERRY<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-文本缩进"><a href="#4-文本缩进" class="headerlink" title="4 文本缩进"></a>4 文本缩进</h2><p><code>text-indent</code> 属性用来指定文本的第一行的缩进，通常是将段落的首行缩进。</p><p>通过设置该属性，所有元素的第一行都可以缩进一个给定的长度，甚至该长度可以是负值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">text-indent</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>em 是一个相对单位，就是当前元素 (font-size) 1 个文字的大小，如果当前元素没有设置大小，则会按照父元素的 1 个文字大小。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">text-indent</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-行间距（行高）"><a href="#5-行间距（行高）" class="headerlink" title="5 行间距（行高）"></a>5 行间距（行高）</h2><p><code>line-height</code> 属性用于设置行间的距离（行高），可以控制文字行与行之间的距离。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">26px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>行间距 = 上间距 + 文本高度 + 下间距</code></p></li><li><p><code>上下间距 = （行间距 - 文本高度）/ 2</code></p></li><li><p><code>文本高度 = font-size</code></p></li></ul><blockquote><p>行高 &#x3D;&#x3D; 容器高度 可实现文本垂直居中</p></blockquote><h2 id="6-文本属性总结"><a href="#6-文本属性总结" class="headerlink" title="6 文本属性总结"></a>6 文本属性总结</h2><table><thead><tr><th>属性</th><th>表示</th><th>注意点</th></tr></thead><tbody><tr><td><code>color</code></td><td>文本颜色</td><td>我们通常用 十六进制 而且通常是简写形式 #fff（6 个一样可以简写）</td></tr><tr><td><code>text-align</code></td><td>文本对齐</td><td>可以设定文字水平的对齐方式</td></tr><tr><td><code>text-indent</code></td><td>文本缩进</td><td>通常我们用于段落首行缩进2个字的距离 text-indent: 2em;</td></tr><tr><td><code>text-decoration</code></td><td>文本修饰</td><td>牢记 添加下划线 underline 取消下划线 none</td></tr><tr><td><code>line-height</code></td><td>行高</td><td>控制行与行之间的距离</td></tr></tbody></table><h1 id="三、CSS-的背景"><a href="#三、CSS-的背景" class="headerlink" title="三、CSS 的背景"></a>三、CSS 的背景</h1><p>通过 CSS 背景属性，可以给页面元素添加背景样式。<br>背景属性可以设置 <code>背景颜色</code>、<code>背景图片</code>、<code>背景平铺</code>、<code>背景图片位置</code>、<code>背景图像固定</code> 等。</p><h2 id="1-背景颜色"><a href="#1-背景颜色" class="headerlink" title="1 背景颜色"></a>1 背景颜色</h2><p><code>background-color</code> 属性定义了元素的背景颜色。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background-color</span>: 颜色值;</span><br></pre></td></tr></table></figure><p>一般情况下元素背景颜色默认值是 <code>transparent</code>（透明），我们也可以手动指定背景颜色为透明色。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background-color</span>: transparent;</span><br></pre></td></tr></table></figure><p>目前 CSS 还支持丰富的渐变色，但是某些浏览器不支持，这里了解即可，具体内容请查阅资料。</p><style>    #grad1 {        height: 200px;        /* 浏览器不支持时显示 */        background-color: red;        /* 线性渐变 - 从上到下（默认情况下）*/        background-image: linear-gradient(#e66465, #9198e5);    }</style><h2 id="2-背景图片"><a href="#2-背景图片" class="headerlink" title="2 背景图片"></a>2 背景图片</h2><p><code>background-image</code> 属性描述了元素的背景图像，实际开发常用于 <strong>logo</strong> 或者一些<strong>装饰性的小图片</strong>或者是<strong>超大的背景图片</strong>, 优点是非常便于控制位置（精灵图也是一种运用场景）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background-image</span> : none | <span class="built_in">url</span>(<span class="string">地址</span>)</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数值</th><th>作用</th></tr></thead><tbody><tr><td><code>none</code></td><td>无背景图（默认的）</td></tr><tr><td><code>url</code></td><td>使用绝对或相对地址指定背景图像</td></tr></tbody></table><p>注意：背景图片后面的地址，千万不要忘记加 URL， 同时里面的路径不要加引号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">background-color: pink;</span><br><span class="line">background-image: url(../images/logo.png);</span><br><span class="line">/* 1、背景图片不平铺 */</span><br><span class="line">/* background-repeat: no-repeat; */</span><br><span class="line">/* 2、默认情况下，背景图片是平铺的 */</span><br><span class="line">/* background-repeat: repeat; */ </span><br><span class="line">/* 页面元素既可以添加背景颜色也可以添加背景图片，只不过背景图片区域会覆盖背景颜色 */</span><br></pre></td></tr></table></figure><h2 id="3-背景平铺"><a href="#3-背景平铺" class="headerlink" title="3 背景平铺"></a>3 背景平铺</h2><p>如果需要在 HTML 页面上对背景图像进行平铺，可以使用 <code>background-repeat</code> 属性。</p><p>注：平铺可以简单的理解为“重复”。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background-repeat</span>: repeat | no-repeat | repeat-x | repeat-y</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数值</th><th>作用</th></tr></thead><tbody><tr><td><code>repeat</code></td><td>背景图像在纵向和横向上平铺（默认的）</td></tr><tr><td><code>no-repeat</code></td><td>背景图像不平铺</td></tr><tr><td><code>repeat-x</code></td><td>背景图像在横向上平铺</td></tr><tr><td><code>repeat-y</code></td><td>背景图像在纵向上平铺</td></tr></tbody></table><h2 id="4-背景图片位置"><a href="#4-背景图片位置" class="headerlink" title="4 背景图片位置"></a>4 背景图片位置</h2><p>利用 <code>background-position</code> 属性可以改变图片在背景中的位置。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background-position</span>: x y;</span><br></pre></td></tr></table></figure><p>参数代表的意思是：x 坐标 和 y 坐标，可以使用 <code>方位名词</code> 或者 <code>精确单位</code>。</p><table><thead><tr><th>参数值</th><th>说明</th></tr></thead><tbody><tr><td><code>length</code></td><td>百分数 | 由浮点数字和单位标识符组成的长度值</td></tr><tr><td><code>position</code></td><td>top | center | bottom | left | rigth 方位名词</td></tr></tbody></table><ul><li><p>参数是方位名词</p><ul><li>如果指定的两个值都是方位名词，则两个值前后顺序无关，比如 left top 和 top left 效果一致</li><li>如果只指定了一个方位名词，另一个值省略，则<strong>第二个值默认居中对齐</strong></li></ul></li><li><p>参数是精确单位</p><ul><li>如果参数值是精确坐标，那么第一个肯定是 x 坐标，第二个一定是 y 坐标</li><li>如果只指定一个数值，那该数值一定是 x 坐标，<strong>另一个默认垂直居中</strong></li></ul></li><li><p>参数是混合单位</p><ul><li>如果指定的两个值是精确单位和方位名词混合使用，则第一个值是 x 坐标，第二个值是 y 坐标</li></ul></li></ul><h2 id="5-背景图像固定（背景附着）"><a href="#5-背景图像固定（背景附着）" class="headerlink" title="5 背景图像固定（背景附着）"></a>5 背景图像固定（背景附着）</h2><p><code>background-attachment</code> 属性设置背景图像是否固定或者随着页面的其余部分滚动。</p><p><code>background-attachment</code> 后期可以制作 <code>视差滚动</code> 的效果。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background-attachment</span> : scroll | fixed</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td><code>scroll</code></td><td>背景图像是随对象内容滚动的（可见区域取决于背景图像的高度）</td></tr><tr><td><code>fixed</code></td><td>背景图像固定</td></tr></tbody></table><h2 id="6-背景复合写法"><a href="#6-背景复合写法" class="headerlink" title="6 背景复合写法"></a>6 背景复合写法</h2><p>为了简化背景属性的代码，我们可以将这些属性合并简写在同一个属性 <code>background</code> 中，从而节约代码量。</p><p>当使用简写属性时，没有特定的书写顺序，一般习惯约定顺序为：</p><p><code>background</code>: <code>背景颜色</code> <code>背景图片地址</code> <code>背景平铺</code> <code>背景图像滚动</code> <code>背景图片位置</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background</span>: transparent <span class="built_in">url</span>(<span class="string">image.jpg</span>) no-repeat fixed top;</span><br></pre></td></tr></table></figure><p>这是实际开发中，我们更提倡的写法。</p><h2 id="7-背景色半透明"><a href="#7-背景色半透明" class="headerlink" title="7 背景色半透明"></a>7 背景色半透明</h2><p>CSS3 为我们提供了背景颜色半透明的效果。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.3</span>);</span><br></pre></td></tr></table></figure><ul><li>最后一个参数是 <code>alpha</code> 透明度，取值范围在 <code>0~1</code> 之间</li><li>习惯把 0.3 的 0 省略掉，写为 <code>background: rgba(0, 0, 0, .3);</code></li><li>注意：背景半透明是指盒子背景半透明，盒子里面的内容不受影响</li><li>CSS3 新增属性，是 IE9+ 版本浏览器才支持的</li><li>但是现在实际开发，我们不太关注兼容性写法了，可以放心使用</li></ul><h2 id="8-背景总结"><a href="#8-背景总结" class="headerlink" title="8 背景总结"></a>8 背景总结</h2><table><thead><tr><th>属性</th><th>作用</th><th>值</th></tr></thead><tbody><tr><td><code>backgroud-color</code></td><td>背景颜色</td><td>预定义的颜色值 &#x2F; 十六进制 &#x2F; RGB代码</td></tr><tr><td><code>backgroud-image</code></td><td>背景图片</td><td>url（图片路径）</td></tr><tr><td><code>backgroud-repeat</code></td><td>是否平铺</td><td>repeat &#x2F; no-repeat &#x2F; repeat-x &#x2F; repeat-y</td></tr><tr><td><code>backgroud-position</code></td><td>背景位置</td><td>length &#x2F; position 分别是 x 和 y 坐标</td></tr><tr><td><code>backgroud-attachment</code></td><td>背景附着</td><td>scroll（背景滚动）&#x2F; fixed（背景固定）</td></tr><tr><td><code>背景简写</code></td><td>书写更简单</td><td>背景颜色 背景图片地址 背景平铺 背景滚动 背景位置</td></tr><tr><td><code>背景色半透明</code></td><td>背景颜色半透明</td><td>background: rgba(0, 0, 0, 0.3); 后面必须是4个值</td></tr></tbody></table><p>背景图片：实际开发常见于 logo 或者一些装饰性的小图片或者是超大的背景图片，优点是非常便于控制位置（精灵图也是一种运用场景）。</p><h1 id="四、精灵图"><a href="#四、精灵图" class="headerlink" title="四、精灵图"></a>四、精灵图</h1><h2 id="1-原理"><a href="#1-原理" class="headerlink" title="1 原理"></a>1 原理</h2><p><strong>为了有效地减少服务器接收和发送请求的次数</strong>，<strong>提高</strong>页面的<strong>加载速度</strong>，出现了 <strong>CSS 精灵技术</strong>（也称 CSS Sprites、CSS 雪碧）。将网页中的一些小背景图像整合到一张大图中 ，这样服务器只需要一次请求就可以了</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230325184245.png"></p><h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2 使用"></a>2 使用</h2><p>使用精灵图核心：</p><ol><li>精灵技术主要针对于背景图片使用。就是把多个小背景图片整合到一张大图片中。</li><li>这个大图片也称为 sprites  精灵图  或者 雪碧图</li><li>移动背景图片位置， 此时可以使用 background-position 。</li><li>移动的距离就是这个目标图片的 x 和 y 坐标。注意网页中的坐标有所不同</li><li>因为一般情况下都是往上往左移动，所以数值是负值。</li><li>使用精灵图的时候需要精确测量，每个小背景图片的大小和位置。</li></ol><p>使用精灵图核心总结：</p><ol><li><p>精灵图主要<strong>针对于小的背景图片</strong>使用。</p></li><li><p>主要借助于背景位置来实现—<strong>background-position</strong> 。</p></li><li><p>一般情况下精灵图都是<strong>负值</strong>。（千万注意网页中的坐标： x轴右边走是正值，左边走是负值， y轴同理。）</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS选择器</title>
      <link href="/2023/03/11/CSS.1/"/>
      <url>/2023/03/11/CSS.1/</url>
      
        <content type="html"><![CDATA[<h1 id="一、CSS基础选择器"><a href="#一、CSS基础选择器" class="headerlink" title="一、CSS基础选择器"></a>一、CSS基础选择器</h1><h2 id="1-CSS选择器的作用"><a href="#1-CSS选择器的作用" class="headerlink" title="1 CSS选择器的作用"></a>1 CSS选择器的作用</h2><p>选择器就是根据不同的需求把不同的标签选出来，这就是选择器的作用，简单来说，就是：选择标签用的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">25px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上 CSS 做了两件事：</p><ul><li>找到所有的 h1 标签。（选对人）</li><li>设置这些标签的样式：颜色为红色、字体大小为 25 像素。（做对事）</li></ul><h2 id="2-选择器的分类"><a href="#2-选择器的分类" class="headerlink" title="2 选择器的分类"></a>2 选择器的分类</h2><p>选择器分为 <code>基础选择器</code> 和 <code>复合选择器</code> 两个大类，本文首先介绍一下基础选择器。</p><ul><li>基础选择器是由 <code>单个</code> 选择器组成的</li><li>基础选择器又包括：<code>标签选择器</code>、<code>类选择器</code>、<code>id 选择器</code>、<code>通配符选择器</code></li></ul><h2 id="3-标签选择器"><a href="#3-标签选择器" class="headerlink" title="3 标签选择器"></a>3 标签选择器</h2><p><code>标签选择器</code>（元素选择器）是指用 HTML 标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的 CSS 样式。</p><p><strong>语法：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">标签名 &#123;</span><br><span class="line">    属性<span class="number">1</span>: 属性值<span class="number">1</span>;</span><br><span class="line">    属性<span class="number">2</span>: 属性值<span class="number">2</span>;</span><br><span class="line">    属性<span class="number">3</span>: 属性值<span class="number">3</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>除了最后一个属性，其余属性后面跟 ; </p></blockquote><p><strong>作用：</strong>标签选择器可以把某一类标签全部选择出来，比如所有的 <code>&lt;div&gt;</code> 标签和所有的 <code>&lt;span&gt;</code> 标签。</p><p><strong>优点：</strong>能快速为页面中同类型的标签统一设置样式。</p><p><strong>缺点：</strong>不能设计差异化样式，只能选择全部的当前标签。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 会对所有的该标签元素运用样式，优点：快速统一，缺点：无法差异化设置 */</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: green;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: pink;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>男<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>男<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>女生<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>女生<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-类选择器"><a href="#4-类选择器" class="headerlink" title="4 类选择器"></a>4 类选择器</h2><p>如果想要差异化选择不同的标签，单独选一个或者某几个标签，可以使用 <code>类选择器</code>。</p><p><strong>CSS 语法：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.类名 &#123;</span><br><span class="line">    属性<span class="number">1</span>: 属性值<span class="number">1</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如：将所有拥有 red 类的 HTML 元素均设置为红色。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.red</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#EE0000</span>;</span><br><span class="line">&#125;</span><br><span class="line">···</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;red&quot;&gt;变红色&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure><blockquote><p>类选择器在 HTML 中以 class 属性表示，在 CSS 中，类选择器以一个 <code>.</code> 号显示。</p></blockquote><p><strong>注意：</strong></p><ul><li>类选择器使用 <code>.</code>（英文点号）进行标识，后面紧跟类名</li><li>类名可以由数字、字母、下划线、中划线组成，但不能以数字或者中划线开头</li><li>一个标签可以同时有多个类名，类名之间以空格隔开</li><li>类名可以重复，一个类选择器可以同时选中多个标签</li><li>所有标签上都有class属性，class属性的属性值称为类名（类似于名字）</li></ul><blockquote><p>类名重复，不报错，但后面的覆盖前面的同名内容的效果</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.red</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.green</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: green;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;red&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;green&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;red&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>类选择器——多类名</strong></p><p>我们可以给一个标签指定多个类名，从而达到更多的选择目的，这些类名都可以选出这个标签，简单理解就是一个标签有多个名字。</p><ul><li>在标签 class 属性中写多个类名</li><li>多个类名中间必须用 <code>空格</code> 分开</li><li>这个标签就可以分别具有这些类名的样式</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 一个标签可以运用多个类选择器，之间用空格隔开 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.red</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.font35</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">font-size</span>: <span class="number">35px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">···</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;red font35&quot;</span>&gt;</span>zhoujirui<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>多类名开发中使用场景</strong></p><ul><li>可以把一些标签元素相同的样式（共同的部分）放到一个类里面</li><li>这些标签都可以调用这个公共的类，然后再调用自己独有的类</li><li>从而节省 CSS 代码，统一修改也非常方便（<strong>模块化、可重用化</strong>）</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 类选择器最大的优势在于：复用 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.red</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.green</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: green;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">···</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box red&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box green&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box red&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>多类名选择器在后期布局比较复杂的情况下，是使用得较多的。</p><h2 id="5-id选择器"><a href="#5-id选择器" class="headerlink" title="5 id选择器"></a>5 id选择器</h2><p>id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。</p><p>HTML 元素以 id 属性来设置 id 选择器，CSS 中 id 选择器以 <code>#</code> 来定义。 </p><p><strong>语法：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#id</span>名 &#123;</span><br><span class="line">    属性<span class="number">1</span>: 属性值<span class="number">1</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例如：</strong>将 id 为 nav 元素中的内容设置为红色。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#nav</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ee0000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>id 属性不能重复命名，在一个 html 中一个 id 只能定义一次，也只能使用一次（ id 是配合 js 使用的，一个 id 只能使用一次）</p><p>测试如下，目前尚未报错，添加 js 可能出问题</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    <span class="selector-id">#red</span>&#123;</span><br><span class="line">        <span class="attribute">color</span>: <span class="number">#ee0000</span>;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">100px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">···</span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> id=&quot;red&quot;&gt;测试内容&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">p</span> id=&quot;red&quot;&gt;测试内容&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> id=&quot;red&quot;&gt;测试内容&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">body</span>&gt;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230311163806.png"></p><p><strong>id 选择器和类选择器的区别：</strong></p><ul><li>类选择器 (class) 好比人的名字，一个人可以有多个名字，同时一个名字也可以被多个人使用</li><li>id 选择器好比人的身份证号码，全中国是唯一的，不可重复（同一个 id 选择器只能调用一次）</li><li>id 选择器和类选择器最大的不同在于使用次数上</li><li>类选择器在修改样式中用的最多，id 选择器一般用于页面唯一性的元素上，经常和 JavaScript 搭配使用</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#pink</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>: pink;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">···</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;pink&quot;</span>&gt;</span>zhoujirui<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再次强调：<strong>同一 id 只能定义一次，同一 id 选择器也只能调用一次！</strong>（对于 CSS 修改样式来说，最好使用类选择器，id 选择器主要与后面的 JS 搭配使用）。</p><h2 id="6-通配符选择器"><a href="#6-通配符选择器" class="headerlink" title="6 通配符选择器"></a>6 通配符选择器</h2><p>在 CSS 中，通配符选择器使用 <code>*</code> 定义，它表示选取页面中<strong>所有元素</strong>（标签）。</p><p><strong>语法：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    属性<span class="number">1</span>: 属性值<span class="number">1</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通配符选择器不需要调用，自动就给所有的元素使用样式</li><li>特殊情况才使用，后面讲解使用场景</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"># 去除各标签的默认间距，网页一般都有</span><br></pre></td></tr></table></figure><h2 id="7-基础选择器总结"><a href="#7-基础选择器总结" class="headerlink" title="7 基础选择器总结"></a>7 基础选择器总结</h2><table><thead><tr><th>基础选择器</th><th>作用</th><th>特点</th><th>使用情况</th><th>用法</th></tr></thead><tbody><tr><td>标签选择器</td><td>可以选出所有相同的标签，比如：p</td><td>不能差异化选择</td><td>较多</td><td><code>p &#123;color: red;&#125;</code></td></tr><tr><td>类选择器</td><td>可以选出 1 个或者 多个 标签</td><td>可以根据需求选择</td><td>非常多</td><td><code>.nav &#123;color: red;&#125;</code></td></tr><tr><td>id 选择器</td><td>一次只能选择 1 个标签</td><td>ID 属性只能在每个 HTML 文档中出现一次，也只能调用一次</td><td>一般和 js 搭配</td><td><code>#nav &#123;color: red;&#125;</code></td></tr><tr><td>通配符选择器</td><td>选择所有的标签</td><td>选择的太多，有部分不需要</td><td>特殊情况使用</td><td><code>* &#123;color: red;&#125;</code></td></tr></tbody></table><ul><li>每个基础选择器都有使用场景，都需要掌握</li><li>如果是修改样式，类选择器是使用最多的</li></ul><h1 id="二、css的复合选择器"><a href="#二、css的复合选择器" class="headerlink" title="二、css的复合选择器"></a>二、css的复合选择器</h1><h2 id="1-什么是复合选择器？"><a href="#1-什么是复合选择器？" class="headerlink" title="1 什么是复合选择器？"></a>1 什么是复合选择器？</h2><p> 在 CSS 中，可以根据选择器的类型把选择器分为<strong>基础选择器</strong>和<strong>复合选择器</strong>，复合选择器是建立在基础选择器之上，对基本选择器进行组合形成的。<br>​ 复合选择器是由两个或多个基础选择器，通过不同的方式组合而成的，可以更准确、更高效的选择目标元素（标签）<br>​ 常用的复合选择器包括：<strong>后代选择器、子选择器、并集选择器、伪类选择器</strong>等等</p><h2 id="2-后代选择器-重要）"><a href="#2-后代选择器-重要）" class="headerlink" title="2 后代选择器 (重要）"></a>2 后代选择器 (重要）</h2><p><strong>定义：</strong></p><p> 后代选择器又称为包含选择器，可以选择父元素里面子元素。其写法就是把外层标签写在前面，内层标签写在后面，中间用空格分隔。当标签发生嵌套时，内层标签就成为外层标签的后代。</p><p>语法： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* 元素 元素 &#123; 具体要求 &#125; */</span><br><span class="line">ul li &#123; 样式声明 &#125;      /* 选择 ul 里面所有的 li 标签元素 */</span><br></pre></td></tr></table></figure><p>上述语法表示选择 元素 1 里面的<strong>所有</strong>元素 2 （后代元素）</p><p>语法说明：</p><ul><li>元素1 和 元素2 中间用空格隔开</li><li>元素1 是父级，元素2 是子级，最终选择的是元素2</li><li>元素2 可以是儿子，也可以是孙子等，只要是元素1 的后代即可</li><li>元素1 和 元素2 可以是任意基础选择器</li></ul><h2 id="3-子选择器"><a href="#3-子选择器" class="headerlink" title="3 子选择器"></a>3 子选择器</h2><p>子元素选择器（子选择器）只能选择作为某元素的<strong>最近一级子元素</strong>，简单理解就是选<strong>儿子辈元素</strong></p><p>注意：是<strong>最近一级而并非最近一个</strong>！</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">元素<span class="number">1</span>&gt;元素<span class="number">2</span> &#123; 样式声明 &#125;</span><br><span class="line"><span class="selector-tag">div</span>&gt;<span class="selector-tag">p</span> &#123; 样式声明 &#125;     <span class="comment">/* 选择 div 里面所有最近一级 p 标签元素 */</span></span><br></pre></td></tr></table></figure><blockquote><p>上述语法表示选择元素1 里面的所有直接后代（子元素）元素2。</p></blockquote><p>语法说明：</p><ul><li>元素1 和 元素2 中间用  <strong>&gt;</strong>  隔开</li><li>元素1 是父级，元素2 是子级，最终选择的是元素2，即元素1 是不会生效样式的</li><li>元素2 <strong>必须是儿子辈，其孙子辈之类都不归他管</strong></li></ul><h2 id="4-并集选择器"><a href="#4-并集选择器" class="headerlink" title="4 并集选择器"></a>4 并集选择器</h2><p><code>并集选择器</code> 可以选择多组标签，同时为他们定义相同的样式，通常用于<strong>集体声明</strong>。 <code>并集选择器</code> 是各选择器通过<strong>英文逗号</strong> <code>,</code> 连接而成，任何形式的选择器都可以作为并集选择器的一部分。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">元素<span class="number">1</span>,</span><br><span class="line">元素<span class="number">2</span>,</span><br><span class="line">元素<span class="number">3</span> &#123;</span><br><span class="line">    样式声明</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 规范编码风格 */</span></span><br></pre></td></tr></table></figure><blockquote><p> 上述语法表示选择元素1、元素2 和 元素3。</p></blockquote><p>语法说明：</p><ul><li>元素1 和 元素2 中间用逗号隔开（最后一个不加逗号）</li><li>逗号可以理解为和的意思</li><li>并集选择器通常用于集体声明</li></ul><h2 id="5-伪类选择器"><a href="#5-伪类选择器" class="headerlink" title="5 伪类选择器"></a>5 伪类选择器</h2><p><code>伪类选择器</code> 用于<strong>向某些选择器添加特殊的效果</strong>，比如：给链接添加特殊效果（链接伪类），或选择第 n 个元素（结构伪类）。 <code>伪类选择器</code> 书写最大的特点是用<strong>冒号</strong> <code>:</code> 表示</p><p>比如：<code>:hover</code>、<code>:first-child</code>。 </p><p>因为伪类选择器很多，比如：<code>链接伪类</code>、<code>结构伪类</code> 等，所以这里先讲解常用的链接伪类选择器。</p><blockquote><p>伪类的由来：因为在页面中并没有这个真实存在的类，所以称为 “伪类”。</p></blockquote><h2 id="6-链接伪类选择器"><a href="#6-链接伪类选择器" class="headerlink" title="6 链接伪类选择器"></a>6 链接伪类选择器</h2><p><strong>链接伪类选择器注意事项：</strong></p><ul><li><p>为了确保生效且不冲突，请按照 <code>LVHA</code> 的顺序声明 <code>:link</code> <code>:visited</code> <code>:hover</code> <code>:active</code></p></li><li><p>因为 a 链接在浏览器中具有默认样式，所以我们实际工作中都需要给链接单独指定样式</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/* a 是标签选择器（所有的链接）*/</span><br><span class="line">a &#123;</span><br><span class="line">color: gray;</span><br><span class="line">&#125;</span><br><span class="line">a:link &#123;</span><br><span class="line">color: #333;</span><br><span class="line">text-decoration: none;</span><br><span class="line">&#125;</span><br><span class="line">/* 2、a:visited 选择点击过的（访问过的）链接选出来 */</span><br><span class="line">a:visited &#123;</span><br><span class="line">color: orange;</span><br><span class="line">&#125;</span><br><span class="line">/* 3、a:hover 选择鼠标经过（停留）的那个链接 */</span><br><span class="line">a:hover &#123;</span><br><span class="line">color: skyblue;</span><br><span class="line">&#125;</span><br><span class="line">/* 4、a:active 选择的是我们鼠标正在按下还没有弹起鼠标的那个链接 */</span><br><span class="line">a:active &#123;</span><br><span class="line">color: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-focus-伪类选择器"><a href="#7-focus-伪类选择器" class="headerlink" title="7 :focus 伪类选择器"></a>7 :focus 伪类选择器</h2><p><strong>定义：</strong>focus 伪类选择器用于选取获得焦点的表单元素。</p><blockquote><p>焦点就是光标，一般情况 &lt; input&gt; 类表单元素才能获取，因此这个选择器也主要针对于表单元素来说。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input:focus &#123;</span><br><span class="line">background-color: pink;</span><br><span class="line">color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20210405202554834.gif"></p><h2 id="8-复合选择器总结"><a href="#8-复合选择器总结" class="headerlink" title="8 复合选择器总结"></a>8 复合选择器总结</h2><table><thead><tr><th>选择器</th><th>作用</th><th>特征</th><th>使用情况</th><th>隔开符号及用法</th></tr></thead><tbody><tr><td>后代选择器</td><td>用来选择后代元素</td><td>可以是子孙后代</td><td>较多</td><td>符号是空格 <code>.nav a</code></td></tr><tr><td>子代选择器</td><td>选择最近一级元素</td><td>只选亲儿子</td><td>较少</td><td>符号是大于 <code>.nav&gt;p</code></td></tr><tr><td>并集选择器</td><td>选择某些相同样式的元素</td><td>可以用于集体声明</td><td>较多</td><td>符号是逗号 <code>.nav, .header</code></td></tr><tr><td>链接伪类选择器</td><td>选择不同状态的链接</td><td>跟链接相关</td><td>较多</td><td>重点记住 <code>a&#123;&#125;</code> 和 <code>a:hover</code> 实际开发的写法</td></tr><tr><td><code>:focus</code> 选择器</td><td>选择获得光标的表单</td><td>跟表单相关</td><td>较少</td><td><code>input:focus</code> 记住这个写法</td></tr></tbody></table><blockquote><p>强调：复合选择器的层级写得越细越好（可读性，可维护性，安全性），同时将复合选择器的层级写得越细，可以提前避免大部分的选择器优先级混乱！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5 基础认知</title>
      <link href="/2023/02/26/HTML5.1/"/>
      <url>/2023/02/26/HTML5.1/</url>
      
        <content type="html"><![CDATA[<h1 id="一、HTML简介"><a href="#一、HTML简介" class="headerlink" title="一、HTML简介"></a>一、HTML简介</h1><h2 id="1-网页"><a href="#1-网页" class="headerlink" title="1 网页"></a>1 网页</h2><h3 id="1-1-什么是网页？"><a href="#1-1-什么是网页？" class="headerlink" title="1.1 什么是网页？"></a>1.1 什么是网页？</h3><p><strong>网页：</strong>构成网站的基本元素，通常是 HTML 格式的文件（.htm 或 .html）必须通过浏览器来阅读</p><p><strong>网站：</strong>利用前端技术制作的网页集合</p><h3 id="1-2-什么是HTML"><a href="#1-2-什么是HTML" class="headerlink" title="1.2 什么是HTML?"></a>1.2 什么是HTML?</h3><p><strong>超文本：</strong>由图片、声音、动画、视频等构成且可以相互链接的文本</p><p><strong>HTML：</strong>超文本标记语言（HTML 不是编程语言，而是由一套标记标签构成的标记语言）</p><h3 id="1-3-网页的形成"><a href="#1-3-网页的形成" class="headerlink" title="1.3 网页的形成"></a>1.3 网页的形成</h3><p>前端代码开发 ——&gt; 浏览器解析、渲染代码 ——&gt; 呈现 Web 页面</p><h2 id="2-浏览器"><a href="#2-浏览器" class="headerlink" title="2 浏览器"></a>2 浏览器</h2><h3 id="2-1-常用浏览器"><a href="#2-1-常用浏览器" class="headerlink" title="2.1 常用浏览器"></a>2.1 常用浏览器</h3><p><strong>PC 端五大浏览器：</strong><code>Edge</code>、<code>Chrome</code>、<code>Firefox</code>、<code>Safari</code>、<code>Opera</code></p><h3 id="2-2-浏览器内核"><a href="#2-2-浏览器内核" class="headerlink" title="2.2 浏览器内核"></a>2.2 浏览器内核</h3><p><strong>四大浏览器内核：</strong>IE（<code>Trident</code>）、Firefox（<code>Gecko</code>）、Safari（<code>Webkit</code>）、Chrome &#x2F; Opera &#x2F; Edge（<code>Blink</code> 属于 Webkit 的分支，Blink 兼容 Webkit）</p><blockquote><p>注：目前国内浏览器一般都采用 Webkit &#x2F; Blink 内核</p></blockquote><h2 id="3-Web标准"><a href="#3-Web标准" class="headerlink" title="3 Web标准"></a>3 Web标准</h2><p><strong>W3C：</strong><code>万维网联盟</code>，国际最著名的标准化组织之一</p><p><strong>Web 标准：</strong>W3C 组织和其他标准化组织为 Web 开发制定的一系列标准的集合</p><h3 id="3-1-为什么需要Web标准？"><a href="#3-1-为什么需要Web标准？" class="headerlink" title="3.1 为什么需要Web标准？"></a>3.1 为什么需要Web标准？</h3><p>浏览器不同，解析渲染显示的页面效果就有些许差异，通过 Web 标准可以统一浏览器解析显示效果，同时大大减少开发者的工作量（一套代码，多种浏览器平台兼容运行）</p><p>遵循 Web 标准除了可以让不同的开发人员写出的页面更标准、更统一外，还有以下优点：</p><ul><li><p>让 Web 开发前景更广阔</p></li><li><p>网页能被更广泛的设备访问</p></li><li><p>更容易被搜索引擎搜索（排名靠前）</p></li><li><p>降低网站的流量费用</p></li><li><p>使网站更易于维护</p></li><li><p>提高页面的加载速度</p></li></ul><h3 id="3-2-Web标准的构成"><a href="#3-2-Web标准的构成" class="headerlink" title="3.2 Web标准的构成"></a>3.2 Web标准的构成</h3><p><strong>主要包括三个方面：</strong><code>结构</code>、<code>表现</code>、<code>行为</code></p><ul><li><strong>结构：</strong>用于对网页元素进行整理和分类，主要指 <code>HTML</code></li><li><strong>表现：</strong>用于设置网页元素的版式、大小、颜色等外观样式，主要指 <code>CSS</code></li><li><strong>行为：</strong>网页模型的定义及交互方式的编写，主要指 <code>JavaScript</code></li></ul><p><strong>Web 标准提出的最佳体验方案：</strong><code>结构</code>、<code>样式</code>、<code>行为</code> 相互分离</p><ul><li><strong>简单的理解：</strong>结构写到 <code>.html</code> 文件中、表现写到 <code>.css</code> 文件中、行为写到 <code>.js</code> 文件中</li><li><strong>一句话解释：</strong>结构类似身体、表现类似衣服、行为类似动作（结构是一切的基础）</li></ul><h1 id="二、HTML骨架"><a href="#二、HTML骨架" class="headerlink" title="二、HTML骨架"></a>二、HTML骨架</h1><p>网页类似于一篇文章：</p><ul><li><p>每一页文章内容是有固定的结构的，如：开头、正文、落款等……</p></li><li><p>网页中也是存在固定的结构的，如：整体、头部、标题、主体</p></li><li><p>网页中的固定结构是要通过特点的 <strong>HTML标签</strong> 进行描述的</p></li></ul><p>HTML骨架：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>标签名</th><th>定义</th><th>说明</th></tr></thead><tbody><tr><td><code>&lt;html&gt;</code> <code>&lt;/html&gt;</code></td><td>根标签</td><td>页面中最大的标签（最基础的标签）</td></tr><tr><td><code>&lt;head&gt;</code> <code>&lt;/head&gt;</code></td><td>头部标签</td><td>在 head 标签中我们必须要设置 title 标签</td></tr><tr><td><code>&lt;title&gt;</code> <code>&lt;/title&gt;</code></td><td>标题标签</td><td>页面自己的网页标题</td></tr><tr><td><code>&lt;body&gt;</code> <code>&lt;/body&gt;</code></td><td>主体标签</td><td>包含文档的所有内容</td></tr></tbody></table><h2 id="1-文档类型声明标签"><a href="#1-文档类型声明标签" class="headerlink" title="1 文档类型声明标签"></a>1 文档类型声明标签</h2><p><code>&lt;!doctype&gt;</code> 文档类型声明，作用是告诉浏览器应该使用哪种 HTML 版本来解析渲染网页。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 当前页面采用 HTML5 版本 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><code>&lt;!doctype&gt;</code> 声明位于文档最前面的位置，处于 &lt;html&gt; 标签之前</li><li><code>&lt;!doctype&gt;</code> 文档类型声明标签，不属于 HTML 标签</li><li>请默认统一指定 HTML5 版本 <code>&lt;!doctype html&gt;</code></li></ul><h2 id="2-lang语言种类"><a href="#2-lang语言种类" class="headerlink" title="2 lang语言种类"></a>2 lang语言种类</h2><p>用来定义当前网页显示的主语言，书写在 <code>&lt;html&gt;</code> 标签内。</p><ul><li><code>en</code> 定义语言为英语</li><li><code>zh</code> 定义语言为中文</li></ul><p>简单来说：定义为 <code>en</code> 就是面向英文用户的网页，定义为 <code>zh</code> 就是面向中国大陆用户的网页。</p><blockquote><p><code>en-GB</code> 英文（英国）</p><p><code>en-US</code> 英文（美国）</p><p><code>zh-CN</code> 中文（简体，中国大陆）</p><p><code>zh-SG</code> 中文（简体，新加坡）</p><p><code>zh-HK</code> 中文（繁体，香港）</p><p><code>zh-MO</code> 中文（繁体，澳门）</p><p><code>zh-TW</code> 中文（繁体，台湾）</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>语言的设置是为了方便 <code>浏览器搜索推荐</code> 以及触发 <code>浏览器翻译功能</code>，并不是说设置了某类主语言后网页中就不能存在其他类型的语言了。</p></blockquote><h3 id="3-字符集"><a href="#3-字符集" class="headerlink" title="3 字符集"></a>3 字符集</h3><p><strong>字符集：</strong>多个字符的集合，以便计算机能够识别和储存各种文字。</p><p>在 <code>&lt;head&gt;</code> 标签内，可以通过 <code>&lt;meta&gt;</code> 标签的 <code>charset</code> 属性来规定 HTML 文档应该使用哪种字符编码。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>charset</code> 常用的值有：<code>GB2312</code>、<code>BIG5</code>、<code>GBK</code>、<code>UTF-8</code>，其中 <code>UTF-8</code> 也被称为：万国码，基本包含了全世界所有国家需要用到的字符。</p><p><strong>注意：</strong>字符设置是必须的，否则极大可能引起网页乱码。一般情况下，统一使用 “UTF-8” 编码，尽量统一写成标准的 <code>UTF-8</code>，不要写成 “utf8” 或 “UTF8”。</p><p><strong>标准骨架：</strong></p><p>空白情况下打<strong>英文 ！</strong> ，然后tab直接生成骨架</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="三、HTML基础标签"><a href="#三、HTML基础标签" class="headerlink" title="三、HTML基础标签"></a>三、HTML基础标签</h1><h2 id="1-标签结构"><a href="#1-标签结构" class="headerlink" title="1 标签结构"></a>1 标签结构</h2><p>HTML 标签是由<strong>尖括号</strong>包围的关键字词，例如：<code>&lt;html&gt;</code>。</p><p>结构说明：</p><ol><li><p>标签由&lt;、&gt;、&#x2F;、英文单词或字母组成。并且把标签中&lt;&gt;包括起来的英文单词或字母称为<strong>标签名</strong></p></li><li><p>常见标签由两部分组成，我们称之为：<strong>双标签</strong>。前部分叫<strong>开始标签</strong>，后部分叫<strong>结束标签</strong>，两部分之间包裹内容</p></li></ol><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230307161001.png"></p><ol start="3"><li>少数标签由一部分组成，我们称之为：<strong>单标签</strong>。自成一体，无法包裹内容。</li></ol><blockquote><p>标签打中间的<strong>英文</strong>然后按<strong>tab</strong>即可直接生成对应标签</p></blockquote><blockquote><p>根据需要划分，截取段落类标签一般是双标签，截断类标签一般是单标签</p></blockquote><blockquote><p>HTML5 规范中明确说明单标签 <code>/</code> 是可以忽略的，<strong>目前的实际开发中习惯不给单标签添加斜线</strong>。</p></blockquote><h2 id="2-标签关系"><a href="#2-标签关系" class="headerlink" title="2 标签关系"></a>2 标签关系</h2><ol><li>包含关系</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>并列关系</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-注释"><a href="#3-注释" class="headerlink" title="3 注释"></a>3 注释</h2><p>HTML 中的注释以：<code>&lt;!--</code> 开头，以 <code>--&gt;</code> 结束。</p><p>在VS Code中注释的快捷键：ctrl + &#x2F;</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注释语句 --&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-特殊字符"><a href="#4-特殊字符" class="headerlink" title="4 特殊字符"></a>4 特殊字符</h2><p>在 HTML 页面中，一些特殊的符号很难或者不方便直接使用，此时我们就可以使用下面的字符来替代。</p><table><thead><tr><th align="left">特殊字符</th><th align="left">描述</th><th align="left">字符的代码</th></tr></thead><tbody><tr><td align="left"><code> </code></td><td align="left">空格符</td><td align="left"><code>&amp;nbsp;</code></td></tr><tr><td align="left"><code>&lt;</code></td><td align="left">小于号</td><td align="left"><code>&amp;lt;</code></td></tr><tr><td align="left"><code>&gt;</code></td><td align="left">大于号</td><td align="left"><code>&amp;gt;</code></td></tr><tr><td align="left"><code>&amp;</code></td><td align="left">和号</td><td align="left"><code>&amp;amp;</code></td></tr><tr><td align="left"><code>±</code></td><td align="left">正负号</td><td align="left"><code>&amp;plusmn;</code></td></tr><tr><td align="left"><code>×</code></td><td align="left">乘号</td><td align="left"><code>&amp;times;</code></td></tr><tr><td align="left"><code>÷</code></td><td align="left">除号</td><td align="left"><code>&amp;divide;</code></td></tr><tr><td align="left"><code>²</code></td><td align="left">上标</td><td align="left"><code>&amp;sup;</code></td></tr><tr><td align="left"><code>²</code></td><td align="left">下标</td><td align="left"><code>&amp;sub;</code></td></tr></tbody></table><blockquote><p>其余符号若有需要请百度</p></blockquote><h2 id="5-排版标签"><a href="#5-排版标签" class="headerlink" title="5 排版标签"></a>5 排版标签</h2><h3 id="5-1-标题标签"><a href="#5-1-标题标签" class="headerlink" title="5.1 标题标签"></a>5.1 标题标签</h3><p>HTML 提供了 6 个等级的网页标题，即：<code>&lt;h1&gt;</code> 到 <code>&lt;h6&gt;</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>一级标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>二级标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>三级标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>四级标题<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>五级标题<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>六级标题<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>标签语义：</strong>作为标题使用，并且依据重要性递减。</p><p><strong>特点：</strong></p><ul><li>加了标题的文字会自动加粗，字号也会依次变大</li><li>一个标题就独占一行，同一行标题后不会再放置其他任何内容（后期可以通过 CSS 修改）</li></ul><h3 id="5-2-段落标签"><a href="#5-2-段落标签" class="headerlink" title="5.2 段落标签"></a>5.2 段落标签</h3><p>段落标签：在新闻和文章的页面中，用于分段显示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是一个段落标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>便签语义：</strong>可以把 HTML 文档分割为若干段落。</p><p><strong>特点：</strong></p><ul><li>文本在一个段落中会根据浏览器窗口的大小自动换行</li><li>段落和段落之间保有空隙（段间距）</li><li>同一段落里的不同行文字之间也有一定的空隙（行间距）</li></ul><h3 id="5-3-换行标签"><a href="#5-3-换行标签" class="headerlink" title="5.3 换行标签"></a>5.3 换行标签</h3><p>换行标签 ： 某段文本强制换行显示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内容<span class="tag">&lt;<span class="name">br</span>&gt;</span>内容</span><br></pre></td></tr></table></figure><p><strong>标签语义：</strong>强制换行。</p><p><strong>特点：</strong></p><ul><li><code>&lt;br&gt;</code> 是个单标签</li><li><code>&lt;br&gt;</code> 标签只是简单地开始新的一行，跟段落不一样，所以不会产生段间距</li></ul><h3 id="5-4-水平线标签"><a href="#5-4-水平线标签" class="headerlink" title="5.4 水平线标签"></a>5.4 水平线标签</h3><p>水平线标签：分割不同主题内容的水平线</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内容<span class="tag">&lt;<span class="name">hr</span>&gt;</span>内容</span><br></pre></td></tr></table></figure><p><strong>标签语义</strong>：主题的分割转换</p><p><strong>特点</strong>：</p><ul><li><p>单标签</p></li><li><p>在页面中显示一条水平线</p></li></ul><p>代码实现图如下：</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230307164051.png"></p><h2 id="6-文本格式化标签"><a href="#6-文本格式化标签" class="headerlink" title="6 文本格式化标签"></a>6 文本格式化标签</h2><p>场景：需要让文字<strong>加粗</strong>、<u>下划线</u>、<em>倾斜</em>、<del>删除线</del>等效果</p><table><thead><tr><th>语义</th><th>标签</th><th>说明</th></tr></thead><tbody><tr><td>加粗</td><td><code>&lt;strong&gt;</code> <code>&lt;/strong&gt;</code> 或 <code>&lt;b&gt;</code> <code>&lt;/b&gt;</code></td><td>介于可读性、搜索引擎优化及屏幕阅读器适配推荐使用前者</td></tr><tr><td>倾斜</td><td><code>&lt;em&gt;</code> <code>&lt;/em&gt;</code> 或 <code>&lt;i&gt;</code> <code>&lt;/i&gt;</code></td><td>介于可读性、搜索引擎优化及屏幕阅读器适配推荐使用前者</td></tr><tr><td>删除线</td><td><code>&lt;del&gt;</code> <code>&lt;/del&gt;</code> 或 <code>&lt;s&gt;</code> <code>&lt;/s&gt;</code></td><td>介于可读性、搜索引擎优化及屏幕阅读器适配推荐使用前者</td></tr><tr><td>下划线</td><td><code>&lt;ins&gt;</code> <code>&lt;/ins&gt;</code> 或 <code>&lt;u&gt;</code> <code>&lt;/u&gt;</code></td><td>介于可读性、搜索引擎优化及屏幕阅读器适配推荐使用前者</td></tr></tbody></table><p><strong>标签语义：</strong>突出重要性的强调语境</p><h2 id="7-媒体标签"><a href="#7-媒体标签" class="headerlink" title="7 媒体标签"></a>7 媒体标签</h2><h3 id="7-1-路径"><a href="#7-1-路径" class="headerlink" title="7.1 路径"></a>7.1 路径</h3><p><strong>绝对路径：</strong>指目录下的绝对位置，可直接到达目标位置，通常<strong>从盘符开始</strong>的路径</p><p>例如：</p><ul><li>盘符开头：D:\day01\images\1.jpg</li><li>完整的网络地址：一个网络链接，可搭配图床使用</li></ul><p><strong>相对路径：</strong>从<strong>当前文件开始</strong>出发找目标文件的过程</p><p>概念普及：</p><ul><li>当前文件：当前的html网页</li><li>目标文件：要找到的图片</li></ul><p>相对路径分类：</p><ul><li>同级目录</li><li>下级目录</li><li>上级目录</li></ul><table><thead><tr><th>相对路径分类</th><th>符号</th><th>说明</th><th>写法</th></tr></thead><tbody><tr><td>同级路径</td><td><code>.</code></td><td>如：<code>&lt;img src=&quot;baidu.png&quot; /&gt;</code></td><td>目标文件名字</td></tr><tr><td>下级路径</td><td><code>/</code></td><td>如：<code>&lt;img src=&quot;image/baidu.png&quot; /&gt;</code></td><td>文件夹名&#x2F;目标文件名字</td></tr><tr><td>上级路径</td><td><code>../</code></td><td>如：<code>&lt;img src=&quot;../image/baidu.png&quot; /&gt;</code></td><td>..&#x2F;目标文件名字</td></tr></tbody></table><p><strong>注意：</strong></p><ul><li>相对路径为 <code>/</code>（正斜杆），绝对路径为 <code>\</code>（反斜杆）</li><li>实际开发中建议使用相对路径或网络地址（都是 <code>/</code> 正斜杆）</li></ul><blockquote><p>这里所说的绝对路径为 <code>\</code>（反斜杠）指的是在 Windows 环境中，而 Linux 系统依旧是正斜杠。</p></blockquote><h3 id="7-2-图片标签"><a href="#7-2-图片标签" class="headerlink" title="7.2 图片标签"></a>7.2 图片标签</h3><p>作用：在网页中显示图片</p><p>代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图像URL&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230307191642.png"></p><table><thead><tr><th>属性</th><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td><code>src</code></td><td>图片路径</td><td>指出图片的地址</td></tr><tr><td><code>url</code></td><td>统一资源定位符</td><td>地址、网址</td></tr><tr><td><code>alt</code></td><td>文本</td><td>替换文本，图像显示失败时显示（为了提高 SEO 及适配屏幕阅读器，建议都把 alt 写上）</td></tr><tr><td><code>title</code></td><td>文本</td><td>提示文本，鼠标放到图片上，显示的提示文字</td></tr><tr><td><code>width</code></td><td>像素</td><td>设置图像的宽度（了解，后面通过 CSS 设置）</td></tr><tr><td><code>height</code></td><td>像素</td><td>设置图像的高度（了解，后面通过 CSS 设置）</td></tr><tr><td><code>border</code></td><td>像素</td><td>设置图像的边框粗细（了解，后面通过 CSS 设置）</td></tr></tbody></table><p><strong>图像标签的注意点：</strong></p><ul><li>标签的属性写在<strong>开始标签内部</strong></li><li>标签上可以同时存在多个属性</li><li>属性之间以空格隔开</li><li>标签名与属性之间<strong>必须以空格隔开</strong></li><li>属性之间没有顺序之分</li><li>如果只设置width或height中的一个，另一个没设置的会自动等比例缩放（此时图片不会变形</li><li>如果同时设置了width和height两个，若设置不当此时图片可能会变形</li></ul><h3 id="7-3-音频标签"><a href="#7-3-音频标签" class="headerlink" title="7.3 音频标签"></a>7.3 音频标签</h3><p>作用：在网页中插入音频</p><p>代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&quot;./music.mp3 controls&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure><p>常见属性：</p><table><thead><tr><th>属性名</th><th>功能</th></tr></thead><tbody><tr><td>src</td><td>路径</td></tr><tr><td>controls</td><td>显示播放的控件</td></tr><tr><td>autoplay</td><td>自动播放</td></tr><tr><td>loop</td><td>循环播放</td></tr></tbody></table><blockquote><p>音频标签目前支持三种格式：<strong>MP3</strong>、Wav、Ogg</p></blockquote><h3 id="7-4-视频标签"><a href="#7-4-视频标签" class="headerlink" title="7.4 视频标签"></a>7.4 视频标签</h3><p>作用：在网页中插入音频</p><p>代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;./video.mp4 controls&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><p>常见属性：</p><table><thead><tr><th>属性名</th><th>功能</th></tr></thead><tbody><tr><td>src</td><td>路径</td></tr><tr><td>controls</td><td>显示播放的控件</td></tr><tr><td>autoplay</td><td>自动播放</td></tr><tr><td>loop</td><td>循环播放</td></tr></tbody></table><blockquote><p>视频标签目前支持三种格式：<strong>MP4</strong>、Wav、Ogg</p></blockquote><h2 id="8-超链接标签"><a href="#8-超链接标签" class="headerlink" title="8 超链接标签"></a>8 超链接标签</h2><p>在 HTML 标签中，<code>&lt;a&gt;</code> 标签用于定义超链接，作用是从一个页面链接到另一个页面</p><p><strong>作用：</strong>点击之后，从一个页面跳转到另一个页面</p><p>称呼： a标签、超链接、锚链接</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;跳转目标&quot;</span> <span class="attr">target</span>=<span class="string">&quot;目标窗口的弹出方式&quot;</span>&gt;</span>文本、图像或其他内容<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>特点：</p><ul><li>双标签，内部可以包裹内容</li><li>如果需要a标签点击之后去指定页面，需要设置a标签的href属性</li></ul><h3 id="8-1-herf属性"><a href="#8-1-herf属性" class="headerlink" title="8.1 herf属性"></a>8.1 herf属性</h3><p>属性值：点击之后跳转去哪一个网页（目标网页的路径）</p><h3 id="8-2target属性"><a href="#8-2target属性" class="headerlink" title="8.2target属性"></a>8.2target属性</h3><p>属性值：目标网页的打开形式</p><p>取值：</p><ul><li>_self：默认值，原网页跳转，覆盖原网页</li><li>_blank：新窗口跳转</li></ul><h3 id="8-3-链接分类"><a href="#8-3-链接分类" class="headerlink" title="8.3 链接分类"></a>8.3 链接分类</h3><ul><li><strong>外部链接：</strong>直接给出一个网站，例如：<code>&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;</code> </li><li><strong>内部链接：</strong>网站内部页面之间相互链接，直接链接内部页面名称即可，例如： <code>&lt;a href=&quot;./about.html&quot;&gt;关于页&lt;/a&gt;</code></li><li><strong>空链接：</strong>如果当时没有确定链接目标时，<code>&lt;a href=&quot;javascript:void(0)&quot;&gt;哪也不去&lt;/a&gt;&quot;</code>，当用户点击链接时 void(0) 计算为 0，但 Javascript 上没有任何效果</li><li><strong>下载链接：</strong>如果 href 里面地址是一个文件或者压缩包（前提：路径包含文件类型后缀名，如：<code>.exe</code>、<code>.zip</code> 等），便会下载这个文件，如果是图片、视频、PDF则会打开一个新窗口预览</li><li><strong>网页元素链接：</strong>在网页中的各种网页元素，如：文本、图像、表格、音频、视频等都可以添加超链接</li><li><strong>锚点链接：</strong>点击链接，可以快速定位到当前页面中的某个位置<ul><li>在链接文本的 href 属性中，设置属性值的 <code>#名字</code> 的形式，如：<code>&lt;a href=&quot;#two&quot;&gt;第2集&lt;/a&gt;</code></li><li>找到目标位置标签（此处以 h3 标签为例），里面添加一个 <code>id属性=&quot;刚才的名字&quot;</code>，如：<code>&lt;h3 id=&quot;two&quot;&gt;第2集介绍&lt;/h3&gt;</code></li><li><code>&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;</code> 定位到页面顶部</li></ul></li></ul><h1 id="四、HTML排版标签"><a href="#四、HTML排版标签" class="headerlink" title="四、HTML排版标签"></a>四、HTML排版标签</h1><h2 id="1-列表标签"><a href="#1-列表标签" class="headerlink" title="1 列表标签"></a>1 列表标签</h2><h3 id="1-1-列表的应用场景"><a href="#1-1-列表的应用场景" class="headerlink" title="1.1 列表的应用场景"></a>1.1 列表的应用场景</h3><p>场景：在网页中按照行展示关联性的内容，如：新闻列表、排行榜、账单等</p><p>特点：按照行的方式，整齐显示内容</p><p>种类：无序列表、有序列表、自定义列表 </p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230309130647.png"></p><p>无序列表最常用，有序列表偶尔用，自定义列表底部导航用</p><h3 id="1-2-无序列表"><a href="#1-2-无序列表" class="headerlink" title="1.2 无序列表"></a>1.2 无序列表</h3><p>场景：在网页中表示一组无顺序之分的列表，如：新闻列表</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">         内容</span><br><span class="line">     <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>显示特点：</p><ul><li>列表的每一项前默认显示圆点标识</li></ul><p>注意点：</p><ul><li>ul 标签中只允许包含 li 标签</li><li>li 标签可以包含任意内容</li></ul><h3 id="1-3-有序列表"><a href="#1-3-有序列表" class="headerlink" title="1.3 有序列表"></a>1.3 有序列表</h3><p>场景：在网页中表示一组有顺序之分的列表，如：热搜</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">         内容</span><br><span class="line">     <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><p>显示特点：</p><ol><li>列表的每一项前默认显示序号标识</li></ol><p>注意点：</p><ol><li>ol 标签中只允许包含 li 标签</li><li>li 标签可以包含任意内容</li></ol><h3 id="1-4-自定义列表"><a href="#1-4-自定义列表" class="headerlink" title="1.4 自定义列表"></a>1.4 自定义列表</h3><p>场景：在网页的底部导航中通常会使用自定义列表实现</p><p>标签组成：</p><table><thead><tr><th>标签名</th><th>说明</th></tr></thead><tbody><tr><td>dl</td><td>表示自定义列表的整体，用于包裹 dt &#x2F; dd 标签</td></tr><tr><td>dt</td><td>表示自定义列表的主题</td></tr><tr><td>dd</td><td>表示自定义列表的针对主题的每一项内容</td></tr></tbody></table><p>显示特点：</p><ul><li>dd 前会默认显示缩进效果</li></ul><p>注意点：</p><ul><li>dl 标签中只允许包含 dt &#x2F; dd 标签</li><li>dt &#x2F; dd 标签可以包含任意内容</li></ul><p>例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dt</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>王五<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>赵六<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dt</span>&gt;</span>成绩<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>99<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>99<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>99<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>99<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230309154437.png"></p><h1 id="五、表格标签"><a href="#五、表格标签" class="headerlink" title="五、表格标签"></a>五、表格标签</h1><p>场景：在网页中以行+列的单元格的方式整齐展示和数据，如：学生成绩表</p><h2 id="1-表格的基本标签"><a href="#1-表格的基本标签" class="headerlink" title="1 表格的基本标签"></a>1 表格的基本标签</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230310165350.png"></p><table><thead><tr><th>标签名</th><th>说明</th></tr></thead><tbody><tr><td>table</td><td>表格整体，包裹多个tr</td></tr><tr><td>tr</td><td>表格每行，包裹多个tr</td></tr><tr><td>td</td><td>表格单元格，包裹内容</td></tr></tbody></table><blockquote><p>标签的嵌套关系：table &gt; tr &gt; td</p></blockquote><h2 id="2-表格相关属性"><a href="#2-表格相关属性" class="headerlink" title="2 表格相关属性"></a>2 表格相关属性</h2><p>场景：设置表格基本展示效果</p><p>常见相关属性：</p><table><thead><tr><th>属性名</th><th>属性值</th><th>效果</th></tr></thead><tbody><tr><td>border</td><td>数字</td><td>边框宽度</td></tr><tr><td>width</td><td>数字</td><td>表格宽度</td></tr><tr><td>height</td><td>数字</td><td>表格高度</td></tr></tbody></table><blockquote><p>实际开发时针对于样式效果推荐用CSS设置</p></blockquote><blockquote><p>没有 border 不会显示边框</p></blockquote><h2 id="3-表格标题和表头单元格标签"><a href="#3-表格标题和表头单元格标签" class="headerlink" title="3 表格标题和表头单元格标签"></a>3 表格标题和表头单元格标签</h2><p>场景：在表格中表示整体大标题和一列小标题</p><p>其他标签：</p><table><thead><tr><th>标签名</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>caption</td><td>表格大标题</td><td>表格的大标题，默认在表格顶部居中显示</td></tr><tr><td>th</td><td>表头单元格</td><td>一列小标题，默认加粗，常用来表示表格第一行</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230310165417.png"></p><h2 id="4-合并单元格"><a href="#4-合并单元格" class="headerlink" title="4 合并单元格"></a>4 合并单元格</h2><p>场景：将水平或垂直多个单元格合并成一个单元格</p><p>通过左上原则，确定保留谁删除谁：</p><ul><li>上下合并→只保留最上的，删除其他</li><li>左右合并→只保留最左的，删除其他</li></ul><table><thead><tr><th>属性名</th><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>rowspan</td><td>合并单元格的个数</td><td>跨行合井，将多行的单元格垂直合并</td></tr><tr><td>colspan</td><td>合并单元格的个数</td><td>跨列合井，将多列的单元格水平合井</td></tr></tbody></table><blockquote><p>只有同一个结构标签中的单元格才能合并，不能跨结构标签合并（不能跨：thead、tbody、tfoot）</p></blockquote><h1 id="六、表单标签"><a href="#六、表单标签" class="headerlink" title="六、表单标签"></a>六、表单标签</h1><h2 id="1-input"><a href="#1-input" class="headerlink" title="1 input"></a>1 input</h2><p>场景：在网页中显示收集用户信息的表单效果，如：登录页、注册页</p><p>input标签可以通过type属性值的不同，展示不同效果：</p><table><thead><tr><th>标签名</th><th>type属性值</th><th>说明</th></tr></thead><tbody><tr><td>input</td><td>text</td><td>文本框，用于输入文字（输入内容直接可见）</td></tr><tr><td>input</td><td>password</td><td>密码框，输入内容不直接可见</td></tr><tr><td>input</td><td>radio</td><td>单选框</td></tr><tr><td>input</td><td>checkbox</td><td>多选框</td></tr><tr><td>input</td><td>file</td><td>文件选择，用于上传文件</td></tr><tr><td>input</td><td>submit</td><td>提交键</td></tr><tr><td>input</td><td>reset</td><td>重置键</td></tr><tr><td>input</td><td>button</td><td>无固定功能键，配合 js 实现多功能</td></tr></tbody></table><h3 id="1-1-文本框text"><a href="#1-1-文本框text" class="headerlink" title="1.1 文本框text"></a>1.1 文本框text</h3><p>场景：在网页中显示输入单行文本的表单控件</p><p>常用属性：</p><p>placeholder：占位符，提升用户输入内容的文本</p><p>value属性：用户输入的内容，提交之后会发送给后端服务器</p><p>name属性：当前控件的含义，提交之后可以告诉后端发送过去的数据是什么含义</p><p>后端接收到数据的格式是：name的属性值 &#x3D; value的属性值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入用户名&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-密码password"><a href="#1-2-密码password" class="headerlink" title="1.2 密码password"></a>1.2 密码password</h3><p>场景：在网页中显示输入密码的表单控件</p><p>常用属性（同文本框)</p><h3 id="1-3-单选框radio"><a href="#1-3-单选框radio" class="headerlink" title="1.3 单选框radio"></a>1.3 单选框radio</h3><p>场景：在网页中显示多选一的单选表单控件</p><p>常用属性：</p><p>name：分组。有相同name属性值的单选框为-一组，一组中同时只能有一个被选中</p><p>checked：默认选中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">性别：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;性别&quot;</span>&gt;</span>男<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;性别&quot;</span>&gt;</span>女</span><br></pre></td></tr></table></figure><h3 id="1-4-复选框checkbox"><a href="#1-4-复选框checkbox" class="headerlink" title="1.4 复选框checkbox"></a>1.4 复选框checkbox</h3><p>场景：在网页中显示多选多的多选表单控件</p><p>常用属性（同单选框）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">爱好：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;爱好&quot;</span>&gt;</span>吃饭 <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;爱好&quot;</span>&gt;</span>睡觉<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;爱好&quot;</span>&gt;</span>打豆豆 <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-5-文件选择file"><a href="#1-5-文件选择file" class="headerlink" title="1.5 文件选择file"></a>1.5 文件选择file</h3><p>场景：在网页中显示文件选择的表单控件</p><p>常用属性：</p><p>multiple：文件多选</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">multiple</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-6-按钮button"><a href="#1-6-按钮button" class="headerlink" title="1.6 按钮button"></a>1.6 按钮button</h3><p>场景：在网页中显示不同功能的按钮表单控件</p><blockquote><p>如果需要实现以上按钮功能，需要配合form标签使用</p></blockquote><blockquote><p>form使用方法：用form标签把表单标签一起包裹起来即可</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    其余内容</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230310172339.png"></p><h2 id="2-button（独立于input的button标签）"><a href="#2-button（独立于input的button标签）" class="headerlink" title="2 button（独立于input的button标签）"></a>2 button（独立于input的button标签）</h2><p>场景：在网页中显示用户点击的按钮</p><p>标签名：button</p><p>type属性值（同input的按钮系列）</p><table><thead><tr><th>标签名</th><th>type属性值</th><th>说明</th></tr></thead><tbody><tr><td>button</td><td>submit</td><td>提交键</td></tr><tr><td>button</td><td>reset</td><td>重置键</td></tr><tr><td>button</td><td>button</td><td>无固定功能键，配合 js 实现多功能</td></tr></tbody></table><blockquote><p>谷歌浏览器中button默认是提交按钮</p></blockquote><blockquote><p>button标签是双标签，更便于包裹其他内容：文字、图片等</p></blockquote><h2 id="3-select下拉菜单标签"><a href="#3-select下拉菜单标签" class="headerlink" title="3 select下拉菜单标签"></a>3 select下拉菜单标签</h2><p>场景：在网页中提供多个选择项的下拉菜单表单控件</p><p>标签组成：</p><p>select标签：下拉菜单的整体</p><p>option标签：下拉菜单的每一项</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;beijing&quot;</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;shanghai&quot;</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>常见属性：</p><p>selected：下拉菜单的默认选中，没有特定指出则第一个为默认选中</p><h2 id="4-textarea文本域"><a href="#4-textarea文本域" class="headerlink" title="4 textarea文本域"></a>4 textarea文本域</h2><p>场景：在网页中提供可输入多行文本的表单控件</p><p>常见属性：</p><p>cols：规定了文本域内可见宽度</p><p>rows：规定了文本域内可见行数</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;30&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="5-label"><a href="#5-label" class="headerlink" title="5 label"></a>5 label</h2><p>场景：常用于绑定内容与表单标签的关系</p><p>使用方法1：</p><ul><li>使用label标签把内容（如：文本）包裹起来</li><li>在表单标签上添加id属性</li><li>在label标签的for属性中设置对应的id属性值</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;性别&quot;</span> <span class="attr">id</span>=<span class="string">&quot;男&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;男&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;性别&quot;</span> <span class="attr">id</span>=<span class="string">&quot;女&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;女&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>id 和 for 的内容相同用来链接</p></blockquote><p>使用方法2：</p><ul><li>直接使用label标签把内容（如：文本）和表单标签一起包裹起来</li><li>需要把label标签的for属性删除即可</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> &gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;爱好&quot;</span>&gt;</span>吃饭 <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> &gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;爱好&quot;</span>&gt;</span>睡觉 <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> &gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;爱好&quot;</span>&gt;</span>打豆豆 <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>我的实验中一个 label 只能对一个选项起作用，不能一个 label 包含多个选项</p></blockquote><h1 id="七、语义化标签"><a href="#七、语义化标签" class="headerlink" title="七、语义化标签"></a>七、语义化标签</h1><h2 id="1-没有语义的布局标签-div和span"><a href="#1-没有语义的布局标签-div和span" class="headerlink" title="1 没有语义的布局标签-div和span"></a>1 没有语义的布局标签-div和span</h2><p>场景：实际开发网页时会大量频繁的使用到div和span这两个没语义的布局标签</p><p>div标签：一行只显示一个（独占一行）</p><p>span标签：一行可以显示多个</p><h2 id="2-有语义的布局标签"><a href="#2-有语义的布局标签" class="headerlink" title="2 有语义的布局标签"></a>2 有语义的布局标签</h2><p>场景：在HTML5新版本中，推出了一些有语义的布局标签供开发者使用</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230310213927.png"></p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">caption</span>&gt;</span>优秀学生信息表格<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>年级<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>学号<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>班级<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>高三<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>110<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>三年二班<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>120<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>三年三班<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>评语<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;3&quot;</span>&gt;</span>你们都有光明的未来<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230310215613.png"></p><p>  经过上手实验，合并表格是占据位置但不覆盖内容，如果要合并内容，应在相应位置空出，合并处会自动补齐，后续内容依次入座</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>宁可累死自己，也要卷死他人<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        昵称：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入昵称&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        性别：</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">id</span>=<span class="string">&quot;男&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;男&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">id</span>=<span class="string">&quot;女&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;女&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        所在地：</span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;beijing&quot;</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;shanghai&quot;</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;guangzhou&quot;</span>&gt;</span>广州<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;shenzhen&quot;</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        学历：</span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;学历&quot;</span>&gt;</span>高中<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;学历&quot;</span>&gt;</span>本科<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;学历&quot;</span>&gt;</span>硕士<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;学历&quot;</span>&gt;</span>博士<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        专业：</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;专业&quot;</span>&gt;</span>计算机</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;专业&quot;</span>&gt;</span>土木工程</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;专业&quot;</span>&gt;</span>外国语</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;专业&quot;</span>&gt;</span>数学<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        个人介绍：<span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">cols</span>=<span class="string">&quot;30&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">b</span>&gt;</span>我保证<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">                学术严谨</span><br><span class="line">                态度严谨</span><br><span class="line">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span>我同意所有条款<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230310222707.png"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>至每一个来到这里的人</title>
      <link href="/2023/02/22/hello-world/"/>
      <url>/2023/02/22/hello-world/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/TEHSN5228DVNJ0IKG8LMEF5.jpg"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

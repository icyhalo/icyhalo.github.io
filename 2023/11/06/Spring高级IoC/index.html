<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Spring高级-IoC部分 | Icyhaloの糖果屋</title><meta name="author" content="冰晕"><meta name="copyright" content="冰晕"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="IoC、DI和AOP思想提出传统开发2个问题  IoCDIAOPIoC思想： Inversion of Control，翻译为“控制反转”或“反转控制”，强调的是原来在程序中创建Bean的权利反转给第三方。 根据IoC思想的指导， 寻求一个第三方去创建UserServiceImpl对象和UserDaoImpl对象。这样程序与具体对象就失去的直接联系。 谁去充当第三方角色呢？   工厂设计模式，Be">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring高级-IoC部分">
<meta property="og:url" content="http://example.com/2023/11/06/Spring%E9%AB%98%E7%BA%A7IoC/index.html">
<meta property="og:site_name" content="Icyhaloの糖果屋">
<meta property="og:description" content="IoC、DI和AOP思想提出传统开发2个问题  IoCDIAOPIoC思想： Inversion of Control，翻译为“控制反转”或“反转控制”，强调的是原来在程序中创建Bean的权利反转给第三方。 根据IoC思想的指导， 寻求一个第三方去创建UserServiceImpl对象和UserDaoImpl对象。这样程序与具体对象就失去的直接联系。 谁去充当第三方角色呢？   工厂设计模式，Be">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/icyhalo/picgo/main/img/7dd0a3a35f174932a8b62f85eed07d34818483c2_rw.jpg">
<meta property="article:published_time" content="2023-11-05T16:00:00.000Z">
<meta property="article:modified_time" content="2023-11-19T13:40:49.762Z">
<meta property="article:author" content="冰晕">
<meta property="article:tag" content="Spring">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/icyhalo/picgo/main/img/7dd0a3a35f174932a8b62f85eed07d34818483c2_rw.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/11/06/Spring%E9%AB%98%E7%BA%A7IoC/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":100},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 冰晕","link":"链接: ","source":"来源: Icyhaloの糖果屋","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spring高级-IoC部分',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-19 21:40:49'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://www.fomal.cc/static/css/runtime.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/img/FeeCpEnVIAAPn7.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">49</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://raw.githubusercontent.com/icyhalo/picgo/main/img/7dd0a3a35f174932a8b62f85eed07d34818483c2_rw.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Icyhaloの糖果屋"><span class="site-name">Icyhaloの糖果屋</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Spring高级-IoC部分</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-05T16:00:00.000Z" title="发表于 2023-11-06 00:00:00">2023-11-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-19T13:40:49.762Z" title="更新于 2023-11-19 21:40:49">2023-11-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>57分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Spring高级-IoC部分"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="IoC、DI和AOP思想提出"><a href="#IoC、DI和AOP思想提出" class="headerlink" title="IoC、DI和AOP思想提出"></a>IoC、DI和AOP思想提出</h1><p>传统开发2个问题</p>
<p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109170011596.png" alt="image-20231109170011596"></p>
<div class="tabs" id="1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#1-1">IoC</button></li><li class="tab"><button type="button" data-href="#1-2">DI</button></li><li class="tab"><button type="button" data-href="#1-3">AOP</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><p>IoC思想： Inversion of Control，翻译为“控制反转”或“反转控制”，强调的是原来在程序中创建Bean的权利反转给第三方。</p>
<p>根据IoC思想的指导， 寻求一个第三方去创建UserServiceImpl对象和UserDaoImpl对象。这样程序与具体对象就失去的直接联系。</p>
<p>谁去充当第三方角色呢？ </p>
<ul>
<li>工厂设计模式，BeanFactory来充当第三方的角色，来产生Bean实例</li>
</ul>
<p>BeanFactory怎么知道产生哪些Bean实例呢？</p>
<ul>
<li>可以使用配置文件配置Bean的基本信息，BeanFactory根据配置文件来生产Bean实例</li>
</ul>
<p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109165542356.png" alt="image-20231109165542356"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-2"><p>DI 依赖注入思想的提出</p>
<p>将 UserDao的创建权也反转给BeanFactory，与此同时UserService内部还需要用到UserDao实例对象，那应该怎 样操作呢？ </p>
<ol>
<li>在程序中，通过BeanFactory获得UserService</li>
<li>在程序中，通过BeanFactory获得UserDao</li>
<li>在程序中，将UserDao设置给UserService</li>
</ol>
<p>将UserDao在BeanFactory内部设置 给UserService的过程叫做“注入” ，而UserService需要依赖UserDao 的注入才能正常工作，这个过程叫做 “依赖注入”</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-3"><p>AOP思想：Aspect Oriented Programming，面向切面编程，是对面向对象编程OOP的升华。</p>
<p>OOP是纵向对一个 事物的抽象，一个对象包括静态的属性信息，包括动态的方法信息等。</p>
<p>AOP是横向的对不同事物的抽象，属 性与属性、方法与方法、对象与对象都可以组成一个切面，而用这种思维去设计编程的方式叫做面向切面编程</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>

<p>三种思想总结</p>
<ol>
<li>IoC控制反转，是将程序创建Bean的权利反转给第三方</li>
<li>DI依赖注入，某个完整Bean需要依赖于其他Bean（或属性）的注入</li>
<li>AOP面向切面编程，用横向抽取方法（属性、对象等）思想，组装成一个功能性切面</li>
</ol>
<p>面试题：IoC 和 DI 的关系？</p>
<ol>
<li>回答IoC和DI的是什么：<ul>
<li>IoC： Inversion of Control，控制反转，将Bean的创建权由原来程序反转给第三方 </li>
<li>DI：Dependency Injection，依赖注入，某个Bean的完整创建依赖于其他Bean（或普通参数）的注入</li>
</ul>
</li>
<li>回答IoC和DI的关系：<ul>
<li>第一种观点：IoC强调的是Bean创建权的反转，而DI强调的是Bean的依赖关系，认为不是一回事 </li>
<li>第二种观点：IoC强调的是Bean创建权的反转，而DI强调的是通过注入的方式反转Bean的创建权，认为DI是IoC的其中一种实现方式</li>
</ul>
</li>
</ol>
<h1 id="Spring框架的诞生"><a href="#Spring框架的诞生" class="headerlink" title="Spring框架的诞生"></a>Spring框架的诞生</h1><h2 id="Spring-Framework技术栈"><a href="#Spring-Framework技术栈" class="headerlink" title="Spring Framework技术栈"></a>Spring Framework技术栈</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231116092050110.png" alt="image-20231116092050110"></p>
<ul>
<li>Data Access: 数据访问</li>
<li>Data Integration: 数据集成</li>
<li>Web: Web开发</li>
<li>AOP: 面向切面编程</li>
<li>Aspects: AOP思想实现</li>
<li>Core Container:核心容器</li>
<li>Test: 单元测试与集成测试</li>
</ul>
<p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231116092105753.png" alt="image-20231116092105753"></p>
<h2 id="Spring-的容器"><a href="#Spring-的容器" class="headerlink" title="Spring 的容器"></a>Spring 的容器</h2><p>主要有2个BeanFactory与ApplicationContext</p>
<ul>
<li>BeanFactory是Spring的早期接口，称为Spring的Bean工厂，ApplicationContext是后期更高级接口，称之为 Spring 容器；</li>
<li>ApplicationContext在BeanFactory基础上对功能进行了扩展，例如：监听功能、国际化功能等。BeanFactory的 API更偏向底层，ApplicationContext的API大多数是对这些底层API的封装；</li>
<li>Bean创建的主要逻辑和功能都被封装在BeanFactory中，ApplicationContext不仅继承了BeanFactory，而且 ApplicationContext内部还维护着BeanFactory的引用，所以，ApplicationContext与BeanFactory既有继承关系，又有融合关系</li>
<li>Bean的初始化时机不同，原始BeanFactory是在首次调用getBean时才进行Bean的创建，而ApplicationContext则是配置文件加载，容器一创建就将Bean都实例化并初始化好</li>
<li>ApplicationContext除了继承了BeanFactory外，还继承了ApplicationEventPublisher（事件发布器）、 ResouresPatternResolver（资源解析器）、MessageSource（消息资源）等。</li>
<li>但是ApplicationContext的核心功能还是BeanFactory。</li>
</ul>
<p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109203334542.png" alt="image-20231109203334542"></p>
<p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109203343674.png" alt="image-20231109203343674"></p>
<h3 id="BeanFactory的继承体系"><a href="#BeanFactory的继承体系" class="headerlink" title="BeanFactory的继承体系"></a>BeanFactory的继承体系</h3><p>BeanFactory是核心接口，项目运行过程中肯定有具体实现参与，这个具体实现就是DefaultListableBeanFactory ，而ApplicationContext内部维护的Beanfactory的实现类也是它</p>
<p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109203910999.png" alt="image-20231109203910999"></p>
<h3 id="ApplicationContext的继承体系"><a href="#ApplicationContext的继承体系" class="headerlink" title="ApplicationContext的继承体系"></a>ApplicationContext的继承体系</h3><p>只在Spring基础环境下，即只导入spring-context坐标时，此时ApplicationContext的继承体系</p>
<p>下图三个是常用的实现类，从上到下为：</p>
<ol>
<li>使用注解进行加载的实现类，<strong>注解的</strong></li>
<li>根据文件在电脑中的绝对位置进行加载的实现类，<strong>XML的</strong></li>
<li>根据文件在项目中的相对位置进行加载的实现类，<strong>XML的</strong></li>
</ol>
<p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109203931158.png" alt="image-20231109203931158"></p>
<p>如果Spring基础环境中加入了其他组件解决方案，如web层解决方案，即导入spring-web坐标，此时 ApplicationContext的继承体系</p>
<p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109204046565.png" alt="image-20231109204046565"></p>
<p>常用的几个ApplicationContext作用如下：</p>
<table>
<thead>
<tr>
<th>实现类</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>ClassPathXmlApplicationContext</td>
<td>加载类路径下的xml配置的ApplicationContext</td>
</tr>
<tr>
<td>FileSystemXmlApplicationContext</td>
<td>加载磁盘路径下的xml配置的ApplicationContext</td>
</tr>
<tr>
<td>AnnotationConfigApplicationContext</td>
<td>加载注解配置类的ApplicationContext</td>
</tr>
<tr>
<td>XmlWebApplicationContext</td>
<td>web环境下，加载类路径下的xml配置的ApplicationContext</td>
</tr>
<tr>
<td>AnnotationConfigWebApplicationContext</td>
<td>web环境下，加载磁盘路径下的xml配置的ApplicationContext</td>
</tr>
</tbody></table>
<h2 id="BeanFactory-快速入门"><a href="#BeanFactory-快速入门" class="headerlink" title="BeanFactory 快速入门"></a>BeanFactory 快速入门</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109165542356.png" alt="image-20231109165542356"></p>
<div class="tabs" id="2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2-1">IoC</button></li><li class="tab"><button type="button" data-href="#2-2">DI</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2-1"><ol>
<li><p>导入Spring的jar包或Maven坐标</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--Spring核心--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.3.7&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>


</li>
<li><p>定义UserService接口及其UserServiceImpl实现类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public interface UserService &#123;&#125;</span><br><span class="line">public class UserServiceImpl implements UserService &#123;&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>创建beans.xml配置文件，将UserServiceImpl的信息配置到该xml中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.impl.UserServiceImpl&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>id：bean的名字</p>
<p>class：bean的全路径，通过反射创建的bean对象</p>
</li>
<li><p>编写测试代码，创建BeanFactory，加载配置文件，获取UserService实例对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//创建BeanFactory</span><br><span class="line">DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();</span><br><span class="line"></span><br><span class="line">//创建读取器</span><br><span class="line">XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">//加载配置文件</span><br><span class="line">reader.loadBeanDefinitions(&quot;beans.xml&quot;);</span><br><span class="line"></span><br><span class="line">//获取Bean实例对象</span><br><span class="line">UserDao userService = (UserService) beanFactory.getBean(&quot;userService&quot;);</span><br></pre></td></tr></table></figure></li>
</ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2-2"><ol>
<li><p>定义UserDao接口及其UserDaoImpl实现类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public interface UserDao &#123;&#125;</span><br><span class="line">public class UserDaoImpl implements UserDao &#123;&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>修改UserServiceImpl代码，添加一个setUserDao(UserDao userDao)用于接收注入的对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line">  public void setUserDao(UserDao userDao) &#123;</span><br><span class="line">    System.out.println(userDao);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>定义UserDao接口及其UserDaoImpl实现类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.impl.UserServiceImpl&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>请回忆2个userDao的区别</p>
</blockquote>
</li>
<li><p>编写测试代码，创建BeanFactory，加载配置文件，获取UserService实例对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//创建BeanFactory</span><br><span class="line">DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();</span><br><span class="line"></span><br><span class="line">//创建读取器</span><br><span class="line">XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">//加载配置文件</span><br><span class="line">reader.loadBeanDefinitions(&quot;beans.xml&quot;);</span><br><span class="line"></span><br><span class="line">//获取Bean实例对象</span><br><span class="line">UserDao userService = (UserService) beanFactory.getBean(&quot;userService&quot;);</span><br></pre></td></tr></table></figure></li>
</ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>



<h2 id="ApplicationContext快速入门"><a href="#ApplicationContext快速入门" class="headerlink" title="ApplicationContext快速入门"></a>ApplicationContext快速入门</h2><p>ApplicationContext 称为Spring容器，内部封装了BeanFactory（本质还是用的BeanFactory），比BeanFactory功能更丰富更强大，使用 ApplicationContext 进行开发时，xml配置文件的名称习惯写成applicationContext.xml，但这个名字不是必须的。</p>
<p>其余配置过程和BeanFactory的一样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//创建ApplicationContext,加载配置文件，实例化容器</span><br><span class="line">ApplicationContext applicationContext =</span><br><span class="line">new ClassPathxmlApplicationContext(“applicationContext.xml&quot;);</span><br><span class="line"></span><br><span class="line">//根据beanName获得容器中的Bean实例</span><br><span class="line">UserService userService = (UserService) applicationContext.getBean(&quot;userService&quot;);</span><br><span class="line">System.out.println(userService);</span><br></pre></td></tr></table></figure>



<h1 id="基于xml的Spring应用"><a href="#基于xml的Spring应用" class="headerlink" title="基于xml的Spring应用"></a>基于xml的Spring应用</h1><h2 id="Bean配置"><a href="#Bean配置" class="headerlink" title="Bean配置"></a>Bean配置</h2><p>Spring开发中主要是对Bean的配置，Bean的常用配置一览如下：</p>
<table>
<thead>
<tr>
<th>Xml配置方式</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td>&lt; bean id&#x3D;”” class&#x3D;””&gt;</td>
<td>Bean的id和全限定类名配置</td>
</tr>
<tr>
<td>&lt; bean name&#x3D;””&gt;</td>
<td>通过name设置Bean的别名，通过别名也能直接获取到Bean实例</td>
</tr>
<tr>
<td>&lt; bean scope&#x3D;””&gt;</td>
<td>Bean的作用范围，BeanFactory作为容器时取值singleton和prototype</td>
</tr>
<tr>
<td>&lt; bean lazy-init&#x3D;””&gt;</td>
<td>Bean的实例化时机，是否延迟加载。BeanFactory作为容器时无效</td>
</tr>
<tr>
<td>&lt; bean init-method&#x3D;””&gt;</td>
<td>Bean实例化后自动执行的初始化方法，method指定方法名</td>
</tr>
<tr>
<td>&lt; bean destroy-method&#x3D;””&gt;</td>
<td>Bean实例销毁前的方法，method指定方法名</td>
</tr>
<tr>
<td>&lt; bean autowire&#x3D;”byType”&gt;</td>
<td>设置自动注入模式，常用的有按照类型byType，按照名字byName</td>
</tr>
<tr>
<td>&lt; bean factory-bean&#x3D;”” factory-method&#x3D;””&#x2F;&gt;</td>
<td>指定哪个工厂Bean的哪个方法完成Bean的创建</td>
</tr>
</tbody></table>
<ul>
<li><p>Bean的基础配置：id 和 class</p>
<p>id：bean的名字，但进后面的容器后 id 会转变为 name</p>
<p>class：bean的全路径，通过反射创建的bean对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;/&gt;</span><br><span class="line">applicationContext.getBean(&quot;userDao&quot;);</span><br></pre></td></tr></table></figure>

<p>此时存储到<strong>singleObjects单例池</strong>中的Bean的beanName是userDao，值是UserDaoImpl对象，可以根据beanName获取Bean实例，如果不配置id，则Spring会把当前Bean实例的全限定名作为beanName</p>
<p>debug中可以看见，key对应id，value对应值</p>
</li>
<li><p>Bean的别名配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;userDao&quot; name=&quot;aaa,bbb&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>可以为当前Bean指定多个别名，根据别名也可以获得Bean对象，此时多个名称都可以获得UserDaoImpl实例对象，使用时优先id</p>
</li>
<li><p>Bean的范围配置：单例和非单例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//singleton</span><br><span class="line">&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot; scope=&quot;singleton&quot;/&gt;</span><br><span class="line">Object userDao = applicationContext.getBean(&quot;userDao&quot;);</span><br><span class="line">Object userDao2 = applicationContext.getBean(&quot;userDao&quot;);</span><br><span class="line">System.out.println(userDao); //com.itheima.dao.impl.UserDaoImpl@631330c</span><br><span class="line">System.out.println(userDao2); //com.itheima.dao.impl.UserDaoImpl@631330c</span><br><span class="line"></span><br><span class="line">//prototype</span><br><span class="line">&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot; scope=&quot;prototype&quot;/&gt;</span><br><span class="line">Object userDao = applicationContext.getBean(&quot;userDao&quot;);</span><br><span class="line">Object userDao2 = applicationContext.getBean(&quot;userDao&quot;);</span><br><span class="line">System.out.println(userDao); //com.itheima.dao.impl.UserDaoImpl@4d50efb8</span><br><span class="line">System.out.println(userDao2); //com.itheima.dao.impl.UserDaoImpl@7e2d773b</span><br></pre></td></tr></table></figure>

<p>singleton：默认值，Spring容器创建的时候，就会进行Bean的实例化，并存储到容器内部的单例池中 ，每次getBean时都是从单例池中获取相同的Bean实例；</p>
<p>prototype：Spring容器初始化时不会创建Bean实例，当调用getBean时才会实例化Bean，每次 getBean都会创建一个新的Bean实例，即用即创，用后回收</p>
</li>
<li><p>Bean的延迟加载</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot; lazy-init=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>当lazy-init设置为true时为延迟加载，也就是当Spring容器创建的时候，不会立即创建Bean实例，等待用到时在创建Bean实例并存储到单例池中去，后续在使用该Bean直接从单例池获取即可，本质上该Bean还是单例的</p>
</li>
<li><p>Bean的初始化和销毁方法配置</p>
<p>Bean在<strong>被实例化后</strong>，可以执行指定的初始化方法完成一些初始化的操作，Bean在销毁之前也可以执行指定的销毁方法完成一些操作，初始化方法名称和销毁方法名称通过 init-method 和 destroy-method 指明</p>
<p>后面的学习中会遇到其他的功能增强，不同增强发生的时机不同。初始化和销毁方法是比较靠后的增强</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot; init-method=&quot;init&quot;</span><br><span class="line">destroy-method=&quot;destroy&quot;/&gt;</span><br><span class="line"></span><br><span class="line">public class UserDaoImpl implements UserDao &#123;</span><br><span class="line">  public UserDaoImpl() &#123; System.out.println(&quot;UserDaoImpl创建了...&quot;); &#125;</span><br><span class="line">  public void init()&#123; System.out.println(&quot;初始化方法...&quot;); &#125;</span><br><span class="line">  public void destroy()&#123; System.out.println(&quot;销毁方法...&quot;); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是销毁方法不一定有机会使用，就像关电视一样，直接断电源是来不及调用方法的。</p>
</li>
<li><p>实现 InitializingBean 接口，完成一些Bean的初始化操作</p>
<p>InitializingBean是个规范，定义好了一堆抽象方法和他们的使用时机，我们使用的时候完成相应方法的功能即可，没有多余配置，执行时机早于init-method，在属性设置之后执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class UserDaoImpl implements UserDao, InitializingBean &#123;</span><br><span class="line">  public UserDaoImpl() &#123;System.out.println(&quot;UserDaoImpl创建了...&quot;);&#125;</span><br><span class="line">  public void init()&#123;System.out.println(&quot;初始化方法...&quot;);&#125;</span><br><span class="line">  public void destroy()&#123;System.out.println(&quot;销毁方法...&quot;);&#125;</span><br><span class="line">  </span><br><span class="line">  //执行时机早于init-method配置的方法</span><br><span class="line">  public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">    System.out.println(&quot;InitializingBean...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>import导入配置文件</p>
<p>用于导入其他配置文件，项目变大后，就会导致一个配置文件内容过多，可以将一个配置文件根 据业务某块进行拆分，拆分后，最终通过&lt; import&gt;标签导入到一个主配置文件中，项目加载主配置文件就连同 &lt; import&gt;导入的文件一并加载了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--导入用户模块配置文件--&gt;</span><br><span class="line">&lt;import resource=&quot;classpath:UserModuleApplicationContext.xml&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--导入商品模块配置文件--&gt;</span><br><span class="line">&lt;import resource=&quot;classpath:ProductModuleApplicationContext.xml&quot;/&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>alias 标签是为某个Bean添加别名:</p>
<p>在beanFactory中维护着一个名为aliasMap的Map集合，存储别名和beanName 之间的映射关系</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置UserService--&gt;</span><br><span class="line">&lt;bean id=&quot;userService&quot; name=&quot;bbb&quot; class=&quot;com.itheima.service.impl.UserServiceImpl&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--指定别名--&gt;</span><br><span class="line">&lt;alias name=&quot;userService&quot; alias=&quot;xxx&quot;/&gt;</span><br><span class="line">&lt;alias name=&quot;userService&quot; alias=&quot;yyy&quot;/&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他配置标签</p>
<p>Spring 的 xml 标签大体上分为两类，一种是默认标签，一种是自定义标签 </p>
<p>默认标签：就是不用额外导入其他命名空间约束的标签</p>
<p>Spring的默认标签用到的是Spring的默认命名空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">      xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>上述代码解读：</p>
<ol>
<li><p>xml第一行必须定义为文档声明</p>
<p>   version：版本号  </p>
<p>   encoding：编码方式，告知解析引擎当前文档使用的字符集</p>
</li>
<li><p>xml文档中有且仅有一个根标签</p>
<p>   根标签&lt; beans&gt;&lt; &#x2F;beans&gt;</p>
<p>   xsd文件的前面部分就是它的命名空间</p>
<p>   如spring-beans.xsd的命名空间就是：<code>http://www.springframework.org/schema/beans/spring-beans</code></p>
</li>
<li><p>属性值必须使用引号(单双都可)引起来</p>
</li>
<li><p>标签必须正确关闭</p>
</li>
<li><p>xml标签名称区分大小写</p>
</li>
</ol>
<p>该命名空间约束下的默认标签如下：</p>
<table>
<thead>
<tr>
<th>标签</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>&lt; beans&gt;</td>
<td>一般作为 xml 配置根标签，其他标签都是该标签的子标签<br>嵌套在根标签内，使用profile属性切换开发环境</td>
</tr>
<tr>
<td>&lt; bean&gt;</td>
<td>Bean的配置标签，上面已经详解了，此处不再阐述</td>
</tr>
<tr>
<td>&lt; import&gt;</td>
<td>外部资源导入标签</td>
</tr>
<tr>
<td>&lt; alias&gt;</td>
<td>指定Bean的别名标签，使用较少</td>
</tr>
</tbody></table>
<p>beans切换开发环境：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置测试环境下，需要加载的Bean实例 --&gt;</span><br><span class="line">&lt;beans profile=&quot;test&quot;&gt;&lt;/beans&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置开发环境下，需要加载的Bean实例 --&gt;</span><br><span class="line">&lt;beans profile=&quot;dev&quot;&gt;&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>可以使用以下两种方式指定被激活的环境：</p>
<ol>
<li>使用命令行动态参数，虚拟机参数位置加载 -Dspring.profiles.active&#x3D;test</li>
<li>使用代码的方式设置环境变量 System.setProperty(“spring.profiles.active”,”test”)</li>
</ol>
</li>
</ul>
<h2 id="自定义标签"><a href="#自定义标签" class="headerlink" title="自定义标签"></a>自定义标签</h2><p>schema引入</p>
<p>自定义标签：就是需要额外引入其他命名空间约束，并通过前缀引用的标签</p>
<p>在配置外部的命名空间时 需要提前在pom中导入对应的依赖</p>
<p>自定义标签的 xmlns和xsi:schemaLocation是成对配置的</p>
<ul>
<li><code>xmlns:别名</code>：用来声明引入某个jar包一类的，然后就能用&lt;别名 : 标签名&gt;使用对应的标签</li>
<li><code>xsi:schemaLocation</code>：后跟着的看着像一个网页地址，但实际上定位是我们引入的jar包地址</li>
</ul>
<p>需要的自定义标签可以去对应的官网找</p>
<h2 id="DI注入标签"><a href="#DI注入标签" class="headerlink" title="DI注入标签"></a>DI注入标签</h2><div class="tabs" id="di注入标签"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#di注入标签-1">constructor-arg</button></li><li class="tab"><button type="button" data-href="#di注入标签-2">property</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="di注入标签-1"><p>指定创建类对象时使用哪个构造函数，每一对或者每一个constructor-arg子标签配置一个参数列表中的参数值；如果不配置子标签，则默认使用无参构造方法实例化对象</p>
<p>属性：</p>
<ul>
<li>name属性：通过参数名找到参数列表中对应参数</li>
<li>index属性：通过参数在参数列表中的索引找到参数列表中对应参数，index从0开始：</li>
<li>type属性：通过参数数据类型找到参数列表中对应参数</li>
<li>value属性：设置参数列表参数对应的值，用于设定基本数据类型和String类型的数据</li>
<li>ref属性：如果参数值为非基本数据类型，则可通过ref为参数注入值，其值为另一个bean标签id或name属性的属性值</li>
</ul>
<p>子标签：</p>
<ul>
<li>ref子标签：对应ref属性，该标签name属性的属性值为另一个bean标签id或name属性的属性值；</li>
<li>value子标签：对应value属性,用于设置基本数据类型或String类型的参数值；</li>
<li>list子标签：为数组或List类型的参数赋值</li>
<li>set子标签：为Set集合类型参数赋值</li>
<li>map子标签：为Map集合类型参数赋值</li>
<li>props子标签：为Properties类型的参数赋值</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="di注入标签-2"><p>Bean定义可以具有零个或多个属性。属性元素对应于bean类公开的 JavaBean setter方法。 Spring支持原语，对相同或相关工厂中的其他bean的引用，列表，映射和属性</p>
<p>属性：</p>
<ul>
<li>name属性：通过参数名找到参数列表中对应参数</li>
<li>value子标签：对应value属性,用于设置基本数据类型或String类型的参数值</li>
<li>ref属性：如果参数值为非基本数据类型，则可通过ref为参数注入值，其值为另一个bean标签id或name属性的属性值</li>
</ul>
<p>子标签：</p>
<ul>
<li>ref子标签：对应ref属性，该标签name属性的属性值为另一个bean标签id或name属性的属性值；</li>
<li>value子标签：对应value属性,用于设置基本数据类型或String类型的参数值；</li>
<li>list子标签：为数组或List类型的参数赋值</li>
<li>set子标签：为Set集合类型参数赋值</li>
<li>map子标签：为Map集合类型参数赋值</li>
<li>props子标签：为Properties类型的参数赋值</li>
</ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>

<p>constructor-arg和property的区别：</p>
<ul>
<li>constructor-arg：通过构造函数注入</li>
<li>property：通过setter对应的方法注入</li>
</ul>
<h3 id="Bean的依赖注入配置"><a href="#Bean的依赖注入配置" class="headerlink" title="Bean的依赖注入配置"></a>Bean的依赖注入配置</h3><div class="tabs" id="3"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#3-1">set方法注入</button></li><li class="tab"><button type="button" data-href="#3-2">构造方法进行注入</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="3-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean&gt;</span><br><span class="line">    &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;userDao&quot; value=&quot;haohao&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;name&quot; ref=&quot;userDao&quot;/&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;name&quot; value=&quot;haohao&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>

<p>ref 是 reference 的缩写，用于引用其他Bean的id。</p>
<p>value 用于注入普通 属性值。</p>
<p>依赖注入的数据类型有如下三种：</p>
<ol>
<li>普通数据类型，例如：String、int、boolean等，通过value属性指定</li>
<li>引用数据类型，例如：UserDaoImpl、DataSource等，通过ref属性指定</li>
<li>集合数据类型，例如：List、Map、Properties等，有单独的格式</li>
</ol>
<h3 id="自动装配方式"><a href="#自动装配方式" class="headerlink" title="自动装配方式"></a>自动装配方式</h3><p>如果被注入的属性类型是Bean引用的话，那么可以在 标签中使用 autowire 属性去配置自动注入方式，属 性值有两个：</p>
<ol>
<li>byName：通过属性名自动装配，即去匹配 setXxx 与 id&#x3D;”xxx”（name&#x3D;”xxx”）是否一致</li>
<li>byType：通过Bean的类型从容器中匹配，匹配出多个相同Bean类型时，报错</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.impl.UserServiceImpl&quot;</span><br><span class="line">autowire=&quot;byName&quot;&gt;</span><br><span class="line">&lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.impl.UserServiceImpl&quot;</span><br><span class="line">autowire=&quot;byType&quot;&gt;</span><br></pre></td></tr></table></figure>



<h2 id="getBean方法"><a href="#getBean方法" class="headerlink" title="getBean方法"></a>getBean方法</h2><table>
<thead>
<tr>
<th>方法定义</th>
<th>返回值和参数</th>
</tr>
</thead>
<tbody><tr>
<td>Object getBean (String beanName)</td>
<td>根据beanName从容器中获取Bean实例，要求容器中Bean唯一，返回值为Object，需要强转</td>
</tr>
<tr>
<td>T getBean (Class type)</td>
<td>根据Class类型从容器中获取Bean实例，要求容器中Bean类型唯一，返回值为Class类型实例， 无需强转</td>
</tr>
<tr>
<td>T getBean (String beanName，Class type)</td>
<td>根据beanName从容器中获得Bean实例，返回值为Class类型实例，无需强转</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//根据beanName获取容器中的Bean实例，需要手动强转</span><br><span class="line">UserService userService = (UserService) applicationContext.getBean(&quot;userService&quot;);</span><br><span class="line"></span><br><span class="line">//根据Bean类型去容器中匹配对应的Bean实例，如存在多个匹配Bean则报错</span><br><span class="line">UserService userService2 = applicationContext.getBean(UserService.class);</span><br><span class="line"></span><br><span class="line">//根据beanName获取容器中的Bean实例，指定Bean的Type类型</span><br><span class="line">UserService userService3 = applicationContext.getBean(&quot;userService&quot;,</span><br><span class="line">UserService.class);</span><br></pre></td></tr></table></figure>



<h2 id="Bean的实例化配置"><a href="#Bean的实例化配置" class="headerlink" title="Bean的实例化配置"></a>Bean的实例化配置</h2><p>Spring的实例化方式主要如下两种：</p>
<ul>
<li><p>构造方式实例化：底层通过构造方法对Bean进行实例化</p>
<p>构造方式实例化Bean又分为<strong>无参构造方法实例化</strong>和<strong>有参构造方法实例化</strong>，Spring中配置的几乎都是无参构造该方式</p>
<p>有参构造在实例化Bean时，需要参数的注入，通过标签，嵌入在标签内部提供构造参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt;</span><br><span class="line">  &lt;constructor-arg name=&quot;name&quot; value=&quot;haohao&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>


</li>
<li><p>工厂方式实例化：底层通过调用自定义的工厂方法对Bean进行实例化，具体有3个不同方式</p>
</li>
</ul>
<div class="tabs" id="5"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#5-1">静态工厂方法实例化Bean</button></li><li class="tab"><button type="button" data-href="#5-2">实例工厂方法实例化Bean</button></li><li class="tab"><button type="button" data-href="#5-3">实现FactoryBean规范延迟实例化Bean</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="5-1"><p>静态工厂方法实例化Bean</p>
<p>是定义一个工厂类，提供一个<strong>静态方法</strong>用于生产Bean实例，在将该工厂类及其 静态方法配置给Spring即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//工厂类</span><br><span class="line">public class UserDaoFactoryBean &#123;</span><br><span class="line">//非静态工厂方法</span><br><span class="line">  public static UserDao getUserDao(String name)&#123;</span><br><span class="line">    //可以在此编写一些其他逻辑代码</span><br><span class="line">    return new UserDaoImpl();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.factory.UserDaoFactoryBean&quot; factorymethod=&quot;getUserDao&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;name&quot; value=&quot;haohao&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>&lt; constructor-arg&gt;标签不仅仅是为构造方法传递参数，只要是为了实例化对象而传递的参数都可以通过&lt; constructor-arg&gt;标签完成</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5-2"><p>实例工厂方法实例化Bean</p>
<p>实例工厂方法，也就是非静态工厂方法产生Bean实例，与静态工厂方式比较，该方式需要<strong>先有工厂对象</strong>，在用工厂对象去调用<strong>成员方法</strong>，所以在进行配置时，要先配置工厂Bean，在配置目标Bean</p>
<p>这种方式常用来处理第三方bean</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//工厂类</span><br><span class="line">public class UserDaoFactoryBean2 &#123;</span><br><span class="line">  //非静态工厂方法</span><br><span class="line">  public UserDao getUserDao(String name)&#123;</span><br><span class="line">    //可以在此编写一些其他逻辑代码</span><br><span class="line">    return new UserDaoImpl();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置实例工厂Bean --&gt;</span><br><span class="line">&lt;bean id=&quot;userDaoFactoryBean2&quot; class=&quot;com.itheima.factory.UserDaoFactoryBean2&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置实例工厂Bean的哪个方法作为工厂方法 --&gt;</span><br><span class="line">&lt;bean id=&quot;userDao&quot; factory-bean=&quot;userDaoFactoryBean2&quot; factory-method=&quot;getUserDao&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;name&quot; value=&quot;haohao&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5-3"><p>底层用的多，开发中用的少</p>
<p>上面不管是静态工厂方式还是非静态工厂方式，都是自定义的工厂方法，Spring提供了FactoryBean的接口规范， FactoryBean接口定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface FactoryBean&lt;T&gt; &#123;</span><br><span class="line">  String OBJECT_TYPE_ATTRIBUTE = “factoryBeanObjectType”;</span><br><span class="line">  T getObject() throws Exception; //获得实例对象方法</span><br><span class="line">  Class&lt;?&gt; getObjectType(); //获得实例对象类型方法</span><br><span class="line">  default boolean isSingleton() &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义工厂实现FactoryBean</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class UserDaoFactoryBean3 implements FactoryBean&lt;UserDao&gt; &#123;</span><br><span class="line">  public UserDao getObject() throws Exception &#123;</span><br><span class="line">    return new UserDaoImpl();</span><br><span class="line">  &#125;</span><br><span class="line">  public Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">    return UserDao.class;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置FactoryBean交由Spring管理即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.factory.UserDaoFactoryBean3&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>通过Spring容器根据beanName可以正常获得UserDaoImpl</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext applicationContext = new ClassPathxmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">Object userDao = applicationContext.getBean(&quot;userDao&quot;);</span><br><span class="line">System.out.println(userDao);</span><br></pre></td></tr></table></figure>



<p>延迟解读：</p>
<p><code>ApplicationContext applicationContext = new ClassPathxmlApplicationContext(&quot;applicationContext.xml&quot;);</code><br><code>Object userDao = applicationContext.getBean(&quot;userDao&quot;);</code></p>
<ol>
<li>加载配置文件创建spring容器的时候，getBean方法没有执行，上述代码第一行</li>
<li>执行到getBean方法时，才运用这个方法，然后把对象存入factoryBeanObjectCache中。也就是说，真正要用的时候才创建bean</li>
</ol>
<p>好处：缓存需求，真正要用的时候才创建</p>
<p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231116105646310.png" alt="image-20231116105646310"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>



<h2 id="配置非自定义Bean"><a href="#配置非自定义Bean" class="headerlink" title="配置非自定义Bean"></a>配置非自定义Bean</h2><p>实际开发中有些 功能类并不是我们自己定义的，而是使用的第三方jar包中的，那么，这些Bean要想让Spring进行管理，也需要对 其进行配置</p>
<p>配置非自定义的Bean需要考虑如下两个问题：</p>
<ol>
<li>被配置的Bean的实例化方式是什么？无参构造、有参构造、静态工厂方式还是实例工厂方式</li>
<li>被配置的Bean是否需要注入必要属性</li>
</ol>
<div class="tabs" id="1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#1-1">德鲁伊</button></li><li class="tab"><button type="button" data-href="#1-2">Connection</button></li><li class="tab"><button type="button" data-href="#1-3">日期对象</button></li><li class="tab"><button type="button" data-href="#1-4">SqlSessionFactory</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><p>以德鲁伊为例</p>
<p>实例化方式：无参构造</p>
<p>必要属性：4个基本属性</p>
<ol start="0">
<li><p>引入依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   </span><br></pre></td></tr></table></figure>
</li>
<li><p>加载启动，配置 Druid 数据源交由Spring管理，配置 DruidDataSource</p>
<p>查看源码，它有无参构造和有参构造，用无参构造的方法可以直接在XML中配置bean</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置 DruidDataSource数据源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置必要属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc://localhost:3306/mybatis&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-2"><p>配置Connection交由Spring管理</p>
<p>Connection 的产生是通过DriverManager的静态方法getConnection获取的，可以视为静态工厂方式配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;java.lang.Class&quot; factory-method=&quot;forName&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;className&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;connection&quot; class=&quot;java.sql.DriverManager&quot; factory-method=&quot;getConnection&quot;</span><br><span class="line">scope=&quot;prototype&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;url&quot; value=&quot;jdbc:mysql:///mybatis&quot;/&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;user&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;password&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>这只是用来理解配置第三方bean的，开发不可能用这个方式，connection是被封装好了的</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-3"><p>配置日期对象交由Spring管理</p>
<p>产生一个指定日期格式的对象，原始代码按如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String currentTimeStr = &quot;2023-08-27 07:20:00&quot;;</span><br><span class="line">SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">Date date = simpleDateFormat.parse(currentTimeStr);</span><br></pre></td></tr></table></figure>

<p>可以看成是实例工厂方式，使用Spring配置方式产生Date实例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//先获得工厂对象的bean</span><br><span class="line">&lt;bean id=&quot;simpleDateFormat&quot; class=&quot;java.text.SimpleDateFormat&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;pattern&quot; value=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">//通过上面的工厂bean，调用工厂bean的方法创建时间对象</span><br><span class="line">&lt;bean id=&quot;date&quot; factory-bean=&quot;simpleDateFormat&quot; factory-method=&quot;parse&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;source&quot; value=&quot;2023-08-27 07:20:00&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-4"><ol>
<li><p>配置MyBatis的SqlSessionFactory交由Spring管理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--mybatis框架--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.5.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- mysql驱动 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.49&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置MyBatis的SqlSessionFactory交由Spring管理 MyBatis原始获得SqlSessionFactory的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//加载mybatis核心配置文件，使用Spring静态工厂方式</span><br><span class="line">InputStream in = Resources.getResourceAsStream(“mybatis-conifg.xml”);</span><br><span class="line"></span><br><span class="line">//创建SqlSessionFactoryBuilder对象，使用Spring无参构造方式</span><br><span class="line">SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();</span><br><span class="line"></span><br><span class="line">//调用SqlSessionFactoryBuilder的build方法，使用Spring实例工厂方式</span><br><span class="line">SqlSessionFactory sqlSessionFactory = builder.build(in);</span><br></pre></td></tr></table></figure>

<p>SqlSessionFactory交由Spring管理配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--静态工厂方式产生Bean实例--&gt;</span><br><span class="line">&lt;bean id=“inputStream” class=“org.apache.ibatis.io.Resources&quot; factorymethod=“getResourceAsStream”&gt;</span><br><span class="line">    &lt;constructor-arg name=“resource” value=“mybatis-config.xml/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--无参构造方式产生Bean实例--&gt;</span><br><span class="line">&lt;bean id=&quot;sqlSessionFactoryBuilder&quot; class=&quot;org.apache.ibatis.session.SqlSessionFactoryBuilder&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--实例工厂方式产生Bean实例--&gt;</span><br><span class="line">&lt;bean id=&quot;sqlSessionFactory&quot; factory-bean=&quot;sqlSessionFactoryBuilder&quot; factory-method=&quot;build&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name=&quot;inputStream&quot; ref=&quot;inputStream&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
</ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>



<h2 id="基于xml方式整合第三方框架"><a href="#基于xml方式整合第三方框架" class="headerlink" title="基于xml方式整合第三方框架"></a>基于xml方式整合第三方框架</h2><p>xml整合第三方框架有两种整合方案：</p>
<ol>
<li>不需要自定义名空间，不需要使用Spring的配置文件配置第三方框架本身内容，例如：MyBatis</li>
<li>需要引入第三方框架命名空间，需要使用Spring的配置文件配置第三方框架本身内容，例如：Dubbo</li>
</ol>
<h3 id="Spring整合MyBatis"><a href="#Spring整合MyBatis" class="headerlink" title="Spring整合MyBatis"></a>Spring整合MyBatis</h3><p>MyBatis提供了mybatis-spring.jar专门用于两大框架的整合</p>
<p>Spring整合MyBatis的步骤如下：</p>
<ol>
<li><p>导入MyBatis整合Spring的相关坐标，一共4个：mysql、mybatis、mybatis-spring、spring-jdbc</p>
</li>
<li><p>编写Mapper和Mapper.xml</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface UserMapper &#123;</span><br><span class="line">    List&lt;User&gt; findAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.itheima.dao.UserMapper&quot;&gt;</span><br><span class="line">    &lt;select id=&quot;findAll&quot; resultType=&quot;com.itheima.pojo.User&quot;&gt;</span><br><span class="line">        select * from tb_user</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>


</li>
<li><p>配置SqlSessionFactoryBean和MapperScannerConfigurer</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置数据源--&gt;</span><br><span class="line">&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--配置SqlSessionFactoryBean--&gt;</span><br><span class="line">&lt;bean class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--配置Mapper包扫描--&gt;</span><br><span class="line">&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;basePackage&quot; value=&quot;com.itheima.dao&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写测试代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassPathxmlApplicationContext applicationContext = new ClassPathxmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        UserMapper userMapper = applicationContext.getBean(UserMapper.class);</span><br><span class="line">        List&lt;User&gt; all = userMapper.findAll();</span><br><span class="line">        System.out.println(all);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="原理剖析"><a href="#原理剖析" class="headerlink" title="原理剖析"></a>原理剖析</h3><p>整合包里提供了一个SqlSessionFactoryBean和一个扫描Mapper的配置对象，SqlSessionFactoryBean一旦被实例化，就开始扫描Mapper并通过动态代理产生Mapper的实现类存储到Spring容器中</p>
<p>相关的有如下四个类： </p>
<ol>
<li>SqlSessionFactoryBean：需要进行配置，用于提供SqlSessionFactory</li>
<li>MapperScannerConfigurer：需要进行配置，用于扫描指定mapper注册BeanDefinition</li>
<li>MapperFactoryBean：Mapper的FactoryBean，获得指定Mapper时调用getObject方法</li>
<li>ClassPathMapperScanner：definition.setAutowireMode()修改了自动注入状态，所以MapperFactoryBean中的setSqlSessionFactory会自动注入进去。</li>
</ol>
<h4 id="SqlSessionFactoryBean"><a href="#SqlSessionFactoryBean" class="headerlink" title="SqlSessionFactoryBean"></a>SqlSessionFactoryBean</h4><p>配置SqlSessionFactoryBean作用是向容器中提供SqlSessionFactory，SqlSessionFactoryBean实现了 FactoryBean 和 InitializingBean 两个接口，所以能实现getObject() 和afterPropertiesSet()方法</p>
<p>getObject()用来提供bean，而它里面也确实有getObject()方法，在afterPropertiesSet()方法内部，反回来一个sqlSessionFactory对象</p>
<p>部分源码，这一段证明返回了SqlSessionFactory对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactoryBean implements FactoryBean&lt;SqlSessionFactory&gt;, InitializingBean&#123;</span><br><span class="line">public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">  //创建SqlSessionFactory对象</span><br><span class="line">        this.sqlSessionFactory = this.buildSqlSessionFactory();</span><br><span class="line">   &#125;</span><br><span class="line">   public SqlSessionFactory getObject() throws Exception &#123;</span><br><span class="line">        return this.sqlSessionFactory;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>FactoryBean、InitializingBean 眼不眼熟</p>
</blockquote>
<h4 id="MapperScannerConfigurer"><a href="#MapperScannerConfigurer" class="headerlink" title="MapperScannerConfigurer"></a>MapperScannerConfigurer</h4><p>记住这个名字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置Mapper包扫描--&gt;</span><br><span class="line">&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;basePackage&quot; value=&quot;com.itheima.dao&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>在配置这个扫描器的时候就把mapper注进去了</p>
<p>配置MapperScannerConfigurer作用是扫描Mapper，向容器中注册Mapper对应的MapperFactoryBean</p>
<p>MapperScannerConfigurer实现了BeanDefinitionRegistryPostProcessor和InitializingBean两个接口，会在postProcessBeanDefinitionRegistry方法中向容器中注册MapperFactoryBean</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class MapperScannerConfigurer implements BeanDefinitionRegistryPostProcessor, InitializingBean,ApplicationContextAware,BeanNameAware &#123;</span><br><span class="line">    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) &#123;</span><br><span class="line">        ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);</span><br><span class="line">        scanner.scan(StringUtils.tokenizeToStringArray(this.basePackage, &quot;,; \t\n&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>BeanDefinitionRegistryPostProcessor、InitializingBean、ApplicationContextAware、BeanNameAware 眼不眼熟</p>
<p>BeanDefinitionRegistryPostProcessor：内部有向BDMap注册BD的作用，最终作用是把UserMapper存储到spring容器中</p>
<p>InitializingBean：注入初始化方法</p>
<p>ApplicationContextAware：注入spring容器</p>
<p>BeanNameAware：注入BeanName</p>
</blockquote>
<p>由于有上述各后处理器等组件，所以注册完SqlSessionFactoryBean和MapperScannerConfigurer后，spring会自动把mapper实现类扔到容器里面</p>
<h4 id="加载外部properties"><a href="#加载外部properties" class="headerlink" title="加载外部properties"></a>加载外部properties</h4><p>Spring 整合其他组件时就不像MyBatis这么简单了，例如Dubbo框架在于Spring进行整合时，要使用Dubbo提供的命名空间的扩展方式，自定义了一些Dubbo标签，为了降低学习成本，不在引入Dubbo第三方框架了，以Spring的 context 命名空间去引入mybatis，加载外部properties文件，将键值对存储在Spring容器中</p>
<ol>
<li><p>编写properties文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jdbc.url=jdbc:mysql://localhost:3306/mybatis</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=root</span><br></pre></td></tr></table></figure>
</li>
<li><p>引入context命名空间，在使用context命名空间的标签，使用SpEL表达式在xml或注解中根据key获得value</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置bean，引入spl表达式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="自定义命名空间使用"><a href="#自定义命名空间使用" class="headerlink" title="自定义命名空间使用"></a>自定义命名空间使用</h2><p>外部命名空间标签的执行流程</p>
<ul>
<li>将自定义标签的约束 与 物理约束文件与网络约束名称的约束 以键值对形式存储到一个spring.schemas文件里<br>，该文件存储在类加载路径的 META-INF里，Spring会自动加载到;</li>
<li>将自定义命名空间的名称 与 自定义命名空间的处理器映射关系 以键值对形式存在到一个叫spring.handlers文<br>件里，该文件存储在类加载路径的 META-INF里，Spring会自动加载到;</li>
<li>准备好NamespaceHandler，如果命名空间只有一个标签，那么直接在parse方法中进行解析即可，一般解析结果就是注册该标签对应的BeanDefinition。</li>
<li>如果命名空间里有多个标签，那么可以在init方法中为每个标签都注册一个BeanDefinitionParser，在执行NamespaceHandler的parse方法时在分流给不同的BeanDefinitionParser进行解析(重写doParse方法即可)</li>
</ul>
<h1 id="Bean的创建使用底层"><a href="#Bean的创建使用底层" class="headerlink" title="Bean的创建使用底层"></a>Bean的创建使用底层</h1><h2 id="实例化的基本流程"><a href="#实例化的基本流程" class="headerlink" title="实例化的基本流程"></a>实例化的基本流程</h2><p>Spring容器在进行初始化时，会将xml配置的的信息封装成一个<strong>BeanDefinition</strong>对象，所有的 BeanDefinition存储到一个名为<strong>beanDefinitionMap</strong>的Map集合中去，Spring框架在对该Map进行遍历，使用反射创建<strong>Bean实例对象</strong></p>
<p>创建好的Bean对象存储在一个名为<strong>singletonObjects（单例池）</strong>的Map集合中，当调用getBean方法 时则最终从该Map集合中取出Bean实例对象返回</p>
<p><strong>Bean</strong>对象：封装我们需要的对象</p>
<p><strong>BeanDefinition</strong>对象：封装bean的对象，每个bean都有一个BeanDefinition与之对应</p>
<p><strong>beanDefinitionMap</strong>：集中存储BeanDefinition对象的Map</p>
<p><strong>singletonObjects</strong>：集中存储完全体Bean对象的Map</p>
<p><strong>单例 Bean 实例化的基本流程</strong>：</p>
<ol>
<li>加载xml配置文件，解析获取配置中的每个的信息，封装成一个个的BeanDefinition对象</li>
<li>将BeanDefinition存储在一个名为beanDefinitionMap的Map中</li>
<li>ApplicationContext底层遍历beanDefinitionMap，创建Bean实例对象</li>
<li>创建好的Bean实例对象，被存储到一个名为singletonObjects的Map中</li>
<li>当执行applicationContext.getBean(beanName)时，从singletonObjects去匹配Bean实例返回</li>
</ol>
<p>DefaultListableBeanFactory对象内部维护着一个Map用于存储封装好的BeanDefinitionMap</p>
<blockquote>
<p>DefaultListableBeanFactory眼熟不，最开始提到的Bean工厂的实现类</p>
</blockquote>
<p>Spring框架会取出beanDefinitionMap中的每个BeanDefinition信息，反射构造方法或调用指定的工厂方法生成Bean实例对象，所以只要将BeanDefinition注册到beanDefinitionMap这个Map中，Spring就会进行对应的Bean的实例化操作</p>
<p>Bean实例及单例池singletonObjects， beanDefinitionMap中的BeanDefinition会被转化成对应的Bean实例对象 ，存储到单例池singletonObjects中去，在DefaultListableBeanFactory的上四级父类 DefaultSingletonBeanRegistry中，维护着singletonObjects，源码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultSingletonBeanRegistry extends ... implements ... &#123;</span><br><span class="line">  //存储Bean实例的单例池</span><br><span class="line">  //key:是Bean的beanName，value:是Bean的实例对象</span><br><span class="line">  private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap(256);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109190337461.png" alt="image-20231109190337461"></p>
<h3 id="debug查看"><a href="#debug查看" class="headerlink" title="debug查看"></a>debug查看</h3><p>可以对创建spring容器的那一步进行debug，查看内部存放内容</p>
<p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231118143106703.png" alt="image-20231118143106703"></p>
<p>其中，存放的对象不是对象本身，是BeanDefinition，真正的对象在上面两行的singletonObjects里面</p>
<p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231118143221334.png" alt="image-20231118143221334"></p>
<h2 id="后处理器"><a href="#后处理器" class="headerlink" title="后处理器"></a>后处理器</h2><p>（这里记的不是很清晰，建议网上另找文章）</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qwer123451234123/article/details/124353567">https://blog.csdn.net/qwer123451234123/article/details/124353567</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/623041363">https://zhuanlan.zhihu.com/p/623041363</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/84413599">https://zhuanlan.zhihu.com/p/84413599</a></p>
<p>Spring的后处理器是Spring对外开发的重要扩展点，允许我们介入到Bean的整个实例化流程中来，以达到动态注册 BeanDefinition，动态修改BeanDefinition，以及动态修改Bean的作用。</p>
<p>Spring主要有三&#x3D;四种后处理器：</p>
<ol>
<li><strong>BeanDefinitionRegistryPostProcessor</strong>：beanDefinition后置处理器，可以动态注册自己的beanDefinition，可以加载classpath之外的bean</li>
<li><strong>BeanFactoryPostProcessor</strong>：Bean工厂后处理器，在BeanDefinitionMap填充完毕，Bean实例化之前执行，它修改的对象是BeanDefinition，可以认为是模具，后面所有的bean都会受影响</li>
<li><strong>BeanPostProcessor</strong>：Bean后处理器，一般在Bean实例化之后，填充到单例池singletonObjects之前执行。它修改的对象是单个Bean，只影响一个</li>
<li><strong>InitializingBean</strong>：</li>
</ol>
<blockquote>
<p>根据上面各个处理器的功能作用描述可以得到三个处理器的执行顺序：</p>
<p>BeanDefinitionRegistryPostProcessor → BeanFactoryPostProcessor → BeanPostProcessor</p>
</blockquote>
<div class="tabs" id="6"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#6-1">BeanFactoryPostProcessor</button></li><li class="tab"><button type="button" data-href="#6-2">BeanDefinitionRegistryPostProcessor</button></li><li class="tab"><button type="button" data-href="#6-3">BeanPostProcessor</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="6-1"><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109193430419.png" alt="image-20231109193430419"></p>
<p>BeanFactoryPostProcessor是一个接口规范，实现了该接口的类只要交由Spring容器管理的话，那么Spring就会回调该接口的方法，用于对BeanDefinition注册和修改的功能</p>
<p>postProcessBeanFactory 参数本质就是 DefaultListableBeanFactory，拿到BeanFactory的引用，自然就可对beanDefinitionMap中的BeanDefinition进行操作了</p>
<p>BeanFactoryPostProcessor接口定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanFactoryPostProcessor &#123;</span><br><span class="line">  void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>模拟使用BeanFactoryPostProcessor：</p>
<ol>
<li><p>编写BeanFactoryPostProcessor实现类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException&#123;</span><br><span class="line">    System.out.println(&quot;MyBeanFactoryPostProcessor执行了...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里拿到了beanFactory，那自然可以对内部的Map进行处理，但是为了安全起见，它不让我们拿到整个Map，我们只能单个BD的拿（内部方法 <code>getBeanDefinition(beanName)</code>）</p>
<ul>
<li><p>比如对UserDaoImpl的BeanDefinition进行修改操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor &#123;</span><br><span class="line">  public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;</span><br><span class="line">    //获得UserDao定义对象</span><br><span class="line">    BeanDefinition userDaoBD = beanFactory.getBeanDefinition(“userDao”);</span><br><span class="line">    </span><br><span class="line">    //修改class</span><br><span class="line">    userDaoBD.setBeanClassName(&quot;com.itheima.dao.impl.UserDaoImpl2&quot;); </span><br><span class="line">    </span><br><span class="line">    //修改初始化方法</span><br><span class="line">    //userDaoBD.setInitMethodName(methodName); </span><br><span class="line">    </span><br><span class="line">    //修改是否懒加载</span><br><span class="line">    //userDaoBD.setLazyInit(true); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对BeanDefiition进行注册操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException &#123;</span><br><span class="line">  </span><br><span class="line">    //强转成子类DefaultListableBeanFactory，不然没有registerBeanDefinition方法</span><br><span class="line">    if(configurableListableBeanFactory instanceof DefaultListableBeanFactory)&#123;</span><br><span class="line">      DefaultListableBeanFactory beanFactory = (DefaultListableBeanFactory) configurableListableBeanFactory;</span><br><span class="line">      </span><br><span class="line">      //注册beanDefinition对象</span><br><span class="line">      BeanDefinition beanDefinition = new RootBeanDefinition();</span><br><span class="line">      </span><br><span class="line">      //获取bean对象信息</span><br><span class="line">      beanDefinition.setBeanClassName(&quot;com.itheima.dao.UserDaoImpl2&quot;);</span><br><span class="line">      </span><br><span class="line">      //进行注册操作</span><br><span class="line">      beanFactory.registerBeanDefinition(&quot;userDao2&quot;,beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>配置BeanFactoryPostProcessor</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;com.itheima.processor.MyBeanFactoryPostProcessor&quot;/&gt;</span><br></pre></td></tr></table></figure></li>
</ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6-2"><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109193430419.png" alt="image-20231109193430419"></p>
<p>Spring 提供了一个BeanFactoryPostProcessor的子接口BeanDefinitionRegistryPostProcessor专门用于注册 BeanDefinition操作，想实现注册直接用这个子接口就行了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class MyBeanFactoryPostProcessor2 implements BeanDefinitionRegistryPostProcessor &#123;</span><br><span class="line">  @Override</span><br><span class="line">  //这个是父接口BeanFactoryPostProcessor的，所以一定要实现</span><br><span class="line">  public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  //这个是专门用来这次的方法</span><br><span class="line">  public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry beanDefinitionRegistry) throws BeansException &#123;</span><br><span class="line">    //注册beanDefinition对象</span><br><span class="line">    BeanDefinition beanDefinition = new RootBeanDefinition();</span><br><span class="line">    //获取bean对象信息</span><br><span class="line">    beanDefinition.setBeanClassName(&quot;com.itheima.dao.UserDaoImpl2&quot;);</span><br><span class="line">    //进行注册操作</span><br><span class="line">    beanDefinitionRegistry.registerBeanDefinition(&quot;userDao2&quot;,beanDefinition);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6-3"><p>Bean被实例化后，到最终缓存到名为singletonObjects单例池之前，中间会经过Bean的初始化过程</p>
<p>例如：属性的填充、初始方法init的执行等，其中有一个对外进行扩展的点BeanPostProcessor，我们称为Bean后处理。</p>
<p>跟上面的 Bean工厂后处理器相似，它也是一个接口，实现了该接口并被容器管理的BeanPostProcessor，会在流程节点上被 Spring自动调用。</p>
<p>BeanPostProcessor的接口定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public interface BeanPostProcessor &#123;</span><br><span class="line"></span><br><span class="line">  @Nullable</span><br><span class="line">  //在属性注入完毕，初始化方法执行之前被回调</span><br><span class="line">  default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">    return bean;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Nullable</span><br><span class="line">  //在初始化方法执行之后，被添加到单例池singletonObjects之前被回调</span><br><span class="line">  default Object postProcessAfterInitialization(Object bean, String beanName) throws</span><br><span class="line">BeansException &#123;</span><br><span class="line">    return bean;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义MyBeanPostProcessor，完成快速入门测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class MyBeanPostProcessor implements BeanPostProcessor &#123;</span><br><span class="line"></span><br><span class="line">/* 参数： bean是当前被实例化的Bean，beanName是当前Bean实例在容器中的名称</span><br><span class="line">返回值：当前Bean实例对象 */</span><br><span class="line"></span><br><span class="line">  public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">    System.out.println(&quot;BeanPostProcessor的before方法...&quot;);</span><br><span class="line">    return bean;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">/* 参数： bean是当前被实例化的Bean，beanName是当前Bean实例在容器中的名称</span><br><span class="line">返回值：当前Bean实例对象 */</span><br><span class="line"></span><br><span class="line">  public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">    System.out.println(&quot;BeanPostProcessor的after方法...&quot;);</span><br><span class="line">    return bean;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置MyBeanPostProcessor</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;com.itheima.processors.MyBeanPostProcessor&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109193635396.png" alt="image-20231109193635396"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>

<p>proxy代理?</p>
<p>动态代理？</p>
<h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231116111100188.png" alt="image-20231116111100188"></p>
<p>Spring Bean的生命周期是从 Bean 实例化之后，即通过反射创建出对象之后，到Bean成为一个完整对象，最终存储到单例池中，这个过程被称为Spring Bean的生命周期。Spring Bean的生命周期大体上分为三个阶段：</p>
<ol>
<li><p>实例化阶段</p>
<p>Spring框架会取出BeanDefinition的信息进行判断当前Bean的范围是否是singleton的， 是否不是延迟加载的，是否不是FactoryBean等一系列的 if 判断，以及一些其他方法，最终将一个普通的singleton的Bean通过反射进行实例化</p>
</li>
<li><p>初始化阶段</p>
<p>Bean创建之后还仅仅是个”半成品”，还需要对Bean实例的属性进行填充、执行一些 Aware 接口方法、执行BeanPostProcessor方法、执行InitializingBean接口的初始化方法、执行自定义初始化init方法 等。</p>
<p>该阶段是Spring最具技术含量和复杂度的阶段，Aop增强功能，Spring的注解功能等都是通过这里实现的</p>
</li>
<li><p>完成阶段</p>
<p>经过初始化阶段，Bean就成为了一个完整的Spring Bean，被存储到单例池 singletonObjects中去了，即完成了Spring Bean的整个生命周期</p>
</li>
</ol>
<h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><p>Spring Bean的初始化过程涉及如下几个过程：</p>
<ul>
<li>Bean实例的属性填充</li>
<li>Aware接口属性注入</li>
<li>BeanPostProcessor 的 before() 方法回调 </li>
<li>InitializingBean 接口的初始化方法回调</li>
<li>自定义初始化方法init回调</li>
<li>BeanPostProcessor的after()方法回调</li>
</ul>
<h4 id="Bean实例的属性填充"><a href="#Bean实例的属性填充" class="headerlink" title="Bean实例的属性填充"></a>Bean实例的属性填充</h4><p>BeanDefinition 中有对当前Bean实体的注入信息通过属性propertyValues进行了存储，这些属性也被封装了</p>
<p>Spring容器中有一个BeanFactory，BeanFactory中有BeanDefinitionMap，BeanDefinitionMap中有propertyValues</p>
<p>例如UserService的属性信息如下</p>
<p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109193947579.png" alt="image-20231109193947579"></p>
<p>Spring在进行属性注入时，会分为如下三种情况：</p>
<ul>
<li>注入普通属性，String、int或存储基本类型的集合时，直接通过set方法的反射设置进去</li>
<li>注入单向对象引用属性时，从容器中getBean获取后通过set方法反射设置进去，如果容器中没有，则先创建被注入对象Bean实例（完成整个生命周期）后，在进行注入操作</li>
<li>注入双向对象引用属性时，就比较复杂了，涉及了循环引用（循环依赖）问题</li>
</ul>
<h5 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h5><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109194114161.png" alt="image-20231109194114161"></p>
<p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109194313661.png" alt="image-20231109194313661"></p>
<p>Bean只需要其他的Bean完成自己的创建，但是不会去干涉其他Bean的创建，可以把半成品的Bean拿去先凑个数然后实现自己的创建（用结果当条件去证结果）</p>
<p>因为new以后地址不会变，所以能保证半成品和成品都在同一个位置，不影响使用</p>
<p>Spring提供了<strong>三级缓存</strong>，保存<strong>完整Bean对象</strong> 和 <strong>半成品Bean对象</strong> ，用于解决循环引用问题，在DefaultListableBeanFactory的上四级父类DefaultSingletonBeanRegistry中提供如下三个Map：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultSingletonBeanRegistry ... &#123;</span><br><span class="line">  //1、最终存储单例Bean成品的容器，即实例化和初始化都完成的Bean，称之为&quot;一级缓存&quot;</span><br><span class="line">  Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap(256);</span><br><span class="line">  //2、早期Bean单例池，缓存半成品对象，且当前对象已经被其他对象引用了，称之为&quot;二级缓存&quot;</span><br><span class="line">  Map&lt;String, Object&gt; earlySingletonObjects = new ConcurrentHashMap(16);</span><br><span class="line">  //3、单例Bean的工厂池，缓存半成品对象，对象未被引用，使用时在通过工厂创建Bean，称之为&quot;三级缓存&quot;</span><br><span class="line">  Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap(16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一级缓存：最终存储单例Bean成品的容器，即实例化和初始化都完成的Bean，容量256</li>
<li>二级缓存：早期Bean单例池，缓存半成品对象，且当前对象已经被其他对象引用了，容量16</li>
<li>三级缓存：单例Bean的工厂池，缓存半成品对象，对象未被引用，使用时在通过工厂创建Bean，容量16</li>
</ul>
<p>UserService和UserDao循环依赖的过程结合上述三级缓存描述一下：</p>
<ol>
<li>UserService 实例化对象，但尚未初始化，将UserService存储到三级缓存</li>
<li>UserService 属性注入，需要UserDao，从缓存中获取，没有UserDao</li>
<li>UserDao实例化对象，但尚未初始化，将UserDao存储到到三级缓存</li>
<li>UserDao属性注入，需要UserService，从三级缓存获取UserService，UserService从三级缓存移入二级缓存</li>
<li>UserDao执行其他生命周期过程，最终成为一个完成Bean，存储到一级缓存，删除二三级缓存</li>
<li>UserService 注入UserDao</li>
<li>UserService执行其他生命周期过程，最终成为一个完成Bean，存储到一级缓存，删除二三级缓存</li>
</ol>
<h4 id="Aware接口属性注入"><a href="#Aware接口属性注入" class="headerlink" title="Aware接口属性注入"></a>Aware接口属性注入</h4><p>Aware接口是一种框架辅助属性注入的一种思想，其他框架中也可以看到类似的接口。框架具备高度封装性，我们接触到的一般都是业务代码，一个底层功能API不能轻易的获取到，但是这不意味着永远用不到这些对象，如果用到了，就可以使用框架提供的类似Aware的接口，让框架给我们注入该对象</p>
<p>大致就是普通人（普通bean）想访问机密文件，本来应该是不允许的，但是这个普通人在这个时候有了权限（实现相关方法），就能访问机密文件</p>
<table>
<thead>
<tr>
<th>Aware接口</th>
<th>回调方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>ServletContextAware</td>
<td>setServletContext(ServletContext context)</td>
<td>Spring框架回调方法注入ServletContext对象，web环境下才生效</td>
</tr>
<tr>
<td>BeanFactoryAware</td>
<td>setBeanFactory(BeanFactory factory)</td>
<td>Spring框架回调方法注入beanFactory对象</td>
</tr>
<tr>
<td>BeanNameAware</td>
<td>setBeanName(String beanName)</td>
<td>Spring框架回调方法注入当前Bean在容器中的beanName</td>
</tr>
<tr>
<td>ApplicationContextAware</td>
<td>setApplicationContext(ApplicationContext applicationContext)</td>
<td>Spring框架回调方法注入applicationContext对象</td>
</tr>
</tbody></table>
<p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231116111100188.png" alt="image-20231116111100188"></p>
<h2 id="Bean创建整体流程总结"><a href="#Bean创建整体流程总结" class="headerlink" title="Bean创建整体流程总结"></a>Bean创建整体流程总结</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109190337461.png" alt="image-20231109190337461"></p>
<p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109221132853.png" alt="image-20231109221132853"></p>
<p>功能增强都是基于这张图实现的，在相应的地方增强功能。</p>
<p>P56 回忆了bean创建的流程，忘记了回来看</p>
<h1 id="基于注解的Spring应用"><a href="#基于注解的Spring应用" class="headerlink" title="基于注解的Spring应用"></a>基于注解的Spring应用</h1><p>Spring除了xml配置文件进行配置之外，还可以使用注解方式进行配置，注解方式慢慢成为xml配置的替代方案</p>
<p>Spring提供的注解有三个版本：</p>
<ul>
<li>2.0时代，Spring开始出现注解</li>
<li>2.5时代，Spring的Bean配置可以使用注解完成</li>
<li>3.0时代，Spring其他配置也可以使用注解完成，我们进入全注解时代</li>
</ul>
<p>但是XML和他的原理是spring的根基，spring的很多强大功能都是<strong>基于XML</strong>，通过几个<strong>后处理器</strong>增强的</p>
<h2 id="Bean注解开发"><a href="#Bean注解开发" class="headerlink" title="Bean注解开发"></a>Bean注解开发</h2><p>Bean注解开发实质：</p>
<ol>
<li>用注解的方式替代原有的xml标签及其标签属性的配置</li>
<li>用核心配置类替换Xml文件</li>
</ol>
<h3 id="Bean标签替换"><a href="#Bean标签替换" class="headerlink" title="Bean标签替换"></a>Bean标签替换</h3><p>使用@Component 注解替代Bean标签，被该注解标识的类，会在指定扫描范围内被Spring加载并注册成Bean</p>
<p>XML中：</p>
<ul>
<li>id：Bean的名字</li>
<li>class：Bean对应的类的全类名，通过反射创建对象</li>
</ul>
<p>@Component：</p>
<ul>
<li><p>value属性指定当前Bean实例的beanName，也可以省略不写，不写的情况下为当前类名首字母小写</p>
<p><code>@Component(value=&quot;userDao&quot;)</code> <code>@Component(&quot;userDao&quot;)</code> <code>@Component()</code>都可以</p>
</li>
<li><p>@Component直接配置在相应类上，指出类的路径</p>
</li>
</ul>
<h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><ol>
<li><p>用注解定义bean</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//获取方式：applicationContext.getBean(&quot;userDao&quot;);</span><br><span class="line">@Component(&quot;userDao&quot;)</span><br><span class="line">public class UserDaoImpl implements UserDao &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//获取方式：applicationContext.getBean(&quot;userDaoImpl&quot;);</span><br><span class="line">@Component</span><br><span class="line">public class UserDaoImpl implements UserDao &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置xml文件，声明要使用注解，并指出扫描的基本包和其子包，要配置组件扫描路径</p>
<p>这个也能被标签替代</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 告知Spring框架去itheima包及其子包下去扫描使用了注解的类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>底层是通过后处理器来实现扫包的效果</p>
</li>
</ol>
<h3 id="Bean其他属性"><a href="#Bean其他属性" class="headerlink" title="Bean其他属性"></a>Bean其他属性</h3><p>@Component就单纯一个value属性，这个属性配置了Bean的名字，其余属性也可以通过注解方式去配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;&quot; name=&quot;&quot; class=&quot;&quot; scope=&quot;&quot; lazy-init=&quot;&quot; init-method=&quot;&quot; destroy-method=&quot;&quot;</span><br><span class="line">abstract=&quot;&quot; autowire=&quot;&quot; factory-bean=&quot;&quot; factory-method=&quot;&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>xml配置</th>
<th>注解</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&lt; bean scope&#x3D;””&gt;</td>
<td>@Scope</td>
<td>在类上或使用了@Bean标注的方法上，标注Bean的作用范围，取值为 singleton或prototype</td>
</tr>
<tr>
<td>&lt; bean lazy-init&#x3D;””&gt;</td>
<td>@Lazy</td>
<td>在类上或使用了@Bean标注的方法上，标注Bean是否延迟加载，取值为 true和false</td>
</tr>
<tr>
<td>&lt; bean init-method&#x3D;””&gt;</td>
<td>@PostConstruct</td>
<td>在方法上使用，标注Bean的实例化后执行的方法</td>
</tr>
<tr>
<td>&lt; bean destroy-method&#x3D;””&gt;</td>
<td>@PreDestroy</td>
<td>在方法上使用，标注Bean的销毁前执行方法</td>
</tr>
</tbody></table>
<p>使用上述注解完成UserDaoImpl的基本配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Component(&quot;userDao&quot;)</span><br><span class="line">@Scope(&quot;singleton&quot;)</span><br><span class="line">@Lazy(true)</span><br><span class="line">public class UserDaoImpl implements UserDao&#123;</span><br><span class="line"></span><br><span class="line">  @PostConstruct</span><br><span class="line">  public void init()&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  @PreDestroy</span><br><span class="line">  public void destroy()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="分层设计"><a href="#分层设计" class="headerlink" title="分层设计"></a>分层设计</h3><p>由于JavaEE开发是分层的，为了每层Bean标识的注解语义化更加明确，@Component又衍生出如下三个注解</p>
<table>
<thead>
<tr>
<th>@Component衍生注解</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>@Repository</td>
<td>在Dao层类上使用</td>
</tr>
<tr>
<td>@Service</td>
<td>在Service层类上使用</td>
</tr>
<tr>
<td>@Controller</td>
<td>在Web层类上使用</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Repository(&quot;userDao&quot;)</span><br><span class="line">public class UserDaoImpl implements UserDao&#123;&#125;</span><br><span class="line"></span><br><span class="line">@Service(&quot;userService&quot;)</span><br><span class="line">public class UserServiceImpl implements UserService&#123;&#125;</span><br><span class="line"></span><br><span class="line">@Controller(&quot;userService&quot;)</span><br><span class="line">public class UserController &#123;&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Bean依赖注入注解开发"><a href="#Bean依赖注入注解开发" class="headerlink" title="Bean依赖注入注解开发"></a>Bean依赖注入注解开发</h2><p>XML中，原来用&lt; porperty&gt; 给Bean配置，中间用value和ref属性来配置普通类型和引用对象</p>
<p>Spring主要提供如下注解，用于在Bean内部进行属性注入的</p>
<table>
<thead>
<tr>
<th>属性注入注解</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>@Value</td>
<td>使用在字段或方法上，用于注入普通数据</td>
</tr>
<tr>
<td>@Autowired</td>
<td>使用在字段或方法上，用于根据类型（byType）注入引用数据</td>
</tr>
<tr>
<td>@Qualifier</td>
<td>使用在字段或方法上，结合@Autowired，根据名称注入</td>
</tr>
<tr>
<td>@Resource</td>
<td>使用在字段或方法上，根据类型或名称进行注入</td>
</tr>
</tbody></table>
<ul>
<li><p>通过@Value 直接注入普通属性，通过反射暴力创建的对象，可以在属性或者方法上配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//属性上配置</span><br><span class="line">@Value(&quot;haohao&quot;)</span><br><span class="line">private String username;</span><br><span class="line"></span><br><span class="line">//方法上配置</span><br><span class="line">@Value(&quot;haohao&quot;)</span><br><span class="line">public void setUsername(String username)&#123;</span><br><span class="line">  System.out.println(username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样就写死了，没意义而且加大了复杂度，下面的使用有一定的意义</p>
</li>
<li><p>通过@Value 注入properties文件中的属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span><br><span class="line">private String username;</span><br><span class="line"></span><br><span class="line">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span><br><span class="line">public void setUsername(String username)&#123;</span><br><span class="line">  System.out.println(username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加载properties文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>@Autowired注解，用于根据类型进行注入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//使用在属性上直接注入</span><br><span class="line">@Autowired</span><br><span class="line">private UserDao userDao;</span><br><span class="line"></span><br><span class="line">//使用在方法上直接注入</span><br><span class="line">@Autowired</span><br><span class="line">public void setUserDao(UserDao userDao)&#123;</span><br><span class="line">System.out.println(userDao);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当容器中同一类型的Bean实例有多个时，会尝试自动根据名字进行匹配，没有名字一样的就会报错</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//匹配当前Bean</span><br><span class="line">@Repository(&quot;userDao&quot;)</span><br><span class="line">public class UserDaoImpl implements UserDao&#123;&#125;</span><br><span class="line"></span><br><span class="line">@Repository(&quot;userDao2&quot;)</span><br><span class="line">public class UserDaoImpl2 implements UserDao&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>@Qualifier配合@Autowired可以完成根据名称注入Bean实例，使用@Qualifier指定名称</p>
<p>@Qualifier是可以单用的，只是这里联合使用了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">@Qualifier(&quot;userDao2&quot;)</span><br><span class="line">private UserDao userDao;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">@Qualifier(&quot;userDao2&quot;)</span><br><span class="line">public void setUserDao(UserDao userDao)&#123;</span><br><span class="line">  System.out.println(userDao);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>@Resource注解既可以根据类型注入，也可以根据名称注入，无参就是根据类型注入，有参数就是根据名称注入，本来是Java的注解，但是被spring拿来用了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Resource</span><br><span class="line">private UserDao userDao;</span><br><span class="line"></span><br><span class="line">@Resource(name = &quot;userDao2&quot;)</span><br><span class="line">public void setUserDao(UserDao userDao)&#123;</span><br><span class="line">  System.out.println(userDao);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Resource注解存在与 javax.annotation 包中，Spring对其进行了解析</p>
</li>
</ul>
<h2 id="非自定义Bean注解开发"><a href="#非自定义Bean注解开发" class="headerlink" title="非自定义Bean注解开发"></a>非自定义Bean注解开发</h2><p>非自定义Bean一般存在于jar包中，不能像自定义Bean一样使用@Component进行管理，要使用@Bean通过工厂方式进行实例化，@Bean(“Bean的名字”)</p>
<p>@Bean的参数 &#x3D; 方法返回值的名字 &#x3D; Bean名字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//将方法返回值Bean实例以@Bean注解指定的名称存储到Spring容器中</span><br><span class="line">@Bean(&quot;dataSource&quot;)</span><br><span class="line">public DataSource dataSource()&#123;</span><br><span class="line">  DruidDataSource dataSource = new DruidDataSource();</span><br><span class="line">  dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">  dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/mybatis&quot;);</span><br><span class="line">  dataSource.setUsername(&quot;root&quot;);</span><br><span class="line">  dataSource.setPassword(&quot;root&quot;);</span><br><span class="line">  return dataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工厂方法所在类必须要被Spring管理</p>
<p>如果@Bean工厂方法需要参数的话，则有如下三种注入方式：</p>
<ol>
<li>使用@Autowired 根据类型自动进行Bean的匹配，@Autowired可以省略 </li>
<li>使用@Qualifier 根据名称进行Bean的匹配</li>
<li>使用@Value 根据名称进行普通数据类型匹配</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">@Autowired //根据类型匹配参数</span><br><span class="line">public Object objectDemo01(UserDao userDao)&#123;</span><br><span class="line">  System.out.println(userDao);</span><br><span class="line">  return new Object();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public Object objectDemo02(@Qualifier(&quot;userDao&quot;) UserDao userDao,</span><br><span class="line">  @Value(&quot;$&#123;jdbc.username&#125;&quot;) String username)&#123;</span><br><span class="line">  System.out.println(userDao);</span><br><span class="line">  System.out.println(username);</span><br><span class="line">  return new Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>细节：</p>
<ol>
<li><p>不加名字行不行？</p>
<p>可以的，默认名字是方法的名字，注意，是<strong>方法的名字</strong></p>
</li>
<li><p>这是用工厂方法生产的，方法存在于对象中，所以，对象bean必须要能扫到</p>
</li>
<li><p>需要其他参数时候怎么办？</p>
<p>和前面给bean配置参数一样，前面怎么配置，这里怎么配置</p>
</li>
</ol>
<h2 id="Bean配置类"><a href="#Bean配置类" class="headerlink" title="Bean配置类"></a>Bean配置类</h2><p>@Component等注解替代了标签，但是像&lt; import&gt;、 &lt; context:componentScan&gt;等非标签怎 去使用注解替代呢？</p>
<p>定义一个配置类替代原有的xml配置文件，标签以外的标签，一般都是在配置类上使用注解完成的</p>
<div class="tabs" id=""><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#-1"><i class="Configuration" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#-2"><i class="ComponentScan" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#-3"><i class="PropertySource" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#-4"><i class="Import" style="text-align: center;"></i></button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="-1"><p>@Configuration：标识的类为配置类，替代原有xml配置文件，有2个作用</p>
<ol>
<li><p>标识该类是一个配置类</p>
</li>
<li><p>具备@Component作用，配置类也是一个组件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class ApplicationContextConfig &#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-2"><p>@ComponentScan：组件扫描配置，替代原有xml文件中的&lt;context:component-scan base-package&#x3D;””&#x2F;&gt;，指出扫描的基本类路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(base-package = &#123;&quot;com.itheima.service&quot;,&quot;com.itheima.dao&quot;&#125;)</span><br><span class="line">public class ApplicationContextConfig &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>base-package的配置方式：</p>
<ol>
<li>指定一个或多个包名：扫描指定包及其子包下使用注解的类</li>
<li>不配置包名：扫描当前@componentScan注解配置类所在包及其子包下的类</li>
</ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-3"><p>@PropertySource：用于加载外部properties资源配置，替代原有xml中的&lt;context:propertyplaceholder location&#x3D;“位置”&#x2F;&gt; 配置，指出去哪里找配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan</span><br><span class="line">@PropertySource(&#123;&quot;classpath:jdbc.properties&quot;,&quot;classpath:xxx.properties&quot;&#125;)</span><br><span class="line">public class ApplicationContextConfig &#123;&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-4"><p>@Import 用于加载其他配置类，替代原有xml中的&lt; import resource&#x3D;”classpath:beans.xml”&#x2F;&gt;配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan</span><br><span class="line">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span><br><span class="line">@Import(OtherConfig.class)</span><br><span class="line">public class ApplicationContextConfig &#123;&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>

<h3 id="更换spring容器实现类"><a href="#更换spring容器实现类" class="headerlink" title="更换spring容器实现类"></a>更换spring容器实现类</h3><p>原先使用的是根据路径加载配置的spring容器实现类<code>ClassPathXmlApplicationContext</code> 和 <code>FileSystemXmlApplicationContext</code></p>
<p>现在配置文件都没了，更换为用注解加载配置的spring容器实现类<code>AnnotationConfigApplicationContext</code></p>
<h2 id="Spring-配置其他注解"><a href="#Spring-配置其他注解" class="headerlink" title="Spring 配置其他注解"></a>Spring 配置其他注解</h2><h3 id="Primary"><a href="#Primary" class="headerlink" title="@Primary"></a>@Primary</h3><p>@Primary注解用于标注相同类型的Bean优先被使用权</p>
<p>@Primary 是Spring3.0引入的，与@Component 和@Bean一起使用，标注该Bean的优先级更高，则在通过类型获取Bean或通过@Autowired根据类型进行注入时， 会选用优先级更高的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Repository(&quot;userDao&quot;)</span><br><span class="line">public class UserDaoImpl implements UserDao&#123;&#125;</span><br><span class="line">@Repository(&quot;userDao2&quot;)</span><br><span class="line">@Primary</span><br><span class="line">public class UserDaoImpl2 implements UserDao&#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public UserDao userDao01()&#123;return new UserDaoImpl();&#125;</span><br><span class="line">@Bean</span><br><span class="line">@Primary</span><br><span class="line">public UserDao userDao02()&#123;return new UserDaoImpl2();&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Profile"><a href="#Profile" class="headerlink" title="@Profile"></a>@Profile</h3><p>@Profile 注解的作用同于xml配置时学习profile属性，是进行环境切换使用的</p>
<p>注解 @Profile 标注在类或方法上，标注当前产生的Bean从属于哪个环境，只有激活了当前环境，被标注的Bean才能被注册到Spring容器里，不指定环境的Bean，即没有加这个注解的Bean，任何环境下都能注册到Spring容器里</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans profile=&quot;test&quot;&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Repository(&quot;userDao&quot;)</span><br><span class="line">@Profile(&quot;test&quot;)</span><br><span class="line">public class UserDaoImpl implements UserDao&#123;&#125;</span><br><span class="line">@Repository(&quot;userDao2&quot;)</span><br><span class="line">public class UserDaoImpl2 implements UserDao&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用以下两种方式指定被激活的环境：</p>
<ol>
<li>使用命令行动态参数，虚拟机参数位置加载 -Dspring.profiles.active&#x3D;test</li>
<li>使用代码的方式设置环境变量 System.setProperty(“spring.profiles.active”,”test”);</li>
</ol>
<h2 id="Spring注解的解析原理"><a href="#Spring注解的解析原理" class="headerlink" title="Spring注解的解析原理"></a>Spring注解的解析原理</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231110210128599.png" alt="image-20231110210128599"></p>
<p> 使用@Component等注解配置完毕后，要配置组件扫描才能使注解生效</p>
<ol>
<li><p>xml配置组件扫描</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:component-scan base-package=&quot;com.itheima&quot;/&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置类配置组件扫描</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.itheima&quot;)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231119181600269.png" alt="image-20231119181600269"></p>
<h3 id="xml方式"><a href="#xml方式" class="headerlink" title="xml方式"></a>xml方式</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/question-sky/p/6953315.html%EF%BC%8C%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E8%AE%B2%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E7%9C%8B">https://www.cnblogs.com/question-sky/p/6953315.html，这篇文章讲相关内容，可以看看</a></p>
<p>component-scan是一个context命名空间下的自定义标签，最终对应他的命名空间处理器NamespaceHandler 和 解析器</p>
<p>查看spring-context包下的spring.handlers文件：ExtrrnalLibraries -&gt; Maven…:spring-context -&gt; META INF -&gt; spring.handlers</p>
<p>对应的是ComponentScanBeanDefinitionParser类，它内部的Parse方法会被解析</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">	public BeanDefinition parse(Element element, ParserContext parserContext) &#123;</span><br><span class="line">	</span><br><span class="line">		//解析base-package属性值，扫描的包可以,;分隔</span><br><span class="line">		String[] basePackages = StringUtils.tokenizeToStringArray(element.getAttribute(BASE_PACKAGE_ATTRIBUTE),			ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);</span><br><span class="line"></span><br><span class="line">		// Actually scan for bean definitions and register them.</span><br><span class="line">		ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element);</span><br><span class="line">		</span><br><span class="line">		//通过ClassPathBeanDefinitionScanner扫描类来获取包名下的所有class并将他们注册到spring的bean工厂中</span><br><span class="line">		Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages);</span><br><span class="line">		</span><br><span class="line">		//注册其他注解组件</span><br><span class="line">		registerComponents(parserContext.getReaderContext(), beanDefinitions, element);</span><br><span class="line">		return null;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>其中doScan的源码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123;</span><br><span class="line">		//表明base-package属性是需要被指定的</span><br><span class="line">		Assert.notEmpty(basePackages, &quot;At least one base package must be specified&quot;);</span><br><span class="line">		Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet&lt;BeanDefinitionHolder&gt;();</span><br><span class="line">		for (String basePackage : basePackages) &#123;</span><br><span class="line">			//对每个基础包都进行扫描寻找并且对基础包下的所有class都注册为BeanDefinition</span><br><span class="line">                        /**</span><br><span class="line">                        **</span><br><span class="line">                        **并对得到的candidates集合进行过滤，此处便用到include-filters和exclude-filters</span><br><span class="line">                        */</span><br><span class="line">			Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">			for (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">				//解析一个bean的scope属性，代表作用范围</span><br><span class="line">				//prototype-&gt;每次请求都创建新的对象 singleton-&gt;单例模式，处理多请求</span><br><span class="line">				ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">				candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">				//使用beanName生成器生成</span><br><span class="line">				String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry);</span><br><span class="line">				/**</span><br><span class="line">				**对注册的bean进行另外的赋值处理，比如默认属性的配置</span><br><span class="line">				*返回的candidate类型为ScannedGenericBeanDefinition，下面两者</span><br><span class="line">				*条件满足</span><br><span class="line">				*/</span><br><span class="line">				if (candidate instanceof AbstractBeanDefinition) &#123;</span><br><span class="line">					//设置lazy-init/autowire-code默认属性，从spring配置的&lt;beans&gt;节点属性读取</span><br><span class="line">					postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">				&#125;</span><br><span class="line">				if (candidate instanceof AnnotatedBeanDefinition) &#123;</span><br><span class="line">					//读取bean上的注解，比如`@Lazy`、`@Dependson`的值设置相应的属性</span><br><span class="line">					AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">				&#125;</span><br><span class="line">				//查看是否已注册</span><br><span class="line">				if (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">					BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">					//默认采取cglib来做代理</span><br><span class="line">					definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry);</span><br><span class="line">					beanDefinitions.add(definitionHolder);</span><br><span class="line">					//**</span><br><span class="line">					//注册bean信息到工厂中</span><br><span class="line">					registerBeanDefinition(definitionHolder, this.registry);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return beanDefinitions;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>源码用&#x2F;&#x2F;**标记，<code>registerBeanDefinition(definitionHolder, this.registry);</code>是真正实现注册的那一行</p>
<p>这个时候把注解标记内容加入BeanDefinitionMap，根据前面的后处理器和生命周期内容，我们可知，最总会产生相关的bean实例</p>
<h3 id="配置类方式"><a href="#配置类方式" class="headerlink" title="配置类方式"></a>配置类方式</h3><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109190337461.png" alt="image-20231109190337461"></p>
<p>AnnotationConfigApplicationContext容器在进行创建时，所有的有参构造方法第一步都是执行自己的无参构造方法</p>
<p>无参构造源码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public AnnotationConfigApplicationContext() &#123;</span><br><span class="line">// 在执行此行代码之前, 先执行了父类的构造方法</span><br><span class="line">// 此段代码做的事情:</span><br><span class="line">// 1. 初始化bean工厂</span><br><span class="line">// 2. 初始化一个注解BeanDefinition读取器</span><br><span class="line">// 3. 将spring内置的6个类封装成RootBeanDefinition并注册到bean工厂, </span><br><span class="line">  this.reader = new AnnotatedBeanDefinitionReader(this);</span><br><span class="line"></span><br><span class="line">// 并没啥用, 虽然ClassPathBeanDefinitionScanner</span><br><span class="line">// 类的作用是扫描@ComponentScan注解提供的包路径。</span><br><span class="line">// 但实际上它并没有做扫描工作, spring内部扫描路径</span><br><span class="line">// 的时候, 是在内部新new了一个ClassPathBeanDefinitionScanner,</span><br><span class="line">// 这个属性目前没啥用, 当然我们可以获取这个对象</span><br><span class="line">// 调用它的scan方法, 但是没有必要! 因为</span><br><span class="line">// @ComponentScan可以支持多个扫描路径。 </span><br><span class="line">// 那这个类有什么用呢？跟刚刚的解释一样, </span><br><span class="line">// 我们可以自己new一个ClassPathBeanDefinitionScanner对象或者扩展他, </span><br><span class="line">// 利用它的扫描功能(因为它是使用ASM来扫描的)</span><br><span class="line">// Mybatis源码中就是自己扩展了</span><br><span class="line">// ClassPathBeanDefinitionScanner类</span><br><span class="line">  this.scanner = new ClassPathBeanDefinitionScanner(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="注解方式整合第三方框架"><a href="#注解方式整合第三方框架" class="headerlink" title="注解方式整合第三方框架"></a>注解方式整合第三方框架</h2><p>xml方式整合MyBatis，大致分为3步 3fenzhong</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置数据源--&gt;</span><br><span class="line">&lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--配置SqlSessionFactoryBean--&gt;</span><br><span class="line">&lt;bean class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--配置Mapper包扫描--&gt;</span><br><span class="line">&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;basePackage&quot; value=&quot;com.itheima.dao&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>



<p>用配置方式替换</p>
<ol>
<li>使用@Bean将DataSource和SqlSessionFactoryBean存储到Spring容器中</li>
<li>MapperScannerConfigurer使用注解@MapperScan进行指明需要扫描的Mapper在哪个包下</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.itheima&quot;)</span><br><span class="line"></span><br><span class="line">//&lt;!--配置Mapper包扫描--&gt;</span><br><span class="line">@MapperScan(&quot;com.itheima.mapper&quot;)</span><br><span class="line">public class ApplicationContextConfig &#123;</span><br><span class="line"></span><br><span class="line">  //&lt;!--配置数据源--&gt;</span><br><span class="line">  @Bean</span><br><span class="line">  public DataSource dataSource()&#123;</span><br><span class="line">    DruidDataSource dataSource = new DruidDataSource();</span><br><span class="line">    //省略部分代码</span><br><span class="line">    return dataSource;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //&lt;!--配置SqlSessionFactoryBean--&gt;</span><br><span class="line">  @Bean</span><br><span class="line">  public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource)&#123;</span><br><span class="line">    SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();</span><br><span class="line">    sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">    return sqlSessionFactoryBean;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>yuanli 还没看</p>
<h2 id="Import整合三方框架"><a href="#Import整合三方框架" class="headerlink" title="@Import整合三方框架"></a>@Import整合三方框架</h2><p>@Import可以导入如下三种类：</p>
<ol>
<li>普通的配置类</li>
<li>实现ImportSelector接口的类</li>
<li>实现ImportBeanDefinitionRegistrar接口的类</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">冰晕</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/11/06/Spring%E9%AB%98%E7%BA%A7IoC/">http://example.com/2023/11/06/Spring%E9%AB%98%E7%BA%A7IoC/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Icyhaloの糖果屋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Spring/">Spring</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/icyhalo/picgo/main/img/7dd0a3a35f174932a8b62f85eed07d34818483c2_rw.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/11/04/JUC%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/" title="JUC进程基础"><img class="cover" src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/102972823.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JUC进程基础</div></div></a></div><div class="next-post pull-right"><a href="/2023/11/11/Spring%E9%AB%98%E7%BA%A7Aop/" title="Spring高级Aop 事务"><img class="cover" src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/102972823.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Spring高级Aop 事务</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/08/31/SSM-Spring03/" title="SpringAOP"><img class="cover" src="https://raw.githubusercontent.com/icyhalo/picgo/main/img/7dd0a3a35f174932a8b62f85eed07d34818483c2_rw.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-31</div><div class="title">SpringAOP</div></div></a></div><div><a href="/2023/08/31/SSM-Spring04/" title="Spring事务"><img class="cover" src="https://raw.githubusercontent.com/icyhalo/picgo/main/img/7dd0a3a35f174932a8b62f85eed07d34818483c2_rw.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-31</div><div class="title">Spring事务</div></div></a></div><div><a href="/2023/10/24/SpringBoot/" title="SpringBoot"><img class="cover" src="https://raw.githubusercontent.com/icyhalo/picgo/main/img/7dd0a3a35f174932a8b62f85eed07d34818483c2_rw.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-24</div><div class="title">SpringBoot</div></div></a></div><div><a href="/2023/08/30/Spring%E5%85%A5%E9%97%A8.1/" title="Spring入门"><img class="cover" src="https://raw.githubusercontent.com/icyhalo/picgo/main/img/7dd0a3a35f174932a8b62f85eed07d34818483c2_rw.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-30</div><div class="title">Spring入门</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/img/FeeCpEnVIAAPn7.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">冰晕</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">53</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">49</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/"><i class="fab fa-github"></i><span>前往糖果屋</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#IoC%E3%80%81DI%E5%92%8CAOP%E6%80%9D%E6%83%B3%E6%8F%90%E5%87%BA"><span class="toc-number">1.</span> <span class="toc-text">IoC、DI和AOP思想提出</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring%E6%A1%86%E6%9E%B6%E7%9A%84%E8%AF%9E%E7%94%9F"><span class="toc-number">2.</span> <span class="toc-text">Spring框架的诞生</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Framework%E6%8A%80%E6%9C%AF%E6%A0%88"><span class="toc-number">2.1.</span> <span class="toc-text">Spring Framework技术栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">2.2.</span> <span class="toc-text">Spring 的容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanFactory%E7%9A%84%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB"><span class="toc-number">2.2.1.</span> <span class="toc-text">BeanFactory的继承体系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ApplicationContext%E7%9A%84%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB"><span class="toc-number">2.2.2.</span> <span class="toc-text">ApplicationContext的继承体系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BeanFactory-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">2.3.</span> <span class="toc-text">BeanFactory 快速入门</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ApplicationContext%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">2.4.</span> <span class="toc-text">ApplicationContext快速入门</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8Exml%E7%9A%84Spring%E5%BA%94%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">基于xml的Spring应用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Bean%E9%85%8D%E7%BD%AE"><span class="toc-number">3.1.</span> <span class="toc-text">Bean配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E7%AD%BE"><span class="toc-number">3.2.</span> <span class="toc-text">自定义标签</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DI%E6%B3%A8%E5%85%A5%E6%A0%87%E7%AD%BE"><span class="toc-number">3.3.</span> <span class="toc-text">DI注入标签</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E9%85%8D%E7%BD%AE"><span class="toc-number">3.3.1.</span> <span class="toc-text">Bean的依赖注入配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">3.3.2.</span> <span class="toc-text">自动装配方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getBean%E6%96%B9%E6%B3%95"><span class="toc-number">3.4.</span> <span class="toc-text">getBean方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bean%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E9%85%8D%E7%BD%AE"><span class="toc-number">3.5.</span> <span class="toc-text">Bean的实例化配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E9%9D%9E%E8%87%AA%E5%AE%9A%E4%B9%89Bean"><span class="toc-number">3.6.</span> <span class="toc-text">配置非自定义Bean</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8Exml%E6%96%B9%E5%BC%8F%E6%95%B4%E5%90%88%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6"><span class="toc-number">3.7.</span> <span class="toc-text">基于xml方式整合第三方框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E6%95%B4%E5%90%88MyBatis"><span class="toc-number">3.7.1.</span> <span class="toc-text">Spring整合MyBatis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90"><span class="toc-number">3.7.2.</span> <span class="toc-text">原理剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SqlSessionFactoryBean"><span class="toc-number">3.7.2.1.</span> <span class="toc-text">SqlSessionFactoryBean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MapperScannerConfigurer"><span class="toc-number">3.7.2.2.</span> <span class="toc-text">MapperScannerConfigurer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E5%A4%96%E9%83%A8properties"><span class="toc-number">3.7.2.3.</span> <span class="toc-text">加载外部properties</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8"><span class="toc-number">3.8.</span> <span class="toc-text">自定义命名空间使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Bean%E7%9A%84%E5%88%9B%E5%BB%BA%E4%BD%BF%E7%94%A8%E5%BA%95%E5%B1%82"><span class="toc-number">4.</span> <span class="toc-text">Bean的创建使用底层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="toc-number">4.1.</span> <span class="toc-text">实例化的基本流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#debug%E6%9F%A5%E7%9C%8B"><span class="toc-number">4.1.1.</span> <span class="toc-text">debug查看</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">4.2.</span> <span class="toc-text">后处理器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">4.3.</span> <span class="toc-text">Bean的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5"><span class="toc-number">4.3.1.</span> <span class="toc-text">初始化阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Bean%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%B1%9E%E6%80%A7%E5%A1%AB%E5%85%85"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">Bean实例的属性填充</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8"><span class="toc-number">4.3.1.1.1.</span> <span class="toc-text">循环引用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Aware%E6%8E%A5%E5%8F%A3%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5"><span class="toc-number">4.3.1.2.</span> <span class="toc-text">Aware接口属性注入</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bean%E5%88%9B%E5%BB%BA%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93"><span class="toc-number">4.4.</span> <span class="toc-text">Bean创建整体流程总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84Spring%E5%BA%94%E7%94%A8"><span class="toc-number">5.</span> <span class="toc-text">基于注解的Spring应用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Bean%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91"><span class="toc-number">5.1.</span> <span class="toc-text">Bean注解开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean%E6%A0%87%E7%AD%BE%E6%9B%BF%E6%8D%A2"><span class="toc-number">5.1.1.</span> <span class="toc-text">Bean标签替换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">5.1.1.1.</span> <span class="toc-text">使用方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean%E5%85%B6%E4%BB%96%E5%B1%9E%E6%80%A7"><span class="toc-number">5.1.2.</span> <span class="toc-text">Bean其他属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E8%AE%BE%E8%AE%A1"><span class="toc-number">5.1.3.</span> <span class="toc-text">分层设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bean%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91"><span class="toc-number">5.2.</span> <span class="toc-text">Bean依赖注入注解开发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E8%87%AA%E5%AE%9A%E4%B9%89Bean%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91"><span class="toc-number">5.3.</span> <span class="toc-text">非自定义Bean注解开发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bean%E9%85%8D%E7%BD%AE%E7%B1%BB"><span class="toc-number">5.4.</span> <span class="toc-text">Bean配置类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%8D%A2spring%E5%AE%B9%E5%99%A8%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">5.4.1.</span> <span class="toc-text">更换spring容器实现类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-%E9%85%8D%E7%BD%AE%E5%85%B6%E4%BB%96%E6%B3%A8%E8%A7%A3"><span class="toc-number">5.5.</span> <span class="toc-text">Spring 配置其他注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Primary"><span class="toc-number">5.5.1.</span> <span class="toc-text">@Primary</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Profile"><span class="toc-number">5.5.2.</span> <span class="toc-text">@Profile</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E6%B3%A8%E8%A7%A3%E7%9A%84%E8%A7%A3%E6%9E%90%E5%8E%9F%E7%90%86"><span class="toc-number">5.6.</span> <span class="toc-text">Spring注解的解析原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#xml%E6%96%B9%E5%BC%8F"><span class="toc-number">5.6.1.</span> <span class="toc-text">xml方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%B1%BB%E6%96%B9%E5%BC%8F"><span class="toc-number">5.6.2.</span> <span class="toc-text">配置类方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%E6%95%B4%E5%90%88%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6"><span class="toc-number">5.7.</span> <span class="toc-text">注解方式整合第三方框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Import%E6%95%B4%E5%90%88%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6"><span class="toc-number">5.8.</span> <span class="toc-text">@Import整合三方框架</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/11/11/Sping%E9%AB%98%E7%BA%A7%E6%95%B4%E5%90%88web/" title="Sping整合web"><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/102972823.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Sping整合web"/></a><div class="content"><a class="title" href="/2023/11/11/Sping%E9%AB%98%E7%BA%A7%E6%95%B4%E5%90%88web/" title="Sping整合web">Sping整合web</a><time datetime="2023-11-10T16:00:00.000Z" title="发表于 2023-11-11 00:00:00">2023-11-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/11/Spring%E9%AB%98%E7%BA%A7Aop/" title="Spring高级Aop 事务"><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/102972823.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring高级Aop 事务"/></a><div class="content"><a class="title" href="/2023/11/11/Spring%E9%AB%98%E7%BA%A7Aop/" title="Spring高级Aop 事务">Spring高级Aop 事务</a><time datetime="2023-11-10T16:00:00.000Z" title="发表于 2023-11-11 00:00:00">2023-11-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/06/Spring%E9%AB%98%E7%BA%A7IoC/" title="Spring高级-IoC部分"><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/img/7dd0a3a35f174932a8b62f85eed07d34818483c2_rw.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring高级-IoC部分"/></a><div class="content"><a class="title" href="/2023/11/06/Spring%E9%AB%98%E7%BA%A7IoC/" title="Spring高级-IoC部分">Spring高级-IoC部分</a><time datetime="2023-11-05T16:00:00.000Z" title="发表于 2023-11-06 00:00:00">2023-11-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By 冰晕</div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://assets.akilar.top/image/cover1.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/JDBC/&quot;);" href="javascript:void(0);">JDBC</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">各类主流的编程语言</span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/JVM/&quot;);" href="javascript:void(0);">JVM</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Java/&quot;);" href="javascript:void(0);">Java</a><span class="categoryBar-list-count">17</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/编程语言/&quot;);" href="javascript:void(0);">编程语言</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Linux/&quot;);" href="javascript:void(0);">Linux</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/框架/&quot;);" href="javascript:void(0);">框架</a><span class="categoryBar-list-count">10</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Spring/&quot;);" href="javascript:void(0);">Spring</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/必看/&quot;);" href="javascript:void(0);">必看</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/数据结构/&quot;);" href="javascript:void(0);">数据结构</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/数据库/&quot;);" href="javascript:void(0);">数据库</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/408/&quot;);" href="javascript:void(0);">408</a><span class="categoryBar-list-count">4</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v6.2.0" title=""><img src="https://img.shields.io/badge/Frame-Hexo-66ccff?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.3.1" title=""><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" data-title="本站采用多线部署，主线路托管于Vercel" title=""><img src="https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel" alt=""/></a><a class="github-badge" target="_blank" href="https://dashboard.4everland.org/" style="margin-inline:5px" data-title="本站采用多线部署，备用线路托管于4EVERLAND" title=""><img src="https://img.shields.io/badge/Hosted-4EVERLAND-22DDDD?style=flat&amp;logo=IPFS" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="/js/runtime.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '1s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '2');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2022/08/16/hello-world/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://raw.githubusercontent.com/icyhalo/picgo/main/TEHSN5228DVNJ0IKG8LMEF5.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-08-16</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2022/08/16/hello-world/&quot;);" href="javascript:void(0);" alt="">至每一个来到这里的人</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2022/08/16/hello-world/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end --></body></html>
<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SpringSecurity使用</title>
      <link href="/2023/12/14/SpringSecurity%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/12/14/SpringSecurity%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>为什么前后端分离不能用session？这里说的前后端分离不能用session，可能是一般情况前后端分离，后端都是分布式部署的，那么这个时候session就不起作用了。待解决</p><p>P10待完善 </p><p>JWT工具类</p><p>P22认证配置</p><p>P25</p><p>P33将到源码</p><p>UserDetails接口在哪里啊？</p><p>过滤器中的异常怎么处理？</p><p>PasswordEncoder在那个部分？</p><p>UsernamePasswordAuthenticationToken是谁的？</p><p>SecurityConfig的configure配置方法</p><p>GrantedAuthority接口和他的实现类</p><p>和全局的异常处理怎么整合的？</p><h1 id="框架简介"><a href="#框架简介" class="headerlink" title="框架简介"></a>框架简介</h1><p><strong>Spring Security</strong> 是<code>Spring</code>家族中的一个安全管理框架。相比与另外一个安全框架<strong>Shiro</strong>，它提供了更丰富的功能，社区资源也比<code>Shiro</code>丰富。</p><p>一般来说中大型的项目都是使用<code>SpringSecurity</code>来做安全框架。小项目有<code>Shiro</code>的比较多，因为相比与<code>SpringSecurity</code>，<code>Shiro</code>的上手更加的简单</p><p>一般Web应用的需要进行<strong>认证</strong>和<strong>授权</strong>。</p><p><strong>认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户</strong></p><p><strong>授权：判断认证后用户是否有权限进行某个操作</strong></p><p>认证和授权也是SpringSecurity作为安全框架的核心功能</p><h1 id="引入框架体验"><a href="#引入框架体验" class="headerlink" title="引入框架体验"></a>引入框架体验</h1><p>这个算不上入门案例，只能说是体验SS的登录功能</p><ol><li><p>准备工作</p><p>创建一个springboot项目，这是用于测试，极度简化</p><p>依赖：目前只导入web和lombok</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>controller类：里面写个hello先测试一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>先测试一道，看看能否正常使用</p></blockquote></li><li><p>引入SpringSecurity</p><p>只导入依赖，剩下的啥也别干，在SpringBoot项目中使用SpringSecurity我们只需要引入依赖即可实现入门案例</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>再次测试</p><p>这次测试会自动跳转到一个SpringSecurity的默认登陆页面，默认用户名是user，密码会输出在控制台</p><p>必须登陆之后才能对接口进行访问</p></li></ol><h1 id="登录校验流程"><a href="#登录校验流程" class="headerlink" title="登录校验流程"></a>登录校验流程</h1><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231219164424076.png" alt="image-20231219164424076"></p><blockquote><p>前后端分离项目认证核心是token，通过token判断是否是当前用户，以及确定是哪位用户</p></blockquote><p>前后端分离项目流程：</p><ol><li>前端请求携带用户名密码访问登陆接口</li><li>后端接收数据和数据库中的用户名和密码进行校验</li><li>如果正确，根据用户id生成一个jwt（Json Web Token）把jwt响应给前端</li><li>前端接收jwt并存储，之后的请求都在请求头中携带token</li><li>服务器获取请求头中的token进行解析，获取userID，根据用户id获取用户相关信息，如果有权则允许访问相关资源访问目标资源，响应给前端</li></ol><p>根据实际项目流程，修改前面入门案例的流程：</p><ol><li><code>SpringSecurity</code>提供的默认登录页面在前后端分离后就用不上了，替换为我们自己的，或者保留一个登录用的API就行</li><li>现在登录用的用户名和密码都是<code>SpringSecurity</code>提供的，真实开发时应该在数据库中查询比对</li></ol><h2 id="原理初探"><a href="#原理初探" class="headerlink" title="原理初探"></a>原理初探</h2><h3 id="Security完整流程"><a href="#Security完整流程" class="headerlink" title="Security完整流程"></a>Security完整流程</h3><p>SpringSecurity的原理其实就是一个过滤器链，内部包含了提供各种功能的过滤器，图中只展示了核心过滤器，其它的非核心过滤器并没有在图中展示。用Debug可以看见剩下的十几个过滤器</p><p>下图只针对上面还没拓展功能的入门案例</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231219223714278.png" alt="image-20231219223714278"></p><ul><li><code>UsernamePasswordAuthenticationFilter</code>：负责处理在登陆页面填写了用户名密码后的登陆请求。负责<strong>账户信息认证</strong></li><li><code>ExceptionTranslationFilter</code>：处理过滤器链中抛出的任何AccessDeniedException和 AuthenticationException。负责<strong>处理异常</strong></li><li><code>FilterSecurityInterceptor</code>：可以通过Debug查看当前系统中SpringSecurity过滤器链中有哪些过滤器及它们的顺序。负责<strong>权限校验</strong>的过滤器</li></ul><h3 id="登录过程详解"><a href="#登录过程详解" class="headerlink" title="登录过程详解"></a>登录过程详解</h3><p>记住这张图，然后就知道该干什么，不需要记住具体步骤顺序。这里大致完成前面确认用户任务和权限授予任务。</p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231219223938618.png" alt="image-20231219223938618"  /><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">默认流程</button></li><li class="tab"><button type="button" data-href="#test1-2">相关接口</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><ol><li>前端提交用户名密码</li><li><code>请求接受者</code>把前端请求封装成<code>Authentication对象</code>，这时候最多只有用户名和密码，权限还没有</li><li><code>UsernamePasswordAuthenticationFilter</code>调用<code>中间商1</code>的authenticate方法进行认证</li><li><code>中间商</code>调用<code>校验者</code>的authenticate方法进行认证</li><li><code>校验者</code>调用真正实现<code>查询者</code>的loadUserByUsername方法查询用户<ol><li><code>查询者</code>根据用户名去查询对于的用户及这个用户对应的权限信息，InMemoryUserDetailsManager是在内存中查询数据进行验证</li><li><code>查询者</code>把对应的用户信息包括去权限信息封装成UserDetails对象</li></ol></li><li><code>校验者</code>返回UserDetails对象给<code>校验者</code>，UserDetails对象含有库中查询到的正确的用户名和密码</li><li><code>校验者</code>通过PasswordEncoder对比UserDetails中的密码和Authentication的密码是是否正确</li><li>如果正确，<code>校验者</code>就把UserDetails中的权限信息设置到Authentication对象中</li><li><code>校验者</code>返回Authentication对象给<code>请求接受者</code></li><li>如果上一步返回了Authentication对象就使用SecurityContextHolder.getContext0.setAuthentication方法存储该对象。其它过滤器中会通过SecurityContextHolder来获取当前用户信息</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><code>请求接受者</code>：AbstractAuthenticationProcessingFilter接口及其实现类，一般自己实现controller作为实现类，调用authenticate方法。并且检验返回的UserDetails</p><p><code>中间商</code>：AuthenticationManager接口及其实现类，一般用默认的实现类</p><p><code>校验者</code>：AbstractUserDetailsAuthenticationProvider接口及其实现类，一般用默认的实现类</p><p><code>查询者</code>：UserDetailsService接口及其实现类，一般自己实现</p><ul><li>Authentication接口: 它的实现类，表示当前访问系统的用户，封装了用户相关信息。</li><li>AuthenticationManager接口：定义了认证Authentication的方法 </li><li>UserDetailsService接口：加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息的 方法。 </li><li>UserDetails接口：提供核心用户信息。通过UserDetailsService根据用户名获取处理的用户信息要封装 成UserDetails对象返回。然后将这些信息封装到Authentication对象中</li></ul><table><thead><tr><th>接口</th><th>作用</th><th>实现类</th><th>实现类作用</th></tr></thead><tbody><tr><td>AbstractAuthenticationProcessingFilter</td><td></td><td>UsernamePasswordAuthenticationFilter</td><td></td></tr><tr><td>AuthenticationManager</td><td></td><td>ProviderManager</td><td></td></tr><tr><td>AbstractUserDetailsAuthenticationProvider</td><td></td><td>DaoAuthenticationProvider</td><td></td></tr><tr><td>UserDetailsService</td><td></td><td>InMemoryUserDetailsManager</td><td></td></tr><tr><td>UserDetails</td><td></td><td>User</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>Authentication</td><td></td><td></td><td></td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="根据实际项目调整流程"><a href="#根据实际项目调整流程" class="headerlink" title="根据实际项目调整流程"></a>根据实际项目调整流程</h3><p>P10 7’40图</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231219184520992.png" alt="image-20231219184520992"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231219184633294.png" alt="image-20231219184633294"></p><h4 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h4><p>流程：</p><ul><li>前端登录后，提交用户名密码给<code>请求接受者</code>，被封装成<code>Authentication对象</code>。目前测试时有id，pwd，权限属性。在过滤器链中，最后调用<code>UserDetailsService接口</code>的方法（默认是在内存中查找，但根据需要，重写成在库中查找）,查找存储的数据。把查询到的结果封装成<code>UserDetails</code>对象传回去，检验返回的UserDetails，最后由<code>请求接受者</code>扔给前端</li></ul><p>操作：</p><ol><li><p>自定义登录接口</p><p>调用ProviderManager的方法进行认证如果认证通过生成jwt</p><p>把用户信息存入redis中</p></li><li><p>自定义UserDetaisService，在这个实现类中去查询数据库</p></li></ol><h4 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h4><p>流程：</p><ul><li><code>查询者</code>根据<code>用户id</code>得到了一个<code>UserDetails</code>，并传送到<code>校验者</code>，在这里比较<code>Authentication</code>和<code>UserDetails</code>里面的密码，确定用户身份，如果是正确用户就查询权限，然后把权限和<code>UserDetails</code>一起封装入<code>Authentication</code>传送给<code>请求接受者</code></li><li>此时把<code>Authentication</code>存储到<code>SecurityContextHolder</code></li></ul><p>操作：</p><ol><li>定义Jwt认证过滤器</li><li>获取token，解析token获取其中的userid</li><li>从redis中获取用户信息</li><li>存入SecurityContextHolder</li></ol><h4 id="修改部分"><a href="#修改部分" class="headerlink" title="修改部分"></a>修改部分</h4><p>主要修改2处：</p><ol><li><p>把从内存中查询数据改为从库中查询数据。这一步通过自己编写<code>UserDetailsService接口</code>的实现类，重写方法完成</p><blockquote><p>把上面流程中的5.1重新实现，5.2功能保存不变，但也一起重写了</p></blockquote></li><li><p>验证通过后又回到了登录过滤器，不需要这个默认页面，自己实现相关API替换登录过滤器，进行控制</p></li></ol><h1 id="认证实现"><a href="#认证实现" class="headerlink" title="认证实现"></a>认证实现</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>这部分准备了个springboot项目，和一些直接用工具类、配置类等</p><div class="tabs" id="test2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test2-1">项目默认架构</button></li><li class="tab"><button type="button" data-href="#test2-2">配置类</button></li><li class="tab"><button type="button" data-href="#test2-3">工具类</button></li><li class="tab"><button type="button" data-href="#test2-4">响应类</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test2-1"><p>添加依赖，直接用下面这个替换</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">&lt;-- web-starter --&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;-- security-starter --&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;-- redis --&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;-- fastjson --&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.33<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;-- jwt --&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;-- lombok --&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;-- tomcat --&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;-- test --&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;-- mybatis-mybatis --&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-mybatis-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;-- mysql --&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>主要是redis、fastjson、jwt的依赖</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-2"><p>下面两个工具直接拿过来用就行，实际开发也就直接拿过来用</p><ol><li><p>Redis的配置类：RedisConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.security.demos.utils.FastJsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(value = &#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span></span><br><span class="line">    &#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="type">FastJsonRedisSerializer</span> <span class="variable">serializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FastJsonRedisSerializer</span>(Object.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用StringRedisSerializer来序列化和反序列化redis的key值</span></span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        template.setValueSerializer(serializer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Hash的key也采用StringRedisSerializer的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        template.setHashValueSerializer(serializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加相关配置，基于FastJson的序列化器<code>FastJsonRedisSerializer</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.serializer.SerializerFeature;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.JavaType;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.type.TypeFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.SerializationException;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.Assert;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastJsonRedisSerializer</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">RedisSerializer</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Charset</span> <span class="variable">DEFAULT_CHARSET</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; clazz;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FastJsonRedisSerializer</span><span class="params">(Class&lt;T&gt; clazz)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.clazz = clazz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] serialize(T t) <span class="keyword">throws</span> SerializationException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> JSON.toJSONString(t,</span><br><span class="line">                SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">deserialize</span><span class="params">(<span class="type">byte</span>[] bytes)</span> <span class="keyword">throws</span> SerializationException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="literal">null</span> || bytes.length &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, DEFAULT_CHARSET);</span><br><span class="line">        <span class="keyword">return</span> JSON.parseObject(str, clazz);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> JavaType <span class="title function_">getJavaType</span><span class="params">(Class&lt;?&gt; clazz)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> TypeFactory.defaultInstance().constructType(clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-3"><ol><li><p>JWT工具类：JwtUtil，里面主要是2个方法，以后用来转换token和明码</p><ol><li><p>createJWT()：传入数据，生成相关token。目前的这个方法实现的比较简单，传入的数据是能很复杂的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成jtw的三个重载方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subject token中要存放的数据（json格式）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createJWT</span><span class="params">(String subject)</span> &#123;</span><br><span class="line">    <span class="type">JwtBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> getJwtBuilder(subject, <span class="literal">null</span>, getUUID());<span class="comment">// 设置过期时间</span></span><br><span class="line">    <span class="keyword">return</span> builder.compact();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createJWT</span><span class="params">(String subject, Long ttlMillis)</span> &#123;</span><br><span class="line">    <span class="type">JwtBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> getJwtBuilder(subject, ttlMillis, getUUID());<span class="comment">// 设置过期时间</span></span><br><span class="line">    <span class="keyword">return</span> builder.compact();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createJWT</span><span class="params">(String id, String subject, Long ttlMillis)</span> &#123;</span><br><span class="line">    <span class="type">JwtBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> getJwtBuilder(subject, ttlMillis, id);<span class="comment">// 设置过期时间</span></span><br><span class="line">    <span class="keyword">return</span> builder.compact();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>parseJWT()：传入token，转回数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jwt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Claims <span class="title function_">parseJWT</span><span class="params">(String jwt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> generalKey();</span><br><span class="line">    <span class="keyword">return</span> Jwts.parser()</span><br><span class="line">        .setSigningKey(secretKey)</span><br><span class="line">        .parseClaimsJws(jwt)</span><br><span class="line">        .getBody();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>整体JwtUtil类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Claims;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.JwtBuilder;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Jwts;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.SignatureAlgorithm;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtil</span> &#123;</span><br><span class="line">    <span class="comment">//有效期为</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">JWT_TTL</span> <span class="operator">=</span> <span class="number">60</span> * <span class="number">60</span> *<span class="number">1000L</span>;<span class="comment">// 60 * 60 *1000 一个小时</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置秘钥明文</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">JWT_KEY</span> <span class="operator">=</span> <span class="string">&quot;sangeng&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getUUID</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> UUID.randomUUID().toString().replaceAll(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成jtw</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subject token中要存放的数据（json格式）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ttlMillis token超时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createJWT</span><span class="params">(String subject)</span> &#123;</span><br><span class="line">        <span class="comment">//不设置过期时间</span></span><br><span class="line">        <span class="type">JwtBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> getJwtBuilder(subject, <span class="literal">null</span>, getUUID());</span><br><span class="line">        <span class="keyword">return</span> builder.compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createJWT</span><span class="params">(String subject, Long ttlMillis)</span> &#123;</span><br><span class="line">        <span class="comment">//设置过期时间</span></span><br><span class="line">        <span class="type">JwtBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> getJwtBuilder(subject, ttlMillis, getUUID());</span><br><span class="line">        <span class="keyword">return</span> builder.compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createJWT</span><span class="params">(String id, String subject, Long ttlMillis)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置过期时间，id和上面两个不一样</span></span><br><span class="line">        <span class="type">JwtBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> getJwtBuilder(subject, ttlMillis, id);</span><br><span class="line">        <span class="keyword">return</span> builder.compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JwtBuilder <span class="title function_">getJwtBuilder</span><span class="params">(String subject, Long ttlMillis, String uuid)</span> &#123;</span><br><span class="line">        <span class="type">SignatureAlgorithm</span> <span class="variable">signatureAlgorithm</span> <span class="operator">=</span> SignatureAlgorithm.HS256;</span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> generalKey();</span><br><span class="line">        <span class="type">long</span> <span class="variable">nowMillis</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(nowMillis);</span><br><span class="line">        <span class="keyword">if</span>(ttlMillis==<span class="literal">null</span>)&#123;</span><br><span class="line">            ttlMillis=JwtUtil.JWT_TTL;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">expMillis</span> <span class="operator">=</span> nowMillis + ttlMillis;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">expDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(expMillis);</span><br><span class="line">        <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">                .setId(uuid) <span class="comment">//唯一的ID</span></span><br><span class="line">                .setSubject(subject) <span class="comment">// 主题 可以是JSON数据</span></span><br><span class="line">                .setIssuer(<span class="string">&quot;sg&quot;</span>) <span class="comment">// 签发者</span></span><br><span class="line">                .setIssuedAt(now) <span class="comment">// 签发时间</span></span><br><span class="line">                .signWith(signatureAlgorithm, secretKey) <span class="comment">//使用HS256对称加密算法签 名, 第二个参数为秘钥</span></span><br><span class="line">                .setExpiration(expDate);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> <span class="string">&quot;eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJjYWM2ZDVhZi1mNjVlLTQ0MDAtYjcxMi0zYWEwOGIyOTIwYjQiLCJzdWIiOiJzZyIsImlzcyI6InNnIiwiaWF0IjoxNjM4MTA2NzEyLCJleHAiOjE2MzgxMTAzMTJ9.JVsSbkP94wuczb4QryQbAke3ysBDIL5ou8fWsbt_ebg&quot;</span>;</span><br><span class="line">        <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> parseJWT(token);</span><br><span class="line">        System.out.println(claims);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成加密后的秘钥 secretKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SecretKey <span class="title function_">generalKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] encodedKey = Base64.getDecoder().decode(JwtUtil.JWT_KEY);</span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(encodedKey, <span class="number">0</span>, encodedKey.length,<span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jwt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Claims <span class="title function_">parseJWT</span><span class="params">(String jwt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> generalKey();</span><br><span class="line">        <span class="keyword">return</span> Jwts.parser()</span><br><span class="line">                .setSigningKey(secretKey)</span><br><span class="line">                .parseClaimsJws(jwt)</span><br><span class="line">                .getBody();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Redis的工具类：RedisCache</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.BoundSetOperations;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.HashOperations;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.ValueOperations;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="meta">@SuppressWarnings(value = &#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisCache</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存基本的对象，Integer、String、实体类等</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   缓存的键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 缓存的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">setCacheObject</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> T value)</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存基本的对象，Integer、String、实体类等</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key      缓存的键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value    缓存的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout  时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeUnit 时间颗粒度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">setCacheObject</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> T value, <span class="keyword">final</span></span></span><br><span class="line"><span class="params">    Integer timeout, <span class="keyword">final</span> TimeUnit timeUnit)</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(key, value, timeout, timeUnit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置有效时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key     Redis键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 超时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true=设置成功；false=设置失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">expire</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> <span class="type">long</span> timeout)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> expire(key, timeout, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置有效时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key     Redis键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 超时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit    时间单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true=设置成功；false=设置失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">expire</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> <span class="type">long</span> timeout, <span class="keyword">final</span> TimeUnit</span></span><br><span class="line"><span class="params">            unit)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.expire(key, timeout, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得缓存的基本对象。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存键值* <span class="doctag">@return</span> 缓存键值对应的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getCacheObject</span><span class="params">(<span class="keyword">final</span> String key)</span> &#123;</span><br><span class="line">        ValueOperations&lt;String, T&gt; operation = redisTemplate.opsForValue();</span><br><span class="line">        <span class="keyword">return</span> operation.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除单个对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteObject</span><span class="params">(<span class="keyword">final</span> String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.delete(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除集合对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> collection 多个对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">deleteObject</span><span class="params">(<span class="keyword">final</span> Collection collection)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.delete(collection);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存List数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key      缓存的键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataList 待缓存的List数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 缓存的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="type">long</span> <span class="title function_">setCacheList</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> List&lt;T&gt; dataList)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> redisTemplate.opsForList().rightPushAll(key, dataList);</span><br><span class="line">        <span class="keyword">return</span> count == <span class="literal">null</span> ? <span class="number">0</span> : count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得缓存的list对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存的键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 缓存键值对应的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">getCacheList</span><span class="params">(<span class="keyword">final</span> String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForList().range(key, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存Set</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key     缓存键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataSet 缓存的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 缓存数据的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; BoundSetOperations&lt;String, T&gt; <span class="title function_">setCacheSet</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span></span></span><br><span class="line"><span class="params">    Set&lt;T&gt; dataSet)</span> &#123;</span><br><span class="line">        BoundSetOperations&lt;String, T&gt; setOperation =</span><br><span class="line">                redisTemplate.boundSetOps(key);</span><br><span class="line">        Iterator&lt;T&gt; it = dataSet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            setOperation.add(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setOperation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得缓存的set</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Set&lt;T&gt; <span class="title function_">getCacheSet</span><span class="params">(<span class="keyword">final</span> String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForSet().members(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存Map</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataMap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">setCacheMap</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> Map&lt;String, T&gt; dataMap)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (dataMap != <span class="literal">null</span>) &#123;</span><br><span class="line">            redisTemplate.opsForHash().putAll(key, dataMap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得缓存的Map</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Map&lt;String, T&gt; <span class="title function_">getCacheMap</span><span class="params">(<span class="keyword">final</span> String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().entries(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往Hash中存入数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   Redis键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hKey  Hash键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">setCacheMapValue</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> String hKey, <span class="keyword">final</span></span></span><br><span class="line"><span class="params">    T value)</span> &#123;</span><br><span class="line">        redisTemplate.opsForHash().put(key, hKey, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取Hash中的数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  Redis键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hKey Hash键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Hash中的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getCacheMapValue</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> String hKey)</span> &#123;</span><br><span class="line">        HashOperations&lt;String, String, T&gt; opsForHash =</span><br><span class="line">                redisTemplate.opsForHash();</span><br><span class="line">        <span class="keyword">return</span> opsForHash.get(key, hKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除Hash中的数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hkey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delCacheMapValue</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> String hkey)</span> &#123;</span><br><span class="line">        <span class="type">HashOperations</span> <span class="variable">hashOperations</span> <span class="operator">=</span> redisTemplate.opsForHash();</span><br><span class="line">        hashOperations.delete(key, hkey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取多个Hash中的数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   Redis键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hKeys Hash键集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Hash对象集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">getMultiCacheMapValue</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span></span></span><br><span class="line"><span class="params">    Collection&lt;Object&gt; hKeys)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().multiGet(key, hKeys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得缓存的基本对象列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pattern 字符串前缀</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对象列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;String&gt; <span class="title function_">keys</span><span class="params">(<span class="keyword">final</span> String pattern)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.keys(pattern);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>工具类：WebUtils，方便响应时的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebUtils</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将字符串渲染到客户端</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response 渲染对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string 待渲染的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">renderString</span><span class="params">(HttpServletResponse response, String string)</span> &#123;</span><br><span class="line">      <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            response.setStatus(<span class="number">200</span>);</span><br><span class="line">            response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">            response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            response.getWriter().print(string);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">catch</span> (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-4"><ol><li><p>响应类：ResponseResult，统一相应体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonInclude;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JsonInclude(JsonInclude.Include.NON_NULL)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseResult</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态码</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//提示信息，如果有错误时，前端可以获取该字段进行提示</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//查询到的结果数据</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ResponseResult</span><span class="params">(Integer code, String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ResponseResult</span><span class="params">(Integer code, T data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCode</span><span class="params">(Integer code)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMsg</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ResponseResult</span><span class="params">(Integer code, String msg, T data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="数据库校验用户"><a href="#数据库校验用户" class="headerlink" title="数据库校验用户"></a>数据库校验用户</h2><p>自定义一个UserDetailsService，让SpringSecurity使用我们的 UserDetailsService。自己的UserDetailsService实现从数据库中查询用户名和密码等功能</p><div class="tabs" id="test3"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test3-1">准备工作</button></li><li class="tab"><button type="button" data-href="#test3-2">核心功能</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test3-1"><ul><li><p>创建数据库，并添加一个用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sys_user` (</span><br><span class="line">`id` <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">`user_name` <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;NULL&#x27;</span> COMMENT <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">`nick_name` <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;NULL&#x27;</span> COMMENT <span class="string">&#x27;昵称&#x27;</span>,</span><br><span class="line">`password` <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;NULL&#x27;</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">`status` <span class="type">CHAR</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;账号状态（0正常 1停用）&#x27;</span>,</span><br><span class="line">`email` <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line">`phonenumber` <span class="type">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;手机号&#x27;</span>,</span><br><span class="line">`sex` <span class="type">CHAR</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户性别（0男，1女，2未知）&#x27;</span>,</span><br><span class="line">`avatar` <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;头像&#x27;</span>,</span><br><span class="line">`user_type` <span class="type">CHAR</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;1&#x27;</span> COMMENT <span class="string">&#x27;用户类型（0管理员，1普通用户）&#x27;</span>,</span><br><span class="line">`create_by` <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建人的用户id&#x27;</span>,</span><br><span class="line">`create_time` DATETIME <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">`update_by` <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;更新人&#x27;</span>,</span><br><span class="line">`update_time` DATETIME <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">`del_flag` <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;删除标志（0代表未删除，1代表已删除）&#x27;</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB AUTO_INCREMENT<span class="operator">=</span><span class="number">2</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;用户表&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>配置数据库信息</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf8&amp;serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">pwd用你自己的</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure></li><li><p>定义Mapper接口，使用Mybatis-plus</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123; &#125;</span><br></pre></td></tr></table></figure></li><li><p>修改User实体类，主要是添加了<code>@TableId</code>和<code>@TableName</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableName(value = &quot;sys_user&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">40356785423868312L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableId</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 昵称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 密码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 账号状态（0正常 1停用）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 邮箱</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 手机号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String phonenumber;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户性别（0男，1女，2未知）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 头像</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String avatar;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户类型（0管理员，1普通用户）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String userType;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建人的用户id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long createBy;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新人</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long updateBy;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除标志（0代表未删除，1代表已删除）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer delFlag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试Mybatis-plus是否能正常使用，查一下我们之前存入的用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.security.demos.domain.User;</span><br><span class="line"><span class="keyword">import</span> com.example.security.demos.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SecurityApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入userMapper</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//测试，使用Mybatis-plus</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUserMapper</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;User&gt; users = userMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">        System.out.println(users);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-2"><p>自定义UserDetailsService的实现类，替换默认的实现类，这个接口security已经提供了，直接创建实现类，实现接口的<code>loadUserByUsername方法</code>，注入<code>Mapper</code>进行数据库查询，这一个过滤器先返回一个包含数据的<code>UserDetails对象</code>，，最终返回一个不含权限的<code>Authentication对象</code></p><blockquote><p>目前只是认证，授权部分先空着，单独实现</p></blockquote><ol><li><p>UserDetailsService的实现类从数据库中查询数据，用UserDetails对象接收、返回查询到的数据，给下一个过滤器进行数据的比较</p><p>  用实现类的构造器方法接受查询结果，并返回</p><p>  这里的异常怎么处理的？</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDetailsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line">    <span class="comment">//注入查询Mapper</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据用户名查询用户信息</span></span><br><span class="line">        LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        wrapper.eq(User::getUserName, username);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectOne(wrapper);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果查询不到数据就通过抛出异常来给出提示</span></span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(user)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//TODO 根据用户查询权限信息 添加到LoginUser中</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//封装成UserDetails对象返回，UserDetails是一个接口，用它的实现类封装</span></span><br><span class="line">        <span class="comment">//用实现类的构造器方法接受</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoginUser</span>(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义UserDetails的实现类LoginUser</p><p>补充属性用来封装返回信息，重写方法</p><p>获取用户名和密码的方法实现功能</p><p>其余方法都先写成true，防止测试出问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginUser</span> <span class="keyword">implements</span> <span class="title class_">UserDetails</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回权限用的方法</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    <span class="comment">//返回数据用的方法</span></span><br><span class="line">    <span class="comment">//框架后面会用这个的get方法获取数据</span></span><br><span class="line">    <span class="comment">//密码</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> user.getPassword();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用户名</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> user.getUserName();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回状态用的方法</span></span><br><span class="line">    <span class="comment">// 帐户未过期</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 帐户未锁定</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 凭证是否过期</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用户是否可用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><p>目前测试有个小问题，是查不到的</p><p>在数据库中，密码前面加上<code>{noop}</code>，指明密码用明文存储，再测试</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="密码加密存储"><a href="#密码加密存储" class="headerlink" title="密码加密存储"></a>密码加密存储</h2><p>实际项目中不会把密码明文存储在数据库中。</p><p>默认使用的<code>PasswordEncoder</code>要求数据库中的密码格式为：<code>&#123;id&#125;password</code>，它会根据id去判断密码的加密方式。但是一般不采用<code>PasswordEncoder</code>。</p><p>一般使用<code>SpringSecurity</code>提供的<code>BCryptPasswordEncoder</code>。把<code>BCryptPasswordEncoder对象</code>注入Spring容器中，SpringSecurity就会使用该<code>BCryptPasswordEncoder</code>来进行密码校验。</p><p>定义一个SpringSecurity的配置类，SpringSecurity要求这个配置类要继承 WebSecurityConfigurerAdapter。在这个配置类里面生成并返回一个BCryptPasswordEncoder，提供<code>@Bean</code>注入容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">//创建BCryptPasswordEncoder注入容器</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意使用BCryptPasswordEncoder后，把数据库里面的密码改了，我当初这里就出错了</p></blockquote><h3 id="BCryptPasswordEncoder使用"><a href="#BCryptPasswordEncoder使用" class="headerlink" title="BCryptPasswordEncoder使用"></a>BCryptPasswordEncoder使用</h3><p>BCryptPasswordEncoder主要有3个方法</p><ol><li><p>encode()：加密方法，把明文加密，每个对象的加密结果不同，但是已经生成的密文能唯一确定明文</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">encode</span><span class="params">(CharSequence rawPassword)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (rawPassword == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;rawPassword cannot be null&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//getSalt用来生成盐，进行加密</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">salt</span> <span class="operator">=</span> <span class="built_in">this</span>.getSalt();</span><br><span class="line">        <span class="keyword">return</span> BCrypt.hashpw(rawPassword.toString(), salt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>matches()：校验方法，先输入明文，再输入密文，进行校验。第一个参数表示需要被解析的密码。第二个参数表示存储的密码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(CharSequence rawPassword, String encodedPassword)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (rawPassword == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;rawPassword cannot be null&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encodedPassword != <span class="literal">null</span> &amp;&amp; encodedPassword.length() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.BCRYPT_PATTERN.matcher(encodedPassword).matches()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.logger.warn(<span class="string">&quot;Encoded password does not look like BCrypt&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> BCrypt.checkpw(rawPassword.toString(), encodedPassword);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.logger.warn(<span class="string">&quot;Empty encoded password&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>upgradeEncoding()：如果解析的密码能够再次进行解析且达到更安全的结果则返回true，否则返回false。默认返回false。现阶段不重要，我没到这个级别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">upgradeEncoding</span><span class="params">(String encodedPassword)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (encodedPassword != <span class="literal">null</span> &amp;&amp; encodedPassword.length() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> <span class="built_in">this</span>.BCRYPT_PATTERN.matcher(encodedPassword);</span><br><span class="line">        <span class="keyword">if</span> (!matcher.matches()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Encoded password does not look like BCrypt: &quot;</span> + encodedPassword);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">strength</span> <span class="operator">=</span> Integer.parseInt(matcher.group(<span class="number">2</span>));</span><br><span class="line">            <span class="keyword">return</span> strength &lt; <span class="built_in">this</span>.strength;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.logger.warn(<span class="string">&quot;Empty encoded password&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="自定义登录接口"><a href="#自定义登录接口" class="headerlink" title="自定义登录接口"></a>自定义登录接口</h2><p>接下来自定义登陆接口，就是定义一套controller、service、Impl实现类</p><p>并且让SpringSecurity对这个接口放行，让用户访问这个接口的时候不用登录也能访问。</p><blockquote><p>既然是个过滤器，就能放行，而且不能让开门这个行为也要门开了才能执行吧</p></blockquote><p>在接口中我们通过<code>AuthenticationManager</code>的<code>authenticate</code>方法来进行用户认证，所以需要在<code>SecurityConfig</code>中配置把<code>AuthenticationManager</code>注入容器。 </p><p>认证成功的话要生成一个<code>jwt</code>，放入响应中返回。并且为了让用户下回请求时能通过jwt识别出具体的是哪个用户，我们需要把用户信息存入<code>Redis</code>，可以把用户id作为key</p><p>创建相关controller、service接口、impl实现类</p><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">LoginController</button></li><li class="tab"><button type="button" data-href="#test4-2">LoginServcie</button></li><li class="tab"><button type="button" data-href="#test4-3">LoginServiceImpl</button></li><li class="tab"><button type="button" data-href="#test4-4">SecurityConfig</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p>创建2个方法，登录和退出</p><p>登录方法携带请求体，里面至少包含了用户名和密码，还有其余属性，使用user实体类接收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> &#123;</span><br><span class="line">    <span class="comment">//注入LoginServcie</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoginServcie loginServcie;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostMapping(&quot;/user/login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseResult <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> loginServcie.login(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/user/logout&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseResult <span class="title function_">logout</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> loginServcie.logout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><p>大哥，你是了解开发的，service接口向来简洁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LoginServcie</span> &#123;</span><br><span class="line">    ResponseResult <span class="title function_">login</span><span class="params">(User user)</span>;</span><br><span class="line">    ResponseResult <span class="title function_">logout</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-3"><p>登录方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">LoginServcie</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisCache redisCache;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ResponseResult <span class="title function_">login</span><span class="params">(User user)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//AuthenticationManager authenticate进行用户认证</span></span><br><span class="line">        <span class="comment">//AuthenticationManager通过SecurityConfig配置类注入容器</span></span><br><span class="line">        <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authenticationToken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(user.getUserName(),user.getPassword());</span><br><span class="line">        <span class="comment">//authenticationToken是UserDetailsServiceImpl里面方法的返回对象</span></span><br><span class="line">        <span class="comment">//看前面流程图，这一步是用Authentication封装数据的那一步</span></span><br><span class="line">        <span class="type">Authentication</span> <span class="variable">authenticate</span> <span class="operator">=</span> authenticationManager.authenticate(authenticationToken);</span><br><span class="line">        <span class="comment">//如果认证没通过，给出时应的提示</span></span><br><span class="line">        <span class="keyword">if</span>(Objects.isNull(authenticate))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//认证通过，使用userid生成token</span></span><br><span class="line">        <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> (LoginUser) authenticate.getPrincipal();</span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> loginUser.getUser().getId().toString();</span><br><span class="line">        <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> JwtUtil.createJWT(userId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//authenticate存入redis</span></span><br><span class="line">        redisCache.setCacheObject(<span class="string">&quot;login:&quot;</span>+userId,loginUser);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把token响应给前端</span></span><br><span class="line">        HashMap&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;token&quot;</span>,jwt);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseResult</span>(<span class="number">200</span>,<span class="string">&quot;登陆成功&quot;</span>,map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-4"><p>这次配置SecurityConfig，注入2个组件和配置方法</p><p>组件：</p><ul><li>PasswordEncoder实现类</li><li>AuthenticationManagerBean</li></ul><p>配置方法：</p><ul><li>configure</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">//注入加密PasswordEncoder实现类</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">//注入authenticationManagerBean</span></span><br><span class="line">    <span class="keyword">public</span> AuthenticationManager <span class="title function_">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Autowired</span></span><br><span class="line"><span class="comment">//    JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">            <span class="comment">//因为是前后端分离，一定关闭csrf</span></span><br><span class="line">            .csrf().disable()</span><br><span class="line"></span><br><span class="line">            <span class="comment">//因为是前后端分离，Session失效，不能通过Session获取SecurityContext</span></span><br><span class="line">            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">            .and()</span><br><span class="line">            .authorizeRequests()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对于登录接口,允许匿名访问,未登录能访问,登录后不能访问（可以避免反复登录）</span></span><br><span class="line">            .antMatchers(<span class="string">&quot;/user/login&quot;</span>).anonymous()</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//permitAll任意情况都能访问</span></span><br><span class="line">            .antMatchers(<span class="string">&quot;/user/login&quot;</span>).permitAll()</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 除上面外的所有请求全部需要鉴权认证</span></span><br><span class="line">            .anyRequest().authenticated();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//把token校验过滤器添加到过滤器链中</span></span><br><span class="line">             http.addFilterBefore(jwtAuthenticationTokenFilter,UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CSRF是指跨站请求伪造（Cross-site request forgery），是web常见的攻击之一。<code>https://blog.csdn.net/freeking101/article/details/86537087</code></p><p>SpringSecurity去防止CSRF攻击的方式就是通过csrf_token。后端会生成一个csrf_token，前端发起请求的时候需要携带这个csrf_token,后端会有过滤器进行校验，如果没有携带或者是伪造的就不允许访问。</p><p>我们可以发现CSRF攻击依靠的是cookie中所携带的认证信息。但是在前后端分离的项目中我们的认证信息其实是token，而token并不是存储中cookie中，并且需要前端代码去把token设置到请求头中才可以，所以CSRF攻击也就不用担心了</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="定义Token认证过滤器"><a href="#定义Token认证过滤器" class="headerlink" title="定义Token认证过滤器"></a>定义Token认证过滤器</h2><p>要自定义一个过滤器，这个过滤器会去获取请求头中的token，对token进行解析取出其中的 userid。再使用userid去redis中获取对应的LoginUser对象。 然后封装Authentication对象存入SecurityContextHolder</p><ol><li><p>定义一个过滤器</p><p>创建一个类让它实现过滤器接口，但是这里条件继承<code>OncePerRequestFilter</code>。确保只过滤一次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtAuthenticationTokenFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisCache redisCache;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//获取token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="comment">//没token就放行，让他去登录</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(token)) &#123;</span><br><span class="line">            filterChain.doFilter(request, response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解析token</span></span><br><span class="line">        String userid;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> JwtUtil.parseJWT(token);</span><br><span class="line">            userid = claims.getSubject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;token非法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从redis中获取用户信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> <span class="string">&quot;login:&quot;</span> + userid;</span><br><span class="line">        <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> redisCache.getCacheObject(redisKey);</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(loginUser)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户未登录&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//存入SecurityContextHolder</span></span><br><span class="line">        <span class="comment">//获取权限信息封装到Authentication中，目前没权限，用null占位</span></span><br><span class="line">        <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authenticationToken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(loginUser, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//P20 13&#x27;</span></span><br><span class="line">        SecurityContextHolder.getContext().setAuthentication(authenticationToken);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//放行</span></span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置认证过滤器</p><p><strong>SpringSecurity</strong>的过滤器链是由<strong>SpringSecurity</strong>维护的，不是放入Spring容器就能直接用的，需要配置。Token认证过滤器需要放在用户名密码校验前面。</p><p>在<code>SecurityConfig</code>中去配置该过滤器，用<code>addFilterBefore方法</code>把<strong>Token认证过滤器</strong>加入</p></li></ol><h2 id="退出登录"><a href="#退出登录" class="headerlink" title="退出登录"></a>退出登录</h2><p>P22 2‘</p><p>退出的时候删除掉<code>Redis</code>和<code>SecurityContextHolder</code>里面的数据，这样即使是旧对象发送新请求，也匹配不上，需要重新登录</p><p>需要定义一个登陆接口，退出的时候发送一个携带token的请求，然后获取SecurityContextHolder中的认证信息，删除redis中对应的数据即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">LoginServcie</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisCache redisCache;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//登出方法</span></span><br><span class="line">    <span class="keyword">public</span> ResponseResult <span class="title function_">logout</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//获取SecurityContextHo1der中的用户id</span></span><br><span class="line">        <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">        <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> (LoginUser) authentication.getPrincipal();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userid</span> <span class="operator">=</span> loginUser.getUser().getId();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//删除redis中的值</span></span><br><span class="line">        redisCache.deleteObject(<span class="string">&quot;login:&quot;</span>+userid);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseResult</span>(<span class="number">200</span>,<span class="string">&quot;退出成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="授权实现"><a href="#授权实现" class="headerlink" title="授权实现"></a>授权实现</h1><h2 id="权限系统的作用"><a href="#权限系统的作用" class="headerlink" title="权限系统的作用"></a>权限系统的作用</h2><p><strong>不同的用户可以使用不同的功能</strong>。这就是权限系统要去实现的效果。</p><p>不能只依赖前端去判断用户的权限来选择显示哪些菜单哪些按钮。因为如果只是这样，如果有人知道了对应功能的接口地址就可以不通过前端，直接去发送请求来实现相关功能操作。</p><p>所以还需要在后台进行用户权限的判断，判断当前用户是否有相应的权限，必须具有所需权限才能进行相应的操作。</p><h2 id="授权基本流程"><a href="#授权基本流程" class="headerlink" title="授权基本流程"></a>授权基本流程</h2><p>之前的UserDUserDetails接口查询过属性和权限，存入了<code>SecurityContextHolder</code>。</p><p>在<code>SpringSecurity</code>中，会使用默认的<code>FilterSecurityInterceptor</code>来进行权限校验。它从<code>SecurityContextHolder</code>获取其中的<code>Authentication</code>，然后获取其中的权限信息。校验当前用户是否拥有访问当前资源所需的权限。</p><p>在项目中把当前登录用户的权限信息也一起存入<code>Authentication</code>即可。</p><h2 id="授权实现-1"><a href="#授权实现-1" class="headerlink" title="授权实现"></a>授权实现</h2><h3 id="定义权限"><a href="#定义权限" class="headerlink" title="定义权限"></a>定义权限</h3><p>SpringSecurity提供了基于注解的权限控制方案，也是项目中主要采用的方式。我们可以使用注解去指定访问对应的资源所需的权限。</p><p>但是要使用它我们需要先开启相关配置，在配置类里面加上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true)</span></span><br></pre></td></tr></table></figure><p>然后就可以在方法上使用对应的注解<code>@PreAuthorize(&#39;权限名&#39;)</code>，这个注解其实是一次方法调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;test&#x27;)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>权限其实就是字符串，这里比较特殊，用单引号包裹字符串，后期可以自己实现权限类，定义权限</p><h3 id="封装权限信息"><a href="#封装权限信息" class="headerlink" title="封装权限信息"></a>封装权限信息</h3><p>前面在写UserDetailsServiceImpl的时候说过，在查询出用户后还要获取对应的权限信息，封装到UserDetails接口中返回。</p><p>先直接把权限信息写死，封装到UserDetails接口中进行测试。</p><p>之前定义UserDetails的实现类LoginUser，想要让其能封装权限信息就要对其进行修改。之前还没用到权限，当时用null占位。</p><p>现在新添加一个构造方法，用来接受用户和他的权限。实现权限封装方法<code>getAuthorities</code>，因为SS要求权限以变量<code>authorities</code>的形式识别，所以要转换，而且要用官方接口提供的该方法转换，需要在实现类重写该方法</p><p>在UserDetailsServiceImpl中去把权限信息封装到LoginUser中。先写死权限进行测试，后面我们再从数据库中查询权限信息。</p><p>校验的时候从redis中获取权限</p><ul><li><p>LoginUser，数据接收类，添加构造方法和实现权限封装方法<code>getAuthorities</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginUser</span> <span class="keyword">implements</span> <span class="title class_">UserDetails</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//存储权限信息，这个属性需要转换才能被SS识别</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; permissions;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//新添加的构造方法，接受用户和他的权限</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoginUser</span><span class="params">(User user,List&lt;String&gt; permissions)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.user = user;</span><br><span class="line">        <span class="built_in">this</span>.permissions = permissions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了安全，避免序列化的一个注解</span></span><br><span class="line">    <span class="meta">@JSONField(serialize = false)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//存储SpringSecurity需要权限的集合</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;GrantedAuthority&gt; authorities;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//SS调用的获取权限方法</span></span><br><span class="line">    <span class="comment">//返回值是GrantedAuthority接口的实现类</span></span><br><span class="line">    <span class="keyword">public</span>  Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="keyword">if</span>(authorities!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> authorities;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把permissions中字符串类型的权限信息转换成SimpleGrantedAuthority对象</span></span><br><span class="line">        <span class="comment">//并存入authorities中</span></span><br><span class="line">        authorities = permissions.stream().</span><br><span class="line">                map(SimpleGrantedAuthority::<span class="keyword">new</span>)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//返回权限的集合</span></span><br><span class="line">        <span class="keyword">return</span> authorities;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*----------------其余代码省略----------------*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>UserDetailsServiceImpl，数据库查询实现类，顺便把权限一起封装</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDetailsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接受查询数据</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        wrapper.eq(User::getUserName,username);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectOne(wrapper);</span><br><span class="line">        <span class="keyword">if</span>(Objects.isNull(user))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//根据用户查询权限信息，添加到LoginUser中，测试先写死</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="string">&quot;test&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoginUser</span>(user,list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>JwtAuthenticationTokenFilter，进行权限校验，从redis中获取权限，并封装到Authentication中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtAuthenticationTokenFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisCache redisCache;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest resuest, HttpServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//获取token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> resuest.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasLength(token)) &#123;</span><br><span class="line">            <span class="comment">//放行</span></span><br><span class="line">            filterChain.doFilter(resuest, response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//解析token</span></span><br><span class="line">        String userId;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> JwtUtil.parseJWT(token);</span><br><span class="line">            userId = claims.getSubject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;token非法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//从redis中获取用户信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> SysConsts.LOGIN_KEY + <span class="string">&quot;:&quot;</span> + userId;</span><br><span class="line">        <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> redisCache.getCacheObject(redisKey);</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(loginUser)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户未登录&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//存入SecurityContextHolder</span></span><br><span class="line">        <span class="comment">//TODO 获取权限信息封装到Authentication中</span></span><br><span class="line">        <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authenticationToken</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(loginUser, <span class="literal">null</span>,loginUser.getAuthorities());</span><br><span class="line">        SecurityContextHolder.getContext().setAuthentication(authenticationToken);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//放行</span></span><br><span class="line">        filterChain.doFilter(resuest, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="从数据库查询权限信息"><a href="#从数据库查询权限信息" class="headerlink" title="从数据库查询权限信息"></a>从数据库查询权限信息</h3><h4 id="RBAC权限模型"><a href="#RBAC权限模型" class="headerlink" title="RBAC权限模型"></a>RBAC权限模型</h4><p>RBAC权限模型（Role-Based Access Control）即：基于角色的权限控制。这是目前最常被开发者使用也是相对易用、通用权限模型</p><p>创建3个数据类表和2个连接用表。分别记录用户、权限、默认权限组合。通过将用户和角色、角色和权限组连接，给用户发放一套权限。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231220131010611.png" alt="image-20231220131010611"></p><h4 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h4><p>建库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE <span class="comment">/*!32312 IF NOT EXISTS*/</span>`sg_security` <span class="comment">/*!40100 DEFAULT CHARACTER SET utf8mb4 */</span>;</span><br><span class="line"></span><br><span class="line">USE `sg_security`;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Table structure for table `sys_menu` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `sys_menu`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sys_menu` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `menu_name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;NULL&#x27;</span> COMMENT <span class="string">&#x27;菜单名&#x27;</span>,</span><br><span class="line">  `path` <span class="type">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;路由地址&#x27;</span>,</span><br><span class="line">  `component` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;组件路径&#x27;</span>,</span><br><span class="line">  `visible` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;菜单状态（0显示 1隐藏）&#x27;</span>,</span><br><span class="line">  `status` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;菜单状态（0正常 1停用）&#x27;</span>,</span><br><span class="line">  `perms` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;权限标识&#x27;</span>,</span><br><span class="line">  `icon` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;#&#x27;</span> COMMENT <span class="string">&#x27;菜单图标&#x27;</span>,</span><br><span class="line">  `create_by` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `update_by` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `update_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `del_flag` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;是否删除（0未删除 1已删除）&#x27;</span>,</span><br><span class="line">  `remark` <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;备注&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">2</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;菜单表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Table structure for table `sys_role` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `sys_role`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sys_role` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `role_key` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;角色权限字符串&#x27;</span>,</span><br><span class="line">  `status` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;角色状态（0正常 1停用）&#x27;</span>,</span><br><span class="line">  `del_flag` <span class="type">int</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;del_flag&#x27;</span>,</span><br><span class="line">  `create_by` <span class="type">bigint</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `update_by` <span class="type">bigint</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `update_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `remark` <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;备注&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">3</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;角色表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Table structure for table `sys_role_menu` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `sys_role_menu`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sys_role_menu` (</span><br><span class="line">  `role_id` <span class="type">bigint</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;角色ID&#x27;</span>,</span><br><span class="line">  `menu_id` <span class="type">bigint</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;菜单id&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`role_id`,`menu_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">2</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Table structure for table `sys_user` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `sys_user`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sys_user` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">  `user_name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;NULL&#x27;</span> COMMENT <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">  `nick_name` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;NULL&#x27;</span> COMMENT <span class="string">&#x27;昵称&#x27;</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;NULL&#x27;</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">  `status` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;账号状态（0正常 1停用）&#x27;</span>,</span><br><span class="line">  `email` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line">  `phonenumber` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;手机号&#x27;</span>,</span><br><span class="line">  `sex` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户性别（0男，1女，2未知）&#x27;</span>,</span><br><span class="line">  `avatar` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;头像&#x27;</span>,</span><br><span class="line">  `user_type` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;1&#x27;</span> COMMENT <span class="string">&#x27;用户类型（0管理员，1普通用户）&#x27;</span>,</span><br><span class="line">  `create_by` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建人的用户id&#x27;</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `update_by` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;更新人&#x27;</span>,</span><br><span class="line">  `update_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">  `del_flag` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;删除标志（0代表未删除，1代表已删除）&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">3</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;用户表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Table structure for table `sys_user_role` */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `sys_user_role`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sys_user_role` (</span><br><span class="line">  `user_id` <span class="type">bigint</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">  `role_id` <span class="type">bigint</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;角色id&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`user_id`,`role_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure><p>编写测试代码，测试数据库是否能正常运行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line"><span class="keyword">DISTINCT</span> m.`perms`</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">sys_user_role ur</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> `sys_role` r <span class="keyword">ON</span> ur.`role_id` <span class="operator">=</span> r.`id`</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> `sys_role_menu` rm <span class="keyword">ON</span> ur.`role_id` <span class="operator">=</span> rm.`role_id`</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> `sys_menu` m <span class="keyword">ON</span> m.`id` <span class="operator">=</span> rm.`menu_id`</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">user_id <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">AND</span> r.`status` <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">AND</span> m.`status` <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建Menu实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//菜单表(Menu)实体类</span></span><br><span class="line"><span class="meta">@TableName(value=&quot;sys_menu&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@JsonInclude(JsonInclude.Include.NON_NULL)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Menu</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">54979041104113736L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//菜单名</span></span><br><span class="line">    <span class="keyword">private</span> String menuName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//路由地址</span></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//组件路径</span></span><br><span class="line">    <span class="keyword">private</span> String component;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//菜单状态（0显示 1隐藏）</span></span><br><span class="line">    <span class="keyword">private</span> String visible;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//菜单状态（0正常 1停用）</span></span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//权限标识</span></span><br><span class="line">    <span class="keyword">private</span> String perms;</span><br><span class="line">    <span class="keyword">private</span> String icon;</span><br><span class="line">    <span class="keyword">private</span> Long createBy;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="keyword">private</span> Long updateBy;</span><br><span class="line">    <span class="keyword">private</span> Date updateTime;</span><br><span class="line">    <span class="keyword">private</span> Integer delFlag;</span><br><span class="line">    <span class="keyword">private</span> String remark;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>我们只需要根据用户id去查询到其所对应的权限信息即可。</p><ol><li>定义个mapper，其中提供一个方法可以根据userid查询权限信息</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"><span class="keyword">import</span> com.sangeng.domain.Menu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MenuMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Menu&gt; &#123;</span><br><span class="line">    List&lt;String&gt; <span class="title function_">selectPermsByUserId</span><span class="params">(Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义方法，所以需要创建对应的mapper文件，定义对应的sql语句</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.sangeng.mapper.MenuMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectPermsByUserId&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.lang.String&quot;</span>&gt;</span></span><br><span class="line">        SELECT</span><br><span class="line">            DISTINCT m.`perms`</span><br><span class="line">        FROM</span><br><span class="line">            sys_user_role ur</span><br><span class="line">            LEFT JOIN `sys_role` r ON ur.`role_id` = r.`id`</span><br><span class="line">            LEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id`</span><br><span class="line">            LEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id`</span><br><span class="line">        WHERE</span><br><span class="line">            user_id = #&#123;userid&#125;</span><br><span class="line">            AND r.`status` = 0</span><br><span class="line">            AND m.`status` = 0</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 在application.yml中配置mapperXML文件的位置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&amp;serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath*:/mapper/**/*.xml</span> </span><br></pre></td></tr></table></figure><ol start="2"><li>在UserDetailsServiceImpl中去调用该mapper的方法查询权限信息封装到LoginUser对象中即可。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDetailsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MenuMapper menuMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//查询用户信息</span></span><br><span class="line">        LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        wrapper.eq(User::getUserName,username);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectOne(wrapper);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//库里面没用户就抛异常</span></span><br><span class="line">        <span class="keyword">if</span>(Objects.isNull(user))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//查询语句        </span></span><br><span class="line">        List&lt;String&gt; permissionKeyList =  menuMapper.selectPermsByUserId(user.getId());</span><br><span class="line">        <span class="comment">//通过UserDetails接口返回数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoginUser</span>(user,permissionKeyList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>JWT中测试是否查询到权限信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtAuthenticationTokenFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisCache redisCache;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//获取token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(token)) &#123;</span><br><span class="line">            <span class="comment">//放行</span></span><br><span class="line">            filterChain.doFilter(request, response);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解析token</span></span><br><span class="line">        String userid;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> JwtUtil.parseJWT(token);</span><br><span class="line">            userid = claims.getSubject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;token非法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从redis中获取用户信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">redisKey</span> <span class="operator">=</span> <span class="string">&quot;login:&quot;</span> + userid;</span><br><span class="line">        <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> redisCache.getCacheObject(redisKey);</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(loginUser)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户未登录&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//存入SecurityContextHolder</span></span><br><span class="line">        <span class="comment">//获取权限信息封装到Authentication中</span></span><br><span class="line">        <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authenticationToken</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(loginUser, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        SecurityContextHolder.getContext().setAuthentication(authenticationToken);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//放行</span></span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="失败处理"><a href="#失败处理" class="headerlink" title="失败处理"></a>失败处理</h1><blockquote><p>和全局的异常处理怎么整合的？</p></blockquote><p>在认证失败或者是授权失败的情况下也能和我们的接口一样返回相同结构的<code>json</code>，这样可以让前端能对响应进行统一的处理。实现这个功能需要知道<code>SpringSecurity</code>的异常处理机制。</p><p>在SpringSecurity中，如果我们在认证或者授权的过程中出现了异常会被ExceptionTranslationFilter捕获到。在ExceptionTranslationFilter中会去判断是认证失败还是授权失败出现的异常。</p><ul><li>认证过程中：异常会被封装成AuthenticationException然后调用<strong>AuthenticationEntryPoint</strong>对象的方法去进行异常处理</li><li>授权过程中：异常会被封装成AccessDeniedException然后调用<strong>AccessDeniedHandler</strong>对象的方法去进行异常处理</li></ul><p>如果需要自定义异常处理，只需要自定义<code>AuthenticationEntryPoint</code>和<code>AccessDeniedHandler</code>，并配置给<code>SpringSecurity</code></p><ol><li><p>自定义实现类</p><p>AccessDeniedHandler实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccessDeniedHandlerImpl</span> <span class="keyword">implements</span> <span class="title class_">AccessDeniedHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">ResponseResult</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResponseResult</span>(HttpStatus.FORBIDDEN.value(), <span class="string">&quot;权限不足&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JSON.toJSONString(result);</span><br><span class="line">        <span class="comment">//工具类方法，封装异常</span></span><br><span class="line">        WebUtils.renderString(response,json);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AuthenticationEntryPoint实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthenticationEntryPointImpl</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationEntryPoint</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commence</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="type">ResponseResult</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResponseResult</span>(HttpStatus.UNAUTHORIZED.value(), <span class="string">&quot;认证失败请重新登录&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JSON.toJSONString(result);</span><br><span class="line">        <span class="comment">//工具类方法，封装异常</span></span><br><span class="line">        WebUtils.renderString(response,json);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置给SpringSecurity</p><p>在SecurityConfig里，注入对应的处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> AuthenticationEntryPoint authenticationEntryPoint;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> AccessDeniedHandler accessDeniedHandler;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 在SecurityConfig里，使用HttpSecurity对象的方法去配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http.exceptionHandling()</span><br><span class="line">    <span class="comment">//认证失败处理器</span></span><br><span class="line">    .authenticationEntryPoint(authenticationEntryPoint)</span><br><span class="line">    <span class="comment">//授权失败处理器</span></span><br><span class="line">    .accessDeniedHandler(accessDeniedHandler);</span><br></pre></td></tr></table></figure></li></ol><h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><p>浏览器出于安全的考虑，使用 XMLHttpRequest对象发起 HTTP请求时必须遵守同源策略，否则就是跨域的HTTP请求，默认情况下是被禁止的。</p><p>同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。</p><p>前后端分离项目，前端项目和后端项目一般都不是同源的，所以肯定会存在跨域请求的问题。</p><p>所以需要处理一下，让前端能进行跨域请求，有2步，</p><ol><li><p>先对SpringBoot配置，允许跨域请求，创建CorsConfig配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">      <span class="comment">// 设置允许跨域的路径</span></span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                <span class="comment">// 设置允许跨域请求的域名</span></span><br><span class="line">                .allowedOriginPatterns(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                <span class="comment">// 是否允许cookie</span></span><br><span class="line">                .allowCredentials(<span class="literal">true</span>)</span><br><span class="line">                <span class="comment">// 设置允许的请求方式</span></span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;PUT&quot;</span>)</span><br><span class="line">                <span class="comment">// 设置允许的header属性</span></span><br><span class="line">                .allowedHeaders(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                <span class="comment">// 跨域允许时间</span></span><br><span class="line">                .maxAge(<span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开启SpringSecurity的跨域访问，由于我们的资源都会收到SpringSecurity的保护，所以想要跨域访问还要让SpringSecurity运行跨域访问，SecurityC中加入方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">            <span class="comment">//关闭csrf</span></span><br><span class="line">            .csrf().disable()</span><br><span class="line">            <span class="comment">//不通过Session获取SecurityContext</span></span><br><span class="line">            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">            .and()</span><br><span class="line">            .authorizeRequests()</span><br><span class="line">            <span class="comment">// 对于登录接口 允许匿名访问</span></span><br><span class="line">            .antMatchers(<span class="string">&quot;/user/login&quot;</span>).anonymous()</span><br><span class="line">            <span class="comment">// 除上面外的所有请求全部需要鉴权认证</span></span><br><span class="line">            .anyRequest().authenticated();</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//添加过滤器</span></span><br><span class="line">    http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//配置异常处理器</span></span><br><span class="line">    http.exceptionHandling()</span><br><span class="line">            <span class="comment">//配置认证失败处理器</span></span><br><span class="line">            .authenticationEntryPoint(authenticationEntryPoint)</span><br><span class="line">            .accessDeniedHandler(accessDeniedHandler);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//允许跨域</span></span><br><span class="line">    http.cors();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="遗留小问题"><a href="#遗留小问题" class="headerlink" title="遗留小问题"></a>遗留小问题</h1><h2 id="其它权限校验方法"><a href="#其它权限校验方法" class="headerlink" title="其它权限校验方法"></a>其它权限校验方法</h2><p>前面都是使用@PreAuthorize注解，在其中使用的是hasAuthority方法进行校验。SpringSecurity还为我们提供了其它方法例如：hasAnyAuthority，hasRole，hasAnyRole等</p><p>先去理解hasAuthority的原理，然后再去学习其他方法，并且我们也可以选择定义校验方法，实现我们自己的校验逻辑。</p><p>hasAuthority方法实际是执行到了SecurityExpressionRoot的hasAuthority，只要断点调试既可知道它内部的校验原理。</p><p>内部其实是调用authentication的getAuthorities方法获取用户的权限列表。然后判断我们存入的方法参数是否在权限列表中。</p><p>hasAnyAuthority方法可以传入多个权限，只要用户有其中任意一个权限都可以访问对应资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize(&quot;hasAnyAuthority(&#x27;admin&#x27;,&#x27;test&#x27;,&#x27;system:dept:list&#x27;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hasRole要求有对应的角色才可以访问，但是它内部会把我们传入的参数拼接上 <strong>ROLE_</strong> 后再去比较。所以这种情况下要用用户对应的权限也要有 <strong>ROLE_</strong> 这个前缀才可以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize(&quot;hasRole(&#x27;system:dept:list&#x27;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hasAnyRole 有任意的角色就可以访问。它内部也会把我们传入的参数拼接上 ROLE_ 后再去比较。所以这种情况下要用用户对应的权限也要有 ROLE_ 这个前缀才可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize(&quot;hasAnyRole(&#x27;admin&#x27;,&#x27;system:dept:list&#x27;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义权限校验方法"><a href="#自定义权限校验方法" class="headerlink" title="自定义权限校验方法"></a>自定义权限校验方法</h2><p>也可以定义自己的权限校验方法，在@PreAuthorize注解中使用我们的方法。</p><p>创建一个类，注入到容器中，这个类定义权限校验方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给这个类起名字</span></span><br><span class="line"><span class="meta">@Component(&quot;ex&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SGExpressionRoot</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasAuthority</span><span class="params">(String authority)</span>&#123;</span><br><span class="line">        <span class="comment">//获取当前用户的权限</span></span><br><span class="line">        <span class="type">Authentication</span> <span class="variable">authentication</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line">        <span class="type">LoginUser</span> <span class="variable">loginUser</span> <span class="operator">=</span> (LoginUser) authentication.getPrincipal();</span><br><span class="line">        List&lt;String&gt; permissions = loginUser.getPermissions();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断用户权限集合中是否存在authority</span></span><br><span class="line">        <span class="keyword">return</span> permissions.contains(authority);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在SPEL表达式中使用 @ex相当于获取容器中名字为ex的bean对象。然后再调用这个对象的hasAuthority方法，区分框架自带的hasAuthority方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;@ex.hasAuthority(&#x27;system:dept:list&#x27;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="基于配置的权限控制"><a href="#基于配置的权限控制" class="headerlink" title="基于配置的权限控制"></a>基于配置的权限控制</h2><p>也可以在配置类中使用使用配置的方式对资源进行权限控制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http</span><br><span class="line">            <span class="comment">//关闭csrf</span></span><br><span class="line">            .csrf().disable()</span><br><span class="line">            <span class="comment">//不通过Session获取SecurityContext</span></span><br><span class="line">            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">            .and()</span><br><span class="line">            .authorizeRequests()</span><br><span class="line">            <span class="comment">// 对于登录接口，允许匿名访问</span></span><br><span class="line">            .antMatchers(<span class="string">&quot;/user/login&quot;</span>).anonymous()</span><br><span class="line">            .antMatchers(<span class="string">&quot;/testCors&quot;</span>).hasAuthority(<span class="string">&quot;system:dept:list222&quot;</span>)</span><br><span class="line">            <span class="comment">// 除上面外的所有请求全部需要鉴权认证</span></span><br><span class="line">            .anyRequest().authenticated();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加过滤器</span></span><br><span class="line">    http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置异常处理器</span></span><br><span class="line">    http.exceptionHandling()</span><br><span class="line">            <span class="comment">//配置认证失败处理器</span></span><br><span class="line">            .authenticationEntryPoint(authenticationEntryPoint)</span><br><span class="line">            .accessDeniedHandler(accessDeniedHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//允许跨域</span></span><br><span class="line">    http.cors();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="认证成功处理器"><a href="#认证成功处理器" class="headerlink" title="认证成功处理器"></a>认证成功处理器</h2><p>实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果登录成功了是会调用AuthenticationSuccessHandler的方法进行认证成功后的处理的。AuthenticationSuccessHandler就是登录成功处理器。</p><p>我们也可以自己去自定义成功处理器进行成功后的相应处理。</p><p>自定义实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SGSuccessHandler</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationSuccessHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationSuccess</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;认证成功了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建配置类，进行配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationSuccessHandler successHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http.formLogin().successHandler(successHandler);</span><br><span class="line"></span><br><span class="line">        http.authorizeRequests().anyRequest().authenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="认证失败处理器"><a href="#认证失败处理器" class="headerlink" title="认证失败处理器"></a>认证失败处理器</h2><p>实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果认证失败了是会调用AuthenticationFailureHandler的方法进行认证失败后的处理的。AuthenticationFailureHandler就是登录失败处理器。</p><p>我们也可以自己去自定义失败处理器进行失败后的相应处理</p><p>自定义实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SGFailureHandler</span> <span class="keyword">implements</span> <span class="title class_">AuthenticationFailureHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationFailure</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;认证失败了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建配置类，进行配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationSuccessHandler successHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationFailureHandler failureHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http.formLogin()</span><br><span class="line"><span class="comment">//                配置认证成功处理器</span></span><br><span class="line">                .successHandler(successHandler)</span><br><span class="line"><span class="comment">//                配置认证失败处理器</span></span><br><span class="line">                .failureHandler(failureHandler);</span><br><span class="line"></span><br><span class="line">        http.authorizeRequests().anyRequest().authenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="登出成功处理器"><a href="#登出成功处理器" class="headerlink" title="登出成功处理器"></a>登出成功处理器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SGLogoutSuccessHandler</span> <span class="keyword">implements</span> <span class="title class_">LogoutSuccessHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLogoutSuccess</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;注销成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationSuccessHandler successHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationFailureHandler failureHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LogoutSuccessHandler logoutSuccessHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http.formLogin()</span><br><span class="line"><span class="comment">//                配置认证成功处理器</span></span><br><span class="line">                .successHandler(successHandler)</span><br><span class="line"><span class="comment">//                配置认证失败处理器</span></span><br><span class="line">                .failureHandler(failureHandler);</span><br><span class="line"></span><br><span class="line">        http.logout()</span><br><span class="line">                <span class="comment">//配置注销成功处理器</span></span><br><span class="line">                .logoutSuccessHandler(logoutSuccessHandler);</span><br><span class="line"></span><br><span class="line">        http.authorizeRequests().anyRequest().authenticated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="核心接口"><a href="#核心接口" class="headerlink" title="核心接口"></a>核心接口</h1><p>Spring Security 是一个基于 Spring 的安全框架，它提供了一系列的接口和类来实现身份验证、授权、访问控制等安全功能。其中，Spring Security 核心接口包括：</p><ol><li>Authentication：表示用户的身份认证信息，包括用户名、密码、权限等信息。</li><li>AuthenticationManager：用于对用户的身份进行认证，验证用户的用户名和密码是否正确，并返回认证后的 Authentication 对象。</li><li>UserDetailsService：用于在认证过程中根据用户名加载用户信息，包括用户名、密码、权限等信息。</li><li>GrantedAuthority：表示用户被授予的权限，Spring Security 中的授权是基于权限的授权。</li><li>AccessDecisionManager：决定用户是否有权访问特定的资源，它根据用户的身份、所请求的资源以及用户被授予的权限，来决定是否允许用户访问该资源。</li><li>FilterSecurityInterceptor：用于保护 Web 应用程序中的特定 URL 资源，它根据用户的身份、所请求的资源以及用户被授予的权限，来决定是否允许用户访问该资源。</li><li>SecurityContext：用于存储当前用户的身份认证信息，包括 Authentication 对象和其他安全相关的信息。</li><li>SecurityContextHolder：用于访问 SecurityContext 对象，提供了一系列的静态方法来获取和设置 SecurityContext 对象，以便在整个应用程序中共享当前用户的身份认证信息。 以上是 Spring Security 中的一些核心接口，它们各自的作用如下：</li><li>Authentication 接口表示用户的身份认证信息，用于存储用户的认证信息，包括用户名、密码、权限等信息。</li><li>AuthenticationManager 接口用于对用户的身份进行认证，实现类通常需要从 UserDetailsService 中加载用户信息，并验证用户的用户名和密码是否正确，并返回认证后的 Authentication 对象。</li><li>UserDetailsService 接口用于在认证过程中根据用户名加载用户信息，包括用户名、密码、权限等信息。实现类通常需要从数据库或其他数据源中获取用户信息，以便进行身份认证。</li><li>GrantedAuthority 接口表示用户被授予的权限，Spring Security 中的授权是基于权限的授权。该接口通常由实现了该接口的类来表示用户的权限，如 SimpleGrantedAuthority。</li><li>AccessDecisionManager 接口用于决定用户是否有权访问特定的资源，它根据用户的身份、所请求的资源以及用户被授予的权限，来决定是否允许用户访问该资源。实现类通常需要根据用户的身份和权限，来决定是否允许用户访问该资源。</li><li>FilterSecurityInterceptor 接口用于保护 Web 应用程序中的特定 URL 资源，它根据用户的身份、所请求的资源以及用户被授予的权限，来决定是否允许用户访问该资源。实现类通常需要将其配置到 Spring Security 过滤器链中，以实现访问控制功能。</li><li>SecurityContext 接口用于存储当前用户的身份认证信息，包括 Authentication 对象和其他安全相关的信息。实现类通常需要将 SecurityContext 存储在 HttpSession 中，以便在整个应用程序中共享当前用户的身份认证信息。</li><li>SecurityContextHolder 类用于访问 SecurityContext 对象，提供了一系列的静态方法来获取和设置 SecurityContext 对象，以便在整个应用程序中共享当前用户的身份认证信息。实现类通常需要使用 SecurityContextHolder 来获取当前用户的身份认证信息。</li><li>AuthenticationProvider：用于对用户的身份进行认证，与 AuthenticationManager 类似，但是可以实现多种认证方式，如用户名密码认证、LDAP 认证等。</li><li>UserDetails：用于存储用户的详细信息，包括用户名、密码、权限等信息。通常由 UserDetailsService 返回，作为 Authentication 对象的一部分。</li><li>UserDetailsService：用于在认证过程中根据用户名加载用户信息，包括用户名、密码、权限等信息。与 UserDetailsService 接口类似，但是返回的是 UserDetails 对象，而不是 Authentication 对象。</li><li>RememberMeAuthenticationToken：用于在用户登录时，通过“记住我”功能，在用户下次访问该应用程序时，可以直接使用该令牌来自动登录。</li><li>RememberMeServices：用于处理“记住我”功能，当用户勾选“记住我”选项时，该服务将生成一个记住令牌并存储在用户的浏览器中，以便在下次访问该应用程序时自动登录。</li><li>SessionRegistry：用于管理应用程序中所有用户的会话信息，包括会话 ID、用户名等信息，以便在用户注销或超时时进行清理。</li><li>LogoutHandler：用于处理用户注销操作，包括清除用户的身份认证信息、清除用户的会话信息等。</li><li>LogoutSuccessHandler：用于处理用户注销成功后的操作，如重定向到登录页面等。</li><li>CsrfTokenRepository：用于存储 CSRF 令牌并验证 CSRF 攻击。</li><li>CsrfToken：用于表示 CSRF 令牌，包括令牌的值、过期时间等信息。</li><li>AccessDeniedHandler：用于处理用户没有访问权限时的操作，如重定向到错误页面等。</li><li>AuthenticationEntryPoint：用于处理未经身份认证的用户访问受保护的资源时的操作，如重定向到登录页面等。</li><li>SecurityMetadataSource：用于从应用程序中的配置信息中获取访问控制信息，包括 URL、角色等信息。</li><li>FilterInvocationSecurityMetadataSource：用于从应用程序中的配置信息中获取访问控制信息，并与请求的 URL 进行匹配，以确定是否允许访问该资源。</li><li>WebSecurityExpressionHandler：用于解析 Spring Security 中的表达式，以便在访问控制中使用。 以上是 Spring Security 中的一些接口，它们各自的作用如上所述。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringSecurity </tag>
            
            <tag> JWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-函数式编程</title>
      <link href="/2023/10/27/Java17%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/10/27/Java17%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><p>Lambda是JDK8中一个语法糖。他可以对某些匿名内部类的写法进行简化。它是函数式编程思想的一个 重要体现。</p><p>它不关注对象。更关注对数据进行了什么操作</p><p>使用条件：</p><ol><li>接口</li><li>接口里面只有一个抽象方法需要实现，但可以有多个default方法</li></ol><p>核心原则：可推导，可省略</p><ul><li>比如：根据方法名，我们能找到形参，确定形参类型，然后因为只有一个抽象方法，我们能确定里面的方法，进一步确定方法的形参的类型</li></ul><p>快捷键：</p><ul><li>alt + enter，如果能用lambda，按这个是会有提示的</li></ul><h2 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h2><h3 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(参数列表)-&gt;&#123;代码&#125;</span><br></pre></td></tr></table></figure><h3 id="省略规则"><a href="#省略规则" class="headerlink" title="省略规则"></a>省略规则</h3><ol><li>参数类型可以省略</li><li>方法体只有一句代码时<code>&#123;&#125;</code>和<code>return</code>和<code>;</code>可以省略</li><li>方法只有一个参数时<code>()</code>可以省略</li><li>以上这些规则都记不住也可以省略不记，快捷键</li></ol><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ol><li><p>在创建线程并启动时可以使用匿名内部类的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;你知道吗 我比你想象的 更想在你身边&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();    </span><br></pre></td></tr></table></figure><p>使用Lambda简化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;你知道吗 我比你想象的 更想在你身边&quot;</span>);</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure></li><li><p>现有方法定义如下，其中IntBinaryOperator是一个接口。先使用匿名内部类的写法调用该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateNum</span><span class="params">(IntBinaryOperator operator)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">return</span> operator.applyAsInt(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> calculateNum(<span class="keyword">new</span> <span class="title class_">IntBinaryOperator</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">applyAsInt</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> left + right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Lambda简化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> calculateNum((<span class="type">int</span> left, <span class="type">int</span> right)-&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> left + right;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>现有方法定义如下，其中IntPredicate是一个接口。先使用匿名内部类的写法调用该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printNum</span><span class="params">(IntPredicate predicate)</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span>(predicate.test(i))&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    printNum(<span class="keyword">new</span> <span class="title class_">IntPredicate</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value%<span class="number">2</span>==<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用Lambda简化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    printNum((<span class="type">int</span> value)-&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> value%<span class="number">2</span>==<span class="number">0</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printNum</span><span class="params">(IntPredicate predicate)</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">        <span class="keyword">if</span>(predicate.test(i))&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>现有方法定义如下，其中Function是一个接口。先使用匿名内部类的写法调用该方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;R&gt; R <span class="title function_">typeConver</span><span class="params">(Function&lt;String,R&gt; function)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;1235&quot;</span>;</span><br><span class="line">    <span class="type">R</span> <span class="variable">result</span> <span class="operator">=</span> function.apply(str);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> typeConver(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;String, Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">apply</span><span class="params">(String s)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.valueOf(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用Lambda简化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> typeConver((String s)-&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.valueOf(s);</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure></li><li><p>现有方法定义如下，其中IntConsumer是一个接口。先使用匿名内部类的写法调用该方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foreachArr</span><span class="params">(IntConsumer consumer)</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">        consumer.accept(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    foreachArr(<span class="keyword">new</span> <span class="title class_">IntConsumer</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Lambda简化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    foreachArr((<span class="type">int</span> value)-&gt;&#123;</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h1><p>Java8的Stream使用的是函数式编程模式，它可以被用来对集合或数组进行链状流 式的操作。可以更方便的对集合或数组操作。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><ol><li><p>项目搭建</p><p>搭建一个maven项目，顺便引入lombok的依赖，用于输出日志</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>数据准备</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode</span><span class="comment">//用于后期的去重使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Author</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String intro;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Book&gt; books;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode</span><span class="comment">//用于后期的去重使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String category;</span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line">    <span class="keyword">private</span> String intro;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动类测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlogApplication</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//打印所有年龄小于18的作家的名字，并且要注意去重</span></span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">        authors.stream()<span class="comment">//把集合转换成流，不然不能使用流的方法</span></span><br><span class="line">               .distinct()<span class="comment">//先去除重复的作家</span></span><br><span class="line">               .filter(author -&gt; author.getAge()&lt;<span class="number">18</span>)<span class="comment">//筛选年龄小于18的</span></span><br><span class="line">               .forEach(author -&gt; System.out.println(author.getName()));<span class="comment">//遍历打印名字</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Author&gt; <span class="title function_">getAuthors</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//数据初始化</span></span><br><span class="line">        <span class="type">Author</span> <span class="variable">author</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Author</span>(<span class="number">1L</span>, <span class="string">&quot;蒙多&quot;</span>, <span class="number">33</span>, <span class="string">&quot;一个从菜刀中明悟哲理的祖安人&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="type">Author</span> <span class="variable">author2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Author</span>(<span class="number">2L</span>, <span class="string">&quot;亚拉索&quot;</span>, <span class="number">15</span>, <span class="string">&quot;狂风也追逐不上他的思考速度&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="type">Author</span> <span class="variable">author3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Author</span>(<span class="number">3L</span>, <span class="string">&quot;易&quot;</span>, <span class="number">14</span>, <span class="string">&quot;是这个世界在限制他的思维&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="type">Author</span> <span class="variable">author4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Author</span>(<span class="number">3L</span>, <span class="string">&quot;易&quot;</span>, <span class="number">14</span>, <span class="string">&quot;是这个世界在限制他的思维&quot;</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//书籍列表</span></span><br><span class="line">        List&lt;Book&gt; books1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Book&gt; books2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Book&gt; books3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        books1.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="number">1L</span>, <span class="string">&quot;刀的两侧是光明与黑暗&quot;</span>, <span class="string">&quot;哲学,爱情&quot;</span>, <span class="number">88</span>, <span class="string">&quot;用一把刀划分了爱恨&quot;</span>));</span><br><span class="line">        books1.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="number">2L</span>, <span class="string">&quot;一个人不能死在同一把刀下&quot;</span>, <span class="string">&quot;个人成长,爱情&quot;</span>, <span class="number">99</span>, <span class="string">&quot;讲述如何从失败中明悟真理&quot;</span>));</span><br><span class="line"></span><br><span class="line">        books2.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="number">3L</span>, <span class="string">&quot;那风吹不到的地方&quot;</span>, <span class="string">&quot;哲学&quot;</span>, <span class="number">85</span>, <span class="string">&quot;带你用思维去领略世界的尽头&quot;</span>));</span><br><span class="line">        books2.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="number">3L</span>, <span class="string">&quot;那风吹不到的地方&quot;</span>, <span class="string">&quot;哲学&quot;</span>, <span class="number">85</span>, <span class="string">&quot;带你用思维去领略世界的尽头&quot;</span>));</span><br><span class="line">        books2.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="number">4L</span>, <span class="string">&quot;吹或不吹&quot;</span>, <span class="string">&quot;爱情,个人传记&quot;</span>, <span class="number">56</span>, <span class="string">&quot;一个哲学家的恋爱观注定很难把他所在的时代理解&quot;</span>));</span><br><span class="line"></span><br><span class="line">        books3.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="number">5L</span>, <span class="string">&quot;你的剑就是我的剑&quot;</span>, <span class="string">&quot;爱情&quot;</span>, <span class="number">56</span>, <span class="string">&quot;无法想象一个武者能对他的伴侣这么的宽容&quot;</span>));</span><br><span class="line">        books3.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="number">6L</span>, <span class="string">&quot;风与剑&quot;</span>, <span class="string">&quot;个人传记&quot;</span>, <span class="number">100</span>, <span class="string">&quot;两个哲学家灵魂和肉体的碰撞会激起怎么样的火花呢？&quot;</span>));</span><br><span class="line">        books3.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="number">6L</span>, <span class="string">&quot;风与剑&quot;</span>, <span class="string">&quot;个人传记&quot;</span>, <span class="number">100</span>, <span class="string">&quot;两个哲学家灵魂和肉体的碰撞会激起怎么样的火花呢？&quot;</span>));</span><br><span class="line"></span><br><span class="line">        author.setBooks(books1);</span><br><span class="line">        author2.setBooks(books2);</span><br><span class="line">        author3.setBooks(books3);</span><br><span class="line">        author4.setBooks(books3);</span><br><span class="line"></span><br><span class="line">        List&lt;Author&gt; authorList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;</span><br><span class="line">                (Arrays.asList(author, author2, author3, author4));</span><br><span class="line">        <span class="keyword">return</span> authorList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>JDK提供的STREAM的方法在stream类中，集合不能直接调用。但是集合有一个叫stream的方法，能返回一个stream类型的结果。先调用这个方法，然后用链式方法调用其他stream的方法</p></blockquote><h2 id="流的操作"><a href="#流的操作" class="headerlink" title="流的操作"></a>流的操作</h2><h3 id="创建流"><a href="#创建流" class="headerlink" title="创建流"></a>创建流</h3><div class="tabs" id=""><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#-1">单列集合</button></li><li class="tab"><button type="button" data-href="#-2">数组</button></li><li class="tab"><button type="button" data-href="#-3">双列集合</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="-1"><ul><li>集合对象.stream()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">Stream&lt;Author&gt; stream = authors.stream();</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-2"><ul><li>Arrays.stream(数组)</li><li>Stream.of(数组)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">Stream&lt;Integer&gt; stream = Arrays.stream(arr);</span><br><span class="line">Stream&lt;Integer&gt; stream2 = Stream.of(arr);</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-3"><p>转换成单列集合后再创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;蜡笔小新&quot;</span>,<span class="number">19</span>);</span><br><span class="line">map.put(<span class="string">&quot;黑子&quot;</span>,<span class="number">17</span>);</span><br><span class="line">map.put(<span class="string">&quot;日向翔阳&quot;</span>,<span class="number">16</span>);</span><br><span class="line">Stream&lt;Map.Entry&lt;String, Integer&gt;&gt; stream = map.entrySet().stream();</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h2><ul><li><p>filter：可以对流中的元素进行条件过滤，里面用一个boolean的方法，true留下，false排除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取stream流</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;张老三&quot;</span>, <span class="string">&quot;张小三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;赵五&quot;</span>, <span class="string">&quot;刘六&quot;</span>, <span class="string">&quot;王七&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需求：过去出姓张的元素</span></span><br><span class="line">stream.filter((String name)-&gt;&#123; <span class="keyword">return</span> name.startsWith(<span class="string">&quot;张&quot;</span>);&#125;)</span><br><span class="line">      .forEach((String name)-&gt;&#123; System.out.println(<span class="string">&quot;流中的元素&quot;</span> + name);&#125;)</span><br></pre></td></tr></table></figure></li><li><p>map：可以把对流中的元素进行计算或转换</p><p>如原来是个实体类，换成实体类的一个元素。</p><p>形参有2个，第一个类型被泛型制定了，第二个用来指定转换后的类型，根据这两个，把流里面的内容进行转换。具体实现的功能由相应的代码决定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">authors</span><br><span class="line">    .stream()</span><br><span class="line">    .map(author -&gt; author.getName())</span><br><span class="line">    .forEach(name-&gt;System.out.println(name));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印所有作家的姓名</span></span><br><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"></span><br><span class="line">authors.stream()</span><br><span class="line">       .map(author -&gt; author.getName())</span><br><span class="line">       .forEach(s -&gt; System.out.println(s));</span><br><span class="line"><span class="comment">//流是一次性的，上面生效以后下面就失效了</span></span><br><span class="line">authors.stream()</span><br><span class="line">       .map(author -&gt; author.getAge())</span><br><span class="line">       .map(age-&gt;age+<span class="number">10</span>)</span><br><span class="line">       .forEach(age-&gt; System.out.println(age));</span><br></pre></td></tr></table></figure></li><li><p>distinct：依赖Object的equals方法来判断是否是相同对象的，然后去重</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">authors.stream()</span><br><span class="line">       .distinct()</span><br><span class="line">       .forEach(author -&gt; System.out.println(author.getName()));</span><br></pre></td></tr></table></figure></li><li><p>sorted：对流中的元素进行排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"><span class="comment">// 对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素。</span></span><br><span class="line">authors.stream()</span><br><span class="line">       .distinct()</span><br><span class="line">       .sorted()</span><br><span class="line">       .forEach(author -&gt; System.out.println(author.getAge()));</span><br><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素。</span></span><br><span class="line">authors.stream()</span><br><span class="line">       .distinct()</span><br><span class="line">       .sorted((o1, o2) -&gt; o2.getAge()-o1.getAge())</span><br><span class="line">       .forEach(author -&gt; System.out.println(author.getAge()));</span><br></pre></td></tr></table></figure></li><li><p>limit：可以设置流的最大长度，超出的部分将被抛弃，类似截取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">authors.stream()</span><br><span class="line">       .distinct()</span><br><span class="line">       .sorted()</span><br><span class="line">       .limit(<span class="number">2</span>)</span><br><span class="line">       .forEach(author -&gt; System.out.println(author.getName()));</span><br></pre></td></tr></table></figure></li><li><p>skip：跳过流中的前n个元素，返回剩下的元素，类似截取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印除了年龄最大的作家外的其他作家，要求不能有重复元素，并且按照年龄降序排序。</span></span><br><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">authors.stream()</span><br><span class="line">       .distinct()</span><br><span class="line">       .sorted()</span><br><span class="line">       .skip(<span class="number">1</span>)</span><br><span class="line">       .forEach(author -&gt; System.out.println(author.getName()));</span><br></pre></td></tr></table></figure></li><li><p>flatMap：map只能把一个对象转换成另一个对象来作为流中的元素。而flatMap可以把一个对象转换成多个对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 打印所有书籍的名字。要求对重复的元素进行去重。</span></span><br><span class="line">  List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">  authors.stream()</span><br><span class="line">         .flatMap(author -&gt; author.getBooks().stream())</span><br><span class="line">         .distinct()</span><br><span class="line">         .forEach(book -&gt; System.out.println(book.getName()));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##  终结操作</span><br><span class="line"></span><br><span class="line">+ forEach：对流中的元素进行遍历操作</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  <span class="comment">//输出所有作家的名字</span></span><br><span class="line">  List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">  </span><br><span class="line">  authors.stream()<span class="comment">//转成流</span></span><br><span class="line">         .map(author -&gt; author.getName())<span class="comment">//转内部元素</span></span><br><span class="line">         .distinct()<span class="comment">//去重</span></span><br><span class="line">         .forEach(name-&gt; System.out.println(name));</span><br></pre></td></tr></table></figure></li><li><p>count：可以用来获取当前流中元素的个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印这些作家的所出书籍的数目，注意删除重复元素。</span></span><br><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> authors.stream()<span class="comment">//转成流</span></span><br><span class="line">                    .flatMap(author -&gt; author.getBooks().stream())<span class="comment">//转内部元素</span></span><br><span class="line">                    .distinct()<span class="comment">//去重</span></span><br><span class="line">                    .count();</span><br><span class="line">System.out.println(count);</span><br></pre></td></tr></table></figure></li><li><p>max&amp;min：可以用来或者流中的最值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分别获取这些作家的所出书籍的最高分和最低分并打印。</span></span><br><span class="line"><span class="comment">//Stream&lt;Author&gt; -&gt; Stream&lt;Book&gt; -&gt;Stream&lt;Integer&gt; -&gt;求值</span></span><br><span class="line"></span><br><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">Optional&lt;Integer&gt; max = authors.stream()</span><br><span class="line">                               .flatMap(author -&gt; author.getBooks().stream())</span><br><span class="line">                               .map(book -&gt; book.getScore())</span><br><span class="line">                               .max((score1, score2) -&gt; score1 - score2);</span><br><span class="line">System.out.println(max.get());</span><br><span class="line"></span><br><span class="line">Optional&lt;Integer&gt; min = authors.stream()</span><br><span class="line">                               .flatMap(author -&gt; author.getBooks().stream())</span><br><span class="line">                               .map(book -&gt; book.getScore())</span><br><span class="line">                               .min((score1, score2) -&gt; score1 - score2);</span><br><span class="line">System.out.println(min.get());</span><br></pre></td></tr></table></figure></li><li><p>collect：把当前流转换成一个集合。</p><p>转换List集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取一个存放所有作者名字的List集合</span></span><br><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">List&lt;String&gt; nameList = authors.stream()</span><br><span class="line">                               .map(author -&gt; author.getName())</span><br><span class="line">                               .collect(Collectors.toList());</span><br><span class="line">System.out.println(nameList);</span><br></pre></td></tr></table></figure><p>转换Set集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取一个所有书名的Set集合。</span></span><br><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">Set&lt;Book&gt; books = authors.stream()</span><br><span class="line">                         .flatMap(author -&gt; author.getBooks().stream())</span><br><span class="line">                         .collect(Collectors.toSet());</span><br><span class="line">System.out.println(books);</span><br></pre></td></tr></table></figure><p>转换Map集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取一个Map集合，map的key为作者名，value为List&lt;Book&gt;</span></span><br><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">Map&lt;String, List&lt;Book&gt;&gt; map = authors.stream()</span><br><span class="line">                                     .distinct()</span><br><span class="line">                                     .collect(Collectors.toMap(author -&gt; author.getName(), author -&gt; author.getBooks()));</span><br><span class="line">System.out.println(map);</span><br></pre></td></tr></table></figure></li></ul><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><ul><li><p>anyMatch：可以用来判断是否有任意符合匹配条件的元素，结果为boolean类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否有年龄在29以上的作家</span></span><br><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> authors.stream()</span><br><span class="line">                      .anyMatch(author -&gt; author.getAge() &gt; <span class="number">29</span>);</span><br><span class="line">System.out.println(flag);</span><br></pre></td></tr></table></figure></li><li><p>allMatch：可以用来判断是否都符合匹配条件，结果为boolean类型。如果都符合结果为true，否则结果为false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否所有的作家都是成年人</span></span><br><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> authors.stream()</span><br><span class="line">                      .allMatch(author -&gt; author.getAge() &gt;= <span class="number">18</span>);</span><br><span class="line">System.out.println(flag);</span><br></pre></td></tr></table></figure></li><li><p>noneMatch：可以判断流中的元素是否都不符合匹配条件。如果都不符合结果为true，否则结果为false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断作家是否都没有超过100岁的。</span></span><br><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> authors.stream()</span><br><span class="line">                   .noneMatch(author -&gt; author.getAge() &gt; <span class="number">100</span>);</span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure></li><li><p>findAny：获取流中的任意一个元素。该方法没有办法保证获取的一定是流中的第一个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取任意一个年龄大于18的作家，如果存在就输出他的名字</span></span><br><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">Optional&lt;Author&gt; optionalAuthor = authors.stream()</span><br><span class="line">                                         .filter(author -&gt; author.getAge()&gt;<span class="number">18</span>)</span><br><span class="line">                                         .findAny();</span><br><span class="line">optionalAuthor.ifPresent(author -&gt; System.out.println(author.getName()));</span><br></pre></td></tr></table></figure></li><li><p>findFirst：获取流中的第一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取一个年龄最小的作家，并输出他的姓名。</span></span><br><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">Optional&lt;Author&gt; first = authors.stream()</span><br><span class="line">                                .sorted((o1, o2) -&gt; o1.getAge() - o2.getAge())</span><br><span class="line">                                .findFirst();</span><br><span class="line">first.ifPresent(author -&gt; System.out.println(author.getName()));</span><br></pre></td></tr></table></figure></li></ul><h3 id="reduce归并"><a href="#reduce归并" class="headerlink" title="reduce归并"></a>reduce归并</h3><p>对流中的数据按照你指定的计算方式计算出一个结果。（缩减操作） reduce的作用是把stream中的元素给组合起来，我们可以传入一个初始值，它会按照我们的计算方式依 次拿流中的元素和初始化值进行计算，计算结果再和后面的元素计算。</p><p>reduce两个参数的重载形式内部的计算方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> identity;</span><br><span class="line"><span class="keyword">for</span> (T element : <span class="built_in">this</span> stream) &#123;</span><br><span class="line">    result = accumulator.apply(result, element)</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>惰性求值（如果没有终结操作，没有中间操作是不会得到执行的）</li><li>流是一次性的（一旦一个流对象经过一个终结操作后。这个流就不能再被使用）</li><li>不会影响原数据（我们在流中可以多数据做很多处理。但是正常情况下是不会影响原来集合中的元 素的。这往往也是我们期望的）</li></ul><h1 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h1><p> 概述</p><p>在编写代码的时候出现最多的就是空指针异常。所以在很多情况下我们需要做各种非空的判断，尤其是对象中的属性还是一个对象的情况下。这种判断会更多。 而过多的判断语句会让我们的代码显得臃肿不堪。 </p><p>在JDK8中引入了Optional,养成使用Optional的习惯后你可以写出更优雅的代码来避免空指针异常</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>创建对象 Optional就好像是包装类，可以把我们的具体数据封装Optional对象内部。然后我们去使用Optional中 封装好的方法操作封装进去的数据就可以非常优雅的避免空指针异常。</p><p>我们一般使用Optional的静态方法<code>ofNullable</code>来把数据封装成一个Optional对象。无论传入的参数是否 为null都不会出现问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Author</span> <span class="variable">author</span> <span class="operator">=</span> getAuthor();</span><br><span class="line">Optional&lt;Author&gt; authorOptional = Optional.ofNullable(author);</span><br></pre></td></tr></table></figure><p>也可以果改造getAuthor方法，让其的返回值就是封装好的Optional</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在实际开发中我们的数据很多是从数据库获取的。Mybatis从<span class="number">3.5</span>版本可以也已经支持Optional了。 我们可以直接把dao方法的返回值类型定义成Optional类型，MyBastis会自己把数据封装成Optional对 象返回。封装的过程也不需要我们自己操作。</span><br><span class="line"></span><br><span class="line">&gt; 如果能确定一个对象不是空的，则可以使用Optional的静态方法of来把数据封装成Optional对象。一定要注意，使用of的时候传入的参数必须不为<span class="literal">null</span>。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果一个方法的返回值类型是Optional类型。而如果我们经判断发现某次计算得到的返回值为<span class="literal">null</span>，这 个时候就需要把<span class="literal">null</span>封装成Optional对象返回。这时则可以使用`Optional.empty`来进行封装。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 安全使用值</span><br><span class="line"></span><br><span class="line">获取到一个Optional对象后肯定需要对其中的数据进行使用。这时候我们可以使用其ifPresent方法来使用其中的值，这个方法会判断其内封装的数据是否为空，不为空时才会执行具体的使用代码。这样使用起来就更加安全</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">Optional&lt;Author&gt; authorOptional = Optional.ofNullable(getAuthor());</span><br><span class="line">authorOptional.ifPresent(author -&gt; System.out.println(author.getName()));</span><br></pre></td></tr></table></figure><h2 id="安全获取值"><a href="#安全获取值" class="headerlink" title="安全获取值"></a>安全获取值</h2><p>如果我们想获取值自己进行处理可以使用get方法获取，但是不推荐。因为当Optional内部的数据为空的时候会出现异常</p><p>如果我们期望安全的获取值。可以使用Optional提供的以下方法</p><ul><li><p>orElseGet</p><p>获取数据并且设置数据为空时的默认值。如果数据不为空就能获取到该数据。如果为空则根据你传入的参数来创建对象作为默认值返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Author&gt; authorOptional = Optional.ofNullable(getAuthor());</span><br><span class="line"><span class="type">Author</span> <span class="variable">author1</span> <span class="operator">=</span> authorOptional.orElseGet(() -&gt; <span class="keyword">new</span> <span class="title class_">Author</span>());</span><br></pre></td></tr></table></figure></li><li><p>orElseThrow</p><p>获取数据，如果数据不为空就能获取到该数据。如果为空则根据你传入的参数来创建异常抛出。配合框架可以进行异常管理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Author&gt; authorOptional = Optional.ofNullable(getAuthor());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Author</span> <span class="variable">author</span> <span class="operator">=</span> authorOptional.orElseThrow((Supplier&lt;Throwable&gt;) () -&gt; <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;author为空&quot;</span>));</span><br><span class="line">    System.out.println(author.getName());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">    throwable.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><p>可以使用filter方法对数据进行过滤。如果原本是有数据的，但是不符合判断，也会变成一个无数据 的Optional对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Author&gt; authorOptional = Optional.ofNullable(getAuthor());</span><br><span class="line">authorOptional.filter(author -&gt; author.getAge()&gt;<span class="number">100</span>)</span><br><span class="line">              .ifPresent(author -&gt; System.out.println(author.getName()));</span><br></pre></td></tr></table></figure><h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><p>我们可以使用isPresent方法进行是否存在数据的判断。如果为空返回值为false,如果不为空，返回值为 true。但是这种方式并不能体现Optional的好处，更推荐使用ifPresent方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Author&gt; authorOptional = Optional.ofNullable(getAuthor());</span><br><span class="line"><span class="keyword">if</span> (authorOptional.isPresent()) &#123;</span><br><span class="line">    System.out.println(authorOptional.get().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h2><p>Optional还提供了map可以让我们的对数据进行转换，并且转换得到的数据也还是被Optional包装好 的，保证了我们的使用安全</p><p>例如我们想获取作家的书籍集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testMap</span><span class="params">()</span> &#123;</span><br><span class="line">    Optional&lt;Author&gt; authorOptional = getAuthorOptional();</span><br><span class="line">    Optional&lt;List&lt;Book&gt;&gt; optionalBooks = authorOptional.map(author -&gt; author.getBooks());</span><br><span class="line">    optionalBooks.ifPresent(books -&gt; System.out.println(books));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h1><p><strong>只有一个抽象方法的接口</strong>我们称之为函数接口。 JDK的函数式接口都加上了@FunctionalInterface 注解进行标识。但是无论是否加上该注解只要接口中只有一个抽象方法，都是函数式接口</p><h2 id="常见函数式接口"><a href="#常见函数式接口" class="headerlink" title="常见函数式接口"></a>常见函数式接口</h2><ul><li>Consumer 消费接口根据其中抽象方法的参数列表和返回值类型知道，我们可以在方法中对传入的参数进行消费</li><li>Function 计算转换接口根据其中抽象方法的参数列表和返回值类型知道，我们可以在方法中对传入的参数计算或转换，把结果返回</li><li>Predicate 判断接口根据其中抽象方法的参数列表和返回值类型知道，我们可以在方法中对传入的参数条件判断，返回判断结果</li><li>Supplier 生产型接口 根据其中抽象方法的参数列表和返回值类型知道，我们可以在方法中创建对象，把创建好的对象返回</li></ul><h2 id="常用的默认方法"><a href="#常用的默认方法" class="headerlink" title="常用的默认方法"></a>常用的默认方法</h2><ul><li><p>and</p><p>使用Predicate接口时候可能需要进行判断条件的拼接。而and方法相当于是使用<code>&amp;&amp;</code>来拼接两个判断条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印作家中年龄大于17并且姓名的长度大于1的作家</span></span><br><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">Stream&lt;Author&gt; authorStream = authors.stream();</span><br><span class="line">authorStream.filter(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Author&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> author.getAge()&gt;<span class="number">17</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.and(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Author&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> author.getName().length()&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)).forEach(author -&gt; System.out.println(author));</span><br></pre></td></tr></table></figure></li><li><p>or</p><p>使用Predicate接口时候可能需要进行判断条件的拼接。而or方法相当于是使用<code>||</code>来拼接两 个判断条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印作家中年龄大于17或者姓名的长度小于2的作家</span></span><br><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">authors.stream()</span><br><span class="line">       .filter(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Author&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> author.getAge()&gt;<span class="number">17</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;.or(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Author&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> author.getName().length()&lt;<span class="number">2</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;))</span><br><span class="line">        .forEach(author -&gt; System.out.println(author.getName()));</span><br></pre></td></tr></table></figure></li><li><p>negate</p><p>Predicate接口中的方法。negate方法相当于是在判断添加前面加了个<code>! </code>表示取反</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印作家中年龄不大于17的作家。</span></span><br><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">authors.stream()</span><br><span class="line">       .filter(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Author&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Author author)</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> author.getAge()&gt;<span class="number">17</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;.negate())</span><br><span class="line">        .forEach(author -&gt; System.out.println(author.getAge()));</span><br></pre></td></tr></table></figure></li></ul><h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><p>在使用lambda时，如果方法体中只有一个方法的调用的话（包括构造方法）,我们可以用方法引用进一步简化代码。</p><p>先写Lambda表达式，在使用lambda时不需要考虑什么时候用方法引用，用哪种方法引用，方法引用的格式是什么。写完lambda方法发现方法体只有一行代码，并且是方法的调用时，可能可以转换为方法引用，使用匿名内部类转换的快捷键可以验证</p><p>基本格式：<code>类名或者对象名::方法名</code></p><blockquote><p>方法引用也是个语法糖，但是规则繁琐</p></blockquote><h2 id="语法详解-了解"><a href="#语法详解-了解" class="headerlink" title="语法详解(了解)"></a>语法详解(了解)</h2><h3 id="引用类的静态方法"><a href="#引用类的静态方法" class="headerlink" title="引用类的静态方法"></a>引用类的静态方法</h3><p>格式：<code>类名::方法名</code></p><p>使用前提：在重写方法的时候，方法体中<strong>只有一行代码</strong>，并且这行代码是调用了<strong>某个类的静态方法</strong>，并且 我们把要重写的<strong>抽象方法中所有的参数都按照顺序传入了这个静态方法中</strong>，这个时候我们就可以引用类的静态方法。</p><p>如果重写的方法是<strong>无参的</strong>，调用的方法也是没有参数的也相当于符合以上规则</p><p>例如：</p><ul><li><p>优化前</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">Stream&lt;Author&gt; authorStream = authors.stream();</span><br><span class="line">authorStream.map(author -&gt; author.getAge())</span><br><span class="line">            .map(age-&gt;String.valueOf(age));</span><br></pre></td></tr></table></figure></li><li><p>优化后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">Stream&lt;Author&gt; authorStream = authors.stream();</span><br><span class="line">authorStream.map(author -&gt; author.getAge())</span><br><span class="line">            .map(String::valueOf);</span><br></pre></td></tr></table></figure></li></ul><h3 id="引用对象的实例方法"><a href="#引用对象的实例方法" class="headerlink" title="引用对象的实例方法"></a>引用对象的实例方法</h3><p>格式：<code>对象名::方法名</code></p><p>使用前提：重写方法的时候，方法体中<strong>只有一行代码</strong>，并且这行代码是调用了<strong>某个对象的成员方法</strong>，并 且我们把要重写的<strong>抽象方法中所有的参数都按照顺序传入了这个成员方法中</strong>，这个时候我们就可以引用 对象的实例方法</p><p>这里无参不行了</p><p>例如：</p><ul><li><p>优化前</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">Stream&lt;Author&gt; authorStream = authors.stream();</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">authorStream.map(author -&gt; author.getName())</span><br><span class="line">            .forEach(name-&gt;sb.append(name));</span><br></pre></td></tr></table></figure></li><li><p>优化后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">Stream&lt;Author&gt; authorStream = authors.stream();</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">authorStream.map(author -&gt; author.getName())</span><br><span class="line">            .forEach(sb::append);</span><br></pre></td></tr></table></figure></li></ul><h3 id="引用类的实例方法"><a href="#引用类的实例方法" class="headerlink" title="引用类的实例方法"></a>引用类的实例方法</h3><p>格式：<code>类名::方法名</code></p><p>使用前提：重写方法的时候，方法体中<strong>只有一行代码</strong>，并且这行代码是<strong>调用了第一个参数（这个参数是个实例化对象）的成员方法</strong>， 重写的抽象方法中<strong>剩余的所有的参数</strong>都按照顺序传入了这个成员方法中，就可以引用类的实例方法。</p><blockquote><p>第一个参数充当实例化对象，然后用这个对象通过剩下的参数调用方法</p></blockquote><p>例如：</p><ul><li><p>优化前</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">UseString</span>&#123;</span><br><span class="line">    String <span class="title function_">use</span><span class="params">(String str,<span class="type">int</span> start,<span class="type">int</span> length)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">subAuthorName</span><span class="params">(String str, UseString useString)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> useString.use(str,start,length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    subAuthorName(<span class="string">&quot;三更草堂&quot;</span>, <span class="keyword">new</span> <span class="title class_">UseString</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">use</span><span class="params">(String str, <span class="type">int</span> start, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> str.substring(start,length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>优化后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    subAuthorName(<span class="string">&quot;三更草堂&quot;</span>, String::substring);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h3><p>格式：<code>类名::new</code></p><p>使用前提：重写方法的时候，方法体中<strong>只有一行代码</strong>，并且这行代码是调用了某个类的<strong>构造方法</strong>，重写的抽象方法中的<strong>所有的参数都按照顺序传入了这个构造方法中</strong>，这个时候我们就可以引用构造器。</p><p>例如：</p><ul><li><p>优化前</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">authors.stream()</span><br><span class="line">       .map(author -&gt; author.getName())</span><br><span class="line">       .map(name-&gt;<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(name))</span><br><span class="line">       .map(sb-&gt;sb.append(<span class="string">&quot;-三更&quot;</span>).toString())</span><br><span class="line">       .forEach(str-&gt; System.out.println(str));</span><br></pre></td></tr></table></figure></li><li><p>优化后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">authors.stream()</span><br><span class="line">       .map(author -&gt; author.getName())</span><br><span class="line">       .map(StringBuilder::<span class="keyword">new</span>)</span><br><span class="line">       .map(sb-&gt;sb.append(<span class="string">&quot;-三更&quot;</span>).toString())</span><br><span class="line">       .forEach(str-&gt; System.out.println(str));</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用原则"><a href="#使用原则" class="headerlink" title="使用原则"></a>使用原则</h2><p>熟练可以直接写Lambda表达式，不熟练可以先写匿名内部类，然后<code>alt + enter</code>，能简化简化，不能就算了</p><h1 id="基本数据类型优化"><a href="#基本数据类型优化" class="headerlink" title="基本数据类型优化"></a>基本数据类型优化</h1><p>之前用到的很多Stream的方法由于都使用了泛型。所以涉及到的参数和返回值都是引用数据类型。所以，操作的整数小数，实际用的是<strong>包装类</strong>。</p><p>虽然JDK5中引入的自动装箱和自动拆箱让我 们在使用对应的包装类时就好像使用基本数据类型一样方便。但是装箱和拆箱要消耗时间的。</p><p>在大量的数据不断的重复装箱拆箱的时候，不能无视这个时间损耗。</p><p>为了对这部分的时间消耗进行优化。Stream还提供了很多专门针对基本数据类型的方法</p><p>例如：mapToInt,mapToLong,mapToDouble,flatMapToInt,flatMapToDouble等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test27</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">    authors.stream()<span class="comment">//没使用转换，以后每次操作都有装箱和拆箱</span></span><br><span class="line">        .map(author -&gt; author.getAge())</span><br><span class="line">        .map(age -&gt; age + <span class="number">10</span>)</span><br><span class="line">        .filter(age-&gt;age&gt;<span class="number">18</span>)</span><br><span class="line">        .map(age-&gt;age+<span class="number">2</span>)</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">    </span><br><span class="line">    authors.stream()<span class="comment">//使用转换，已经都是int类型了</span></span><br><span class="line">        .mapToInt(author -&gt; author.getAge())</span><br><span class="line">        .map(age -&gt; age + <span class="number">10</span>)</span><br><span class="line">        .filter(age-&gt;age&gt;<span class="number">18</span>)</span><br><span class="line">        .map(age-&gt;age+<span class="number">2</span>)</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h1><p>当流中有大量元素时，可以使用并行流去提高操作的效率。</p><p>并行流就是把任务分配给多个线程去完成。如果用自己的代码实现的话其实会非常的复杂，并且要求你对并发编程有足够的理解和认识。</p><p>但如果使用Stream的话，我们只需要修改一个方法的调用就可以使用并行流来帮我们实现，从而提高效率。</p><p>parallel方法可以把串行流转换成并行流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test28</span><span class="params">()</span> &#123;</span><br><span class="line">    Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> stream.parallel()</span><br><span class="line">                        .peek(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Integer&gt;() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Integer num)</span> &#123;</span><br><span class="line">                                System.out.println(num+Thread.currentThread().getName());</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;)</span><br><span class="line">                        .filter(num -&gt; num &gt; <span class="number">5</span>)</span><br><span class="line">                        .reduce((result, ele) -&gt; result + ele)</span><br><span class="line">                        .get();</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以通过parallelStream直接获取并行流对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">authors.parallelStream()</span><br><span class="line">       .map(author -&gt; author.getAge())</span><br><span class="line">       .map(age -&gt; age + <span class="number">10</span>)</span><br><span class="line">       .filter(age-&gt;age&gt;<span class="number">18</span>)</span><br><span class="line">       .map(age-&gt;age+<span class="number">2</span>)</span><br><span class="line">       .forEach(System.out::println);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot</title>
      <link href="/2023/10/24/SpringBoot/"/>
      <url>/2023/10/24/SpringBoot/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot简介"><a href="#SpringBoot简介" class="headerlink" title="SpringBoot简介"></a>SpringBoot简介</h1><p>SpringBoot是由Pivotal团队提供的全新框架，其设计目的是用来 简化 Spring应用的 初始搭建 以及 开发过程 。<br>使用了Spring框架后已经简化了我们的开发，而SpringBoot又是对Spring开发进行简化的，可想而知SpringBoot使用的简单及广泛性。<br>既然SpringBoot是用来简化Spring开发的，那我们就先回顾一下，以SpringMVC开发为例</p><p>一共四步：加依赖、配置web、配置spring、编写controller</p><ol><li><p>创建一个maven工程，并在pom.xml中导入所需依赖的坐标</p><pre><code>&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;        &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;    &lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;    &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;    &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;    &lt;version&gt;3.5.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;    &lt;version&gt;1.3.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;5.1.46&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;druid&lt;/artifactId&gt;    &lt;version&gt;1.1.16&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;junit&lt;/groupId&gt;    &lt;artifactId&gt;junit&lt;/artifactId&gt;    &lt;version&gt;4.12&lt;/version&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;    &lt;version&gt;3.1.0&lt;/version&gt;    &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;    &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;/dependencies&gt;</code></pre></li><li><p>编写web3.0的配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer &#123;</span><br><span class="line">    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        return new Class[]&#123;SpringConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        return new Class[]&#123;SpringMvcConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected String[] getServletMappings() &#123;</span><br><span class="line">        return new String[]&#123;&quot;/&quot;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Filter[] getServletFilters() &#123;</span><br><span class="line">        CharacterEncodingFilter filter = new CharacterEncodingFilter();</span><br><span class="line">        filter.setEncoding(&quot;utf-8&quot;);</span><br><span class="line">        return new Filter[]&#123;filter&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写SpringMvc配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.blog.controller&quot;)</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class SpringMvcConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写Controller类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/books&quot;)</span><br><span class="line">public class BookController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private BookService bookService;</span><br><span class="line"></span><br><span class="line">    @PostMapping</span><br><span class="line">    public boolean save(@RequestBody Book book) &#123;</span><br><span class="line">        return bookService.save(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PutMapping</span><br><span class="line">    public boolean update(@RequestBody Book book) &#123;</span><br><span class="line">        return bookService.update(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public boolean delete(@PathVariable Integer id) &#123;</span><br><span class="line">        return bookService.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public Book getById(@PathVariable Integer id) &#123;</span><br><span class="line">        return bookService.getById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping</span><br><span class="line">    public List&lt;Book&gt; getAll() &#123;</span><br><span class="line">        return bookService.getAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>从上面的 SpringMVC 程序开发可以看到，前三步都是在搭建环境，而且这三步基本都是固定的。SpringBoot 就是对这三步进行简化了。接下来我们通过一个入门案例来体现 SpingBoot 简化 Spring 开发。</p><h2 id="SpringBoot快速入门"><a href="#SpringBoot快速入门" class="headerlink" title="SpringBoot快速入门"></a>SpringBoot快速入门</h2><h3 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h3><p>SpringBoot 开发起来特别简单，分为如下几步：</p><ul><li>创建新模块，选择Spring初始化，并配置模块相关基础信息</li><li>选择当前模块需要使用的技术集</li><li>开发控制器类</li><li>运行自动生成的Application类<br>知道了 SpringBoot 的开发步骤后，下面我们进行具体的操作</li></ul><p>实现：</p><ul><li>步骤一： 创建新模块<br>  在IDEA下创建一个新模块，选择Spring Initializr，用来创建SpringBoot工程</li></ul><p>  选中 Web，然后勾选 Spring Web，由于我们需要开发一个  web  程序，使用到了  SpringMVC  技术，所以按照下图红框进行勾选</p><p>  最后点击创建，就大功告成了，经过以上步骤后就创建了如下结构的模块，它会帮我们自动生成一个 Application 类，而该类一会再启动服务器时会用到</p><p>  注意：</p><ol><li><strong>编写项目的时候不要配置Artifact，这里只需要group的名字</strong></li><li>在创建好的工程中不需要创建配置类</li><li>创建好的项目会自动生成其他的一些文件，而这些文件目前对我们来说没有任何作用，所以可以将这些文件删除。</li><li>可以删除的目录和文件如下：<ul><li>.mvn </li><li>.gitignore </li><li>HELP.md </li><li>mvnw </li><li>mvnw.cmd</li></ul></li></ol><ul><li>步骤二： 创建Controller（除了controller，其余配置都被简化了）<br>  在 com.blog.controller 包下创建BookController，代码如下</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/books&quot;)</span><br><span class="line">public class BookController &#123;</span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public String getById(@PathVariable Integer id) &#123;</span><br><span class="line">        System.out.println(&quot;get id ==&gt; &quot; + id);</span><br><span class="line">        return &quot;hello,spring boot!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>步骤三： 启动服务器<br>  运行  SpringBoot  工程不需要使用本地的  Tomcat  和 插件，只运行项目  com.blog  包下的  Application  类，我们就可以在控制台看出如下信息</li></ul><p>  springboot自带一个java类，这个类就是运行类</p><ul><li>步骤四： 进行测试<br>  依旧是使用PostMan来测试，发送GET请求访问 localhost:8080&#x2F;books&#x2F;9527<br>  可以看到响应回来的结果 hello,spring boot!<br>  同时控制台也输出了 get id &#x3D;&#x3D;&gt; 9527</li></ul><blockquote><p><strong>总结：springboot项目创建也是四步，但是只有controller需要自己实现，其余都自动实现了</strong></p></blockquote><p>通过上面的入门案例我们可以看到使用  SpringBoot  进行开发，使整个开发变得很简单，那它是如何做到的呢？</p><ul><li><p>要研究这个问题，我们需要看看  Application  类和  pom.xml  都书写了什么。先看看  Applicaion  类，该类内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类中的东西很简单，就在类上添加了一个  @SpringBootApplication  注解，而在主方法中就一行代码。我们在启动服务器时就是执行的该类中的主方法。</p></li><li><p>再看看  pom.xml  配置文件中的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;!--指定了一个父工程，父工程中的东西在该工程中可以继承过来使用--&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.7.3&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springboot_01_quickstart&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!--JDK 的版本--&gt;</span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--该依赖就是我们在创建 SpringBoot 工程勾选的那个 Spring Web 产生的--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--这个是单元测试的依赖，我们现在没有进行单元测试，所以这个依赖现在可以没有--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;!--这个插件是在打包时需要的，而这里暂时还没有用到--&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li></ul><p>我们代码之所以能简化，就是因为指定的父工程和  Spring Web  依赖实现的。具体的我们后面在聊。</p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>做完  SpringBoot  的入门案例后，接下来对比一下  Spring  程序和  SpringBoot  程序。</p><table><thead><tr><th align="center">类&#x2F;配置文件</th><th align="center">Spring</th><th align="center">SpringBoot</th></tr></thead><tbody><tr><td align="center">pom文件中的坐标</td><td align="center">手工添加</td><td align="center">勾选添加</td></tr><tr><td align="center">web3.e配置类</td><td align="center">手工制作</td><td align="center">无</td></tr><tr><td align="center">Spring&#x2F;SpringMVC配置类</td><td align="center">手工制作</td><td align="center">无</td></tr><tr><td align="center">控制器</td><td align="center">手工制作</td><td align="center">手工制作</td></tr></tbody></table><ul><li>坐标<br> Spring  程序中的坐标需要自己编写，而且坐标非常多<br> SpringBoot  程序中的坐标是我们在创建工程时进行勾选自动生成的</li><li>web3.0配置类<br> Spring  程序需要自己编写这个配置类。这个配置类我们之前编写过，肯定感觉很复杂<br> SpringBoot  程序不需要我们自己书写</li><li>配置类<br> Spring&#x2F;SpringMVC  程序的配置类需要自己书写。而  SpringBoot  程序则不需要书写。</li></ul><p>注意：基于Idea的  Spring Initializr  快速构建  SpringBoot  工程时需要联网。</p><h2 id="官网构建工程"><a href="#官网构建工程" class="headerlink" title="官网构建工程"></a>官网构建工程</h2><p>在入门案例中之所以能快速构建  SpringBoot  工程，是因为  Idea  使用了官网提供了快速构建  SpringBoot  工程的组件实现的。<br>首先进入SpringBoot官网 <a href="https://spring.io/projects/spring-boot">https://spring.io/projects/spring-boot</a> ，拉到页面最下方，会有一个 Quickstart your project<br>然后点击 Spring Initializr 超链接，就会跳转到如下页面，构建工程的步骤与我们在IDEA中几乎没什么区别</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310241216558.png"></p><p>点击 GENERATE ，就可以生成工程并下载到本地了，打开下载好的压缩包，可以看到工程的内容与IDEA生成的一模一样。<br>通过上面官网的操作，我们知道  Idea  中快速构建  SpringBoot  工程其实就是使用的官网的快速构建组件，那以后即使没有  Idea  也可以使用官网的方式构建  SpringBoot  工程。</p><h2 id="SpringBoot工程快速启动"><a href="#SpringBoot工程快速启动" class="headerlink" title="SpringBoot工程快速启动"></a>SpringBoot工程快速启动</h2><ul><li><p>问题引入<br>以后我们和前端开发人员协同开发，而前端开发人员需要测试前端程序就需要后端开启服务器，这就受制于后端开发人员。为了摆脱这个受制，前端开发人员尝试着在自己电脑上安装  Tomcat  和  Idea  ，在自己电脑上启动后端程序，这显然不现实。<br>我们后端可以将  SpringBoot  工程打成  jar  包，该  jar  包运行不依赖于  Tomcat  和  Idea  这些工具也可以正常运行，只是这个  jar  包在运行过程中连接和我们自己程序相同的  Mysql  数据库即可，这样就可以解决这个问题。</p></li><li><p>那现在问题就是如何打包<br>由于我们在构建  SpringBoot  工程时已经在  pom.xml  中配置了如下插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure></li></ul><p>所以我们只需要使用  Maven  的  package  指令打包就会在  target  目录下生成对应的  Jar  包。</p><blockquote><p>注意：该插件必须配置，不然打好的  jar  包也是有问题的。</p></blockquote><ul><li><p>快速启动<br>进入  jar  包所在位置，在  命令提示符  中输入如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar springboot_01_quickstart-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p>执行上述命令就可以看到  SpringBoot  运行的日志信息，同时使用PostMan发送GET请求访问 localhost:8080&#x2F;books&#x2F;9527 ，也可以正常输出get id &#x3D;&#x3D;&gt; 9527</p></li></ul><blockquote><p>pom中的那个插件就是用来实现快速启动的</p><p>快速打包需要用Maven的package指令进行打包</p><p>虽然能快速启动，但是数据库还是那个数据库，要连到固定数据库上</p></blockquote><h1 id="SpringBoot概述"><a href="#SpringBoot概述" class="headerlink" title="SpringBoot概述"></a>SpringBoot概述</h1><p> SpringBoot  是由Pivotal团队提供的全新框架，其设计目的是用来 简化 Spring应用的 初始搭建 以及 开发过程 。</p><p>原始  Spring  环境搭建和开发存在以下问题</p><ul><li>配置繁琐</li><li>依赖设置繁琐<br> SpringBoot  程序优点恰巧就是针对  Spring  的缺点</li><li>自动配置。这个是用来解决  Spring  程序配置繁琐的问题</li><li>起步依赖。这个是用来解决  Spring  程序依赖设置繁琐的问题</li><li>辅助功能（内置服务器，…）。我们在启动  SpringBoot  程序时既没有使用本地的  tomcat  也没有使用  tomcat  插件，而是使用  SpringBoot  内置的服务器。</li></ul><p>接下来我们来说一下  SpringBoot  的起步依赖</p><h2 id="起步依赖"><a href="#起步依赖" class="headerlink" title="起步依赖"></a>起步依赖</h2><p>我们使用  Spring Initializr  方式创建的  Maven  工程的的  pom.xml  配置文件中自动生成了很多包含  starter  的依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;!--                      ↓↓↓              --&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.7.3&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt; </span><br><span class="line">&lt;/parent&gt;</span><br><span class="line">&lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;springboot_01_quickstart&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;!--                      ↓↓↓              --&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;!--                      ↓↓↓              --&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h3 id="父工程"><a href="#父工程" class="headerlink" title="父工程"></a>父工程</h3><p>从上面的文件中可以看到指定了一个父工程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.7.3&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure><p>进入到父工程，发现父工程中又指定了一个父工程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.7.3&lt;/version&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure><p>进入到<strong>爷工程</strong>中，在该工程中我们可以看到配置内容结构如下</p><div class="tabs" id="1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#1-1">properties</button></li><li class="tab"><button type="button" data-href="#1-2">dependencyManagement</button></li><li class="tab"><button type="button" data-href="#1-3">plugin</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><p> properties  标签中定义了各个技术软件依赖的版本，避免了我们在使用不同软件技术时考虑版本的兼容问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;activemq.version&gt;5.16.5&lt;/activemq.version&gt;</span><br><span class="line">&lt;antlr2.version&gt;2.7.7&lt;/antlr2.version&gt;</span><br><span class="line">&lt;appengine-sdk.version&gt;1.9.98&lt;/appengine-sdk.version&gt;</span><br><span class="line">&lt;artemis.version&gt;2.19.1&lt;/artemis.version&gt;</span><br><span class="line">&lt;aspectj.version&gt;1.9.7&lt;/aspectj.version&gt;</span><br><span class="line">&lt;assertj.version&gt;3.22.0&lt;/assertj.version&gt;</span><br><span class="line">&lt;atomikos.version&gt;4.0.6&lt;/atomikos.version&gt;</span><br><span class="line">&lt;awaitility.version&gt;4.2.0&lt;/awaitility.version&gt;</span><br><span class="line">&lt;build-helper-maven-plugin.version&gt;3.3.0&lt;/build-helper-maven-plugin.version&gt;</span><br><span class="line">&lt;byte-buddy.version&gt;1.12.13&lt;/byte-buddy.version&gt;</span><br><span class="line"></span><br><span class="line">···</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-2"><p> dependencyManagement  标签是进行依赖版本锁定，但是并没有导入对应的依赖；如果我们工程需要那个依赖只需要引入依赖的  groupid  和  artifactId  不需要定义  version 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;activemq-amqp&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;activemq.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;activemq-blueprint&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;activemq.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;activemq-broker&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;activemq.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">···</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-3"><p>而  build  标签中也对插件的版本进行了锁定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;build-helper-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;build-helper-maven-plugin.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.flywaydb&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;flyway-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;flyway.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;pl.project13.maven&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;git-commit-id-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;git-commit-id-plugin.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line"></span><br><span class="line">···</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>父工程中指明版本</p><h3 id="starter起步依赖"><a href="#starter起步依赖" class="headerlink" title="starter起步依赖"></a>starter起步依赖</h3><p>工程中的pom.xml中配置了如下依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>进入到该依赖，查看pom.xml的依赖，会发现它引入了如下依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.7.3&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.3.22&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.3.22&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>里面的引入了  spring-web  和  spring-webmvc  的依赖，这就是为什么我们的工程中没有依赖这两个包还能正常使用  springMVC  中的注解的原因。<br>而依赖  spring-boot-starter-tomcat  ，从名字基本能确认内部依赖了  tomcat ，所以我们的工程才能正常启动。<br>结论：以后需要使用技术，只需要引入该技术对应的起步依赖即可</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>starter：</p><ul><li>SpringBoot  中常见项目名称，定义了当前项目使用的所有项目坐标，以达到减少依赖配置的目的</li></ul><p>parent：</p><ul><li>所有  SpringBoot  项目要继承的项目，定义了若干个坐标版本号（依赖管理，而非依赖），以达到减少依赖冲突的目的</li></ul><p>实际开发：</p><ul><li>使用任意坐标时，仅书写GAV中的G和A，V由SpringBoot提供<ul><li>G：groupid</li><li>A：artifactId</li><li>V：version</li></ul></li><li>如发生坐标错误，再指定version（要小心版本冲突）</li></ul><h2 id="程序启动"><a href="#程序启动" class="headerlink" title="程序启动"></a>程序启动</h2><p>创建的每一个  SpringBoot  程序时都包含一个类似于下面的类，我们将这个类称作引导类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class Springboot01QuickstartApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Springboot01QuickstartApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>SpringBoot  在创建项目时，采用jar的打包方式</li><li>SpringBoot  的引导类是项目的入口，运行  main  方法就可以启动项目<br>  因为我们在  pom.xml  中配置了  spring-boot-starter-web  依赖，而该依赖通过前面的学习知道它依赖  tomcat  ，所以运行  main  方法就可以使用  tomcat  启动咱们的工程。</li></ul><h2 id="切换web服务器"><a href="#切换web服务器" class="headerlink" title="切换web服务器"></a>切换web服务器</h2><p>现在我们启动工程使用的是  tomcat  服务器，那能不能不使用  tomcat  而使用  jetty  服务器。而要切换  web  服务器就需要将默认的  tomcat  服务器给排除掉，怎么排除呢？需要用到我们前面学的知识 排除依赖 ，使用  exclusion  标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>然后还要引入  jetty  服务器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;xxxxxxxxxx &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;&lt;/dependency&gt;XML</span><br></pre></td></tr></table></figure><p>接下来再次运行引导类，在日志信息中就可以看到使用的是jetty服务器</p><blockquote><p>通过切换服务器，我们不难发现在使用  SpringBoot  换技术时只需要导入该技术的 起步依赖 即可。</p></blockquote><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><h2 id="配置文件格式"><a href="#配置文件格式" class="headerlink" title="配置文件格式"></a>配置文件格式</h2><p> SpringBoot  提供了 3 种属性配置方式</p><p>注意： SpringBoot  程序的配置文件名必须是  application  ，只是后缀名不同而已。</p><div class="tabs" id="2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2-1">application.properties</button></li><li class="tab"><button type="button" data-href="#2-2">application.yml</button></li><li class="tab"><button type="button" data-href="#2-3">application.yaml</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2-1"><p>配置文件必须放在  resources  目录下，而该目录下有一个名为  application.properties  的配置文件（SpringBoot已经为我们提供好了），我们就可以在该配置文件中修改端口号，在该配置文件中书写  port  ， Idea  就会补全提示</p><p>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=80</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2-2"><p>在  resources  下（同级）创建一个名为  application.yml  的配置文件，在该文件中书写端口号的配置项，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 81</span><br></pre></td></tr></table></figure><p>注意： 在 : 后，数据前一定要加空格。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2-3"><p>然后在  resources  下创建名为  application.yaml  的配置文件，配置内容和后缀名为  yml  的配置文件中的内容相同，只是使用了不同的后缀名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 82</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>三种配合文件的优先级：</p><p>properties &gt; yml &gt; yaml</p><h2 id="yaml格式"><a href="#yaml格式" class="headerlink" title="yaml格式"></a>yaml格式</h2><p>YAML（YAML Ain’t Markup Language），一种数据序列化格式。这种格式的配置文件在近些年已经占有主导地位，那么这种配置文件和前期使用的配置文件是有一些优势的，我们先看之前使用的配置文件。</p><p>最开始我们使用的是  xml  ，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;enterprise&gt;</span><br><span class="line">    &lt;name&gt;Helsing&lt;/name&gt;</span><br><span class="line">    &lt;age&gt;16&lt;/age&gt;</span><br><span class="line">    &lt;tel&gt;400-957-241&lt;/tel&gt;</span><br><span class="line">&lt;/enterprise&gt;</span><br></pre></td></tr></table></figure><p>而  properties  类型的配置文件如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enterprise.name=Helsing</span><br><span class="line">enterprise.age=16</span><br><span class="line">enterprise.tel=400-957-241</span><br></pre></td></tr></table></figure><p>yaml 类型的配置文件内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enterprise:</span><br><span class="line">  name: Helsing</span><br><span class="line">  age: 16</span><br><span class="line">  tel: 400-957-241</span><br></pre></td></tr></table></figure><p>通过对比，我们得出yaml的优点有：</p><ul><li>容易阅读<ul><li>yaml  类型的配置文件比  xml  类型的配置文件更容易阅读，结构更加清晰</li></ul></li><li>容易与脚本语言交互（暂时还体会不到，后面会了解）</li><li>以数据为核心，重数据轻格式<ul><li>yaml  更注重数据，而  xml  更注重格式</li></ul></li></ul><p>YAML 文件扩展名：</p><ul><li>.yml  (主流)</li><li>.yaml</li></ul><p>上面两种后缀名都可以，以后使用更多的还是  yml  的。</p><h2 id="yml语法规则"><a href="#yml语法规则" class="headerlink" title="yml语法规则"></a>yml语法规则</h2><ul><li><p>大小写敏感</p></li><li><p>属性层级关系使用多行描述，每行结尾使用冒号结束</p></li><li><p>使用缩进表示层级关系，同层级左侧对齐，只允许使用空格（不允许使用Tab键）</p><ul><li>空格的个数并不重要，只要保证同层级的左侧对齐即可。</li></ul></li><li><p><strong>属性值前面添加空格</strong>（属性名与属性值之间使用冒号+空格作为分隔）</p></li><li><p>数组数据在数据书写位置的下方使用减号作为数据开始符号，每行书写一个数据，减号与数据间空格分隔</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enterprise:</span><br><span class="line">  name: Helsing</span><br><span class="line">  age: 16</span><br><span class="line">  tel: 400-957-241</span><br><span class="line">  subject:</span><br><span class="line">    - Java</span><br><span class="line">    - Python</span><br><span class="line">    - C#</span><br></pre></td></tr></table></figure></li></ul><h2 id="yaml配置文件数据读取"><a href="#yaml配置文件数据读取" class="headerlink" title="yaml配置文件数据读取"></a>yaml配置文件数据读取</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ul><li><p>修改 resource 目录下的 application.yml 配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">lesson: SpringBoot</span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line">  port: 80</span><br><span class="line"></span><br><span class="line">enterprise:</span><br><span class="line">  name: Helsing</span><br><span class="line">  age: 16</span><br><span class="line">  tel: 400-957-241</span><br><span class="line">  subject:</span><br><span class="line">    - Java</span><br><span class="line">    - Python</span><br><span class="line">    - C#</span><br></pre></td></tr></table></figure></li><li><p>在 com.blog.domain 包下新建一个Enterprise类，用来封装数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package com.blog.domain;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class Enterprise &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private String tel;</span><br><span class="line">    private String[] subject;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getTel() &#123;</span><br><span class="line">        return tel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTel(String tel) &#123;</span><br><span class="line">        this.tel = tel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String[] getSubject() &#123;</span><br><span class="line">        return subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSubject(String[] subject) &#123;</span><br><span class="line">        this.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Enterprise&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &quot;, tel=&#x27;&quot; + tel + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, subject=&quot; + Arrays.toString(subject) +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="读取配置文件"><a href="#读取配置文件" class="headerlink" title="读取配置文件"></a>读取配置文件</h3><div class="tabs" id="3"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#3-1"><i class="Value注解"></i>使用</button></li><li class="tab"><button type="button" data-href="#3-2">使用 Environment 对象</button></li><li class="tab"><button type="button" data-href="#3-3">使用自定义对象</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="3-1"><p>使用  @Value(“表达式”)  注解可以从配合文件中读取数据，注解中用于读取属性名引用方式是： ${一级属性名.二级属性名……} </p><p>我们可以在  BookController  中使用  @Value  注解读取配合文件数据，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/books&quot;)</span><br><span class="line">public class BookController &#123;</span><br><span class="line">    @Value(&quot;$&#123;lesson&#125;&quot;)</span><br><span class="line">    private String lesson;</span><br><span class="line">    @Value(&quot;$&#123;server.port&#125;&quot;)</span><br><span class="line">    private Integer port;</span><br><span class="line">    @Value(&quot;$&#123;enterprise.subject[0]&#125;&quot;)</span><br><span class="line">    private String subject_0;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public String getById(@PathVariable Integer id) &#123;</span><br><span class="line">        System.out.println(lesson);</span><br><span class="line">        System.out.println(port);</span><br><span class="line">        System.out.println(subject_0);</span><br><span class="line">        return &quot;hello , spring boot!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3-2"><p>上面方式读取到的数据特别零散， SpringBoot  还可以使用  @Autowired  注解注入  Environment  对象的方式读取数据。这种方式  SpringBoot  会将配置文件中所有的数据封装到  Environment  对象中，如果需要使用哪个数据只需要通过调用  Environment  对象的  getProperty(String name)  方法获取。具体代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/books&quot;)</span><br><span class="line">public class BookController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private Environment environment;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public String getById(@PathVariable Integer id) &#123;</span><br><span class="line">        System.out.println(environment.getProperty(&quot;lesson&quot;));</span><br><span class="line">        System.out.println(environment.getProperty(&quot;enterprise.name&quot;));</span><br><span class="line">        System.out.println(environment.getProperty(&quot;enterprise.subject[1]&quot;));</span><br><span class="line">        return &quot;hello , spring boot!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：这种方式在开发中很少用，因为框架内含大量数据</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3-3"><p>SpringBoot还提供了将配置文件中的数据封装到我们自定义的实体类对象中的方式。具体操作如下：</p><ul><li><p>将实体类bean的创建交给Spring管理。</p><ul><li>在类上添加  @Component  注解</li></ul></li><li><p>使用@ConfigurationProperties</p><p> 注解表示加载配置文件</p><ul><li>在该注解中也可以使用  prefix  属性指定只加载指定前缀的数据</li></ul></li><li><p>在  BookController  中进行注入</p></li></ul><p>Enterprise 实体类内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(prefix = &quot;enterprise&quot;)</span><br><span class="line">public class Enterprise &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private String tel;</span><br><span class="line">    private String[] subject;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getTel() &#123;</span><br><span class="line">        return tel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTel(String tel) &#123;</span><br><span class="line">        this.tel = tel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String[] getSubject() &#123;</span><br><span class="line">        return subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSubject(String[] subject) &#123;</span><br><span class="line">        this.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Enterprise&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &quot;, tel=&#x27;&quot; + tel + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, subject=&quot; + Arrays.toString(subject) +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BooKController内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/books&quot;)</span><br><span class="line">public class BookController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private Enterprise enterprise;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public String getById(@PathVariable Integer id) &#123;</span><br><span class="line">        System.out.println(enterprise);</span><br><span class="line">        System.out.println(enterprise.getAge());</span><br><span class="line">        System.out.println(enterprise.getName());</span><br><span class="line">        System.out.println(enterprise.getTel());</span><br><span class="line">        return &quot;hello , spring boot!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h1><p>后在工作中，对于开发环境、测试环境、生产环境的配置肯定都不相同，比如我们开发阶段会在自己的电脑上安装  mysql  ，连接自己电脑上的  mysql  即可，但是项目开发完毕后要上线就需要该配置，将环境的配置改为线上环境的。<br>来回的修改配置会很麻烦，而  SpringBoot  给开发者提供了多环境的快捷配置，需要切换环境时只需要改一个配置即可。不同类型的配置文件多环境开发的配置都不相同，接下来对不同类型的配置文件进行说明</p><h2 id="yaml文件"><a href="#yaml文件" class="headerlink" title="yaml文件"></a>yaml文件</h2><p>在  application.yml  中使用  —  来分割不同的配置，内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">## 开发环境</span><br><span class="line">spring:</span><br><span class="line">  profiles: dev ## 给开发环境取的名</span><br><span class="line">server:</span><br><span class="line">  port: 80</span><br><span class="line">---</span><br><span class="line">## 生产环境</span><br><span class="line">spring:</span><br><span class="line">  profiles: pro ## 给生产环境取的名</span><br><span class="line">server:</span><br><span class="line">  port: 81</span><br><span class="line">---</span><br><span class="line">## 测试环境</span><br><span class="line">spring:</span><br><span class="line">  profiles: test ## 给测试环境起的名</span><br><span class="line">server:</span><br><span class="line">  port: 82</span><br></pre></td></tr></table></figure><p>上面配置中  spring.profiles  是用来给不同的配置起名字的。而如何告知  SpringBoot  使用哪段配置呢？可以使用如下配置来启用都一段配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## 设置启用的环境</span><br><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev  ## 表示使用的是开发环境的配置</span><br></pre></td></tr></table></figure><p>整合：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br><span class="line">---</span><br><span class="line">## 开发环境</span><br><span class="line">spring:</span><br><span class="line">  profiles: dev ## 给开发环境取的名</span><br><span class="line">server:</span><br><span class="line">  port: 80</span><br><span class="line">---</span><br><span class="line">## 生产环境</span><br><span class="line">spring:</span><br><span class="line">  profiles: pro ## 给生产环境取的名</span><br><span class="line">server:</span><br><span class="line">  port: 81</span><br><span class="line">---</span><br><span class="line">## 测试环境</span><br><span class="line">spring:</span><br><span class="line">  profiles: test ## 给测试环境起的名</span><br><span class="line">server:</span><br><span class="line">  port: 82</span><br></pre></td></tr></table></figure><p>注意：在上面配置中给不同配置起名字的  spring.profiles  配置项已经过时，但是能用。最新用来起名字的配置项是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## 开发环境</span><br><span class="line">spring:</span><br><span class="line">  config:</span><br><span class="line">    activate:</span><br><span class="line">      on-profile: dev ## 给开发环境取的名</span><br></pre></td></tr></table></figure><h2 id="命令行启动参数设置"><a href="#命令行启动参数设置" class="headerlink" title="命令行启动参数设置"></a>命令行启动参数设置</h2><p>使用  SpringBoot  开发的程序以后都是打成  jar  包，通过  java -jar xxx.jar  的方式启动服务的。那么就存在一个问题，如何切换环境呢？因为配置文件打到的jar包中了。</p><p> SpringBoot  提供了在运行  jar  时设置开启指定的环境的方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">测试</span><br><span class="line">java -jar xxx.jar --spring.profiles.active=test</span><br><span class="line"></span><br><span class="line">临时修改端口号</span><br><span class="line">java -jar xxx.jar --server.port=9421</span><br><span class="line"></span><br><span class="line">指定启用哪个环境配置，又临时指定端口</span><br><span class="line">java -jar xxx.jar -server.port=9421 --spring.profiles.active=pro</span><br></pre></td></tr></table></figure><p>配置的优先级官网已经进行了说明。</p><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config">https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config</a></p><h1 id="配置文件分类"><a href="#配置文件分类" class="headerlink" title="配置文件分类"></a>配置文件分类</h1><p>有这样的场景，我们开发完毕后需要测试人员进行测试，由于测试环境和开发环境的很多配置都不相同，所以测试人员在运行我们的工程时需要临时修改很多配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java –jar springboot.jar –-spring.profiles.active=test --server.port=85 --server.servlet.context-path=/heima --server.tomcat.connection-timeout=-1 …… …… …… …… ……</span><br></pre></td></tr></table></figure><p>针对这种情况， SpringBoot  定义了配置文件不同的放置的位置；而放在不同位置的优先级时不同的。</p><p>SpringBoot中4级配置文件放置位置：</p><ul><li>1级：classpath：application.yml</li><li>2级：classpath：config&#x2F;application.yml</li></ul><p>分界线，以同级为界，上面两个在 jar 包里面，下面两个在 jar 包外</p><ul><li>3级：file ：application.yml</li><li>4级：file ：config&#x2F;application.yml</li></ul><p>说明：级别越高的优先级越高</p><h1 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h1><h2 id="整合Junit"><a href="#整合Junit" class="headerlink" title="整合Junit"></a>整合Junit</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310242218493.png"></p><p>使用  @RunWith  注解指定运行器，使用  @ContextConfiguration  注解来指定配置类或者配置文件。</p><p>而  SpringBoot  整合  junit  特别简单，分为以下三步完成</p><ul><li>在测试类上添加  SpringBootTest  注解</li><li>使用  @Autowired  注入要测试的资源</li><li>定义测试方法进行测试</li></ul><h3 id="SpringBoot整合"><a href="#SpringBoot整合" class="headerlink" title="SpringBoot整合"></a>SpringBoot整合</h3><h4 id="环境准备-1"><a href="#环境准备-1" class="headerlink" title="环境准备"></a>环境准备</h4><ul><li><p>创建一个新的SpringBoot工程</p></li><li><p>在com.blog.service包下创建BookService接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface BookService &#123;</span><br><span class="line">    void save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在com.blog.service.impl包下创建BookService接口的实现类，并重写其方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class BookServiceImpl implements BookService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book service is running ..&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="编写测试类"><a href="#编写测试类" class="headerlink" title="编写测试类"></a>编写测试类</h4><p>在  test&#x2F;java  下创建  com.blog  包，在该包下创建测试类，将  BookService  注入到该测试类中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">class Springboot02JunitApplicationTests &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private BookService bookService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void contextLoads() &#123;</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试方法，控制台成功输出</p><p>注意：这里的引导类所在包必须是测试类所在包及其子包。</p><p>例如：</p><ul><li>引导类所在包是  com.blog </li><li>测试类所在包是  com.blog</li></ul><p>如果不满足这个要求的话，就需要在使用  @SpringBootTest  注解时，使用  classes  属性指定引导类的字节码对象。如  @SpringBootTest(classes &#x3D; XxxApplication.class) </p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310242222895.png"></p><h2 id="整合MyBatis"><a href="#整合MyBatis" class="headerlink" title="整合MyBatis"></a>整合MyBatis</h2><h3 id="回顾Spring整合MyBatis"><a href="#回顾Spring整合MyBatis" class="headerlink" title="回顾Spring整合MyBatis"></a>回顾Spring整合MyBatis</h3><p>之前Spring整合MyBatis时，需要定义很多配置类</p><ul><li>SpringConfig配置类</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.blog&quot;)</span><br><span class="line">@PropertySource(&quot;jdbc.properties&quot;)</span><br><span class="line">@Import(&#123;JdbcConfig.class, MyBatisConfig.class&#125;)</span><br><span class="line">public class SpringConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>导入JdbcConfig配置类</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class JdbcConfig &#123;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span><br><span class="line">    private String driver;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.url&#125;&quot;)</span><br><span class="line">    private String url;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.username&#125;&quot;)</span><br><span class="line">    private String username;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.password&#125;&quot;)</span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource() &#123;</span><br><span class="line">        DruidDataSource dataSource = new DruidDataSource();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        return dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>导入MyBatisConfig配置类<ul><li>定义  SqlSessionFactoryBean </li><li>定义映射配置</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class MyBatisConfig &#123;</span><br><span class="line"></span><br><span class="line">    //定义bean，SqlSessionFactoryBean，用于产生SqlSessionFactory对象</span><br><span class="line">    @Bean</span><br><span class="line">    public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource) &#123;</span><br><span class="line">        SqlSessionFactoryBean sqlSessionFactory = new SqlSessionFactoryBean();</span><br><span class="line">        //设置模型类的别名扫描</span><br><span class="line">        sqlSessionFactory.setTypeAliasesPackage(&quot;com.blog.domain&quot;);</span><br><span class="line">        //设置数据源</span><br><span class="line">        sqlSessionFactory.setDataSource(dataSource);</span><br><span class="line">        return sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    //定义bean，返回MapperScannerConfigurer对象</span><br><span class="line">    @Bean</span><br><span class="line">    public MapperScannerConfigurer mapperScannerConfigurer() &#123;</span><br><span class="line">        MapperScannerConfigurer msc = new MapperScannerConfigurer();</span><br><span class="line">        msc.setBasePackage(&quot;com.blog.dao&quot;);</span><br><span class="line">        return msc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringBoot整合MyBatis"><a href="#SpringBoot整合MyBatis" class="headerlink" title="SpringBoot整合MyBatis"></a>SpringBoot整合MyBatis</h3><ul><li><p>创建一个新的模块<br>注意选择技术集的时候，要勾选 MyBatis Framework 和 MySQL Driver </p></li><li><p>建库建表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE springboot_db;</span><br><span class="line">USE springboot_db;</span><br><span class="line"></span><br><span class="line">CREATE TABLE tbl_book</span><br><span class="line">(</span><br><span class="line">    id          INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">    `type`      VARCHAR(20),</span><br><span class="line">    `name`      VARCHAR(50),</span><br><span class="line">    description VARCHAR(255)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO `tbl_book`(`id`, `type`, `name`, `description`)</span><br><span class="line">VALUES (1, &#x27;计算机理论&#x27;, &#x27;Spring实战 第五版&#x27;, &#x27;Spring入门经典教程，深入理解Spring原理技术内幕&#x27;),</span><br><span class="line">       (2, &#x27;计算机理论&#x27;, &#x27;Spring 5核心原理与30个类手写实践&#x27;, &#x27;十年沉淀之作，手写Spring精华思想&#x27;),</span><br><span class="line">       (3, &#x27;计算机理论&#x27;, &#x27;Spring 5设计模式&#x27;, &#x27;深入Spring源码刨析Spring源码中蕴含的10大设计模式&#x27;),</span><br><span class="line">       (4, &#x27;计算机理论&#x27;, &#x27;Spring MVC+Mybatis开发从入门到项目实战&#x27;,</span><br><span class="line">        &#x27;全方位解析面向Web应用的轻量级框架，带你成为Spring MVC开发高手&#x27;),</span><br><span class="line">       (5, &#x27;计算机理论&#x27;, &#x27;轻量级Java Web企业应用实战&#x27;, &#x27;源码级刨析Spring框架，适合已掌握Java基础的读者&#x27;),</span><br><span class="line">       (6, &#x27;计算机理论&#x27;, &#x27;Java核心技术 卷Ⅰ 基础知识(原书第11版)&#x27;,</span><br><span class="line">        &#x27;Core Java第11版，Jolt大奖获奖作品，针对Java SE9、10、11全面更新&#x27;),</span><br><span class="line">       (7, &#x27;计算机理论&#x27;, &#x27;深入理解Java虚拟机&#x27;, &#x27;5个纬度全面刨析JVM,大厂面试知识点全覆盖&#x27;),</span><br><span class="line">       (8, &#x27;计算机理论&#x27;, &#x27;Java编程思想(第4版)&#x27;, &#x27;Java学习必读经典，殿堂级著作！赢得了全球程序员的广泛赞誉&#x27;),</span><br><span class="line">       (9, &#x27;计算机理论&#x27;, &#x27;零基础学Java(全彩版)&#x27;, &#x27;零基础自学编程的入门图书，由浅入深，详解Java语言的编程思想和核心技术&#x27;),</span><br><span class="line">       (10, &#x27;市场营销&#x27;, &#x27;直播就这么做:主播高效沟通实战指南&#x27;, &#x27;李子柒、李佳奇、薇娅成长为网红的秘密都在书中&#x27;),</span><br><span class="line">       (11, &#x27;市场营销&#x27;, &#x27;直播销讲实战一本通&#x27;, &#x27;和秋叶一起学系列网络营销书籍&#x27;),</span><br><span class="line">       (12, &#x27;市场营销&#x27;, &#x27;直播带货:淘宝、天猫直播从新手到高手&#x27;, &#x27;一本教你如何玩转直播的书，10堂课轻松实现带货月入3W+&#x27;);</span><br></pre></td></tr></table></figure></li><li><p>定义实体类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class Book &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String type;</span><br><span class="line">    private String name;</span><br><span class="line">    private String description;</span><br><span class="line"></span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getType() &#123;</span><br><span class="line">        return type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setType(String type) &#123;</span><br><span class="line">        this.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDescription() &#123;</span><br><span class="line">        return description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDescription(String description) &#123;</span><br><span class="line">        this.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Book&#123;&quot; +</span><br><span class="line">                &quot;id=&quot; + id +</span><br><span class="line">                &quot;, type=&#x27;&quot; + type + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, description=&#x27;&quot; + description + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义dao接口<br>在com.blog.dao包下定义BookDao接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface BookDao &#123;</span><br><span class="line">    @Select(&quot;select * from tbl_book where id = #&#123;id&#125;&quot;)</span><br><span class="line">    Book getById(Integer id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义测试类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">class Springboot03MybatisApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void contextLoads() &#123;</span><br><span class="line">        Book book = bookDao.getById(1);</span><br><span class="line">        System.out.println(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://localhost:3306/springboot_db?serverTimezone=UTC</span><br><span class="line">    username: root</span><br><span class="line">    password: PASSWORD</span><br></pre></td></tr></table></figure></li><li><p>测试<br>运行测试方法，会报错 No qualifying bean of type ‘com.blog.dao.BookDao’ ，没有类型为“com.blog.dao.BookDao”的限定bean<br>为什么会出现这种情况呢？之前我们在配置MyBatis时，配置了如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public MapperScannerConfigurer mapperScannerConfigurer() &#123;</span><br><span class="line">    MapperScannerConfigurer msc = new MapperScannerConfigurer();</span><br><span class="line">    msc.setBasePackage(&quot;com.blog.dao&quot;);</span><br><span class="line">    return msc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> Mybatis  会扫描接口并创建接口的代码对象交给  Spring  管理，但是现在并没有告诉  Mybatis  哪个是  dao  接口。<br>而我们要解决这个问题需要在 BookDao  接口上使用  @Mapper  ， BookDao  接口修改为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface BookDao &#123;</span><br><span class="line">    @Select(&quot;select * from tbl_book where id = #&#123;id&#125;&quot;)</span><br><span class="line">    Book getById(Integer id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>注意：<br> SpringBoot  版本低于2.4.3(不含)，Mysql驱动版本大于8.0时，需要在url连接串中配置时区  jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;springboot_db?serverTimezone&#x3D;UTC ，或在MySQL数据库端配置时区解决此问题</p><h3 id="更改数据源"><a href="#更改数据源" class="headerlink" title="更改数据源"></a>更改数据源</h3><p>现在我们并没有指定数据源， SpringBoot  有默认的数据源，我们也可以指定使用  Druid  数据源，按照以下步骤实现</p><ul><li><p>导依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.12&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>修改配置文件配置</p><p>在  application.yml  可以通过  spring.datasource.type  来配置使用什么数据源。配置文件内容可以改进为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://localhost:3306/springboot_db?serverTimezone=UTC</span><br><span class="line">    username: root</span><br><span class="line">    password: PASSWORD.</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br></pre></td></tr></table></figure></li></ul><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310250916598.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310250916084.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310250917844.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310250917764.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310250917615.png"></p><h1 id="SSM整合案例"><a href="#SSM整合案例" class="headerlink" title="SSM整合案例"></a>SSM整合案例</h1><h3 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h3><p>创建一个新的SpringBoot工程，注意要勾选 Spring Web ， MyBatis Framework 和 MySQL Driver<br>由于我们工程中使用到了  Druid  ，所以需要导入  Druid  的坐标。druid在parent中没有，这个要加版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.12&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="代码拷贝"><a href="#代码拷贝" class="headerlink" title="代码拷贝"></a>代码拷贝</h3><p>将之前的ssm整合工程的代码拷贝过来，将 com.blog 包下的所有内容拷贝过来，放在对应的位置即可。项目结构如下</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310250932818.png"></p><ul><li>config：原有的配置文件，全被springboot整合简化</li><li>controller：相应web请求</li><li>dao：执行相应的SQL语句，需要添加 @mapper 注册</li><li>domain：定义实体类</li><li>exception：异常处理</li><li>service：添加功能接口和相关实现类</li></ul><p>需要修改的内容如下：</p><ul><li>config：直接删掉，SpringBoot并不需要这些配置类</li><li>dao：添加 @mapper 注册</li><li>将测试类也修改为SpringBoot的</li></ul><h3 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h3><p>把application. properties 改成 application.yml文件，把里面的配置改为 yml 格式</p><ul><li><p>服务的端口号（设为80，这样我们就不用写了）</p></li><li><p>连接数据库的信息（数据库连接四要素）</p></li><li><p>数据源（德鲁伊）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 80</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://localhost:3306/springboot_db?serverTimezone=UTC</span><br><span class="line">    username: root</span><br><span class="line">    password: PASSWORD.</span><br></pre></td></tr></table></figure></li></ul><h3 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h3><p>在  SpringBoot  程序中是没有  webapp  目录的，那么在  SpringBoot  程序中静态资源需要放在什么位置呢？<br>静态资源需要放在  resources  下的  static  下<br>那我们再配置一个默认页面，跳转到我们的增删改页面，新建 index.html ，写入以下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    document.location.href=&quot;/pages/books.html&quot;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这样当我们在浏览器输入localhost，然后直接按回车，就能直接跳转到增删改的页面了，如果以后我们需要频繁测试某一个页面，也可以将上述代码中的地址换为我们要测试的地址，这样就不用老手敲地址了</p><h1 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h1><h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><ol><li><p>创建工程</p><p>创建一个SpringBoot工程</p><p>需要勾选 Spring Web ， MyBatis Framework 和 MySQL Driver </p></li><li><p>SpringBoot整合</p><p>整合MyBatis</p><ul><li>添加Druid数据源依赖</li><li>编写数据库配置文件（application.yml），配置数据库连接四要素</li><li>对于Dao层的包扫描，使用 @Mapper 注解</li></ul><p>整合Junit</p><ul><li>使用 @SpringBootTest 注解</li></ul></li><li><p>功能模块</p><p>创建数据库和表</p><p>根据数据表来创建对应的模型类</p><p>通过 Dao 层完成数据库的增删改</p><p>编写 Service 层（Service接口+实现类）</p><p>编写Controller层</p><ul><li>接收请求  @RequestMapping 、 @GetMapping 、 @PostMapping 、 @PutMapping 、 @DeleteMapping </li><li>接收数据 简单类型、POJO类型、嵌套POJO类型、数组类型、JSON数据类型<ul><li>@RequestParam </li><li>@PathVariable </li><li>@RequestBody</li></ul></li><li>转发业务层<ul><li>使用 @Autowired 自动装配</li></ul></li><li>响应结果<ul><li>@ResponseBody</li></ul></li></ul></li></ol><h2 id="整合配置"><a href="#整合配置" class="headerlink" title="整合配置"></a>整合配置</h2><ul><li><p>步骤一： 创建一个SpringBoot工程<br>  注意要勾选 Spring Web ， MyBatis Framework 和 MySQL Driver </p></li><li><p>步骤二：</p><p>创建项目包结构</p><ul><li>com.blog.controller  编写Controller类</li><li>com.blog.dao  存放的是Dao层的接口，注意要使用 @Mapper 注解</li><li>com.blog.service  存放的是Service层接口，</li><li>com.blog.service.impl  存放的是Service的实现类</li><li>com.blog.domain  存放的是pojo类</li><li>resources&#x2F;static  存放静态资源HTML，CSS，JS等</li><li>test&#x2F;java  存放测试类</li></ul></li><li><p>步骤三： 编写application.yml<br>  导入Druid的坐标，并在配置文件中编写数据库连接四要素</p></li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 80</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://localhost:3306/springboot_db?serverTimezone=UTC</span><br><span class="line">    username: root</span><br><span class="line">    password: YOURPASSWORD.</span><br></pre></td></tr></table></figure><h2 id="功能模块开发"><a href="#功能模块开发" class="headerlink" title="功能模块开发"></a>功能模块开发</h2><ul><li>步骤一： 创建数据库和表</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">create database springboot_db;</span><br><span class="line">use springboot_db;</span><br><span class="line">create table tbl_book</span><br><span class="line">(</span><br><span class="line">    id          int primary key auto_increment,</span><br><span class="line">    type        varchar(20),</span><br><span class="line">    `name`      varchar(50),</span><br><span class="line">    description varchar(255)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">insert into `tbl_book`(`id`, `type`, `name`, `description`)</span><br><span class="line">values (1, &#x27;计算机理论&#x27;, &#x27;Spring实战 第五版&#x27;, &#x27;Spring入门经典教程，深入理解Spring原理技术内幕&#x27;),</span><br><span class="line">       (2, &#x27;计算机理论&#x27;, &#x27;Spring 5核心原理与30个类手写实践&#x27;, &#x27;十年沉淀之作，手写Spring精华思想&#x27;),</span><br><span class="line">       (3, &#x27;计算机理论&#x27;, &#x27;Spring 5设计模式&#x27;, &#x27;深入Spring源码刨析Spring源码中蕴含的10大设计模式&#x27;),</span><br><span class="line">       (4, &#x27;计算机理论&#x27;, &#x27;Spring MVC+Mybatis开发从入门到项目实战&#x27;,</span><br><span class="line">        &#x27;全方位解析面向Web应用的轻量级框架，带你成为Spring MVC开发高手&#x27;),</span><br><span class="line">       (5, &#x27;计算机理论&#x27;, &#x27;轻量级Java Web企业应用实战&#x27;, &#x27;源码级刨析Spring框架，适合已掌握Java基础的读者&#x27;),</span><br><span class="line">       (6, &#x27;计算机理论&#x27;, &#x27;Java核心技术 卷Ⅰ 基础知识(原书第11版)&#x27;,</span><br><span class="line">        &#x27;Core Java第11版，Jolt大奖获奖作品，针对Java SE9、10、11全面更新&#x27;),</span><br><span class="line">       (7, &#x27;计算机理论&#x27;, &#x27;深入理解Java虚拟机&#x27;, &#x27;5个纬度全面刨析JVM,大厂面试知识点全覆盖&#x27;),</span><br><span class="line">       (8, &#x27;计算机理论&#x27;, &#x27;Java编程思想(第4版)&#x27;, &#x27;Java学习必读经典，殿堂级著作！赢得了全球程序员的广泛赞誉&#x27;),</span><br><span class="line">       (9, &#x27;计算机理论&#x27;, &#x27;零基础学Java(全彩版)&#x27;, &#x27;零基础自学编程的入门图书，由浅入深，详解Java语言的编程思想和核心技术&#x27;),</span><br><span class="line">       (10, &#x27;市场营销&#x27;, &#x27;直播就这么做:主播高效沟通实战指南&#x27;, &#x27;李子柒、李佳奇、薇娅成长为网红的秘密都在书中&#x27;),</span><br><span class="line">       (11, &#x27;市场营销&#x27;, &#x27;直播销讲实战一本通&#x27;, &#x27;和秋叶一起学系列网络营销书籍&#x27;),</span><br><span class="line">       (12, &#x27;市场营销&#x27;, &#x27;直播带货:淘宝、天猫直播从新手到高手&#x27;, &#x27;一本教你如何玩转直播的书，10堂课轻松实现带货月入3W+&#x27;);</span><br></pre></td></tr></table></figure><ul><li>步骤二： 编写模型类</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class Book &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String type;</span><br><span class="line">    private String name;</span><br><span class="line">    private String description;</span><br><span class="line"></span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getType() &#123;</span><br><span class="line">        return type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setType(String type) &#123;</span><br><span class="line">        this.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDescription() &#123;</span><br><span class="line">        return description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDescription(String description) &#123;</span><br><span class="line">        this.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Book&#123;&quot; +</span><br><span class="line">                &quot;id=&quot; + id +</span><br><span class="line">                &quot;, type=&#x27;&quot; + type + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, description=&#x27;&quot; + description + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>步骤三： 编写dao接口<br>  注意使用 @Mapper 注解</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface BookDao &#123;</span><br><span class="line">    @Select(&quot;select * from tbl_book where id=#&#123;id&#125;&quot;)</span><br><span class="line">    Book getById(Integer id);</span><br><span class="line"></span><br><span class="line">    @Select(&quot;select * from tbl_book&quot;)</span><br><span class="line">    List&lt;Book&gt; getAll();</span><br><span class="line"></span><br><span class="line">    @Update(&quot;update tbl_book set type=#&#123;type&#125;, `name`=#&#123;name&#125;, `description`=#&#123;description&#125; where id=#&#123;id&#125;&quot;)</span><br><span class="line">    int update(Book book);</span><br><span class="line"></span><br><span class="line">    @Delete(&quot;delete from tbl_book where id=#&#123;id&#125;&quot;)</span><br><span class="line">    int delete(Integer id);</span><br><span class="line"></span><br><span class="line">    @Insert(&quot;insert into tbl_book values (null, #&#123;type&#125;, #&#123;name&#125;, #&#123;description&#125;)&quot;)</span><br><span class="line">    int save(Book book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>步骤四： 编写service接口及其实现类</li></ul><p>  接口：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface BookService &#123;</span><br><span class="line">    boolean save(Book book);</span><br><span class="line"></span><br><span class="line">    boolean update(Book book);</span><br><span class="line"></span><br><span class="line">    boolean delete(Integer id);</span><br><span class="line"></span><br><span class="line">    Book getById(Integer id);</span><br><span class="line"></span><br><span class="line">    List&lt;Book&gt; getAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  实现类：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class BookServiceImpl implements BookService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean save( Book book) &#123;</span><br><span class="line">        int cnt = bookDao.save(book);</span><br><span class="line">        return cnt &gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean update(Book book) &#123;</span><br><span class="line">        int cnt = bookDao.update(book);</span><br><span class="line">        return cnt&gt;0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean delete(Integer id) &#123;</span><br><span class="line">        return bookDao.delete(id) &gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Book getById(Integer id) &#123;</span><br><span class="line">        return bookDao.getById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;Book&gt; getAll() &#123;</span><br><span class="line">        return bookDao.getAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>步骤五： 编写Controller类<br>  注意响应pojo类型要加 @RequestBody 注解，某人忘加了，调试了半天</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/books&quot;)</span><br><span class="line">public class BookController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private BookService bookService;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public Book getById(@PathVariable Integer id) &#123;</span><br><span class="line">        return bookService.getById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping</span><br><span class="line">    public List&lt;Book&gt; getAll() &#123;</span><br><span class="line">        return bookService.getAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping</span><br><span class="line">    public boolean save(@RequestBody Book book) &#123;</span><br><span class="line">        return bookService.save(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PutMapping</span><br><span class="line">    public boolean update(@RequestBody Book book) &#123;</span><br><span class="line">        return bookService.update(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public boolean delete(@PathVariable Integer id) &#123;</span><br><span class="line">        return bookService.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>步骤六： 使用PostMan进行测试<br>  将增删改查全部测试完毕之后，就可以继续往下做了</li></ul><h2 id="统一结果封装"><a href="#统一结果封装" class="headerlink" title="统一结果封装"></a>统一结果封装</h2><ul><li><p>创建一个返回结果类<br>我这里暂时只需要返回的结果，状态码和异常信息，如果还有别的需求，可以自行删改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class Result &#123;</span><br><span class="line">    private Object data;</span><br><span class="line">    private Integer code;</span><br><span class="line">    private String msg;</span><br><span class="line"></span><br><span class="line">    public Object getData() &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Object data) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getCode() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCode(Integer code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getMsg() &#123;</span><br><span class="line">        return msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMsg(String msg) &#123;</span><br><span class="line">        this.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Result&#123;&quot; +</span><br><span class="line">                &quot;data=&quot; + data +</span><br><span class="line">                &quot;, code=&quot; + code +</span><br><span class="line">                &quot;, msg=&#x27;&quot; + msg + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义状态码Code类<br>状态码也可以根据自己的需求来自定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Code &#123;</span><br><span class="line">    public static final Integer SAVE_OK = 20011;</span><br><span class="line">    public static final Integer SAVE_ERR = 20010;</span><br><span class="line"></span><br><span class="line">    public static final Integer UPDATE_OK = 20021;</span><br><span class="line">    public static final Integer UPDATE_ERR = 20020;</span><br><span class="line"></span><br><span class="line">    public static final Integer DELETE_OK = 20031;</span><br><span class="line">    public static final Integer DELETE_ERR = 20030;</span><br><span class="line"></span><br><span class="line">    public static final Integer GET_OK = 20041;</span><br><span class="line">    public static final Integer GET_ERR = 20040;</span><br><span class="line"></span><br><span class="line">    public static final Integer SYSTEM_ERR = 50001;</span><br><span class="line">    public static final Integer SYSTEM_TIMEOUT_ERR = 50002;</span><br><span class="line">    public static final Integer SYSTEM_UNKNOW_ERR = 59999;</span><br><span class="line"></span><br><span class="line">    public static final Integer BUSINESS_ERR = 60001;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改Controller类的返回值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/books&quot;)</span><br><span class="line">public class BookController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private BookService bookService;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public Result getById(@PathVariable Integer id) &#123;</span><br><span class="line">        Book book = bookService.getById(id);</span><br><span class="line">        Integer code = book == null ? Code.GET_ERR : Code.GET_OK;</span><br><span class="line">        String msg = book == null ? &quot;数据查询失败，请重试！&quot; : &quot;&quot;;</span><br><span class="line">        return new Result(code, book, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping</span><br><span class="line">    public Result getAll() &#123;</span><br><span class="line">        List&lt;Book&gt; books = bookService.getAll();</span><br><span class="line">        Integer code = books == null ? Code.GET_ERR : Code.GET_OK;</span><br><span class="line">        String msg = books == null ? &quot;数据查询失败，请重试！&quot; : &quot;&quot;;</span><br><span class="line">        return new Result(code, books, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping</span><br><span class="line">    public Result save(@RequestBody Book book) &#123;</span><br><span class="line">        boolean flag = bookService.save(book);</span><br><span class="line">        return new Result(flag ? Code.SAVE_OK : Code.SAVE_ERR, flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PutMapping</span><br><span class="line">    public Result update(@RequestBody Book book) &#123;</span><br><span class="line">        boolean flag = bookService.update(book);</span><br><span class="line">        return new Result(flag ? Code.UPDATE_OK : Code.UPDATE_ERR, flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public Result delete(@PathVariable Integer id) &#123;</span><br><span class="line">        boolean flag = bookService.delete(id);</span><br><span class="line">        return new Result(flag ? Code.DELETE_OK : Code.DELETE_ERR, flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h2><ul><li><p>将异常进行分类<br>这里只将其划分为了业务异常和系统异常<br>在com.blog.exception包下新建两个异常类</p><p>BusinessException：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class BusinessException extends RuntimeException &#123;</span><br><span class="line">    private Integer code;</span><br><span class="line"></span><br><span class="line">    public Integer getCode() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCode(Integer code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BusinessException(Integer code) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BusinessException(Integer code, String message) &#123;</span><br><span class="line">        super(message);</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BusinessException(Integer code, String message, Throwable cause) &#123;</span><br><span class="line">        super(message, cause);</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SystemException：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class SystemException extends RuntimeException &#123;</span><br><span class="line">    private Integer code;</span><br><span class="line"></span><br><span class="line">    public Integer getCode() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCode(Integer code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SystemException(Integer code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SystemException(Integer code, String message) &#123;</span><br><span class="line">        super(message);</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SystemException(Integer code, String message, Throwable cause) &#123;</span><br><span class="line">        super(message, cause);</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>同时再增加几个状态码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static final Integer SYSTEM_ERR = 50001;</span><br><span class="line">public static final Integer SYSTEM_TIMEOUT_ERR = 50002;</span><br><span class="line">public static final Integer SYSTEM_UNKNOW_ERR = 59999;</span><br><span class="line">public static final Integer BUSINESS_ERR = 60001;</span><br></pre></td></tr></table></figure></li><li><p>编写自定义异常处理类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@RestControllerAdvice</span><br><span class="line">public class ProjectExceptionAdvice &#123;</span><br><span class="line"></span><br><span class="line">    //处理系统异常</span><br><span class="line">    @ExceptionHandler(SystemException.class)</span><br><span class="line">    public Result doSystemException(SystemException exception)&#123;</span><br><span class="line">        return new Result(exception.getCode(),null,exception.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //处理业务异常</span><br><span class="line">    @ExceptionHandler(BusinessException.class)</span><br><span class="line">    public Result doBusinessException(BusinessException exception)&#123;</span><br><span class="line">        return new Result(exception.getCode(),null,exception.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //处理未知异常</span><br><span class="line">    @ExceptionHandler(Exception.class)</span><br><span class="line">    public Result doException(Exception exception)&#123;</span><br><span class="line">        return new Result(Code.SYSTEM_UNKNOW_ERR,null,&quot;系统繁忙，请稍后再试&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试异常<br>可以getById方法中来进行测试，当id为1时，错误码为 BUSINESS_ERR ，错误信息为 不让你瞅 ，当查询其他id时，均为 SYSTEM_UNKNOW_ERR ，错误提示信息为 服务器访问超时，请稍后再试 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class BookServiceImpl implements BookService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean save(Book book) &#123;</span><br><span class="line">        int cnt = bookDao.save(book);</span><br><span class="line">        return cnt &gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean update(Book book) &#123;</span><br><span class="line">        int cnt = bookDao.update(book);</span><br><span class="line">        return cnt &gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean delete(Integer id) &#123;</span><br><span class="line">        return bookDao.delete(id) &gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Book getById(Integer id) &#123;</span><br><span class="line">        if (id == 1)&#123;</span><br><span class="line">            throw new BusinessException(Code.BUSINESS_ERR,&quot;不让你瞅&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            int a = 1 / 0;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new SystemException(Code.SYSTEM_UNKNOW_ERR, &quot;服务器访问超时，请稍后再试&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return bookDao.getById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;Book&gt; getAll() &#123;</span><br><span class="line">        return bookDao.getAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis-Plus</title>
      <link href="/2023/10/23/MyBatisPlus/"/>
      <url>/2023/10/23/MyBatisPlus/</url>
      
        <content type="html"><![CDATA[<h1 id="MyBatis-Plus"><a href="#MyBatis-Plus" class="headerlink" title="MyBatis-Plus"></a>MyBatis-Plus</h1><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231203212401381.png" alt="image-20231203212401381"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p><p>MyBatis-Plus提供 了通用的mapper和service，可以在不编写任何SQL语句的情况下，快速的实现对单表的CRUD、批量、逻辑删除、分页等操作。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li><li>损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li><li>强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li><li>支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li><li>支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li><li>支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li><li>支持自定义全局通用操作：支持全局通用方法注入（ Write once,  use anywhere ）</li><li>内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li><li>内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li><li>分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li><li>内置性能分析插件：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li><li>内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li></ul><h2 id="支持数据库"><a href="#支持数据库" class="headerlink" title="支持数据库"></a>支持数据库</h2><p>任何能使用 <code>MyBatis</code> 进行 CRUD，并且支持标准 SQL 的数据库，具体支持情况如下：</p><ul><li>MySQL，Oracle，DB2，H2，HSQL，SQLite，PostgreSQL，SQLServer，Phoenix，Gauss ，ClickHouse，Sybase，OceanBase，Firebird，Cubrid，Goldilocks，csiidb</li></ul><h2 id="框架结构"><a href="#框架结构" class="headerlink" title="框架结构"></a>框架结构</h2><img src="https://baomidou.com/img/mybatis-plus-framework.jpg" alt="framework" style="zoom:50%;" /><ol><li>扫描实体类，通过反射，把实体类抽取出来</li><li>分析要操作的表和属性，生成相应的SQL语句</li><li>把SQL语句注入到Mybatis容器里面</li></ol><h2 id="官方地址"><a href="#官方地址" class="headerlink" title="官方地址"></a>官方地址</h2><p>官方网站：<a href="https://baomidou.com/">https://baomidou.com/</a></p><p>官方文档：<a href="https://baomidou.com/pages/24112f/">https://baomidou.com/pages/24112f/</a></p><h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h2><h3 id="建库建表"><a href="#建库建表" class="headerlink" title="建库建表"></a>建库建表</h3><ul><li><p>运行以下SQL脚本进行建库建表</p><p>这里因为后面使用雪花算法，自动为id赋一个19为的值，要用bigInt接受</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE `mybatis_plus` <span class="comment">/*!40100 DEFAULT CHARACTER SET utf8mb4 */</span>; </span><br><span class="line">use `mybatis_plus`; </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` ( </span><br><span class="line">    `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主键ID&#x27;</span>,  </span><br><span class="line">    `name` <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,  </span><br><span class="line">    `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;年龄&#x27;</span>,  </span><br><span class="line">    `email` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>,  </span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`) </span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure></li><li><p>插入几条测试数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> (id,  name,  age,  email) <span class="keyword">VALUES</span> </span><br><span class="line">(<span class="number">1</span>,  <span class="string">&#x27;Jone&#x27;</span>,  <span class="number">18</span>,  <span class="string">&#x27;test1@baomidou.com&#x27;</span>),  </span><br><span class="line">(<span class="number">2</span>,  <span class="string">&#x27;Jack&#x27;</span>,  <span class="number">20</span>,  <span class="string">&#x27;test2@baomidou.com&#x27;</span>),  </span><br><span class="line">(<span class="number">3</span>,  <span class="string">&#x27;Tom&#x27;</span>,  <span class="number">28</span>,  <span class="string">&#x27;test3@baomidou.com&#x27;</span>),  </span><br><span class="line">(<span class="number">4</span>,  <span class="string">&#x27;Sandy&#x27;</span>,  <span class="number">21</span>,  <span class="string">&#x27;test4@baomidou.com&#x27;</span>),  </span><br><span class="line">(<span class="number">5</span>,  <span class="string">&#x27;Billie&#x27;</span>,  <span class="number">24</span>,  <span class="string">&#x27;test5@baomidou.com&#x27;</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h3><ul><li><p>使用<code>Spring Initializer</code>快速初始化一个<code>SpringBoot工程</code></p></li><li><p>引入<code>MyBatis-Plus</code>的依赖</p><p><code>mvnrepository.com</code>里面找相关依赖坐标，有2个，</p><p>带<code>starter</code>的给<code>SpringBoot工程</code>用，</p><p>单独<code>mybatis-plus</code>的给<code>Spring工程</code>用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>安装<code>Lombok</code>插件</p></li><li><p>配置application.yml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment">#配置数据源</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="comment">#配置数据源类型</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">    <span class="comment">#配置连接数据库的信息</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> &#123;<span class="string">username</span>&#125;</span><br><span class="line">    <span class="attr">password:</span> &#123;<span class="string">password</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#MyBatis-Plus相关配置</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment">#配置日志</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure><p>驱动类：</p><ul><li><code>SpringBoot 2.0</code>内置jdbc5驱动，使用：driver-class-name: com.mysql.jdbc.Driver</li><li><code>SpringBoot 2.1及以上</code>内置jdbc8驱动，使用：driver-class-name: com.mysql.cj.jdbc.Driver</li></ul><p>连接地址url：</p><ul><li>MySQL5.7：<code>jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;useSSL=false </code></li><li>MySQL8.0：<code>jdbc:mysql://localhost:3306/mybatis_plus? serverTimezone=GMT%2B8&amp;characterEncoding=utf-8&amp;useSSL=false</code></li></ul></li><li><p>在 Spring Boot 启动类中添加 <code>@MapperScan</code> 注解，扫描 Mapper 接口所在的包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;指定Mapper接口所在的包全类名&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusDemoApplication</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">SpringApplication.run(MybatisPlusDemoApplication.class,  args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写实体类 <code>User.java</code>（此处使用了 Lombok 简化代码）</p><blockquote><p>@Data 和 @NoargsConstructor、@AllargsConstructor、@EqualsAndHashCode、@ToString</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoargsConstructor</span></span><br><span class="line"><span class="meta">@AllargsConstructor</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写 Mapper 包下的 <code>UserMapper</code>接口，继承<code>BaseMapper</code>接口，要用泛型指定类型，类型来自我们的entity层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul><li><p>编写一个测试类<code>MyBatisPlusTest.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisPlusTest</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="comment">//这个地方大概率报红，但是不影响使用，因为这个是接口，spring容器无法注入接口</span></span><br><span class="line">    <span class="comment">//实际上是动态生成一个代理类交给了容器，但是编译器不一定认</span></span><br><span class="line">    <span class="comment">//解决办法有，但是不影响使用，我也不知道原理，就不写了</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSelectList</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//通过条件构造器查询一个list集合，若没有条件，则可以设置null为参数</span></span><br><span class="line">        List&lt;User&gt; users = userMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">        users.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="常见配置"><a href="#常见配置" class="headerlink" title="常见配置"></a>常见配置</h2><p>MybatisPlus也支持基于yaml文件的自定义配置，详见<a href="https://www.baomidou.com/pages/56bac0/">官方文档</a></p><p>大多数的配置都有默认值，因此我们都无需配置。配置和Mybatis的基本一样</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.itheima.mp.domain.po</span> <span class="comment"># 别名扫描包  </span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">&quot;classpath*:/mapper/**/*.xml&quot;</span> <span class="comment"># Mapper.xml文件地址，默认值，可以改 </span></span><br><span class="line">  <span class="attr">configuration:</span>    </span><br><span class="line">  <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span> <span class="comment"># 是否开启下划线和驼峰的映射    </span></span><br><span class="line">    <span class="attr">cache-enabled:</span> <span class="literal">false</span> <span class="comment"># 是否开启二级缓存</span></span><br><span class="line">  <span class="attr">global-config:</span>    </span><br><span class="line">  <span class="attr">db-config:</span>     </span><br><span class="line">    <span class="attr">id-type:</span> <span class="string">assign_id</span> <span class="comment"># id为雪花算法生成     </span></span><br><span class="line">    <span class="attr">update-strategy:</span> <span class="string">not_null</span> <span class="comment"># 更新策略：只更新非空字段</span></span><br></pre></td></tr></table></figure><p>但还有一些是没有默认值的，例如:</p><ul><li>实体类的别名扫描包</li><li>全局id类型</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="string">//实体类的别名扫描包</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.itheima.mp.domain.po</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="string">//全局id类型</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span> <span class="comment"># 全局id类型为自增长</span></span><br></pre></td></tr></table></figure><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>UserMapper在继承BaseMapper的时候指定了一个泛型，泛型中的User就是与数据库对应的POJO。MybatisPlus就是根据实体类的信息来推断出表的信息，从而生成SQL的。</p><p>默认情况下：</p><ul><li>MybatisPlus会把实体类的类名驼峰转下划线作为表名</li><li>MybatisPlus会把实体类的所有变量名驼峰转下划线作为表的字段名，并根据变量类型推断字段类型</li><li>MybatisPlus会把名为id的字段作为主键</li></ul><p>但很多情况下，默认的实现与实际场景不符，因此MybatisPlus提供了一些注解便于我们声明表信息。</p><h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><p>常用注解有：</p><ul><li>@TableName：用来指定表名</li><li>@TableId：用来指定表中的主键字段信息</li><li>@TableField：用来指定表中的普通字段信息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@TableId</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="meta">@TableField(&quot;isMarried&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Boolean isMarried;</span><br><span class="line">    <span class="meta">@TableField(&quot;concat&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String concat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="tabs" id=""><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#-1"><i class="TableName" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#-2"><i class="TableId" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#-3"><i class="TbaleField" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#-4"><i class="TableLogic" style="text-align: center;"></i></button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="-1"><p>@TableName：表名注解，标识实体类对应的表，加在实体类上</p><p>TableName注解除了指定表名以外，还可以指定很多其它属性，用的时候查表</p><hr><p>若实体类类型的类名和要操作的表的表名不一致，会出现什么问题？</p><ul><li><p>我们将表<code>user</code>更名为<code>t_user</code>，测试查询功能</p></li><li><p>程序抛出异常，Table ‘mybatis_plus.user’ doesn’t exist，因为现在的表名为<code>t_user</code>，而默认操作的表名和实体类型的类名一致，即<code>user</code>表</p></li></ul><p>解决办法：</p><ol><li><p>使用注解解决问题</p><p>在实体类类型上添加<code>@TableName(&quot;t_user&quot;)</code>，标识实体类对应的表，即可成功执行SQL语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;t_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用全局配置解决问题</p><p>在开发的过程中，我们经常遇到以上的问题，即实体类所对应的表都有固定的前缀，例如 <code>t_</code> 或 <code>tbl_</code> 此时，可以使用MyBatis-Plus提供的全局配置，为实体类所对应的表名设置默认的前缀，那么就不需要在每个实体类上通过@TableName标识实体类对应的表</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="comment"># 设置实体类所对应的表的统一前缀</span></span><br><span class="line">      <span class="attr">table-prefix:</span> <span class="string">t_</span></span><br></pre></td></tr></table></figure></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-2"><p>@TableId：主键注解，标识实体类中的主键字段，加在属性上，MyBatis-Plus在实现CRUD时，会默认将id作为主键列，并在插入数据时，默认基于雪花算法的策略生成id，可以用type属性指定更改策略</p><p><code>TableId</code>注解支持两个属性：</p><table><thead><tr><th align="left"><strong>属性</strong></th><th align="left"><strong>类型</strong></th><th align="left"><strong>必须指定</strong></th><th align="left"><strong>默认值</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left">value</td><td align="left">String</td><td align="left">否</td><td align="left">“”</td><td align="left">表名</td></tr><tr><td align="left">type</td><td align="left">Enum</td><td align="left">否</td><td align="left">IdType.NONE</td><td align="left">指定主键类型</td></tr></tbody></table><p><code>IdType</code>支持的类型有：</p><table><thead><tr><th align="left"><strong>值</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left">AUTO</td><td align="left">数据库 ID 自增</td></tr><tr><td align="left">NONE</td><td align="left">无状态，该类型为未设置主键类型（注解里等于跟随全局，全局里约等于 INPUT）</td></tr><tr><td align="left">INPUT</td><td align="left">insert 前自行 set 主键值</td></tr><tr><td align="left">ASSIGN_ID</td><td align="left">分配 ID(主键类型为 Number(Long 和 Integer)或 String)(since 3.3.0), 使用接口IdentifierGenerator的方法nextId(默认实现类为DefaultIdentifierGenerator雪花算法)</td></tr><tr><td align="left">ASSIGN_UUID</td><td align="left">分配 UUID, 主键类型为 String(since 3.3.0), 使用接口IdentifierGenerator的方法nextUUID(默认 default 方法)</td></tr><tr><td align="left">ID_WORKER</td><td align="left">分布式全局唯一 ID 长整型类型(please use ASSIGN_ID)</td></tr><tr><td align="left">UUID</td><td align="left">32 位 UUID 字符串(please use ASSIGN_UUID)</td></tr><tr><td align="left">ID_WORKER_STR</td><td align="left">分布式全局唯一 ID 字符串类型(please use ASSIGN_ID)</td></tr></tbody></table><p>这里比较常见的有三种：</p><ul><li><code>AUTO</code>：利用数据库的id自增长</li><li><code>INPUT</code>：手动生成id</li><li><code>ASSIGN_ID</code>：雪花算法生成<code>Long</code>类型的全局唯一id，这是默认的ID策略</li></ul><hr>配置全局主键策略：<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#MyBatis-Plus相关配置</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment">#配置日志</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="comment">#配置mp的主键策略为自增</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br><span class="line">      <span class="comment"># 设置实体类所对应的表的统一前缀</span></span><br><span class="line">      <span class="attr">table-prefix:</span> <span class="string">t_</span></span><br></pre></td></tr></table></figure><hr><p>若实体类和表中表示主键的不是id，而是其他字段，例如uid，MyBatis-Plus会自动识别uid为主键列吗？</p><ol><li>我们实体类中的属性<code>id</code>改为<code>uid</code>，将表中的字段<code>id</code>也改为<code>uid</code>，测试添加功能</li><li>程序抛出异常，Field ‘uid’ doesn’t have a default value，说明MyBatis-Plus没有将<code>uid</code>作为主键赋值</li><li>在实体类中uid属性上通过<code>@TableId</code>将其标识为主键，即可成功执行SQL语句</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-3"><p>@TbaleField：普通字段注解，加在属性上</p><p>一般情况下我们并不需要给字段添加<code>@TableField</code>注解，一些特殊情况除外：</p><ul><li>成员变量名与数据库字段名不一致</li><li>成员变量是以<code>isXXX</code>命名，按照<code>JavaBean</code>的规范，<code>MybatisPlus</code>识别字段时会把<code>is</code>去除，这就导致与数据库不符。</li><li>成员变量名与数据库一致，但是与数据库的关键字冲突。使用<code>@TableField</code>注解给字段名添加转义字符</li></ul><hr>如果实体类中的属性名和字段名不一致的情况，会出现什么问题呢<ol><li><p>若实体类中的属性使用的是驼峰命名风格，而表中的字段使用的是下划线命名风格</p><p>例如实体类属性<code>userName</code>，表中字段<code>user_name</code></p><p>此时MyBatis-Plus会自动将下划线命名风格转化为驼峰命名风格, 相当于在MyBatis中配置</p></li><li><p>若实体类中的属性和表中的字段不满足上诉要求</p><p>例如实体类属性<code>name</code>，表中字段<code>username</code></p><p>此时需要在实体类属性上使用<code>@TableField(&quot;username&quot;)</code>设置属性所对应的字段名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@TableId(&quot;uid&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@TableField(&quot;username&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-4"><p>物理删除：真实删除，将对应数据从数据库中删除，之后查询不到此条被删除的数据</p><p>逻辑删除：假删除，将对应数据中代表是否被删除字段的状态修改为“被删除状态”，之后在数据库中仍旧能看到此条数据记录</p><p>使用场景：可以进行数据恢复</p><hr><p>在实体类的属性上添加<code>@TableLogic</code>，把实体类和表的逻辑删除字段联系起来</p><p>默认只有MybatisPlus提供的SQL支持逻辑删除，自己的SQL语句需要进行配置</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h1><h2 id="BaseMapper-lt-T-gt"><a href="#BaseMapper-lt-T-gt" class="headerlink" title="BaseMapper&lt;T&gt;"></a>BaseMapper&lt;T&gt;</h2><p>为了简化单表CRUD，MybatisPlus提供了一个基础的<code>BaseMapper</code>接口，其中已经实现了单表的CRUD，自定义的Mapper接口只要实现了这个<code>BaseMapper</code>，就无需自己实现单表CRUD了。</p><p>只需要继承BaseMapper就能省去所有的单表CRUD</p><p>说明:</p><ul><li>通用 CRUD 封装BaseMapper 接口，为 <code>Mybatis-Plus</code> 启动时自动解析实体表关系映射转换为 <code>Mybatis</code> 内部对象注入容器</li><li>泛型 <code>T</code> 为任意实体对象</li><li>参数 <code>Serializable</code> 为任意类型主键 <code>Mybatis-Plus</code> 不推荐使用复合主键约定每一张表都有自己的唯一 <code>id</code> 主键</li><li>对象 <code>Wrapper</code> 为条件构造器</li></ul><p>MyBatis-Plus中的基本CRUD在内置的BaseMapper中都已得到了实现，因此我们继承该接口以后可以直接使用。</p><p>BaseMapper源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.baomidou.mybatisplus.core.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.Wrapper;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.metadata.IPage;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BaseMapper</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Mapper</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">insert</span><span class="params">(T entity)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteByMap</span><span class="params">(<span class="meta">@Param(&quot;cm&quot;)</span> Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteBatchIds</span><span class="params">(<span class="meta">@Param(&quot;coll&quot;)</span> Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateById</span><span class="params">(<span class="meta">@Param(&quot;et&quot;)</span> T entity)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">update</span><span class="params">(<span class="meta">@Param(&quot;et&quot;)</span> T entity, <span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; updateWrapper)</span>;</span><br><span class="line"></span><br><span class="line">    T <span class="title function_">selectById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;T&gt; <span class="title function_">selectBatchIds</span><span class="params">(<span class="meta">@Param(&quot;coll&quot;)</span> Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;T&gt; <span class="title function_">selectByMap</span><span class="params">(<span class="meta">@Param(&quot;cm&quot;)</span> Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"></span><br><span class="line">    T <span class="title function_">selectOne</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line">    Integer <span class="title function_">selectCount</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;T&gt; <span class="title function_">selectList</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">selectMaps</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;Object&gt; <span class="title function_">selectObjs</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line">    &lt;E <span class="keyword">extends</span> <span class="title class_">IPage</span>&lt;T&gt;&gt; E <span class="title function_">selectPage</span><span class="params">(E page, <span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line">    &lt;E <span class="keyword">extends</span> <span class="title class_">IPage</span>&lt;Map&lt;String, Object&gt;&gt;&gt; E <span class="title function_">selectMapsPage</span><span class="params">(E page, <span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CRUD方法"><a href="#CRUD方法" class="headerlink" title="CRUD方法"></a>CRUD方法</h3><ul><li><p>增加：Insert</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入一条记录</span></span><br><span class="line"><span class="comment">// @param entity 实体对象</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(T entity)</span>;</span><br></pre></td></tr></table></figure></li><li><p>删除：Delete</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 ID 删除</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 entity 条件，删除记录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除（根据ID 批量删除）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteBatchIds</span><span class="params">(<span class="meta">@Param(&quot;coll&quot;)</span> Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 columnMap 条件，删除记录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteByMap</span><span class="params">(<span class="meta">@Param(&quot;cm&quot;)</span> Map&lt;String, Object&gt; columnMap)</span>;</span><br></pre></td></tr></table></figure></li><li><p>修改：Update</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 ID 修改</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">updateById</span><span class="params">(<span class="meta">@Param(Constants.ENTITY)</span> T entity)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 whereWrapper 条件，更新记录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">update</span><span class="params">(<span class="meta">@Param(&quot;et&quot;)</span> T entity, <span class="meta">@Param(&quot;ew&quot;)</span> Wrapper&lt;T&gt; updateWrapper)</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询：Selete</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 ID 查询</span></span><br><span class="line">T <span class="title function_">selectById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 entity 条件，查询一条记录</span></span><br><span class="line">T <span class="title function_">selectOne</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询（根据ID 批量查询）</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">selectBatchIds</span><span class="params">(<span class="meta">@Param(Constants.COLLECTION)</span> Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 entity 条件，查询全部记录</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">selectList</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询（根据 columnMap 条件）</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">selectByMap</span><span class="params">(<span class="meta">@Param(Constants.COLUMN_MAP)</span> Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">selectMaps</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录。注意： 只返回第一个字段的值</span></span><br><span class="line">List&lt;Object&gt; <span class="title function_">selectObjs</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 entity 条件，查询全部记录（并翻页）</span></span><br><span class="line">IPage&lt;T&gt; <span class="title function_">selectPage</span><span class="params">(IPage&lt;T&gt; page, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录（并翻页）</span></span><br><span class="line">IPage&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">selectMapsPage</span><span class="params">(IPage&lt;T&gt; page, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询总记录数</span></span><br><span class="line">Integer <span class="title function_">selectCount</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><div class="tabs" id=""><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#-1">插入</button></li><li class="tab"><button type="button" data-href="#-2">删除</button></li><li class="tab"><button type="button" data-href="#-3">修改</button></li><li class="tab"><button type="button" data-href="#-4">查询</button></li><li class="tab"><button type="button" data-href="#-5">插入</button></li><li class="tab"><button type="button" data-href="#-6">删除</button></li><li class="tab"><button type="button" data-href="#-7">修改</button></li><li class="tab"><button type="button" data-href="#-8">查询</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 测试插入一条数据</span></span><br><span class="line"><span class="comment">  * MyBatis-Plus在实现插入数据时，会默认基于雪花算法的策略生成id</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsert</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;咕哒子&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">21</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.insert(user);</span><br><span class="line">    System.out.println(result &gt; <span class="number">0</span> ? <span class="string">&quot;添加成功！&quot;</span> : <span class="string">&quot;添加失败！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数为：&quot;</span> + result);</span><br><span class="line">    <span class="comment">//1527206783590903810（当前 id 为雪花算法自动生成的id）</span></span><br><span class="line">    System.out.println(<span class="string">&quot;id自动获取&quot;</span> + user.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-2"><p>根据ID删除数据：<strong>调用方法：<code>int deleteById(Serializable id);</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 测试根据id删除一条数据</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteById</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.deleteById(<span class="number">1527206783590903810L</span>);</span><br><span class="line">    System.out.println(result &gt; <span class="number">0</span> ? <span class="string">&quot;删除成功！&quot;</span> : <span class="string">&quot;删除失败！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数为：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据ID批量删除数据：<strong>调用方法：<code>int deleteBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 测试通过id批量删除数据</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteBatchIds</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Long&gt; ids = Arrays.asList(<span class="number">6L</span>,<span class="number">7L</span>,<span class="number">8L</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.deleteBatchIds(ids);</span><br><span class="line">    System.out.println(result &gt; <span class="number">0</span> ? <span class="string">&quot;删除成功！&quot;</span> : <span class="string">&quot;删除失败！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数为：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据Map条件删除数据：<strong>调用方法：<code>int deleteByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap);</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 测试根据Map集合中所设置的条件删除数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteByMap</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//当前演示为根据name和age删除数据</span></span><br><span class="line">    <span class="comment">//执行SQL为：DELETE FROM user WHERE name = ? AND age = ?</span></span><br><span class="line">    Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;咕哒子&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;age&quot;</span>,<span class="number">21</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.deleteByMap(map);</span><br><span class="line">    System.out.println(result &gt; <span class="number">0</span> ? <span class="string">&quot;删除成功！&quot;</span> : <span class="string">&quot;删除失败！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数为：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-3"><p>根据ID修改：<strong>调用方法：<code>int updateById(@Param(Constants.ENTITY) T entity);</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 测试根据id修改用户信息</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdateById</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//执行SQL为： UPDATE user SET name=?, age=?, email=? WHERE id=?</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setId(<span class="number">6L</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;咕哒子&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">18</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.updateById(user);</span><br><span class="line">    System.out.println(result &gt; <span class="number">0</span> ? <span class="string">&quot;修改成功！&quot;</span> : <span class="string">&quot;修改失败！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数为：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-4"><p>根据ID查询用户信息：<strong>调用方法：<code>T selectById(Serializable id);</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 测试根据id查询用户数据</span><br><span class="line">  */</span><br><span class="line">@Test</span><br><span class="line">public void testSelectById()&#123;</span><br><span class="line">    User user = userMapper.selectById(1L);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line">java</span><br></pre></td></tr></table></figure><p>根据多个ID查询多个用户信息：<strong>调用方法：<code>List selectBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 根据多个id查询用户数据</span><br><span class="line">  */</span><br><span class="line">@Test</span><br><span class="line">public void testSelectBatchIds()&#123;</span><br><span class="line">    //执行SQL为：SELECT id,name,age,email FROM user WHERE id IN ( ? , ? , ? )</span><br><span class="line">    List&lt;Long&gt; ids = Arrays.asList(1L,2L,3L);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectBatchIds(ids);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line">java</span><br></pre></td></tr></table></figure><p>根据Map条件查询用户信息：<strong>调用方法：<code>List selectByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap);</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 根据Map所设置的条件查询用户</span><br><span class="line">  */</span><br><span class="line">@Test</span><br><span class="line">public void testSelectByMap()&#123;</span><br><span class="line">    //执行SQL为：SELECT id,name,age,email FROM user WHERE age = ?</span><br><span class="line">    Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    map.put(&quot;age&quot;,18);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectByMap(map);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line">java</span><br></pre></td></tr></table></figure><p>查询所有用户信息：<strong>调用方法：<code>List selectList(@Param(Constants.WRAPPER) Wrapper queryWrapper);</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 测试查询所有数据</span><br><span class="line">  */</span><br><span class="line">@Test</span><br><span class="line">void testSelectList()&#123;</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(null);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-5"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 测试插入一条数据</span></span><br><span class="line"><span class="comment">  * MyBatis-Plus在实现插入数据时，会默认基于雪花算法的策略生成id</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsert</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;咕哒子&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">21</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;404&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.insert(user);</span><br><span class="line">    System.out.println(result &gt; <span class="number">0</span> ? <span class="string">&quot;添加成功！&quot;</span> : <span class="string">&quot;添加失败！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数为：&quot;</span> + result);</span><br><span class="line">    <span class="comment">//1527206783590903810（当前 id 为雪花算法自动生成的id）</span></span><br><span class="line">    System.out.println(<span class="string">&quot;id自动获取&quot;</span> + user.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-6"><p>根据ID删除数据：<strong>调用方法：<code>int deleteById(Serializable id);</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 测试根据id删除一条数据</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteById</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.deleteById(<span class="number">1527206783590903810L</span>);</span><br><span class="line">    System.out.println(result &gt; <span class="number">0</span> ? <span class="string">&quot;删除成功！&quot;</span> : <span class="string">&quot;删除失败！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数为：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据ID批量删除数据：<strong>调用方法：<code>int deleteBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 测试通过id批量删除数据</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteBatchIds</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Long&gt; ids = Arrays.asList(<span class="number">6L</span>,<span class="number">7L</span>,<span class="number">8L</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.deleteBatchIds(ids);</span><br><span class="line">    System.out.println(result &gt; <span class="number">0</span> ? <span class="string">&quot;删除成功！&quot;</span> : <span class="string">&quot;删除失败！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数为：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据Map条件删除数据：<strong>调用方法：<code>int deleteByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap);</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 测试根据Map集合中所设置的条件删除数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDeleteByMap</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//当前演示为根据name和age删除数据</span></span><br><span class="line">    <span class="comment">//执行SQL为：DELETE FROM user WHERE name = ? AND age = ?</span></span><br><span class="line">    Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;咕哒子&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;age&quot;</span>,<span class="number">16</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.deleteByMap(map);</span><br><span class="line">    System.out.println(result &gt; <span class="number">0</span> ? <span class="string">&quot;删除成功！&quot;</span> : <span class="string">&quot;删除失败！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数为：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-7"><p>根据ID修改：<strong>调用方法：<code>int updateById(@Param(Constants.ENTITY) T entity);</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 测试根据id修改用户信息</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdateById</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//执行SQL为： UPDATE user SET name=?, age=?, email=? WHERE id=?</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setId(<span class="number">6L</span>);</span><br><span class="line">    user.setName(<span class="string">&quot;咕哒子&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">18</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;404@sina.com&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.updateById(user);</span><br><span class="line">    System.out.println(result &gt; <span class="number">0</span> ? <span class="string">&quot;修改成功！&quot;</span> : <span class="string">&quot;修改失败！&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数为：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-8"><p>根据ID查询用户信息：<strong>调用方法：<code>T selectById(Serializable id);</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 测试根据id查询用户数据</span><br><span class="line">  */</span><br><span class="line">@Test</span><br><span class="line">public void testSelectById()&#123;</span><br><span class="line">    User user = userMapper.selectById(1L);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line">java</span><br></pre></td></tr></table></figure><p>根据多个ID查询多个用户信息：<strong>调用方法：<code>List selectBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList);</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 根据多个id查询用户数据</span><br><span class="line">  */</span><br><span class="line">@Test</span><br><span class="line">public void testSelectBatchIds()&#123;</span><br><span class="line">    //执行SQL为：SELECT id,name,age,email FROM user WHERE id IN ( ? , ? , ? )</span><br><span class="line">    List&lt;Long&gt; ids = Arrays.asList(1L,2L,3L);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectBatchIds(ids);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line">java</span><br></pre></td></tr></table></figure><p>根据Map条件查询用户信息：<strong>调用方法：<code>List selectByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap);</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 根据Map所设置的条件查询用户</span><br><span class="line">  */</span><br><span class="line">@Test</span><br><span class="line">public void testSelectByMap()&#123;</span><br><span class="line">    //执行SQL为：SELECT id,name,age,email FROM user WHERE age = ?</span><br><span class="line">    Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    map.put(&quot;age&quot;,18);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectByMap(map);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line">java</span><br></pre></td></tr></table></figure><p>查询所有用户信息：<strong>调用方法：<code>List selectList(@Param(Constants.WRAPPER) Wrapper queryWrapper);</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 测试查询所有数据</span><br><span class="line">  */</span><br><span class="line">@Test</span><br><span class="line">void testSelectList()&#123;</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(null);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="Service-CRUD-接口"><a href="#Service-CRUD-接口" class="headerlink" title="Service CRUD 接口"></a>Service CRUD 接口</h2><p>MybatisPlus不仅提供了BaseMapper，还提供了通用的Service接口及默认实现，进一步封装 CRUD，前缀命名方式区分 <code>Mapper</code> 层避免混淆。前缀命名方式区分 <code>Mapper</code> 层避免混淆。通用接口为<code>IService</code>，默认实现为<code>ServiceImpl</code>，<code>ServiceImpl</code>在使用的时候需要指明泛型中<code>Mapper接口</code>和<code>实体类</code>的类型</p><p>其中封装的方法可以分为以下几类：</p><ul><li><code>save</code>：新增</li><li><code>remove</code>：删除</li><li><code>update</code>：更新</li><li><code>get</code>：查询单个结果</li><li><code>list</code>：查询集合结果</li><li><code>count</code>：计数</li><li><code>page</code>：分页查询</li><li>方法形参： <code>Wrapper</code>对象，为条件构造器</li></ul><blockquote><p>建议如果存在自定义通用 Service 方法的可能，请创建自己的 <code>IBaseService</code> 继承 <code>Mybatis-Plus</code> 提供的基类</p></blockquote><h3 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h3><div class="tabs" id=""><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#-1">增</button></li><li class="tab"><button type="button" data-href="#-2">删</button></li><li class="tab"><button type="button" data-href="#-3">改</button></li><li class="tab"><button type="button" data-href="#-4">查</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="-1"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入一条记录（选择字段，策略插入）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">save</span><span class="params">(T entity)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入（批量）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入（批量）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TableId 注解存在更新记录，否插入一条记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdate</span><span class="params">(T entity)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据updateWrapper尝试更新，否继续执行saveOrUpdate(T)方法</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdate</span><span class="params">(T entity, Wrapper&lt;T&gt; updateWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量修改插入</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量修改插入</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>save</code>是新增单个元素</li><li><code>saveBatch</code>是批量新增</li><li><code>saveOrUpdate</code>是根据id判断，如果数据存在就更新，不存在则新增</li><li><code>saveOrUpdateBatch</code>是批量的新增或修改</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-2"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 entity 条件，删除记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 ID 删除</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 columnMap 条件，删除记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除（根据ID 批量删除）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeByIds</span><span class="params">(Collection&lt;? extends Serializable&gt; idList)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>removeById</code>：根据id删除</li><li><code>removeByIds</code>：根据id批量删除</li><li><code>removeByMap</code>：根据Map中的键值对为条件删除</li><li><code>remove(Wrapper&lt;T&gt;)</code>：根据Wrapper条件删除</li><li><del>removeBatchByIds</del>：暂不支持</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 UpdateWrapper 条件，更新记录 需要设置sqlset</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">update</span><span class="params">(Wrapper&lt;T&gt; updateWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 whereWrapper 条件，更新记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">update</span><span class="params">(T updateEntity, Wrapper&lt;T&gt; whereWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 ID 选择修改</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">updateById</span><span class="params">(T entity)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据ID 批量更新</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据ID 批量更新</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>updateById</code>：根据id修改</li><li><code>update(Wrapper&lt;T&gt;)</code>：根据<code>UpdateWrapper</code>修改，<code>Wrapper</code>中包含<code>set</code>和<code>where</code>部分</li><li><code>update(T，Wrapper&lt;T&gt;)</code>：按照<code>T</code>内的数据修改与<code>Wrapper</code>匹配到的数据</li><li><code>updateBatchById</code>：根据id批量修改</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-4"><p><strong>Get：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 ID 查询</span></span><br><span class="line">T <span class="title function_">getById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 Wrapper查询一条记录。</span></span><br><span class="line"><span class="comment">// 结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last(&quot;LIMIT 1&quot;)</span></span><br><span class="line">T <span class="title function_">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">T <span class="title function_">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, <span class="type">boolean</span> throwEx)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">Map&lt;String, Object&gt; <span class="title function_">getMap</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">&lt;V&gt; V <span class="title function_">getObj</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, Function&lt;? <span class="built_in">super</span> Object, V&gt; mapper)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>getById</code>：根据id查询1条数据</li><li><code>getOne(Wrapper&lt;T&gt;)</code>：根据<code>Wrapper</code>查询1条数据</li><li><code>getBaseMapper</code>：获取<code>Service</code>内的<code>BaseMapper</code>实现，某些时候需要直接调用<code>Mapper</code>内的自定义<code>SQL</code>时可以用这个方法获取到<code>Mapper</code></li></ul><p><strong>List：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询所有</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">list</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询列表</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">list</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询（根据ID 批量查询）</span></span><br><span class="line">Collection&lt;T&gt; <span class="title function_">listByIds</span><span class="params">(Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询（根据 columnMap 条件）</span></span><br><span class="line">Collection&lt;T&gt; <span class="title function_">listByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询所有列表</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">listMaps</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询列表</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">listMaps</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询全部记录</span></span><br><span class="line">List&lt;Object&gt; <span class="title function_">listObjs</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询全部记录</span></span><br><span class="line">&lt;V&gt; List&lt;V&gt; <span class="title function_">listObjs</span><span class="params">(Function&lt;? <span class="built_in">super</span> Object, V&gt; mapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line">List&lt;Object&gt; <span class="title function_">listObjs</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line">&lt;V&gt; List&lt;V&gt; <span class="title function_">listObjs</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, Function&lt;? <span class="built_in">super</span> Object, V&gt; mapper)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>listByIds</code>：根据id批量查询</li><li><code>list(Wrapper&lt;T&gt;)</code>：根据Wrapper条件查询多条数据</li><li><code>list()</code>：查询所有</li></ul><p><strong>Count</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询总记录数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询总记录数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>count()</code>：统计所有数量</li><li><code>count(Wrapper&lt;T&gt;)</code>：统计符合<code>Wrapper</code>条件的数据数量</li></ul><p><strong>getBaseMapper</strong>： </p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231213161547250.png" alt="image-20231213161547250"></p><ul><li>当我们在service中要调用Mapper中自定义SQL时，就必须获取service对应的Mapper，就可以通过这个方法</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>由于<code>Service</code>中经常需要定义与业务有关的自定义方法，因此我们不能直接使用<code>IService</code>，而是自定义<code>Service</code>接口，然后继承<code>IService</code>以拓展方法。同时，让自定义的<code>Service实现类</code>继承<code>ServiceImpl</code>，这样就不用自己实现<code>IService</code>中的接口了。</p><ol><li><p>定义<code>UserService</code>，继承<code>IService</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="comment">// 拓展自定义方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写<code>UserServiceImpl</code>类，继承<code>ServiceImpl</code>，实现<code>UserService</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123; &#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testGetCount()&#123;</span><br><span class="line"></span><br><span class="line">    //注入</span><br><span class="line">    @Autowired</span><br><span class="line">    public UserService userService;</span><br><span class="line"></span><br><span class="line">    //查询总记录数</span><br><span class="line">    //执行的SQL为：SELECT COUNT( * ) FROM user</span><br><span class="line">    </span><br><span class="line">    long count = userService.count();</span><br><span class="line">    System.out.println(&quot;总记录数：&quot; + count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="批量新增"><a href="#批量新增" class="headerlink" title="批量新增"></a>批量新增</h4><p>Mapper中不支持批量添加，Mapper实现的是最简单的那些SQL语句</p><p>批量添加在service中实现，service中有<code>savebatch</code>方法实现批量添加，这个方法的形参是一个集合，集合中的每一个实体类对象就是一个添加的数据</p><p>调用方法：<code>boolean saveBatch(Collection entityList);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;User&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;咕哒子&quot;</span>+i);</span><br><span class="line">        user.setAge(<span class="number">20</span>+i);</span><br><span class="line">        list.add(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> userService.saveBatch(list);</span><br><span class="line">    System.out.println(b ? <span class="string">&quot;添加成功！&quot;</span> : <span class="string">&quot;添加失败！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h3><p>IService中还提供了Lambda功能来简化我们的复杂查询及更新功能</p><h2 id="条件构造器Wrapper"><a href="#条件构造器Wrapper" class="headerlink" title="条件构造器Wrapper"></a>条件构造器Wrapper</h2><p>SQL语句可以拆分成三部分：</p><ol><li>前面的动作</li><li>中间的范围</li><li>后面的条件</li></ol><p>Wrapper就是确定条件的java语句</p><p>前面的案例中都是以id为条件的简单CRUD，一些复杂条件的SQL语句就要用到写sql语句了，可以直接写sql语句，或者用Wrapper使用链式方法实现</p><p>除了新增以外，修改、删除、查询的SQL语句都需要指定where条件。因此BaseMapper中提供的相关方法除了以<code>id</code>作为<code>where</code>条件以外，还支持更加复杂的<code>where</code>条件</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231204141622045.png" alt="image-20231204141622045"></p><h3 id="Wrapper家系"><a href="#Wrapper家系" class="headerlink" title="Wrapper家系"></a>Wrapper家系</h3><p><code>Wrapper</code> ： 条件构造抽象类，最顶端父类</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20220521092812125.png" alt="image-20220521092812125"></p><p><code>AbstractWrapper </code>： 用于查询条件封装，生成 sql 的 where 条件，提供了where中包含的所有条件构造方法：</p><ul><li><p><code>QueryWrapper </code>： 查询条件封装</p></li><li><p><code>UpdateWrapper </code>： Update 条件封装</p></li><li><p><code>AbstractLambdaWrapper </code>： 使用Lambda 语法的<code>AbstractWrapper </code>接口</p></li><li><p><code>LambdaQueryWrapper </code>：用Lambda语法使用的查询Wrapper</p></li><li><p><code>LambdaUpdateWrapper </code>：用Lambda 更新封装Wrapper</p></li></ul><h3 id="QueryWrapper"><a href="#QueryWrapper" class="headerlink" title="QueryWrapper"></a>QueryWrapper</h3><p>QueryWrapper在AbstractWrapper的基础上拓展了一个select方法，允许指定查询字段</p><div class="tabs" id=""><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#-1">查询</button></li><li class="tab"><button type="button" data-href="#-2">更新</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="-1"><p>查询出名字中带<code>o</code>的，存款大于等于1000元的人。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testQueryWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.构建查询条件 where name like &quot;%o%&quot; AND balance &gt;= 1000</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;()</span><br><span class="line">            .select(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;username&quot;</span>, <span class="string">&quot;info&quot;</span>, <span class="string">&quot;balance&quot;</span>)</span><br><span class="line">            .like(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;o&quot;</span>)</span><br><span class="line">            .ge(<span class="string">&quot;balance&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 2.查询数据</span></span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-2"><p>更新用户名为jack的用户的余额为2000，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUpdateByQueryWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.构建查询条件 where name = &quot;Jack&quot;</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;().eq(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.更新数据，user中非null字段都会作为set语句</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setBalance(<span class="number">2000</span>);</span><br><span class="line">    userMapper.update(user, wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="UpdateWrapper"><a href="#UpdateWrapper" class="headerlink" title="UpdateWrapper"></a>UpdateWrapper</h3><p>基于BaseMapper中的update方法更新时只能直接赋值，对于一些复杂的需求就难以实现。</p><p>例如：更新id为<code>1,2,4</code>的用户的余额，扣200，对应的SQL应该是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">200</span> <span class="keyword">WHERE</span> id <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>SET的赋值结果是基于字段现有值的，这个时候就要利用UpdateWrapper中的setSql功能了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUpdateWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Long&gt; ids = List.of(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">4L</span>);</span><br><span class="line">    <span class="comment">// 1.生成SQL</span></span><br><span class="line">    UpdateWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;User&gt;()</span><br><span class="line">            .setSql(<span class="string">&quot;balance = balance - 200&quot;</span>) <span class="comment">// SET balance = balance - 200</span></span><br><span class="line">            .in(<span class="string">&quot;id&quot;</span>, ids); <span class="comment">// WHERE id in (1, 2, 4)</span></span><br><span class="line">        <span class="comment">// 2.更新，注意第一个参数可以给null，也就是不填更新字段和数据，</span></span><br><span class="line">    <span class="comment">// 而是基于UpdateWrapper中的setSQL来更新</span></span><br><span class="line">    userMapper.update(<span class="literal">null</span>, wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LambdaQueryWrapper"><a href="#LambdaQueryWrapper" class="headerlink" title="LambdaQueryWrapper"></a><strong>LambdaQueryWrapper</strong></h3><p>无论是QueryWrapper还是UpdateWrapper在构造条件的时候都需要写死字段名称，会出现字符串<code>魔法值</code>。这在编程规范中显然是不推荐的。 那怎么样才能不写字段名，又能知道字段名呢？</p><p>其中一种办法是基于变量的<code>gettter</code>方法结合反射技术。因此我们只要将条件对应的字段的<code>getter</code>方法传递给MybatisPlus，它就能计算出对应的变量名了。而传递方法可以使用JDK8中的<code>方法引用</code>和<code>Lambda</code>表达式。 因此MybatisPlus又提供了一套基于Lambda的Wrapper，包含两个：</p><ul><li>LambdaQueryWrapper</li><li>LambdaUpdateWrapper</li></ul><p>分别对应QueryWrapper和UpdateWrapper</p><p>其使用方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testLambdaQueryWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.构建条件 WHERE username LIKE &quot;%o%&quot; AND balance &gt;= 1000</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    wrapper.lambda()</span><br><span class="line">            .select(User::getId, User::getUsername, User::getInfo, User::getBalance)</span><br><span class="line">            .like(User::getUsername, <span class="string">&quot;o&quot;</span>)</span><br><span class="line">            .ge(User::getBalance, <span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 2.查询</span></span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义SQL"><a href="#自定义SQL" class="headerlink" title="自定义SQL"></a>自定义SQL</h2><p>MyBatisPlus增强了MyBatis，没有削减起功能，MyBatisPlus也支持手写SQL</p><ol><li><p>创建映射文件：</p><p>有了Mapper接口后，根据MyBatis，创建mapper文件就能在文件里面自定义SQL语句了，MyBatis时，文件路径有要求</p><p>而mapper文件的读取地址可以自己配置：默认值是<code>classpath*:/mapper/**/*.xml</code>，也可以改位置</p><blockquote><p>注意中间的**，resouces下的mapper里面都是</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">&quot;classpath*:/mapper/**/*.xml&quot;</span> <span class="comment"># Mapper.xml文件地址，当前这个是默认值。</span></span><br></pre></td></tr></table></figure></li></ol><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231213160652385.png" alt="image-20231213160652385"></p><ol start="2"><li><p>编写SQL</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org/DTD Mapper 3.0&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.cy.mybatis.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--自定义SQL--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--自定义SQL--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--自定义SQL--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="MybatisPlus中的使用"><a href="#MybatisPlus中的使用" class="headerlink" title="MybatisPlus中的使用"></a>MybatisPlus中的使用</h3><p>在演示UpdateWrapper的案例中，我们在代码中编写了更新的SQL语句<code>setSql(&quot;balance = balance - 200&quot;)</code></p><p>这种写法在某些企业也是不允许的，因为SQL语句最好都维护在持久层，而不是业务层。就当前案例来说，由于条件是in语句，只能将SQL写在Mapper.xml文件，利用foreach来生成动态SQL。</p><p>MybatisPlus提供了自定义SQL功能，可以让我们利用Wrapper生成查询条件，再结合Mapper.xml编写SQL</p><h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><p>还是前面的案例</p><ol><li><p>用wrapper制作查询范围</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCustomWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.准备自定义查询条件</span></span><br><span class="line">    List&lt;Long&gt; ids = List.of(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">4L</span>);</span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;().in(<span class="string">&quot;id&quot;</span>, ids);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.调用mapper的自定义方法，直接传递Wrapper</span></span><br><span class="line">    userMapper.deductBalanceByIds(<span class="number">200</span>, wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后在UserMapper中自定义SQL，通过wrapper对象调用SQL方法，传递参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;UPDATE user SET balance = balance - #&#123;money&#125; $&#123;ew.customSqlSegment&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deductBalanceByIds</span><span class="params">(<span class="meta">@Param(&quot;money&quot;)</span> <span class="type">int</span> money, <span class="meta">@Param(&quot;ew&quot;)</span> QueryWrapper&lt;User&gt; wrapper)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="主键策略"><a href="#主键策略" class="headerlink" title="主键策略"></a>主键策略</h2><h2 id="自定义ID生成器"><a href="#自定义ID生成器" class="headerlink" title="自定义ID生成器"></a>自定义ID生成器</h2><h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><h2 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h2><p>对于一些比较重要的数据，我们往往会采用逻辑删除的方案，即：</p><ul><li>在表中添加一个字段标记数据是否被删除</li><li>当删除数据时把标记置为true</li><li>查询时过滤掉标记为true的数据</li></ul><p>一旦采用了逻辑删除，所有的查询和删除逻辑都要跟着变化，非常麻烦。但<code>MybatisPlus</code>添加了对逻辑删除的支持。</p><blockquote><p>只有MybatisPlus生成的SQL语句才支持自动的逻辑删除，自定义SQL需要自己手动处理逻辑删除。</p></blockquote><p>开启了逻辑删除功能并配置完成以后，基本不用考虑代码逻辑问题，像普通删除一样做CRUD。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="编写"><a href="#编写" class="headerlink" title="编写"></a>编写</h4><ol><li><p>给<code>address</code>表添加一个逻辑删除字段：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> address <span class="keyword">add</span> deleted bit <span class="keyword">default</span> b<span class="string">&#x27;0&#x27;</span> <span class="keyword">null</span> comment <span class="string">&#x27;逻辑删除&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>给<code>Address</code>实体添加<code>deleted</code>字段：</p></li><li><p>在<code>application.yml</code>中配置逻辑删除字段：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">logic-delete-field:</span> <span class="string">deleted</span> <span class="comment"># 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span> <span class="comment"># 逻辑已删除值(默认为 1)</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span> <span class="comment"># 逻辑未删除值(默认为 0)</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h4><ol><li><p>执行删除操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDeleteByLogic</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 删除方法与以前没有区别</span></span><br><span class="line">    addressService.removeById(<span class="number">59L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查看日志</p><p>方法与普通删除一模一样，但是底层的SQL逻辑变了：</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231213165425661.png" alt="image-20231213165425661"></p></li><li><p>执行查询操作验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testQuery</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Address&gt; list = addressService.list();</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>id为59没有查询出来，而且SQL中也对逻辑删除字段做了判断：</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231213165535353.png" alt="image-20231213165535353"></p></li></ol><h2 id="静态工具"><a href="#静态工具" class="headerlink" title="静态工具"></a>静态工具</h2><p>有的时候Service之间也会相互调用，为了避免出现循环依赖问题，MybatisPlus提供一个静态工具类：<code>Db</code>，其中的一些静态方法与<code>IService</code>中方法签名基本一致，也可以帮助我们实现CRUD功能：</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231213165737883.png" alt="image-20231213165737883"></p><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><h2 id="通用枚举"><a href="#通用枚举" class="headerlink" title="通用枚举"></a>通用枚举</h2><h2 id="JSON类型处理器"><a href="#JSON类型处理器" class="headerlink" title="JSON类型处理器"></a>JSON类型处理器</h2><p>数据库的user表中有一个<code>info</code>字段，是JSON类型，格式像这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span> <span class="attr">&quot;intro&quot;</span><span class="punctuation">:</span> <span class="string">&quot;佛系青年&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;male&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>而目前<code>User</code>实体类中却是<code>String</code>类型</p><p>这样一来，我们要读取info中的属性时就非常不方便。如果要方便获取，info的类型最好是一个<code>Map</code>或者实体类。</p><p>而一旦我们把<code>info</code>改为<code>对象</code>类型，就需要在写入数据库时手动转为<code>String</code>，再读取数据库时，手动转换为<code>对象</code>，这会非常麻烦。</p><p>因此MybatisPlus提供了很多特殊类型字段的类型处理器，解决特殊字段类型与数据库类型转换的问题。例如处理JSON就可以使用<code>JacksonTypeHandler</code>处理器。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li><p>定义实体</p><p>定义一个单独实体类来与info字段的属性匹配</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.mp.domain.po;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String intro;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用类型处理器</p><p>接下来，将User类的info字段修改为UserInfo类型，并声明类型处理器：</p></li><li><p>同时，为了让页面返回的结果也以对象格式返回，我们要修改UserVO中的info字段</p></li></ol><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><h2 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h2><h2 id="1-分页插件"><a href="#1-分页插件" class="headerlink" title="1.分页插件"></a>1.分页插件</h2><blockquote><p>MyBatis Plus自带分页插件，只要简单的配置即可实现分页功能</p></blockquote><ul><li><p>添加配置类<code>MyBatisPlusConfig</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.atguigu.mybatisplus.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisPlusConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">//添加分页插件</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPage</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//new Page()中的两个参数分别是当前页码，每页显示数量</span></span><br><span class="line">    Page&lt;User&gt; page = userMapper.selectPage(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>,  <span class="number">2</span>),  <span class="literal">null</span>);</span><br><span class="line">    List&lt;User&gt; users = page.getRecords();</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-自定义分页"><a href="#2-自定义分页" class="headerlink" title="2.自定义分页"></a>2.自定义分页</h2><blockquote><p>上面调用的是MyBatis-Plus提供的带有分页的方法，那么我们自己定义的方法如何实现分页呢？</p></blockquote><ul><li><p>在<code>UserMapper</code>接口中定义一个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line">  * 根据年龄查询用户列表，分页显示 </span><br><span class="line">  * <span class="meta">@param</span> page 分页对象, xml中可以从里面进行取值, 传递参数 Page 即自动分页, 必须放在第一位 </span><br><span class="line">  * <span class="meta">@param</span> age 年龄 </span><br><span class="line">  * <span class="meta">@return</span> </span><br><span class="line">  */</span><br><span class="line">Page&lt;User&gt; <span class="title function_">selectPageVo</span><span class="params">(<span class="meta">@Param(&quot;page&quot;)</span> Page&lt;User&gt; page, <span class="meta">@Param(&quot;age&quot;)</span> Integer age)</span>;</span><br></pre></td></tr></table></figure></li><li><p>在<code>UserMapper.xml</code>中编写SQL实现该方法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectPageVo&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    select id, username as name, age, email from t_user where age &gt; #&#123;age&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPageVo</span><span class="params">()</span>&#123;</span><br><span class="line">    Page&lt;User&gt; page = userMapper.selectPageVo(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;User&gt;(<span class="number">1</span>, <span class="number">2</span>),  <span class="number">20</span>);</span><br><span class="line">    List&lt;User&gt; users = page.getRecords();</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-乐观锁"><a href="#3-乐观锁" class="headerlink" title="3.乐观锁"></a>3.乐观锁</h2><blockquote><p>作用：当要更新一条记录的时候，希望这条记录没有被别人更新</p></blockquote><p>乐观锁的实现方式：</p><ul><li>取出记录时，获取当前 version</li><li>更新时，带上这个 version</li><li>执行更新时， set version &#x3D; newVersion where version &#x3D; oldVersion</li><li>如果 version 不对，就更新失败</li></ul><h3 id="3-1场景"><a href="#3-1场景" class="headerlink" title="3.1场景"></a>3.1场景</h3><hr><ul><li>一件商品，成本价是80元，售价是100元。老板先是通知小李，说你去把商品价格增加50元。小李正在玩游戏，耽搁了一个小时。正好一个小时后，老板觉得商品价格增加到150元，价格太高，可能会影响销量。又通知小王，你把商品价格降低30元。</li><li>此时，小李和小王同时操作商品后台系统。小李操作的时候，系统先取出商品价格100元；小王也在操作，取出的商品价格也是100元。小李将价格加了50元，并将100+50&#x3D;150元存入了数据库；小王将商品减了30元，并将100-30&#x3D;70元存入了数据库。是的，如果没有锁，小李的操作就完全被小王的覆盖了。</li><li>现在商品价格是70元，比成本价低10元。几分钟后，这个商品很快出售了1千多件商品，老板亏1万多。</li></ul><h3 id="3-2乐观锁与悲观锁"><a href="#3-2乐观锁与悲观锁" class="headerlink" title="3.2乐观锁与悲观锁"></a>3.2乐观锁与悲观锁</h3><hr><ul><li>上面的故事，如果是乐观锁，小王保存价格前，会检查下价格是否被人修改过了。如果被修改过了，则重新取出的被修改后的价格，150元，这样他会将120元存入数据库。</li><li>如果是悲观锁，小李取出数据后，小王只能等小李操作完之后，才能对价格进行操作，也会保证最终的价格是120元。</li></ul><h3 id="3-3模拟修改冲突"><a href="#3-3模拟修改冲突" class="headerlink" title="3.3模拟修改冲突"></a>3.3模拟修改冲突</h3><hr><ul><li><p>数据库中增加商品表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_product ( </span><br><span class="line">    id <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主键ID&#x27;</span>,  </span><br><span class="line">    NAME <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品名称&#x27;</span>,  </span><br><span class="line">    price <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;价格&#x27;</span>,  </span><br><span class="line">    VERSION <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;乐观锁版本号&#x27;</span>,  </span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id) </span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>添加一条数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_product (id,  NAME,  price) <span class="keyword">VALUES</span> (<span class="number">1</span>,  <span class="string">&#x27;外星人笔记本&#x27;</span>,  <span class="number">100</span>);</span><br></pre></td></tr></table></figure></li><li><p>添加一个实体类<code>Product</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="keyword">private</span> Integer version;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加一个Mapper接口<code>ProductMapper</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Product&gt; &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testProduct01</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.小李获取商品价格</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">productLi</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;小李获取的商品价格为：&quot;</span> + productLi.getPrice());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.小王获取商品价格</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">productWang</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;小李获取的商品价格为：&quot;</span> + productWang.getPrice());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.小李修改商品价格+50</span></span><br><span class="line">    productLi.setPrice(productLi.getPrice()+<span class="number">50</span>);</span><br><span class="line">    productMapper.updateById(productLi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.小王修改商品价格-30</span></span><br><span class="line">    productWang.setPrice(productWang.getPrice()-<span class="number">30</span>);</span><br><span class="line">    productMapper.updateById(productWang);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.老板查询商品价格</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">productBoss</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;老板获取的商品价格为：&quot;</span> + productBoss.getPrice());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-4乐观锁解决问题"><a href="#3-4乐观锁解决问题" class="headerlink" title="3.4乐观锁解决问题"></a>3.4乐观锁解决问题</h3><hr><ul><li><p>实体类<code>version</code>字段添加注解<code>@Version</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="meta">@Version</span></span><br><span class="line">    <span class="keyword">private</span> Integer version;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加乐观锁插件配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">    <span class="comment">//添加分页插件</span></span><br><span class="line">    interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">    <span class="comment">//添加乐观锁插件</span></span><br><span class="line">    interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());</span><br><span class="line">    <span class="keyword">return</span> interceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>再次执行测试方法</p><blockquote><p>小李查询商品信息：</p><p>​SELECT id, name, price, version FROM t_product WHERE id&#x3D;?</p><p>小王查询商品信息：</p><p>​SELECT id, name, price, version FROM t_product WHERE id&#x3D;?</p><p>小李修改商品价格，自动将version+1</p><p>​UPDATE t_product SET name&#x3D;?,  price&#x3D;?,  version&#x3D;? WHERE id&#x3D;? AND version&#x3D;?</p><p>​Parameters: 外星人笔记本(String),  150(Integer),  1(Integer),  1(Long),  0(Integer)</p><p>小王修改商品价格，此时version已更新，条件不成立，修改失败</p><p>​UPDATE t_product SET name&#x3D;?,  price&#x3D;?,  version&#x3D;? WHERE id&#x3D;? AND version&#x3D;?</p><p>​Parameters: 外星人笔记本(String),  70(Integer),  1(Integer),  1(Long),  0(Integer)</p><p>最终，小王修改失败，查询价格：150</p><p>​SELECT id, name, price, version FROM t_product WHERE id&#x3D;?</p></blockquote></li><li><p>优化执行流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testProduct01</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.小李获取商品价格</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">productLi</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;小李获取的商品价格为：&quot;</span> + productLi.getPrice());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.小王获取商品价格</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">productWang</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;小李获取的商品价格为：&quot;</span> + productWang.getPrice());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.小李修改商品价格+50</span></span><br><span class="line">    productLi.setPrice(productLi.getPrice()+<span class="number">50</span>);</span><br><span class="line">    productMapper.updateById(productLi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.小王修改商品价格-30</span></span><br><span class="line">    productWang.setPrice(productWang.getPrice()-<span class="number">30</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> productMapper.updateById(productWang);</span><br><span class="line">    <span class="keyword">if</span>(result == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//操作失败，重试</span></span><br><span class="line">        <span class="type">Product</span> <span class="variable">productNew</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1</span>);</span><br><span class="line">        productNew.setPrice(productNew.getPrice()-<span class="number">30</span>);</span><br><span class="line">        productMapper.updateById(productNew);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.老板查询商品价格</span></span><br><span class="line">    <span class="type">Product</span> <span class="variable">productBoss</span> <span class="operator">=</span> productMapper.selectById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;老板获取的商品价格为：&quot;</span> + productBoss.getPrice());</span><br><span class="line">&#125;<span class="number">11</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="通用枚举-1"><a href="#通用枚举-1" class="headerlink" title="通用枚举"></a>通用枚举</h2><blockquote><p>表中的有些字段值是固定的，例如性别（男或女），此时我们可以使用MyBatis-Plus的通用枚举来实现</p></blockquote><ul><li><p>数据库表添加字段<code>sex</code></p></li><li><p>创建通用枚举类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SexEnum</span> &#123;</span><br><span class="line">    MALE(<span class="number">1</span>,  <span class="string">&quot;男&quot;</span>), </span><br><span class="line">    FEMALE(<span class="number">2</span>,  <span class="string">&quot;女&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EnumValue</span> <span class="comment">//将注解所标识的属性的值存储到数据库中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> sex;</span><br><span class="line">    <span class="keyword">private</span> String sexName;</span><br><span class="line"></span><br><span class="line">    SexEnum(Integer sex,  String sexName) &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">        <span class="built_in">this</span>.sexName = sexName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>User实体类中添加属性sex</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@TableField(&quot;username&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TableLogic</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> isDeleted;  <span class="comment">//逻辑删除</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SexEnum sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置扫描通用枚举</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#MyBatis-Plus相关配置</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="comment">#指定mapper文件所在的地址</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment">#配置日志</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">banner:</span> <span class="string">off</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="comment">#配置mp的主键策略为自增</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br><span class="line">      <span class="comment"># 设置实体类所对应的表的统一前缀</span></span><br><span class="line">      <span class="attr">table-prefix:</span> <span class="string">t_</span></span><br><span class="line">  <span class="comment">#配置类型别名所对应的包</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.atguigu.mybatisplus.pojo</span></span><br><span class="line">  <span class="comment"># 扫描通用枚举的包</span></span><br><span class="line">  <span class="attr">type-enums-package:</span> <span class="string">com.atguigu.mybatisplus.enums</span></span><br></pre></td></tr></table></figure></li><li><p>执行测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">33</span>);</span><br><span class="line">    user.setSex(SexEnum.MALE);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.insert(user);</span><br><span class="line">    System.out.println(<span class="string">&quot;result:&quot;</span>+result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="多数据源"><a href="#多数据源" class="headerlink" title="多数据源"></a>多数据源</h2><blockquote><p>适用于多种场景：纯粹多库、 读写分离、 一主多从、 混合模式等</p></blockquote><p>场景说明：</p><p>我们创建两个库，分别为：<code>mybatis_plus</code>（以前的库不动）与<code>mybatis_plus_1</code>（新建），将mybatis_plus库的<code>product</code>表移动到mybatis_plus_1库，这样每个库一张表，通过一个测试用例分别获取用户数据与商品数据，如果获取到说明多库模拟成功</p><h2 id="1-创建数据库及表"><a href="#1-创建数据库及表" class="headerlink" title="1.创建数据库及表"></a>1.创建数据库及表</h2><ul><li><p>创建数据库<code>mybatis_plus_1</code>和表&#96;product</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE `mybatis_plus_1` <span class="comment">/*!40100 DEFAULT CHARACTER SET utf8mb4 */</span>;</span><br><span class="line">use `mybatis_plus_1`; </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> product ( </span><br><span class="line">    id <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主键ID&#x27;</span>,  </span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品名称&#x27;</span>,  </span><br><span class="line">    price <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;价格&#x27;</span>,  </span><br><span class="line">    version <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;乐观锁版本号&#x27;</span>,  </span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id) </span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>添加测试数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product (id,  NAME,  price) <span class="keyword">VALUES</span> (<span class="number">1</span>,  <span class="string">&#x27;外星人笔记本&#x27;</span>,  <span class="number">100</span>);</span><br></pre></td></tr></table></figure></li><li><p>删除<code>mybatis_plus</code>库中的<code>product</code>表 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use mybatis_plus; </span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> product;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-新建工程引入依赖"><a href="#2-新建工程引入依赖" class="headerlink" title="2.新建工程引入依赖"></a>2.新建工程引入依赖</h2><blockquote><p>自行新建一个Spring Boot工程并选择MySQL驱动及Lombok依赖</p></blockquote><p>引入MyBaits-Plus的依赖及多数据源的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dynamic-datasource-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-编写配置文件"><a href="#3-编写配置文件" class="headerlink" title="3.编写配置文件"></a>3.编写配置文件</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># 配置数据源信息</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">dynamic:</span></span><br><span class="line">      <span class="comment"># 设置默认的数据源或者数据源组, 默认值即为master</span></span><br><span class="line">      <span class="attr">primary:</span> <span class="string">master</span></span><br><span class="line">      <span class="comment"># 严格匹配数据源, 默认false.true未匹配到指定数据源时抛异常, false使用默认数据源</span></span><br><span class="line">      <span class="attr">strict:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">master:</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">          <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">          <span class="attr">password:</span> <span class="number">132537</span></span><br><span class="line">        <span class="attr">slave_1:</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatis_plus_1?characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">          <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">          <span class="attr">password:</span> <span class="number">132537</span></span><br></pre></td></tr></table></figure><h2 id="4-创建实体类"><a href="#4-创建实体类" class="headerlink" title="4.创建实体类"></a>4.创建实体类</h2><ul><li><p>新建一个<code>User</code>实体类（如果数据库表名有t_前缀记得配置）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>新建一个实体类<code>Product</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="keyword">private</span> Integer version;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-创建Mapper及Service"><a href="#5-创建Mapper及Service" class="headerlink" title="5.创建Mapper及Service"></a>5.创建Mapper及Service</h2><ul><li><p>新建接口<code>UserMapper</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>新建接口<code>ProductMapper</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Product&gt; &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>新建Service接口<code>UserService</code>指定操作的数据源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DS(&quot;master&quot;)</span> <span class="comment">//指定操作的数据源，master为user表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>新建Service接口<code>ProductService</code>指定操作的数据源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DS(&quot;slave_1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;Product&gt; &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>自行建立Service的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><h2 id="6-编写测试方法"><a href="#6-编写测试方法" class="headerlink" title="6.编写测试方法"></a>6.编写测试方法</h2><blockquote><p>记得在启动类中添加注解<code>@MapperScan()</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestDatasourceApplicationTests</span> &#123;</span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line">UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line">ProductService productService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.getById(<span class="number">1L</span>);</span><br><span class="line"><span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> productService.getById(<span class="number">1L</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;User = &quot;</span> + user);</span><br><span class="line">System.out.println(<span class="string">&quot;Product = &quot;</span> + product);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MyBatisX插件"><a href="#MyBatisX插件" class="headerlink" title="MyBatisX插件"></a>MyBatisX插件</h2><blockquote><p>MyBatis-Plus为我们提供了强大的mapper和service模板，能够大大的提高开发效率。</p><p>但是在真正开发过程中，MyBatis-Plus并不能为我们解决所有问题，例如一些复杂的SQL，多表联查，我们就需要自己去编写代码和SQL语句，我们该如何快速的解决这个问题呢，这个时候可以使用MyBatisX插件。</p><p>MyBatisX一款基于 IDEA 的快速开发插件，为效率而生。</p></blockquote><h2 id="1-安装MyBatisX插件"><a href="#1-安装MyBatisX插件" class="headerlink" title="1.安装MyBatisX插件"></a>1.安装MyBatisX插件</h2><blockquote><p>打开IDEA，File-&gt; Setteings-&gt;Plugins-&gt;MyBatisX，搜索栏搜索MyBatisX然后安装。</p></blockquote><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522115718361.png" alt="image-20220522115718361"></p><h2 id="2-快速生成代码"><a href="#2-快速生成代码" class="headerlink" title="2.快速生成代码"></a>2.快速生成代码</h2><ul><li><p>新建一个Spring Boot项目引入依赖（创建工程时记得勾选lombok及mysql驱动）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dynamic-datasource-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置数据源信息</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatis_plus?characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">132537</span></span><br></pre></td></tr></table></figure></li><li><p>在IDEA中与数据库建立链接</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522120758740.png" alt="image-20220522120758740"></p></li><li><p>填写数据库信息并保存</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522121434468.png" alt="image-20220522121434468"></p></li><li><p>找到我们需要生成的表点击右键</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522121613909.png" alt="image-20220522121613909"></p></li><li><p>填写完信息以后下一步</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522122127649.png" alt="image-20220522122127649"></p></li><li><p>继续填写信息</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522122525598.png" alt="image-20220522122525598"></p></li><li><p>大功告成（真特么好用yyds）</p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522122612334.png" alt="image-20220522122612334"></p></li></ul><h2 id="3-快速生成CRUD"><a href="#3-快速生成CRUD" class="headerlink" title="3.快速生成CRUD"></a>3.快速生成CRUD</h2><blockquote><p>MyBaitsX可以根据我们在Mapper接口中输入的方法名快速帮我们生成对应的sql语句</p></blockquote><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522123143852.png" alt="image-20220522123143852"></p><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/MyBatis-Plus/image-20220522123202310.png" alt="image-20220522123202310"></p><h1 id="待解决问题"><a href="#待解决问题" class="headerlink" title="待解决问题"></a>待解决问题</h1><p>sqlsessionfactory没配啊，去哪了？<a href="https://blog.csdn.net/elvishehai/article/details/107565980">https://blog.csdn.net/elvishehai/article/details/107565980</a></p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MybatisPlus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-进程</title>
      <link href="/2023/10/22/Linux%E8%BF%9B%E7%A8%8B/"/>
      <url>/2023/10/22/Linux%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><ol><li><p>在LINUX中 ，每个执行的程都称为个进程。每个进程都分配一个ID号(pid,进程号)。</p><p>windows 都一样 Linux</p></li><li><p>每个进程都可能以两种方式存在的：前台与后台</p><p>前台进程就是用户目前的屏幕上可以进行操作的。</p><p>后台进程则是实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行。</p></li><li><p>一般系统的服务都是以后台进程的方式存在,而且都会常驻在系统中。直到关机才才结束。</p></li></ol><h2 id="显示系统执行的进程"><a href="#显示系统执行的进程" class="headerlink" title="显示系统执行的进程"></a>显示系统执行的进程</h2><p>ps命令是用来查看目前系统中,有哪些正在执行,以及它们执行的状况。可以不加任何参数，</p><p>常用参数：</p><ul><li>-a:显示当前终端的所有进程信息</li><li>-u:以用户的格式显示进程信息</li><li>-x:显示后台进程运行的参数</li></ul><p>查询结果：</p><ul><li>System V展示风格</li><li>USER :用户名称</li><li>PID :进程号</li><li>%CPU :进程占用CPU的百分比</li><li>%MEM :进程占用物理内存的百分比</li><li>VSZ :进程占用的虚拟内存大小(单位: KB )</li><li>RSS ;进程占用的物理内存大小(单位; KB )</li><li>Tt :终端名称，缩写.</li><li>STAT :进程状态，其中S睡眠，s-表示该进程是会话的先导进程, N-表示进程拥有比普通优先级更低的优先级，R-正在运行，D-短期等待，Z-僵死进程, T-被跟踪或者被停止等等</li><li>STARTED :进程的启动时间</li><li>TIME : CPU时间，即进程使用CPU的总时间</li><li>COMMAND :启动进程所用的命令和参教如果过长会波裁斯显示</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot-基本使用</title>
      <link href="/2023/10/21/SpringBoot%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/10/21/SpringBoot%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="打包与运行"><a href="#打包与运行" class="headerlink" title="打包与运行"></a>打包与运行</h1><p>写程序是在Idea下写的，运行也是在Idea下运行的，此时大概率是window系统。</p><p>上线后，程序是运行在专用的服务器上的，简单说就是将你做的程序放在一台独立运行的电脑上，此时一定是Linux系统。</p><p>程序需要打包后上传至Linux服务器运行，我们的程序要先组织成一个文件，然后将这个文件传输到这台服务器上。这里面就存在两个过程，一个是打包的过程，另一个是运行的过程</p><h2 id="程序打包"><a href="#程序打包" class="headerlink" title="程序打包"></a>程序打包</h2><p>SpringBoot程序是基于Maven创建的，在Maven中提供有打包的指令，叫做package。本操作可以在Idea环境下执行<code>mvn package</code></p><p>打包后会产生一个与工程名类似的jar文件，其名称是由模块名+版本号+.jar组成的</p><h2 id="程序运行"><a href="#程序运行" class="headerlink" title="程序运行"></a>程序运行</h2><p>程序包打好以后，就可以直接执行了。</p><p>用cmd，在程序包所在路径下，执行指令<code>java -jar 工程包名.jar</code></p><p>执行程序打包指令后，程序正常运行，与在Idea下执行程序没有区别，SpringBoot的jar包是fat jar，打包时一起把运行要依赖的东西以前打包了</p><p>而且，fat jar可以用命令行改变一些配置，再运行，比如更换端口号，有相应的命令</p><p><font color="#ff0000"><b>特别关注</b></font>：在使用向导创建SpringBoot工程时，pom.xml文件中会有如下配置，这一段配置千万不能删除，否则打包后无法正常执行程序。有了这插件，就能在</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="打包失败处理"><a href="#打包失败处理" class="headerlink" title="打包失败处理"></a>打包失败处理</h2><p>打包以后执行会出现一些问题，导致程序无法正常执行，例如下面的现象</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231122191537268.png" alt="image-20231122191537268"></p><p>mysql的驱动jar包和上面我们程序打包后得到的都是一个jar文件，如果你使用上面的java -jar指令去执行mysql的驱动jar包就会出现上述不可执行的现象，而SpringBoot项目就能执行。因为打包方式不一样。</p><p>在SpringBoot工程的pom.xml中有前面提到的创建，这组配置决定了打包出来的程序包是否可以执行。</p><p>分别开启这段配置和注释掉这段配置分别执行两次打包，然后观察两次打包后的程序包的差别，共有3处比较明显的特征</p><ul><li>打包后文件的大小不同</li><li>打包后所包含的内容不同</li><li>打包程序中个别文件内容不同</li></ul><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231122191732171.png" alt="image-20231122191732171"></p><p>带有配置的程序包体积比不带配置的大了30倍</p><p>内容也完全不一样，仅有一个目录是一样的，叫做META-INF。</p><p>打开容量大的程序包中的BOOT-INF目录下的classes目录，其中的内容居然和容量小的程序包中的内容完全一样。也就是小jar包</p><p>多的东西是当前工程运行需要使用的jar包，就是为了可以独立运行，不依赖程序包外部的任何资源可以独立运行当前程序。</p><h2 id="临时属性设置"><a href="#临时属性设置" class="headerlink" title="临时属性设置"></a>临时属性设置</h2><p>目前我们的程序包打好了，可以发布了。但是程序包打好以后，里面的配置都已经是固定的了，比如配置了服务器的端口是8080。不能写死啊。</p><p>SpringBoot提供了灵活的配置方式，可以使用临时属性的方式快速修改某些配置，在启动的时候添加上对应参数就可以了。如，修改端口</p><p>多出来的部分：<code>–-server.port=80</code></p><p>整体：<code>java –jar springboot.jar –-server.port=80</code></p><p>上面的命令是启动SpringBoot程序包的命令，在命令输入完毕后，空一格，然后输入两个<code>-</code>号。按照属性名&#x3D;属性值的形式添加对应参数，当属性存在多级名称时，中间使用点分隔，和properties文件中的属性格式完全相同</p><p>要修改的属性不止一个，可以按照上述格式继续写，属性与属性之间使用空格分隔。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java –jar springboot.jar –-server.port=<span class="number">80</span> --logging.level.root=debug</span><br></pre></td></tr></table></figure><h3 id="属性加载优先级"><a href="#属性加载优先级" class="headerlink" title="属性加载优先级"></a>属性加载优先级</h3><p>打开官方文档，可以查看配置读取的优先顺序。<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html">官网</a></p><p>里面数字是权重，数字越大，优先级越高</p><p>一般：</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231122193650670.png" alt="image-20231122193650670"></p><h3 id="开发环境中使用临时属性"><a href="#开发环境中使用临时属性" class="headerlink" title="开发环境中使用临时属性"></a>开发环境中使用临时属性</h3><p>临时使用目前是有了，但是上线的时候通过命令行输入的临时属性必须是正确的，换句话说，那这些属性配置值我们必须在开发环境中测试，指明没问题。</p><p>打开SpringBoot引导类的运行界面，在里面找到配置项。其中Program arguments对应的位置就是添加临时属性的</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231122212120499.png" alt="image-20231122212120499"></p><p>回忆java的main函数，运行main方法的时候，如果想使用main方法的参数，也就是下面的args参数，就是在上面这个位置添加的参数。通过这个args就可以获取到参数，再看看我们的引导类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SpringApplication.run(SSMPApplication.class,args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个args参数被传递给了run方法，Idea中配置的临时参数就是通过这个位置传递到我们的程序中的。所以，可以用引导类来配置临时参数，不将配置写在配置文件中，直接写成一个字符串数组，传递给程序入口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    String[] arg = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">1</span>];</span><br><span class="line">    arg[<span class="number">0</span>] = <span class="string">&quot;--server.port=8082&quot;</span>;</span><br><span class="line">    SpringApplication.run(SSMPApplication.class, arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置文件分类"><a href="#配置文件分类" class="headerlink" title="配置文件分类"></a>配置文件分类</h2><p>SpringBoot提供了配置文件和临时属性的方式来对程序进行配置。一共4个级别。</p><p>4个级别分别是：</p><ol><li><p>类路径下配置文件（一直使用的是这个，也就是resources目录中的application.yml文件）</p><p>classpath：application.yml </p></li><li><p>类路径下config目录下配置文件</p><p>classpath：config&#x2F;application.yml</p></li><li><p>程序包所在目录中配置文件</p><p>file ：application.yml</p></li><li><p>程序包所在目录中config目录下配置文件</p><p>file ：config&#x2F;application.yml</p></li></ol><p>高级的会覆盖低级的，但是运行的时候会扫描所有配置，换句话说，最低级的配置文件里面的配置可能会被覆盖掉，但是没被覆盖的会正常使用。4级配置可以用来保证安全性，比如最高级只有最高权限有，然后实现了最总的配置</p><p>优先级：</p><ol><li>同层中config文件夹中的大于直接写的yml</li><li>不同层中fat jar包中的配置大于项目jar包中的配置</li><li>不同层的情况优先考虑</li></ol><h2 id="自定义配置文件"><a href="#自定义配置文件" class="headerlink" title="自定义配置文件"></a>自定义配置文件</h2><p>之前做配置使用的配置文件都叫application.yml，其实这个文件也是可以改名字的，这样方便维护。</p><p>自定义配置文件方式有如下两种：</p><ol><li><p>使用临时属性设置配置文件名，注意仅仅是名称，不要带扩展名<code>spring.config.name</code></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231122215055428.png" alt="image-20231122215055428"></p></li><li><p>使用临时属性设置配置文件路径，这个是全路径名<code>spring.config.location</code></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231122215108260.png" alt="image-20231122215108260"></p></li></ol><p>使用的属性一个是spring.config.name，另一个是spring.config.location，这个一定要区别清楚</p><p>也可以设置加载多个配置文件，操作和以前一样，如果有重复项，最后一个生效</p><p>其实企业开发现在更多的是使用基于SpringCloud技术的多服务器项目。这种配置方式和我们现在学习的完全不一样，所有的服务器将不再设置自己的配置文件，而是通过配置中心获取配置，动态加载配置信息。集中管理。</p><h1 id="多环境开发"><a href="#多环境开发" class="headerlink" title="多环境开发"></a>多环境开发</h1><p>程序最终要放到服务器上去运行。每个计算机环境不一样，这就是多环境。</p><p>常见的多环境开发主要兼顾3种环境设置，</p><ol><li>开发环境——自己用的，</li><li>测试环境——自己公司用的，</li><li>生产环境——甲方爸爸用的。</li></ol><p>因为这是绝对不同的三台电脑，所以环境肯定有所不同，比如连接的数据库不一样，设置的访问端口不一样等等。</p><div class="tabs" id=""><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#-1">yaml单一文件版</button></li><li class="tab"><button type="button" data-href="#-2">yaml多文件版</button></li><li class="tab"><button type="button" data-href="#-3">properties多文件版</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="-1"><p>针对不同的环境设置不同的配置属性即可，中间使用三个减号分隔开不同环境，起名字区分不同环境，设置启动属性使用环境</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">profiles:</span></span><br><span class="line"><span class="attr">active:</span> <span class="string">pro</span><span class="comment">#选择使用</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">profiles:</span> <span class="string">pro</span>  <span class="comment">#取名，叫pro</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">profiles:</span> <span class="string">dev</span>  <span class="comment">#取名，叫dev</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">81</span></span><br></pre></td></tr></table></figure><p>关于环境名称定义上述格式是过时格式，但是能用，标准格式如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">config:</span></span><br><span class="line">    <span class="attr">activate:</span></span><br><span class="line">        <span class="attr">on-profile:</span> <span class="string">pro</span></span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><ol><li>多环境开发需要设置若干种常用环境，例如开发、生产、测试环境</li><li>yaml格式中设置多环境使用<code>---</code>区分环境设置边界</li><li>每种环境的区别在于加载的配置属性不同</li><li>启用某种环境时需要指定启动时使用该环境</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-2"><p>将一个配置文件拆分成多个配置文件的想法。拆分后，每个配置文件中写自己的配置，主配置文件中写清楚用哪一个配置文件就好了。</p><p>环境配置文件因为每一个都是配置自己的项，所以连名字都不用写里面了。使用文件名区分环境。</p><p>文件的命名规则为：application-环境名.yml</p><p><strong>主配置文件</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">profiles:</span></span><br><span class="line"><span class="attr">active:</span> <span class="string">pro</span><span class="comment"># 启动pro</span></span><br></pre></td></tr></table></figure><p><strong>环境配置文件</strong>：</p><p><strong>application-pro.yaml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p><strong>application-dev.yaml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">81</span></span><br></pre></td></tr></table></figure><p>在配置文件中，如果某些配置项所有环境都一样，可以将这些项写入到主配置中，只有哪些有区别的项才写入到环境配置文件中。</p><ul><li>主配置文件中设置公共配置（全局）</li><li>环境分类配置文件中常用于设置冲突属性（局部）</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-3"><p>SpringBoot最早期提供的配置文件格式是properties格式的，所以它肯定也有多环境配置，properties文件多环境配置仅支持多文件格式</p><p>文件的命名规则为：application-环境名.properties</p><p><strong>主配置文件</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.profiles.active</span>=<span class="string">pro</span></span><br></pre></td></tr></table></figure><p><strong>环境配置文件</strong></p><p><strong>application-pro.properties</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">80</span></span><br></pre></td></tr></table></figure><p><strong>application-dev.properties</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">81</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="多环境开发独立配置文件书写技巧"><a href="#多环境开发独立配置文件书写技巧" class="headerlink" title="多环境开发独立配置文件书写技巧"></a>多环境开发独立配置文件书写技巧</h2><p>基于多环境开发做配置独立管理，务必掌握</p><div class="tabs" id=""><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#-1">include</button></li><li class="tab"><button type="button" data-href="#-2">group</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="-1"><ol><li><p>将所有的配置根据功能对配置文件中的信息进行拆分，并制作成独立的配置文件，命名规则如下</p><ul><li>application.yml（这个是主配置）</li></ul><ul><li>application-devDB.yml</li><li>application-devRedis.yml</li><li>application-devMVC.yml</li></ul></li><li><p>使用include属性在激活指定环境的情况下，同时对多个环境进行加载使其生效，多个环境间使用逗号分隔，include属性只能使用一次</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">devDB,devRedis,devMVC</span></span><br></pre></td></tr></table></figure><p>现在相当于加载dev配置时，再加载对应的3组配置，从结构上就很清晰，用了什么，对应的名称是什么</p><p>当主环境dev与其他环境有相同属性时，主环境属性生效；其他环境中有相同属性时，最后加载的环境属性生效</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-2"><p>SpringBoot从2.4版开始使用group属性替代include属性，降低了配置书写量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">profiles:</span><br><span class="line">    active: dev</span><br><span class="line">        group:</span><br><span class="line">        &quot;dev&quot;: devDB,devRedis,devMVC</span><br><span class="line">      &quot;pro&quot;: proDB,proRedis,proMVC</span><br><span class="line">      &quot;test&quot;: testDB,testRedis,testMVC</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="多环境开发控制"><a href="#多环境开发控制" class="headerlink" title="多环境开发控制"></a>多环境开发控制</h2><p>还有一个冲突问题，maven和SpringBoot同时设置多环境的话怎么搞</p><p>要想处理这个冲突问题，你要先理清一个关系，究竟谁在多环境开发中其主导地位。也就是说如果现在都设置了多环境，谁的应该是保留下来的，另一个应该遵从相同的设置</p><p>maven是用来项目构建管理的，最终生成代码包的，SpringBoot是简化开发的。二者里面最终还是要靠maven来管理整个工程，所以SpringBoot应该听maven的。</p><p>大体思想如下：</p><ol><li><p>在maven环境中设置用什么具体的环境</p></li><li><p>在SpringBoot中读取maven设置的环境即可</p></li></ol><div class="tabs" id=""><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#-1">maven中设置多环境（使用属性方式区分环境）</button></li><li class="tab"><button type="button" data-href="#-2">SpringBoot中读取maven设置值</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="-1"><p>pom中配置对应的多环境开发，每个profile就是一个环境，要用id来区分</p><p>properties指出这个profile用的具体属性，具体属性的名字不重要，叫profile.active是为了见名知义，属性的值指出使用的属性，不同环境真正的区别是里面配置的属性</p><p>activation指明默认启动环境</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    //第一个环境</span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        //名字</span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>env_dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        //具体属性</span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">profile.active</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">profile.active</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">        //设置默认启动环境</span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span><span class="comment">&lt;!--默认启动环境--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    //第二个环境</span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>env_pro<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">profile.active</span>&gt;</span>pro<span class="tag">&lt;/<span class="name">profile.active</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-2"><p>SpringBoot这边使用时用<code>@名字@</code>指定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">profiles:</span><br><span class="line">    active: @profile.active@</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>这节没看懂，后续要复习</p><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>日志其实就是记录程序日常运行的信息，主要作用如下：</p><ul><li>编程期调试代码</li><li>运营期记录信息</li><li>记录日常运营重要信息（峰值流量、平均响应时长……）</li><li>记录应用报错信息（错误堆栈）</li><li>记录运维过程数据（扩容、宕机、报警……）</li></ul><h2 id="使用日志工具记录日志"><a href="#使用日志工具记录日志" class="headerlink" title="使用日志工具记录日志"></a>使用日志工具记录日志</h2><ol><li><p>添加日志记录操作</p><p>创建日志类对象，然后调用相应api</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/books&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> <span class="keyword">extends</span> <span class="title class_">BaseClass</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(BookController.class);</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getById</span><span class="params">()</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;debug...&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;info...&quot;</span>);</span><br><span class="line">        log.warn(<span class="string">&quot;warn...&quot;</span>);</span><br><span class="line">        log.error(<span class="string">&quot;error...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;springboot is running...2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中log对象就是用来记录日志的对象，下面的log.debug，log.info这些操作就是写日志的API</p></li><li><p>设置日志输出级别</p><p>日志设置好以后可以根据设置选择哪些参与记录。这里是根据日志的级别来设置的。日志的级别分为6种，实际上用4种，分别是：</p><ul><li>TRACE：运行堆栈信息，基本不用</li><li>DEBUG：程序员调试代码使用</li><li>INFO：记录运维过程数据</li><li>WARN：记录运维过程报警数据</li><li>ERROR：记录错误堆栈信息</li><li>FATAL：灾难信息，合并计入ERROR</li></ul><p>一般情况下，开发时候使用DEBUG，上线后使用INFO，运维信息记录使用WARN即可</p><p>日志系统通常都提供了细粒度的控制，默认使用info级别，只显示info及以上的日志。</p><p>设置日志级别，有三种方法</p><ol><li><p>在Program arguements里面设置属性<code>--debug</code></p></li><li><p>在yml文件中配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启debug模式，输出调试信息，常用于检查系统运行状况</span></span><br><span class="line"><span class="attr">debug:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>还是在yml中配置，推荐这个方式</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置日志级别，root表示根节点，即整体应用日志级别</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line"><span class="attr">level:</span></span><br><span class="line">    <span class="comment">#设置整体的日志级别</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">debug</span></span><br><span class="line">    <span class="comment">#设置某个包的日志级别</span></span><br><span class="line">    <span class="comment">#路径: 级别</span></span><br><span class="line">    <span class="attr">com.demo.controller:</span> <span class="string">error</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>设置日志组，控制指定包对应的日志输出级别，也可以直接控制指定包对应的日志输出级别</p><p>说白了就是总体设置一下，每个包设置一下，如果感觉设置的麻烦，就先把包分个组，对组设置，能极大的简化开发</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line"><span class="comment"># 设置日志组</span></span><br><span class="line">    <span class="attr">group:</span></span><br><span class="line">    <span class="comment"># 自定义组名，设置当前组中所包含的包</span></span><br><span class="line">        <span class="string">组名（随意）:</span> <span class="string">包1,包2...</span></span><br><span class="line">    <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">warn</span></span><br><span class="line">        <span class="comment"># 为对应组设置日志级别</span></span><br><span class="line">        <span class="string">上面的组名:</span> <span class="string">debug</span></span><br><span class="line">    <span class="comment">#对某个小包微调</span></span><br><span class="line">        <span class="attr">com.itheima.controller:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="优化日志对象创建代码"><a href="#优化日志对象创建代码" class="headerlink" title="优化日志对象创建代码"></a>优化日志对象创建代码</h2><p>lombok技术给我们提供的工具类帮我们简化了代码，使用<code>@Slf4j</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span><span class="comment">//这个注解替代了下面那一行</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/books&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> <span class="keyword">extends</span> <span class="title class_">BaseClass</span>&#123;</span><br><span class="line">    <span class="comment">//这一句可以不写了，被@Slf4j替代了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(BookController.class);</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getById</span><span class="params">()</span>&#123;</span><br><span class="line">        log.debug(<span class="string">&quot;debug...&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;info...&quot;</span>);</span><br><span class="line">        log.warn(<span class="string">&quot;warn...&quot;</span>);</span><br><span class="line">        log.error(<span class="string">&quot;error...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;springboot is running...2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>人工模拟：P67前半</p><h2 id="日志输出格式控制"><a href="#日志输出格式控制" class="headerlink" title="日志输出格式控制"></a>日志输出格式控制</h2><p>日志已经能够记录了，但是目前记录的格式是SpringBoot给我们提供的，如果想自定义控制就需要自己设置了。先分析一下当前日志的记录格式</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231123140302477.png" alt="image-20231123140302477"></p><p>时间：</p><p>…</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line"><span class="attr">pattern:</span></span><br><span class="line">    <span class="attr">console:</span> <span class="string">&quot;%d %clr(%p) --- [%16t] %clr(%-40.40c)&#123;cyan&#125; : %m %n&quot;</span></span><br></pre></td></tr></table></figure><ul><li>%d</li><li>%clr()</li><li>%p</li><li>— [%t]</li><li>%c</li><li>{cyan} </li><li>%m</li><li>%n</li></ul><h2 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h2><p>日志信息显示，记录已经控制住了。日志不能仅显示在控制台上，要把日志记录到文件中，方便后期维护查阅</p><p>记录日志到文件中格式非常简单，设置日志文件名即可</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line"><span class="attr">file:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">server.log</span></span><br></pre></td></tr></table></figure><p>使用上述格式可以将日志记录下来，但是面对线上的复杂情况，一个文件记录肯定是不能够满足运维要求的，通常会每天记录日志文件，同时为了便于维护，还要限制每个日志文件的大小。</p><p>下面给出日志文件的常用配置方式：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line"><span class="attr">logback:</span></span><br><span class="line">    <span class="attr">rollingpolicy:</span></span><br><span class="line">        <span class="attr">max-file-size:</span> <span class="string">3KB</span></span><br><span class="line">            <span class="attr">file-name-pattern:</span> <span class="string">server.%d&#123;yyyy-MM-dd&#125;.%i.log</span></span><br></pre></td></tr></table></figure><ul><li>%d</li><li>%i</li></ul><h1 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h1><p>什么是热部署？</p><p>简单说就是你程序改了，现在要重新启动服务器，不用人为重启，服务器会自己悄悄的把更新后的程序给重新加载一遍，这就是热部署。</p><p><strong>springboot项目热部署实现原理</strong></p><p>基于springboot开发的web工程，tomcat服务器内置了，现在tomcat和我们的程序是平级的了，都是spring容器中的组件，不能监控工程的变化了，要想让tomcat服务器知道工程变化，需要在spring容器里面进行配置，监控工程变化并通知tomcat服务器。</p><h2 id="开启热部署"><a href="#开启热部署" class="headerlink" title="开启热部署"></a>开启热部署</h2><p>这个配置springboot早就做好了，搞我们导入一个坐标再进行配置就行了</p><div class="tabs" id=""><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#-1">手动启动热部署</button></li><li class="tab"><button type="button" data-href="#-2">自动启动热部署</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="-1"><ol><li><p>导入开发者工具对应的坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>构建项目，可以使用快捷键激活此功能，对应的快捷键：<code>CTRL+F9</code></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231123164009672.png" alt="image-20231123164009672"></p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-2"><p>自动热部署其实就是设计一个开关，打开这个开关后，IDE工具就可以自动热部署。这个操作和IDE工具有关，以下以idea为例设置idea中启动热部署</p><ol><li><p>设置自动构建项目</p><p>打开<code>File</code> -&gt; <code>settings</code> -&gt; <code>Compile</code>，然后勾选<code>Build project automatically</code>，意思是自动构建项目</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231123165628501.png" alt="image-20231123165628501"></p></li><li><p>允许在程序运行时进行自动构建</p><p>使用快捷键<code>Ctrl+Alt+Shit+/</code>打开维护面板，选择第1项<code>Registry</code></p><p>在选项中搜索comple，然后勾选对应项即可</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231123165713150.png" alt="image-20231123165713150"></p></li><li><p>设置时间，这个是默认设置好的</p><p>每敲一个字母，服务器就重新构建一次，这未免有点太频繁了，可以设置当idea工具失去焦点5秒后进行热部署。其实就是你从idea工具中切换到其他工具时进行热部署，比如改完程序需要到浏览器上去调试，这个时候idea就自动进行热部署操作。</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p><strong>简单普及一下底层的工作流程</strong>：</p><p>一个springboot项目在运行时实际上是分两个过程进行的，根据加载的东西不同，划分成base类加载器与restart类加载器</p><ul><li><p>重启（restart）：加载自定义开发代码，包含类、页面、配置文件等的过程，由restart类加载器加载</p></li><li><p>重载（reload）：加载jar包，由base类加载器加载</p></li></ul><p>我们修改程序，大多数是更改里面的内容，很少会更换jar包，修改jar包就更少见了，我们写的东西由restart类加载器加载，jar包由base类加载器加载。热部署其实只是重启的过程，不包括重载。</p><p>程序第一次启动是：重启+重载</p><ul><li>base类加载器：用来加载jar包中的类，jar包中的类和配置文件由于不会发生变化，因此不管加载多少次，加载的内容不会发生变化</li><li>restart类加载器：用来加载开发者自己开发的类、配置文件、页面等信息，这一类文件受开发者影响</li></ul><h2 id="热部署范围"><a href="#热部署范围" class="headerlink" title="热部署范围"></a>热部署范围</h2><p>并不是所有的文件修改都会激活热部署的，原因在于在开发者工具中有一组配置，当满足了配置中的条件后，才会启动热部署，配置中默认不参与热部署的目录信息如下</p><ul><li>&#x2F;META-INF&#x2F;maven</li><li>&#x2F;META-INF&#x2F;resources</li><li>&#x2F;resources</li><li>&#x2F;static</li><li>&#x2F;public</li><li>&#x2F;templates</li></ul><p>以上目录中的文件如果发生变化，是不参与热部署的。如果想修改配置，因为这个简化实现是springboot带来的，可以通过application.yml文件修改springboot配置，来设定哪些文件不参与热部署操作</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">devtools:</span></span><br><span class="line">    <span class="attr">restart:</span></span><br><span class="line">      <span class="comment"># 设置不参与热部署的文件或文件夹</span></span><br><span class="line">      <span class="attr">exclude:</span> <span class="string">static/**,public/**,config/application.yml</span></span><br></pre></td></tr></table></figure><h2 id="关闭热部署"><a href="#关闭热部署" class="headerlink" title="关闭热部署"></a>关闭热部署</h2><p>线上环境运行时是不可能使用热部署功能的，所以需要强制关闭此功能，通过配置可以关闭此功能</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">devtools:</span></span><br><span class="line">    <span class="attr">restart:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>这个地方的设置是有效的，但是这整个配置都可能被其他配置覆盖或失活，这个关闭操作是有其他配置方法的，在更高级的地方设置就行了</p><p>例如.写在启动类里面，在启动容器前通过系统属性设置关闭热部署功能，这个的优先级很高，一定能生效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SSMPApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.setProperty(<span class="string">&quot;spring.devtools.restart.enabled&quot;</span>,<span class="string">&quot;false&quot;</span>);</span><br><span class="line">        SpringApplication.run(SSMPApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="配置高级"><a href="#配置高级" class="headerlink" title="配置高级"></a>配置高级</h1><h2 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h2><p>此注解的作用是用来为bean绑定属性的。在前面yml中讲过，开发者可以在yml配置文件中以对象的格式添加若干属性，但是有前提：</p><ul><li>yml中要有对应的配置</li><li>java代码中要有一个实体类或能封装数据的类，二者属性一一对应</li></ul><p>@ConfigurationProperties的使用</p><ol><li><p>在java包中创建相关类，如ServerConfig，用来加载对应的属性，注意要提供属性对应的setter方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String ipAddress;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> timeout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置相关属性</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">servers:</span></span><br><span class="line">  <span class="attr">ip-address:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span> </span><br><span class="line">  <span class="attr">port:</span> <span class="number">2345</span></span><br><span class="line">  <span class="attr">timeout:</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></li><li><p>使用@ConfigurationProperties注解就可以将配置中的属性值关联到开发的模型类上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;servers&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String ipAddress;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> timeout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这样加载对应bean的时候就可以直接加载配置属性值了。</p><p>目前我们学的都是给自定义的bean使用这种形式加载属性值，如果是第三方的bean能不能用这种形式加载属性值呢？</p><p>为什么会提出这个疑问？因为当前@ConfigurationProperties注解是写在类定义的上方，而第三方开发的bean源代码不是自己书写的，也不可能到源代码中去添加@ConfigurationProperties注解</p><p>使用@ConfigurationProperties注解其实可以为第三方bean加载属性，格式特殊一点而已</p><ol><li><p>使用@Bean注解定义第三方bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DruidDataSource <span class="title function_">datasource</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">    <span class="keyword">return</span> ds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在yml中定义要绑定的属性，注意datasource此时全小写</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">datasource:</span></span><br><span class="line">  <span class="attr">driverClassName:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure></li><li><p>使用@ConfigurationProperties注解为第三方bean进行属性绑定，注意前缀是全小写的datasource</p><p>在步骤1的基础上添加注解<code>@ConfigurationProperties(prefix = &quot;datasource&quot;)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;datasource&quot;)</span></span><br><span class="line"><span class="keyword">public</span> DruidDataSource <span class="title function_">datasource</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">    <span class="keyword">return</span> ds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>操作方式完全一样，只不过@ConfigurationProperties注解不仅能添加到类上，还可以添加到方法上，添加到类上是为spring容器管理的当前类的对象绑定属性，添加到方法上是为spring容器管理的当前方法的返回值对象绑定属性，其实本质上都一样</p></blockquote><h3 id="EnableConfigurationProperties"><a href="#EnableConfigurationProperties" class="headerlink" title="@EnableConfigurationProperties"></a>@EnableConfigurationProperties</h3><p>Enable开头的注解类似一个开关，用来开启功能使用</p><p>spring提供注解@EnableConfigurationProperties，专门标注使用@ConfigurationProperties注解绑定属性的bean是哪些。功能是开启属性绑定并设定目标是谁</p><p>使用步骤：</p><ol><li><p>在配置类上开启@EnableConfigurationProperties注解，并标注要使用@ConfigurationProperties注解绑定属性的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(ServerConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Springboot13ConfigurationApplication</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在对应的类上直接使用@ConfigurationProperties进行属性绑定</p><p>注意观察，现在绑定属性的ServerConfig类并没有声明@Component注解。当使用@EnableConfigurationProperties注解时，spring会默认将其标注的类定义为bean，因此无需再次声明@Component注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;servers&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String ipAddress;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> timeout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>使用@ConfigurationProperties注解时，可能会出现一个提示信息，出现这个提示后只需要添加一个坐标此提醒就消失了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231123194705182.png" alt="image-20231123194705182"></p><p><strong>总结</strong></p><ol><li>使用@ConfigurationProperties可以为使用@Bean声明的第三方bean绑定属性</li><li>当使用@EnableConfigurationProperties声明进行属性绑定的bean后，无需使用@Component注解再次进行bean声明</li></ol><h2 id="宽松绑定"><a href="#宽松绑定" class="headerlink" title="宽松绑定"></a>宽松绑定</h2><p>在进行属性绑定时，可能会遇到如下情况，为了进行标准命名，开发者会将属性名严格按照驼峰命名法书写，在yml配置文件中将datasource修改为dataSource，此时程序可以正常运行</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dataSource:</span></span><br><span class="line">  <span class="attr">driverClassName:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure><p>然后又将代码中的前缀datasource修改为dataSource</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">@Bean</span></span><br><span class="line"><span class="string">@ConfigurationProperties(prefix</span> <span class="string">=</span> <span class="string">&quot;dataSource&quot;</span><span class="string">)</span></span><br><span class="line"><span class="string">public</span> <span class="string">DruidDataSource</span> <span class="string">datasource()&#123;</span></span><br><span class="line">    <span class="string">DruidDataSource</span> <span class="string">ds</span> <span class="string">=</span> <span class="string">new</span> <span class="string">DruidDataSource();</span></span><br><span class="line">    <span class="string">return</span> <span class="string">ds;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>此时就发生了编译错误，而且并不是idea工具导致的，运行后依然会出现问题，配置属性名dataSource是无效的</p><blockquote><p>Configuration property name ‘dataSource’ is not valid:</p><p>Invalid characters: ‘S’<br>Bean: datasource<br>Reason: Canonical names should be kebab-case (‘-‘ separated), lowercase alpha-numeric characters and must start with a letter</p><p>Action:<br>Modify ‘dataSource’ so that it conforms to the canonical names requirements.</p></blockquote><p>为什么会出现这种问题，这就要来说一说springboot进行属性绑定时的一个重要知识点了，有关属性名称的宽松绑定，也可以称为宽松绑定</p><p>宽松绑定：实际上是springboot进行编程时人性化设计的一种体现，即<strong>配置文件</strong>中的命名格式与变量名的命名格式可以进行格式上的最大化兼容</p><p>@ConfigurationProperties 支持宽松绑定，其他的就不一定了</p><p>例如：</p><ul><li><p>ServerConfig中的ipAddress属性名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;servers&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String ipAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置文件中属性名</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">servers:</span></span><br><span class="line">  <span class="attr">ipAddress:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.2</span>       <span class="comment"># 驼峰模式</span></span><br><span class="line">  <span class="attr">ip_address:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.2</span>      <span class="comment"># 下划线模式</span></span><br><span class="line">  <span class="attr">ip-address:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.2</span>      <span class="comment"># 烤肉串模式，这个模式常用</span></span><br><span class="line">  <span class="attr">IP_ADDRESS:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.2</span>      <span class="comment"># 常量模式</span></span><br></pre></td></tr></table></figure></li></ul><p>在进行匹配时，配置中的名称要去掉中划线和下划线后，忽略大小写的情况下去与java代码中的属性名进行忽略大小写的等值匹配，以上4种命名去掉下划线中划线忽略大小写后都是一个词ipaddress，java代码中的属性名忽略大小写后也是ipaddress，这样就可以进行等值匹配了</p><p>springboot官方推荐使用烤肉串模式，也就是中划线模式</p><p><strong>绑定前缀名命名规范：仅能使用纯小写字母.数字、下划线作为合法的字符</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>@ConfigurationProperties绑定属性时支持属性名宽松绑定，这个宽松体现在属性名的命名规则上</li><li>@Value注解不支持松散绑定规则</li><li>绑定前缀名推荐采用烤肉串命名规则，即使用中划线做分隔符</li></ol><h2 id="常用计量单位绑定"><a href="#常用计量单位绑定" class="headerlink" title="常用计量单位绑定"></a>常用计量单位绑定</h2><p>在前面的配置中，我们书写了如下配置值，其中第三项超时时间timeout描述了服务器操作超时时间，当前值是-1表示永不超时</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">servers:</span></span><br><span class="line">  <span class="attr">ip-address:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span> </span><br><span class="line">  <span class="attr">port:</span> <span class="number">2345</span></span><br><span class="line">  <span class="attr">timeout:</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>springboot充分利用了JDK8中提供的全新的用来表示计量单位的新数据类型，从根本上解决这个问题。以下模型类中添加了两个JDK8中新增的类，分别是Duration和DataSize，在配置类中配置单位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;servers&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerConfig</span> &#123;</span><br><span class="line">    <span class="meta">@DurationUnit(ChronoUnit.HOURS)</span></span><br><span class="line">    <span class="keyword">private</span> Duration serverTimeOut;</span><br><span class="line">    <span class="meta">@DataSizeUnit(DataUnit.MEGABYTES)</span></span><br><span class="line">    <span class="keyword">private</span> DataSize dataSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Duration</strong>：表示时间间隔，可以通过@DurationUnit注解描述时间单位，例如上例中描述的单位为小时（ChronoUnit.HOURS）</li><li><strong>DataSize</strong>：表示存储空间，可以通过@DataSizeUnit注解描述存储空间单位，例如上例中描述的单位为MB（DataUnit.MEGABYTES）</li></ul><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231124204828672.png" alt="image-20231124204828672"></p><h2 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h2><p>在书写时由于无法感知模型类中的数据类型，就会出现类型不匹配的问题，比如代码中需要int类型，配置中给了非法的数值，例如写一个“a”，这种数据肯定无法有效的绑定，还会引发错误</p><p>SpringBoot给出了强大的数据校验功能，可以有效的避免此类问题的发生。在JAVAEE的JSR303规范中给出了具体的数据校验标准，开发者可以根据自己的需要选择对应的校验框架</p><p>此处使用Hibernate提供的校验框架来作为实现进行数据校验。书写应用格式非常固定</p><p>步骤：</p><ol><li><p>开启校验框架</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1.导入JSR303规范--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.validation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>validation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在需要开启校验功能的类上使用注解@Validated开启校验功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;servers&quot;)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//开启对当前bean的属性注入校验</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerConfig</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>对具体的字段设置校验规则，在2的基础上配置规则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置具体的规则</span></span><br><span class="line">    <span class="meta">@Max(value = 8888,message = &quot;最大值不能超过8888&quot;)</span></span><br><span class="line">    <span class="meta">@Min(value = 202,message = &quot;最小值不能低于202&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这个时候就能测试了，然后我们发现报错，提示缺少实现类，我们添加hibernate框架提供的校验器做实现类</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--使用hibernate框架提供的校验器做实现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>再测试，就能用了</p></li></ol><p><strong>总结</strong></p><p>开启Bean属性校验功能一共3步：</p><ol><li>导入JSR303与Hibernate校验框架坐标</li><li>使用@Validated注解启用校验功能</li><li>使用具体校验规则规范数据校验格式</li></ol><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p>先把提出一个问题，这位开发者连接数据库正常操作，但是运行程序后显示的信息是密码错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.sql.SQLException: Access denied for user &#x27;root&#x27;@&#x27;localhost&#x27; (using password: YES)</span><br></pre></td></tr></table></figure><p>这是用户名和密码不匹配，就是密码输入错了，但是问题就在于密码并没有输入错误，这就比较讨厌了。给的报错信息无法帮助你有效的分析问题，甚至会给你带到沟里。</p><p>来看看用户名密码的配置是如何写的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">0127</span></span><br></pre></td></tr></table></figure><p>这名开发者的生日是1月27日，所以密码就使用了0127，其实问题就出在这里了。</p><p>在整数相关知识中有这么一句话，<strong>支持二进制，八进制，十六进制</strong></p><p>因为0127在开发者眼中是一个字符串“0127”，但是在springboot看来，这就是一个数字，而且是一个八进制的数字。当后台使用String类型接收数据时，如果配置文件中配置了一个整数值，他是先安装整数进行处理，读取后再转换成字符串。0127撞上了八进制的格式，所以最终以十进制数字87的结果存在了。</p><p>这里提两个注意点：</p><ol><li>符串标准书写加上引号包裹，养成习惯</li><li>遇到0开头的数据多注意吧</li></ol><h1 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h1><h2 id="bean的加载方式（复习）"><a href="#bean的加载方式（复习）" class="headerlink" title="bean的加载方式（复习）"></a>bean的加载方式（复习）</h2><p>5开始，后面的方法问题很大，以前没接触过</p><p>关于bean的加载方式，spring提供了各种各样的形式。因为spring管理bean整体上来说就是由spring维护对象的生命周期，所以bean的加载可以从大的方面划分成2种形式。已知类并交给spring管理，和已知类名并交给spring管理。一个给.class，一个给类名字符串。内部其实都一样，都是通过spring的BeanDefinition对象初始化spring的bean。</p><h3 id="方式一：配置文件-lt-bean-gt-标签"><a href="#方式一：配置文件-lt-bean-gt-标签" class="headerlink" title="方式一：配置文件+&lt;bean/&gt;标签"></a>方式一：配置文件+<code>&lt;bean/&gt;</code>标签</h3><p>最初级的bean的加载方式其实可以直击spring管控bean的核心思想，就是提供类名，然后spring就可以管理了。内部是反射机制加载成class，拿到了class你就可以搞定一切了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--xml方式声明自己开发的bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.demo.Cat&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--xml方式声明第三方开发的bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>先获取spring容器，再调用spring容器的getBean的方法获取相关的实例</p><h3 id="方式二：配置文件扫描-注解定义bean"><a href="#方式二：配置文件扫描-注解定义bean" class="headerlink" title="方式二：配置文件扫描+注解定义bean"></a>方式二：配置文件扫描+注解定义bean</h3><p>方式一种需要将spring管控的bean全部写在xml文件中，写起来麻烦，在相关类上用注解就指明了路径，然后定义名字就行</p><p>这里可以使用的注解有@Component以及三个衍生注解@Service、@Controller、@Repository</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;tom&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mouse</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要在xml配置文件中开启扫描功能</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--指定扫描加载bean的位置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima.bean,com.itheima.config&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>由于我们无法在第三方提供的技术源代码中去添加上述4个注解，可以用@Bean定义在一个方法上方，当前方法的返回值就可以交给spring管控，记得这个方法所在的类一定要定义在@Component修饰的类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DbConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DruidDataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面提供的仅仅是bean的声明，spring并没有感知到这些东西，想让spring感知到这些积极的小伙伴，必须设置spring去检查这些类，看他们是否贴标签，可以通过下列xml配置设置自定义命名空间，发现定了对应注解，就将对应的类纳入spring管控范围，声明成bean。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span>//<span class="attr">新增的一行</span>，<span class="attr">抄下面的</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>//<span class="attr">原有的一行</span>，<span class="attr">模版</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">    &quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--指定扫描加载bean的位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima.bean,com.itheima.config&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>方式一中，通过一个配置文件，你可以查阅当前spring环境中定义了多少个或者说多少种bean。</p><p>方式二没有任何一个地方可以查阅整体信息，只有当程序运行起来才能感知到加载了多少个bean。</p><h6 id="Configuration怎么用"><a href="#Configuration怎么用" class="headerlink" title="@Configuration怎么用"></a>@Configuration怎么用</h6><h3 id="方式三：注解方式声明配置类"><a href="#方式三：注解方式声明配置类" class="headerlink" title="方式三：注解方式声明配置类"></a>方式三：注解方式声明配置类</h3><p>通过方式二，已经简化了bean的声明，xml配置文件中只剩了扫描包这句话，使用java类替换掉这种固定格式的配置，所以下面这种格式就出现了。</p><p>定义一个类并使用@ComponentScan替代原始xml配置中的包扫描这个动作，其实功能基本相同。还是有差别的。</p><p>配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.itheima.bean&quot;,&quot;com.itheima.config&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig3</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DogFactoryBean <span class="title function_">dog</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DogFactoryBean</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动类：</p><p>因为没有配置文件了，所以原来spring容器的实现类就用不了了，换成配置类的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        String[] names = ctx.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FactroyBean接口"><a href="#FactroyBean接口" class="headerlink" title="FactroyBean接口"></a>FactroyBean接口</h3><p>spring提供了一个接口FactoryBean，也可以用于声明bean，只不过实现了FactoryBean接口的类造出来的对象不是当前类的对象，而是FactoryBean接口泛型指定类型的对象。</p><p>如下列，造出来的bean并不是DogFactoryBean，而是Dog。有什么用呢？可以在对象初始化前做一些事情，下例中的注释位置就是让你自己去扩展要做的其他事情的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DogFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;Dog&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Dog <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//扩展操作</span></span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Dog.class;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有人说，注释中的代码写入Dog的构造方法不就行了吗？干嘛这么费劲转一圈，还写个类，还要实现接口，多麻烦啊。还真不一样，你可以理解为Dog是一个抽象后剥离的特别干净的模型，但是实际使用的时候必须进行一系列的初始化动作。只不过根据情况不同，初始化动作不同而已。如果写入Dog，或许初始化动作A当前并不能满足你的需要，这个时候你就要做一个DogB的方案了。然后，就没有然后了，你就要做两个Dog类。当时使用FactoryBean接口就可以完美解决这个问题。</p><p>通常实现了FactoryBean接口的类使用@Bean的形式进行加载，当然你也可以使用@Component去声明DogFactoryBean，只要被扫描加载到即可</p><h4 id="注解格式导入XML格式配置的bean"><a href="#注解格式导入XML格式配置的bean" class="headerlink" title="注解格式导入XML格式配置的bean"></a>注解格式导入XML格式配置的bean</h4><p>早起开发的系统大部分都是采用xml的形式配置bean，如果你特别幸运，需要基于之前的系统进行二次开发，这就尴尬了。新开发的用注解格式，之前开发的是xml格式。这个时候可不是让你选择用哪种模式的，而是两种要同时使用。</p><p>spring提供了一个注解可以解决这个问题，@ImportResource，在配置类上直接写上要被融合的xml配置文件名即可，算的上一种兼容性解决方案</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportResource(&quot;applicationContext1.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig32</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="proxyBeanMethods属性"><a href="#proxyBeanMethods属性" class="headerlink" title="proxyBeanMethods属性"></a>proxyBeanMethods属性</h4><p>@Configuration和@Component区别？</p><p>源码中@Component只有一个，给bean取名字用</p><p>源码中@Configuration有value属性，还有一个属性proxyBeanMethods</p><p>使用AnnotationConfigApplicationContext加载配置类的时候，配置类可以不添加@Configuration注解。但是这个注解有一个更加强大的功能，它可以保障配置类中使用方法创建的bean的唯一性。把@Configuration注解proxyBeanMethods属性设置为true即可，由于此属性默认值为true，所以很少看见明确书写的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig33</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Cat <span class="title function_">cat</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>proxyBeanMethods为true时，创建的对象是SpringCGLIB的代理方式，创建的bean对象都是单例对象。</p><p>proxyBeanMethods为false时，创建的对就是原始对象了，每次使用的时候执行方法new一个，创建的bean对象是非单例对象。</p><p>使用proxyBeanMethods&#x3D;true可以保障调用此方法得到的对象是从容器中获取的而不是重新创建的</p><h3 id="方式四：使用-Import注解注入bean"><a href="#方式四：使用-Import注解注入bean" class="headerlink" title="方式四：使用@Import注解注入bean"></a>方式四：使用@Import注解注入bean</h3><p>@Import源码中只有一个属性<code>Class&lt;?&gt; [] value()</code>，要填充类型，可以用数组的格式填充多个，但是1个类只能用一个@Import</p><p>@Import是一种精准制导的加载方式，它可以加载所有的一切，只需要在注解的参数中写上加载的类对应的.class即可。可以用来快速导入第三方bean，被导入的bean无需使用注解声明为bean，简单快捷</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(&#123;Dog.class,DbConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig4</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>除了加载bean，还可以使用@Import注解加载配置类。其实本质上是一样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(DogFactoryBean.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig4</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="方式五：编程形式注册bean"><a href="#方式五：编程形式注册bean" class="headerlink" title="方式五：编程形式注册bean"></a>方式五：编程形式注册bean</h3><p>这种方式就比较特殊了，可以在容器初始化完成后手动加载bean。通过这种方式可以实现编程式控制bean的加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//上下文容器对象已经初始化完毕后，手工加载bean</span></span><br><span class="line">        ctx.register(Mouse.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这种方式坑还是挺多的，比如容器中已经有了某种类型的bean，再加载会不会覆盖呢？这都是要思考和关注的问题。</p><p>这种方式就像map，往里面添东西，若key一样，就覆盖，这是spring的一个机制，同名bean被替换</p><p>新手慎用（这个方法没学过哎）</p><h3 id="方式六：导入实现了ImportSelector接口的类"><a href="#方式六：导入实现了ImportSelector接口的类" class="headerlink" title="方式六：导入实现了ImportSelector接口的类"></a>方式六：导入实现了ImportSelector接口的类</h3><p>开发人员用的少，但是框架内部用的多</p><p>在方式五种，我们感受了bean的加载可以进行编程化的控制，添加if语句就可以实现bean的加载控制了。但是毕竟是在容器初始化后实现bean的加载控制，还可以在容器初始化过程中进行控制。</p><p>实现ImportSelector接口的类可以设置加载的bean的全路径类名，记得一点，只要能编程就能判定，能判定意味着可以控制程序的运行走向，进而控制一切</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata metadata) &#123;</span><br><span class="line">        <span class="comment">//各种条件的判定，判定完毕后，决定是否装载指定的bean</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> metadata.hasAnnotation(<span class="string">&quot;org.springframework.context.annotation.Configuration&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;com.itheima.bean.Dog&quot;</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;com.itheima.bean.Cat&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AnnotationMetadata：注解元数据</p><h3 id="方式七：导入ImportBeanDefinitionRegistrar的实现类"><a href="#方式七：导入ImportBeanDefinitionRegistrar的实现类" class="headerlink" title="方式七：导入ImportBeanDefinitionRegistrar的实现类"></a>方式七：导入ImportBeanDefinitionRegistrar的实现类</h3><p>方式六中提供了给定类全路径类名控制bean加载的形式，如果对spring的bean的加载原理比较熟悉的小伙伴知道，其实bean的加载不是一个简简单单的对象，spring中定义了一个叫做BeanDefinition的东西，它才是控制bean初始化加载的核心。</p><p>BeanDefinition接口中给出了若干种方法，可以控制bean的相关属性。我们可以通过定义一个类，然后实现ImportBeanDefinitionRegistrar接口的方式定义bean，并且还可以让你对bean的初始化进行更加细粒度的控制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> BeanDefinitionBuilder.rootBeanDefinition(BookServiceImpl2.class).getBeanDefinition();</span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;bookService&quot;</span>,beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方式八：导入实现了BeanDefinitionRegistryPostProcessor接口的类"><a href="#方式八：导入实现了BeanDefinitionRegistryPostProcessor接口的类" class="headerlink" title="方式八：导入实现了BeanDefinitionRegistryPostProcessor接口的类"></a>方式八：导入实现了BeanDefinitionRegistryPostProcessor接口的类</h3><p>这是个后处理器，BeanDefinitionPostProcessor专门关于注册功能的子接口。在所有bean注册都折腾完后，它把最后一道关，它是最后一个运行的，它说了算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> BeanDefinitionBuilder.rootBeanDefinition(BookServiceImpl4.class).getBeanDefinition();</span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;bookService&quot;</span>,beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol><li>bean的定义由前期xml配置逐步演化成注解配置，本质是一样的，都是通过反射机制加载类名后创建对象，对象就是spring管控的bean</li><li>@Import注解可以指定加载某一个类作为spring管控的bean，如果被加载的类中还具有@Bean相关的定义，会被一同加载</li><li>spring开放出了若干种可编程控制的bean的初始化方式，通过分支语句由固定的加载bean转成了可以选择bean是否加载或者选择加载哪一种bean</li></ol><p>方式：</p><ol><li>xml+&lt; bean&#x2F;&gt;</li><li>xml:context+注解(@Component+4个@Bean)</li><li>配置类+扫描+注解(@Component+4个@Bean)</li></ol><ul><li>@Bean定义FactoryBean接口</li><li>@ImportResource</li><li>@Configuration注解 的proxyBeanMethods属性</li></ul><ol start="4"><li>@Import导入bean的类<br>@Import导入配置类</li><li>AnnotationConfigApplicationContext 调用register方法</li><li>@Import导 入ImportSelector接口</li><li>@Import导 入ImportBeanDefinitionRegistrar接口</li><li>@Import导 入BeanDefinitionRegistryPostProcessor接口</li></ol><h2 id="bean的加载控制"><a href="#bean的加载控制" class="headerlink" title="bean的加载控制"></a>bean的加载控制</h2><p>前面回顾了8种bean的加载方式，都能把bean加载到容器里面，但是根据使用情况的不同，我们可能选择使用不同的bean，而不是使用那些固定的bean，这个情况叫bean的加载控制，我们能在这个过程中进行一些特殊控制</p><p>bean的加载控制：根据特定情况对bean进行选择性加载以达到适用于项目的目标。适应程序的需求，用什么加载什么。</p><p>想要进行加载控制，至少要有一个if判断吧，前面8个方式中，后四种可以满足这个要求</p><p>使用注解控制bean加载</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-磁盘调度和网络配置</title>
      <link href="/2023/10/20/Linux%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/"/>
      <url>/2023/10/20/Linux%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="分盘原理"><a href="#分盘原理" class="headerlink" title="分盘原理"></a>分盘原理</h1><p>Linux来说无论有几个分区，分给哪一目录使用 ,它归根结底就只有一个根目录， -个独立且唯-的文件结构, Linux中每个分区都是用来组成整个文件系统的一部分。<br>Linux采用了一种叫<strong>载入</strong>的处理方法，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202311012120168.png"></p><h1 id="Linux分区"><a href="#Linux分区" class="headerlink" title="Linux分区"></a>Linux分区</h1><h2 id="硬盘说明"><a href="#硬盘说明" class="headerlink" title="硬盘说明"></a>硬盘说明</h2><ol><li>Linux硬盘分IDE硬盘和SCSI硬盘，目前基本上是SCSI硬盘</li><li>对于IDE硬盘,驱动器标识符为**hdx~**其中”hd”表明分区所在设备的类型,这里是指IDE硬盘<br>了。”x”为盘号( a为基本盘, b为基本从属盘, c为辅助主盘，d为辅助从属盘)，”心”代表分区，<br>前四个分区用数字1到4表示，它们是主分区或扩展分区,从5开始就是逻辑分区。例，hda3表示为<br>第一个IDE硬盘上的第三个主分区或扩展分区,hdb2表示为第二个IDE硬盘上的第二个主分区或扩展<br>分区。</li><li>对于SCSI硬盘则标识为”sdx~” ， SCSI硬盘是用”sd” 来表示分区所在设备的类型的，其余则和<br>IDE硬盘的表示方法样。</li></ol><h2 id="查看所有设备挂载情况"><a href="#查看所有设备挂载情况" class="headerlink" title="查看所有设备挂载情况"></a>查看所有设备挂载情况</h2><p> Isblk或者Isblk -f</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h2 id="磁盘情况查询"><a href="#磁盘情况查询" class="headerlink" title="磁盘情况查询"></a>磁盘情况查询</h2><p>查询指定目录的磁盘占用情况<br>1基本语法<br>du-h &#x2F;目录<br>查询指定目录的磁盘占用情况，默认为当前目录<br>-S指定目录占用大小汇总<br>-h带计量单位<br>-a含文件<br>–max- depth&#x3D;1子目录深度<br>-C列出明细的同时,增加汇总值<br>V应用实例<br>查询&#x2F;opt目录的磁盘占用情况,深度为1</p><h1 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h1><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202311012141932.png"></p><p>设置IP地址方式：</p><ol><li><p>自动获取:<br>登陆后，通过界面的来设置自动获取ip，特点: linux启动后会自动获取IP缺点是每次自动获取的<br>ip地址可能不一样。</p></li><li><p>指定ip<br>直接修改配置文件来指定IP并可以连接到外网(程序员推荐)</p><p>编辑vi &#x2F;etc&#x2F;sysconfig&#x2F;network scripts&#x2F;ifcfg-ens33</p><p>要求:将ip地址配置的静态的,比如: ip地址为192.168.200.130</p></li></ol><h2 id="设置主机名和hosts映射"><a href="#设置主机名和hosts映射" class="headerlink" title="设置主机名和hosts映射"></a>设置主机名和hosts映射</h2><p>设置主机名</p><ol><li>为了方便记忆,可以给linux系统设置主机名，也可以根据需要修改主机名</li><li>指令hostname :查看主机名</li><li>修改文件在&#x2F;etc&#x2F;hostname指定</li><li>修改后，重启生效</li></ol><p>设置hosts映射</p><ul><li><p>windows</p><p>在C:\Windows\System32\drivers\etc\hosts文件指定即可</p><p>案例: 192.168.200.130 名字</p></li><li><p>linux</p><p>在&#x2F;etc&#x2F;hosts文件指定1</p><p>案例: 192.168.200.1 名字</p></li></ul><h2 id="主机名解析过程分析-Hosts、DNS"><a href="#主机名解析过程分析-Hosts、DNS" class="headerlink" title="主机名解析过程分析(Hosts、DNS)"></a>主机名解析过程分析(Hosts、DNS)</h2><p>Hosts：一个文本文件，用来记录IP和Hostname(主机名)的映射关系<br>DNS是什么：</p><ol><li>DNS ,就是Domain Name System的缩写,翻译过来就是域名系统</li><li>是互联网上作为域名和IP地址相互映射的一一个分布式数据库</li></ol><h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><p>用户在浏览器输入了<a href="http://www.baidu.com/">www.baidu.com</a></p><ol><li><p>浏览器先检查浏览器缓存中有没有该域名解析IP地址 ，有就先调用这个IP完成解析;如果没有,就检查DNS解析器缓存,如果有直接返回IP完成解析。这两个缓存，可以理解为本地解析器缓存</p></li><li><p>一般来说，当电脑第次成功访问某网站后，在一 定时间内，浏览器或操作系统会缓存他的IP地址( DNS解析记录) .如在cmd窗口中输入<br>ipconfig &#x2F;displaydns  &#x2F;&#x2F;DNS域名解析缓存<br>ipconfig &#x2F;flushdns     &#x2F;&#x2F;手动清理dns缓存</p></li><li><p>如果本地解板 温缓存没有找到对应映射,检查系统中hosts文件中有没有配置对应的域名IP映射，如果有，则完成解析并返回。</p></li><li><p>如果 本地DNS解析器缓存和hosts文件中均没有找到对应的IP，则到域名服务DNS进行解析域</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot基本使用</title>
      <link href="/2023/10/19/SpringBoot%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/10/19/SpringBoot%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">Idea联网版</button></li><li class="tab"><button type="button" data-href="#test1-2">官网创建版</button></li><li class="tab"><button type="button" data-href="#test1-3">手工制作版</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20231121163935.png"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231121164021822.png" alt="image-20231121164021822"></p><p>第3步点击Next时，Idea需要联网!状态才可以进入到后面那一页，如果不能正常联网，就无法正确到达右面那个设置页了，会一直<font color="#ff0000"><b>联网</b></font>转转转</p><p>第5步选择java版本和你计算机上安装的JDK版本匹配即可，但是最低要求为JDK8或以上版本，推荐使用8或11</p><blockquote><p>本人使用的时候默认springboot3，不支持jdk8了，要手动降springboot版本</p><p><font color="#ff0000"><b>java: 警告: 源发行版 17 需要目标发行版 17</b></font></p><p>这东西先看看pom.xml里面给&lt; java.version&gt;8&lt; &#x2F;java.version&gt;配的什么，原来是17，我每次关系都报一次什么错误</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><ol><li><p>点击<strong>Spring Initializr</strong>后进入到创建SpringBoot程序界面，接下来就是输入信息的过程，和在Idea中制作是一样的，只是界面发生了变化，根据自己的要求，在左侧选择对应信息和输入对应的信息。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231121170547431.png"></p></li><li><p>右侧的<strong>ADD DEPENDENCIES</strong>用于选择使用何种技术，和之前勾选的Spring WEB是在做同一件事，仅仅是界面不同而已，点击后打开网页版的技术选择界面</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231121170729107.png" alt="image-20231121170729107"></p></li><li><p>所有信息设置完毕后，点击下面左侧<strong>GENERATE</strong>按钮，生成一个文件包，保存后得到一个压缩文件，这个文件就是创建的SpringBoot工程，解压缩此文件得到工程目录，在Idea中导入即可直接使用，和之前在Idea环境下根据向导创建的工程完全一样</p></li></ol><blockquote><p>其实Idea工具中创建SpringBoot工程其实连接的就是SpringBoot的官网，换句话说这种方式和第一种方式是一模一样的，只不过Idea把界面给整合了一下</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/1724035ac0724e3ca3177fd10e77f77a.png" alt="img"></p><ol><li><p>导入坐标，这个坐标就是springboot简化开发的魔法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.5.6&lt;/version&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;groupId&gt;com.example&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;springboot_01_04_quickstart&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></li><li><p>制作引导类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>在Idea中隐藏指定文件&#x2F;文件夹</p><p>使用SpringBoot创建，得到一个标准的SpringBoot工程文件结构。标准的工程结构中包含了一些未知的文件夹，在开发的时候看起来特别别扭，处理方案有两种：</p><ol><li><p>有用的留着，没有用的完全可以删除掉</p></li><li><p>不删除，设置文件为看不到就行了</p><ul><li>打开设置，Files→Settings</li><li>打开文件类型设置界面后，Editor→File Types→Ignored Files and Folders，忽略文件或文件夹显示</li></ul><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231121171136758.png" alt="image-20231121171136758"></p></li></ol><h2 id="起步依赖"><a href="#起步依赖" class="headerlink" title="起步依赖"></a>起步依赖</h2><div class="tabs" id="test2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test2-1">parent</button></li><li class="tab"><button type="button" data-href="#test2-2">starter</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test2-1"><p>所有SpringBoot项目要继承的项目，定义了若干个坐标版本号（管理依赖版本，而非使用依赖），以达到减少依赖冲突的目的</p><p>spring-boot-starter-parent各版本间存在着诸多坐标版本不同</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>打开后可以查阅到其中又继承了一个坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个坐标中定义了两组信息</p><ol><li><p>第一组是各式各样的依赖版本号属性，下面列出依赖版本属性的局部，可以看的出来，定义了若干个技术的依赖版本号</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activemq.version</span>&gt;</span>5.16.3<span class="tag">&lt;/<span class="name">activemq.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aspectj.version</span>&gt;</span>1.9.7<span class="tag">&lt;/<span class="name">aspectj.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">assertj.version</span>&gt;</span>3.19.0<span class="tag">&lt;/<span class="name">assertj.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">commons-codec.version</span>&gt;</span>1.15<span class="tag">&lt;/<span class="name">commons-codec.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">commons-dbcp2.version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">commons-dbcp2.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">commons-lang3.version</span>&gt;</span>3.12.0<span class="tag">&lt;/<span class="name">commons-lang3.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">commons-pool.version</span>&gt;</span>1.6<span class="tag">&lt;/<span class="name">commons-pool.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">commons-pool2.version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">commons-pool2.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2.version</span>&gt;</span>1.4.200<span class="tag">&lt;/<span class="name">h2.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hibernate.version</span>&gt;</span>5.4.32.Final<span class="tag">&lt;/<span class="name">hibernate.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hibernate-validator.version</span>&gt;</span>6.2.0.Final<span class="tag">&lt;/<span class="name">hibernate-validator.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">httpclient.version</span>&gt;</span>4.5.13<span class="tag">&lt;/<span class="name">httpclient.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jackson-bom.version</span>&gt;</span>2.12.4<span class="tag">&lt;/<span class="name">jackson-bom.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">javax-jms.version</span>&gt;</span>2.0.1<span class="tag">&lt;/<span class="name">javax-jms.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">javax-json.version</span>&gt;</span>1.1.4<span class="tag">&lt;/<span class="name">javax-json.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">javax-websocket.version</span>&gt;</span>1.1<span class="tag">&lt;/<span class="name">javax-websocket.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jetty-el.version</span>&gt;</span>9.0.48<span class="tag">&lt;/<span class="name">jetty-el.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.13.2<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>第二组是各式各样的依赖坐标信息，可以看出依赖坐标定义中没有具体的依赖版本号，而是引用了第一组信息中定义的依赖版本属性值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;hibernate.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>总结</strong></p><ol><li>开发SpringBoot程序要继承spring-boot-starter-parent</li><li>spring-boot-starter-parent中定义了若干个依赖管理</li><li>继承parent模块可以避免多个依赖使用相同技术时出现依赖版本冲突</li><li>继承parent的形式也可以采用引入依赖的形式实现效果</li></ol><p><strong>思考</strong></p><p>parent中定义了若干个依赖版本管理，但是也没有使用，那这个设定也就不生效啊，究竟谁在使用这些定义呢？</p><p>stater依赖</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-2"><p>SpringBoot中常见项目名称，定义了当前项目使用的所有依赖坐标，以达到减少依赖配置的目的，它才是使用依赖的那个</p><p>需要什么就导入相应的依赖就好，starter定义了使用某种技术时对于依赖的固定搭配格式，也是一种最佳解决方案，使用starter可以帮助开发者减少依赖配置</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>实际开发</p><ul><li>使用任意坐标时，仅书写GAV(groupId, artifactId, version)中的G和A，V由SpringBoot提供，除非SpringBoot未提供对应版本V</li><li>如发生坐标错误，再指定Version（要小心版本冲突）</li></ul><h2 id="引导类"><a href="#引导类" class="headerlink" title="引导类"></a>引导类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class Springboot0101QuickstartApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //启动spring容器</span><br><span class="line">        ConfigurableApplicationContext ctx = SpringApplication.run(Springboot0101QuickstartApplication.class, args);</span><br><span class="line">        </span><br><span class="line">        //获取bean对象</span><br><span class="line">        BookController bean = ctx.getBean(BookController.class);</span><br><span class="line">        System.out.println(&quot;bean======&gt;&quot; + bean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>SpringBoot的引导类是Boot工程的执行入口，运行main方法就可以启动项目</li><li>SpringBoot工程运行后初始化Spring容器，扫描引导类所在包加载bean</li></ul><h2 id="内嵌tomcat"><a href="#内嵌tomcat" class="headerlink" title="内嵌tomcat"></a>内嵌tomcat</h2><p>当前我们做的SpringBoot入门案例勾选了Spring-web的功能，并且导入了对应的starter</p><p>既然是web程序，肯定离不开使用web服务器，SpringBoot又顺便把web服务器也一起提供了，所以我们不用自己配置。如果不需要，也能用maven的依赖排除进而替换服务器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-json<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    //Tomcat在这里</span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第三个依赖就是tomcat对应的东西了，也是一个starter，打开看看</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.annotation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.annotation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.0.52<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-annotations-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-el<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.0.52<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.0.52<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-annotations-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>里面有一个核心的坐标，tomcat-embed-core，叫做tomcat内嵌核心。就是这个东西把tomcat功能引入到了我们的程序中的.</p><h3 id="内嵌Tomcat运行原理"><a href="#内嵌Tomcat运行原理" class="headerlink" title="内嵌Tomcat运行原理"></a>内嵌Tomcat运行原理</h3><p>Tomcat服务器是一款使用java语言开发的软件，熟悉tomcat的话应该知道tomcat安装目录中保存有很多jar文件。</p><p>既然是使用java语言开发的，运行的时候肯定符合java程序运行的原理，依靠对象运行。</p><p>如果是对象，是个对象都可以交给Spring容器管理，tomcat服务器运行其实是以对象的形式在Spring容器中运行的。具体运行的就是上前面提到的那个tomcat内嵌核心。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.0.52<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那既然是个对象，如果把这个对象从Spring容器中去掉是不是就没有web服务器的功能呢？没错，通过依赖排除可以去掉这个web服务器功能</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="更换内嵌Tomcat"><a href="#更换内嵌Tomcat" class="headerlink" title="更换内嵌Tomcat"></a>更换内嵌Tomcat</h3><p>根据SpringBoot的工作机制，用什么技术，加入什么依赖就行了。SpringBoot提供了3款内置的服务器：</p><ul><li><p>tomcat(默认)：apache出品，粉丝多，应用面广，负载了若干较重的组件</p></li><li><p>jetty：更轻量级，负载性能远不及tomcat</p></li><li><p>undertow：负载性能勉强跑赢tomcat</p></li></ul><p>想用哪个，加个坐标就OK。前提是把tomcat排除掉，因为tomcat是默认加载的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>核心思想就是用什么加入对应坐标就可以了。如果有starter，优先使用starter</p><p><strong>总结</strong></p><ol><li>内嵌Tomcat服务器是SpringBoot辅助功能之一</li><li>内嵌Tomcat工作原理是将Tomcat服务器作为对象运行，并将该对象交给Spring容器管理</li><li>变更内嵌服务器思想是去除现有服务器，添加全新的服务器</li></ol><h1 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h1><h2 id="属性配置"><a href="#属性配置" class="headerlink" title="属性配置"></a>属性配置</h2><p>SpringBoot默认提供一个application.properties，通过配置该文件就可以修改默认的配置，properties格式的文件书写规范是key&#x3D;value。如，修改port&#x3D;8081</p><p>在以前的工程里面，有很多xml、properties等配置文件，现在全可以写入application.properties。而且默认会有辅助提示</p><p>找到SpringBoot官方文档，打开查看附录中的Application Properties就可以获取到对应的配置项了，网站如下：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties">https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties</a></p><p>配置的功能不是凭空来的，就像工具一样，导入一些组件，除了我们最需要的功能，它还能附带一些小功能。相关的配置项也是这么添加进来的</p><h3 id="spring-boot-starter"><a href="#spring-boot-starter" class="headerlink" title="spring-boot-starter"></a>spring-boot-starter</h3><p>所有的starter中都会依赖下面这个starter，叫做spring-boot-starter。这个starter是所有的SpringBoot的starter的基础依赖，里面定义了SpringBoot相关的基础配置。很多功能都是跟随它一起来的</p><h3 id="配置文件类型"><a href="#配置文件类型" class="headerlink" title="配置文件类型"></a>配置文件类型</h3><p>SpringBoot除了支持properties格式的配置文件，还支持另外两种格式的配置文件。三种配置文件格式分别如下:</p><ul><li><p>properties格式（默认&#x2F;传统）</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">80</span></span><br></pre></td></tr></table></figure></li><li><p>yml格式（主流）</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">81</span></span><br></pre></td></tr></table></figure></li><li><p>yaml格式</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">82</span></span><br></pre></td></tr></table></figure></li></ul><p>优先级：properties &gt; yml &gt; yaml</p><p>以后我们开发只写yml文件</p><p>yml文件扩展了配置文件数量，并且配置方式更简洁，减少application.properties里面的内容，让配置看起来更井井有条</p><h4 id="yml文件提示配置"><a href="#yml文件提示配置" class="headerlink" title="yml文件提示配置"></a>yml文件提示配置</h4><p>提示其实是idea的，而不是spring的，需要在idea中配置</p><p>这个自动提示功能消失的原因还是蛮多的，如果想解决这个问题，就要知道为什么会消失，大体原因有如下2种：</p><ol><li><p>Idea认为你现在写配置的文件不是个配置文件，所以拒绝给你提供提示功能</p><p>解决方式如下：</p><ol><li>打开设置，<code>Files</code>→<code>Project Structure</code></li><li>在弹出窗口中左侧选择<code>Facets</code>，右侧选中Spring路径下对应的模块名称，也就是你自动提示功能消失的那个模块</li><li>点击Customize SpringBoot按钮，此时可以看到当前模块对应的配置文件是哪些了。如果没有你想要称为配置文件的文件格式，就有可能无法弹出提示</li></ol></li><li><p>Idea认定你是合理的配置文件，但是Idea加载不到对应的提示信息</p><p>第二种现象到原理篇再讲解。</p></li></ol><h1 id="SpringBoot整合"><a href="#SpringBoot整合" class="headerlink" title="SpringBoot整合"></a>SpringBoot整合</h1><p>下面以JUnit、MyBatis、MyBatis-Plus、Druid为例子。不要单学怎么整合这些，学的是思想，整合基本上都这些步骤</p><div class="tabs" id="test3"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test3-1">整合JUnit</button></li><li class="tab"><button type="button" data-href="#test3-2">MyBatis</button></li><li class="tab"><button type="button" data-href="#test3-3">MyBatis-Plus</button></li><li class="tab"><button type="button" data-href="#test3-4">Druid</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test3-1"><ol><li><p>创建项目</p><p>这个测试只整合JUnit，web的依赖就不用倒了，所以依赖选项为空，创建的项目中可以看见少了静态资源的目录，因为这两个是web带进来的，而我们现在没导入web依赖</p><p>最下面的那个Tests.java就是测试要用的那个类</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231121213835538.png" alt="image-20231121213835538"></p></li><li><p>创建dao接口和实现类，用以测试</p><ul><li>实现类用@Component注册成bean</li></ul></li><li><p>编写测试类DemoApplicationTests</p><ul><li><p>添加bean</p></li><li><p>编写测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoApplicationTests</span> &#123;</span><br><span class="line">    <span class="comment">//添加bean</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//编写测试方法</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>测试结果如下</p><p>有一个报红，但是功能是正确的</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231121220033678.png" alt="image-20231121220033678"></p></li></ol><p>回忆以前自动装配时我们扫包的操作，SpringBoot项目其实也需要，只是默认配置帮我们扫好了</p><p>P27</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-2"><p>MyBatis工作需要的内容：</p><ol><li>核心配置：数据库连接相关信息(连什么?连谁?什么权限)</li><li>映射配置：SQL映射(XML&#x2F;注解)</li></ol><p>实现配置</p><ol><li><p>创建项目</p><p>导依赖：SQL类中需要Mybatis 和 MySQL</p><p>因为我们没有引入starter-web，依赖如下，可以看出外置依赖和官方依赖命名的区别</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;-- 分割线 --&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>这里创文件的时候没关注前面，只顾着依赖，用的不是maven，导致最开始一直没有pom.xml文件</p></blockquote></li><li><p>编写配置类，用yml的文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/ssm_db</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure><p>上面用的是5版本MySQL的url，8版本MySQL的url还要配置时区和编码</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/ssm_db?serverTimezone=Asia/Shanghai</span></span><br></pre></td></tr></table></figure></li><li><p>查看依赖，自带的依赖是MySQL的8版本的，不一定适合我的数据库，下面是更换依赖的操作</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   </span><br></pre></td></tr></table></figure></li><li><p>创建实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各类方法可以用快捷键生成，也可以用lombok的注解</p></li><li><p>配置映射接口（Dao）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from tbl_book where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getById</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进行测试</p></li></ol><p><strong>总结</strong></p><ol><li><p>整合操作需要勾选MyBatis技术，也就是导入MyBatis对应的starter</p></li><li><p>数据库连接相关信息转换成配置</p></li><li><p>数据库SQL映射需要添加@Mapper被容器识别到</p></li><li><p>MySQL 8.X驱动强制要求设置时区</p><ul><li>修改url，添加serverTimezone设定</li><li>修改MySQL数据库配置</li></ul></li><li><p>驱动类过时，提醒更换为com.mysql.cj.jdbc.Driver</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-3"><p>MyBaits-Plus，国人开发的技术，符合中国人开发习惯，也比MyBaits更强大</p><ol><li><p>创建项目</p><p>导入依赖的时候发现没有MyBaits-Plus的依赖，现在没有就不要了，后面额外导入</p><p>看依赖的时候能看到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>但其实<code>spring-boot-starter-test</code>就已经包含了<code>spring-boot-starter</code></p></li><li><p>进入mvnrepository.com，搜索mybatis plus，依赖如下（随便找的，版本可能有问题）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.4.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>进行配置，因为MyBaits-Plus是MyBaits的增强，所以后期配置很类似</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/ssm_db</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">table-prefix:</span> <span class="string">tb1</span></span><br></pre></td></tr></table></figure></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-4"><p>前面整合MyBatis和MyBatisPlus的时候，使用的数据源对象都是SpringBoot默认的数据源对象，下面我们手工控制一下，自己指定了一个数据源对象，Druid</p><p>在没有指定数据源时，我们的配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/ssm_db?serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure><p>虽然没有指定数据源，但是根据SpringBoot的简化，肯定选了一个它认为最好的数据源对象HiKari</p><ol><li><p>创建文件</p><p>导入相关依赖，druid也是，需要自行添加，搜索时有2个，根据命名用<code>druid-spring-boot-starter</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid-spring-boot-starter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写配置文件</p><p>方法1：追加type</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/ssm_db</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">druid</span></span><br></pre></td></tr></table></figure><p>方法2：编写druid配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    druid: </span><br><span class="line">      driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">      url: jdbc:mysql://localhost:3306/ssm_db</span><br><span class="line">      username: root</span><br><span class="line">      password: root </span><br></pre></td></tr></table></figure></li><li><p>因为只是换了个数据源，所以后续操作没有改变</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="SSMP整合综合案例"><a href="#SSMP整合综合案例" class="headerlink" title="SSMP整合综合案例"></a>SSMP整合综合案例</h1><p>前面做了4个整合了，下面就通过一个稍微综合一点的案例，将所有知识贯穿起来，同时做一个小功能，体会一下</p><p>但是因为这东西书写太简单了，简单到瞬间写完，大量的时间做的不是这些整合工作。所以感觉SpringBoot整合其他技术的身影不多</p><h2 id="创建项目-1"><a href="#创建项目-1" class="headerlink" title="创建项目"></a>创建项目</h2><p>选择依赖时加入spring web和MySQL，因为后期用mybatis plus，就不添加mybatis了</p><p>手动添加mybatis plus 和 druid依赖，注意要加版本</p><p>修改项目配置，添加yml配置文件，修改端口号为80</p><h2 id="实体类开发（使用lombok）"><a href="#实体类开发（使用lombok）" class="headerlink" title="实体类开发（使用lombok）"></a>实体类开发（使用lombok）</h2><p>Lombok，一个Java类库，提供了一组注解，简化P0J0实体类开发</p><ol><li><p>项目中创建相关包和类，创建属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建get&#x2F;set方法</p><ul><li>手写</li><li>lombok的注解</li></ul><p>lombok使用</p><p>需要导入依赖，这个依赖也在parent里面，不需要指定版本了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用注解</p><table><thead><tr><th>name</th><th>作用</th></tr></thead><tbody><tr><td>@Data</td><td></td></tr><tr><td>@Getter 和 @Setter</td><td></td></tr><tr><td>@ALL</td><td></td></tr><tr><td>@NO</td><td></td></tr><tr><td></td><td></td></tr></tbody></table></li></ol><h2 id="数据层基础crud"><a href="#数据层基础crud" class="headerlink" title="数据层基础crud"></a>数据层基础crud</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>现在常用的数据层技术是mybatis plus 和 Druid，已经引入依赖了，现在是配置文件</p><p>MyBatisPlus技术默认的主键生成策略为雪花算法，生成的主键ID长度较大，和目前的数据库设定规则不相符，需要配置一下使MyBatisPlus使用数据库的主键生成策略，在application.yml中添加对应配置即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 80</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    druid:</span><br><span class="line">      driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">      url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC+8</span><br><span class="line">      username: root</span><br><span class="line">      password: root</span><br><span class="line"></span><br><span class="line">mybatis-plus:</span><br><span class="line">  global-config:</span><br><span class="line">    db-config:</span><br><span class="line">      table-prefix: tbl_  #设置表名通用前缀</span><br><span class="line">      id-type: auto  #设置主键id字段的生成策略为参照数据库设定的策略，当前数据库设置id生成策略为自增</span><br></pre></td></tr></table></figure><h3 id="crud"><a href="#crud" class="headerlink" title="crud"></a>crud</h3><ol><li><p>创建数据层接口</p><p>使用MyBatisPlus的标准通用接口BaseMapper加速开发，用@Mapper和泛型的指定</p><p>编写SQL语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from tbl_book where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getById</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>但其实MP简化了上述代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface BookDao extends BaseMapper&lt;Book&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，我们的接口继承了<code>BaseMapper&lt;V&gt;</code>，这是MP提供的，里面有默认的一套全面的方法</p></li><li><p>编写测试类</p><p>制作测试类测试结果，这个测试类制作是个好习惯，步子太大，咔，容易扯着蛋–师爷</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoTestCase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testGetById</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(bookDao.selectById(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSave</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">        book.setType(<span class="string">&quot;测试数据123&quot;</span>);</span><br><span class="line">        book.setName(<span class="string">&quot;测试数据123&quot;</span>);</span><br><span class="line">        book.setDescription(<span class="string">&quot;测试数据123&quot;</span>);</span><br><span class="line">        bookDao.insert(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">        book.setId(<span class="number">17</span>);</span><br><span class="line">        book.setType(<span class="string">&quot;测试数据abcdefg&quot;</span>);</span><br><span class="line">        book.setName(<span class="string">&quot;测试数据123&quot;</span>);</span><br><span class="line">        book.setDescription(<span class="string">&quot;测试数据123&quot;</span>);</span><br><span class="line">        bookDao.updateById(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span>&#123;</span><br><span class="line">        bookDao.deleteById(<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testGetAll</span><span class="params">()</span>&#123;</span><br><span class="line">        bookDao.selectList(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开启MyBatisPlus运行日志</p><p>因为基础的CRUD操作均由MyBatisPlus给我们提供了，所以开发者不需要书写SQL语句了，这样程序运行的时候就像黑盒一样，因为传递参数、封装SQL语句这些操作完全不是你开发出来的，所以查看执行期运行的SQL语句就成为当务之急</p><p>通过配置的形式就可以查阅执行期SQL语句</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">table-prefix:</span> <span class="string">tbl_</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="string">//标准输出</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure><p>再来看运行结果，就显示了运行期执行SQL的情况</p><p>此处设置的是日志的显示形式，当前配置的是控制台输出，当然还可以由更多的选择，根据需求切换即可</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>手工导入starter坐标（2个），mysql驱动（1个）</p></li><li><p>配置数据源与MyBatisPlus对应的配置</p></li><li><p>开发Dao接口（继承BaseMapper）</p></li><li><p>制作测试类测试Dao功能是否有效</p></li><li><p>使用配置方式开启日志，设置日志输出方式为标准输出即可查阅SQL执行日志</p></li></ol><h2 id="分页功能制作"><a href="#分页功能制作" class="headerlink" title="分页功能制作"></a>分页功能制作</h2><p>MyBatisPlus给我们提供了几乎所有的基础操作，包括分页</p><p>MyBatisPlus提供的分页操作API如下：</p><p>其中selectPage方法需要传入一个封装分页数据的对象，可以通过new的形式创建这个对象，当然这个对象也是MyBatisPlus提供的，别选错包了。创建此对象时需要指定两个分页的基本数据</p><p>当前显示第几页和每页显示几条数据可以通过创建Page对象时利用构造方法初始化这两个数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IPage page = new Page(2,5);</span><br></pre></td></tr></table></figure><p>将该对象传入到查询方法selectPage后，可以得到查询结果，但是我们会发现当前操作查询结果返回值仍然是一个IPage对象，因为这个IPage对象中封装了若干个数据，而查询的结果作为IPage对象封装的一个数据存在的，可以理解为查询结果得到后，又塞到了这个IPage对象中，其实还是为了高度的封装，一个IPage描述了分页所有的信息。</p><p>下面5个操作就是IPage对象中封装的所有信息了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testGetPage</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//当前显示第几页和每页显示几条数据</span></span><br><span class="line">    <span class="type">IPage</span> <span class="variable">page</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Page</span>(<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">    bookDao.selectPage(page, <span class="literal">null</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当前页码值</span></span><br><span class="line">    System.out.println(page.getCurrent());</span><br><span class="line">    <span class="comment">//每页显示数</span></span><br><span class="line">    System.out.println(page.getSize());</span><br><span class="line">    <span class="comment">//数据总量</span></span><br><span class="line">    System.out.println(page.getTotal());</span><br><span class="line">    <span class="comment">//总页数</span></span><br><span class="line">    System.out.println(page.getPages());</span><br><span class="line">    <span class="comment">//详细数据</span></span><br><span class="line">    System.out.println(page.getRecords());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义MyBatisPlus拦截器"><a href="#定义MyBatisPlus拦截器" class="headerlink" title="定义MyBatisPlus拦截器"></a>定义MyBatisPlus拦截器</h3><p>运行时这个分页功能当前是无效的。因为MyBatisPlus的内部机制。对于MySQL的分页操作使用limit关键字进行，而并不是所有的数据库都使用limit关键字实现的，这个时候MyBatisPlus为了制作的兼容性强，将分页操作设置为基础查询操作的升级版</p><p>基础操作中有查询全部的功能，而在这个基础上只需要升级一下（PLUS）就可以得到分页操作。所以MyBatisPlus将分页操作做成了一个开关，你用分页功能就把开关开启，不用就不需要开启这个开关</p><p>这个开关是通过MyBatisPlus的拦截器的形式存在的，具体设置方式如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MPConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>());</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="业务层开发"><a href="#业务层开发" class="headerlink" title="业务层开发"></a>业务层开发</h2><p>业务层开发和数据层开发其实有很大的区别，可能功能是一样的，但是：</p><ul><li><p>业务层的方法名定义<strong>一定</strong>要与业务有关，例如登录操作<code>login(String username,String password);</code></p></li><li><p>数据层的方法名定义<strong>一定</strong>与业务无关，例如根据用户名密码查询<code>selectByUserNameAndPassword(String username,String password);</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-定时任务</title>
      <link href="/2023/10/15/Linux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
      <url>/2023/10/15/Linux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Linux中的任务调度是指在特定的时间或条件下执行预定的任务。<code>crond</code>和<code>at</code>都是Linux中用于任务调度的工具。<code>crond</code>可以周期性地执行任务，而<code>at</code>则可以在指定的时间点执行任务。它们都可以帮助用户在特定的时间或条件下自动执行预定的任务，提高工作效率</p><h1 id="crond"><a href="#crond" class="headerlink" title="crond"></a>crond</h1><p><code>crond</code>是Linux系统中的一个守护进程，负责周期性地执行预定的任务。它根据预设的时间表（通常是<code>crontab</code>文件）来触发任务的执行。<code>crontab</code>文件包含了一系列的任务定义，每个任务定义包括了任务的执行时间、执行的命令或脚本等信息。<code>crond</code>会根据这些定义，按照设定的时间间隔周期性地执行任务。常见的时间间隔包括每分钟、每小时、每天、每周、每月等。</p><p>corntab [选项]</p><p>选项如下</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-e</code></td><td>编辑<code>corntab</code>文件</td></tr><tr><td><code>-l</code></td><td>查询<code>corntab</code>定时任务调度</td></tr><tr><td><code>-r</code></td><td>递归删除<code>corntab</code>定时任务调度</td></tr></tbody></table><p>编辑<code>crontab</code>文件的格式：<code>分 时 日 月 周 要执行的命令或脚本</code></p><h2 id="定时规则"><a href="#定时规则" class="headerlink" title="定时规则"></a>定时规则</h2><p>其中的<code>分 时 日 月 周</code>是<code>cron</code>的定时规则，也称为【cron表达式】，它还支持一些特殊字符和符号，例如通配符（*）、范围（-）、逗号（,）、间隔（&#x2F;）等，以提供更灵活的调度选项。</p><p><strong>示例</strong></p><ol><li><code>10 18 * * * ls /root/cat &gt;&gt; /home/user/watch.log</code>：每天18点10分执行<code>ls /root/cat &gt;&gt; /home/user/watch.log</code>命令</li><li><code>* 18 8 1 * ls /root/cat &gt;&gt; /home/user/watch.log</code>：每年1月8日的18点执行<code>ls /root/cat &gt;&gt; /home/user/watch.log</code>命令</li><li><code>0 9 * * 1-5 /home/myshell.sh</code>：每周一到周五的9点执行<code>/home/myshell.sh</code>脚本</li><li><code>0 9 * * 1,5 /home/myshell.sh</code>：每周一和每周五的9点执行<code>/home/myshell.sh</code>脚本</li><li><code>*/5 * * * * ls /root/cat &gt;&gt; /home/user/watch.log</code>：每隔5分钟执行<code>ls /root/cat &gt;&gt; /home/user/watch.log</code>命令</li></ol><h1 id="at"><a href="#at" class="headerlink" title="at"></a>at</h1><p><strong>简要介绍</strong></p><p><code>at</code>是另一个任务调度工具，它允许用户在指定的时间执行一次性的任务。与<code>crond</code>不同，<code>at</code>不会周期性地执行任务，而是在指定的时间点执行一次任务。用户可以使用<code>at</code>命令来创建任务，并指定任务的执行时间和要执行的命令或脚本。<code>at</code>命令可以接受多种时间格式，如绝对时间、相对时间等。</p><p><code>atd</code>（<code>at</code>守护进程）是一个后台进程，负责管理<code>at</code>命令提交的任务。<code>atd</code>进程会根据系统时间和任务的执行时间进行调度，并将任务分配给合适的执行环境。</p><p>默认情况下，<code>atd</code>守护进程每60秒检测作业队列，如果存在作业时间并且当前时间匹配，则运行</p><p><strong>基本语法</strong></p><p>在执行<code>at</code>命令前，我们得先确认<code>atd</code>守护进程是否在运行中：</p><ul><li><code>ps -ef | gerp atd</code>：查看活跃进程，后面接上管道命令过滤出<code>atd</code>线程</li></ul><p>确定<code>atd</code>线程开启后，我们可以使用<code>at</code>命令了，下面是<code>at</code>命令的说明</p><ul><li><code>at [选项] [时间]</code>：具体选项说明如下表</li></ul><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-m</code></td><td>指定任务执行完成后，通过邮件通知任务的所有者。</td></tr><tr><td><code>-l</code></td><td>列出待执行的任务列表。</td></tr><tr><td><code>-r</code></td><td>删除指定的任务。</td></tr><tr><td><code>-q 队列</code></td><td>指定任务队列的名称。</td></tr><tr><td><code>-t 时间</code></td><td>指定任务的执行时间。</td></tr><tr><td><code>-f 文件</code></td><td>指定要执行的命令或脚本文件。</td></tr><tr><td><code>-I</code></td><td>忽略任务执行时的标准输入。</td></tr><tr><td><code>-V</code></td><td>显示<code>at</code>命令的版本信息。</td></tr><tr><td><code>-c</code></td><td>显示任务的命令行内容。</td></tr></tbody></table><p>输入完<code>at</code>命令后就可以进入编辑状态，在此界面输入执行的命令或脚本，使用<code>Ctrl</code>+<code>D</code>退出</p><ul><li><code>atq</code>：可以查看队列中未执行的定时任务信息，包括任务编号</li><li><code>atrm 任务编号</code>：移除指定编号的定时任务</li></ul><h2 id="定时规则-1"><a href="#定时规则-1" class="headerlink" title="定时规则"></a>定时规则</h2><p>与<code>crontab</code>的定时规则不一样，<code>at</code>有很多种的定时规则：</p><table><thead><tr><th>时间规则</th><th>说明</th></tr></thead><tbody><tr><td>绝对时间</td><td>使用24小时制的绝对时间来指定任务的执行时间。例如，<code>at 12:30</code>表示任务将在当天的12:30执行。</td></tr><tr><td>相对时间</td><td>使用相对时间来指定任务的执行时间。相对时间可以是当前时间的偏移量。例如，<code>at now + 1 hour</code>表示任务将在当前时间的1小时后执行。时间单位还有：<code>days</code>，<code>minutes</code>，<code>weeks</code>。</td></tr><tr><td>特定日期和时间</td><td>指定具体的日期和时间来执行任务。例如，<code>at 2023-07-04 09:00</code>表示任务将在2023年7月4日的9:00执行。</td></tr><tr><td>关键字</td><td><code>at</code>指令支持一些关键字来指定特定的时间点，例如<code>midnight</code>（午夜）、<code>noon</code>（中午）和<code>teatime</code>（下午4点）。例如，<code>at midnight</code>表示任务将在每天的午夜执行。<code>today</code>,<code>tomorrow</code>也是可以的。</td></tr><tr><td>时间表达式</td><td>使用时间表达式来指定更复杂的时间规则。时间表达式使用特定的语法来描述任务的执行时间。例如，<code>at 10:00pm + 2 days</code>表示任务将在两天后的晚上10点执行。</td></tr></tbody></table><p><strong>示例</strong></p><ol><li><p>在晚上10点执行位于<code>/path/to/script.sh</code>的脚本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">$at 10:00 PM</span><br><span class="line">at&gt; /path/to/script.sh</span><br><span class="line">at&gt; Ctrl+D</span><br></pre></td></tr></table></figure></li><li><p>在当前时间的1小时后执行命令，将”Hello, world!”写入到<code>/path/to/output.txt</code>文件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">$at now + 1 hour</span><br><span class="line">at&gt; echo &quot;Hello, world!&quot; &gt; /path/to/output.txt</span><br><span class="line">at&gt; Ctrl+D</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux-常用命令</title>
      <link href="/2023/10/13/Linux%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/10/13/Linux%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Linux命令是一组用于在Linux操作系统上执行特定任务的命令。这些命令可以在终端窗口中使用，也可以通过脚本自动化执行。Linux命令可以用于管理文件和目录、安装和卸载软件、配置网络、查看系统状态等多种任务。在Linux中，命令通常由一个或多个单词组成，可以带有选项和参数，用于指定命令的行为和操作对象。Linux命令是Linux操作系统中的核心组件之一，掌握Linux命令可以帮助用户更好地管理和使用Linux系统。</p><h1 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h1><p><strong>基本介绍</strong></p><ol><li>man [命令|配置文件] ：获取该命令或配置文件的帮助信息，例如查看ls命令的帮助信息可以输入 man ls </li><li>help [命令]  ：获取Shell内置命令的帮助信息，例如 help cd 查看 cd 命令信息</li><li>–help ：一般所有的CLI程序都是命令和选项组成的，一般情况都有 –help 选项（有时候是 -h ），可以查看该命令及其选项将要说明</li></ol><div class="tabs" id="t1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#t1-1">man</button></li><li class="tab"><button type="button" data-href="#t1-2">help</button></li><li class="tab"><button type="button" data-href="#t1-3">--help</button></li><li class="tab"><button type="button" data-href="#t1-4">百度</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="t1-1"><p>man [命令|配置文件] ：获取该命令或配置文件的帮助信息，例如查看ls命令的帮助信息可以输入 man ls </p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="t1-2"><p>help [命令]  ：获取Shell内置命令的帮助信息，例如 help cd 查看 cd 命令信息</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="t1-3"><p> –help ：一般所有的CLI程序都是命令和选项组成的，一般情况都有 –help 选项（有时候是 -h ），可以查看该命令及其选项将要说明</p><blockquote><p>这个是后缀使用</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="t1-4"><p>面向百度编程</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="关机和重启"><a href="#关机和重启" class="headerlink" title="关机和重启"></a>关机和重启</h1><p><strong>基本介绍</strong></p><ol><li>shutdown -h now ：立刻关机</li><li>shutdown -h 数字n ：n分钟后关机</li><li>shutdown -r now ：立刻重启</li><li>shutdown -r 数字n ：n分钟后重启</li><li>halt ：关机，效果和 shutdown 一样，其实 -h 的 h 就是 halt</li><li>reboot ：立刻重启</li><li>sync ：将内存数据同步到磁盘</li></ol><p><strong>使用细节</strong></p><ol><li>不管关机还是重启，首先都应该运行 sync 命令，确保内存数据写入磁盘</li><li>目前的 shutdown | reboot | halt ，命令都已经在关机前进行了 sync ，但是以防万一，在生产环境建议至少手动执行一次 sync 。</li></ol><h1 id="用户登录和注销"><a href="#用户登录和注销" class="headerlink" title="用户登录和注销"></a>用户登录和注销</h1><p><strong>基本介绍</strong></p><ol><li>su - 用户名 ：切换用户，不填默认为切换root用户，等同于 su - root </li><li>logout ：注销用户</li></ol><p><strong>使用细节</strong></p><ol><li>logout 注销命令在图形运行级别无效（一般会提示 bash: logout: not login shell: use ‘exit’ ），在运行级别3（无界面终端）下有效</li><li>在Ubuntu中，第一次登录root用户时，可以使用 sudo su root ，输入用户密码切换到root用户，然后使用 passwd 修改密码，修改密码后面讲，这里有个坑</li><li>在一般情况下，我们登录时应该尽量不使用root（系统管理员）用户登录，因为其拥有最大权限，可能导致误操作。一般使用普通用户登录，需要时再使用 su root 切root用户</li></ol><h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><p>Linux系统是一个<strong>多用户多任务</strong>的操作系统，任何一个要使用系统资源的用户，都应该向系统管理员申请一个用户，然后使用该用户登录系统。下面我们会介绍一些系统管理员（root）用户用于管理用户的命令，这意味着这些命令有的必须拥有root用户权限才能执行</p><p>Root 只能有一个。</p><p>Root 用户能创建普通用户，每个用户创建的时候都有一个组，可以人为分配。默认是系统创建一个和他名字一样的组。<strong>每个用户都有自己的目录和权限</strong></p><h2 id="单用户"><a href="#单用户" class="headerlink" title="单用户"></a>单用户</h2><ul><li><p>添加用户</p><ol><li><p>useradd 新用户名 </p><p>创建用户，用户目录会自动创建在 &#x2F;home&#x2F;新用户名 </p></li><li><p>useradd -d 指定目录 新用户名</p></li></ol><p>   创建用户，用户目录会创建在 &#x2F;home&#x2F;指定目录 </p></li><li><p>修改密码</p><ol><li><p>passwd 用户名 </p><p>修改指定用户密码，如果不填用户名，会给当前用户设置密码。</p></li><li><p>passwd </p><p>改 Root 用户的密码，这就是前面的坑。别改错了</p></li></ol><blockquote><p>新密码是运行上面指令以后再输入</p></blockquote></li><li><p>删除用户</p><ol><li><p>userdel 用户名 </p><p>删除指定用户，但是保留其家目录（推荐）</p></li><li><p>userdel -r 用户名</p></li></ol><p>   删除指定用户及其用户目录（有风险）</p></li><li><p>切换用户</p><ol><li><p>su - 用户名</p><p>切用户</p><p>高权限切低权限不需要输密码，反过来需要。</p></li><li><p>exit&#x2F;logout</p><p>能切回高权限，切不用输密码</p><p>高权限切低权限后回来可以</p></li></ol></li><li><p>我是谁</p><ol><li>whoami</li></ol><p>   显示当前用户名</p><ol start="2"><li>who im i</li></ol><p>   显示当前终端的用户名、终端设备和登录时间等详细信息；</p></li></ul><p><strong>细节说明</strong></p><ol><li>passwd 修改密码命令，root用户在修改其他用户密码，如果忘记填写要修改的用户名，会修复当前root用户密码，这在生产环境中会导致很严重的后果</li><li>一般情况下，我们删除用户不会使用 userdel -r ，因为往往用户目录下仍有重要的数据，非必要应该保留该用户目录</li><li>root用户用 useradd 创建完用户后，系统会自动切换到新用户的目录；可以通过 su root 切换回root用户；root用户也可以使用 exit 或者 logout 切换回原用户</li><li>who am i 这条命令，本人实测必须在图形运行级别是无效的，假如你刚好和我一样使用的Ubuntu图形界面系统，可以使用 ctrl + alt + f5 进入运行级别3无界面终端进行测试。</li></ol><h2 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h2><ol><li>用户组概念说明：<ul><li>在Linux中，用户组是一组具有相同权限和访问权限的用户的集合。每个用户都必须属于至少一个用户组。</li><li>用户组可以用于管理文件和目录的访问权限，以及限制用户对系统资源的访问。</li><li>在Linux中，每个用户都有一个主组和多个附加组。用户的主组是在创建用户时指定的，而附加组是可以随时添加或删除的</li></ul></li><li>假如我们在创建用户时没有指定组，Linux会自动创建一个与用户名同名的组，然后将该用户指定到该同名组下</li></ol><ul><li><p>创建用户组：groupadd 组名</p></li><li><p>删除用户组：groupdel 用户组 </p></li><li><p>创建一个用户并指定用户组：useradd -g 用户组 新用户名 </p></li><li><p>修改用户的用户组：usermod -g 用户组 用户名 </p><blockquote><p>组就像户口，改了原来的就没了</p></blockquote></li></ul><p><strong>扩展</strong></p><p>用户和用户组相关文件：</p><ol><li><p>&#x2F;etc&#x2F;passwd</p><p>文件：</p><ul><li>解释：用户（user）的配置文件，记录用户的各种信息</li><li>内容： 用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录使用的Shell </li><li>示例： gallifrey:x:1000:1000:gallifrey display:&#x2F;home&#x2F;gallifrey:&#x2F;bin&#x2F;bash</li></ul></li><li><p>&#x2F;etc&#x2F;shadow</p><p>文件：</p><ul><li>解释：口令的配置文件</li><li>内容： 登录名:加密口令:最后修改时间:最小时间间隔:最大时间间隔:告警时间:不活动时间:失效时间:标志 </li><li>示例： mail:*:19411:0:99999:7:::</li></ul></li><li><p>&#x2F;etc&#x2F;group</p><p>文件：</p><ul><li>解释：组（group）的配置文件，</li><li>内容： 组名:口令:组标识号：组内用户列表 </li><li>示例： sambashare x:136:gallifrey</li></ul></li></ol><h1 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h1><p><strong>基本介绍</strong></p><p>运行级别的说明：</p><table><thead><tr><th>运行级别</th><th>使用频率</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>不常用</td><td>关机，系统停机状态，系统已关闭，没有任何服务或进程运行</td></tr><tr><td>1</td><td>不常用<br/>但是可用于找回丢失密码，后面示范</td><td>单用户模式，只有最基本的系统服务和进程运行，没有网络服务</td></tr><tr><td>2</td><td>不常用<br/>因为无网络服务</td><td>多用户模式，无网络服务</td></tr><tr><td>3</td><td>常用<br/>无图形界面节省资源，且多用户有网络服务，基本服务器都是该运行级别</td><td>多用户模式，有网络服务</td></tr><tr><td>4</td><td>不常用</td><td>保留级别，系统未使用</td></tr><tr><td>5</td><td>常用<br>个人使用的Linux系统，基本都会使用图形界面</td><td>图形用户界面，多用户模式，有网络服务</td></tr><tr><td>6</td><td>不常用</td><td>系统重启模式，用于重新启动系统。</td></tr></tbody></table><p>命令：</p><ol><li><p>init[0-6] ：切换运行级别0-6，例如 init 3 就是切换到运行级别3</p></li><li><p>who -r 或 runlevel ：可以查看当前的运行级别</p></li><li><p>systemctl get-default ：可以查看系统默认的运行级别</p></li></ol><p>   其中 multi-user.target 就是运行级别3</p><p>   graphical.target 就是运行级别5</p><ol start="4"><li>systemctl set-default [multi-user.target|graphical.target] ：设置运行级别3或5</li></ol><p><strong>细节说明</strong></p><ol><li><p>实际上CentOs7及之后的版本，采用了systemd作为系统初始化和管理的工具，对运行级别进行了简化。</p></li><li><p>systemd为了简化运行级别的管理，将所有的运行级别都映射到了不同的target中。</p><p> multi-user.target 代表的是文本模式下的多用户运行级别（运行级别3）</p><p>graphical.target 代表的是图形化界面下的多用户运行级别（运行级别5）</p></li><li><p>Ubuntu 15.04及更高版本已经使用了systemd来管理系统服务和运行级别。</p></li><li><p>在 &#x2F;lib&#x2F;systemd&#x2F;system 目录下可以看到可以指定运行级别的所有的target</p></li></ol><h2 id="找回密码示范"><a href="#找回密码示范" class="headerlink" title="找回密码示范"></a>找回密码示范</h2><h1 id="文件目录（最常用）"><a href="#文件目录（最常用）" class="headerlink" title="文件目录（最常用）"></a>文件目录（最常用）</h1><p><strong>基本介绍</strong></p><ol><li><p>pwd ：显示当前用户所在目录路径</p></li><li><p>cd 指定目录 ：切换到指定目录</p></li></ol><ul><li>cd ~ ：回到根目录，普通用户所在的用户目录，一般是 &#x2F;home&#x2F;用户名 ，root用户则是 &#x2F;root </li><li>cd .. ：返回上一级目录</li></ul><ol start="3"><li>ls 指定路径 ：列出指定路径目录的内容</li></ol><ul><li>ls -a ：列出当前目录的所有内容，包括以 . 开头的隐藏文件</li><li>ls -l ：列出当前目录的内容，单列输出详细内容</li><li>ls -al ：上面两个的组合</li><li>ls -h ：列出当前目录的内容，显示更符合人类习惯（文件大小显示从字节显示变为自适应单位）</li></ul><ol start="4"><li>mkdir 指定一级目录 ：创建一个一级目录，如 mkdir dog 在创建一个名为 dog 的目录</li></ol><ul><li>mkdir 指定路径指定目录 ：在指定路径创建一个目录，如 mkdir .&#x2F;dog 在当前目录创建 dog 目录， mkdir &#x2F;home&#x2F;用户目录&#x2F;dog 在用户目录下创建 dog 目录</li><li>mkdir -p 多级目录 ：创建多级目录，如 mkdir .&#x2F;animal&#x2F;dog 在当前目录创建 animal 目录，再在 animaml 目录下创建 dog 目录</li></ul><ol start="5"><li>rm 文件 ：删除文件</li></ol><ul><li>rmdir ：删除空目录</li></ul><pre><code> 注意：只能删除空目录，命令中间没有空格</code></pre><ul><li>rm -rf 目录 ：删除整个目录，</li></ul><pre><code> -f 是强制删除不提示 -r 是递归删除，就是强制递归删除所有文件</code></pre><ol start="6"><li><p>touch 文件名 ： 创建指定文件名的空文件，然后 touch &#x2F;home&#x2F;用户目录&#x2F;cat 就是在用户目录创建名为 cat 空文件</p></li><li><p>cp 原文件 目标路径 ：将原文件拷贝到目标路径下，例如 cp duck animal&#x2F; 就是将 duck 文件拷贝到 animal 目录下</p></li></ol><ul><li>cp -r 原目录 目标路径 ：将原目录递归拷贝到目标路径下，例如 cp -r animal zoo&#x2F; 就是将 animal 目录及其所有内容拷贝到 zoo 目录下</li><li>\cp -r 原目录 目标路径 ：将原目录递归拷贝到目标路径下，覆盖不提示</li></ul><ol start="8"><li>mv ：移动文件及重命名</li></ol><ul><li>mv 旧文件名 新文件名 ：在两个文件在同一个目录下执行 mv ，其实就是重命名文件，例如 mv anmail&#x2F;dog animal&#x2F;cat 就是把 animal 目录下 dog 文件重命名为 cat </li><li>mv 旧文件路径 新文件路径 ：当两个文件不在同一个路径下执行 mv ，可以移动文件（也可以重命名）例如 mv animal&#x2F;cat ctiy&#x2F;bat 将 animal 目录下的 cat 移动到 city 目录下并重命名为 bat</li></ul><ol start="9"><li>cat 文件名 ：查看文件内容</li></ol><ul><li>cat -n 文件名 ：查看文件内容，带上行号</li><li>cat 文件名 | more ：一般为了浏览方便，会加上 | more 使用 more  文本过滤器， | 是管道符号， more 的说明请看下面</li></ul><ol start="10"><li><pre><code>more</code></pre><p>：基于Vi编辑器的文本过滤器命令，可以以全屏的方式按页显示文本内容。</p><ul><li>除了常常和 cat 联用，也能直接 more 文件名 来查看文件</li><li>其内置了若干快捷键用于浏览操作，详情请看下表：</li></ul></li></ol><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>空格  Space</td><td>下翻一页</td></tr><tr><td>回车  Enter</td><td>下翻一行</td></tr><tr><td>q</td><td>退出</td></tr><tr><td>Ctrl + F</td><td>向下滚动一屏</td></tr><tr><td>Ctrl + B</td><td>向上滚动一屏</td></tr><tr><td>&#x3D;</td><td>输出当前行的行号</td></tr><tr><td>:f</td><td>输出文件名和当前行的行号</td></tr></tbody></table><ol><li>less ：文本查阅工具，功能与 more 类似，但是更加强大，支持各种显示终端，查找操作，而且是懒加载，大文件打开更快，效率更高。</li></ol><ul><li>使用方法 less 文件名 ，查看文件</li><li>其内置了若干快捷键用于浏览操作，详情请看下表：</li></ul><table><thead><tr><th align="left">操作</th><th>说明</th></tr></thead><tbody><tr><td align="left">空格  Space</td><td>下翻一页</td></tr><tr><td align="left">下箭头 pagedown</td><td>下翻一页</td></tr><tr><td align="left">上箭头 pageup</td><td>上翻一页</td></tr><tr><td align="left">&#x2F;字符串</td><td>搜索 字符串 ， n 上一个， N 下一个</td></tr><tr><td align="left">?字符串</td><td>搜索 字符串 ， n 上一个， N 下一个</td></tr><tr><td align="left">q</td><td>退出</td></tr></tbody></table><ol><li>echo ：输出命令</li></ol><ul><li>echo $PATH ：输出环境变量</li><li>echo hello world! ：输出 hello wrold！ 到控制台</li><li>echo hello world!&gt;&gt;learn.txt ：追加 hello world 文本到 learn.txt 文件中</li></ul><ol start="2"><li>head -n 数字x 文件名 ：查看指定文件头部x行数据，如果直接 head 文件名 ，会默认显示前面10行数据</li><li>tail -n 数字x 文件名 ：查看指定文件尾部x行数据，如果直接 tail 文件名 ，会默认显示最后10行数据</li></ol><ul><li>tail -f 文件名 ：实时监控文件尾部，如果有追加就会显示</li></ul><ol start="4"><li><blockquote><p>：输出重定向（覆盖写），示例如下</p></blockquote></li></ol><ul><li>ls -l &gt; nowdir.log ：将该目录下内容覆盖写入 nowdir.log 文件</li><li>cat pig.txt &gt; dog.txt ：将 pig.txt 文件内容覆盖写入 dog.txt 文件</li><li>如果重定向的文件不存在会自动创建再写入</li></ul><ol start="5"><li><blockquote><blockquote><p>：输出重定向（追加写），示例如下</p></blockquote></blockquote></li></ol><ul><li>cal &gt;&gt; today.log ：将当前日历信息追加写入 today.log 文件，注意： cal 是CentOs自带输出日历信息的命令，其他linux版本可能没有</li><li>cat pig.txt &gt;&gt; dog.txt ：将 pig.txt 文件内容追加写入 dog.txt 文件</li><li>如果重定向的文件不存在会自动创建再写入</li></ul><ol start="6"><li>ln ：软连接，相对于Windows中的快捷方式</li></ol><ul><li>ln -s &#x2F;root &#x2F;home&#x2F;myroot ：在 home 目录下创建 myroot 目录，进入该目录会进入 root 目录</li><li>删除软链接使用 rm 命令删除 软链接目录 就也可以了</li></ul><ol start="7"><li>history [数字n] ：查看最近执行过的n条命令（附带编号），不添加数字时，默认显示最近执行过的10条命令。</li><li>!数字n ：执行编号为 数字n 的命令，比如 history 1 查出来的最近执行过的1条命令记录是 383 ls -a ，此时输入 !383 就会执行 ls -a</li></ol><h1 id="时间日期"><a href="#时间日期" class="headerlink" title="时间日期"></a>时间日期</h1><h2 id="查看时间"><a href="#查看时间" class="headerlink" title="查看时间"></a>查看时间</h2><ol><li><p>date：显示当前时间</p></li><li><p>date “+指定时间格式” ：按指定时间格式显示日期，如 date “+%Y-%m-%d %H:%M:%S” ，会按照 年-月-日 时:分:秒 格式输出当前时间</p></li></ol><blockquote><p>年、月、日可以单独显现</p></blockquote><ol start="3"><li><p>cal ：显示当前月月历</p></li><li><p>cal 年份 ：显示指定年份所有月历</p></li></ol><h2 id="修改时间"><a href="#修改时间" class="headerlink" title="修改时间"></a>修改时间</h2><p>date -s “%Y-%m-%d %H:%M:%S” ：设置系统当前时间，如 date “2099-2-25 12:21:21” </p><blockquote><p>时间是字符串格式，即用””引用</p></blockquote><p><strong>细节说明</strong></p><ol><li>date “+指定时间格式” ，时间格式并不是一定要完整的，你可以指定任意格式的时间显示，如 date “+%Y %m” 只显示年份和月份， date “+%D—%D” 显示当前天数中间两次用 — 链接</li><li>cal 是CentOs自带输出日历信息的命令，其他linux版本可能没有，像Ubuntu默认没有 cal 命令</li></ol><h1 id="搜索查找"><a href="#搜索查找" class="headerlink" title="搜索查找"></a>搜索查找</h1><p><strong>基本介绍</strong></p><ol><li><p>find [搜索范围] [选项] 查询内容</p><p>搜索命令，可以按照文件名，用户，文件大小等条件搜索</p><ul><li>find [搜索范围] -n 文件名</li></ul><p>  按照文件名搜索文件，如 find &#x2F;home dog.txt 就是在 home 目录下搜索 dog.txt 文件</p><ul><li>find [搜索范围] -user 用户名</li></ul><p>  按照用户名搜索文件，如 find -user pig 就是搜索所有用户为 pig 的文件</p><ul><li>find [搜索范围] -size 数字n</li></ul><p>  搜索指定文件大小为 n 的文件，其中 +数字n 表示大于 n ， -数字n 表示小于 n ，单位有 k ， M ， G 。如 find &#x2F; -size +1G 就是搜索根目录下大于 1G 的文件</p></li><li><p>locate 文件名 ：快速定位文件路径</p></li></ol><p>   Linux中自己构建了数据库，帮助快速查找，但是这玩意不一定准</p><ol start="3"><li><p>updatedb ：更新locate数据库，root用户才有权限更新，保证上面那个</p></li><li><p>which 命令 ：用于查找命令的二进制文件位置，如 which ls 就是查找 ls 命令的程序位置</p></li><li><p>| ：管道符号，用于将前一个命令的结果传输给后面的命令处理，如上文中的 cat 文件名 | more </p></li><li><p>grep [选项] 查询内容 源文件</p><p>：过滤查找要压缩的文件[</p><ul><li>grep -n 查询内容 源文件 ：过滤查找，显示行号</li><li>grep -i 查询内容 源文件 ：过滤查找，忽略大小写</li><li>grep 常与 | 管道符号一起使用，查询文本内容，如 cat bird.txt | gerp -i “hello” ：查看 bird.txt 文本并查询 hello 忽略大小写</li></ul></li></ol><p><strong>细节说明</strong></p><ol><li>find 命令是递归搜索文件目录</li><li>locate 命令与 find 不同，它不会递归搜索文件目录， locate 命令利用建立好的locate数据库去搜索文件路径。locate数据库会保存系统所有的文件名称及其路径。因此第一次运行 locate 前得先执行 updatedb 命令</li><li>locate 因为查询数据库，所以比直接遍历文件系统快很多，但是为了保证数据准确性，root用户必须定期更新locate数据库</li><li>乌班图系统是默认没有 locate 命令的，可以使用 sudo apt install mlocate 来安装</li></ol><h2 id="压缩解压"><a href="#压缩解压" class="headerlink" title="压缩解压"></a>压缩解压</h2><p><strong>基本介绍</strong></p><ul><li>打包：是将多个文件和目录组合成一个单独的文件，以便于传输、备份或存档</li><li>压缩：是指通过使用特定的算法和技术，将文件或数据转换为较小的尺寸，以节省存储空间或减少数据传输所需的带宽</li></ul><p>生产压缩包其实包含了两个过程，将多个文件打包成一个包，然后再把包用压缩程序压缩成压缩包</p><p><strong>tar命令</strong></p><p> tar 是最常用的打包命令，使用  tar  程序打出来的包我们常称为 tar 包，tar 包文件的命令通常都是以  .tar 结尾的。生成 tar 包后，就可以用其它的程序来进行压缩了。常见的压缩程序有以下几种：</p><ol><li>gzip 是 GNU 组织开发的一个压缩程序， .gz  结尾的文件就是 gzip 压缩的结果。与 gzip 相对的解压程序是 gunzip。tar 中使用  -z  这个参数来调用gzip</li><li>bzip2 是一个压缩能力更强的压缩程序， .bz2  结尾的文件就是 bzip2 压缩的结果。与 bzip2 相对的解压程序是 bunzip2。tar 中使用 -j 这个参数来调用 bzip2。</li><li>compress 也是一个压缩程序，但是比较冷门。与 compress 相对的解压程序是 uncompress。 .Z  结尾的文件就是 bzip2 压缩的结果。tar 中使用 -Z  这个参数来调用 compress。</li></ol><p><strong>选项</strong></p><p> tar 常见选项如下</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-c</td><td>产生 .tar 打包文件</td></tr><tr><td>-x</td><td>解包 .tar 文件</td></tr><tr><td>-v</td><td>显示详细信息</td></tr><tr><td>-t</td><td>列出包中所有内容</td></tr><tr><td>-f</td><td>这个选项是必须的，指定操作涉及的文件名</td></tr><tr><td>-z</td><td>调用 giz，文件后缀是 .gz</td></tr><tr><td>-j</td><td>调用 bzip2，文件后缀是 .bz2</td></tr><tr><td>-Z</td><td>调用 compress，文件后缀是 .Z</td></tr></tbody></table><p><strong>示例</strong></p><p>其实选项顺序是没有固定写法的，但是如果你和我一样有选择困难症，可能参考将压缩程序的选项放在最前面的写法：</p><ol><li>tar -zcvf zoo.tar.gz dog bat pig ：打包 dog , bat , pig 文件并用gzip压缩，生产压缩包 zoo.tar ，显示详细信息</li><li>tar -zxvf zoo.tar.gz ：解压 zoo.tar.gz 压缩包并解包，显示详细信息</li><li>tar -cxf zoo.tar dog bat pig ：打包 dog , bat , pig 文件，生成tar包 zoo.tar </li><li>tar -xvf zoo.tar ：解包文件 zoo.tar</li></ol><p>举一反三就有 tar -jcvf ， tar -jxvf ， tar -Zcvf 和 tar -Zxvf 等等</p><p><strong>更多</strong></p><p>在Windows中，我们更多会使用 .rar 和 .zip 为后缀的压缩包，在Linux系统要生成或者解压这些压缩包，我们可以使用 zip 和 unzip ， rar 和 unrar 命令。但是zip和rar程序在不同Linux系统中不一定自带的，可能需要我们自行安装</p><p>另外 zip 和 unzip ， rar 和 unrar 直接执行是包括【打包】和【压缩】或者【解包】和【解压】两个动作的，一般用法如下：</p><ol><li>rar a jpg.rar *.jpg ：rar格式的压缩，需要先下载 rar for linux 压缩打包目录里所有jpg文件</li><li>zip jpg.zip *.jpg ：zip格式的压缩，需要先下载 zip for linux 压缩打包目录里所有jpg文件</li><li>unrar e a.rar ：解压 rar</li><li>unzip jpg.zip ：解压 zip</li></ol><p>更多使用方法，请自行 man 查阅帮助文档或 –help 查看选项简要说明</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-介绍及虚拟机配置</title>
      <link href="/2023/10/12/Linux%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/10/12/Linux%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux前置"><a href="#Linux前置" class="headerlink" title="Linux前置"></a>Linux前置</h1><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310312106430.png"></p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p><strong>服务器领域</strong></p><p>linux在服务器领域的应用是最强的。linux免费、稳定、高效等特点在这里得到了很好的体现，尤其在一些高端领域尤为广泛。</p><p>嵌入式领域<br>linux运行稳定、对网络的良好支持性、低成本，且可以根据需要进行软件裁剪，内核最小可以达到几百KB等特点，使其近些年来在嵌入式领域的应用得到非常大的提高</p><h2 id="Linux和Unix的关系"><a href="#Linux和Unix的关系" class="headerlink" title="Linux和Unix的关系"></a>Linux和Unix的关系</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310312109303.png"></p><h2 id="VM和Linux的安装"><a href="#VM和Linux的安装" class="headerlink" title="VM和Linux的安装"></a>VM和Linux的安装</h2><h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><p>Linux的文件系统是采用级层式的树状目录结构，在此结构中的最上层是根目录，然后在此目录下再创建其他的目录。</p><blockquote><p>在Linux世界里，一切皆文件。Linux系统会把硬件，网络，系统等各种东西映射成文件。</p></blockquote><p>因此与Windows不同，Linux中的目录结构是有规范的，不同的目录承载着不同的功能。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310312113041.png"></p><h2 id="具体的目录结构"><a href="#具体的目录结构" class="headerlink" title="具体的目录结构"></a>具体的目录结构</h2><table><thead><tr><th>目录</th><th>使用频率</th><th>说明</th></tr></thead><tbody><tr><td>&#x2F;bin</td><td>【常用】如 &#x2F;usr&#x2F;bin , &#x2F;usr&#x2F;local&#x2F;bin</td><td>Binary的简写，存放着最常用的程序（命令）</td></tr><tr><td>&#x2F;sbin</td><td>【常用】如 &#x2F;usr&#x2F;sbin , &#x2F;usr&#x2F;local&#x2F;sbin</td><td>Super User Binary的简写，存放系统管理员使用的系统管理程序（命令）</td></tr><tr><td>&#x2F;home</td><td>【常用】如 &#x2F;home&#x2F;UserName</td><td>在Linux中每一个普通用户都有一个自己的目录，一般以自己的用户名命名</td></tr><tr><td>&#x2F;root</td><td>【常用】</td><td>系统管理员的目录，也称为超级权限者的用户目录</td></tr><tr><td>&#x2F;lib</td><td>【不常用】</td><td>系统开机所需最基本的动态链接共享库，其作用类似于Windows里的DDL文件。几乎所有的应用程序都需要用到这些共享库</td></tr><tr><td>&#x2F;lost+found</td><td>【不常用】</td><td>一个隐藏目录，一般情况是空的，在系统非法关机后，会记录一些文件</td></tr><tr><td>&#x2F;etc</td><td>【常用】</td><td>存放所有的系统管理所需要的配置文件会子目录，如MySQL的 my.conf 配置文件</td></tr><tr><td>&#x2F;usr</td><td>【常用】</td><td>重要目录，存放用户很多的应用程序和文件，类型Windows下的program files目录</td></tr><tr><td>&#x2F;boot</td><td>【常用】</td><td>存放启动Linux时的一些核心文件，包括连接文件和镜像文件</td></tr><tr><td>&#x2F;proc</td><td>【不能动】</td><td>这是一个虚拟的目录，所系统内存的映射，访问这个目录可以获取系统信息</td></tr><tr><td>&#x2F;srv</td><td>【不能动】</td><td>service的简写，存放一些服务启动后需要提取的数据</td></tr><tr><td>&#x2F;sys</td><td>【不能动】</td><td>Linux内核2.6后的重大变化，目录下安装了2.6内核新出现的一个文件系统 sysfs</td></tr><tr><td>&#x2F;tmp</td><td>【不常用】</td><td>存放一些临时文件的目录</td></tr><tr><td>&#x2F;dev</td><td>【不常用】</td><td>类似Windows的设备管理器，存放所有硬件的文件映射</td></tr><tr><td>&#x2F;media</td><td>【常用】</td><td>Linux系统会把自动识别到的一些设备挂载到该目录下面，如U盘，光驱等等</td></tr><tr><td>&#x2F;mnt</td><td>【常用】</td><td>系统提供该目录给用户临时挂别的文件系统，可以把外部存储挂载到 &#x2F;mnt&#x2F; 上，然后在该目录查看内容。</td></tr><tr><td>&#x2F;opt</td><td>【不常用】</td><td>给主机额外安装软件的安装包所存放的目录，默认为空。</td></tr><tr><td>&#x2F;usr&#x2F;local</td><td>【常用】</td><td>给主机额外安装软件的目录。</td></tr><tr><td>&#x2F;var</td><td>【常用】</td><td>用于存放不断扩充（追加）的文件，例如日志文件</td></tr><tr><td>&#x2F;selinux</td><td>【不常用】</td><td>系统安全的目录</td></tr></tbody></table><h1 id="远程登录到Linux服务器"><a href="#远程登录到Linux服务器" class="headerlink" title="远程登录到Linux服务器"></a>远程登录到Linux服务器</h1><p>为什么需要远程登录Linux？<br>公司开发时候，具体的应用场景是这样的</p><ol><li>Linux服务器是开发小组共享</li><li>正式上线的项目是运行在公网</li><li>因此程序 员需要远程登录到Linux进行项目管理或者开发</li><li>画出简单的网络拓扑示意图(帮助理解)</li><li>远程登录客户端有Xshell6，Xftp6，我们学习使用Xshell 和Xftp6 ，其它的远程工具大同小异</li></ol><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310312119731.png"></p><h2 id="Xshell6"><a href="#Xshell6" class="headerlink" title="Xshell6"></a>Xshell6</h2><p>Xshell是目前最好的远程登录到Linux操作的软件，流畅的速度并且完美解决了中文乱码的问题，是目前程序员首选的软件。</p><p>Xshell是一个强大的安全终端模拟软件，它支持SSH1, SSH2,以及Microsoft Windows平台的TELNET协议。</p><p>Xshell可以在Windows界面下用来访问远端不同系统下的服务器，从而比较好的达到远程控制终端的目的</p><h1 id="Vi与Vim"><a href="#Vi与Vim" class="headerlink" title="Vi与Vim"></a>Vi与Vim</h1><p>Vi是Linux系统内置的文本编辑器</p><p>Vim可以看做Vi的升级版本，具有程序编辑功能，可以主动设置以字体的颜色辨别语法正确性，方便程序设计。拥有代码补全，编译错误跳转等方便编程的等丰富功能。</p><h2 id="三种模式"><a href="#三种模式" class="headerlink" title="三种模式"></a>三种模式</h2><p>Vi和Vim有三种常用模式</p><div class="tabs" id="t1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#t1-1">**正常模式**</button></li><li class="tab"><button type="button" data-href="#t1-2">**插入模式**</button></li><li class="tab"><button type="button" data-href="#t1-3">**命令行模式**</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="t1-1"><p>当我们用vim或者vi打开一个文档时，默认进入的模式。在这个模式下，我们可以用方向键移动光标，可用【删除字符】或者【删除整行】来处理档案内容，也可以用【复制】，【粘贴】来处理文件数据</p><p>快捷键：</p><ol><li>在正常模式下，输入数字n+ yy 可以复制光标往下n行数据，例如 5yy 就是复制光标向下5行数据，输入 p 就可以粘贴刚刚复制的内容</li><li>在正常模式下，输入数字n+ dd 可以删除光标往下n行数据，例如 5yy 就是删除光标向下5行数据</li><li>在正常模式下，输入 gg 可以到定位到文档首行，输入 G 可以定位到文档末行</li><li>在正常模式下，输入 u 可以执行撤销操作</li><li>在正常模式下，输入数字n，然后输入 shift + g 可以定位到第n行，例如：输入 5 ，然后输入 shift + g 就是定位到第5行数据</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="t1-2"><p>按下 i , I , o , O , a , A , r , R 任何一个键可以进入插入模式，一般来说按 i 就可以了</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="t1-3"><p>正常模式下输入 : 可以进入命令行模式。使用相关命令，可以完成【读取】，【存盘】，【替换】，【离开】，【显示行号】等操作。</p><p>快捷键：</p><ol><li>使用 &#x2F; 进入命令行模式后，输入任何你想查找的 单词或语句 后按下回车可以查找该 单词\语句 ，输入 n 可以查找下一个，输入 N 可以查找上一个。</li><li>使用 ： 进入命令行模式后，输入 set nu 可以设置行号，输入 set nonu 可以取消行号设置</li><li>使用 ： 进入命令行模式后，输入 set list 可以查看特殊字符，输入 set nolist 可以取消设置</li><li>使用 ： 进入命令行模式后，输入 h 可以查看帮助</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>更多内容可以查看：<a href="https://vimcdoc.sourceforge.net/doc/quickref.html">Vim官方文档</a></p><h2 id="模式切换"><a href="#模式切换" class="headerlink" title="模式切换"></a>模式切换</h2><ol><li>在终端下，我们可以使用 vi xxx  或 vim xxx 进入相应编辑器的正常模式浏览文件</li><li>在正常模式下，我们可以输入 i 或上面提到的任何一个字母进入插入模式进行文本编辑</li><li>在插入模式下，我们可以按 esc 键退出插入模式</li><li>在正常模式下，我们可以输入 <strong>:</strong> 或者 <strong>&#x2F;</strong> 进入命令行模式（注意 : 和 &#x2F; 功能不一样）</li><li>在命令行模式下，我们可以<ul><li>输入: wq 保存退出到终端 （write&amp;quit）</li><li>输入: q 直接退出到终端</li><li>输入: q！ 强制直接退出到终端</li><li>输入: wq！ 强制保存退出到终端</li></ul></li><li>在命令行模式下，我们可以按 esc 键退出命令行模式</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 虚拟机安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis-缓存及分页插件</title>
      <link href="/2023/10/10/Mybatis04%E7%BC%93%E5%AD%98/"/>
      <url>/2023/10/10/Mybatis04%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Mybatis的缓存"><a href="#Mybatis的缓存" class="headerlink" title="Mybatis的缓存"></a>Mybatis的缓存</h1><h2 id="MyBatis的一级缓存"><a href="#MyBatis的一级缓存" class="headerlink" title="MyBatis的一级缓存"></a>MyBatis的一级缓存</h2><p>一级缓存是SqlSession级别的，通过<strong>同一个SqlSession 对象</strong>查询的数据会被缓存，下次查询<strong>相同的数据</strong>，就会从缓存中直接获取，不会从数据库重新访问。一级缓存默认开启</p><p>使一级缓存失效的四种情况:</p><ol><li><p>不同的SqlSession对应不同的一级缓存</p><p>一级缓存的范围是SqlSession，不同的SqlSession对应不同的一级缓存</p></li><li><p>同一个SqlSession但是查询条件不同</p></li><li><p>同一个SqlSession两次查询期间执行了任何一次增删改操作</p><p>为了确保数据的正确，只要一改就会清空，后面二级缓存也一样</p></li><li><p>同一个SqlSession两次查询期间手动清空了缓存</p></li></ol><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">不同的SqlSession</button></li><li class="tab"><button type="button" data-href="#test1-2">查询条件不同</button></li><li class="tab"><button type="button" data-href="#test1-3">执行修改操作</button></li><li class="tab"><button type="button" data-href="#test1-4">手动清空缓存</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p>不同的SqlSession对应不同的一级缓存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCache</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line">    <span class="type">CacheMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(CacheMapper.class);</span><br><span class="line">    <span class="type">Emp</span> <span class="variable">emp1</span> <span class="operator">=</span> mapper.getEmpById(<span class="number">3</span>);</span><br><span class="line">    System.out.println(emp1);</span><br><span class="line">    System.out.println(<span class="string">&quot;========第二次调用========从缓存中取数据&quot;</span>);</span><br><span class="line">    <span class="type">Emp</span> <span class="variable">emp2</span> <span class="operator">=</span> mapper.getEmpById(<span class="number">3</span>);</span><br><span class="line">    System.out.println(emp2);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;\n========即使用的不是同一个Mapper，也同样从缓存中取(同一个sqlsession)========&quot;</span>);</span><br><span class="line">    <span class="type">CacheMapper</span> <span class="variable">mapper2</span> <span class="operator">=</span> sqlSession.getMapper(CacheMapper.class);</span><br><span class="line">    <span class="type">Emp</span> <span class="variable">empByMapper2</span> <span class="operator">=</span> mapper2.getEmpById(<span class="number">3</span>);</span><br><span class="line">    System.out.println(empByMapper2);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;\n========一级缓存的范围在sqlsession中，换一个新的sqlsession就会再次用sql读取数据========&quot;</span>);</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession2</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line">    <span class="type">CacheMapper</span> <span class="variable">mapper2BySqlSession2</span> <span class="operator">=</span> sqlSession2.getMapper(CacheMapper.class);</span><br><span class="line">    System.out.println(mapper2BySqlSession2.getEmpById(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310191104641.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p>同一个SqlSession但是查询条件不同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCache3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line">    <span class="type">CacheMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(CacheMapper.class);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;=====第一次获取数据=====&quot;</span>);</span><br><span class="line">    <span class="type">Emp</span> <span class="variable">emp1</span> <span class="operator">=</span> mapper.getEmpById(<span class="number">3</span>);</span><br><span class="line">    System.out.println(emp1);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;\n=====查询条件不同=====&quot;</span>);</span><br><span class="line">    <span class="type">Emp</span> <span class="variable">emp2</span> <span class="operator">=</span> mapper.getEmpById(<span class="number">5</span>);</span><br><span class="line">    System.out.println(emp2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310191104217.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p>同一个SqlSession两次查询期间执行了任何一次增删改操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCache2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line">    <span class="type">CacheMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(CacheMapper.class);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;=====第一次获取数据=====&quot;</span>);</span><br><span class="line">    <span class="type">Emp</span> <span class="variable">emp1</span> <span class="operator">=</span> mapper.getEmpById(<span class="number">3</span>);</span><br><span class="line">    System.out.println(emp1);</span><br><span class="line">    <span class="type">Emp</span> <span class="variable">emp2</span> <span class="operator">=</span> mapper.getEmpById(<span class="number">3</span>);</span><br><span class="line">    System.out.println(emp2);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;\n=====进行增删改操作=====&quot;</span>);</span><br><span class="line">    mapper.insetEmp(<span class="keyword">new</span> <span class="title class_">Emp</span>(<span class="literal">null</span>, <span class="string">&quot;Joey&quot;</span>, <span class="number">44</span>, <span class="string">&quot;男&quot;</span>, <span class="string">&quot;8888@gmai.com&quot;</span>));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;\n=====同一个sqlsession，再获取数据=====&quot;</span>);</span><br><span class="line">    <span class="type">Emp</span> <span class="variable">emp3</span> <span class="operator">=</span> mapper.getEmpById(<span class="number">3</span>);</span><br><span class="line">    System.out.println(emp3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310191104525.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><p>同一个SqlSession两次查询期间手动清空了（一级）缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCache4</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line">    <span class="type">CacheMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(CacheMapper.class);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;=====第一次获取数据=====&quot;</span>);</span><br><span class="line">    <span class="type">Emp</span> <span class="variable">emp1</span> <span class="operator">=</span> mapper.getEmpById(<span class="number">3</span>);</span><br><span class="line">    System.out.println(emp1);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;\n=====两次查询期间手动清空缓存=====&quot;</span>);</span><br><span class="line">    sqlSession.clearCache();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;\n=====再次查询id=3的emp=====&quot;</span>);</span><br><span class="line">    <span class="type">Emp</span> <span class="variable">emp2</span> <span class="operator">=</span> mapper.getEmpById(<span class="number">3</span>);</span><br><span class="line">    System.out.println(emp2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310191105166.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="MyBatis的二级缓存"><a href="#MyBatis的二级缓存" class="headerlink" title="MyBatis的二级缓存"></a>MyBatis的二级缓存</h2><p>二级缓存是SqlSessionFactory级别，范围比一级缓存大，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取</p><p>二级缓存开启的条件：</p><ol><li>在核心配置文件中，设置全局配置属性<code>cacheEnabled=“true&quot;</code>，默认为true，不需要设置</li><li>在映射文件中设置标签<code>&lt;cache /&gt;</code></li><li>二级缓存必须在SqlSession关闭或提交之后有效</li><li>查询的数据所转换的实体类类型必须实现序列化的接口</li></ol><p>使二级缓存失效的情况：</p><ol><li><p><strong>两次查询之间执行了任意的增删改</strong>，会使一级和二级缓存同时失效</p></li><li><p>没有提交sqlsession时，数据会保存在一级缓存中，提交后，会保存在二级缓存中。</p></li></ol><p>缓存有个属性是命中率，值有2中情况</p><ol><li>值为0：缓存中没有需要的结果</li><li>值非0：缓存中有需要的结果</li></ol><p>测试</p><ol><li><p>要把Emp Class加上<code>implements Serializable</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCacheTwo</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//这里不能用工具类了，因为每次都会创建新的sqlsessionfactory</span></span><br><span class="line">    <span class="comment">//        SqlSession sqlSession = SqlSessionUtils.getSqlSession();</span></span><br><span class="line">    <span class="comment">//        CacheMapper mapper = sqlSession.getMapper(CacheMapper.class);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//只要是同一个sqlsessionfactory获得的sqlsession就可以</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(is);</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession1</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">CacheMapper</span> <span class="variable">mapper1</span> <span class="operator">=</span> sqlSession1.getMapper(CacheMapper.class);</span><br><span class="line">        System.out.println(mapper1.getEmpById(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Cache Hit Ratio：缓存命中率，指的是在缓存中有没有这条数据&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;=====二级缓存未打开，没从缓存中获取数据=====&quot;</span>);</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession2</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">CacheMapper</span> <span class="variable">mapper2</span> <span class="operator">=</span> sqlSession2.getMapper(CacheMapper.class);</span><br><span class="line">        System.out.println(mapper2.getEmpById(<span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310191107676.png"></p></li><li><p>关闭sqlSession，再看是用sql从数据库读取数据还是从缓存中取数据：</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310191108932.png"></p></li></ol><h3 id="二级缓存的相关配置"><a href="#二级缓存的相关配置" class="headerlink" title="二级缓存的相关配置"></a>二级缓存的相关配置</h3><p>在mapper配置文件中添加的cache标签可以设置一些属性:</p><ol><li><p>eviction属性：缓存回收策略</p><p>LRU(Least Recently Used) ：最近最少使用的:移除最长时间不被使用的对象。</p><p>FIFO(First in First out)：先进先出:按对象进入缓存的顺序来移除它们。</p><p>SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。</p><p>WEAK –弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。</p><p>默认的是 LRU。</p></li><li><p>flushInterval属性：刷新间隔，单位毫秒</p><p>默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句（增删改） 时刷新</p></li><li><p>size属性：引用数目，正整数</p><p>代表缓存最多可以存储多少个对象，太大容易导致内存溢出</p></li><li><p>readOnly属性：只读，true&#x2F;false</p><p>true：只读缓存; 会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。【性能好】</p><p>false：读写缓存; 会返回缓存对象的拷贝(通过序列化)。这会慢一些，但是安全，因此默认是 false。【安全】</p></li></ol><h2 id="MyBatis缓存查询的顺序"><a href="#MyBatis缓存查询的顺序" class="headerlink" title="MyBatis缓存查询的顺序"></a>MyBatis缓存查询的顺序</h2><p>先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用。</p><p>如果二级缓存没有命中，再查询一级缓存</p><p>如果一级缓存也没有命中，则查询数据库</p><p>SqlSession关闭之后，一级缓存中的数据会写入二级缓存。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310191107676.png"></p><h1 id="分页插件的配置及使用"><a href="#分页插件的配置及使用" class="headerlink" title="分页插件的配置及使用"></a>分页插件的配置及使用</h1><h2 id="分页插件配置"><a href="#分页插件配置" class="headerlink" title="分页插件配置"></a>分页插件配置</h2><ol><li><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置分页插件</p><p>在MyBatis的核心配置文件中配置插件，注意顺序</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置分页插件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="分页插件的使用"><a href="#分页插件的使用" class="headerlink" title="分页插件的使用"></a>分页插件的使用</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310191527610.png"></p><ol><li><p>在查询功能之前使用 PageHelper.startPage(int pageNum, int pageSize) 开启分页功能</p><ul><li>pageNum:当前页的页码</li><li>pageSize:每页显示的条数</li></ul></li><li><p>在查询获取list集合之后，使用PageInfo pageInfo &#x3D; new PageInfo&lt;&gt;(List list, int navigatePages)获取分页相关数据</p><ul><li>list:分页之后的数据</li><li>navigatePages:导航分页的页码数</li></ul></li><li><p>分页相关数据</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">PageInfo<span class="punctuation">&#123;</span></span><br><span class="line">    pageNum=<span class="number">8</span><span class="punctuation">,</span></span><br><span class="line">    pageSize=<span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">    size=<span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">    startRow=<span class="number">29</span><span class="punctuation">,</span></span><br><span class="line">    endRow=<span class="number">30</span><span class="punctuation">,</span></span><br><span class="line">    total=<span class="number">30</span><span class="punctuation">,</span></span><br><span class="line">    pages=<span class="number">8</span><span class="punctuation">,</span></span><br><span class="line">    ist=Page <span class="punctuation">&#123;</span></span><br><span class="line">    count=<span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    pageNum=<span class="number">8</span><span class="punctuation">,</span> </span><br><span class="line">    pageSize=<span class="number">4</span><span class="punctuation">,</span> </span><br><span class="line">    startRow=<span class="number">28</span><span class="punctuation">,</span> </span><br><span class="line">    endRow=<span class="number">32</span><span class="punctuation">,</span> </span><br><span class="line">    total=<span class="number">30</span><span class="punctuation">,</span> </span><br><span class="line">    pages=<span class="number">8</span><span class="punctuation">,</span> </span><br><span class="line">    reasonable=<span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> </span><br><span class="line">    pageSizeZero=<span class="literal"><span class="keyword">false</span></span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">prePage=<span class="number">7</span><span class="punctuation">,</span> </span><br><span class="line">nextPage=<span class="number">0</span><span class="punctuation">,</span> </span><br><span class="line">isFirstPage=<span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> </span><br><span class="line">isLastPage=<span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> </span><br><span class="line">hasPreviousPage=<span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> </span><br><span class="line">hasNextPage=<span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> </span><br><span class="line">navigatePages=<span class="number">5</span><span class="punctuation">,</span> </span><br><span class="line">navigateFirstPage4<span class="punctuation">,</span> </span><br><span class="line">navigateLastPage8<span class="punctuation">,</span> </span><br><span class="line">navigatepageNums=<span class="punctuation">[</span><span class="number">4</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">,</span> <span class="number">6</span><span class="punctuation">,</span> <span class="number">7</span><span class="punctuation">,</span> <span class="number">8</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>pageNum:当前页的页码</li><li>pageSize:每页显示的条数</li><li>size:当前页显示的真实条数</li><li>total:总记录数</li><li>pages:总页数</li><li>prePage:上一页的页码</li><li>nextPage:下一页的页码</li><li>isFirstPage&#x2F;isLastPage:是否为第一页&#x2F;最后一页</li><li>hasPreviousPage&#x2F;hasNextPage:是否存在上一页&#x2F;下一页</li><li>navigatePages:导航分页的页码数</li><li>navigatepageNums:导航分页的页码，[1,2,3,4,5]</li></ul></li></ol><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * limit    index，pagesize</span></span><br><span class="line"><span class="comment">     * index    当前页的起始索引</span></span><br><span class="line"><span class="comment">     * pageSize 每页显示的条数</span></span><br><span class="line"><span class="comment">     * pageNum  当前页的页码</span></span><br><span class="line"><span class="comment">     * 当前页的起始索引 = 每页条数 * 页码 - 1</span></span><br><span class="line"><span class="comment">     * index = pageNum * pageSize - 1</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 通过索引获得数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 使用MyBatis的分页插件，实现分页功能：</span></span><br><span class="line"><span class="comment">     * 1。需要在查询功能之前开启分页</span></span><br><span class="line"><span class="comment">     * PageHelper.startPage(2, 4);</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 2。在查询功能之后获取分页相关信息</span></span><br><span class="line"><span class="comment">     *   PageInfo&lt;Emp&gt; pages = new PageInfo&lt;&gt;(emps, 5); 5表示导航分页的数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(is);</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        <span class="type">EmpMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpMapper.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n查询功能前开启分页&quot;</span>);</span><br><span class="line">        PageHelper.startPage(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">        List&lt;Emp&gt; emps = mapper.selectByExample(<span class="literal">null</span>);</span><br><span class="line">        emps.forEach(emp -&gt; System.out.println(emp));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        PageInfo&lt;Emp&gt; pages = <span class="keyword">new</span> <span class="title class_">PageInfo</span>&lt;&gt;(emps, <span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;PageInfo-----&gt;&quot;</span>+pages);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis-执行SQL</title>
      <link href="/2023/10/09/Mybatis03SQL%E6%89%A7%E8%A1%8C/"/>
      <url>/2023/10/09/Mybatis03SQL%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="获取参数"><a href="#获取参数" class="headerlink" title="获取参数"></a>获取参数</h1><h2 id="获取参数方式"><a href="#获取参数方式" class="headerlink" title="获取参数方式"></a>获取参数方式</h2><p>MyBatis获取参数值的两种方式：${}和#{}  </p><ul><li>${}的本质就是字符串拼接，${}使用字符串拼接的方式拼接sql，若为字符串类型或日期类型的字段进行赋值时，需要手动加单引号；</li><li>#{}的本质就是占位符赋值 ，#{}使用占位符赋值的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时，可以自动添加单引号</li></ul><h2 id="获取参数情况"><a href="#获取参数情况" class="headerlink" title="获取参数情况"></a>获取参数情况</h2><div class="tabs" id="参数情况1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#参数情况1-1">单个字面量参数</button></li><li class="tab"><button type="button" data-href="#参数情况1-2">多个字面量类型参数</button></li><li class="tab"><button type="button" data-href="#参数情况1-3">map集合参数</button></li><li class="tab"><button type="button" data-href="#参数情况1-4">实体类类型参数</button></li><li class="tab"><button type="button" data-href="#参数情况1-5"><i class="Param注解" style="text-align: center;"></i></button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="参数情况1-1"><p>若mapper接口中的方法参数为单个的字面量类型，此时可以使用<code>${}</code>和<code>#{}</code>以任意的名称（最好见名识意）获取参数的值，注意${}需要手动加单引号、</p><p>如下所示，java代码和SQL语句中的都是形参，形参名字无所谓，实参最总都会被赋给形参</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--User getUserByUsername(String 形参);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByUsername&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select * from t_user where username = #&#123;形参&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--User getUserByUsername(String 形参);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByUsername&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span>  </span><br><span class="line">select * from t_user where username = &#x27;$&#123;形参&#125;&#x27;  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="参数情况1-2"><p>若mapper接口中的方法参数为多个时，此时MyBatis会自动将这些参数放在一个map集合中</p><p>存储方式：</p><ol><li>以arg0,arg1…为键，以参数为值；</li><li>以param1,param2…为键，以参数为值；</li></ol><blockquote><p>可以理解为形参名已经确定了，根据形参的顺序有对应的名字</p></blockquote><ul><li>因此需要通过<code>${}</code>和<code>#{}</code>访问map集合的键就可以获取相对应的值，注意<code>${}</code>需要手动加单引号。</li><li>使用arg或者param都行，要注意的是，arg是从arg0开始的，param是从param1开始的，两种可以混用，注意下标</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--User checkLogin(String username,String password);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;checkLogin&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span>  </span><br><span class="line">select * from t_user where username = #&#123;arg0&#125; and password = #&#123;arg1&#125;  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--User checkLogin(String username,String password);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;checkLogin&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select * from t_user where username = &#x27;$&#123;param1&#125;&#x27; and password = &#x27;$&#123;param2&#125;&#x27;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="参数情况1-3"><p>若mapper接口中的方法需要的参数为多个时，此时可以手动创建map集合，将这些数据放在map中只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号</p><blockquote><p>可以理解为方式二，但是形参由我们自己取名</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkLoginByMap</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line"><span class="type">ParameterMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(ParameterMapper.class);</span><br><span class="line">Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;usermane&quot;</span>,<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mapper.checkLoginByMap(map);</span><br><span class="line">System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--User checkLoginByMap(Map&lt;String,Object&gt; map);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;checkLoginByMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select * from t_user where username = #&#123;username&#125; and password = #&#123;password&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="参数情况1-4"><p>若mapper接口中的方法参数为实体类对象时此时可以使用${}和#{}，通过访问<strong>实体类对象中的属性名获取属性值</strong>，注意${}需要手动加单引号</p><p>底层用的是<code>setter</code>和<code>getter</code>方法确定属性名，相关方法去掉get和set，然后转小写，可能没有相关对象却有对应方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertUser</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line"><span class="type">ParameterMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(ParameterMapper.class);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="literal">null</span>,<span class="string">&quot;Tom&quot;</span>,<span class="string">&quot;123456&quot;</span>,<span class="number">12</span>,<span class="string">&quot;男&quot;</span>,<span class="string">&quot;123@321.com&quot;</span>);</span><br><span class="line">mapper.insertUser(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int insertUser(User user);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">insert into t_user values(null,#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;,#&#123;sex&#125;,#&#123;email&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="参数情况1-5"><p>可以通过<code>@Param注解</code>手动标识mapper接口中的方法参数，此时，会将这些参数放在map集合中，此时有2中存储形式</p><ol><li>以@Param注解的value属性值为键，以实参为值；</li><li>以param1,param2…为键，以参数为值；</li></ol><p>只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--User CheckLoginByParam(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password);--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;CheckLoginByParam&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        select * from t_user where username = #&#123;username&#125; and password = #&#123;password&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkLoginByParam</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line"><span class="type">ParameterMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(ParameterMapper.class);</span><br><span class="line">mapper.CheckLoginByParam(<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>总结：要么用实体类对象接受，要么全用<code>@Param注解</code>，其余方式都被这两种方式包含了</p><h1 id="查询实现"><a href="#查询实现" class="headerlink" title="查询实现"></a>查询实现</h1><p>如果查询出的数据只有一条，可以通过</p><ol><li><p>实体类对象接收</p><p>mapper 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 id 查询信息，并把信息封装成 Employee 对象</span></span><br><span class="line">Employee <span class="title function_">getEmpById</span><span class="params">(Integer id)</span>;</span><br></pre></td></tr></table></figure><p>SQL 映射文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">   通过 resultType 指定查询的结果是 Employee 类型的数据  </span></span><br><span class="line"><span class="comment">   只需要指定 resultType 的类型，MyBatis 会自动将查询的结果映射成 JavaBean 中的属性</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;employee&quot;</span>&gt;</span></span><br><span class="line">    select * from t_employee where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>List集合接收</p><p>mapper 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假如是全表查询数据，将查询的数据封装成 Employee 类型的集合</span></span><br><span class="line">List&lt;Employee&gt; <span class="title function_">getAllEmps</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>SQL 映射文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    注意这里的 resultType 返回值类型是集合内存储数据的类型，不是 &#x27;list&#x27;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllEmps&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;employee&quot;</span>&gt;</span></span><br><span class="line">    select * from t_employee</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Map集合接收</p><ul><li><p>查询结果是一条</p><p>mapper 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  根据 id 查询信息，并把结果信息封装成 Map </span></span><br><span class="line">Map&lt;String, Object&gt; <span class="title function_">getEmpAsMapById</span><span class="params">(Integer id)</span>;</span><br></pre></td></tr></table></figure><p>SQL 映射文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">   注意这里的 resultType 返回值类型是 &#x27;map&#x27;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAsMapById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    select * from t_employee where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20180312091558498?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY29kZWphcw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p></li><li><p>查询结果是多条：可以把查询的数据以<code>&#123;表中某一字段名, JavaBean&#125;</code>方式来封装成<code>Map</code>，比如用主键为键</p><p>mapper 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询所有员工的信息，把数据库中的 &#x27;id&#x27; 字段作为 key,对应的 value 封装成 Employee 对象</span></span><br><span class="line"><span class="comment">// @MapKey 中的值表示用数据库中的哪个字段名作 key</span></span><br><span class="line"><span class="meta">@MapKey(&quot;id&quot;)</span></span><br><span class="line">Map&lt;Integer, Employee&gt; <span class="title function_">getAllEmpsAsMap</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>SQL 映射文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    注意 resultType 返回值类型，不再是 &#x27;map&#x27;，而是 Map 的 value 对应的 JavaBean 类型</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllEmpsAsMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;employee&quot;</span>&gt;</span></span><br><span class="line">    select * from t_employee</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><p>如果查询出的数据有多条，一定不能用实体类对象接收，会抛异常<code>TooManyResultsException</code>，可以通过</p><ol><li>实体类类型的LIst集合接收</li><li>Map类型的LIst集合接收</li><li>在mapper接口的方法上添加@MapKey注解，指明结果中的属性作为键，将整个实体类结果作为值，以键值对的方式存储多条结果</li></ol><h3 id="SQL标签属性"><a href="#SQL标签属性" class="headerlink" title="SQL标签属性"></a>SQL标签属性</h3><p>parameterType：接口中方法参数的类型， 类型的完全限定名或别名。<strong>这个属性是可选的</strong>，因为 MyBatis可以推断出具体传入语句的参数，默认值为未设置（unset）。接口中方法的参数从 java 代码传入到mapper 文件的 sql 语句。</p><ul><li><p>@Param：在方法形参前面加入<code>@Param(“自定义参数名”)</code>，mapper 文件使用<code>#&#123;自定义参数名&#125;</code>。</p></li><li><p>resultType：指定sql映射文件中定义返回值类型，注意如果是集合情形，那应该是集合可以包含的类型，而不能是集合本身。</p><ul><li>基本类型：resultType&#x3D;基本类型</li><li>List类型：  resultType&#x3D;List中元素的类型</li><li>Map类型：单条记录：resultType &#x3D;map</li><li>多条记录：resultType &#x3D;Map中value的类型</li></ul></li><li><p>resultMap：可以将查询到的复杂数据（比如查询到几个表中数据）映射到一个结果集当中</p></li></ul><table><thead><tr><th>属性</th><th>简要描述</th></tr></thead><tbody><tr><td>id</td><td>在命名空间中唯一的标识符，用来确定接口中的方法，id应该与方法名一致</td></tr><tr><td>parameterType</td><td>指定参数类型，可以是简单类型，也可以是复杂类型。默认值为unset（依赖驱动）</td></tr><tr><td>resultType</td><td>指定sql映射文件中定义返回值类型。<strong>使用resultType或resultMap，但不能同时使用</strong></td></tr><tr><td>resultMap</td><td>外部resultMap的命名引用。结果集的映射是MyBatis最强大的特性，对其有一个很好的理解的话，许多复杂映射的情形都能迎刃而解。<strong>使用resultMap或resultType，但不能同时使用</strong></td></tr><tr><td>flushCache</td><td>设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空。默认值：false</td></tr><tr><td>useCache</td><td>将其设置为true，将会导致本条语句的结果被二级缓存。默认值：对select元素为true</td></tr><tr><td>timeout</td><td>这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值：unset（依赖驱动）</td></tr><tr><td>fetchSize</td><td>这是尝试影响驱动程序每次批量返回的结果行数和这个设置值相等。默认值：unset（依赖驱动）</td></tr><tr><td>statementType</td><td>指明MyBatis使用Statement、PreparedStatement或CallableStatement。默认值：PREPARED（PreparedStatement）</td></tr><tr><td>resultSetType</td><td>FORWARD_ONLY，SCROLL_SENSITIVE或SCROLL_INSENSITIVE中的一个。默认值：unset（依赖驱动）</td></tr><tr><td>databaseId</td><td>如果配置了databaseIdProvider，MyBatis会加载所有的不带databaseId或匹配当前databaseId语句，如果带或者不带的语句都有，则不带的会被忽略</td></tr><tr><td>resultOrdered</td><td>这个设置仅针对嵌套结果select语句适用：如果为true，就是假设包含了嵌套结果集或是分组了，这样的话当返回一个主结果行的时候，就不会发生有对前面结果集的引用的情况。这就使得在获取嵌套的结果集的时候不至于导致内存不够用。默认值：false</td></tr><tr><td>resultSets</td><td>仅对多结果集的情况适用，它将列出语句执行后返回的结果集并每个结果集给一个名称，名称是逗号分隔的</td></tr></tbody></table><h1 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h1><p>Mybatis框架的动态SQL技术是一种根据特定条件动态拼装SQL语句的功能，它存在的意义是为了解决拼接SQL语句字符串时的痛点问题。</p><p><strong>可以在XML映射文件内，以XML标签的形式编写动态SQL，完成逻辑判断和动态拼接SQL的功能</strong></p><p>所有语法中的条件参数，如果没有传入则跳过，不影响SQL语句的执行</p><p>Mybatis提供了9种动态SQL标签：</p><table><thead><tr><th>标签</th><th>作用</th></tr></thead><tbody><tr><td><code>&lt;if&gt;</code></td><td>判断条件，双条件用and连接，当中可插入其他语句</td></tr><tr><td><code>&lt;where&gt;</code></td><td>替代SQL语句中的where关键字，优化了开头的连接词</td></tr><tr><td><code>&lt;trim&gt;</code></td><td>修改前后缀</td></tr><tr><td><code>&lt;choose&gt;``&lt;when&gt;``&lt;otherwise&gt;</code></td><td>三位一体，类似<code>if...else if..else</code></td></tr><tr><td><code>&lt;foreach&gt;</code></td><td>实现批量操作</td></tr><tr><td><code>&lt;set&gt;</code></td><td></td></tr><tr><td><code>&lt;bind&gt;</code></td><td></td></tr></tbody></table><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p>if标签可通过test属性（即传递过来的数据）的表达式进行判断，若表达式的结果为true，则标签中的内容会执行；反之标签中的内容不会执行</p><p>在where后面添加一个恒成立条件<code>1=1</code>，这个恒成立条件并不会影响查询的结果，主要用来拼接<code>and</code>语句</p><p>例如：当empName为null时</p><ul><li><p>如果不加上恒成立条件，此时<code>where</code>会与<code>and</code>相连，SQL语句会报错，此时SQL语句为：</p><p><code>select * from t_emp where and age = ? and sex = ? and email = ?</code></p></li><li><p>如果加上该恒成立条件，此时不报错，SQL语句为：</p><p><code>select * from t_emp where 1= 1 and age = ? and sex = ? and email = ?</code></p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp where 1=1</span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null and empName !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">and emp_name = #&#123;empName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">and age = #&#123;age&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null and sex !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">and sex = #&#123;sex&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null and email !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">and email = #&#123;email&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="where"><a href="#where" class="headerlink" title="where"></a>where</h2><p>where和if一般结合使用：</p><ul><li>若where标签中的if条件都不满足，则where标签没有任何功能，即不会添加where关键字  </li><li>若where标签中的if条件满足，则where标签会自动添加where关键字，并将条件<strong>最前方</strong>多余的and&#x2F;or去掉  </li><li>注意：where标签不能去掉条件后多余的and&#x2F;or</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp</span><br><span class="line"><span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null and empName !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">emp_name = #&#123;empName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">and age = #&#123;age&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null and sex !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">and sex = #&#123;sex&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null and email !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">and email = #&#123;email&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h2><p>trim用于去掉或添加标签中的内容  </p><p>常用属性：</p><ul><li>prefix：在trim标签中<strong>加前缀</strong></li></ul><ul><li>suffix：在trim标签中<strong>加后缀</strong></li><li>prefixOverrides：在trim标签中<strong>去前缀</strong></li><li>suffixOverrides：在trim标签中<strong>去后缀</strong></li></ul><p>若trim中的标签都不满足条件，则trim标签没有任何效果，也就是只剩下<code>select * from t_emp</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp</span><br><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;where&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;and|or&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null and empName !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">emp_name = #&#123;empName&#125; and</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">age = #&#123;age&#125; and</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null and sex !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">sex = #&#123;sex&#125; or</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null and email !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">email = #&#123;email&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="choose、when、otherwise"><a href="#choose、when、otherwise" class="headerlink" title="choose、when、otherwise"></a>choose、when、otherwise</h2><ul><li><code>choose、when、otherwise</code>相当于<code>if...else if..else</code></li><li>when至少要有一个，otherwise至多只有一个</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByChoose&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp</span><br><span class="line"><span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;empName != null and empName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">emp_name = #&#123;empName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">age = #&#123;age&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;sex != null and sex != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">sex = #&#123;sex&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;email != null and email != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">email = #&#123;email&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">did = 1</span><br><span class="line"><span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><p>动态SQL的另外一个常用的必要操作是需要对一个集合进行遍历，通常是在构建<code>IN</code>条件语句的时候</p><p>foreach一共有三种类型，分别为List、Array、Map三种</p><p>属性： </p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>collection</td><td>做foreach的对象，用于设置要循环的数组或集合</td></tr><tr><td>item</td><td>循环体中的具体对象（每次循环出来的对象）。支持属性的点路径访问，如<code>item.age</code><br>在list和数组中是其中的对象，在map中是value。</td></tr><tr><td>separator</td><td>元素之间的分隔符<br/>例如在in()的时候，separator&#x3D;”,”会自动在元素中间用“,“隔开，避免手动输入逗号导致sql错误，如in(1,2,)这样</td></tr><tr><td>index</td><td>在list和数组中,index是元素的序号，在map中，index是元素的key，该参数<strong>可选</strong>。</td></tr><tr><td>open</td><td>foreach代码的开始符号，一般是(和close&#x3D;”)”合用。常用在in(),values()时。该参数<strong>可选</strong>。</td></tr><tr><td>close</td><td>foreach代码的关闭符号，一般是)和open&#x3D;”(“合用。常用在in(),values()时。该参数<strong>可选</strong></td></tr></tbody></table><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int insertMoreByList(@Param(&quot;emps&quot;) List&lt;Emp&gt; emps);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertMoreByList&quot;</span>&gt;</span></span><br><span class="line">insert into t_emp values</span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">item</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">(null,#&#123;emp.empName&#125;,#&#123;emp.age&#125;,#&#123;emp.sex&#125;,#&#123;emp.email&#125;,null)</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertMoreByList</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line"><span class="type">DynamicSQLMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(DynamicSQLMapper.class);</span><br><span class="line"><span class="type">Emp</span> <span class="variable">emp1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>(<span class="literal">null</span>,<span class="string">&quot;a&quot;</span>,<span class="number">1</span>,<span class="string">&quot;男&quot;</span>,<span class="string">&quot;123@321.com&quot;</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="type">Emp</span> <span class="variable">emp2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>(<span class="literal">null</span>,<span class="string">&quot;b&quot;</span>,<span class="number">1</span>,<span class="string">&quot;男&quot;</span>,<span class="string">&quot;123@321.com&quot;</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="type">Emp</span> <span class="variable">emp3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>(<span class="literal">null</span>,<span class="string">&quot;c&quot;</span>,<span class="number">1</span>,<span class="string">&quot;男&quot;</span>,<span class="string">&quot;123@321.com&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">List&lt;Emp&gt; emps = Arrays.asList(emp1, emp2, emp3);</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> mapper.insertMoreByList(emps);</span><br><span class="line">System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SQL片段"><a href="#SQL片段" class="headerlink" title="SQL片段"></a>SQL片段</h2><p>sql片段，可以记录一段公共sql片段，在使用的地方通过include标签进行引入</p><ul><li><p>声明sql片段：<code>&lt;sql&gt;</code>标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;empColumns&quot;</span>&gt;</span>eid,emp_name,age,sex,email<span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>引用sql片段：<code>&lt;include&gt;</code>标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;empColumns&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span> </span><br><span class="line">    from t_emp</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h1><h2 id="自定义映射"><a href="#自定义映射" class="headerlink" title="自定义映射"></a>自定义映射</h2><p>默认映射：名字一样就能映射上</p><blockquote><p>但是SQL和java的命名规则并不一样，经常有匹配不上的情况，此时大概率不会报错，但是找不到的添null，找得到的添加匹配值</p></blockquote><p>有三中解决方式：</p><ol><li><p>可以通过为字段起别名的方式（sql语句的起别名），保证和实体类中的属性名保持一致</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllEmp&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">    select eid, emp_name empName, age, sex, email from t_emp</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>可以在<strong>核心配置文件</strong>的<code>setting</code>中设置一个全局配置信息<code>mapUnderscoreToCamelCase</code>，可 以在查询表中数据时，自动将 _ 类型的字段名转换为驼峰，日志输出的时候也会转换</p><p>注意核心配置文件中的顺序</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--设置MyBatis的全剧配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--将下划线自动映射成驼峰，比如emp_name -&gt; empName --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>比如字段名<code>user_name</code>，设置了<code>mapUnderscoreToCamelCase</code>，此时字段名就会转换为<code>userName</code></p></blockquote></li><li><p>逐一设置resultMap映射关系</p><p>在resultMap中，一一对应地设置属性名和字段名，再在 select标签中添加<code>resultMap=&quot;对应resultMap的id&quot;</code></p><p>resultMap属性：</p><ul><li>id：唯一标识，可以理解为resultMap的对象的id，指明某个resultMap的对象，而resultMap的对象是一个类</li><li>type    映射的实体类型</li></ul><p>resultMap的子标签：</p><ul><li>id：设置主键的映射关系</li><li>result：设置其他的映射关系，属性如下<ul><li>property：设置映射关系中的属性名，必须是type属性所设置的实体类类型的属性名</li><li>column：设置映射关系中的字段名，必须是sql语句查询出来的字段名</li></ul></li></ul><blockquote><p>如果使用resultMap，就所有属性都需要设置</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置接受对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用接受对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllEmp&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empResultMap&quot;</span>&gt;</span></span><br><span class="line">    select * from t_emp</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="多对一的映射"><a href="#多对一的映射" class="headerlink" title="多对一的映射"></a>多对一的映射</h2><p>需要查询一对多、多对一的关系，需要在少的一方中加入集合，在多的一方中加入单个对象。</p><p>也就是说，在Dept类中，要加入private List&lt; Emp &gt; emps；在Emp类中，要加入private Dept dept;。然后给他们各自添加get、set方法，重写构造器和toString()</p><div class="tabs" id="参数情况2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#参数情况2-1">级联方式处理映射</button></li><li class="tab"><button type="button" data-href="#参数情况2-2">association处理映射</button></li><li class="tab"><button type="button" data-href="#参数情况2-3">分步查询</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="参数情况2-1"><p>就是创建resultMap对象时将多的属性加入，类似DTO</p><p>EmpMapper.xml中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 多对一映射关系，方式一：级联属性赋值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDeptResultMapOne&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;dept.did&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;dept.deptName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Emp getEmpAndDept(@Param(&quot;eid&quot;) Integer eid);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDept&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;getEmpAndDeptResultMapOne&quot;</span>&gt;</span></span><br><span class="line">    select * from t_emp left join t_dept</span><br><span class="line">    on t_emp.eid = t_dept.did WHERE t_emp.eid = #&#123;eid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>EmpMapper类中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmpMapper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询员工及其所对应的部门信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Emp <span class="title function_">getEmpAndDept</span><span class="params">(<span class="meta">@Param(&quot;eid&quot;)</span> Integer eid)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="参数情况2-2"><p><code>&lt;association&gt;</code>：专门用来处理多对一的一个标签，思想和上一个差不多，标签细节不同</p><ul><li>property：需要处理多对的映射关系的属性名</li><li>javaType：该属性的类型，通过反射能拿到类对应的属性</li></ul><p>EmpMapper.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empDeptMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">property</span>=<span class="string">&quot;ename&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span> <span class="attr">property</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dname&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--Emp getEmpAndDeptByEid(@Param(&quot;eid&quot;) int eid);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDeptByEid&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empDeptMap&quot;</span>&gt;</span></span><br><span class="line">    select emp.*,dept.* from t_emp emp left join t_dept dept on emp.did =</span><br><span class="line">    dept.did where emp.eid = #&#123;eid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="参数情况2-3"><p>分步查询的<code>&lt;association&gt;</code>中又包含了一个SQL语句，执行第二步及以后的查询</p><p>属性：</p><ul><li>select: 设置分步查询的sql的唯一标识，指明下一步用哪个SQL语句（namespace.SQLId或mapper接口的全类名.方法名）</li><li>column：条件字段</li><li>fetchType: 当开启了全局的延迟记载后，可通过此属性手动控制延迟加载的效果。<ul><li>lazy表示延迟加载</li><li>eager表示立即加载</li></ul></li></ul><p>根据员工所对应的部门id查询部门信息：</p><p>EmpMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo是这条sql语句的全类名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDeptByStepResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">select</span>=<span class="string">&quot;com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo&quot;</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">column</span>=<span class="string">&quot;did&quot;</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">fetchType</span>=<span class="string">&quot;eager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    Emp getEmpAndDeptByStepOne(@Param(&quot;eid&quot;) Integer eid);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDeptByStepOne&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;getEmpAndDeptByStepResultMap&quot;</span>&gt;</span></span><br><span class="line">    select * from t_emp where eid = #&#123;eid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>DeptMapper.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Dept getEmpAndDeptByStepTwo(Integer did);--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 分步查询可以实现懒加载--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDeptByStepTwo&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line">    select * from t_dept where did = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>EmpMapper类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmpMapper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">* 通过分步查询查询员工信息 * <span class="doctag">@param</span> eid</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    Emp <span class="title function_">getEmpByStep</span><span class="params">(<span class="meta">@Param(&quot;eid&quot;)</span> <span class="type">int</span> eid)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DeptMapper接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DeptMapper</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 分步查询的第二步:根据员工所对应的did查询部门信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Dept <span class="title function_">getEmpDeptByStep</span><span class="params">(<span class="meta">@Param(&quot;did&quot;)</span> <span class="type">int</span> did)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="一对多的映射"><a href="#一对多的映射" class="headerlink" title="一对多的映射"></a>一对多的映射</h2><p>需要查询一对多、多对一的关系，需要在少的一方中加入集合，在多的一方中加入单个对象。</p><p>也就是说，在Dept类中，要加入<code>private List&lt;Emp&gt; emps;</code>；在Emp类中，要加入<code>private Dept dept;</code>。然后给他们各自添加get、set方法，重写构造器和toString()</p><div class="tabs" id="参数情况3"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#参数情况3-1">collection</button></li><li class="tab"><button type="button" data-href="#参数情况3-2">分步查询</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="参数情况3-1"><p>该方法一次性查完，联表查询</p><p><code>&lt;collection&gt;</code>标签：处理一对多的映射关系，内部用子标签指明属性</p><p>属性：</p><ul><li><code>ofType</code>：表示该属性对应的集合中存储数据的类型</li></ul><p>DeptMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;deptAndEmpResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;did&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;deptName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            collection：处理一对多的映射关系</span></span><br><span class="line"><span class="comment">            ofType：表示该属性对应的集合中存储数据的类型</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        Dept getDeptAndEmp(@Param(&quot;did&quot;) Integer did);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptAndEmp&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;deptAndEmpResultMap&quot;</span>&gt;</span></span><br><span class="line">    select * from t_dept left join t_emp on t_dept.did = t_emp.did where t_dept.did = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>DeptMapper接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DeptMapper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取部门以及部门中所有的员工信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Dept <span class="title function_">getDeptAndEmp</span><span class="params">(<span class="meta">@Param(&quot;did&quot;)</span> Integer did)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="参数情况3-2"><ol><li><p>查询部门信息</p><p>DeptMapper接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DeptMapper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分步查询 查询部门及其所有的员工信息</span></span><br><span class="line"><span class="comment">     * 第一步  查询部门信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Dept <span class="title function_">getDeptAndEmoByStepOne</span><span class="params">(<span class="meta">@Param(&quot;did&quot;)</span> Integer did)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DeptMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    分步查询--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;deptAndEmoByStepOneMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;did&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;deptName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;emps&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">select</span>=<span class="string">&quot;com.atguigu.mybatis.mapper.EmpMapper.getDeptAndEmpByStepTwo&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        Dept getDeptAndEmoByStepOne(@Param(&quot;did&quot;) Integer did);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptAndEmoByStepOne&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;deptAndEmoByStepOneMap&quot;</span>&gt;</span></span><br><span class="line">    select * from t_dept where did = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>根据部门id查询部门中的所有员工</p><p>EmpMapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmpMapper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分步查询 查询部门及其所有的员工信息</span></span><br><span class="line"><span class="comment">     * 第二步  根据查询员工信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;Emp&gt; <span class="title function_">getDeptAndEmpByStepTwo</span><span class="params">(<span class="meta">@Param(&quot;did&quot;)</span> Integer did)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EmpMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 分步查询--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- List&lt;Emp&gt; getDeptAndEmpByStepTwo(@Param(&quot;did&quot;) Integer did);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptAndEmpByStepTwo&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">    select * from t_emp where did = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis-配置文件</title>
      <link href="/2023/10/08/Mybatis02%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
      <url>/2023/10/08/Mybatis02%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="MyBatis核心配置文件"><a href="#MyBatis核心配置文件" class="headerlink" title="MyBatis核心配置文件"></a>MyBatis核心配置文件</h1><blockquote><p>mybatis中有2种配置文件，一个是<strong>核心配置文件</strong>，另一个是<strong>映射文件</strong></p></blockquote><p>核心配置文件主要用于配置数据连接和MyBatis运行时所需的各种特性，包含了影响MyBatis行为甚深的设置（settings）和属性（properties）</p><p>核心配置文件是Mybatis的全局配置文件，核心配置文件没有固定的名字，但是默认都叫<code>mybatis-config.xml</code></p><p>configuration为配置文件的根元素节点，下面是configuration元素子节点。子节点必须按照固定的顺序，没有的忽略，有的按顺序：</p><ol><li><p>properties</p><p>通过resource属性从外部指定属性文件（db.properties），该属性文件描述数据库连接的相关配置（数据库驱动、连接数据库的url、数据库用户名、数据库密码），位置也是在&#x2F;resources目录下</p></li><li><p>settings</p><p>设置MyBatis运行中的一些行为，比如此处设置MyBatis的log日志实现为LOG4J，即使用log4j实现日志功能</p></li><li><p>typeAliases</p><p>为Java类型命名一个别名（简称）</p></li><li><p>typeHandlers</p><p>类型处理器</p></li><li><p>objectFactory</p></li><li><p>objectWrapperFactory</p></li><li><p>reflectorFactory</p></li><li><p>plugins</p><p>插件</p></li><li><p>environments</p><p>表示配置MyBatis的多套运行环境，将SQL映射到多个不同的数据库上，<code>environments</code>可以配置多个<code>environment</code>子元素节点，但是必须指定其中一个默认运行环境（通过default指定）</p><p>environment：配置MyBatis的一套运行环境，需指定运行环境ID、事务管理、数据源配置等相关信息</p><table><thead><tr><th>environment的子元素</th><th>描述</th></tr></thead><tbody><tr><td>transactionManager</td><td>事务管理器</td></tr><tr><td>dataSource</td><td>数据源</td></tr></tbody></table></li><li><p>databaseIdProvider</p></li><li><p>mappers</p><p>告诉MyBatis去哪里找到SQL映射文件（开发者定义的映射SQL语句），整个项目中可以有1个或多个SQL映射文件</p></li></ol><blockquote><p>没写的不管，写了的一定要按顺序，不然会报错</p></blockquote><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20240227100312070.png" alt="image-20240227100312070"></p><h2 id="properties（数据库连接）"><a href="#properties（数据库连接）" class="headerlink" title="properties（数据库连接）"></a>properties（数据库连接）</h2><p>通过该标签来读取Java配置信息，数据源信息写在<code>db.properties</code>文件中，可以通过<code>properties</code>标签来加载该文件</p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">db.properties</button></li><li class="tab"><button type="button" data-href="#test1-2">mybatis-config.xml</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">db.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">db.url</span>=<span class="string">jdbc:mysql://localhost:3306/my</span></span><br><span class="line"><span class="attr">db.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">db.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过properties标签，读取java配置文件的内容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;db.properties&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 可能不配置这一句 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;db.username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1234&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置mybatis的环境信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 配置JDBC事务控制，由mtybatis进行管理 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 配置数据源，采用dbcp连接池 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db.driver&#125;&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db.url&#125;&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db.username&#125;&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db.password&#125;&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><ol><li>先加载<code>properties标签</code>中<code>property标签</code>声明的属性，因此在<code>property标签</code>中的name属性的值和value比<code>properties配置文件</code>中的resource属性先加载；后加载的<code>db.properties配置文件</code>会覆盖于property加载属性和值</li><li>再加载<code>properties标签</code>引入的Java配置文件中的属性</li><li>最后再读取<code>映射文件（xml）</code>中parameterType的值会和properties的属性值发生冲突。因此，在properties文件里的内容命名最好加上db.代表是跟数据源相关的属性，这样不容易跟后面的属性发生冲突</li></ol><h2 id="settings（运行）"><a href="#settings（运行）" class="headerlink" title="settings（运行）"></a>settings（运行）</h2><p>设置一些非常重要的设置选项，用于设置和改变MyBatis运行中的行为<br>settings元素支持的属性。</p><table><thead><tr><th>设置项</th><th>描述</th><th>允许值</th><th>默认</th></tr></thead><tbody><tr><td>cacheEnabled</td><td>该配置影响的所有映射器中配置的缓存的全局开关</td><td>true&#x2F;false</td><td>true</td></tr><tr><td>lazyLoadingEnabled</td><td>全局性设置懒加载。false则所有相关联的都会被初始化加载</td><td>true&#x2F;false</td><td>true</td></tr><tr><td>autoMappingBehavior</td><td>MyBatis对于resultMap自动映射的匹配级别</td><td>NONE</td><td>PARTIAL</td></tr><tr><td>aggressiveLazyLoading</td><td>当启用时，对任意延迟属性的调用会使带有延迟加载属性的对象完整加载；反之，每种属性将会按需加载</td><td>true&#x2F;false</td><td></td></tr><tr><td>multipleResultSetsEnabled</td><td>是否允许单一语句返回多结果集（需要兼容驱动）</td><td>true&#x2F;false</td><td>true</td></tr><tr><td>useColumnLabel</td><td>使用列标签代替列名。不同的驱动在这方面会有不同的表现， 具体可参考相关驱动文档或通过测试这两种不同的模式来观察所用驱动的结果</td><td>true&#x2F;false</td><td>true</td></tr><tr><td>useGeneratedKeys</td><td>允许JDBC支持自动生成主键，需要驱动兼容。如果设置为true则这个设置强制使用自动生成主键，尽管一些驱动不能兼容但仍可正常工作（比如Derby）</td><td>true&#x2F;false</td><td>false</td></tr><tr><td>defaultExecutorType</td><td>配置默认的执行器。SIMPLE就是普通的执行器；REUSE执行器会重用预处理语句（prepared statements）；BATCH执行器将重用语句并执行批量更新</td><td>SIMPLER,EUSE,BATCH</td><td>SIMPLE</td></tr><tr><td>defaultStatementTimeout</td><td>设置超时时间，它决定驱动等待数据库响应的秒数</td><td>Any positive integer；任意正整数</td><td>Not Set (null)</td></tr><tr><td>safeRowBoundsEnabled</td><td>允许在嵌套语句中使用分页（RowBounds）</td><td>true&#x2F;false</td><td>false</td></tr><tr><td>mapUnderscoreToCamelCase</td><td>是否开启自动驼峰命名规则（camel case）映射。即从经典数据库列名A_COLUMN到经典Java属性名aColumn的类似映射</td><td>true&#x2F;false</td><td>false</td></tr><tr><td>localCacheScope</td><td>MyBatis利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速重复嵌套查询。 默认值为SESSION，这种情况下会缓存一个会话中执行的所有查询。若设置值为STATEMENT，本地会话仅用在语句执行上，对相同SqlSession 的不同调用将不会共享数据</td><td>SESSION,STATEMENT</td><td>SESSION</td></tr><tr><td>jdbcTypeForNull</td><td>当没有为参数提供特定的JDBC类型时。为空值指定JDBC类型。某些驱动需要指定列的JDBC类型，多数情况直接用一般类型即可，比如NULL、VARCHAR或OTHER</td><td>JdbcType enumeration. Most common are: NULL, VARCHAR and OTHER</td><td>OTHER</td></tr><tr><td>lazyLoadTriggerMethods</td><td>指定哪个对象的方法触发一次延迟加载</td><td>用逗号分隔的方法名列表</td><td>equals,clone,hashCode,toString</td></tr><tr><td>defaultScriptingLanguage</td><td>指定动态SQL生成的默认语言</td><td>类型别名或完全限定类名</td><td>org.apache.ibatis.scripting.xmltags.XMLDynamicLanguageDriver</td></tr><tr><td>callSettersOnNulls</td><td>指定当结果集中值为null的时候，是否调用映射对象的setter（map对象时为put）方法，这对于有 Map.keySet()依赖或null值初始化的时候是有用的。注意基本类型（int、boolean等）是不能设置成 null的</td><td>true&#x2F;false</td><td>false</td></tr><tr><td>logPrefix</td><td>指定MyBatis增加到日志名称的前缀</td><td>指定MyBatis所用日志的具体实现，未指定时将自动查找</td><td>SLF4J,LOG4J,LOG4J2,JDK_LOGGING,COMMONS_LOGGING,STDOUT_LOGGING,NO_LOGGING</td></tr><tr><td>proxyFactory</td><td>指定Mybatis创建具有延迟加载能力的对象所用到的代理工具</td><td>CGLIB,JAVASSIST</td><td>CGLIB</td></tr></tbody></table><h2 id="typeAliases（别名）"><a href="#typeAliases（别名）" class="headerlink" title="typeAliases（别名）"></a>typeAliases（别名）</h2><p>类型别名是为Java类型设置一个短的名字。它只和XML配置有关，存在的意义仅在于用来减少类完全限定名的冗余。</p><h3 id="给实体类取别名，方便在mapper配置文件中使用"><a href="#给实体类取别名，方便在mapper配置文件中使用" class="headerlink" title="给实体类取别名，方便在mapper配置文件中使用"></a>给实体类取别名，方便在mapper配置文件中使用</h3><p>typeAlias属性：</p><ul><li><p>type: 设置需要设置别名的类型</p></li><li><p>alias: 设置某个类型的别名，如果不设置该属性，那么该类型拥有默认的类名，且不区分大小写</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;user&quot;</span> <span class="attr">type</span>=<span class="string">&quot;cn.my.pojo.User&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;provider&quot;</span> <span class="attr">type</span>=<span class="string">&quot;cn.my.pojo.Provider&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用<code>User</code>作为<code>cn.my.pojo.User</code>的别名，可以在mapper的配置文件中直接使用User来代表这个类。</p><p>当这样配置时，可以在任何地方使用<code>cn.my.pojo.User</code>，这种写法的弊端在于如果一个项目中有多个POJO的时候，都需要配置</p><h3 id="通过package的name属性直接指定包名"><a href="#通过package的name属性直接指定包名" class="headerlink" title="通过package的name属性直接指定包名"></a>通过package的name属性直接指定包名</h3><p>MyBatis会自动扫描指定包下的JavaBean，给包下所有的类型设置默认的类型别名且不区分大小写，默认名称为JavaBean的非限定类名（首字母小写，如：User —&gt; user）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--以包为单位，将包下所有的类型设置默认的类型别名且不区分大小写--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;cn.my.pojo&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>每一个在包 cn.my.pojo 中的 JavaBean，在没有注解的情况下，会使用Bean的首字母小写的非限定类名来作为它的别名</p><p>如 ：domain.blog.Author的别名为author；若有注解，则别名为其注解值</p><h3 id="Mybatis映射处理"><a href="#Mybatis映射处理" class="headerlink" title="Mybatis映射处理"></a>Mybatis映射处理</h3><p>Mybatis已经为许多常见的Java类型内建了相应的类型别名。它们都是大小写不敏感的，需要注意的是由基本类型名称重复导致的特殊处理</p><table><thead><tr><th>映射类型</th><th>别名</th><th>映射类型</th><th>别名</th></tr></thead><tbody><tr><td>byte</td><td>_byte</td><td>Double</td><td>double</td></tr><tr><td>long</td><td>_long</td><td>Float</td><td>float</td></tr><tr><td>short</td><td>_short</td><td>Boolean</td><td>boolean</td></tr><tr><td>int</td><td>_int</td><td>Date</td><td>date</td></tr><tr><td>int</td><td>_integer</td><td>BigDecimal</td><td>decimal</td></tr><tr><td>double</td><td>_double</td><td>BigDecimal</td><td>bigdecimal</td></tr><tr><td>float</td><td>_float</td><td>Object</td><td>object</td></tr><tr><td>boolean</td><td>_boolean</td><td>Map</td><td>map</td></tr><tr><td>String</td><td>string</td><td>HashMap</td><td>hashmap</td></tr><tr><td>Byte</td><td>byte</td><td>List</td><td>list</td></tr><tr><td>Long</td><td>long</td><td>ArrayList</td><td>arraylist</td></tr><tr><td>Short</td><td>short</td><td>Collection</td><td>collection</td></tr><tr><td>Integer</td><td>int</td><td>Iterator</td><td>iterator</td></tr><tr><td>Integer</td><td>integer</td><td></td><td></td></tr></tbody></table><h2 id="typeHandlers（类型处理器）"><a href="#typeHandlers（类型处理器）" class="headerlink" title="typeHandlers（类型处理器）"></a>typeHandlers（类型处理器）</h2><p>无论是MyBatis在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时，都会用类型处理器将获取的值以合适的方式转换成Java类型。</p><p><strong>默认的类型处理器</strong></p><table><thead><tr><th>类型处理器</th><th>Java类型</th><th>JDBC类型</th></tr></thead><tbody><tr><td>BooleanTypeHandler</td><td>java.lang.Boolean,boolean</td><td>数据库兼容的BOOLEAN</td></tr><tr><td>ByteTypeHandler</td><td>java.lang.Byte,byte</td><td>数据库兼容的NUMERIC或BYTE</td></tr><tr><td>ShortTypeHandler</td><td>java.lang.Short,short</td><td>数据库兼容的NUMERIC或SHORT INTEGER</td></tr><tr><td>IntegerTypeHandler</td><td>java.lang.Integer,int</td><td>数据库兼容的NUMERIC或INTEGER</td></tr><tr><td>LongTypeHandler</td><td>java.lang.Long,long</td><td>数据库兼容的NUMERIC或LONG INTEGER</td></tr><tr><td>FloatTypeHandler</td><td>java.lang.Float,float</td><td>数据库兼容的NUMERIC或FLOAT</td></tr><tr><td>DoubleTypeHandler</td><td>java.lang.Double,double</td><td>数据库兼容的NUMERIC或DOUBLE</td></tr><tr><td>BigDecimalTypeHandler</td><td>java.math.BigDecimal</td><td>数据库兼容的NUMERIC或DECIMAL</td></tr><tr><td>StringTypeHandler</td><td>java.lang.String</td><td>CHAR,VARCHAR</td></tr><tr><td>ClobTypeHandler</td><td>java.lang.String</td><td>CLOB,LONGVARCHAR</td></tr><tr><td>NStringTypeHandler</td><td>java.lang.String</td><td>NVARCHAR,NCHAR</td></tr><tr><td>NClobTypeHandler</td><td>java.lang.String</td><td>NCLOB</td></tr><tr><td>ByteArrayTypeHandler</td><td>byte[]</td><td>数据库兼容的字节流类型</td></tr><tr><td>BlobTypeHandler</td><td>byte[]</td><td>BLOB,LONGVARBINARY</td></tr><tr><td>DateTypeHandler</td><td>java.util.Date</td><td>TIMESTAMP</td></tr><tr><td>DateOnlyTypeHandler</td><td>java.util.Date</td><td>DATE</td></tr><tr><td>TimeOnlyTypeHandler</td><td>java.util.Date</td><td>TIME</td></tr><tr><td>SqlTimestampTypeHandler</td><td>java.sql.Timestamp</td><td>TIMESTAMP</td></tr><tr><td>SqlDateTypeHandler</td><td>java.sql.Date</td><td>DATE</td></tr><tr><td>SqlTimeTypeHandler</td><td>java.sql.Time</td><td>TIME</td></tr><tr><td>ObjectTypeHandler</td><td>Any</td><td>OTHER或未指定类型</td></tr><tr><td>EnumTypeHandler</td><td>Enumeration Type</td><td>VARCHAR-任何兼容的字符串类型，存储枚举的名称（而不是索引）</td></tr><tr><td>EnumOrdinalTypeHandler</td><td>Enumeration Type</td><td>任何兼容的NUMERIC或DOUBLE类型，存储枚举的索引（而不是名称）</td></tr></tbody></table><h2 id="objectFactory（对象工厂）"><a href="#objectFactory（对象工厂）" class="headerlink" title="objectFactory（对象工厂）"></a>objectFactory（对象工厂）</h2><p>MyBatis每次创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成。 默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过参数构造方法来实例化。 如果想覆盖对象工厂的默认行为，则可以通过创建自己的对象工厂来实现<br>ObjectFactory 接口很简单，它包含两个创建用的方法，一个是处理默认构造方法的，另外一个是处理带参数的构造方法的。 最后，setProperties方法可以被用来配置ObjectFactory，在初始化你的ObjectFactory实例后，objectFactory元素体中定义的属性会被传递给setProperties方法。</p><h2 id="plugins（插件）"><a href="#plugins（插件）" class="headerlink" title="plugins（插件）"></a>plugins（插件）</h2><p>MyBatis允许在已映射语句执行过程中的某一点进行拦截调用</p><p>默认情况下，MyBatis允许使用插件来拦截的方法调用包括<br>（1）Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)<br>（2）ParameterHandler (getParameterObject, setParameters)<br>（3）ResultSetHandler (handleResultSets, handleOutputParameters)<br>（4）StatementHandler (prepare, parameterize, batch, update, query)<br>这些类中方法的细节可以通过查看每个方法的签名来发现，或者直接查看MyBatis的发行包中的源代码。假设你想做的不仅仅是监控方法的调用，那么你应该很好的了解正在重写的方法的行为。 因为如果在试图修改或重写已有方法的行为的时候，你很可能在破坏MyBatis的核心模块。这些都是更低层的类和方法，所以使用插件的时候要特别当心<br>通过MyBatis提供的强大机制，使用插件是非常简单的，只需实现Interceptor接口，并指定了想要拦截的方法签名即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis-config.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;org.mybatis.ExamplePlugin&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;someProperty&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>覆盖配置类<br>除了用插件来修改MyBatis核心行为之外，还可以通过完全覆盖配置类来达到目的。只需继承后覆盖其中的每个方法，再把它传递到sqlSessionFactoryBuilder.build(myConfig)方法即可。再次重申，这可能会严重影响MyBatis的行为，务请慎之又慎</p><h2 id="environments（环境）"><a href="#environments（环境）" class="headerlink" title="environments（环境）"></a>environments（环境）</h2><p>MyBatis可以配置成适应多种环境，这种机制有助于将SQL映射应用于多种数据库之中，不同场景使用不同环境。</p><p>尽管可以配置多个环境，每个SqlSessionFactory实例只能选择其一。所以，如果想连接两个数据库，就需要创建两个SqlSessionFactory实例，每个数据库对应一个。而如果是三个数据库，就需要三个实例，依此类推。</p><p>指定创建哪种环境，只要将它作为可选的参数传递给SqlSessionFactoryBuilder即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(reader, environment);</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(reader, environment,properties);</span><br></pre></td></tr></table></figure><p>如果忽略了环境参数，那么默认环境将会被加载（default指定的有环境）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(reader);</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(reader,properties);</span><br></pre></td></tr></table></figure><h3 id="使用environments"><a href="#使用environments" class="headerlink" title="使用environments"></a>使用environments</h3><p>环境元素定义了如何配置环境。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- default=&quot;development&quot;默认的环境ID，id=&quot;development&quot;自定义的环境ID --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- type事务管理器配置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span> </span><br><span class="line">           <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;...&quot;</span> <span class="attr">value</span>=<span class="string">&quot;...&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  type数据源的配置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="transactionManager（事务管理器）"><a href="#transactionManager（事务管理器）" class="headerlink" title="transactionManager（事务管理器）"></a>transactionManager（事务管理器）</h4><p>在MyBatis中有两种类型的事务管理器（type&#x3D;”[ JDBC | MANAGED ]”）</p><ul><li><p>JDBC：直接使用了JDBC的提交和回滚设置，它依赖于从数据源得到的连接来管理事务范围</p></li><li><p>MANAGED：受容器管理，让容器来管理事务的整个生命周期</p><p>默认情况下它会关闭连接，然而一些容器并不希望这样，因此需将closeConnection属性设置为false来阻止它默认的关闭行为。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;MANAGED&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;closeConnection&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>如果正在使用Spring + MyBatis，则没有必要配置事务管理器，因为Spring模块会使用自带的管理器来覆盖前面的配置</p><h4 id="dataSource（数据源）"><a href="#dataSource（数据源）" class="headerlink" title="dataSource（数据源）"></a>dataSource（数据源）</h4><p>dataSource元素使用标准的JDBC数据源接口来配置JDBC连接对象的资源<br>许多MyBatis的应用程序将会按示例中的例子来配置数据源。然而它并不是必须的。要知道为了方便使用延迟加载，数据源才是必须的。</p><p>有三种内建的数据源类型（也就是type&#x3D;”[UNPOOLED|POOLED|JNDI]”）</p><div class="tabs" id="datasource"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#datasource-1">UNPOOLED</button></li><li class="tab"><button type="button" data-href="#datasource-2">POOLED</button></li><li class="tab"><button type="button" data-href="#datasource-3">JNDI</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="datasource-1"><p>数据源的实现只是<strong>每次被请求时打开和关闭连接</strong>。虽然一点慢，它对在及时可用连接方面没有性能要求的简单应用程序是一个很好的选择（<strong>某些数据库对连接池不重要，这个配置是理想的</strong>）</p><p><strong>UNPOOLED类型的数据源仅仅需要配置以下5种属性</strong></p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>driver</td><td>JDBC驱动的Java类的完全限定名</td></tr><tr><td>url</td><td>数据库的JDBC URL地址</td></tr><tr><td>username</td><td>登录数据库的用户名</td></tr><tr><td>password</td><td>登录数据库的密码</td></tr><tr><td>defaultTransactionIsolationLevel</td><td>默认连接事务隔离级别</td></tr><tr><td>driver.encoding&#x3D;UTF8</td><td>通过DriverManager.getConnection(url,driverProperties)方法传递值为UTF8的encoding属性给数据库驱动</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="datasource-2"><p>利用”池”的概念将JDBC连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。是一种使得并发Web应用快速响应请求的流行处理方式</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>poolMaximumActiveConnections</td><td>在任意时间可以存在的活动（也就是正在使用）连接数量。默认值：10</td></tr><tr><td>poolMaximumIdleConnections</td><td>任意时间可能存在的空闲连接数</td></tr><tr><td>poolMaximumCheckoutTime</td><td>在被强制返回之前，池中连接被检出（checked out）时间。默认值：20000 毫秒（即 20 秒）</td></tr><tr><td></td><td></td></tr><tr><td>poolTimeToWait</td><td>底层设置，如果获取连接花费的相当长的时间，它会给连接池打印状态日志并重新尝试获取一个连接（避免在误配置的情况下一直安静的失败）。默认值：20000 毫秒（即 20 秒）</td></tr><tr><td>poolPingQuery</td><td>发送到数据库的侦测查询，用来检验连接是否处在正常工作秩序中并准备接受请求。默认”NO PING QUERY SET”，会导致多数数据库驱动失败时带有一个恰当的错误消息</td></tr><tr><td>poolPingEnabled</td><td>是否启用侦测查询。若开启，也必须使用一个可执行的SQL语句设置poolPingQuery属性（最好是一个非常快的SQL）。默认值：false</td></tr><tr><td>poolPingConnectionsNotUsedFor</td><td>配置poolPingQuery的使用频度。可以被设置成匹配具体的数据库连接超时时间，来避免不必要的侦测。默认值：0（即所有连接每一时刻都被侦测 — 当然仅当poolPingEnabled为true时适用）</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="datasource-3"><p>数据源的实现是为了能在如EJB或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个JNDI上下文的引用</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>initial_context</td><td>这个属性用来在InitialContext中寻找上下文（即，initialContext.lookup(initial_context)）。这是个可选属性，如果忽略，那么data_source属性将会直接从InitialContext中寻找</td></tr><tr><td>data_source</td><td>这是引用数据源实例位置的上下文的路径。提供了initial_context配置时会在其返回的上下文中进行查找，没有提供时则直接在 InitialContext 中查找；和其他数据源配置类似，可以通过添加前缀”env.”直接把属性传递给初始上下文</td></tr><tr><td>env.encoding&#x3D;UTF-8</td><td>这就会在初始上下文（InitialContext）实例化时往它的构造方法传递值为 UTF8 的 encoding 属性</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="mappers"><a href="#mappers" class="headerlink" title="mappers"></a>mappers</h2><p>mappers：映射器，用来定义SQL的映射语句，只需要告诉MyBatis去哪里找到这些SQL语句，即去哪里找到相应的SQL映射文件（加载映射文件）</p><p>使用方式：</p><ol><li><p>类资源路径：<code>&lt;mapper resource=&quot;&quot;/&gt;</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/my/mapper/UserMapper.xml&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>全限定路径（URL获取资源）：<code>&lt;mapper url=&quot;&quot;/&gt;</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">&quot;file:///D:/workspace/mybatis/com/my/mapper/UserMapper.xml&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>mapper接口的全限定类名：<code>&lt;mapper class=&quot;&quot;/&gt;</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.my.mapper.UserMapper&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>加载指定包下的所有映射文件：<code>&lt;package name=&quot;&quot;/&gt;</code></p><p>以包为单位引入映射文件，要求：</p><ol><li>mapper接口所在的包要和映射文件所在的包一致</li><li>mapper接口要和映射文件的名字一致</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.my.mapper&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="Mybatis映射文件"><a href="#Mybatis映射文件" class="headerlink" title="Mybatis映射文件"></a>Mybatis映射文件</h1><h2 id="持久化类（POJO，JavaBean）"><a href="#持久化类（POJO，JavaBean）" class="headerlink" title="持久化类（POJO，JavaBean）"></a>持久化类（POJO，JavaBean）</h2><p>持久化类：其实例状态需要被MyBatis持久化到数据库中的类。</p><p>在应用的设计中，持久化类通常对应需求中的业务实体。MyBatis一般采用POJO编程模型来实现持久化类，与POJO类配合完成持久化工作是MyBatis最常见的工作模式</p><p>POJO（Plain Ordinary Java Object，普通Java对象）：POJO类可以简单地理解为符合JavaBean规范的实体类，它不需要继承和实现任何特殊的Java基类或者接口。JavaBean对象的状态保存在属性中，访问属性必须通过对应的getter和setter方法。</p><p>在MyBatis中，不需要POJO类名与数据库表名一致，因为MyBatis是POJO与SQL语句之间的映射机制，一般情况下，保证POJO对象的属性与数据库表的字段名一致即可</p><h2 id="映射文件"><a href="#映射文件" class="headerlink" title="映射文件"></a>映射文件</h2><p>MyBatis真正强大之处就在于SQL映射语句。相较于它强大的功能，SQL映射文件的配置却非常简单。</p><p>SQL映射文件的创建，完成与POJO（实体类）的映射，该文件也是一个XML文件，命名为UserMapper.xml（一般都是采用POJO的名称 + Mapper的规则来进行命名）；当然该mapper文件属于DAO层的操作，应该放置在dao包下，并根据业务功能进行分包放置</p><h3 id="SQL映射文件顶级元素配置"><a href="#SQL映射文件顶级元素配置" class="headerlink" title="SQL映射文件顶级元素配置"></a>SQL映射文件顶级元素配置</h3><table><thead><tr><th>顶级元素</th><th>描述</th></tr></thead><tbody><tr><td>mapper</td><td>映射文件的根元素节点，只有一个属性namespace（命名空间）。用于区分不同的mapper，全局唯一；绑定DAO接口，即面向对象编程。当namespace绑定某一接口之后，可以不用写该接口的实现类。MyBatis通过接口的完整限定名查找到对应的mapper配置来执行SQL语句。因此namespace的命名必须要与接口同名</td></tr><tr><td>cache</td><td>配置给定命名空间的缓冲</td></tr><tr><td>cache-ref</td><td>从其他命名空间引用缓冲配置</td></tr><tr><td>parameterMap</td><td>表示将查询结果集中列值的类型一一映射到java对象属性的类型上，在开发过程中不推荐这种方式</td></tr><tr><td>resultMap</td><td>用来描述数据库结果集和对象的对应关系</td></tr><tr><td>sql</td><td>可以重用的SQL块，也可以被其他语句引用</td></tr><tr><td>insert</td><td>映射插入语句</td></tr><tr><td>update</td><td>映射更新语句</td></tr><tr><td>delete</td><td>映射删除语句</td></tr><tr><td>select</td><td>映射查询语句</td></tr></tbody></table><h3 id="Insert、Update-和-Delete（DML）"><a href="#Insert、Update-和-Delete（DML）" class="headerlink" title="Insert、Update 和 Delete（DML）"></a>Insert、Update 和 Delete（DML）</h3><p>insert，update和delete方法返回的值指示该语句影响的行数</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>命名空间中的唯一标识符，可被用来代表这条语句。一个命名空间（namespace）对应一个dao接口，这个id也应该对应dao里面的某个方法（相当于方法的实现），因此id 应该与方法名一致</td></tr><tr><td>parameterType</td><td>将要传入语句的参数的完全限定类名或别名。这个属性是可选的，因为MyBatis可以通过TypeHandler推断出具体传入语句的参数。默认值：unset（无设置，依赖驱动）</td></tr><tr><td>statementType</td><td>让MyBatis使用Statement、PreparedStatement或CallableStatement。默认值：PREPARED</td></tr><tr><td>timeout</td><td>这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值：unset（依赖驱动）</td></tr><tr><td>flushCache</td><td>设置为true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空。默认值：true（对应插入、更新和删除语句）</td></tr><tr><td>useGeneratedKeys</td><td>（仅对insert和update有用）这会MyBatis使用JDBC的getGeneratedKeys方法来取出由数据库内部生成的主键（比如：像MySQL和SQL Server这样的关系数据库管理系统的自动递增字段）。默认值：false</td></tr><tr><td>keyProperty</td><td>（仅对insert和update 有用）唯一标记一个属性，MyBatis会通过getGeneratedKeys的返回值或者通过insert语句的selectKey子元素设置它的键值。默认：unset。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表</td></tr><tr><td>keyColumn</td><td>（仅对insert和update有用）通过生成的键值设置表中的列名，这个设置仅在某些数据库（像PostgreSQL）是必须的，当主键列不是表中的第一列的时候需要设置。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表</td></tr><tr><td>databaseId</td><td>如果配置了databaseIdProvider，MyBatis会加载所有的不带databaseId或匹配当前databaseId的语句；如果带或者不带的语句都有，则不带的会被忽略</td></tr></tbody></table><h3 id="selectKey（子元素）"><a href="#selectKey（子元素）" class="headerlink" title="selectKey（子元素）"></a>selectKey（子元素）</h3><p>用来给不支持自动生成主键的数据库用，如oracel，或者该表主键没有设置为主键增长策略</p><p>SelectKey在Mybatis中是为了解决Insert数据时不支持主键自动生成的问题，可以很随意的设置生成主键的方式</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>keyProperty</td><td>selectKey语句结果应该被设置的目标属性。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表</td></tr><tr><td>keyColumn</td><td>匹配属性的返回结果集中的列名称。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表</td></tr><tr><td>resultType</td><td>结果的类型。MyBatis通常可以推算出来，但是为了更加确定写上也不会有什么问题。MyBatis允许任何简单类型用作主键的类型，包括字符串。如果希望作用于多个生成的列，则可以使用一个包含期望属性的Object或一个Map</td></tr><tr><td>order</td><td>这可以被设置为BEFORE或AFTER。如果设置为BEFORE，那么它会首先选择主键，设置keyProperty然后执行插入语句。如果设置为AFTER，那么先执行插入语句，然后是selectKey元素 - 这和像Oracle的数据库相似，在插入语句内部可能有嵌入索引调用</td></tr><tr><td>statementType</td><td>与前面相同，MyBatis支持STATEMENT，PREPARED和CALLABLE语句的映射类型，分别代表PreparedStatement和CallableStatement类型</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis-基本介绍及使用</title>
      <link href="/2023/10/07/Mybatis01%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/10/07/Mybatis01%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="MyBatis简介"><a href="#MyBatis简介" class="headerlink" title="MyBatis简介"></a>MyBatis简介</h1><h2 id="MyBatis历史"><a href="#MyBatis历史" class="headerlink" title="MyBatis历史"></a>MyBatis历史</h2><p>MyBatis最初是Apache的一个开源项目iBatis, 2010年6月这个项目由Apache Software Foundation迁 移到了Google Code。随着开发团队转投Google Code旗下， iBatis3.x正式更名为MyBatis。代码于 2013年11月迁移到Github。</p><p>iBatis一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。 iBatis提供的持久层框架 包括SQL Maps和Data Access Objects(DAO)。</p><h2 id="MyBatis下载"><a href="#MyBatis下载" class="headerlink" title="MyBatis下载"></a>MyBatis下载</h2><p>MyBatis下载地址: <a href="https://github.com/mybatis/mybatis-3">https://github.com/mybatis/mybatis-3</a></p><p>使用Maven创建工程可以不用下载jar包，在这里面选择下载全部资源然后找到里面的官方文档即可。不看官方文档的可以跳过这一步。</p><h2 id="MyBatis特性"><a href="#MyBatis特性" class="headerlink" title="MyBatis特性"></a>MyBatis特性</h2><p>MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架</p><p>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集</p><p>MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO映射成数据库中的记录</p><p>MyBatis 是一个 半自动的ORM(Object Relation Mapping) 框架</p><h3 id="为何使用MyBatis"><a href="#为何使用MyBatis" class="headerlink" title="为何使用MyBatis"></a>为何使用MyBatis</h3><ol><li>JDBC在创建Connection的时候，存在硬编码问题（也就是直接把连接信息写死，不方便后期维护）</li><li>preparedStatement对象在执行sql语句的时候存在硬编码问题</li><li>每次在进行一次数据库连接后都会关闭数据库连接，频繁的开启&#x2F;关闭数据连接影响性能</li></ol><h3 id="mybatis相对JDBC优势"><a href="#mybatis相对JDBC优势" class="headerlink" title="mybatis相对JDBC优势"></a>mybatis相对JDBC优势</h3><ol><li>mybatis是把连接数据库的信息都是写在配置文件中，因此不存在硬编码问题，方便后期维护</li><li>mybatis执行的sql语句都是通过配置文件进行配置，不需要写在Java代码中</li><li>mybatis的连接池管理、缓存管理等让连接数据库和查询数据效率更高</li></ol><h3 id="数据持久化概念"><a href="#数据持久化概念" class="headerlink" title="数据持久化概念"></a>数据持久化概念</h3><p>数据持久化：将内存的数据模型转换为存储模型，以及将存储模型转换为内存中的数据模型的统称文件的存储、数据的读取等都是数据持久化操作</p><p>数据模型可以是任何数据结构或对象模型，存储模型可以是关系模型、XML、二进制流等</p><h3 id="MyBatis框架即ORM（实现）"><a href="#MyBatis框架即ORM（实现）" class="headerlink" title="MyBatis框架即ORM（实现）"></a>MyBatis框架即ORM（实现）</h3><p>MyBatis是一个开源的数据持久层框架。内部封装了通过JDBC访问数据库的操作，支持普通的SQL查询、存储过程和高级映射，几乎消除了所有的JDBC代码和参数的手工设置以及结果集的检索。</p><p>MyBatis是一款优秀的持久层框架，它支持定制化SQL、存储过程以及高级映射。MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。MyBatis可以使用简单的XML或注解来配置和映射原生信息，将接口和Java的POJO（Plain Old Java Objects，普通Java对象）映射成数据库中的记录</p><p>MyBatis作为持久层框架，主要思想是将程序中的大量SQL语句剥离出来，配置在配置文件中，实现SQL的灵活配置。这样做的好处是将SQL与程序代码分离，可以在不修改程序代码的情况下，直接在配置文件中修改SQL</p><h4 id="ORM（对象-x2F-关系数据映射）"><a href="#ORM（对象-x2F-关系数据映射）" class="headerlink" title="ORM（对象&#x2F;关系数据映射）"></a>ORM（对象&#x2F;关系数据映射）</h4><p>ORM（Object&#x2F;Relational Mapping）即对象&#x2F;关系数据映射，可以理解为一种数据持久化技术。</p><p>在对象与关系型数据库之间建立起对应的关系，并且提供一种机制，通过JavaBean对象去操作数据库表中的数据。</p><p>ORM在对象模型和关系数据库的表之间建立了一座桥梁，不需要在使用SQL语句操作数据库中的表，可以直接使用API直接操作JavaBean对象就可以实现数据库的存储、查询、更改和删除等操作。</p><p>基于ORM，MyBatis在对象模型和关系数据库的表之间建立了一座桥梁，通过MyBatis建立SQL关系映射，以便捷地实现数据库存储、查询、更改和删除等操作。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20240225095242122.png" alt="image-20240225095242122"></p><h2 id="MyBatis基本要素"><a href="#MyBatis基本要素" class="headerlink" title="MyBatis基本要素"></a>MyBatis基本要素</h2><p>三个基本要素：</p><ol><li>核心接口和类（对象）</li><li>核心配置文件（mybatis-cofig.xml）</li><li>SQL映射文件（mapper.xml）</li></ol><p>使用过程：</p><ol><li>每个MyBatis的应用程序都以一个<code>SqlSessionFactory</code>对象的实例为核心</li><li>首先获取<code>SqlSesssionFactoryBuilder</code>对象，可以根据<code>XML配置文件或Connection类</code>的实例构建该对象</li><li>然后获取<code>SqlSessionFactory</code>对象，该对象实例可以通过<code>SqlSessionFactoryBuilder</code>对象来获得</li><li>有了<code>SqlSessionFactory</code>对象之后，就可以进而获取<code>SqlSession</code>实例，<code>SqlSession</code>对象中完全包含以数据库为背景的所有执行SQL操作的方法。可以通过该实例来直接执行以映射的SQL语句</li></ol><h2 id="MyBatis框架的优缺点"><a href="#MyBatis框架的优缺点" class="headerlink" title="MyBatis框架的优缺点"></a>MyBatis框架的优缺点</h2><p>优点：</p><ol><li>与JDBC相比，减少50%以上的代码量</li><li>MyBatis是最简单的持久化框架，小巧并且简单易学</li><li>代码中彻底分离，降低耦合度，便于统一管理和优化，并且可重用</li><li>提供XML标签，支持编写动态SQL语句</li><li>提供映射标签，支持对象与数据库的ORM字段关系映射</li></ol><p>缺点：</p><ol><li>SQL语句的编写工作量较大，对开发人员编写SQL语句的功底有一定要求</li><li>SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库</li></ol><h1 id="Mybatis基本使用"><a href="#Mybatis基本使用" class="headerlink" title="Mybatis基本使用"></a>Mybatis基本使用</h1><h2 id="Mybatis执行流程"><a href="#Mybatis执行流程" class="headerlink" title="Mybatis执行流程"></a>Mybatis执行流程</h2><ol><li><p>通过<code>Resources.getResourceAsStream</code>加载xml文件，将配置文件解析为一个流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;sqlMapConfig.xml&quot;</span>; <span class="comment">// 文件名</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(resource); <span class="comment">//获取文件的输入流</span></span><br></pre></td></tr></table></figure></li><li><p>SqlSessionFactoryBuilder.build()完成对配置文件的读取，构建SqlSessionFactory会话工厂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">build</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(is);</span><br></pre></td></tr></table></figure></li><li><p>通过SqlSessionFactory创建SqlSession</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> build.openSession();</span><br></pre></td></tr></table></figure></li><li><p>通过mapper文件的namespace和子元素的id来找到相应的SQL，从而执行查询操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不使用接口</span></span><br><span class="line">sqlSession.selectList(<span class="string">&quot;user.findUserById&quot;</span>, <span class="string">&quot;name like &#x27;曹%&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用mapper接口</span></span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.getFindUser(<span class="number">10</span>);</span><br><span class="line">session.commit();</span><br></pre></td></tr></table></figure></li><li><p>关闭SqlSession对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openSession.close();</span><br></pre></td></tr></table></figure></li></ol><ul><li>SqlSession：代表Java程序和数据库之间的会话。（HttpSession是Java程序和浏览器之间的会话）</li><li>SqlSessionFactory：是生产SqlSession的<strong>工厂</strong></li></ul><h2 id="Myabtis详细使用"><a href="#Myabtis详细使用" class="headerlink" title="Myabtis详细使用"></a>Myabtis详细使用</h2><blockquote><p>只记录最常用的方式，使用Mapper接口，该方式开发，不需要写dao层的实现类，mybatis会根据映射文件等信息对接口进行jdk动态代理生成代理类来实现接口中的方法</p></blockquote><ol><li><p>导入jar包</p></li><li><p>配置mybatis-config.xml核心配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 打印查询语句 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 和Spring整合后environment配置都会被干掉 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 使用jdbc事务管理，目前由mybatis来管理 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 数据库连接池，目前由mybatis来管理 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span><span class="comment">&lt;!--有关于mysql数据库的各种信息--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--将操作配置文件User.xml系添加进mapper--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mybatis/user.xml&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>实体类</p></li><li><p>Mapper接口，接口名要和xml映射的文件名一致</p></li><li><p>实体对应Mapper配置XML文件获取SqlSession工具类</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;user&quot;</span>&gt;</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 通过id查询用户 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.mvc.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--通过name查找一个list的用户，模糊匹配--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUserByName&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.mvc.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--插入用户信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.mvc.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--删除用户信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Integer&quot;</span>&gt;</span></span><br><span class="line">        delete from user where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--更新用户信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.mvc.User&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>获取SqlSession工具类</p><ul><li><p>SqlSessionFactoryBuilder</p><p>可以被实例化、使用和丢弃，一旦创建了SqlSessionFactory，就不再需要它了</p><p>因此SqlSessionFactoryBuilder实例的最佳范围（作用域）是方法范围（也就是局部方法变量）</p><p>可以重用SqlSessionFactoryBuilder来创建多个SqlSessionFactory实例，但是最好还是不要让其一直存在，以保证所有的XML解析资源开放给更重要的事情</p></li><li><p>SqlSessionFactory</p><p>一旦被创建就应该在应用的运行期间一直存在，没有任何理由对它进行清除或重建。</p><p>使用SqlSessionFactory的最佳实践是在应用运行期间不要重复创建多次。</p><p>SqlSessionFactory的最佳范围是应用范围</p></li><li><p>SqlSession</p><p>每个线程都应该有它自己的SqlSession实例。SqlSession的实例不是线程安全的，因此是不能被共享的，所以它的最佳的范围是请求或方法范围</p><p>绝对不能将SqlSession实例的引用放在一个类的静态域（静态变量），甚至一个类的实例变量也不行。也绝不能将SqlSession实例的引用放在任何类型的管理范围中</p><p>sqlSession有个方法：<code>getMapper(UserMapper.class);</code>，可以返回一个类的实例化对象。虽然UserMapper接口没有实现类，按理说不能创建实例化对象，但是mybatis底层会根据对应的<code>UserMapper.xml</code>文件创建一个实例化对象，充当实现类。使用代理模式</p></li></ul></li></ol><p>开发代理规范：</p><ol><li>mapper接口的全限定名要和mapper映射文件的namespace值一致</li><li>mapper接口的方法名称要和mapper映射文件的statement的id一致</li><li>mapper接口的方法参数类型要和mapper映射文件的statement的parameterType的值一致，而且它的参数是一个</li><li>mapper接口的方法返回值类型要和mapper映射文件的statement的resultType的值一致</li></ol><h1 id="Mybatis入门案例"><a href="#Mybatis入门案例" class="headerlink" title="Mybatis入门案例"></a>Mybatis入门案例</h1><p>相关概念：<strong>ORM(Object Relationship Mapping)对象关系映射</strong>。</p><ul><li>对象：Java的实体类对象</li><li>关系：关系型数据库</li><li>映射：二者之间的对应关系</li></ul><table><thead><tr><th>Java概念</th><th>数据库概念</th></tr></thead><tbody><tr><td>类</td><td>表</td></tr><tr><td>属性</td><td>字段&#x2F;列</td></tr><tr><td>对象</td><td>记录&#x2F;行</td></tr></tbody></table><h2 id="创建maven工程"><a href="#创建maven工程" class="headerlink" title="创建maven工程"></a>创建maven工程</h2><ol><li><p>创建一个普通Java项目，然后在其中新建一个maven工程。配置maven打包方式为jar。</p><p>maven工程和spring工程引入mybatis不一样，这里大致了解就行，很多配置在后面都简化了</p></li><li><p>引入mybatis、junit、mysql依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Mybatis核心 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- junit测试 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- MySQL驱动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>建立sql表单</p><p>创建一个名称为 user 的table，并设置属性：id(主键、非空、自增)、username等</p></li><li><p>创建 MyBatis核心配置文件</p><p>习惯上命名为<code>mybatis-config.xml</code>，这个文件名仅仅只是建议，并非强制要求。</p><p>将来整合Spring或者SpringBoot之后，这个配置文件直接省略，由Spring的配置文件一同管理，而且内容只有几处需要修改，操作时直接复制、粘贴。</p><p>核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息。存放的于<code>src/main/resources</code>目录下。</p><p>新建一个<code>mybatis-config.xml</code>文件，将以下内容粘贴进去：</p><p>配置了多个使用环境，其中单个环境包括有：事务方式、数据源、JDBC四件套</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置连接数据库的环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span></span></span><br><span class="line"><span class="tag">                          <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span></span></span><br><span class="line"><span class="tag">                &lt;<span class="attr">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;161519&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入映射文件--&gt;</span> <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mappers/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建Mapper接口</p><p>MyBatis中的mapper接口相当于以前的dao。</p><p>区别在于：mapper仅仅是接口，我们不需要提供实现类。</p></li><li><p>创建实体类，对应表单 </p><p>创建Users实体类，对应表单 user。User类中，包括private类型的对应字段、一个有参构造器、一个无参构造器、所有字段的getter和setter。用lombok注解简化</p></li><li><p>创建UserMapper接口</p><p>MyBatis面向接口编程的两个一致：</p><ol><li>映射文件namespace和Mapper接口的全类名一致（第一个一致）</li><li>映射文件中sql语句的id和mapper接口中的方法一致（第二个一致）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">insertUser</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>映射路径：在UserMapper.xml中，namespace为 <code>UserMapper全路径</code> ，通过<code>namespace</code>定位到这个UserMapper接口</p><p>UserMapper接口定义方法，通过方法名和xml文件中SQL语句的<code>id</code>属性定位SQL语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加用户信息</span></span><br><span class="line"><span class="comment">     * sql写在映射文件中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insertUser</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改用户信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除用户信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deleteUser</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据id查询用户信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    User <span class="title function_">getUserById</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有的用户信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">getAllUser</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>创建MyBatis的映射文件</p><p>映射文件的命名规则：表所对应的实体类的<code>类名+Mapper.xml</code></p><p>例如:</p><ul><li>表user，映射的实体类为User，所对应的映射文件为UserMapper.xml (一张表一个映射文件)</li><li>一个映射文件对应一个实体类，对应一张表的操作</li><li>MyBatis映射文件用于编写SQL，访问以及操作表中的数据</li><li>MyBatis映射文件存放的位置是<code>src/main/resources/mappers</code></li></ul><p>再次强调，MyBatis中可以面向接口操作数据，<strong>要保证两个一致:</strong></p><ol><li>mapper接口的全类名(实体类中 package 后面的那一串)和映射文件的命名空间(namespace)保持一致</li><li>mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致</li></ol><p>在src&#x2F;main&#x2F;resources下，创建UserMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.atguigu.mybatis.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--int insertUser();--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">        insert into t_user values(null, &quot;marina&quot;,&quot;456&quot;,23,&#x27;f&#x27;,&quot;153456@qq.com&quot;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--void updateUser();--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span>&gt;</span></span><br><span class="line">        update t_user set username = &quot;RUOYI&quot; where id = 4</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--void deleteUser();--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUser&quot;</span>&gt;</span></span><br><span class="line">        delete from t_user where id = 5</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--User getUserById();--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        查询功能的标签必须设置resultType或者resultMap</span></span><br><span class="line"><span class="comment">        resultType：设置默认的映射关系</span></span><br><span class="line"><span class="comment">        resultMap：设置自定义的映射关系（字段名和表头不一样）</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from t_user where id = 4</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--List&lt;User&gt; getAllUser();--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        select * from t_user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改核心配置文件，引入映射文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--设置连接数据库的环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span></span></span><br><span class="line"><span class="tag">                          <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span></span></span><br><span class="line"><span class="tag">                          &lt;<span class="attr">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;161519&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--引入映射文件--&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mappers/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserMapperTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsertUser</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//读取MyBatis的核心配置文件</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取SqlSessionFactoryBuilder对象</span></span><br><span class="line">        <span class="type">SqlSessionFactoryBuilder</span> <span class="variable">sqlSessionFactoryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line">        <span class="comment">//通过核心配置文件所对应的字节输入流创建工厂类SqlSessionFactory</span></span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(is);</span><br><span class="line">        <span class="comment">//获取sqlSession</span></span><br><span class="line">        <span class="comment">//此时通过SqlSession对象所操作的sql都必须手动提交或回滚事务</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">    <span class="comment">//此时通过SqlSession对象所操作的sql都会自动提交  </span></span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//通过代理模式创建UserMapper接口的代理实现类对象</span></span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        <span class="comment">//调用UserMapper接口中的方法，就可以根据UserMapper的全类名匹配元素文件，通过调用的方法名匹配映射文件中的SQL标签，并执行标签中的SQL语句</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.insertUser();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//提交事务，注意事务和SQL的顺序</span></span><br><span class="line">        <span class="comment">//sqlSession.commit();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;result:&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在获取sqlSession对象时，根据<code>sqlSessionFactory.openSession(true);</code>的参数不同，决定事务的使用方式，传入true，就可以自动提交。默认是false，需要手动提交</p></li></ol><h1 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h1><h2 id="SqlSessionFactoryBuilder（类）"><a href="#SqlSessionFactoryBuilder（类）" class="headerlink" title="SqlSessionFactoryBuilder（类）"></a>SqlSessionFactoryBuilder（类）</h2><p>SqlSessionFactoryBuilder的作用：负责构建SqlSessionFactory，并且提供了多个build方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build(InputStream inputstream,String environment,Properties properties)</span><br></pre></td></tr></table></figure><blockquote><p>Environment和properties都是可选的，所以说构造方法重载了三种，InputStream字节流可以换为Reader字符流读取</p></blockquote><h3 id="构建一个SqlSessionFactory"><a href="#构建一个SqlSessionFactory" class="headerlink" title="构建一个SqlSessionFactory"></a>构建一个SqlSessionFactory</h3><p>有两种方式：</p><ol><li>读取XML配置文件构造方式</li><li>编程构造方式</li></ol><h3 id="声明周期和作用域"><a href="#声明周期和作用域" class="headerlink" title="声明周期和作用域"></a>声明周期和作用域</h3><p>SqlSessionFactoryBuilder的最大特点用过即丢。，一旦创建了SqlSessionFactory对象之后，这个类就不再需要存在了，因此SqlSessionFactoryBuilder的最佳范围就是存在于方法体内，也就局部变量而已。</p><h2 id="SqlSessionFactory（接口）"><a href="#SqlSessionFactory（接口）" class="headerlink" title="SqlSessionFactory（接口）"></a>SqlSessionFactory（接口）</h2><p>SqlSessionFactory的作用：创建SqlSession实例的工厂。所有的MyBatis应用都是以SqlSessionFactory实例为中心，SqlSessionFactory的实例可以通过SqlSessionFactoryBuilder对象来获得。</p><p>通过SqlSessionFactory提供的openSession()方法来获取SqlSession实例</p><blockquote><p>openSession()方法的参数为boolean值时，若传入true表示关闭事务控制，自动提交；false表示开启事务控制。默认为true。</p></blockquote><h3 id="生命周期和作用域"><a href="#生命周期和作用域" class="headerlink" title="生命周期和作用域"></a>生命周期和作用域</h3><p>一旦创建，就会在整个应用运行过程中始终存在。没有理由去销毁在创建它，并且在应用程序运行中也不建议多次创建SqlSessionFactory。因此SqlSessionFactory的最佳作用域是Application，即随着应用的生命周期一同存在。</p><p>那么这种<strong>存在于整个应用运行期间，并且同时只存在一个对象实例</strong>的模式就是所谓的<strong>单例模式</strong></p><blockquote><p>指在应用运行期间有且仅有一个实例</p><p>最简单的实现方式就是放在静态代码块下，以保证SqlSessionFactory对象只被创建一次</p><p>最佳的解决方案是使用依赖注入容器——Spring框架来管理SqlSessionFactory的单例声明周期。Spring的bran默认都是单例的</p></blockquote><h2 id="SqlSession（接口）"><a href="#SqlSession（接口）" class="headerlink" title="SqlSession（接口）"></a>SqlSession（接口）</h2><p>SqlSession是用于执行持久化操作的对象，类似于JDBC中的Connection。它提供了面向数据库执行SQL命令所需的所有方法，可以通过SqlSession实例直接运行以映射的SQL语句</p><h3 id="生命周期和作用域-1"><a href="#生命周期和作用域-1" class="headerlink" title="生命周期和作用域"></a>生命周期和作用域</h3><p>SqlSession对应这一次数据库会话。由于数据库会话不是永久的，因此SqlSession的生命周期也不应该是永久的。<br>相反，每次在访问数据库时都需要创建它，并不是说在SqlSession例只能执行依次SQL，是完全可以执行多次的，但是若关闭了SqlSession，那么就需要重新创建它</p><p>创建SqlSession的地方只有一个，那就是<code>SqlSessionFactory</code>对象的<code>openSession()</code>方法</p><p>需要注意：每个线程都有自己的SqlSession实例，SqlSession实例不能被共享，也不是线程安全的。因此最佳的作用域范围是request作用域或者方法体作用域内</p><p>关闭SqlSession是非常重要的。必须确保SqlSession在finally语句块中正常关闭</p><p>SqlSession的两种使用方式</p><ol><li>通过SqlSession实例来直接执行已映射的SQL语句。</li><li>基于mapper接口方式操作数据</li></ol><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20240227100214296.png" alt="image-20240227100214296"></p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-高级</title>
      <link href="/2023/10/03/MySQL02%E9%AB%98%E7%BA%A7/"/>
      <url>/2023/10/03/MySQL02%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>视图（view）是一种虚拟存在的表。视图中的数据并不存在数据库中实际存在，行和列数据来自定义视图的查询中使用过的表，并且是在使用视图时动态生成的（视图的数据不是唯一的，而是随着表的数据变化而变化）</p><p>通俗的讲，<strong>视图只保存了查询的SQL逻辑，不保存查询的结果</strong>。所以我们在创建视图的时候，主要的工作就落在创建这条SQL语句上。</p><ol><li><p>创建</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">or</span> replace] <span class="keyword">view</span> 视图名称[(列名列表)] <span class="keyword">as</span> <span class="keyword">select</span>语句 [<span class="keyword">with</span>[<span class="keyword">cascaded</span><span class="operator">|</span><span class="keyword">local</span>] <span class="keyword">check</span> option]</span><br><span class="line"></span><br><span class="line"><span class="comment">--创建视图</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_v_1 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">where</span> id<span class="operator">&lt;</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查看创建视图语句</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">view</span> 视图名称;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查看视图数据(可以将视图理解为表的查询使用)</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 视图名称....;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">view</span> stu_v_1;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu_v_1;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> stu_v_1 <span class="keyword">where</span> id<span class="operator">&lt;</span><span class="number">5</span>;</span><br></pre></td></tr></table></figure></li><li><p>修改</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--方式一</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> 视图名称[(列名列表)] <span class="keyword">as</span> <span class="keyword">select</span>语句 [<span class="keyword">with</span>[<span class="keyword">cascaded</span><span class="operator">|</span><span class="keyword">local</span>]<span class="keyword">check</span> option]</span><br><span class="line"></span><br><span class="line"><span class="comment">--方式二</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> 视图名称[(列名列表)] <span class="keyword">as</span> <span class="keyword">select</span>语句 [<span class="keyword">with</span>[<span class="keyword">cascaded</span><span class="operator">|</span><span class="keyword">local</span>] <span class="keyword">check</span> option]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace stu_v_1 <span class="keyword">as</span> <span class="keyword">select</span> id,name,<span class="keyword">no</span> <span class="keyword">from</span> student <span class="keyword">where</span> id<span class="operator">&lt;=</span><span class="number">10</span>;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> stu_v_1 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">where</span> id<span class="operator">&lt;=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> [if <span class="keyword">exists</span>] 视图名称[,视图名称]</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> if <span class="keyword">exists</span> stu_v_1;</span><br></pre></td></tr></table></figure></li></ol><h2 id="检查选项"><a href="#检查选项" class="headerlink" title="检查选项"></a>检查选项</h2><p>当使用**<code>WITH CHECK OPTION</code>**子句创建视图时，MySQL会通过试图检查正在更改的每个行，例如 插入、更新、删除，以使其符合视图的定义。MySQL允许基于另一个视图创建视图，他还会检查依赖视图中的规则来保持一致性。为了确定检查的范围，MySQL提供了两个选项：cascaded和local，默认值为cascaded</p><h3 id="cascaded"><a href="#cascaded" class="headerlink" title="cascaded"></a>cascaded</h3><p>用继承帮助理解。使用这个关键字，不管父类有没有用**<code>WITH CHECK OPTION</code><strong>，都会检查父类的</strong><code>where</code>**条件。但是不管子类。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">创建视图</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v1 <span class="keyword">as</span> <span class="keyword">select</span> id,namd <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span><span class="number">20</span> <span class="keyword">with</span> <span class="keyword">cascaded</span> <span class="keyword">check</span> option;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v2 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> v1 <span class="keyword">where</span> id <span class="operator">&gt;=</span><span class="number">10</span> <span class="keyword">with</span> <span class="keyword">cascaded</span> <span class="keyword">check</span> option;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v3 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> v2 <span class="keyword">where</span> id<span class="operator">&lt;</span><span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">插入测试</span><br><span class="line"><span class="comment">--1</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_v_1 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">where</span> id<span class="operator">&lt;=</span><span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--2, 可以正常运行，但是数据添加在 student 表中，而不是在视图中。视图可以查看到</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_1 <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--3，可以正常运行，不报错，但是数据添加在 student 表中，而不是在视图中。视图中不存在这条数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_1 <span class="keyword">values</span>(<span class="number">25</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--4</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_v_2 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> stu_v_1 <span class="keyword">where</span> id<span class="operator">&gt;=</span><span class="number">10</span> <span class="keyword">with</span> <span class="keyword">cascaded</span> <span class="keyword">check</span> option;</span><br><span class="line"></span><br><span class="line"><span class="comment">--5 报错，因为不满足 id&gt;=10 的条件</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_2 <span class="keyword">values</span>(<span class="number">7</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--6 报错，因为不满足 v1视图 的id &lt;=20 条件</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_2 <span class="keyword">values</span>(<span class="number">26</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--7 可以正常运行，首先判断 是否满足4中 id&gt;=10 的条件，其次检查是否满足1中 id&lt;=20 的条件</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_2 <span class="keyword">values</span>(<span class="number">15</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--8 </span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_v_3 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> stu_v_2 <span class="keyword">where</span> id<span class="operator">&lt;=</span><span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--9 可以正常运行，因为满足v3中id&lt;=15，v2中id&gt;=10, v1&lt;=20 的条件</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_3 <span class="keyword">values</span>(<span class="number">11</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--10 可以正常运行，v3视图没有with cascaede check option,所以不会检查是否 &lt;=15,</span></span><br><span class="line"><span class="comment">--   然后检查v2视图条件，满足 id&gt;=10</span></span><br><span class="line"><span class="comment">--   因为v2视图含有with cascaede check option，检查v1视图条件 id&lt;=20</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_3 <span class="keyword">values</span>(<span class="number">17</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--11 报错，v3视图没有with cascaede check option,所以不会检查是否 &lt;=15,</span></span><br><span class="line"><span class="comment">--   然后检查v2视图条件，满足 id&gt;=10</span></span><br><span class="line"><span class="comment">--   因为v2视图含有with cascaede check option，检查v1视图条件 id&lt;=20，不满足，报错</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_3 <span class="keyword">values</span>(<span class="number">28</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="local"><a href="#local" class="headerlink" title="local"></a>local</h3><p>用继承帮助理解。使用这个关键字，如果父类使用**<code>WITH CHECK OPTION</code><strong>，才检查父类的</strong><code>where</code><strong>条件，没有</strong><code>WITH CHECK OPTION</code>**就不加条件。同样不管子类。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">创建视图</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_v_4 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> student <span class="keyword">where</span> id<span class="operator">&lt;=</span><span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">插入测试</span><br><span class="line"><span class="comment">--2, 可以正常运行，但是数据添加在 student 表中，而不是在视图中。视图可以查看到</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_4 <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--3，可以正常运行，不报错，但是数据添加在 student 表中，而不是在视图中。视图中不存在这条数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_4 <span class="keyword">values</span>(<span class="number">16</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--4</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_v_5 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> stu_v_4 <span class="keyword">where</span> id<span class="operator">&gt;=</span><span class="number">10</span> <span class="keyword">with</span> <span class="keyword">local</span> <span class="keyword">check</span> option;</span><br><span class="line"></span><br><span class="line"><span class="comment">--5 可以正常运行，不报错，，因为满足v5的id&gt;=10，且v4的id&lt;=15不检查(没有local) 的条件</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_5 <span class="keyword">values</span>(<span class="number">13</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--6 可以正常运行，不报错，因为满足v5的id&gt;=10，且v4的id&lt;=15不检查(没有local) 的条件</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_5 <span class="keyword">values</span>(<span class="number">17</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--7 </span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_v_6 <span class="keyword">as</span> <span class="keyword">select</span> id,name <span class="keyword">from</span> stu_v_5 <span class="keyword">where</span> id<span class="operator">&lt;=</span><span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--8 可以正常运行，因为满足v5的id&gt;=10，且v4的id&lt;=15和v6的id&lt;=20不检查(没有local) 的条件</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> stu_v_6 <span class="keyword">values</span>(<span class="number">14</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="视图的更新和作用"><a href="#视图的更新和作用" class="headerlink" title="视图的更新和作用"></a>视图的更新和作用</h2><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一项，则该视图不可更新：</p><ol><li>聚合函数或者函窗口函数（sum(), min(), max(), count()等）</li><li>distinct 去重</li><li>group by 分组</li><li>having 过滤</li><li>union 或者 union all 合并查询结果</li></ol><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li><p>简单</p><p>视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件</p></li><li><p>安全</p><p>数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能看到的数据</p></li><li><p>数据独立</p><p>视图可以帮助用户屏蔽真实表结构变化带来的影响</p></li></ol><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310041019321.png"></p><ol><li><p>为了保证数据库表的安全性，开发人员在操作tb_user表时，只能看到的用户的基本字段，屏蔽手机号和邮箱两个字段。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> tb_user_view <span class="keyword">as</span> <span class="keyword">select</span> id,name,profession,age,gender,status <span class="keyword">from</span> tb_user;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user_view;</span><br></pre></td></tr></table></figure></li><li><p>查询每个学生所选修的课程（三张表联查），这个功能在很多业务中都有使用到，为了简化操作，定义一个视图</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">多表联查</span><br><span class="line"><span class="keyword">select</span> s.name,s.no,c.name <span class="keyword">from</span> student s,stuent_course sc,course c <span class="keyword">where</span> s.id <span class="operator">=</span> sc.studentid <span class="keyword">and</span> c.id <span class="operator">=</span> sc.courseid;</span><br><span class="line"></span><br><span class="line">根据联查创建视图</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> tb_stu_course_view <span class="keyword">as</span> selest s.name,s.no,c.name <span class="keyword">from</span> student s,stuent_course sc,course c <span class="keyword">where</span> s.id <span class="operator">=</span> sc.studentid <span class="keyword">and</span> c.id <span class="operator">=</span> sc.courseid;</span><br><span class="line"></span><br><span class="line">这一步大概率报错，说叫name的太多了，要起别名</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> tb_stu_course_view <span class="keyword">as</span> selest s.name student_name,s.no student_no,c.name course_name <span class="keyword">from</span> student s,stuent_course sc,course c <span class="keyword">where</span> s.id <span class="operator">=</span> sc.studentid <span class="keyword">and</span> c.id <span class="operator">=</span> sc.courseid;</span><br></pre></td></tr></table></figure></li></ol><h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><p>存储过程是事先经过编译并存储在数据库中的一段sql语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的</p><p>存储过程思想很简单，就是把数据库SQL语言层面的代码封装与重用</p><p><strong>特点：</strong>封装、复用；可以接受参数，也可以返回数据；减少网络交互，效率提升</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>创建</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名称([参数列表])</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  若干<span class="keyword">sql</span>语句</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>调用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> 名称([参数])</span><br></pre></td></tr></table></figure><p>查看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查询指定数据库的存储过程及状态信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.routines <span class="keyword">where</span> routine_schema<span class="operator">=</span><span class="string">&#x27;xxx&#x27;</span>;  </span><br><span class="line"></span><br><span class="line">查询某个存储过程的定义</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名称;</span><br></pre></td></tr></table></figure><p>删除</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> [if <span class="keyword">exists</span>] 存储过程名称;</span><br></pre></td></tr></table></figure><p>例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">存储过程基本语法</span><br><span class="line"></span><br><span class="line">创建</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p1()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> student;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">调用</span><br><span class="line"><span class="keyword">call</span> p1();</span><br><span class="line"></span><br><span class="line">查看  (查看itcast数据库的所有存储过程)</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.ROUTINES <span class="keyword">where</span> ROUTINE_SCHEMA<span class="operator">=</span><span class="string">&#x27;itcast&#x27;</span></span><br><span class="line">(查看存储过程p1的创建语句)</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">procedure</span> p1;</span><br><span class="line"></span><br><span class="line">删除</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> if <span class="keyword">exists</span> p1; </span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310041105910.png"></p><p>报错，因为命令行看见 ; 就认为结束了，打断正确语法</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310041106783.png"></p><blockquote><p><strong>注意：在命令行中，执行创建存储过程的SQL时，需要通过关键词delimiter指定SQL语句的结束符（见上图）</strong></p></blockquote><blockquote><p>delimiter：更改结束符号，如上图改为$$，避免提前结束。但是效果是持久的，要么改回来，要么j就用改的</p></blockquote><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310041117993.png"></p><h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><p>是MySQL服务器提供的，不是用户定义的，属于服务器层面。分为全局变量（GLOBAL）、会话变量（SESSION），默认会话变量</p><blockquote><p>类似浏览器页面，一个页面就是一个会话</p></blockquote><p>查看系统变量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">查看所有系统变量</span><br><span class="line"><span class="keyword">show</span> [session<span class="operator">|</span><span class="keyword">global</span>] variables; </span><br><span class="line"></span><br><span class="line">可以通过<span class="keyword">like</span>模糊匹配方式查找变量</span><br><span class="line"><span class="keyword">show</span> [session<span class="operator">|</span><span class="keyword">global</span>] variables <span class="keyword">like</span> <span class="string">&#x27;xxxx&#x27;</span>;</span><br><span class="line"></span><br><span class="line">查看指定变量的值</span><br><span class="line"><span class="keyword">select</span> @@[session<span class="operator">|</span><span class="keyword">global</span>] 系统变量名;</span><br></pre></td></tr></table></figure><p>设置系统变量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> [session<span class="operator">|</span><span class="keyword">global</span>] 系统变量名<span class="operator">=</span>值;</span><br><span class="line"><span class="keyword">set</span> @@[session<span class="operator">|</span><span class="keyword">global</span>] 系统变量名<span class="operator">=</span>值;</span><br></pre></td></tr></table></figure><blockquote><p>如果没有指定session、global，默认是session级别，会话变量</p><p>MySQL服务重新启动之后，所设置的全局参数会失效，想要不失效，可以在&#x2F;etc&#x2F;my.cnf中配置</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--  变量：系统变量</span></span><br><span class="line"><span class="comment">--  查看系统变量</span></span><br><span class="line"><span class="keyword">show</span> session variables;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> session variables <span class="keyword">like</span> <span class="string">&#x27;auto%&#x27;</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;auto%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@autocommit</span>;</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@global</span>.autocommit;   <span class="comment">--查看global级别的autocommit变量值1</span></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@session</span>.autocommit;  <span class="comment">--查看session级别的autocommit变量值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--  设置系统变量</span></span><br><span class="line"><span class="keyword">set</span> session autocommit <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> autocommit<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="用户自定义变量"><a href="#用户自定义变量" class="headerlink" title="用户自定义变量"></a>用户自定义变量</h3><p>是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用”@变量名”使用就可以。其作用域为当前连接（session级别）</p><blockquote><p>@@ 是系统变量</p><p>@    是用户自定义变量 </p></blockquote><p>赋值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="variable">@var</span>_name <span class="operator">=</span> expr [,<span class="variable">@var</span>_name2 <span class="operator">=</span> expr]...;</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@var</span>_name :<span class="operator">=</span> expr [,<span class="variable">@var</span>_name2 :<span class="operator">=</span> expr]...;</span><br><span class="line"></span><br><span class="line">推荐 :<span class="operator">=</span> ，用以区分等于运算符</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="variable">@var</span>_name :<span class="operator">=</span>expr[,<span class="variable">@var</span>_name2:<span class="operator">=</span>expr]...;</span><br><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">into</span> <span class="variable">@var</span>_name <span class="keyword">from</span> 表名；</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="variable">@var</span>_name;</span><br></pre></td></tr></table></figure><blockquote><p>用户定义的变量无需对其进行声明或初始化，只不过获取到的值为null</p></blockquote><p>例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--变量：用户变量</span></span><br><span class="line"><span class="comment">--赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="variable">@myname</span> <span class="operator">=</span> <span class="string">&#x27;itcast&#x27;</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@myage</span> :<span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@mygender</span> :<span class="operator">=</span><span class="string">&#x27;男&#x27;</span>,<span class="variable">@myhobby</span>:<span class="operator">=</span><span class="string">&#x27;java&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="variable">@mycolor</span> :<span class="operator">=</span> <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">into</span> <span class="variable">@mycount</span> <span class="keyword">from</span> tb_user;</span><br><span class="line"></span><br><span class="line"><span class="comment">--使用</span></span><br><span class="line"><span class="keyword">select</span> <span class="variable">@myname</span>,<span class="variable">@myage</span>,<span class="variable">@mygender</span>,<span class="variable">@myhobby</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@mycolor</span>,<span class="variable">@mycount</span>;</span><br></pre></td></tr></table></figure><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>局部变量是根据需要定义的在局部生效的变量，访问之前，需要declare声明。可以作存储过程内的局部变量和输入参数，局部变量的范围是在其内部声明的<code>begin ... end</code>块中有效，超出则无效。</p><p>声明</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> 变量名 数据类型 [<span class="keyword">default</span> 默认值];</span><br><span class="line"></span><br><span class="line">变量的数据类型就是数据库字段类型：<span class="type">int</span>, <span class="type">bigint</span>, <span class="type">char</span>, <span class="type">varchar</span>, <span class="type">date</span>, <span class="type">time</span>等</span><br></pre></td></tr></table></figure><p>赋值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--赋值</span></span><br><span class="line"><span class="keyword">set</span> 变量名 :<span class="operator">=</span> 值;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">into</span> 变量名 <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure><h2 id="if条件判断"><a href="#if条件判断" class="headerlink" title="if条件判断"></a>if条件判断</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if 条件<span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">....</span><br><span class="line">elseif 条件<span class="number">2</span> <span class="keyword">then</span></span><br><span class="line">....</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">....</span><br><span class="line"><span class="keyword">end</span> if; 用来结束if</span><br></pre></td></tr></table></figure><p>例：</p><p>定义存储过程，完成如下需求</p><p>根据定义的分数score变量，判断当前分数对应的分数等级</p><ol><li>score&gt;&#x3D;85,等级为优秀</li><li>score&gt;&#x3D;60分 且 score &lt;85分，等级为及格</li><li>score&lt;60分，等级为不及格</li></ol><p>缺点：</p><ol><li>当前数据写死，要改为由变量传递数值</li><li>当前结果只是展示，需要实现返回</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p1()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> scoure <span class="type">int</span> <span class="keyword">default</span> <span class="number">58</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">result</span> <span class="type">varchar</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">if score <span class="operator">&gt;=</span><span class="number">85</span> <span class="keyword">then</span>     <span class="comment">--情况1</span></span><br><span class="line">      <span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;优秀&#x27;</span>;</span><br><span class="line">elseif score<span class="operator">&gt;=</span><span class="number">60</span> <span class="keyword">then</span>  <span class="comment">--情况2 </span></span><br><span class="line">  <span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;及格&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span>                   <span class="comment">--余下情况    </span></span><br><span class="line">      <span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;不及格&#x27;</span>;</span><br><span class="line"><span class="keyword">end</span> if;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">result</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h2 id="参数（IN，OUT，INOUT）"><a href="#参数（IN，OUT，INOUT）" class="headerlink" title="参数（IN，OUT，INOUT）"></a>参数（IN，OUT，INOUT）</h2><table><thead><tr><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>IN（默认值）</td><td>该类参数作为输入，也就是需要调用时传入值</td></tr><tr><td>OUT</td><td>该类参数作为输出，也就是该参数可以作为返回值</td></tr><tr><td>INOUT</td><td>既可以作为参数，也可以作为输出参数</td></tr></tbody></table><p>用法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名称([<span class="keyword">IN</span><span class="operator">/</span><span class="keyword">OUT</span><span class="operator">/</span><span class="keyword">INOUT</span> 参数名 参数类型])</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">sql</span>语句</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>例</p><ol><li><p>根据传入参数score，判断当前分数对应的分数等级，并返回</p></li><li><ol><li>score&gt;&#x3D;85分，等级为优秀</li><li>score&gt;&#x3D;60 且score&lt;85分，等级为及格</li><li>score&lt;60分，等级为不及格</li></ol></li><li><p>&#96;&#96;&#96;sql<br>create procedure p1(in score int,out result varchar(10))<br>begin<br>  if score &gt;&#x3D; 85 then<br>set result :&#x3D; ‘优秀’;<br>  elseif score &gt;&#x3D; 60 then<br>set result :&#x3D; ‘及格’;<br>  else<br>set result :&#x3D; ‘不及格’;<br>  end if;<br>end;</p><p>call p1(66,@result)<br>select @result;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. </span><br><span class="line"></span><br><span class="line">## case</span><br><span class="line"></span><br><span class="line">![](https://raw.githubusercontent.com/icyhalo/picgo/main/202310041516564.png)</span><br><span class="line"></span><br><span class="line">```sql</span><br><span class="line">--case</span><br><span class="line">--根据传入的月份，判断月份所属的季节（要求采用case结构）</span><br><span class="line">--1-3月份，为第一季度</span><br><span class="line">--4-6月份，为第二季度</span><br><span class="line">--7-9月份，为第三季度</span><br><span class="line">--10-12月份，为第四季度</span><br><span class="line"></span><br><span class="line">create procedure p6(in month int)</span><br><span class="line">begin</span><br><span class="line">  declare result varchar(10);</span><br><span class="line">  case </span><br><span class="line">when month&gt;=1 and month&lt;=3 then </span><br><span class="line">set result:=&#x27;第一季度&#x27;;</span><br><span class="line">      when month&gt;=4 and month&lt;=6 then </span><br><span class="line">    set result:=&#x27;第二季度&#x27;;</span><br><span class="line">when month&gt;=7 and month&lt;=9 then </span><br><span class="line">set result:=&#x27;第三季度&#x27;;</span><br><span class="line">      when month&gt;=10 and month&lt;=12 then </span><br><span class="line">    set result:=&#x27;第四季度&#x27;;</span><br><span class="line">else </span><br><span class="line">set result:=&#x27;非法参数&#x27;;</span><br><span class="line">end case;</span><br><span class="line">  select concat(&#x27;您输入的月份为&#x27;,month,&#x27;,所属的季度为：&#x27;,result);</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">call p6(4);</span><br></pre></td></tr></table></figure></li></ol><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p>while循环是有条件的循环控制语句。满足条件后，再执行循环体中的SQL语句。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">先判断条件，如果条件为<span class="literal">true</span>，则执行逻辑，否则不执行逻辑</span><br><span class="line">while 条件 do</span><br><span class="line">sql...</span><br><span class="line"><span class="keyword">end</span> while;</span><br></pre></td></tr></table></figure><p>例：</p><p>计算从1累加到n的值，n为传入的参数值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p7(<span class="keyword">in</span> n <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> total <span class="type">int</span> defult <span class="number">0</span>;</span><br><span class="line">while n<span class="operator">&gt;</span><span class="number">0</span> do</span><br><span class="line">  <span class="keyword">set</span> total :<span class="operator">=</span> total <span class="operator">+</span> n;</span><br><span class="line">  <span class="keyword">set</span> n :<span class="operator">=</span> n<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> p7(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h3><p>repeat是有条件的循环控制语句，当满足条件的时候退出循环。</p><blockquote><p>至少执行一次，其余和 while 相反</p></blockquote><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#先执行一次逻辑，然后判断逻辑是否满足，如果满足，则退出。如果不满足，则继续下一次循环</span><br><span class="line">repeat</span><br><span class="line">    <span class="keyword">sql</span>逻辑</span><br><span class="line">    until条件</span><br><span class="line"><span class="keyword">end</span> repeat;</span><br></pre></td></tr></table></figure><p>例：</p><p>计算从1累加到n的值，n为传入的参数值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--A，定义局部变量，记录累加之后的值</span></span><br><span class="line"><span class="comment">--B，每循环一次，就会对n进行减1，如果n减到0，则退出循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p8(<span class="keyword">in</span> n <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line">    <span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    repeat</span><br><span class="line">        <span class="keyword">set</span> total <span class="operator">=</span> total <span class="operator">+</span> n;</span><br><span class="line">        <span class="keyword">set</span> n <span class="operator">=</span> n<span class="number">-1</span>;</span><br><span class="line">        until n<span class="operator">&lt;=</span><span class="number">0</span></span><br><span class="line">    <span class="keyword">end</span> repeat;</span><br><span class="line">    <span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> p8(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">call</span> p8(<span class="number">11</span>);</span><br></pre></td></tr></table></figure><h3 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h3><p>loop实现简单的循环，如果不在SQL逻辑中增加退出循环的条件，可以用其来实现简单的死循环。loop可以配合以下两个语句使用：</p><ul><li>leave：配合循环使用，退出循环</li><li>iterate：必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--[begin_label]的意思是标记一个名字为 [begin_label] 的循环</span></span><br><span class="line"></span><br><span class="line">[begin_label]loop</span><br><span class="line">    <span class="keyword">sql</span>逻辑</span><br><span class="line"><span class="keyword">end</span> loop [end_label]</span><br><span class="line"></span><br><span class="line">leave label;    <span class="comment">--退出指定标记的循环体，label 循环的标识</span></span><br><span class="line">iterate label;  <span class="comment">--直接进入下一次循环</span></span><br></pre></td></tr></table></figure><p>例：</p><ol><li>计算从1累加到n的值，n为传入的参数值</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p9()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    sum:loop                       <span class="comment">-- sum:loop 意思是：创建一个名字为sum的loop循环，从此处开始</span></span><br><span class="line">        if n<span class="operator">&lt;=</span><span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">            leave sum;             <span class="comment">-- leave sum 意思是：如果满足if的条件，则结束sum整这个循环</span></span><br><span class="line">        <span class="keyword">end</span> if;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">set</span> total <span class="operator">=</span> total <span class="operator">+</span> n;</span><br><span class="line">        <span class="keyword">set</span> n <span class="operator">=</span> n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">end</span> loop sum;                  <span class="comment">-- end loop sum 意思是：结束loop循环</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> p9(<span class="number">10</span>)  ;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>计算从1到n之间的偶数累加的值，n为传入的参数值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--分析问题，解决思路</span></span><br><span class="line"><span class="comment">--A，定义局部变量，记录累加之后的值</span></span><br><span class="line"><span class="comment">--B，每循环一次，就会对n进行-1，如果n减到0，则退出循环  -----&gt; leave xxx</span></span><br><span class="line"><span class="comment">--C，如果当次累加的数据是奇数，则直接进入下一次循环     -----&gt; iterate xxx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p10(<span class="keyword">in</span> n <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    sum:loop</span><br><span class="line">        if n<span class="operator">&lt;=</span><span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">            leave sum;</span><br><span class="line">        <span class="keyword">end</span> if;</span><br><span class="line">        </span><br><span class="line">        if n<span class="operator">%</span><span class="number">2</span> <span class="operator">=</span><span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">set</span> n<span class="operator">=</span> n<span class="number">-1</span>;</span><br><span class="line">            iterate sum;</span><br><span class="line">        <span class="keyword">end</span> if;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">set</span> total <span class="operator">=</span> total <span class="operator">+</span> n;</span><br><span class="line">        <span class="keyword">set</span> n<span class="operator">=</span>n<span class="number">-1</span>；</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">end</span> loop sum;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> p10(<span class="number">100</span>);</span><br></pre></td></tr></table></figure></li></ol><h2 id="游标-cursor"><a href="#游标-cursor" class="headerlink" title="游标 cursor"></a>游标 cursor</h2><p>游标（cursor）是用来存储查询结果集的数据类型，在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括游标的声明、open、fetch、close</p><p>声明</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> 游标名称 <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> 查询语句;</span><br></pre></td></tr></table></figure><p>open</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">OPEN</span> 游标名称;  </span><br></pre></td></tr></table></figure><p>fetch</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FETCH</span> 游标名称 <span class="keyword">INTO</span> 变量[，变量];</span><br></pre></td></tr></table></figure><p>close</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CLOSE</span> 游标名称;</span><br></pre></td></tr></table></figure><p>例.</p><p>根据传入的参数uage，来查询用户表tb_user中，所有的用户年龄小于等于uage的用户姓名(name)和专业(profession),并将用户的姓名和专业插入到所创建的一张新表(id,name,profession)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--逻辑</span></span><br><span class="line"><span class="comment">--A,声明游标，存储查询结果集</span></span><br><span class="line"><span class="comment">--B，准备：创建表结构</span></span><br><span class="line"><span class="comment">--C，开启游标</span></span><br><span class="line"><span class="comment">--D，获取游标中的记录</span></span><br><span class="line"><span class="comment">--E，插入数据到新表中</span></span><br><span class="line"><span class="comment">--F，关闭游标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p11(<span class="keyword">in</span> uage <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> uname <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">declare</span> upro <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">declare</span> u_cursor <span class="keyword">cursor</span> <span class="keyword">for</span> <span class="keyword">select</span> name,profession <span class="keyword">from</span> tb_user <span class="keyword">where</span> age<span class="operator">&lt;=</span>uage;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> tb_user_pro;</span><br><span class="line">    <span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> tb_user_pro(</span><br><span class="line">        id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">        name <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">        profession <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">open</span> u_cursor;</span><br><span class="line">    while ture do</span><br><span class="line">        <span class="keyword">fetch</span> u_cursor <span class="keyword">into</span> uname,upro;</span><br><span class="line">        <span class="keyword">insert</span> <span class="keyword">into</span> ub_user_pro <span class="keyword">values</span>(<span class="keyword">null</span>, uname,upro);</span><br><span class="line">    <span class="keyword">end</span> while;</span><br><span class="line">    <span class="keyword">close</span> u_cursor;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><p>触发器是与表有关的数据库对象，指在insert&#x2F;update&#x2F;delete之前或之后，触发并执行触发器中定义的SQL语句集合。<strong>触发器的这种特性可以协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作。</strong></p><p>使用别名OLD或者NEW来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还支持行级触发（触发几次就执行几次），不支持语句级触发（针对这一个语句只触发一次）。</p><p><strong>查看触发器有没有触发只需要去日志表中查看有无数据即可。</strong></p><table><thead><tr><th>类型</th><th>old 和 new</th></tr></thead><tbody><tr><td>insert型</td><td>new表示将要或者已经新增的数据</td></tr><tr><td>update型</td><td>old表示修改之前的数据，new表示将要或已经修改后的数据</td></tr><tr><td>delete型</td><td>old表示修改之前的数据,，new表示将要或已经修改后的数据</td></tr></tbody></table><p>创建触发器</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> 触发器名称</span><br><span class="line">before<span class="operator">/</span>after <span class="keyword">insert</span><span class="operator">/</span><span class="keyword">update</span><span class="operator">/</span><span class="keyword">delete</span> <span class="comment">--前后触发 和 类型</span></span><br><span class="line"><span class="keyword">on</span> 表名 <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span>  <span class="comment">--行级触发器</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    trigger_stmt;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>查看触发器</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> triggers;</span><br></pre></td></tr></table></figure><p>删除触发器</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">trigger</span> 表名.触发器名;  <span class="comment">--如果不指定表名，默认为当前数据库</span></span><br></pre></td></tr></table></figure><h3 id="例-insert触发器"><a href="#例-insert触发器" class="headerlink" title="例.insert触发器"></a>例.insert触发器</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">创建触发器</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tb_user_insert_trigger</span><br><span class="line">after <span class="keyword">update</span> <span class="keyword">on</span> tb_user <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> user_logs(id, operation, operation_time, operation_id, operate_params) <span class="keyword">values</span></span><br><span class="line">    (<span class="keyword">null</span>, <span class="string">&#x27;insert&#x27;</span>, now(), new.id, concat(<span class="string">&#x27;插入的数据内容为：id=&#x27;</span>, new.id,<span class="string">&#x27;,name=&#x27;</span>,new.name,<span class="string">&#x27;,phone=&#x27;</span>,new.phone,<span class="string">&#x27;,email=&#x27;</span>,new.eamil,<span class="string">&#x27;,profession=&#x27;</span>,new.profession))</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">查看触发器</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">trigger</span>;</span><br><span class="line"></span><br><span class="line">删除触发器</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">trigger</span> tb_user_insert_trigger;</span><br><span class="line"></span><br><span class="line">验证tb_user_insert_trigger触发器效果</span><br><span class="line"><span class="comment">--1.先插入数据到tb_user</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_user(id,name,phone,email,profession,age,gender,status,createtime)</span><br><span class="line"><span class="keyword">values</span>(<span class="number">25</span>,<span class="string">&#x27;二皇子&#x27;</span>,<span class="string">&#x27;18809091212&#x27;</span>,<span class="string">&#x27;erhuangzi@163.com&#x27;</span>,<span class="string">&#x27;软件工程&#x27;</span>,<span class="number">23</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,now());</span><br><span class="line"></span><br><span class="line"><span class="comment">--2.查看日志表是否含有新插入的数据</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user_logs;</span><br><span class="line"></span><br><span class="line"><span class="comment">--3.再插入一条数据到tb_user</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_user(id,name,phone,email,profession,age,gender,status,createtime)</span><br><span class="line"><span class="keyword">values</span>(<span class="number">26</span>,<span class="string">&#x27;三皇子&#x27;</span>,<span class="string">&#x27;18809091212&#x27;</span>,<span class="string">&#x27;erhuangzi@163.com&#x27;</span>,<span class="string">&#x27;软件工程&#x27;</span>,<span class="number">23</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,now());</span><br><span class="line"></span><br><span class="line"><span class="comment">--4.再次查看日志表是否含有新插入的数据</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user_logs;</span><br></pre></td></tr></table></figure><h3 id="例-update触发器"><a href="#例-update触发器" class="headerlink" title="例.update触发器"></a>例.update触发器</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--1.创建update类型的触发器</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tb_user_update_trigger</span><br><span class="line">after <span class="keyword">update</span> <span class="keyword">on</span> tb_user <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> user_logs(id, operation, operation_time, operation_id, operation_param) <span class="keyword">values</span></span><br><span class="line">    (<span class="keyword">null</span>,<span class="string">&#x27;update&#x27;</span>,now(),new.id, </span><br><span class="line">        concat(<span class="string">&#x27;更新之前的数据：id=&#x27;</span>,old.id,<span class="string">&#x27;,name=&#x27;</span>,<span class="string">&#x27;,name=&#x27;</span>,old.name,<span class="string">&#x27;,phone=&#x27;</span>,old.phone,<span class="string">&#x27;,email=&#x27;</span>,old.eamil,<span class="string">&#x27;,profession=&#x27;</span>,old.profession,</span><br><span class="line">        <span class="string">&#x27;| 更新之后的数据：id=&#x27;</span>,new.id,<span class="string">&#x27;,name=&#x27;</span>,new.name,<span class="string">&#x27;,phone=&#x27;</span>,new.phone,<span class="string">&#x27;,email=&#x27;</span>,new.eamil,<span class="string">&#x27;,profession=&#x27;</span>,new.profession)</span><br><span class="line">    );</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--2.更新tb_user表中的数据</span></span><br><span class="line"><span class="keyword">update</span> tb_user <span class="keyword">set</span> profession <span class="operator">=</span><span class="string">&#x27;会计&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span><span class="number">23</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--3.验证tb_user_update_trigger触发器是否有作用，查看user_logs表数据</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span>  user_logs;  </span><br></pre></td></tr></table></figure><h3 id="例-delete触发器"><a href="#例-delete触发器" class="headerlink" title="例.delete触发器"></a>例.delete触发器</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--1，创建删除触发器</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> tb_user_delete_trigger</span><br><span class="line">after <span class="keyword">delete</span> <span class="keyword">on</span> tb_user <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> user_logs(id, operation, operation_time, operation_id, operation_param) <span class="keyword">values</span></span><br><span class="line">    (<span class="keyword">null</span>,<span class="string">&#x27;update&#x27;</span>,now(),new.id, </span><br><span class="line">        concat(<span class="string">&#x27;删除之前的数据：id=&#x27;</span>,old.id,<span class="string">&#x27;,name=&#x27;</span>,<span class="string">&#x27;,name=&#x27;</span>,old.name,<span class="string">&#x27;,phone=&#x27;</span>,old.phone,<span class="string">&#x27;,email=&#x27;</span>,old.eamil,<span class="string">&#x27;,profession=&#x27;</span>,old.profession));</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--2，删除tb_user表中的数据</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> id<span class="operator">=</span><span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--3,验证删除触发器是否执行，查询user_logs表中是否有删除的记录数据</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user_logs;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310041710156.png"></p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源(CPU、RAM、I&#x2F;O)的争用以外，数据也是一种供多个用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，针对数据库而言显得尤为重要，也更加复杂。</p><p>MySQL中的锁，按照锁的粒度分，分为以下三类：</p><ol><li>全局锁：锁定数据库中的所有表</li><li>表级锁：每次操作锁住整张表</li><li>行级锁：每次操作锁住对应的行数据</li></ol><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。</p><p>其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性的视图，保证数据的完整性。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--1.添加全局锁</span></span><br><span class="line">mysql<span class="operator">&gt;</span> flush tables <span class="keyword">with</span> read lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">--2.备份表,直接在cmd命令中执行</span></span><br><span class="line">CMD: mysqldump <span class="operator">-</span>h ip <span class="operator">-</span>u用户名 <span class="operator">-</span>p密码 数据库名 <span class="operator">&gt;</span> 磁盘路径<span class="operator">/</span>文件名.<span class="keyword">sql</span></span><br><span class="line">CMD: mysqldump <span class="operator">-</span>h <span class="number">192.168</span><span class="number">.200</span><span class="number">.202</span> <span class="operator">-</span>uroot <span class="operator">-</span>p1234 db01 <span class="operator">&gt;</span> D:<span class="operator">/</span>db01.sql</span><br><span class="line"></span><br><span class="line"><span class="comment">--3.释放锁</span></span><br><span class="line">mysql<span class="operator">&gt;</span> unlook tables;</span><br></pre></td></tr></table></figure><ul><li>特点</li></ul><p>数据库中加全局锁，是一个比较中的操作，存在以下问题：</p><ol><li>如果在主库中备份，那么在备份期间都不能执行更新，业务基本上就得停摆</li><li>如果在从库中备份，那么在备份期间从库不能执行主库同步过来的二进制日志(binlog)，会导致主从延迟</li></ol><p> 在InnoDB引擎中，我们可以在备份时加上参数 –single-transaction 参数来完成不加锁的一致性数据备份</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="comment">--single-transaction -uroot -p1234 itcast &gt; itcast.sql</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310041718267.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310041722798.png"></p><blockquote><p>此时只能查询，其他语句都无效</p></blockquote><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310041726659.png"></p><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>表级锁，每次操作锁住整张锁。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中</p><p>对于表级锁，主要分为以下三类：</p><ol><li>表锁</li><li>元数据锁（meta data lock, MDL）</li><li>意向锁</li></ol><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>对于表锁，分为两类：</p><ol><li>表共享读锁 &#x2F; 读锁（read lock）</li><li>表独占写锁 &#x2F; 写锁（write lock）</li></ol><p>语法</p><ol><li>加锁：lock tables 表名 …… read&#x2F;write;</li><li>释放锁：unlock tables&#x2F; 客户端断开连接</li></ol><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310042151317.png"></p><blockquote><p>加读锁，其他进程能读不能写</p><p>加写锁，其他进程能读不能写也不能读</p></blockquote><h3 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h3><p>MDL（meta data lock）加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与DDL冲突(增删改查和修改表结构语句的冲突)，保证读写的正确性。</p><p>在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁（共享）；当对表结构进行变更操作的时候，加MDL写锁（排他）</p><blockquote><p>元数据简单理解就是 表结构</p></blockquote><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310042155630.png"></p><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查<br><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310042202748.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310042203183.png"></p><ol><li>意向共享锁（IS）：与表锁共享锁(read)兼容，与表锁排它锁（write）互斥。由语句select ….. Lock in share mode添加</li><li>意向排它锁（IX）：与表锁共享锁(read)及排他锁（write）都互斥。意向锁之间不会互斥。由insert、update、delete、select…..for update 添加</li></ol><p>线程A执行：首先begin开启事务，执行update的时候会将指定行的加上行锁，紧接着会对整张表加上一个意向锁</p><p>线程B执行的之前，会检查这张表得到意向锁情况，能否加上线程B的锁取决于对意向锁的判断。如果线程B添加的表锁和线程A的意向锁兼容，则可以加锁。如果不兼容，则线程B处于阻塞状态，阻塞状态随着线程A事务的commit提交，释放意向锁和行锁之后，线程B才能加表锁。</p><p>可以通过以下SQL，查看意向锁及行锁的加锁情况：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> object_schema, object_name, index_name, lock_type, lock_mode, lock_data </span><br><span class="line"><span class="keyword">from</span> performance_schema.data_locks;</span><br></pre></td></tr></table></figure><h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。</p><p>InnoDB的数据是基于索引组织的，行锁的通过对索引上的索引项来加锁实现的，而不是对记录加的锁。对于行级锁，主要分为三类：</p><ol><li>行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此进行update和delete。在Read Commit、Read Repeatable隔离级别下都支持</li><li>间隙锁（Gap Lock ）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RP隔离级别下都支持</li><li>临键锁（Next-key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RP隔离级别下支持</li></ol><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310042035102.png"></p><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p>InnoDB实现了以下两种类型的行锁</p><ol><li>共享锁（S）：运行一个事务去读一行，阻止其他事务获得相同数据集的排他锁</li><li>排他锁（X）：运行获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁</li></ol><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310042037218.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310042043978.png"></p><h4 id="行锁演示"><a href="#行锁演示" class="headerlink" title="行锁演示"></a>行锁演示</h4><p>默认情况下，InnoDB在Repeatable Read事务隔离级别运行，在InnoDB使用next-key锁进行搜索和索引扫描，以防止幻读</p><ol><li>针对唯一索引进行检索时，对已存在的记录进行等值匹配，将会自动优化为行锁</li><li>InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会升级为表锁。</li></ol><p>可以通过以下SQL，查看意向锁及行锁的加锁情况</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> object<span class="operator">-</span>schema, object_name, index_name, lock_type, lock_mode, lock_data</span><br><span class="line"><span class="keyword">from</span> performance_schema.data_locks;</span><br></pre></td></tr></table></figure><h3 id="间隙锁、临键锁"><a href="#间隙锁、临键锁" class="headerlink" title="间隙锁、临键锁"></a>间隙锁、临键锁</h3><p>默认情况下，InnoDB在RepeatableRead事务隔离级别运行，InnoDB使用next-key锁进行搜索和索引扫描，以防止幻读</p><ol><li>索引上的等值查询（唯一索引），给不存在的记录加锁时，优化为间隙锁</li><li>索引上的等值查询（普通索引），向右遍历时最后一个值不满足查询需求时，next-key lock退化为间隙锁</li><li>索引上的范围查询（唯一索引），会访问到不满足条件的第一个值为止</li></ol><blockquote><p>间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一个间隙上采用间隙锁。</p><p>间隙锁不包含边界，只包含间隙范围 ()</p><p>临键锁包含边界数据和间隙范围 []</p></blockquote><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310042133775.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310042207350.png"></p><h1 id="InnoDB引擎"><a href="#InnoDB引擎" class="headerlink" title="InnoDB引擎"></a>InnoDB引擎</h1><h2 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310050937462.png"></p><p><strong>表空间（idb文件）</strong>：一个MySQL实例可以对应多个表空间，用来存储记录、索引等数据</p><p><strong>段</strong>：分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段（Rollback segment）、InnoDB是索引组织表，数据段就是B+树的叶子节点，索引段即为B+树的非叶子节点。段用来管理多个Extent（区）</p><p><strong>区</strong>：表空间的单元结构，每个区的大小为1M。默认情况下，InnoDB存储引擎页大小为16K，即一个区中一共有64个连续的页。</p><p><strong>页</strong>：是InnoDB存储引擎磁盘管理的最小单元，每个页的大小默认为16KB。为了保证页的连续性，InnoDB存储引擎每次从磁盘申请4–5个区</p><p><strong>行</strong>：InnoDB存储引擎数据是按行进行存放的。</p><p>Trx_id：每次对某条记录进行改动时，都会把对应的事务Id赋值给Tri_id隐藏列</p><p>Roll_pointer：每次对某条记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310050940962.png"></p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>MySQL5.5版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发中使用非常广泛。下面是InnoDB架构图，左侧为内存结构，右侧为磁盘结构</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310050942995.png"></p><h3 id="内存架构"><a href="#内存架构" class="headerlink" title="内存架构"></a>内存架构</h3><h4 id="Buffer-Pool：缓冲池"><a href="#Buffer-Pool：缓冲池" class="headerlink" title="Buffer Pool：缓冲池"></a>Buffer Pool：缓冲池</h4><p>缓冲池是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度。</p><p>缓冲池以Page页为单位，底层采用链表数据结构管理Page。根据状态，将Page分为三种类型（上图中不同颜色的方块表示）</p><ul><li>Free page：空闲page，未被使用</li><li>Clean page：被使用page，数据没有被修改过</li><li>Dirty page：脏页，被使用page，数据被修改过，页中数据与磁盘的数据产生了不一致。</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310050943396.png"></p><h4 id="Change-Buffer：更改缓冲区"><a href="#Change-Buffer：更改缓冲区" class="headerlink" title="Change Buffer：更改缓冲区"></a>Change Buffer：更改缓冲区</h4><p>Change buffer：更改缓冲区（针对于非唯一二级索引页），在执行DML语句时，如果这些数据Page没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区Change Buffer中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中</p><p><strong>Change Buffer的意义是什么？</strong></p><p>与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量得到磁盘IO。有了Change Buffer之后，我们可以在缓冲池中进行合并处理，减少磁盘IO</p><h4 id="Adaptive-hash-Index：自适应哈希索引"><a href="#Adaptive-hash-Index：自适应哈希索引" class="headerlink" title="Adaptive hash Index：自适应哈希索引"></a>Adaptive hash Index：自适应哈希索引</h4><p>自适应hash索引，用于优化对BufferPool数据的查询。InnoDB存储引擎会监控对表上各索引页的查询，如果观察到hash索引可以提升速度，则建立Hash索引，称之为自适应hash索引</p><p>自适应哈希索引，无需人工干预，是系统根据情况自动完成的</p><p>参数：adaptive_hash_index</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%hash_index%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--on 表示开启</span></span><br></pre></td></tr></table></figure><h4 id="Log-Buffer：日志缓存区"><a href="#Log-Buffer：日志缓存区" class="headerlink" title="Log Buffer：日志缓存区"></a>Log Buffer：日志缓存区</h4><p>用来保存要写入到磁盘中的log日志数据（redo log、undo log），默认大小为16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或者删除许多行的事务，增加日志缓冲区的大小可以节省磁盘I&#x2F;O</p><p>参数： innodb_log_buffer_size：缓冲区大小</p><p> innodb_flush_log_at_trx_commit：日志刷新到磁盘时机。 </p><p>0：每秒将日志写入并刷新到磁盘一次</p><p>1：日志在每次事务提交时写入并刷新到磁盘（默认值）</p><p>2：日志在每次事务提交后写入，并每秒刷新到磁盘一次</p><h3 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h3><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310050950558.png"></p><h4 id="System-Tablespace"><a href="#System-Tablespace" class="headerlink" title="System Tablespace"></a>System Tablespace</h4><p>系统表空间是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建的，它也可能包含表和索引数据。（在MySQL5.x版本中还包含InnoDB数据字典、undolog等）</p><p>参数：innodb_data_file_path</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310050952666.png"></p><h4 id="File-Per-Tablespaces"><a href="#File-Per-Tablespaces" class="headerlink" title="File-Per-Tablespaces"></a>File-Per-Tablespaces</h4><p>每个表的文件表空间包含单个InnoDB表的数据和索引，并存储在文件系统上的单个数据文件中</p><p>参数：innodb_file_per_table。</p><p>on表示每一张表都会生成一个表空间文件。下图 .idb 结尾的文件就是表空间文件。每个表空间文件中存储的是这个表的表结构、数据、索引</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310050953194.png"></p><h4 id="General-Tablespace"><a href="#General-Tablespace" class="headerlink" title="General Tablespace"></a>General Tablespace</h4><p>通用表空间，需要通过CREATE TABLESPACE语法创建通用表空间，在创建表时，可以指定该表空间</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--创建通用表空间语法</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span>space xxx <span class="keyword">add</span> datafile <span class="string">&#x27;文件名&#x27;</span> engine <span class="operator">=</span> 引擎名称;</span><br><span class="line"></span><br><span class="line"><span class="comment">--实操案例，创建表空间</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span>space ts_itheima <span class="keyword">add</span> datafile <span class="string">&#x27;myitheima.idb&#x27;</span> engin <span class="operator">=</span> innodb;</span><br><span class="line"></span><br><span class="line">use itcast;</span><br><span class="line"></span><br><span class="line"><span class="comment">--创建表，指定这个表的表空间为ts_itheima </span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> a(id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment, name <span class="type">varchar</span>(<span class="number">20</span>))engine<span class="operator">=</span>innodb tablespace ts_itheima;</span><br></pre></td></tr></table></figure><h4 id="Undo-Tablespace"><a href="#Undo-Tablespace" class="headerlink" title="Undo Tablespace"></a>Undo Tablespace</h4><p>撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间（初始化大小16M），用于存储undo log日志</p><h4 id="Temporary-Tablespace"><a href="#Temporary-Tablespace" class="headerlink" title="Temporary Tablespace"></a>Temporary Tablespace</h4><p>InnoDB使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据</p><h4 id="Doublewrite-Buffer-Files"><a href="#Doublewrite-Buffer-Files" class="headerlink" title="Doublewrite Buffer Files"></a>Doublewrite Buffer Files</h4><p>双写缓冲区，innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入到双写缓冲区文件中，便于系统异常时恢复数据</p><h4 id="Redo-log"><a href="#Redo-log" class="headerlink" title="Redo log"></a>Redo log</h4><p>重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲(在内存中，redo log buffer)以及重做日志文件(在磁盘中，redo log)。当事务提交之后会把所有修改信息都会存到该日志中，用于在刷新脏页到磁盘时，发生错误时，进行数据恢复使用。</p><p>以循环方式写入重做日志文件，涉及两个文件：ib_logfile0 , ib_logfile1</p><h3 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h3><p>后台线程的作用就是在合适的时机将InnoDB存储引擎缓冲池的数据刷新到磁盘文件当中。</p><p>后台线程有4种：</p><ol><li><p>Master Thread  </p><p>核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中，保持数据的一致性，还包括脏页的刷新、合并插入缓存、undo页的回收</p></li><li><p>IO Thread  </p><p>在InnoDB存储引擎中大量使用了AIO(异步IO)来处理IO请求，这样可以极大的提高数据库的性能，而IO Thread主要负责这些IO请求的回调</p></li></ol><table><thead><tr><th>线程类型</th><th>默认个数</th><th>职责</th></tr></thead><tbody><tr><td>Read thread</td><td>4</td><td>负责读操作</td></tr><tr><td>Write thread</td><td>4</td><td>负责写操作</td></tr><tr><td>Log thread</td><td>1</td><td>负责将日志缓冲区刷新到磁盘</td></tr><tr><td>Insert buffer thread</td><td>1</td><td>负责将写缓冲区内容刷新到磁盘</td></tr></tbody></table><ol start="3"><li><p>Purge Thread</p><p>主要用于回收事务已经提交了undo log，在事务提交之后，undo log可能不用了 ，就用此线程来回收</p></li><li><p>Page Cleaner Thread</p><p>协助Master Thread刷新脏页到磁盘的线程，他可以减轻Master Thread的工作压力，减少阻塞。</p></li></ol><h2 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h2><h3 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a><strong>什么是事务？</strong></h3><p>是一组操作的集合，他是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败</p><h3 id="事务的特点"><a href="#事务的特点" class="headerlink" title="事务的特点"></a><strong>事务的特点</strong></h3><ul><li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败</li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li><li>持久性（Durability）：事务一旦提交或回滚，它对数据库的数据的改变就是永久的</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051012233.png"></p><h3 id="Redo-log-–-持久性"><a href="#Redo-log-–-持久性" class="headerlink" title="Redo log – 持久性"></a>Redo log – 持久性</h3><p>重做日志，记录的是事务提交时数据页的物理修改，<strong>是用来实现事务的持久性</strong>。</p><p>该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file）,前者是在内存中，后者是在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中，用于在刷新脏页到磁盘，发生错误时，进行数据恢复使用</p><p>正常执行的先后顺序是1234，当4（缓冲池的数据刷新到磁盘时）发生了错误，此时redo log的两份日志文件会将数据正确的同步到相应操作受影响的表空间(.ibd文件)中</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051017488.png"></p><h3 id="Undo-log-–-原子性"><a href="#Undo-log-–-原子性" class="headerlink" title="Undo log – 原子性"></a>Undo log – 原子性</h3><p> 回滚日志，用于记录数据被修改前的信息，作用包含两个：提供回滚和MVCC（多版本并发控制）</p><p>Undo log（逻辑日志）和 redo log（物理日志）不一样。可以认为当delete一条数据时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚</p><p>Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC</p><p>Undo log存储：undo log采用段的方式进行管理和记录，存放在前面介绍的rollback segment回滚段中，内部包含1024个undo log segment</p><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><ul><li><strong>当前读</strong></li></ul><p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如select … Lock in share mode(共享锁),select … For update、update、insert、delete（排他锁）都是一种当前读。</p><ul><li><strong>快照读</strong></li></ul><p>简单的select（不加锁）就是快照读，快照读读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。</p><ul><li><p>Read Committted：每次select，都生成一个快照读</p></li><li><p>Repeatable Read：开始事务后第一个select语句才是快照读的地方</p></li><li><p>Serializable：快照读会退化为当前读。</p></li><li><p><strong>MVCC</strong></p></li></ul><p>全称Muti-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySql实现MVCC提供一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库中的三个隐式字段、undo log日志、readView</p><h3 id="MVCC–实现原理"><a href="#MVCC–实现原理" class="headerlink" title="MVCC–实现原理"></a>MVCC–实现原理</h3><h4 id="记录中的隐藏字段"><a href="#记录中的隐藏字段" class="headerlink" title="记录中的隐藏字段"></a>记录中的隐藏字段</h4><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051031987.png"></p><p>如图所示，当创建表的字段有 id age name的时候，MySQL会创建 DB_TRX_ID，DB_ROLL_PTR，DB_ROW_ID这三个隐藏字段</p><table><thead><tr><th>隐藏字段</th><th>含义</th></tr></thead><tbody><tr><td>DB_TRX_ID</td><td>最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID</td></tr><tr><td>DB_ROLL_PTR</td><td>回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版本</td></tr><tr><td>DB_ROW_ID</td><td>隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查看表空间文件，表空间文件中可以查看表的详细信息，比如数据库的版本号，表的所有字段（包括隐藏字段）</span><br><span class="line">ibd2sdi xxx.ibd</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051033402.png"></p><h4 id="Undo-log版本链"><a href="#Undo-log版本链" class="headerlink" title="Undo log版本链"></a>Undo log版本链</h4><ul><li><p>Undo log</p><p>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志</p><p>当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。</p><p>而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会被立即删除。</p></li><li><p>Undo log 版本链</p><p>不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条记录版本链表，链表的头部是最新的旧纪录，链表尾部是最早的旧纪录。</p><p>那么我执行一条查询语句，数据库给我反馈的数据到底是哪个版本，是谁控制决定的呢？看下面ReadView</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051039486.png" alt="初始"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051039179.png"></p></li></ul><h4 id="Readview"><a href="#Readview" class="headerlink" title="Readview"></a>Readview</h4><p>ReadView(读视图)是快照读SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id.</p><p>readview中包含了四个核心字段：</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>m_ids</td><td>当前活跃的事务ID集合</td></tr><tr><td>min_trx_id</td><td>最小活跃事务ID</td></tr><tr><td>max_trx_id</td><td>预分配事务ID，当前最大事务ID+1（因为事务ID是自增的）</td></tr><tr><td>create_trx_id</td><td>ReadView创建者的事务ID</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051044061.png"></p><p><strong>不同的隔离级别，生成ReadView的时机不同：</strong></p><ul><li><strong>READ COMMITTED：在事务中每一次执行快照读时生成ReadView</strong></li><li><strong>REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView</strong></li></ul><h3 id="MVCC–原理分析"><a href="#MVCC–原理分析" class="headerlink" title="MVCC–原理分析"></a>MVCC–原理分析</h3><p>RC读已提交隔离级别下，在事务中每一次执行快 照读时生成ReadView。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051048472.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051055787.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051055429.png"></p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051055494.png"></p><h1 id="MySQL管理"><a href="#MySQL管理" class="headerlink" title="MySQL管理"></a>MySQL管理</h1><h2 id="系统数据库介绍"><a href="#系统数据库介绍" class="headerlink" title="系统数据库介绍"></a>系统数据库介绍</h2><p>MySQL数据库安装完成后，自带了以下四个数据库（8.0之后），具体作用如下：</p><table><thead><tr><th>数据库</th><th>含义</th></tr></thead><tbody><tr><td>mysql</td><td>存储MySQL服务器正常运行所需要的各种信息（时区、主从、用户、权限等）</td></tr><tr><td>information_schema</td><td>提供了访问数据库元数据的各种表和视图，包含数据库、表、字段类型及访问权限</td></tr><tr><td>performance_schema</td><td>为MySQL服务器运行时状态提供了一个底层监控功能，主要用于收集数据库服务器性能参数</td></tr><tr><td>sys</td><td>包含了一系列方便DBA和开发人员利用performance_schema性能数据库进行性能调优和诊断的视图</td></tr></tbody></table><h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h2><h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><p>该mysql不是指mysql服务，而是指mysql的客户端工具</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--语法</span></span><br><span class="line">mysql [options] [database]</span><br><span class="line"></span><br><span class="line"><span class="comment">--选项</span></span><br><span class="line"><span class="operator">-</span>u, <span class="comment">--user=name         #指定用户名</span></span><br><span class="line"><span class="operator">-</span>p, <span class="comment">--password[=name]   #指定密码</span></span><br><span class="line"><span class="operator">-</span>h, <span class="comment">--host=name         #指定服务器IP或域名</span></span><br><span class="line"><span class="operator">-</span>P, <span class="comment">--port=port         #指定连接端口</span></span><br><span class="line"><span class="operator">-</span>e, <span class="comment">--execute=name      #执行SQL语句并退出</span></span><br></pre></td></tr></table></figure><p>-e选项可以在MySQL客户端执行SQL语句，而不用连接到MySQL数据库再执行，对于一些批处理脚本，这种方式尤其方便，实例如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">-</span>uroot <span class="operator">-</span>p123456 db01 <span class="operator">-</span>e &quot;select * from stu&quot;;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310051116745.png"></p><h3 id="mysqladmin"><a href="#mysqladmin" class="headerlink" title="mysqladmin"></a>mysqladmin</h3><p>mysqladmin是一个执行管理操作的客户端程序。可以用它来检查服务器的配置和当前状态、创建并删除数据库等</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--通过帮助文档查看选项</span></span><br><span class="line">mysqladmin <span class="comment">--help</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--示例</span></span><br><span class="line">mysqladmin <span class="operator">-</span>uroot <span class="operator">-</span>p123456 <span class="keyword">drop</span> <span class="string">&#x27;test01&#x27;</span>;   <span class="comment">--删除数据库test01</span></span><br><span class="line"></span><br><span class="line">mysqladmin <span class="operator">-</span>uroot <span class="operator">-</span>p123456 version;         <span class="comment">--查看数据库版本信息</span></span><br></pre></td></tr></table></figure><h3 id="mysqlbinlog"><a href="#mysqlbinlog" class="headerlink" title="mysqlbinlog"></a>mysqlbinlog</h3><p>由于服务器生成的二进制日志文件以二进制格式保存，所以如果想要检查这些文本的文本格式，就会使用到mysqlbinlog日志管理工具</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">mysqlbinlog [options] log<span class="operator">-</span>files1 log<span class="operator">-</span>files2......</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line"><span class="operator">-</span>d, <span class="comment">--database=name                 指定数据库名称，只列出指定的数据库相关操作</span></span><br><span class="line"><span class="operator">-</span>o, <span class="comment">--offser=#                              忽略掉日志中的前n行命令</span></span><br><span class="line"><span class="operator">-</span>r, <span class="comment">--result-file=name                   将输出的文本格式日志输出到指定文件</span></span><br><span class="line"><span class="operator">-</span>s, <span class="comment">--short-form                           显示简单格式，省略掉一些信息</span></span><br><span class="line"><span class="comment">--start-datatime=data1  --stop-datatime=data2     指定日期间隔内的所有日志</span></span><br><span class="line"><span class="comment">--start-position=pos1  --stop-position=pos2          指定位置间隔内的所有日志</span></span><br></pre></td></tr></table></figure><h3 id="mysqlshow"><a href="#mysqlshow" class="headerlink" title="mysqlshow"></a>mysqlshow</h3><p>mysqlshow客户端对象查找工具，用来很快的查找存在哪些数据库、数据库中的表、表中的列、或者索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">Mysqlshow [options] [db_name [table_name[column_name]]]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line"><span class="comment">--count     显示数据库及表的统计信息（数据库，表均可不指定）</span></span><br><span class="line"><span class="operator">-</span>i              显示指定数据库或者指定表的状态信息</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">\#查询每个数据库的表的数量及表中记录的数量</span><br><span class="line">mysqlshow <span class="operator">-</span>uroot <span class="operator">-</span>p123456 <span class="comment">--count</span></span><br><span class="line">\#查询test数据库中每个表中的字段数，及行数</span><br><span class="line">mysqlshow <span class="operator">-</span>uroot <span class="operator">-</span>p123456 test <span class="comment">--count</span></span><br><span class="line">\#查询test数据库中book表的详细情况</span><br><span class="line">mysqlshow <span class="operator">-</span>uroot <span class="operator">-</span>p123456 test book <span class="comment">--count</span></span><br></pre></td></tr></table></figure><h3 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h3><p>mysqldump客户端工具用来被封数据库或在不同数据库之间进行数据迁移。备份内容包含创建表，及插入表的SQL语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">语法</span><br><span class="line">Mysqldump [options] db_name [tables]</span><br><span class="line">Mysqldump [options] <span class="comment">--database / -B db1 [db2 db3...]</span></span><br><span class="line">Mysqldump [options] <span class="comment">--all -databases /-A</span></span><br><span class="line"></span><br><span class="line">连接选项：</span><br><span class="line"><span class="operator">-</span>u，<span class="comment">--user=name              指定用户名</span></span><br><span class="line"><span class="operator">-</span>p，<span class="comment">--password[=name]    指定密码</span></span><br><span class="line"><span class="operator">-</span>h，<span class="comment">--host=name               指定服务器ip或域名</span></span><br><span class="line"><span class="operator">-</span>P，<span class="comment">--port=#                      指定连接端口</span></span><br><span class="line"></span><br><span class="line">输出选项：</span><br><span class="line"><span class="comment">--add-drop-database         在每个数据库创建语句前加上drop database语句</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-组和权限</title>
      <link href="/2023/10/02/Linux%E7%BB%84%E5%92%8C%E6%9D%83%E9%99%90/"/>
      <url>/2023/10/02/Linux%E7%BB%84%E5%92%8C%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<h1 id="组"><a href="#组" class="headerlink" title="组"></a>组</h1><p>Linux系统中的每个文件和目录都有一组权限，用于控制对它们的访问。</p><p>每个人都有自己的组</p><p>这些权限分为三个类别：</p><ul><li>所有者（Owner）：谁创建文件谁是所有者</li><li>所属组（Group）</li><li>其他人（Others）</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202311012024859.png"></p><h2 id="相关指令"><a href="#相关指令" class="headerlink" title="相关指令"></a>相关指令</h2><ul><li>查看文件的所有者：Is -ahl</li><li>修改文件所有者：chown 用户名 文件名</li><li>创建组：groupadd 名字</li><li></li></ul><h1 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h1><p>每个类别都有读（Read）、写（Write）和执行（Execute）权限。权限可以使用符号表示法来表示，其中每个类别都有一个字母表示权限：</p><ul><li><code>r</code>（读权限）：表示可以读取文件内容或查看目录中的文件列表。</li><li><code>w</code>（写权限）：表示可以修改文件内容，或在目录中创建、删除和重命名文件。</li><li><code>x</code>（执行权限）：对于文件，表示可以执行文件作为可执行程序；对于目录，表示可以进入目录。</li></ul><p>注意：如上面所说，如果你对一个文件拥有<code>w</code>权限，你可以修改这个文件，但是你并不能删除这个文件。删除这个文件的前提是你拥有文件所在目录的<code>w</code>权限</p><div class="tabs" id="1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#1-1">文件的权限效果</button></li><li class="tab"><button type="button" data-href="#1-2">目录的权限效果</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><p>r 代表可读(read):可以读取查看</p><p>w 代表可写(write):可以修改但是不代表可以删除该文件,删除一个文件的前提条件是对该又件所在的目录有写权限，才能删除该文件</p><p>x 代表可执行(execute):可以被执行</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-2"><p>rwx作用到目录</p><p>r 代表可读(read):可以读取, Is查看目录内容</p><p>w 代表可写(write):可以修改，对目录内创建+删除+重命名月录</p><p>x 代表可执行(execute):可以进入该目录</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="表示方法"><a href="#表示方法" class="headerlink" title="表示方法"></a>表示方法</h2><ol><li><p>符号表示法</p><p>权限符号表示法的格式为：<code>[所有者权限][所属组权限][其他人权限]</code>。</p></li><li><p>数字表示法</p><p>权限在数字表示法中使用三位二进制数表示每个权限组的权限。每个权限对应一个二进制位，其中1表示有权限，0表示没有权限。例如：如果一个权限组的权限是rwx（即读、写和执行权限都有），它的二进制表示为111，对应的数字表示为7。</p></li></ol><p>改权限的时候能用字母又能用数字，数字要合写。例如，<code>rw-r--r--</code>表示所有者具有读写权限，所属组和其他人只有读权限，数字表示法表示为<code>644</code>。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>drwxr-xr-x 2 root root 4096 2月 23 12:00 xml</p><p>drwxr-xr-x：表示类型和相关权限</p><p>0-9位说明：</p><ul><li><p>第0位确定文件类型(d,-,I,c, b)</p><p>-是普通文件，单纯的文件</p><p>I是链接，相当于windows的快捷方式</p><p>d是目录，相当于windows的文件夹</p><p>c是待设备文件，鼠标，键盘</p><p>b是块设备，比如硬盘</p></li><li><p>第1- 3位确定<strong>所有者</strong>（该文件的所有者）拥有该文件的权限。User</p></li><li><p>第4- 6位确定<strong>所属组</strong>（同用户组的）拥有该文件的权限。G roup</p></li><li><p>第7-9位确定<strong>其他用户</strong>拥有该文件的权限。Other</p><blockquote><p>写什么就有什么权限，没有的用 - 占位，如rwx，rw-，r–</p></blockquote></li></ul><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><p>因为Linux的权限与组密不可分，所以在讲述权限管理的命令之前，我们会先提及一些组管理的相关命令。</p><p>以下一些命令可能需要root用户权限</p><h2 id="组管理"><a href="#组管理" class="headerlink" title="组管理"></a>组管理</h2><p><strong>创建</strong></p><ol><li><code>groupadd 新组名</code>：创建一个组</li><li><code>useradd -g 用户组 新用户名</code>：创建一个用户并指定用户组</li></ol><p>当这个新创建的一个用户创建一个文件之后，文件的所有者就是该用户，所属组就是该用户所属的组</p><p>我们可以使用<code>ls -l 指定文件/目录</code>查看指定文件或目录的详细信息，其中就包括了权限信息，文件所有者和所属组信息。</p><p><strong>修改</strong></p><ol><li><p><code>chgrp 组名 文件名/目录名</code>：修改指定文件或目录所属组，加上选项<code>-R</code>可以递归修改。</p></li><li><p><code>usermod -g 组名 用户名</code>：修改用户所在的组</p></li><li><p><code>usermod -d 路径 用户名</code>：可以指定用户登录进入的初始化目录，其他是该用户拥有进入该目录的权限</p></li></ol><p><strong>查看</strong></p><ol><li><code>id 用户名</code>：可以查看用户ID信息，其中包括组ID</li><li>在<code>/etc/group</code>文件中，可以查看所有的组的信息（组名、组密码、组ID（GID）和组成员）</li></ol><p><strong>删除</strong></p><p><code>groupdel 用户组</code>：删除用户组</p><h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><p><strong>查看权限</strong></p><p>使用<code>ls -l</code>可以查看文件的详细信息，其中就包括了权限信息（权限信息为符号表示，如<code>rw-r--r--</code>），下面让我们看看具体示例</p><p>示例输出：<code>drwxr-xr-x 2 root root 4096 2月 23 12:00 xml</code>：</p><ol><li><code>d</code>：文件类型，<code>d</code>表示目录</li><li><code>rwxr-xr-x</code>：权限信息</li><li><code>2</code>：如果是目录显示子目录数（不包括文件，包括隐藏目录<code>.</code>和<code>..</code>，所以一个空目录该数值是<code>2</code>），如果是文件则显示硬链接数</li><li><code>root</code>：用户</li><li><code>root</code>：组</li><li><code>4096</code>：如果是目录则显示<code>4096</code>，如果是文件则显示文件大小（默认单位：字节）</li><li><code>2月 23 12:00</code>：最后修改时间</li></ol><p>扩展:在<code>ls -l</code>查看到详细信息，在权限信息前有一个别的字母（如<code>drwxr-xr-x</code>中的<code>d</code>），该字母表示文件的类型具体含义如下：</p><ul><li><code>l</code>：link 表示软链接，类似Windows的快捷方式</li><li><code>d</code>：directory 表示目录</li><li><code>c</code>：character device 字符设备，如鼠标，键盘</li><li><code>b</code>：block device 块设备，如硬盘</li><li><code>-</code>：普通文件</li><li><code>s</code>：socket 套接字，表示该文件是一个进程间通信的通道，</li></ul><p><strong>修改权限</strong></p><ol><li>chmod [u&#x2F;g&#x2F;o&#x2F;a] [+ &#x2F;-&#x2F;&#x3D;] [权限] 文件名或者目录：<ul><li><code>u</code>代表所有者，<code>g</code>代表所属组，<code>o</code>代表其他人，<code>a</code>代表所有人（前面三者的总和）</li><li><code>=</code>赋值，<code>+</code>增加，<code>-</code>减少</li><li>示例<code>chomd u=rwx,g=rx,o-x dog</code>：<code>dog</code>文件所有者权限修改为读写执行，所属组权限修改为读和执行，其他人减少执行权限</li></ul></li><li>chomd 数字表示法权限 文件：我们也可以使用数字表示法表示权限修改文件权限，让我们看看示例<ul><li><code>chomd 777 dog</code>：把<code>dog</code>文件的权限修改为<code>rwxrwxrwx</code>，<code>7</code>是二进制<code>111</code>的十进制表示，详情请看<a href="https://gallifrey.asia/posts/77d4628760e7/#%E6%A6%82%E5%BF%B5">概念</a></li><li><code>chomd 644 hello.txt</code>：把<code>hello.txt</code>文件的权限修改为<code>rw-r--r--</code>,<code>6</code>是二进制<code>110</code>的十进制表示</li></ul></li><li>chown：修改文件或目录的所有者（Owner，我其实觉得翻译为拥有者或者主人更合适）<ul><li><code>chown 用户名 文件或目录</code>：修改指定文件或者目录的所有者</li><li><code>chown 用户名:组名 文件或目录</code>：修改指定文件或者目录的所有者和组名</li><li><code>chown 用户名 -R 文件或目录</code>：递归修改修改指定文件或者目录的所有者，一般用于修改整个目录下所有文件的所有者</li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-SQL使用</title>
      <link href="/2023/10/01/MySQL01%E5%9F%BA%E7%A1%80%E8%AF%AD%E5%8F%A5/"/>
      <url>/2023/10/01/MySQL01%E5%9F%BA%E7%A1%80%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL关键字"><a href="#MySQL关键字" class="headerlink" title="MySQL关键字"></a>MySQL关键字</h1><table><thead><tr><th>关键字</th><th>位置</th><th>作用</th></tr></thead><tbody><tr><td>ADD</td><td></td><td>用于向现有表添加一列或多列</td></tr><tr><td>ALTER</td><td></td><td>用于修改表的结构，例如更改列名、更改列的数据类型、修改索引等</td></tr><tr><td>AND</td><td></td><td>用于组合多个条件，如果所有条件都为true，条件才会返回true</td></tr><tr><td>ASC</td><td></td><td>用于按升序对结果集进行排序</td></tr><tr><td>AVG</td><td></td><td>用于计算一组数的平均值</td></tr><tr><td>BETWEEN</td><td></td><td>用于指定某个范围内的条件，查询满足范围内的记录</td></tr><tr><td>BY</td><td></td><td>用于指定用于排序的列名</td></tr><tr><td>CASE</td><td></td><td>用于在SELECT语句中实现分支逻辑</td></tr><tr><td>COUNT</td><td></td><td>用于计算指定列的行数</td></tr><tr><td>CREATE</td><td></td><td>用于创建新表、视图、函数等数据库对象</td></tr><tr><td>DATABASE</td><td></td><td>用于指定数据库的名称</td></tr><tr><td>DELETE</td><td></td><td>用于删除表或从表中删除行</td></tr><tr><td>DESC</td><td></td><td>用于按降序对结果集进行排序</td></tr><tr><td>DISTINCT</td><td></td><td>用于从结果集中消除重复行</td></tr><tr><td>DROP</td><td></td><td>用于从数据库中删除表、视图、函数等数据库对象</td></tr><tr><td>EXISTS</td><td></td><td>用于检查一个子查询是否有结果集</td></tr><tr><td>FOREIGN KEY</td><td></td><td>用于创建引用其他表的外键</td></tr><tr><td>FROM</td><td></td><td>用于指定表名或视图名</td></tr><tr><td>GROUP BY</td><td></td><td>用于将结果集按一列或多列进行分组</td></tr><tr><td>HAVING</td><td></td><td>用于指定GROUP BY语句的条件</td></tr><tr><td>INNER JOIN</td><td></td><td>用于返回两个表中都有匹配行的所有行</td></tr><tr><td>INSERT INTO</td><td></td><td>用于将新行插入到表中</td></tr><tr><td>INTO</td><td></td><td>用于指定要插入行的表或视图</td></tr><tr><td>IS NULL</td><td></td><td>用于检查列或表达式是否为NULL</td></tr><tr><td>LIKE</td><td></td><td>用于按照通配符匹配来检索结果集</td></tr><tr><td>LIMIT</td><td></td><td>用于限制结果集返回的行数</td></tr><tr><td>MODIFY</td><td></td><td>用于修改表的结构，例如更改列名、更改列的数据类型等</td></tr><tr><td>NOT NULL</td><td></td><td>用于确保列中不允许出现NULL值</td></tr><tr><td>ON</td><td></td><td>用于指定JOIN操作中的连接条件</td></tr><tr><td>OR</td><td></td><td>用于组合多个条件，条件中至少有一个为true，条件就会返回true</td></tr><tr><td>ORDER BY</td><td></td><td>用于按升序或降序对结果集进行排序</td></tr><tr><td>PRIMARY KEY</td><td></td><td>用于定义表的主键</td></tr><tr><td>REFERENCES</td><td></td><td>用于定义外键约束</td></tr><tr><td>SELECT</td><td></td><td>用于从一个或多个表中检索数据</td></tr><tr><td>SET</td><td></td><td>用于更新指定列的值</td></tr><tr><td>SUM</td><td></td><td>用于计算数值列中数值的总和</td></tr><tr><td>TABLE</td><td></td><td>用于指定表的名称</td></tr><tr><td>UNION</td><td></td><td>用于将两个或多个SELECT语句的结果集组合为单个结果集</td></tr><tr><td>UPDATE</td><td></td><td>用于更新表中的数据</td></tr><tr><td>VALUES</td><td></td><td>用于指定新行的值</td></tr><tr><td>VIEW</td><td></td><td>用于创建虚拟表</td></tr></tbody></table><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><div class="tabs" id="数据类型"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#数据类型-1">数值类型</button></li><li class="tab"><button type="button" data-href="#数据类型-2">字符串类型</button></li><li class="tab"><button type="button" data-href="#数据类型-3">日期类型</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="数据类型-1"><table><thead><tr><th>类型</th><th>大小</th><th>有符号(SIGNED)范围</th><th>无符号(UNSIGNED)范围</th><th>描述</th></tr></thead><tbody><tr><td>TINYINT</td><td>1 byte</td><td>(-128，127)</td><td>(0，255)</td><td>小整数值</td></tr><tr><td>SMALLINT</td><td>2 bytes</td><td>(-32768，32767)</td><td>(0，65535)</td><td>大整数值</td></tr><tr><td>MEDIUMINT</td><td>3 bytes</td><td>(-8388608，8388607)</td><td>(0，16777215)</td><td>大整数值</td></tr><tr><td>INT或INTEGER</td><td>4 bytes</td><td>(-2147483648，2147483647)</td><td>(0，4294967295)</td><td>大整数值</td></tr><tr><td>BIGINT</td><td>8 bytes</td><td>(-2^63，2^63-1)</td><td>(0，2^64-1)</td><td>极大整数值</td></tr><tr><td>FLOAT</td><td>4 bytes</td><td>(-3.402823466 E+38，3.402823466351 E+38)</td><td>0 和 (1.175494351 E-38，3.402823466 E+38)</td><td>单精度浮点数值</td></tr><tr><td>DOUBLE</td><td>8 bytes</td><td>(-1.7976931348623157 E+308，1.7976931348623157 E+308)</td><td>0 和 (2.2250738585072014 E-308，1.7976931348623157 E+308)</td><td>双精度浮点数值</td></tr><tr><td>DECIMAL</td><td></td><td>依赖于M(精度)和D(标度)的值</td><td>依赖于M(精度)和D(标度)的值</td><td>小数值(精确定点数)</td></tr></tbody></table><blockquote><p>DECIMAL类型数据123.45 精度是5（一共几位），标度是2（小数点后几位）</p><p>UNSIGNED 使用后说明是无符号数</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="数据类型-2"><table><thead><tr><th>类型</th><th>大小</th><th>描述</th></tr></thead><tbody><tr><td>CHAR</td><td>0-255 bytes</td><td>定长字符串</td></tr><tr><td>VARCHAR</td><td>0-65535 bytes</td><td>变长字符串</td></tr><tr><td>TINYBLOB</td><td>0-255 bytes</td><td>不超过255个字符的二进制数据</td></tr><tr><td>TINYTEXT</td><td>0-255 bytes</td><td>短文本字符串</td></tr><tr><td>BLOB</td><td>0-65 535 bytes</td><td>二进制形式的长文本数据</td></tr><tr><td>TEXT</td><td>0-65 535 bytes</td><td>长文本数据</td></tr><tr><td>MEDIUMBLOB</td><td>0-16 777 215 bytes</td><td>二进制形式的中等长度文本数据</td></tr><tr><td>MEDIUMTEXT</td><td>0-16 777 215 bytes</td><td>中等长度文本数据</td></tr><tr><td>LONGBLOB</td><td>0-4 294 967 295 bytes</td><td>二进制形式的极大文本数据</td></tr><tr><td>LONGTEXT</td><td>0-4 294 967 295 bytes</td><td>极大文本数据</td></tr></tbody></table><blockquote><p>char(10)的10个字节是固定的，没有占用完的内存，会被填充为空格。但是char性能高（空间换时间）</p><p>varchar(10)表示最大字节为10，如果存储占用1个字节，则物理上只使用了1个字节。超出10会报错。varchar性能差，但节省空间</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="数据类型-3"><table><thead><tr><th>DATE</th><th>大小</th><th>1000-01-01 至 9999-12-31</th><th>YYYY-MM-DD</th><th>日期值</th></tr></thead><tbody><tr><td>TIME</td><td>3</td><td>-838:59:59 至 838:59:59</td><td>HH:MM:SS</td><td>时间值或持续时间</td></tr><tr><td>YEAR</td><td>1</td><td>1901 至 2155</td><td>YYYY</td><td>年份值</td></tr><tr><td>DATETIME</td><td>8</td><td>1000-01-01 00:00:00 至 9999-12-31 23:59:59</td><td>YYYY-MM-DD HH:MM:SS</td><td>混合日期和时间值</td></tr><tr><td>TIMESTAMP</td><td>4</td><td>1970-01-01 00:00:01 至 2038-01-19 03:14:07</td><td>YYYY-MM-DD HH:MM:SS</td><td>混合日期和时间值，时间戳</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h1><h2 id="通用语法"><a href="#通用语法" class="headerlink" title="通用语法"></a>通用语法</h2><ol><li>SQL语句可以单行或多行书写，以分号结尾。</li><li>SQL语句可以使用<strong>空格</strong>或者<strong>缩进</strong>来增强语句的可读性。</li><li>MySQL数据库的SQL语句不区分大小写，但是关键字建议使用大写。</li><li>注释：<br> 单行注释：<code>-- 注释内容</code>或<code>#注释内容(MySQL特有)</code><br> 多行注释：<code>/* 注释内容*/</code></li></ol><h2 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a>SQL分类</h2><table><thead><tr><th>类型</th><th>全称</th><th>功能</th></tr></thead><tbody><tr><td>DDL</td><td>Data Definition Language</td><td>数据定义语言，用来定义数据库对象（数据库，表，字段）</td></tr><tr><td>DML</td><td>Data Manipulation Language</td><td>数据操作语言，用来对数据库表中的数据进行增改查</td></tr><tr><td>DQL</td><td>Data Query Language</td><td>数据查询语言，用力啊查询数据库中表的记录</td></tr><tr><td>DCL</td><td>Data Control Language</td><td>数据控制语言，用来创建数据库用户，控制数据库的访问权限</td></tr></tbody></table><h3 id="DDL数据定义语言"><a href="#DDL数据定义语言" class="headerlink" title="DDL数据定义语言"></a>DDL数据定义语言</h3><h4 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h4><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">增</button></li><li class="tab"><button type="button" data-href="#test1-2">删</button></li><li class="tab"><button type="button" data-href="#test1-3">使用</button></li><li class="tab"><button type="button" data-href="#test1-4">查</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p>创建数据库：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database [if <span class="keyword">not</span> <span class="keyword">exists</span>] 数据库名 [<span class="keyword">default</span> charset 字符集] [<span class="keyword">collate</span> 排序规则];</span><br></pre></td></tr></table></figure><blockquote><p> utf8字符集存储长度为3byte，但是有些字符4byte。推荐utf8mb4字符集</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p>删除数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> database [if <span class="keyword">exists</span>] 数据库名；</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p>使用数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use 数据库名;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><p>查询所有数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> databases;</span><br></pre></td></tr></table></figure><p>查询当前使用的数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> database();</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h4 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h4><div class="tabs" id="test2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test2-1">增</button></li><li class="tab"><button type="button" data-href="#test2-2">删</button></li><li class="tab"><button type="button" data-href="#test2-3">改</button></li><li class="tab"><button type="button" data-href="#test2-4">查</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test2-1"><p>创建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">  字段<span class="number">1</span> 字段<span class="number">1</span>类型 [comment 字段<span class="number">1</span>注释],</span><br><span class="line">  字段<span class="number">2</span> 字段<span class="number">2</span>类型 [comment 字段<span class="number">2</span>注释],</span><br><span class="line">  字段<span class="number">3</span> 字段<span class="number">3</span>类型 [comment 字段<span class="number">3</span>注释],</span><br><span class="line">  ......</span><br><span class="line">  字段n 字段n类型 [comment 字段n注释]</span><br><span class="line">)[comment 表注释];</span><br></pre></td></tr></table></figure><blockquote><p>最后一个字段后面没有<strong>逗号</strong>，其余用<code>,</code>隔开</p><p>注意 comment ‘’ 是英文的单引号，不能是 &#96;&#96;,否则创建失败</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-2"><p>删除表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 表名;</span><br></pre></td></tr></table></figure><p>删除指定表，并重新创建该表（从来没用过）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> 表名;</span><br></pre></td></tr></table></figure><blockquote><p>在删除表时，表中的全部数据也会被删除。</p></blockquote><p>删除字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> 字段名;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-3"><p>为表添加字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> 字段名 类型（长度）[comment 注释] [约束]</span><br></pre></td></tr></table></figure><p>修改数据类型</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 modify 字段名 新数据类型(长度);</span><br></pre></td></tr></table></figure><p>修改字段名和字段类型</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 change 旧字段 新字段 类型(长度) [comment 注释][约束];</span><br></pre></td></tr></table></figure><p>修改表名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 rename <span class="keyword">to</span> 新表名;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-4"><p>查询当前数据库所有表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> tables;</span><br></pre></td></tr></table></figure><p>查询表结构</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">desc</span> 表名；</span><br></pre></td></tr></table></figure><p>查询指定表的建表语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> 表名；</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="DML数据操作语言"><a href="#DML数据操作语言" class="headerlink" title="DML数据操作语言"></a>DML数据操作语言</h3><p>Data Manipulation Language数据操作语言，用来对数据库中表的数据记录进行增删改操作。没有查，查被单独分离为DQL</p><ul><li>添加数据 INSERT，对数据表增加一行数据</li><li>修改数据 UPDATE，对数据表中某一行的某个字段的值进行修改</li><li>删除数据 DELETE，对数据表中某一行数据进行删除</li></ul><div class="tabs" id="dml"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#dml-1">INSERT</button></li><li class="tab"><button type="button" data-href="#dml-2">UPDATE</button></li><li class="tab"><button type="button" data-href="#dml-3">DELETE</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="dml-1"><p>给指定字段添加数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名 (字段名<span class="number">1</span>，字段名<span class="number">2</span>，.....) <span class="keyword">values</span> (值<span class="number">1</span>，值<span class="number">2</span>，.....);</span><br></pre></td></tr></table></figure><p>给全部字段添加数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名 <span class="keyword">values</span>(值<span class="number">1</span>, 值<span class="number">2</span>,......);</span><br></pre></td></tr></table></figure><blockquote><p>用这种方法必须包含所有数据项，且按顺序，不然会报错1136</p></blockquote><p>批量添加数据（一次插入多个）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名 (字段名<span class="number">1</span>，字段名<span class="number">2</span>，....) <span class="keyword">values</span> (值<span class="number">1</span>，值<span class="number">2</span>，..),(值<span class="number">1</span>，值<span class="number">2</span>，...),(值<span class="number">1</span>，值<span class="number">2</span>,...);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名 <span class="keyword">values</span> (值<span class="number">1</span>，值<span class="number">2</span>，..),(值<span class="number">1</span>，值<span class="number">2</span>，...),(值<span class="number">1</span>，值<span class="number">2</span>,...);</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>插入数据时，指定的字段顺序需要与值的顺序要对应</li><li>字符串和日期类型数据应该包含在引号中，单引号双引号都可以</li><li>插入的数据大小，应该在字段的规定范围内，不然报错</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="dml-2"><p>修改数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 字段名<span class="number">1</span><span class="operator">=</span>值<span class="number">1</span>, 字段名<span class="number">2</span><span class="operator">=</span>值<span class="number">2</span>, 字段名<span class="number">3</span><span class="operator">=</span>值<span class="number">3</span>,....[<span class="keyword">where</span> 条件]</span><br></pre></td></tr></table></figure><blockquote><p>修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表的所有该数据。</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="dml-3"><p>删除数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 [<span class="keyword">where</span> 条件]</span><br></pre></td></tr></table></figure><blockquote><p>delete语句的条件可以有，也可以没有。如果没有条件，则会删除整张表的所有数据</p><p>delete语句不能删除某一个字段的值（可以使用update为null），只能删除某条记录</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="DQL数据查询语言"><a href="#DQL数据查询语言" class="headerlink" title="DQL数据查询语言"></a>DQL数据查询语言</h3><p>Data query language数据查询语言 ，用来查询数据库中的表的记录。</p><p>查询关键词：select</p><p>查询语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> 表名列表</span><br><span class="line"></span><br><span class="line"><span class="keyword">where</span> 条件查询</span><br><span class="line"></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> 分组字段列表</span><br><span class="line"></span><br><span class="line"><span class="keyword">having</span>  分组后条件列表</span><br><span class="line"></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> 排序字段列表</span><br><span class="line"></span><br><span class="line">limit 分页参数</span><br></pre></td></tr></table></figure><h4 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h4><ol><li><p>查询多个字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段<span class="number">1</span>, 字段<span class="number">2</span>, 字段<span class="number">3</span>,....<span class="keyword">from</span> 表名;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名; <span class="comment">--一般实际工作中，不建议使用如此，实际工作中数据量巨大</span></span><br></pre></td></tr></table></figure></li><li><p>设置别名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段<span class="number">1</span> [<span class="keyword">as</span> 别名<span class="number">1</span>], 字段<span class="number">2</span> [<span class="keyword">as</span> 别名<span class="number">2</span>],.... <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure><blockquote><p>as 可以省略，但是字段之间要用<strong>逗号</strong>隔开</p></blockquote></li><li><p>去除重复记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> 字段列表 <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure></li></ol><h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><div class="tabs" id="条件"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#条件-1">比较运算符</button></li><li class="tab"><button type="button" data-href="#条件-2">逻辑运算符</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="条件-1"><table><thead><tr><th><strong>比较运算符</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>!&#x3D;</td><td>不等</td></tr><tr><td>between and</td><td>在（最小值）和（最大值）之间，包括最值</td></tr><tr><td>in</td><td>在in之后的列表中的值，多选一</td></tr><tr><td>like</td><td>模糊匹配( <strong>_</strong> 匹配单个字符, <strong>%</strong> 匹配任意个字符)</td></tr><tr><td>is null</td><td>是NULL</td></tr><tr><td>is not null</td><td>不是NULL</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="条件-2"><table><thead><tr><th><strong>逻辑运算符</strong></th><th>功能</th></tr></thead><tbody><tr><td>&amp;&amp;  and</td><td>与</td></tr><tr><td>||  or</td><td>或</td></tr><tr><td>!  not</td><td>非</td></tr></tbody></table><blockquote><p>逻辑运算符一般用英文单词，不用&amp;&amp;等符号</p></blockquote><p>例子</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">查询年龄等于 <span class="number">88</span> 的员工</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">88</span>;</span><br><span class="line"></span><br><span class="line">查询年龄小于 <span class="number">20</span> 的员工信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> age <span class="operator">&lt;</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">查询年龄小于等于 <span class="number">20</span> 的员工信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> age <span class="operator">&lt;=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">查询年龄不等于 <span class="number">88</span> 的员工信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> age <span class="operator">!=</span> <span class="number">88</span>;</span><br><span class="line"></span><br><span class="line">查询年龄在<span class="number">15</span>岁（包含）到<span class="number">20</span>岁（包含）之间的员工信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> age <span class="keyword">between</span> <span class="number">15</span> <span class="keyword">and</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">查询性别为 女 且年龄小于 <span class="number">25</span>岁的员工信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> <span class="operator">&lt;</span> <span class="number">20</span> <span class="keyword">and</span> gender <span class="operator">=</span> &quot;女&quot;;</span><br><span class="line"></span><br><span class="line">查询年龄等于<span class="number">18</span>或<span class="number">20</span>或<span class="number">40</span>的员工信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> age <span class="keyword">in</span> <span class="number">18</span> <span class="keyword">or</span> <span class="number">20</span> <span class="keyword">or</span> <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">查询姓名为两个字的员工信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="keyword">like</span> &quot;--&quot;</span><br><span class="line"></span><br><span class="line">查询身份证号最后一位是X的员工信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> idcard <span class="keyword">like</span> &quot;%x&quot; ;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><p>常见聚合函数：</p><table><thead><tr><th>名称</th><th>功能</th></tr></thead><tbody><tr><td>count</td><td>统计数量</td></tr><tr><td>max</td><td>最大值</td></tr><tr><td>min</td><td>最小值</td></tr><tr><td>avg</td><td>平均值</td></tr><tr><td>sum</td><td>求和</td></tr></tbody></table><blockquote><p>null值不参与所有聚合函数运算</p></blockquote><p>语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 聚合函数（字段列表）<span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure><h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 [<span class="keyword">where</span> 条件] <span class="keyword">group</span> <span class="keyword">by</span> 分组字段名 <span class="keyword">having</span> [分组后过滤条件];</span><br></pre></td></tr></table></figure><blockquote><p>聚合函数一般和分组查询搭配使用</p></blockquote><p>where 与 having区别：</p><ol><li>执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤。</li><li>判断条件不同：where不能对聚合函数进行判断，而having可以。</li></ol><p>注意：</p><ul><li>执行顺序：where &gt; 聚合函数 &gt; having</li><li>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义</li></ul><h4 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 <span class="keyword">order</span> <span class="keyword">by</span> 字段<span class="number">1</span> 排序方式<span class="number">1</span>, 字段<span class="number">2</span> 排序方式<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>排序方式：</p><ul><li><strong>ASC</strong> ：升序（默认值）</li><li><strong>DESC</strong>：降序</li></ul><blockquote><p>如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序。</p></blockquote><h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 limit 起始索引,查询记录数</span><br></pre></td></tr></table></figure><p>注意</p><ul><li>起始索引从0开始，起始索引&#x3D;（查询页码-1）* 每页显示记录数</li><li>分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是limit</li><li>如果查询的是第一页数据，起始索引可以省略，直接简写为limit10</li></ul><h4 id="DQL执行顺序"><a href="#DQL执行顺序" class="headerlink" title="DQL执行顺序"></a>DQL执行顺序</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> 表</span><br><span class="line"><span class="keyword">where</span> 条件查询</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> 分组字段列表</span><br><span class="line"><span class="keyword">having</span> 分组后条件列表</span><br><span class="line"><span class="keyword">select</span> 字段列表</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> 排序字段列表</span><br><span class="line">limit 分页参数</span><br></pre></td></tr></table></figure><h3 id="DCL数据控制语言"><a href="#DCL数据控制语言" class="headerlink" title="DCL数据控制语言"></a>DCL数据控制语言</h3><p>DCL Data Control Language(数据控制语言)，用来管理数据库用户，控制数据库的访问权限</p><ol><li>主要控制数据库有哪些用户可以访问</li><li>每一个用户具有什么样的访问权限</li></ol><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><p>查询用户：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><p>创建用户：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;密码&#x27;</span>;</span><br></pre></td></tr></table></figure><p>修改用户密码：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;新密码&#x27;</span>;</span><br></pre></td></tr></table></figure><p>删除用户：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><p>MySQL中定义了很多种权限，但是常用的主要是下面几种</p><table><thead><tr><th>ALL ,  ALL PRIVILEGES</th><th>所有权限</th></tr></thead><tbody><tr><td>SELECT</td><td>查询数据</td></tr><tr><td>INSERT</td><td>插入数据</td></tr><tr><td>UPDATE</td><td>修改数据</td></tr><tr><td>DELETE</td><td>删除数据</td></tr><tr><td>ALTER</td><td>修改表</td></tr><tr><td>DROP</td><td>删除数据库、表、视图</td></tr><tr><td>CREATE</td><td>创建数据库、表</td></tr></tbody></table><p>注意：</p><ul><li>多个权限之间，使用 , 逗号 分离</li><li>授权时，数据库名和表名可以使用 * 进行通配，代表所有</li></ul><p>查询权限：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> grants <span class="keyword">for</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> grants <span class="keyword">for</span> <span class="string">&#x27;heima&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;  </span><br><span class="line">查询heima这个用户的权限</span><br></pre></td></tr></table></figure><p>授予权限：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> 权限列表 <span class="keyword">on</span> 数据库名.表名 <span class="keyword">to</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>; </span><br><span class="line">如果是所有数据库所有表 写法是： <span class="operator">*</span>.<span class="operator">*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">on</span> itheima.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;heima&#x27;</span>@<span class="string">&#x27;%&#x27;</span>; </span><br><span class="line">给heima这个用户授予itheima数据库所有表的权限</span><br></pre></td></tr></table></figure><p>撤销权限：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">revoke</span> 权限列表 <span class="keyword">on</span> 数据库名.表名 <span class="keyword">from</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">all</span> <span class="keyword">on</span> itcast.<span class="operator">*</span> <span class="keyword">from</span> <span class="string">&#x27;heima&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;  </span><br><span class="line">撤销heima这个用户的所有itcast数据库表的权限</span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><div class="tabs" id="函数"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#函数-1">字符串函数</button></li><li class="tab"><button type="button" data-href="#函数-2">数值函数</button></li><li class="tab"><button type="button" data-href="#函数-3">日期函数</button></li><li class="tab"><button type="button" data-href="#函数-4">流程控制函</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="函数-1"><h2 id=""><a href="#" class="headerlink" title=""></a></h2><table><thead><tr><th>函数名</th><th>功能</th></tr></thead><tbody><tr><td>concat(s1,s2,s3,s4….sn)</td><td>字符串拼接，将s1,s2,s3,s4……..sn拼接成一个字符串</td></tr><tr><td>lower(str)</td><td>将字符串str全部转为小写</td></tr><tr><td>upper(str)</td><td>将字符串str全部转为大写</td></tr><tr><td>lpad(str,n,pad)</td><td>左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td></tr><tr><td>rpad(str,n,pad)</td><td>右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</td></tr><tr><td>trim(str)</td><td>去掉字符串头部和尾部的空格</td></tr><tr><td>substring(str,start,len)</td><td>返回字符串str从start位置起的len个长度的字符串</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="函数-2"><table><thead><tr><th>函数名</th><th>功能</th></tr></thead><tbody><tr><td>ceil(x)</td><td>向上取整  —&gt; (整数部分＋1)</td></tr><tr><td>floor(x)</td><td>向下取整  —&gt;  (只保留整数部分)</td></tr><tr><td>mod(x,y)</td><td>返回x&#x2F;y的模 —&gt; 取模，得到余数即为模</td></tr><tr><td>rand()</td><td>返回 0–1内的随机数</td></tr><tr><td>round(x,y)</td><td>求参数x的四舍五入的值，保留y位小数</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="函数-3"><table><thead><tr><th>函数名</th><th>功能</th></tr></thead><tbody><tr><td>curdate()</td><td>返回当前日期</td></tr><tr><td>curtime()</td><td>返回当前时间</td></tr><tr><td>now()</td><td>返回当前日期和时间</td></tr><tr><td>year(date)</td><td>获取指定date的年份</td></tr><tr><td>month(date)</td><td>获取指定date的月份</td></tr><tr><td>day(date)</td><td>获取指定date的日期</td></tr><tr><td>date_add(date,INTERVAL expr type)</td><td>返回一个日期&#x2F;时间值加上一个时间间隔expr后的时间值</td></tr><tr><td>datediff(date1,date2)</td><td>返回起始日期date1和结束时间date2之间的天数</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="函数-4"><p>流程函数可以在SQL语句中实现条件筛选，从而提高语句的效率</p><table><thead><tr><th>函数名</th><th>功能</th></tr></thead><tbody><tr><td>if(value, t, f )</td><td>如果value为true，则返回t，否则返回f</td></tr><tr><td>ifnull(value1, value2)</td><td>如果value1不为空，返回value1，否则返回value2</td></tr><tr><td>case when [val1] then [res1]……else [defalut] end;</td><td>如果val1为true，返回res1,…..否则返回default默认值</td></tr><tr><td>case [expr] when [val1] then [res1]…..else [defalut] end</td><td>如果expr的值等于val1，返回res1,………否则默认返回default默认值</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><p>概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据</p><p>目的：保证数据库中数据的正确、有效性和完整性</p><p>分类：</p><table><thead><tr><th>名称</th><th>作用</th><th>关键字</th></tr></thead><tbody><tr><td>非空约束</td><td>限制该字段的数据不能为null</td><td>NOT NULL</td></tr><tr><td>唯一约束</td><td>保证该字段的所有数据都是唯一、不重复的</td><td>UNIQUE</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，要求非空且唯一</td><td>PRIMARY KEY</td></tr><tr><td>默认约束</td><td>保存数据时，如果未指定该字段的值，则采用默认值</td><td>DEFAULT</td></tr><tr><td>检查约束（8.0.16版本之后）</td><td>保证字段值满足某一个条件</td><td>CHECK</td></tr><tr><td>外键约束</td><td>用来让两张表的数据之间建立连接，保证数据的一致性和完整性</td><td>FOREIGN KEY</td></tr></tbody></table><blockquote><p>约束时作用在表中字段上的，可以在创建表、修改表的时候添加约束</p></blockquote><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。（spring里面还会见到，经典例子：银行存取钱）</p><p>默认MySQL的事务时自动提交的，也就是说，当执行一条DML语句，MySQL会立即隐式的提交事务。</p><h2 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h2><p>mysql中事务默认开启，可以手动关闭</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@autocommit</span>;  <span class="comment">--结果是 1 ，默认是自动提交事务</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> @<span class="variable">@autocommit</span><span class="operator">=</span><span class="number">0</span>;  <span class="comment">--设置成0 ，设置成手动提交</span></span><br><span class="line"></span><br><span class="line">开启事务</span><br><span class="line"><span class="keyword">start</span> transaction 或 <span class="keyword">begin</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION 或 <span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line">提交事务</span><br><span class="line"><span class="keyword">commit</span>;  <span class="comment">--在手动提交事务的情况下，执行commit才会执行事务的操作</span></span><br><span class="line"></span><br><span class="line">回滚事务</span><br><span class="line"><span class="keyword">rollback</span>;  <span class="comment">--当业务操作的DML语句出现异常，需要将表中数据执行的操作结果回退到未执行的状态。</span></span><br></pre></td></tr></table></figure><h2 id="事务四大特性–ACID"><a href="#事务四大特性–ACID" class="headerlink" title="事务四大特性–ACID"></a>事务四大特性–ACID</h2><ul><li><p>原子性atomicity</p><p>事务是不可分割的最小操作单元，要么全部成功，要么全部失败</p></li><li><p>一致性consistency</p><p>事务完成时，必须使所有的数据都保持一直状态。</p><p>如银行例子，总金额是一致的，钱不能凭空增加或减少。</p></li><li><p>隔离性isolation</p><p>数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</p><p>2个事务之间互不影响</p></li><li><p>持久性durability</p><p>事务一旦提交或回滚，他对数据库中的数据的改变就是永久的。</p><p>不管成功或失败，对数据的改变是永久的。</p></li></ul><h2 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h2><table><thead><tr><th>问题</th><th>解释</th></tr></thead><tbody><tr><td>脏读</td><td>一个事务读到另外一个事务还没有提交的数据</td></tr><tr><td>不可重复读</td><td>一个事务先后读取同一条记录，但两次读取的数据不同，成为不可重复读</td></tr><tr><td>幻读</td><td>一个事务按照条件查询时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了“幻影”</td></tr></tbody></table><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>read uncommitted</td><td>会出现</td><td>会出现</td><td>会出现</td></tr><tr><td>read committed</td><td>不会出现</td><td>会出现</td><td>会出现</td></tr><tr><td>repeatable read（默认）</td><td>不会出现</td><td>不会出现</td><td>会出现</td></tr><tr><td>serializable</td><td>不会出现</td><td>不会出现</td><td>不会出现</td></tr></tbody></table><blockquote><p>性能越强，安全性越低。</p><p>read uncommitted 性能最强，安全性最低</p><p>serializable 性能最低，安全性最高</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">查看事务隔离级别</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@transaction</span>_isolation</span><br><span class="line"></span><br><span class="line">设置事务隔离级别</span><br><span class="line">session 是当前会话的隔离级别，就是当前操作界面的范围</span><br><span class="line"><span class="keyword">global</span> 是全部数据库内的隔离级别</span><br><span class="line"><span class="keyword">set</span> [session<span class="operator">|</span><span class="keyword">global</span>] transaction isolation level &#123;read uncommitted<span class="operator">|</span> read committed<span class="operator">|</span> repeatable read<span class="operator">|</span> serializable&#125;</span><br></pre></td></tr></table></figure><h1 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h1><p>项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上可以分为三种：</p><ul><li>一对多（多对一）</li></ul><p>案例：部门 与 员工的关系</p><p>关系：一个部门对应多个员工，一个员工对应一个部门</p><p>实现：在多的一方建立外键，外键指向一的一方的主键</p><p><img src="D:\NoteBook\图片\image-20230929194442388.png" alt="image-20230929194442388"></p><ul><li>多对多</li></ul><p>案例：学生 与 课程的关系</p><p>关系：一个学生可以选修多门课程，一门课程也可以供多个学生选择</p><p>实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</p><p><img src="D:\NoteBook\图片\image-20230929194455257.png" alt="image-20230929194455257"></p><ul><li>一对一</li></ul><p>案例：用户 与 用户详情的关系</p><p>关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提高效率</p><p>实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE）</p><p><img src="D:\NoteBook\图片\image-20230929194558399.png" alt="image-20230929194558399"></p><h2 id="多表查询概述"><a href="#多表查询概述" class="headerlink" title="多表查询概述"></a>多表查询概述</h2><p><img src="D:\NoteBook\图片\image-20230929194918647.png" alt="image-20230929194918647"></p><p>笛卡尔积：笛卡尔积是指在数学中，两个集合 A集合和B集合的所有组合情况（多表查询时，需要消除无效的笛卡尔积）</p><p>如何消除笛卡尔积呢？</p><p>在sql中，使用where 表1.字段1 &#x3D; 表2.字段2  找到相关联的能唯一的即可</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp, dept <span class="keyword">where</span> emp.dept_id <span class="operator">=</span> dept.id;</span><br></pre></td></tr></table></figure><h2 id="多表查询分类"><a href="#多表查询分类" class="headerlink" title="多表查询分类"></a>多表查询分类</h2><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p><img src="D:\NoteBook\图片\image-20230929200123811.png" alt="image-20230929200123811"></p><h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><p>相当于查询A、B交集部分数据</p><p>隐式内连接：多张表直接<strong>逗号</strong>分隔</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span>,表<span class="number">2</span> <span class="keyword">where</span> 条件 .....;</span><br><span class="line"></span><br><span class="line">表别名写法：表起了别名之后，就不能写全名了</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> e.name, d.name <span class="keyword">from</span> emp e, dept d <span class="keyword">where</span> e.dept_id <span class="operator">=</span> d.id;</span><br></pre></td></tr></table></figure><p>显式内连接：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> [<span class="keyword">inner</span>] <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 连接条件.....;</span><br></pre></td></tr></table></figure><h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><p>左外连接：查询 左表 <strong>所有数据</strong>，以及两张表交集部分数据</p><p>右外连接：查询 右表 <strong>所有数据</strong>，以及两张表交集部分数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">left</span> [<span class="keyword">outer</span>] <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 条件.....;</span><br><span class="line">相当于查询表<span class="number">1</span>(左表)的所有数据 包含 表<span class="number">1</span> 和 表<span class="number">2</span> 交集部分的数据</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">right</span> [<span class="keyword">outer</span>] <span class="keyword">join</span> 表<span class="number">2</span> <span class="keyword">on</span> 条件.....;</span><br><span class="line">相当于查询表<span class="number">2</span>(右表)的所有数据 包含 表<span class="number">1</span> 和 表<span class="number">2</span> 交集部分的数据</span><br></pre></td></tr></table></figure><blockquote><p>左右连接交换表的顺序就是另外一种，一般只用左外连接</p></blockquote><h4 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h4><p>当前表与自身的连接查询，自连接必须使用表别名。可以是内连接查询，也可以是外连接查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表A 别名A <span class="keyword">join</span> 表A 别名B <span class="keyword">on</span> 条件.......;</span><br></pre></td></tr></table></figure><blockquote><p>必须起别名，用来区分前后查询用的条件</p></blockquote><blockquote><p>虽然只用了一张表，但是由于使用多次，要视为多张表</p></blockquote><h4 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h4><p>对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表A .....</span><br><span class="line"><span class="keyword">union</span> [<span class="keyword">all</span>]</span><br><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表B .....;</span><br></pre></td></tr></table></figure><p>union：<strong>会对合并之后的数据去重</strong></p><p>union all：<strong>会将全部的数据直接合并在一起，可能出现重复</strong></p><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>SQL语句中嵌套select语句，内层的select语句称为嵌套查询，又称为子查询</p><p>根据子查询结果不同，分为</p><ul><li>标量子查询（子查询结果为单个值）</li><li>列子查询（子查询结果为一列）</li><li>行子查询（子查询结果为一行）</li><li>表子查询（子查询结果为多行多列）</li></ul><p>根据子查询位置，分为：where之后，from之后，select之后</p><h4 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h4><p>子查询返回的结果是单个值（数字、字符串、日期等），最简单的形式，这种子查询称为标量子查询</p><p>常用的操作符：&#x3D; &lt;&gt; &gt; &gt;&#x3D; &lt; &lt;&#x3D;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例.查询 ‘销售部’的所有员工信息</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 查询‘销售部’的部门ID是多少</span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;销售部&#x27;</span>;</span><br><span class="line"><span class="number">2.</span> 根据销售部门ID，查询员工信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id<span class="operator">=</span>(<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;销售部&#x27;</span>;);</span><br></pre></td></tr></table></figure><h4 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h4><p>子查询返回的结果是一列（可以是多行），这种子查询称为列子查询</p><p>常用的操作符：in、not in、any、some、all</p><table><thead><tr><th>in</th><th>在指定的集合范围之内，多选一</th></tr></thead><tbody><tr><td>not in</td><td>不在指定的集合返回之内</td></tr><tr><td>any</td><td>子查询返回列表中，有任意一个满足即可</td></tr><tr><td>some</td><td>与any等同，使用some的地方都可以使用any</td></tr><tr><td>all</td><td>子查询返回列表的所有值都必须满足</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">例.查询“销售部”和“市场部”的所有员工信息</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp </span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&gt;</span> (<span class="keyword">select</span> <span class="built_in">max</span>(salary) <span class="keyword">from</span> emp <span class="keyword">where</span> deptid<span class="operator">=</span>(<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;财务部&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 查询所有 财务部 人员工资</span><br><span class="line"><span class="keyword">select</span> salary <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id<span class="operator">=</span>(<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;财务部&#x27;</span>);</span><br><span class="line"><span class="number">2.</span> 比财务部所有人工资都高的员工信息，<span class="keyword">all</span>表示所有的列子查询都满足</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> salary <span class="operator">&gt;</span> <span class="keyword">all</span>(<span class="keyword">select</span> salary <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id<span class="operator">=</span>(<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;财务部&#x27;</span>));</span><br></pre></td></tr></table></figure><h4 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h4><p>子查询返回的结果是一行（可以是多列），这种子查询称为行子查询</p><p>常用的操作符：&#x3D;、&lt;&gt;、IN、NOT IN</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">例.查询比财务部所有人工资都高的员工信息</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp </span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&gt;</span> (<span class="keyword">select</span> <span class="built_in">max</span>(salary) <span class="keyword">from</span> emp <span class="keyword">where</span> deptid<span class="operator">=</span>(<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;财务部&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 查询所有 财务部 人员工资</span><br><span class="line"><span class="keyword">select</span> salary <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id<span class="operator">=</span>(<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;财务部&#x27;</span>);</span><br><span class="line"><span class="number">2.</span> 比财务部所有人工资都高的员工信息，<span class="keyword">all</span>表示所有的列子查询都满足</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> salary <span class="operator">&gt;</span> <span class="keyword">all</span>(<span class="keyword">select</span> salary <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id<span class="operator">=</span>(<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;财务部&#x27;</span>));</span><br></pre></td></tr></table></figure><h4 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h4><p>子查询返回的结果是多行多列，这种子查询称为表子查询</p><p>常用的操纵符：IN</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例.查询入职日期是&quot;2006-01-01&quot;之后的员工信息，及其部门信息</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 入职日期是‘<span class="number">2006</span><span class="number">-01</span><span class="number">-01</span>’之后的员工信息</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> entrydate<span class="operator">&gt;</span><span class="string">&#x27;2006-01-01&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 查询这部分员工的部门信息</span><br><span class="line"><span class="keyword">select</span> e.<span class="operator">*</span>, d.<span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> entrydate<span class="operator">&gt;</span><span class="string">&#x27;2006-01-01&#x27;</span>) e <span class="keyword">left</span> <span class="keyword">join</span> dept d <span class="keyword">on</span> e.dept_id<span class="operator">=</span>d.id;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> SQL语句 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>丁奇MySql</title>
      <link href="/2023/09/28/%E4%B8%81%E5%A5%87MySql/"/>
      <url>/2023/09/28/%E4%B8%81%E5%A5%87MySql/</url>
      
        <content type="html"><![CDATA[<h1 id="Day1-讲基础架构：一条SQL查询语句是如何执行的"><a href="#Day1-讲基础架构：一条SQL查询语句是如何执行的" class="headerlink" title="Day1-讲基础架构：一条SQL查询语句是如何执行的"></a>Day1-讲基础架构：一条SQL查询语句是如何执行的</h1><p>平时我们使用数据库，看到的通常都是一个整体。比如，你有个最简单的表，表里只有一个ID字段，在执行下面这个查询语句时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from T where ID=10；</span><br></pre></td></tr></table></figure><p>我们看到的只是输入一条语句，返回一个结果，却不知道这条语句在MySQL内部的执行过程。</p><p>今天把MySQL拆解一下，看看里面都有哪些“零件”，</p><p>下面我给出的是MySQL的基本架构示意图，从中你可以清楚地看到SQL语句在MySQL的各个功能模块中的执行过程。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310081010377.png"></p><p>大体来说，MySQL可以分为<strong>Server层</strong>和<strong>存储引擎层</strong>两部分。</p><p>Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p><p>存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认存储引擎。</p><p>也就是说，你执行create table建表的时候，如果不指定引擎类型，默认使用的就是InnoDB。也可以通过指定存储引擎的类型来选择别的引擎，比如在create table语句中使用engine&#x3D;memory, 来指定使用内存引擎创建表。不同存储引擎的表数据存取方式不同，支持的功能也不同。</p><blockquote></blockquote><p>从图中不难看出，不同的存储引擎共用一个<strong>Server层</strong>，也就是从连接器到执行器的部分。</p><p>结合开头提到的那条SQL语句，走一遍整个执行流程，依次看下每个组件的作用。</p><h2 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h2><p>第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h$ip -P$port -u$user -p</span><br></pre></td></tr></table></figure><p>输完命令之后，你就需要在交互对话里面输入密码。虽然密码也可以直接跟在-p后面写在命令行中，但这样可能会导致你的密码泄露。如果你连的是生产服务器，强烈建议你不要这么做。</p><p>连接命令中的mysql是客户端工具，用来跟服务端建立连接。在完成经典的TCP握手后，连接器就要开始认证身份，这个时候用的就是你输入的用户名和密码。</p><ul><li>如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。</li><li>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</li></ul><p>这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限（当前链接）。修改完成后，只有再<strong>新建的连接</strong>才会使用新的权限设置。</p><p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态，你可以在show processlist命令中看到它。文本中这个图是show processlist的结果，其中的Command列显示为“Sleep”的这一行，就表示现在系统里面有一个空闲连接。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310081037347.png"></p><p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数wait_timeout控制的，默认值是8小时。</p><p>如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误提醒： Lost connection to MySQL server during query。这时候如果你要继续，就需要重连，然后再执行请求了。</p><ul><li>长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。</li><li>短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</li></ul><p>建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。</p><p>但是全部使用长连接后，你可能会发现，有些时候MySQL占用内存涨得特别快，这是因为MySQL在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是MySQL异常重启了。</p><p>怎么解决这个问题呢？你可以考虑以下两种方案。</p><ol><li><p>定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。</p></li><li><p>如果你用的是MySQL 5.7或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</p><p>造成影响如下：</p><ol><li>回滚活跃的事务并重新设置自动提交模式</li><li>释放所有表锁</li><li>关闭或删除所有的临时表</li><li>重新初始化会话的系统变量值</li><li>丢失用户定义的设置变量</li><li>释放prepare语句</li><li>关闭handler变量</li><li>将last_insert_id()值设置为0</li><li>释放get_lock（）获取的锁</li><li>清空通过mysql_bind_param()调用定义的当前查询属性</li></ol></li></ol><h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><blockquote><p>MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有这个功能了。</p></blockquote><p>连接建立完成后，你就可以执行select语句了。执行逻辑就会来到第二步：查询缓存。</p><p>MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。如果你的查询能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端。（计网中也有类似的东西）</p><p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。</p><p><strong>但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。</strong></p><p>查询缓存的<strong>失效非常频繁</strong>，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。</p><p>很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。<strong>除非你的业务就是有一张静态表，很长时间才会更新一次</strong>。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p><p>好在MySQL也提供了这种“按需使用”的方式。你可以将参数query_cache_type设置成DEMAND，这样对于默认的SQL语句都不使用查询缓存。而对于你确定要使用查询缓存的语句，可以用SQL_CACHE显式指定，像下面这个语句一样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select SQL_CACHE * from T where ID=10；</span><br></pre></td></tr></table></figure><h2 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h2><p>如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL需要知道你要做什么，因此需要对SQL语句做解析。</p><p>分析器先会做“<strong>词法分析</strong>”。你输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么。</p><p>MySQL从你输入的”select”这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名T”，把字符串“ID”识别成“列ID”。</p><p>做完了这些识别以后，就要做“<strong>语法分析</strong>”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。</p><p>如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，比如下面这个语句select少打了开头的字母“s”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; elect * from t where ID=1;</span><br><span class="line"></span><br><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;elect * from t where ID=1&#x27; at line 1</span><br></pre></td></tr></table></figure><p>一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。</p><h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>经过了分析器，MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。</p><p>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的join：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from t1 join t2 using(ID)  where t1.c=10 and t2.d=20;</span><br></pre></td></tr></table></figure><ul><li>既可以先从表t1里面取出c&#x3D;10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。</li><li>也可以先从表t2里面取出d&#x3D;20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。</li></ul><p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</p><p>优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等等，后面的文章中单独展开说明优化器的内容。</p><h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。</p><p>开始执行的时候，要先判断一下你对这个表T有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示(在工程实现上，如果命中查询缓存，会在查询缓存放回结果的时候，做权限验证。查询也会在优化器之前调用precheck验证权限)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from T where ID=10;</span><br><span class="line"></span><br><span class="line">ERROR 1142 (42000): SELECT command denied to user &#x27;b&#x27;@&#x27;localhost&#x27; for table &#x27;T&#x27;</span><br></pre></td></tr></table></figure><p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</p><p>比如我们这个例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的：</p><ol><li>调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；</li><li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li><li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li></ol><p>至此，这个语句就执行完成了。</p><p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。</p><p>你会在数据库的慢查询日志中看到一个rows_examined的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。</p><p>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此<strong>引擎扫描行数跟rows_examined并不是完全相同的。</strong>我们后面会专门有一篇文章来讲存储引擎的内部机制，里面会有详细的说明。</p><h2 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h2><p>如果表T中没有字段k，而你执行了这个语句 select * from T where k&#x3D;1, 那肯定是会报“不存在这个列”的错误： “Unknown column ‘k’ in ‘where clause’”。你觉得这个错误是在我们上面提到的哪个阶段报出来的呢？</p><p>分析器</p><ol><li>MySQL的框架有几个组件, 各是什么作用?</li><li>Server层和存储引擎层各是什么作用?</li><li>you have an error in your SQL syntax 这个保存是在词法分析里还是在语法分析里报错?</li><li>对于表的操作权限验证在哪里进行?</li><li>执行器的执行查询语句的流程是什么样的?</li></ol><h1 id="D2-讲日志系统：一条SQL更新语句是如何执行的"><a href="#D2-讲日志系统：一条SQL更新语句是如何执行的" class="headerlink" title="D2-讲日志系统：一条SQL更新语句是如何执行的"></a>D2-讲日志系统：一条SQL更新语句是如何执行的</h1><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310081010377.png"></p><p>MySQL可以恢复到半个月内任意一秒的状态，这是怎样做到的呢？</p><p>我们还是从一个表的一条更新语句说起，下面是这个表的创建语句，这个表有一个主键ID和一个整型字段c：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T(ID int primary key, c int);</span><br></pre></td></tr></table></figure><p>如果要将ID&#x3D;2这一行的值加1，SQL语句就会这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update T set c=c+1 where ID=2;</span><br></pre></td></tr></table></figure><p>前面我有跟你介绍过SQL语句基本的执行链路，这里我再把那张图拿过来，你也可以先简单看看这个图回顾下。首先，可以确定的说，查询语句的那一套流程，更新语句也是同样会走一遍。</p><p>执行语句前要先连接数据库，这是连接器的工作。</p><p>前面我们说过，在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表T上所有缓存结果都清空。这也就是我们一般不建议使用查询缓存的原因。</p><p>接下来，分析器会通过词法和语法解析知道这是一条更新语句。优化器决定要使用ID这个索引。然后，执行器负责具体执行，找到这一行，然后更新。</p><p>与查询流程不一样的是，更新流程还涉及两个重要的日志模块，它们正是我们今天要讨论的主角：redo log（重做日志）和 binlog（归档日志）。如果接触MySQL，那这两个词肯定是绕不过的，我后面的内容里也会不断地和你强调。不过话说回来，redo log和binlog在设计上有很多有意思的地方，这些设计思路也可以用到你自己的程序里。</p><h2 id="重要的日志模块：redo-log"><a href="#重要的日志模块：redo-log" class="headerlink" title="重要的日志模块：redo log"></a>重要的日志模块：redo log</h2><p>《孔乙己》这篇文章，酒店掌柜有一个粉板，专门用来记录客人的赊账记录。如果赊账的人不多，那么他可以把顾客名和账目写在板上。但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。</p><p>如果有人要赊账或者还账的话，掌柜一般有两种做法：</p><ul><li>一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉；</li><li>另一种做法是先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。</li></ul><p>在生意红火柜台很忙时，掌柜一定会选择后者，因为前者操作实在是太麻烦了。首先，你得找到这个人的赊账总额那条记录。你想想，密密麻麻几十页，掌柜要找到那个名字，可能还得带上老花镜慢慢找，找到之后再拿出算盘计算，最后再将结果写回到账本上。</p><p>这整个过程想想都麻烦。相比之下，还是先在粉板上记一下方便。你想想，如果掌柜没有粉板的帮助，每次记账都得翻账本，效率是不是低得让人难以忍受？</p><p>同样，在MySQL里也有这个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。为了解决这个问题，MySQL的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。</p><p>而粉板和账本配合的整个过程，其实就是MySQL里经常说到的WAL技术，WAL的全称是Write-Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。</p><p>具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。</p><p>InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么这块“粉板”总共就可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310081324101.png"></p><ul><li><p>write pos是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。checkpoint是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p></li><li><p>write pos和checkpoint之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果write pos追上checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把checkpoint推进一下。</p></li></ul><p>有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<strong>crash-safe</strong>。</p><p>要理解crash-safe这个概念，可以想想我们前面赊账记录的例子。只要赊账记录记在了粉板上或写在了账本上，之后即使掌柜忘记了，比如突然停业几天，恢复生意后依然可以通过账本和粉板上的数据明确赊账账目。</p><h2 id="重要的日志模块：binlog"><a href="#重要的日志模块：binlog" class="headerlink" title="重要的日志模块：binlog"></a>重要的日志模块：binlog</h2><p>MySQL整体来看，其实就有两块：</p><ol><li>一块是Server层，它主要做的是MySQL功能层面的事情；</li><li>还有一块是引擎层，负责存储相关的具体事宜。</li></ol><p>上面我们聊到的粉板redo log是InnoDB引擎特有的日志，而Server层也有自己的日志，称为binlog（归档日志）。</p><p>我想你肯定会问，为什么会有两份日志呢？</p><p>因为最开始MySQL里并没有InnoDB引擎。MySQL自带的引擎是MyISAM，但是MyISAM没有crash-safe的能力，binlog日志只能用于归档。而InnoDB是另一个公司以插件形式引入MySQL的，既然只依靠binlog是没有crash-safe能力的，所以InnoDB使用另外一套日志系统——也就是redo log来实现crash-safe能力。</p><p>这两种日志有以下三点不同。</p><ol><li><p>redo log是InnoDB引擎特有的；</p><p>binlog是MySQL的Server层实现的，所有引擎都可以使用。</p></li><li><p>redo log是物理日志，记录的是“<strong>在某个数据页上做了什么修改</strong>”；</p><p>binlog是逻辑日志，记录的是这个<strong>语句的原始逻辑</strong>，比如“给ID&#x3D;2这一行的c字段加1 ”。</p></li><li><p>redo log是循环写的，空间固定会用完；</p><p>binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</p></li></ol><p>有了对这两个日志的概念性理解，我们再来看执行器和InnoDB引擎在执行这个简单的update语句时的内部流程。</p><ol><li>执行器先找引擎取 ID&#x3D;2 这一行。ID是主键，引擎直接用树搜索找到这一行。如果 ID&#x3D;2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li><li>执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li><li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。</li><li>执行器生成这个操作的binlog，并把binlog写入磁盘。</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。</li></ol><p>这里我给出这个update语句的执行流程图，图中浅色框表示是在InnoDB内部执行的，深色框表示是在执行器中执行的。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png"></p><p>你可能注意到了，最后三步看上去有点“绕”，将redo log的写入拆成了两个步骤：prepare和commit，这就是”两阶段提交”。</p><h2 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h2><p>为什么必须有“两阶段提交”呢？这是为了让两份日志之间的逻辑一致。要说明这个问题，我们得从文章开头的那个问题说起：<strong>怎样让数据库恢复到半个月内任意一秒的状态？</strong></p><p>binlog会记录所有的逻辑操作，并且是采用“追加写”的形式。如果你的DBA承诺说半个月内可以恢复，那么备份系统中一定会保存最近半个月的所有binlog，同时系统会定期做整库备份。这里的“定期”取决于系统的重要性，可以是一天一备，也可以是一周一备。</p><p>当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做：</p><ul><li>首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库；</li><li>然后，从备份的时间点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时刻。</li></ul><p>这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去。</p><p>好了，说完了数据恢复过程，我们回来说说，为什么日志需要“两阶段提交”。这里不妨用反证法来进行解释。</p><p>由于redo log和binlog是两个独立的逻辑，如果不用两阶段提交，要么就是先写完redo log再写binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。</p><p>仍然用前面的update语句来做例子。假设当前ID&#x3D;2的行，字段c的值是0，再假设执行update语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了crash，会出现什么情况呢？</p><ol><li><strong>先写redo log后写binlog</strong>。假设在redo log写完，binlog还没有写完的时候，MySQL进程异常重启。由于我们前面说过的，redo log写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行c的值是1。<br>但是由于binlog没写完就crash了，这时候binlog里面就没有记录这个语句。因此，之后备份日志的时候，存起来的binlog里面就没有这条语句。<br>然后你会发现，如果需要用这个binlog来恢复临时库的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同。</li><li><strong>先写binlog后写redo log</strong>。如果在binlog写完之后crash，由于redo log还没写，崩溃恢复以后这个事务无效，所以这一行c的值是0。但是binlog里面已经记录了“把c从0改成1”这个日志。所以，在之后用binlog来恢复的时候就多了一个事务出来，恢复出来的这一行c的值就是1，与原库的值不同。</li></ol><p>可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。</p><p>你可能会说，这个概率是不是很低，平时也没有什么动不动就需要恢复临时库的场景呀？</p><p>其实不是的，不只是误操作后需要用这个过程来恢复数据。当你需要扩容的时候，也就是需要再多搭建一些备库来增加系统的读能力的时候，现在常见的做法也是用全量备份加上应用binlog来实现的，这个“不一致”就会导致你的线上出现主从数据库不一致的情况。</p><p>简单说，redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>今天，我介绍了MySQL里面最重要的两个日志，即物理日志redo log和逻辑日志binlog。</p><p>redo log用于保证crash-safe能力。innodb_flush_log_at_trx_commit这个参数设置成1的时候，表示每次事务的redo log都直接持久化到磁盘。这个参数我建议你设置成1，这样可以保证MySQL异常重启之后数据不丢失。</p><p>sync_binlog这个参数设置成1的时候，表示每次事务的binlog都持久化到磁盘。这个参数我也建议你设置成1，这样可以保证MySQL异常重启之后binlog不丢失。</p><p>我还跟你介绍了与MySQL日志系统密切相关的“两阶段提交”。两阶段提交是跨系统维持数据逻辑一致性时常用的一个方案，即使你不做数据库内核开发，日常开发中也有可能会用到。</p><p>文章的最后，我给你留一个思考题吧。前面我说到定期全量备份的周期“取决于系统重要性，有的是一天一备，有的是一周一备”。那么在什么场景下，一天一备会比一周一备更有优势呢？或者说，它影响了这个数据库系统的哪个指标？</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC</title>
      <link href="/2023/09/19/SpringMVC/"/>
      <url>/2023/09/19/SpringMVC/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringMVC简介"><a href="#SpringMVC简介" class="headerlink" title="SpringMVC简介"></a>SpringMVC简介</h1><p>SpringMVC是一个基于Spring开发的MVC轻量级框架，SpringMVC和Spring可以无缝整合。</p><p>使用DispatcherServlet作为前端控制器，且内部提供了处理器映射器、处理器适配器、视图解析器等组件，可以简化JavaBean封装，Json转化、文件上传等操作。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231114093704185.png" alt="image-20231114093704185"></p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><ol><li><p>导入Spring整合SpringMVC的坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在web.xml中配置SpringMVC的前端控制器ServletDispatcher</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">&lt;!--指定springMVC配置文件位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--服务器启动就创建--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>2<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在javaweb中就学习过，这两个标签配套使用能配置一个servlet</p></li><li><p>编写一个控制器Controller，配置映射信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/show&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show 执行....&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//视图跳转到index.jsp</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建springMVC的核心配置文件 spring-mvc.xml，并配置组件扫描web层</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/xmlSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 组件扫描web层 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima.controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="Controller中访问容器中的Bean"><a href="#Controller中访问容器中的Bean" class="headerlink" title="Controller中访问容器中的Bean"></a>Controller中访问容器中的Bean</h2><p>DispatcherServlet在进行初始化时，加载的spring-mvc.xml配置文件创建的SpringMVC容器，那么web层 Controller被扫描进入到了容器中，之前Spring容器中的Service也可以获取到</p><p>下面搭建Spring的web环 境进行验证</p><ol><li><p>创建一个applicationContext.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 组件扫描非web层 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--排除com.itheima包下使用@Controller注解的类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在web.xml中配置ContextLoaderListener</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置ContextLoaderListener--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applictionContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写UserService和UserServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service(&quot;userService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserServiceImpl show running ......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改UserController，从Spring容器中匹配Service进行注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="comment">//注入Service</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/show&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show 执行....&quot;</span>);</span><br><span class="line">        <span class="comment">//调用userService的show方法</span></span><br><span class="line">        userService.show();</span><br><span class="line">        <span class="comment">//视图跳转到index.jsp</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="SpringMVC关键组件浅析"><a href="#SpringMVC关键组件浅析" class="headerlink" title="SpringMVC关键组件浅析"></a>SpringMVC关键组件浅析</h2><p>Spring和SpringMVC的整合中，只需要按照规则去定义Controller和业务方法就可，在这个过程中，肯定是很多核心功能类参与到其中这些核心功能类，一般称为组件。</p><p>请问：当请求到达服务器时，是哪个组件接收的请求，是哪个组件帮我们找到的Controller，是哪个组件 帮我们调用的方法，又是哪个组件最终解析的视图？</p><blockquote><p>servlet -&gt; handlerMapping -&gt; handlerAdapter -&gt; ViewResolver</p><p>上面4个名字都是接口或者说是相关规范，运行的时候有其他的实现类</p></blockquote><table><thead><tr><th>组件</th><th>描述</th><th>常用组件</th></tr></thead><tbody><tr><td>处理器映射器HandlerMapping</td><td>匹配映射路径对应的Handler，返回可执行的处 理器链对象HandlerExecutionChain对象</td><td>RequestMappingHandlerMapping</td></tr><tr><td>处理器适配器HandlerAdapter</td><td>匹配HandlerExecutionChain对应的适配器进行处理器调用，返回视图模型对象</td><td>RequestMappingHandlerAdapter</td></tr><tr><td>视图解析器ViewResolver</td><td>对视图模型对象进行解析</td><td>InternalResourceViewResolver</td></tr></tbody></table><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231114095122540.png" alt="image-20231114095122540"></p><p>SpringMVC 在前端控制器 DispatcherServlet加载时，就会进行初始化操作，在进行初始化时，就会加载SpringMVC默认指定的一些组件，这些默认组件配置在<code>DispatcherServlet.properties</code>文件中</p><blockquote><p>该文件存在与spring-webmvc-5.3.7.jar包下的<code>org\springframework\web\servlet\DispatcherServlet.properties</code>，里面指定了上面接口的实现类</p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 处理器映射器有三个实现类</span></span><br><span class="line"><span class="attr">org.springframework.web.servlet.HandlerMapping</span>=<span class="string">org.springframework.web.servlet.handler.BeanNameUrl HandlerMapping,\</span></span><br><span class="line"><span class="string">   org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping,\</span></span><br><span class="line"><span class="string">   org.springframework.web.servlet.function.support.RouterFunctionMapping</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment"># 处理器适配器有四个实现类</span></span><br><span class="line"><span class="attr">org.springframework.web.servlet.HandlerAdapter</span>=<span class="string">org.springframework.web.servlet.mvc.HttpRequestHand lerAdapter,\</span></span><br><span class="line"><span class="string">   org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\</span></span><br><span class="line"><span class="string">   org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter,\</span></span><br><span class="line"><span class="string">   org.springframework.web.servlet.function.support.HandlerFunctionAdapter</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 视图解析器有一个实现类</span></span><br><span class="line"><span class="attr">org.springframework.web.servlet.ViewResolver</span>=<span class="string">org.springframework.web.servlet.view.InternalResource ViewResolver</span></span><br></pre></td></tr></table></figure><p>这些默认的组件是在DispatcherServlet中进行初始化加载的，在DispatcherServlet中存在集合存储着这些组件， SpringMVC的默认组件会在 DispatcherServlet 中进行维护，但是并没有存储在与SpringMVC的容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title class_">FrameworkServlet</span> &#123;</span><br><span class="line">    <span class="comment">//存储处理器映射器</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;HandlerMapping&gt; handlerMappings;</span><br><span class="line">    <span class="comment">//存储处理器适配器</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;HandlerAdapter&gt; handlerAdapters;</span><br><span class="line">    <span class="comment">//存储视图解析器</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;ViewResolver&gt; viewResolvers;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置组件代替默认组件，如果不想使用默认组件，可以将替代方案使用Spring Bean的方式进行配置，例如，在 spring-mvc.xml中配置RequestMappingHandlerMapping</p><p><code> &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;/&gt;</code></p><p>但是我们在Spring容器中配置了HandlerMapping，则就不会在加载默认的HandlerMapping策略了</p><p>原理： DispatcherServlet 在进行HandlerMapping初始化时，先从SpringMVC容器中找是否存在HandlerMapping，如果 存在直接取出容器中的HandlerMapping，在存储到 DispatcherServlet 中的handlerMappings集合中去</p><h1 id="请求处理"><a href="#请求处理" class="headerlink" title="请求处理"></a>请求处理</h1><p>配置映射路径，映射器处理器才能找到Controller的方法资源，目前主流映射路径配置方式就是@RequestMapping、@GetMapping、@PostMapping，后面有REST风格拓展了这些注释，但是这三个是基础</p><table><thead><tr><th>相关注解</th><th>作用</th><th>使用位置</th></tr></thead><tbody><tr><td>@RequestMapping</td><td>设置控制器方法的访问资源路径，可以接收任何请求</td><td>方法和类</td></tr><tr><td>@GetMapping</td><td>设置控制器方法的访问资源路径，可以接收Get请求</td><td>方法</td></tr><tr><td>@PostMapping</td><td>设置控制器方法的访问资源路径，可以接收Post请求</td><td>方法</td></tr></tbody></table><h2 id="请求映射路径的配置"><a href="#请求映射路径的配置" class="headerlink" title="请求映射路径的配置"></a>请求映射路径的配置</h2><ol><li><p>单标签配置路径：只用一个标签写死位置，这样起名麻烦，可能冲突</p></li><li><p>多标签配置路径：在类上使用一次，方法上使用一次，通过父子标签减少冗余项，并避免冲突</p><p>该类所有方法都公用该@RequestMapping设置的属性，访问路径则为类上的映射 地址+方法上的映射地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/xxx&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span>, ServletContextAware &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/aaa&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">aaa</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> IOException,</span><br><span class="line">    ModelAndViewDefiningException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="RequestMapping的属性"><a href="#RequestMapping的属性" class="headerlink" title="@RequestMapping的属性"></a>@RequestMapping的属性</h3><p>@RequestMapping注解，主要使用在控制器的方法上，用于标识客户端访问资源路径</p><h4 id="常用的属性"><a href="#常用的属性" class="headerlink" title="常用的属性"></a>常用的属性</h4><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">value</button></li><li class="tab"><button type="button" data-href="#test1-2">method</button></li><li class="tab"><button type="button" data-href="#test1-3">headers</button></li><li class="tab"><button type="button" data-href="#test1-4">params</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p>value&#x2F;path：这俩互为别名，使用value属性指定一个访问路径</p><p>只有一个访问路径需要指定时，<strong>使用value属性</strong>、<strong>使用path属性</strong>或者<strong>省略value和path</strong>都可以</p><p>当有多个属性时，value和path不能省略，用来指明位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/show&quot;)</span><span class="comment">//使用value属性指定一个访问路径</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="meta">@RequestMapping(path = &quot;/show&quot;)</span><span class="comment">//使用path属性指定一个访问路径</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="meta">@RequestMapping(&quot;/show&quot;)</span><span class="comment">//如果只设置访问路径时，value和path可以省略</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value = &#123;&quot;/show&quot;,&quot;/haohao&quot;,&quot;/abc&quot;&#125;)</span><span class="comment">//使用value属性指定多个访问路径</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="meta">@RequestMapping(path = &#123;&quot;/show&quot;,&quot;/haohao&quot;,&quot;/abc&quot;&#125;)</span><span class="comment">//使用path属性指定多个访问路径</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="meta">@RequestMapping(&#123;&quot;/show&quot;,&quot;/haohao&quot;,&quot;/abc&quot;&#125;)</span><span class="comment">//如果只设置访问路径时，value和path可以省略</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p>method：通过method属性设置前端访问方式，限定访问方式时，方式和路径都匹配上才能匹配成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求地址是/show,且请求方式必须是POST才能匹配成功</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/show&quot;,method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>@GetMapping，当请求方式是GET时，我们可以使用@GetMapping替代@RequestMapping </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/show&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>@PostMapping，当请求方式是POST时，我们可以使用@PostMapping替代@RequestMapping </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/show&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>method的属性值是一个枚举类型，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RequestMethod</span> &#123;</span><br><span class="line">    GET,</span><br><span class="line">    HEAD,</span><br><span class="line">    POST,</span><br><span class="line">    PUT,</span><br><span class="line">    PATCH,</span><br><span class="line">    DELETE,</span><br><span class="line">    OPTIONS,</span><br><span class="line">    TRACE;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">RequestMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p>一般都是请求里面携带请求头，服务端可以通过请求头的名字去获得对应的值，使用<code>@RequestHeader(请求头名字) 形参1，...</code></p><ul><li><p>接收指定名称的请求头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/headers&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">headers</span><span class="params">(<span class="meta">@RequestHeader(&quot;Accept-Encoding&quot;)</span> String acceptEncoding)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Accept-Encoding:&quot;</span>+acceptEncoding);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接收所有的请求头信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/headersMap&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">headersMap</span><span class="params">(<span class="meta">@RequestHeader</span> Map&lt;String,String&gt; map)</span>&#123;</span><br><span class="line">    map.forEach((k,v)-&gt;&#123;</span><br><span class="line">        System.out.println(k+<span class="string">&quot;:&quot;</span>+v);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获得客户端携带的Cookie数据</p><p>cookie也是个请求头，叫<code>JSESSIONID</code>的更特殊，是session域的cookie</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/cookies&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">cookies</span><span class="params">(<span class="meta">@CookieValue(value = &quot;JSESSIONID&quot;,defaultValue = &quot;&quot;)</span> String jsessionid)</span>&#123;</span><br><span class="line">    System.out.println(jsessionid);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><p>获得转发Request域中数据，在进行资源之间转发时，有时需要将一些参数存储到request域中携带给下一个资源</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="请求数据的接收"><a href="#请求数据的接收" class="headerlink" title="请求数据的接收"></a>请求数据的接收</h2><h3 id="普通请求数据"><a href="#普通请求数据" class="headerlink" title="普通请求数据"></a>普通请求数据</h3><ul><li><p>当客户端提交的数据是普通键值对形式时，直接使用同名形参接收即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//username=haohao&amp;age=35</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/show&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">(String username, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">    System.out.println(username+<span class="string">&quot;==&quot;</span>+age);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>请求参数有特殊格式数据，如日期时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//username=haohao&amp;age=35&amp;birthday=1986/01/01</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/show&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">(String username,<span class="type">int</span> age,Date birthday)</span>&#123;</span><br><span class="line">    System.out.println(username+<span class="string">&quot;==&quot;</span>+age+<span class="string">&quot;==&quot;</span>+birthday);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Date可以正常接收，因为Spring内置的类型解析器，可以识别的日期格式是 yyyy&#x2F;MM&#x2F;dd，但是如果我们提交其他 格式，例如：yyyy-MM-dd 时，类型转换会报错</p><p>可以使用@DateTimeFormat 指定日期格式解决</p><p>修改UserController如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/show&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">(String username,<span class="type">int</span> age,<span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> Date birthday)</span>&#123;</span><br><span class="line">    System.out.println(username+<span class="string">&quot;==&quot;</span>+age+<span class="string">&quot;==&quot;</span>+birthday);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接收普通请求数据，当请求参数的名称与方法参数名不一致时，默认不能注入成功，相关属性是null</p><p>可以使用@RequestParam注解进行标注，<strong>起别名</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//username=haohao&amp;age=35</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/show&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">(<span class="meta">@RequestParam(name = &quot;username&quot;,required = true)</span> String name, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">    System.out.println(name+<span class="string">&quot;==&quot;</span>+age);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="数组或集合数据"><a href="#数组或集合数据" class="headerlink" title="数组或集合数据"></a>数组或集合数据</h3><h4 id="接收多个同名参数时"><a href="#接收多个同名参数时" class="headerlink" title="接收多个同名参数时"></a>接收多个同名参数时</h4><p>接收数组或集合数据，客户端传递多个同名参数时，也可以使用单列集合接收，但是需要使用@RequestParam告知框架传递的参数是要同名设置的，不是对象属性设置的</p><ul><li><p>请求：<code>hobbies=eat&amp;hobbies=sleep</code></p></li><li><p>数组接受</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组接受</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/show&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">(String[] hobbies)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String hobby : hobbies) &#123;</span><br><span class="line">        System.out.println(hobby);&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>list列表接受</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/show&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;String&gt; hobbies)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String hobby : hobbies) &#123;</span><br><span class="line">        System.out.println(hobby);&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h4 id="接收多个不同命参数"><a href="#接收多个不同命参数" class="headerlink" title="接收多个不同命参数"></a>接收多个不同命参数</h4><p>可以使用 Map 进行接收多个不同命参数，同样需要用 @RequestParam 进行修饰，</p><ul><li><p>请求：<code>username=haohao&amp;age=18</code></p></li><li><p>Map 接收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/show&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">(<span class="meta">@RequestParam</span> Map&lt;String,Object&gt; params)</span>&#123;</span><br><span class="line">    params.forEach((key,value)-&gt;&#123;</span><br><span class="line">        System.out.println(key+<span class="string">&quot;==&quot;</span>+value);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="RequestParam属性"><a href="#RequestParam属性" class="headerlink" title="@RequestParam属性"></a>@RequestParam属性</h4><p>value</p><p>required</p><p>default</p><h3 id="实体JavaBean属性数据"><a href="#实体JavaBean属性数据" class="headerlink" title="实体JavaBean属性数据"></a>实体JavaBean属性数据</h3><ul><li><p>单个JavaBean数据</p><p>前面提到，提交的参数名称只要与Java的属性名一致，就可以进行自动封装</p><p>如果不一致，可以用<code>@RequestParam</code>起别名来接收</p><p>实体类中，同名属性直接接收，不同名属性就在属性上加注解起别名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">username=haohao&amp;age=<span class="number">35</span>&amp;hobbies=eat&amp;hobbies=sleep</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  <span class="keyword">private</span> Integer age;</span><br><span class="line">  <span class="keyword">private</span> String[] hobbies;</span><br><span class="line">  <span class="keyword">private</span> Date birthday;</span><br><span class="line">  <span class="keyword">private</span> Address address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/show&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">(User user)</span>&#123;</span><br><span class="line">  System.out.println(user);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>嵌套JavaBean数据：提交的参数名称用，去描述嵌套对象的属性关系即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username=haohao&amp;address.city=tianjin&amp;address.area=jinghai</span><br></pre></td></tr></table></figure></li></ul><h3 id="Json数据格式"><a href="#Json数据格式" class="headerlink" title="Json数据格式"></a>Json数据格式</h3><p>Json数据都是以请求体的方式提交的，且不是原始的键值对格式的，所以我们要使用 @RequestBody注解整体接收该数据</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span><span class="string">&quot;haohao&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">18</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hobbies&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;eat&quot;</span><span class="punctuation">,</span><span class="string">&quot;sleep&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;birthday&quot;</span><span class="punctuation">:</span><span class="string">&quot;1986-01-01&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span><span class="string">&quot;tj&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;area&quot;</span><span class="punctuation">:</span><span class="string">&quot;binhai&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/show6&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show6</span><span class="params">(<span class="meta">@RequestBody</span> String body)</span>&#123;</span><br><span class="line">  System.out.println(body);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Json工具"><a href="#Json工具" class="headerlink" title="Json工具"></a>Json工具</h4><p> jackson 将Json格式的字符串转化为JavaBean进行操作，也能把JavaBean转为Json</p><ol><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/show&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">(<span class="meta">@RequestBody</span> String body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println(body);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获得ObjectMapper</span></span><br><span class="line">    <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将json格式字符串转化成指定的User</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> objectMapper.readValue(body, User.class);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置RequestMappingHandlerAdapter，指定消息转换器，就不用手动转换json格式字符串了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;messageConverters&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/show&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接收Json数据格式数据，使用Map接收json格式字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/show&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">show</span><span class="params">(<span class="meta">@RequestBody</span> Map map)</span>&#123;</span><br><span class="line">    System.out.println(map);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Restful风格"><a href="#Restful风格" class="headerlink" title="Restful风格"></a>Restful风格</h2><p>Rest（Representational State Transfer）表象化状态转变（表述性状态转变）基于HTTP、URI 、xml、JSON等标准和协议，支持轻量级、跨平台、跨语言的架构设计。是Web服务的一种新网络应用程序的设计风 格和开发方式。</p><p>常见的规则有如下三点：</p><ol><li><p>用URI表示某个模块资源，资源名称为名词</p></li><li><p>用请求方式表示模块具体业务动作</p><p>例如：GET表示查询、POST表示插入、PUT表示更新、DELETE表示删除</p></li><li><p>用HTTP响应状态码表示结果，国内常用的响应包括三部分：状态码、状态信息、响应数据</p></li></ol><p>接收Restful风格数据时，一般会在URL地址上携带Restful请求数据，这样参数就在原来的路径里面了，相应的controller路径不能写死，可以使用<code>@PathVariable(占位符参数名称)</code>，占位以后当做形参使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//http://localhost/user/100</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">findUserById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>&#123;</span><br><span class="line">    System.out.println(id);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求URL资源地址包含多个参数情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//http://localhost/user/haohao/18</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/user/&#123;username&#125;/&#123;age&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">findUserByUsernameAndAge</span><span class="params">(<span class="meta">@PathVariable(&quot;username&quot;)</span> String</span></span><br><span class="line"><span class="params">                                       username,<span class="meta">@PathVariable(&quot;age&quot;)</span> Integer age)</span>&#123;</span><br><span class="line">    System.out.println(username+<span class="string">&quot;==&quot;</span>+age);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>客户端提交文件一般通过表单方式，对表单需要一定的要求</p><ol><li>表单的提交方式必须是POST</li><li>表单的enctype属性必须是multipart&#x2F;form-data</li><li>文件上传项需要有name属性</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;myFile&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在SpringMVC中，只要名字能进行匹配，SpringMVC会自动进行设置</p><h2 id="Javaweb常用对象获取"><a href="#Javaweb常用对象获取" class="headerlink" title="Javaweb常用对象获取"></a>Javaweb常用对象获取</h2><p>获得Javaweb常见原生对象，有时在我们的Controller方法中需要用到Javaweb的原生对象，例如：Request、 Response等，我们只需要将需要的对象以形参的形式写在方法上，SpringMVC框架在调用Controller方法时，会自动传递实参：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/javawebObject&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">javawebObject</span><span class="params">(HttpServletRequest request, HttpServletResponse response, HttpSession session)</span>&#123;</span><br><span class="line">    System.out.println(request);</span><br><span class="line">    System.out.println(response);</span><br><span class="line">    System.out.println(session);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/index.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="请求静态资源"><a href="#请求静态资源" class="headerlink" title="请求静态资源"></a>请求静态资源</h2><p>使用SpringMVC后，访问静态资源一定会失效，因为当DispatcherServlet的映射路径配置为<code>/</code> 的时候，那么就覆盖的Tomcat容器默认的缺省Servlet，<strong>在Tomcat的config目录下有一个web.xml</strong>是对所有的web项目的全局配置，其中有如下配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.apache.catalina.servlets.DefaultServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>url-pattern配置为<code>/</code> 的Servlet我们称其为缺省的Servlet，作用是当其他Servlet都匹配不成功时，就找缺省的Servlet，<code>/</code>的接受路径是除了<code>jsp</code>外的所有请求</p><p>默认情况下，静态资源由于没有匹配成功的Servlet，所以会找缺省的DefaultServlet，该DefaultServlet具备二次去匹配静态资源的功能。</p><p>但是在项目的web.xml中配置DispatcherServlet后，DefaultServlet就被覆盖掉了，而DispatcherServlet会将请求的静态资源的名称当成Controller的映射路径去匹配，所以静态资源访问不成功了</p><h3 id="静态资源请求的三种解决方案"><a href="#静态资源请求的三种解决方案" class="headerlink" title="静态资源请求的三种解决方案"></a>静态资源请求的三种解决方案</h3><div class="tabs" id="test2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test2-1">再次激活DefaultServlet</button></li><li class="tab"><button type="button" data-href="#test2-2">配置静态资源映射</button></li><li class="tab"><button type="button" data-href="#test2-3">配置mvc:default-servlet-handler</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test2-1"><p>可以再次激活Tomcat的DefaultServlet，Servlet的url-pattern的匹配优先级是：精确匹配&gt;目录匹配&gt; 扩展名匹配&gt;缺省匹配，所以可以指定某个目录下或某个扩展名的资源使用DefaultServlet进行解析</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/img/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.html<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-2"><p>在spring-mvc.xml中去配置静态资源映射，匹配映射路径的请求到指定的位置去匹配资源</p><p>同时要配置自命名空间</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231208222341463.png" alt="image-20231208222341463"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           &quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- mapping是映射资源路径，location是对应资源所在的位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/img/*&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/img/&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/css/*&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/css/&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/css/*&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/js/&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/html/*&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/html/&quot;</span>/&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-3"><p>在spring-mvc.xml中去配置&lt; mvc:default-servlet-handler&gt;，该方式是注册了一个 DefaultServletHttpRequestHandler 处理器，静态资源的访问都由该处理器去处理，这也是开发中使用最多的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;mvc:default-servlet-handler/&gt;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="注解驱动mvc-annotation-driven"><a href="#注解驱动mvc-annotation-driven" class="headerlink" title="注解驱动mvc:annotation-driven"></a>注解驱动mvc:annotation-driven</h3><p>静态资源配置的第二第三种方式我们可以正常访问静态资源了，但是Controller又无法访问了，报错404，即找不到对应的资源</p><p>第二种方式是通过SpringMVC去解析mvc命名空间下的resources标签完成的静态资源解析</p><p>第三种方式式通过 SpringMVC去解析mvc命名空间下的default-servlet-handler标签完成的静态资源解析</p><p>根据前面所学习的自定义命名空间的解析的知识，可以发现不管是以上哪种方式，最终都会注册SimpleUrlHandlerMapping，然后就覆盖了Tomcat的web.xml配置</p><blockquote><p>主要是有没有RequestMappingHandlerMapping</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BeanDefinition <span class="title function_">parse</span><span class="params">(Element element, ParserContext context)</span> &#123;</span><br><span class="line">    <span class="comment">//创建SimpleUrlHandlerMapping类型的BeanDefinition</span></span><br><span class="line">    <span class="type">RootBeanDefinition</span> <span class="variable">handlerMappingDef</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(SimpleUrlHandlerMapping.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册SimpleUrlHandlerMapping的BeanDefinition</span></span><br><span class="line">    context.getRegistry().registerBeanDefinition(beanName, handlerMappingDef);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合组件浅析知识点，一旦SpringMVC容器中存在 HandlerMapping类型的组件时，前端控制器 DispatcherServlet在进行初始化时，就会从容器中获得HandlerMapping ，不再加载 dispatcherServlet.properties中默认处理器映射器策略，那也就意味着RequestMappingHandlerMapping不会被加载到了。</p><p>同样的，手动将RequestMappingHandlerMapping也注册到SpringMVC容器中就可以了，这样DispatcherServlet在进行初始化时，就会从容器中同时获得RequestMappingHandlerMapping存储到DispatcherServlet中名为 handlerMappings的List集合中，对@RequestMapping注解进行解析。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>综合上面配置，要求：</p><ul><li>@RequestMapping能正常映射到资源方法</li><li>静态资源能正常访问</li><li>将请求json格式字符串和JavaBean之间自由转换</li></ul><div class="tabs" id="test3"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test3-1">原始配置方式</button></li><li class="tab"><button type="button" data-href="#test3-2">mvc:annotation-driven简化</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test3-1"><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 显示配置RequestMappingHandlerMapping --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 显示配置RequestMappingHandlerAdapter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;messageConverters&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置DefaultServletHttpRequestHandler--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-2"><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--mvc注解驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置DefaultServletHttpRequestHandler--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>该标签内部会帮我们注册RequestMappingHandlerMapping、注册 RequestMappingHandlerAdapter并注入Json消息转换器等</p><blockquote><p>另外：标签在不同的版本中，帮我们注册的组件不同，Spring 3.0.X 版本注册是 DefaultAnnotationHandlerMapping 和 AnnotationMethodHandlerAdapter，由于框架的发展，从Spring 3.1.X 开始注册组件变为 RequestMappingHandlerMapping和RequestMappingHandlerAdapter</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="响应处理"><a href="#响应处理" class="headerlink" title="响应处理"></a>响应处理</h1><p>响应数据主要分为两大部分：</p><ul><li>传统同步方式：准备好模型数据，在跳转到执行页面进行展示，此方式使用越来越少了，基于历史原因，一些旧项目还在使用</li><li>前后端分离异步方式：前端使用Ajax技术+Restful风格与服务端进行Json格式为主的数据交互，目前市场上几乎都是此种方式了。</li></ul><p>传统同步业务在数据响应时，SpringMVC又涉及如下四种形式： </p><ol><li>请求资源转发</li><li>请求资源重定向</li><li>响应模型数据</li><li>直接回写数据给客户端；</li></ol><h1 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h1><h2 id="拦截器的配置"><a href="#拦截器的配置" class="headerlink" title="拦截器的配置"></a>拦截器的配置</h2><p>SpringMVC中的拦截器用于拦截控制器方法的执行</p><p>SpringMVC中的拦截器需要实现HandlerInterceptor</p><p>SpringMVC的拦截器必须在SpringMVC的配置文件中进行配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.interceptor.FirstInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;firstInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 以上两种配置方式都是对DispatcherServlet所处理的所有的请求进行拦截 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/testRequestEntity&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;firstInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上配置方式可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求</p><h2 id="拦截器的三个抽象方法"><a href="#拦截器的三个抽象方法" class="headerlink" title="拦截器的三个抽象方法"></a>拦截器的三个抽象方法</h2><table><thead><tr><th></th><th>作用</th><th>参数</th><th>返回值</th></tr></thead><tbody><tr><td>preHandle</td><td>对拦截到的请求进行预处理，返回true放 行执行处理器方法，false不放行</td><td>Handler是拦截到的Controller方 法处理器</td><td>一旦返回false，代表终止向后 执行，所有后置方法都不执行， 最终方法只执行对应preHandle 返回了true的</td></tr><tr><td>postHandle</td><td>在处理器的方法执行后，对拦截到的请求 进行后处理，可以在方法中对模型数据和视图进行修改</td><td>Handler是拦截到的Controller方 法处理器；modelAndView是返回的模型视图对象</td><td>无</td></tr><tr><td>afterCompletion</td><td>视图渲染完成后(整个流程结束之后)，进行 最后的处理，如果请求流程中有异常，可 以处理异常对象</td><td>Handler是拦截到的Controller方法处理器；ex是异常对象</td><td></td></tr></tbody></table><h2 id="多个拦截器的执行顺序"><a href="#多个拦截器的执行顺序" class="headerlink" title="多个拦截器的执行顺序"></a>多个拦截器的执行顺序</h2><ul><li><p>若每个拦截器的preHandle()都返回true</p><p>此时多个拦截器的执行顺序和拦截器在SpringMVC的配置文件的配置顺序有关：</p><p>preHandle()会按照配置的顺序执行，而postHandle()和afterComplation()会按照配置的反序执行</p></li><li><p>若某个拦截器的preHandle()返回了false、</p><p>preHandle()返回false和它之前的拦截器的preHandle()都会执行，postHandle()都不执行，返回false的拦截器之前的拦截器的afterComplation()会执行</p></li></ul><h2 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231209111725141.png" alt="image-20231209111725141"></p><h1 id="全注解开发"><a href="#全注解开发" class="headerlink" title="全注解开发"></a>全注解开发</h1><p>跟之前全注解开发思路一致， xml配置文件使用核心配置类替代，xml中的标签使用对应的注解替代</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           &quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 组件扫描 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima.controller&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--非自定义bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5000000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--注解驱动--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置静态资源处理器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置文件上传解析器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置拦截器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/*&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.interceptor.MyInterceptor01&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p>组件扫描web层，使用</p></li><li><p>注解驱动</p></li><li><p>配置文件上传解析器</p><p>组件扫描，可以通过@ComponentScan注解完成</p><p>文件上传解析器multipartResolver可以通过非自定义Bean的注解配置方式，即@Bean注解完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima.controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMVCConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CommonsMultipartResolver <span class="title function_">multipartResolver</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">CommonsMultipartResolver</span> <span class="variable">multipartResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CommonsMultipartResolver</span>();</span><br><span class="line">        multipartResolver.setDefaultEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        multipartResolver.setMaxUploadSize(<span class="number">3145728</span>);</span><br><span class="line">        multipartResolver.setMaxUploadSizePerFile(<span class="number">1048576</span>);</span><br><span class="line">        multipartResolver.setMaxInMemorySize(<span class="number">1048576</span>);</span><br><span class="line">        <span class="keyword">return</span> multipartResolver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置拦截器</p><p>SpringMVC 提供了一个注解叫做 @EnableWebMvc，我们看一下源码，内部通过@Import 导入了DelegatingWebMvcConfiguration类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(&#123;DelegatingWebMvcConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableWebMvc &#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelegatingWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">WebMvcConfigurerComposite</span> <span class="variable">configurers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebMvcConfigurerComposite</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从容器中注入WebMvcConfigurer类型的Bean</span></span><br><span class="line">    <span class="meta">@Autowired(required = false)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setConfigurers</span><span class="params">(List&lt;WebMvcConfigurer&gt; configurers)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(configurers)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.configurers.addWebMvcConfigurers(configurers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置DefaultServletHttpRequestHandler</p><p>WebMvcConfigurer类型的Bean会被注入进来，然后被自动调用，所以可以实现WebMvcConfigurer接口，完成一些 解析器、默认Servlet等的指定，WebMvcConfigurer接口定义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="comment">//配置默认Servet处理器</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加拦截器</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加资源处理器</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加视图控制器</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置视图解析器</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加参数解析器</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">addArgumentResolvers</span><span class="params">(List&lt;HandlerMethodArgumentResolver&gt; resolvers)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="组件原理剖析"><a href="#组件原理剖析" class="headerlink" title="组件原理剖析"></a>组件原理剖析</h1><h2 id="前端控制器初始化"><a href="#前端控制器初始化" class="headerlink" title="前端控制器初始化"></a>前端控制器初始化</h2><p>前端控制器DispatcherServlet是SpringMVC的入口，主流程的工作都是在此完成的</p><p>DispatcherServlet 本质是个Servlet，当配置了 load-on-startup 时，会在服务 器启动时就执行创建和执行初始化init方法，每次请求都会执行service方法</p><p>DispatcherServlet 的初始化主要做了两件事：</p><ol><li>获得了一个 SpringMVC 的 ApplicationContext容器</li><li>注册了 SpringMVC的 九大组件。</li></ol><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231114222415821.png" alt="image-20231114222415821"></p><p>SpringMVC 的ApplicationContext容器创建时机：</p><ul><li><p>Servlet 规范的 init(ServletConfig config) 方法经过子类重写 ，最终会调用 FrameworkServlet 抽象类的initWebApplicationContext() 方法，该方法中最终获得 一个根 Spring容器（Spring产生的），一个子Spring容器（SpringMVC产生的）</p></li><li><p>HttpServletBean 的初始化方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    <span class="built_in">this</span>.initServletBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>FrameworkServlet的initServletBean方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    <span class="built_in">this</span>.webApplicationContext = <span class="built_in">this</span>.initWebApplicationContext();<span class="comment">//初始化ApplicationContext</span></span><br><span class="line">    <span class="built_in">this</span>.initFrameworkServlet();<span class="comment">//模板设计模式，供子类覆盖实现，但是子类DispatcherServlet没做使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在initWebApplicationContext方法中体现的父子容器的逻辑关系</p><ul><li>父容器：Spring 通过ContextLoaderListener为入口产生的applicationContext容器，内部主要维护的是 applicationContext.xml（或相应配置类）配置的Bean信息</li><li>子容器：SpringMVC通过DispatcherServlet的init() 方法产生的applicationContext容器，内部主要维护的 是spring-mvc.xml（或相应配置类）配置的Bean信息，且内部还通过parent属性维护这父容器的引用</li><li>Bean的检索顺序：根据上面子父容器的概念，可以知道Controller存在与子容器中，而Controller中要注入 Service时，会先从子容器本身去匹配，匹配不成功时在去父容器中去匹配，于是最终从父容器中匹配到的 UserService，这样子父容器就可以进行联通了。但是父容器只能从自己容器中进行匹配，不能从子容器中进 行匹配。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化ApplicationContext是一个及其关键的代码</span></span><br><span class="line"><span class="keyword">protected</span> WebApplicationContext <span class="title function_">initWebApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//获得根容器，其实就是通过ContextLoaderListener创建的ApplicationContext</span></span><br><span class="line">    <span class="comment">//如果配置了ContextLoaderListener则获得根容器，没配置获得的是null</span></span><br><span class="line">    <span class="type">WebApplicationContext</span> <span class="variable">rootContext</span> <span class="operator">=</span></span><br><span class="line">        WebApplicationContextUtils.getWebApplicationContext(<span class="built_in">this</span>.getServletContext());</span><br><span class="line">    <span class="comment">//定义SpringMVC产生的ApplicationContext子容器</span></span><br><span class="line">    <span class="type">WebApplicationContext</span> <span class="variable">wac</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (wac == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//==&gt;创建SpringMVC的子容器，创建同时将Spring的创建的rootContext传递了过去</span></span><br><span class="line">        wac = <span class="built_in">this</span>.createWebApplicationContext(rootContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将SpringMVC产生的ApplicationContext子容器存储到ServletContext域中</span></span><br><span class="line">    <span class="comment">//key名是：org.springframework.web.servlet.FrameworkServlet.CONTEXT.DispatcherServlet</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.publishContext) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">attrName</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContextAttributeName();</span><br><span class="line">        <span class="built_in">this</span>.getServletContext().setAttribute(attrName, wac);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进创建子容器的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> WebApplicationContext <span class="title function_">createWebApplicationContext</span><span class="params">(<span class="meta">@Nullable</span> ApplicationContext parent)</span> &#123;</span><br><span class="line">    <span class="comment">//实例化子容器ApplicationContext</span></span><br><span class="line">    <span class="type">ConfigurableWebApplicationContext</span> <span class="variable">wac</span> <span class="operator">=</span></span><br><span class="line">        (ConfigurableWebApplicationContext)BeanUtils.instantiateClass(contextClass);</span><br><span class="line">    <span class="comment">//设置传递过来的ContextLoaderListener的rootContext为父容器</span></span><br><span class="line">    wac.setParent(parent);</span><br><span class="line">    <span class="comment">//获得web.xml配置的classpath:spring-mvc.xml</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">configLocation</span> <span class="operator">=</span> <span class="built_in">this</span>.getContextConfigLocation();</span><br><span class="line">    <span class="keyword">if</span> (configLocation != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//为子容器设置配置加载路径</span></span><br><span class="line">        wac.setConfigLocation(configLocation);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化子容器(就是加载spring-mvc.xml配置的Bean)</span></span><br><span class="line">    <span class="built_in">this</span>.configureAndRefreshWebApplicationContext(wac);</span><br><span class="line">    <span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子容器中的parent维护着父容器的引用</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231114223638531.png" alt="image-20231114223638531"></p></li></ul><h2 id="注册-SpringMVC的-九大组件"><a href="#注册-SpringMVC的-九大组件" class="headerlink" title="注册 SpringMVC的 九大组件"></a>注册 SpringMVC的 九大组件</h2><p>在初始化容器initWebApplicationContext方法中执行了onRefresh方法，进而执 行了初始化策略initStrategies方法，注册了九个解析器组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DispatcherServlet初始化SpringMVC九大组件</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initStrategies</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.initMultipartResolver(context);<span class="comment">//1、初始化文件上传解析器</span></span><br><span class="line">    <span class="built_in">this</span>.initLocaleResolver(context);<span class="comment">//2、初始化国际化解析器</span></span><br><span class="line">    <span class="built_in">this</span>.initThemeResolver(context);<span class="comment">//3、初始化模板解析器</span></span><br><span class="line">    <span class="built_in">this</span>.initHandlerMappings(context);<span class="comment">//4、初始化处理器映射器</span></span><br><span class="line">    <span class="built_in">this</span>.initHandlerAdapters(context);<span class="comment">//5、初始化处理器适配器</span></span><br><span class="line">    <span class="built_in">this</span>.initHandlerExceptionResolvers(context);<span class="comment">//6、初始化处理器异常解析器</span></span><br><span class="line">    <span class="built_in">this</span>.initRequestToViewNameTranslator(context);<span class="comment">//7、初始化请求视图转换器</span></span><br><span class="line">    <span class="built_in">this</span>.initViewResolvers(context);<span class="comment">//8、初始化视图解析器</span></span><br><span class="line">    <span class="built_in">this</span>.initFlashMapManager(context);<span class="comment">//9、初始化lashMapManager策略组件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h1><p>异常分为编译时异常和运行时异常，在SpringMVC 中，2种异常都最终由 SpringMVC提供的异常处理器进行统一处理，这样就避免了随时随地捕获处理的繁琐性，除了繁琐之外，进行前后端分离异步开发时，返回统一格式的结果给客户端，即使报异常了，需要将异常转换成符合json的响应数据给客户端</p><p>SpringMVC 处理异常的思路是，一路向上抛，都抛给前端控制器 DispatcherServlet ，DispatcherServlet 在调 用异常处理器ExceptionResolver进行处理</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231114214420631.png" alt="image-20231114214420631"></p><h2 id="异常处理方式"><a href="#异常处理方式" class="headerlink" title="异常处理方式"></a>异常处理方式</h2><p>SpringMVC 提供了以下三种处理异常的方式：</p><ol><li>简单异常处理器：使用SpringMVC 内置的异常处理器处理SimpleMappingExceptionResolver</li><li>自定义异常处理器：实现HandlerExceptionResolver接口，自定义异常处理器进行处理</li><li>注解方式：使用@ControllerAdvice + @ExceptionHandler 来处理</li></ol><h3 id="简单异常处理器"><a href="#简单异常处理器" class="headerlink" title="简单异常处理器"></a>简单异常处理器</h3><p>使用SimpleMappingExceptionResolver处理一些简单异常，配置开启SimpleMappingExceptionResolver， 并指定异常捕获后的处理动作，当发生了异常后，会被 SimpleMappingExceptionResolver 处理，跳转到我们 配置的错误页面error.html给用户进行友好展示</p><p>在配置SimpleMappingExceptionResolver时，指定一些参数，比如异常的类型</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置简单异常处理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 异常捕获后动作：展示视图 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultErrorView&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/error.html&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionMappings&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 配置异常类型对应的展示视图 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;java.lang.RuntimeException&quot;</span>&gt;</span>/error.html<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;java.io.FileNotFoundException&quot;</span>&gt;</span>/io.html<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注解方式配置简单映射异常处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SimpleMappingExceptionResolver <span class="title function_">simpleMappingExceptionResolver</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//创建SimpleMappingExceptionResolver</span></span><br><span class="line">    <span class="type">SimpleMappingExceptionResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMappingExceptionResolver</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义Properties设置特殊异常对应的映射视图</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="comment">//设置RuntimeException异常展示视图</span></span><br><span class="line">    properties.setProperty(<span class="string">&quot;java.lang.RuntimeException&quot;</span>,<span class="string">&quot;/error.html&quot;</span>);</span><br><span class="line">    <span class="comment">//设置FileNotFoundException异常展示视图</span></span><br><span class="line">    properties.setProperty(<span class="string">&quot;java.io.FileNotFoundException&quot;</span>,<span class="string">&quot;/io.html&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置默认错误展示视图</span></span><br><span class="line">    resolver.setDefaultErrorView(<span class="string">&quot;/error.html&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    resolver.setExceptionMappings(properties);</span><br><span class="line">    <span class="keyword">return</span> resolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义异常处理器"><a href="#自定义异常处理器" class="headerlink" title="自定义异常处理器"></a>自定义异常处理器</h3><p>实现HandlerExceptionResolver接口自定义异常处理器，可以完成异常逻辑的处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyHandlerExceptionResolver</span> <span class="keyword">implements</span> <span class="title class_">HandlerExceptionResolver</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//参数Object是当前目标方法处理器对象HandlerMethod</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">resolveException</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> &#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        modelAndView.setViewName(<span class="string">&quot;/error.html&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>交给Spring管理异常处理器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.exception.MyHandlerExceptionResolver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>返回Json格式字符串信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyHandlerExceptionResolver</span> <span class="keyword">implements</span> <span class="title class_">HandlerExceptionResolver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">resolveException</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//编写要返回的json格式的字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonStr</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;code\&quot;:0,\&quot;message\&quot;:\&quot;error\&quot;,\&quot;data\&quot;:\&quot;\&quot;&#125;&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            httpServletResponse.getWriter().write(jsonStr);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h3><p>使用注解 @ControllerAdvice + @ExceptionHandler 配置异常</p><p>@ControllerAdvice 注解本质是一个 @Component，也会被扫描到，与此同时，具备AOP功能，默认情况下对所有的Controller都进行拦截操作</p><p>拦截结合@ExceptionHandler、@InitBinder、@ModelAttribute 注解一起使用此 处我们讲解的是异常，所以是@ControllerAdvice + @ExceptionHandler的组合形式</p><ul><li><p>编写全局异常处理器类，使用@ControllerAdvice标注，且@ExceptionHandler指定异常类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(RuntimeException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">runtimeHandleException</span><span class="params">(RuntimeException e)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;全局异常处理器执行....&quot;</span>+e);</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;/error.html&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(IOException.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> ResultInfo <span class="title function_">ioHandleException</span><span class="params">(IOException e)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟一个ResultInfo</span></span><br><span class="line">        <span class="type">ResultInfo</span> <span class="variable">resultInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResultInfo</span>(<span class="number">0</span>,<span class="string">&quot;IOException&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> resultInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果全局异常处理器响应的数据都是Json格式的字符串的话，可以使用@RestControllerAdvice替代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="meta">@ExceptionHandler(RuntimeException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResultInfo <span class="title function_">runtimeHandleException</span><span class="params">(RuntimeException e)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟一个ResultInfo</span></span><br><span class="line">        <span class="type">ResultInfo</span> <span class="variable">resultInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResultInfo</span>(<span class="number">0</span>,<span class="string">&quot;RuntimeException&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> resultInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(IOException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResultInfo <span class="title function_">ioHandleException</span><span class="params">(IOException e)</span>&#123;</span><br><span class="line">        <span class="comment">//模拟一个ResultInfo</span></span><br><span class="line">        <span class="type">ResultInfo</span> <span class="variable">resultInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResultInfo</span>(<span class="number">0</span>,<span class="string">&quot;IOException&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> resultInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="异常处理机制原理剖析"><a href="#异常处理机制原理剖析" class="headerlink" title="异常处理机制原理剖析"></a>异常处理机制原理剖析</h2><ol><li><p>初始化加载的处理器异常解析器，SpringMVC 的前置控制器在进行初始化的时候，会初始化处理器异常解析器 HandlerExceptionResolver</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化处理器异常解析器</span></span><br><span class="line"><span class="built_in">this</span>.initHandlerExceptionResolvers(context);</span><br></pre></td></tr></table></figure></li><li><p>从容器中获得HandlerExceptionResolver的Map集合，如果容器中没有HandlerExceptionResolver的话，则加载默认的HandlerExceptionResolver</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initHandlerExceptionResolvers</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从容器中获得HandlerExceptionResolver的Map集合</span></span><br><span class="line">    Map&lt;String, HandlerExceptionResolver&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerExceptionResolver.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果容器中没有HandlerExceptionResolver的话，则加载默认的HandlerExceptionResolver</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.handlerExceptionResolvers == <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从dispatcherServlet.properties中加载</span></span><br><span class="line">        <span class="built_in">this</span>.handlerExceptionResolvers = <span class="built_in">this</span>.getDefaultStrategies(context,HandlerExceptionResolver.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>加载DispatcherServlet.properties中默认的异常处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver,\</span><br><span class="line">    org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\</span><br><span class="line">    org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver</span><br></pre></td></tr></table></figure></li><li><p>配置了自定义的异常处理器后，默认的异常处理器就不会被加载，当配置 或配置了 注解@EnableWebMvc后，默认异常处理器和自定的处理器异常解析器都会被注册</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231114221439631.png" alt="image-20231114221439631"></p></li><li><p>异常处理器加载完毕后，当发生异常时，就会进行处理，跟踪 DispatcherServlet 的 doDispatch() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">dispatchException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义异常</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        dispatchException = e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable te) &#123;</span><br><span class="line">        dispatchException = <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Handler dispatch failed&quot;</span>, te);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//视图处理、拦截器最终方法调用、异常处理都在该方法内 </span></span><br><span class="line">    <span class="built_in">this</span>.processDispatchResult(processedRequest, response, mappedHandler, mv,</span><br><span class="line">                               (Exception)dispatchException);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>跟踪processDispatchResult方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processDispatchResult</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                   <span class="meta">@Nullable</span> HandlerExecutionChain mappedHandler, <span class="meta">@Nullable</span> ModelAndView mv, <span class="meta">@Nullable</span> Exception</span></span><br><span class="line"><span class="params">                                   exception)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">errorView</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//定义错误视图标识，默认为false</span></span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//判断当前捕获的异常是否是ModelAndViewDefiningException类型的异常</span></span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> ModelAndViewDefiningException) &#123;</span><br><span class="line">            <span class="comment">//获得ModelAndViewDefiningException异常对象中的ModelAndView对象</span></span><br><span class="line">            mv = ((ModelAndViewDefiningException)exception).getModelAndView();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//捕获到其他异常，获得当前发生异常的Handler对象</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">handler</span> <span class="operator">=</span> mappedHandler != <span class="literal">null</span> ? mappedHandler.getHandler() : <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//执行processHandlerException 方法</span></span><br><span class="line">            mv = <span class="built_in">this</span>.processHandlerException(request, response, handler, exception);</span><br><span class="line">            <span class="comment">//如果异常处理返回了ModelAndView 则修改错误视图的标识为true</span></span><br><span class="line">            errorView = mv != <span class="literal">null</span>;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">    <span class="comment">// ... 省略其他代码 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟踪processHandlerException 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> ModelAndView <span class="title function_">processHandlerException</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                               <span class="meta">@Nullable</span> Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">exMv</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//定义ModelAndView</span></span><br><span class="line">    <span class="comment">//判断处理器异常解析器集合是否是空的</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.handlerExceptionResolvers != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//遍历处理器异常解析器List集合</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">var6</span> <span class="operator">=</span> <span class="built_in">this</span>.handlerExceptionResolvers.iterator();</span><br><span class="line">        <span class="keyword">while</span>(var6.hasNext()) &#123;</span><br><span class="line">            <span class="comment">//取出每一个异常解析器</span></span><br><span class="line">            <span class="type">HandlerExceptionResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> (HandlerExceptionResolver)var6.next();</span><br><span class="line">            <span class="comment">//执行异常解析器的resolveException方法</span></span><br><span class="line">            exMv = resolver.resolveException(request, response, handler, ex);</span><br><span class="line">            <span class="comment">//只要有一个异常处理器返回ModelAndView 则不在执行后面的异常处理器</span></span><br><span class="line">            <span class="keyword">if</span> (exMv != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; &#125;</span><br><span class="line">    <span class="comment">//如果视图解析器不为null</span></span><br><span class="line">    <span class="keyword">if</span> (exMv != <span class="literal">null</span>) &#123;<span class="keyword">return</span> exMv;</span><br><span class="line">                      &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="keyword">throw</span> ex; &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用的异常解析器"><a href="#常用的异常解析器" class="headerlink" title="常用的异常解析器"></a>常用的异常解析器</h2><p>相关的处理器异常解析器继承体系如下</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231114221809448.png" alt="image-20231114221809448"></p><table><thead><tr><th>接口或类</th><th>说明</th></tr></thead><tbody><tr><td>HandlerExceptionResolver</td><td>异常处理器类的顶级接口，实现了该接口的类都会作为异常处理器类</td></tr><tr><td>MyHandlerExceptionResolver</td><td>自定义的处理器类，实现了HandlerExceptionResolver接口</td></tr><tr><td>HandlerExceptionResolverComposite</td><td>异常解析器混合器，内部存在集合存储多种异常解析器</td></tr><tr><td>SimpleMappingExceptionResolver</td><td>简单映射异常处理器，可以配置异常与对应的错误视图</td></tr><tr><td>ExceptionHandlerExceptionResolver</td><td>异常处理器异常解析器，默认会被注册到Spring容器中，@ExceptionHandler方式 异常处理就是该解析器解析的</td></tr><tr><td>DefaultHandlerExceptionResolver</td><td>默认处理器异常解析器，所有异常处理器都不匹配时，最后执行的异常处理器</td></tr><tr><td>ResponseStatusExceptionResolver</td><td>响应状态异常解析器，结合使用@ResponseStatus标注的异常使用</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM整合</title>
      <link href="/2023/09/18/Spring09SSM%E6%95%B4%E5%90%88/"/>
      <url>/2023/09/18/Spring09SSM%E6%95%B4%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a>SSM整合</h1><h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><ol><li>创建工程<ul><li>创建一个Maven的web工程</li><li>pom.xml添加SSM需要的依赖jar包</li><li>编写Web项目的入口配置类，实现AbstractAnnotationConfigDispatcherServletInitializer重写以下方法<ul><li><code>getRootConfigClasses()</code> ：返回Spring的配置类 –&gt; 需要<code>SpringConfig</code>配置类</li><li><code>getServletConfigClasses()</code> ：返回SpringMVC的配置类 –&gt; 需要<code>SpringMvcConfig</code>配置类</li><li><code>getServletMappings()</code> : 设置SpringMVC请求拦截路径规则</li><li><code>getServletFilters()</code> ：设置过滤器，解决POST请求中文乱码问题</li></ul></li></ul></li><li>SSM整合(重点是各个配置的编写)<ul><li>SpringConfig<ul><li>标识该类为配置类，使用<code>@Configuration</code></li><li>扫描<code>Service</code>所在的包，使用<code>@ComponentScan</code></li><li>在<code>Service</code>层要管理事务，使用<code>@EnableTransactionManagement</code></li><li>读取外部的<code>properties</code>配置文件，使用<code>@PropertySource</code></li><li>整合Mybatis需要引入Mybatis相关配置类，使用@Import<ul><li>第三方数据源配置类 <code>JdbcConfig</code></li><li>构建DataSource数据源，DruidDataSouroce，需要注入数据库连接四要素，使用<code> @Bean</code>、<code>@Value</code></li><li>构建平台事务管理器，DataSourceTransactionManager，使用<code>@Bean</code></li><li>Mybatis配置类 <code>MybatisConfig</code></li><li>构建<code>SqlSessionFactoryBean</code>并设置别名扫描与数据源，使用<code>@Bean</code></li><li>构建<code>MapperScannerConfigurer</code>并设置DAO层的包扫描</li></ul></li></ul></li><li>SpringMvcConfig<ul><li>标识该类为配置类，使用<code>@Configuratio</code></li><li>扫描<code>Controller</code>所在的包，使用<code>@ComponentScan</code></li><li>开启SpringMVC注解支持，使用<code>@EnableWebMvc</code></li></ul></li></ul></li><li>功能模块(与具体的业务模块有关)<ul><li>创建数据库表</li><li>根据数据库表创建对应的模型类</li><li>通过Dao层完成数据库表的增删改查(接口+自动代理)</li><li>编写Service层(Service接口+实现类)<ul><li><code>@Service</code></li><li><code>@Transactional</code></li><li>整合Junit对业务层进行单元测试<ul><li><code>@RunWith</code></li><li><code>@ContextConfiguration</code></li><li><code>@Test</code></li></ul></li></ul></li><li>编写Controller层<ul><li>接收请求 <code>@RequestMapping</code>、<code>@GetMapping</code>、<code>@PostMapping</code>、<code>@PutMapping</code>、<code>@DeleteMapping</code></li><li>接收数据 简单、POJO、嵌套POJO、集合、数组、JSON数据类型<ul><li><code>@RequestParam</code></li><li><code>@PathVariable</code></li><li><code>@RequestBody</code></li></ul></li><li>转发业务层<ul><li><code>@Autowired</code></li></ul></li><li>响应结果<ul><li><code>@ResponseBody</code></li></ul></li></ul></li></ul></li></ol><h2 id="整合配置"><a href="#整合配置" class="headerlink" title="整合配置"></a>整合配置</h2><ol><li><p>创建Maven的web项目</p></li><li><p>导入坐标，配置依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.5.6&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.3.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.1.46&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.1.16&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">        &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.9.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></li><li><p>创建项目包结构</p><ul><li><code>com.blog.config</code>目录存放的是相关的配置类</li><li><code>com.blog.controller</code>编写的是Controller类</li><li><code>com.blog.dao</code>存放的是Dao接口，因为使用的是Mapper接口代理方式，所以没有实现类包</li><li><code>com.blog.service</code>存的是Service接口，<code>com.blog.service.impl</code>存放的是Service实现类</li><li><code>resources</code>:存入的是配置文件，如Jdbc.properties</li><li><code>webapp</code>:目录可以存放静态资源</li><li><code>test/java</code>:存放的是测试类</li></ul></li><li><p>创建jdbc.properties（注意版本差异）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql://localhost:13306/test</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=PASSWORD.</span><br></pre></td></tr></table></figure></li><li><p>创建JdbcConfig配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class JdbcConfig &#123;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span><br><span class="line">    private String driver;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.url&#125;&quot;)</span><br><span class="line">    private String url;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.username&#125;&quot;)</span><br><span class="line">    private String username;</span><br><span class="line">    @Value(&quot;$&#123;jdbc.password&#125;&quot;)</span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource() &#123;</span><br><span class="line">        DruidDataSource dataSource = new DruidDataSource();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        return dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public PlatformTransactionManager platformTransactionManager(DataSource dataSource)&#123;</span><br><span class="line">        DataSourceTransactionManager ds = new DataSourceTransactionManager();</span><br><span class="line">        ds.setDataSource(dataSource);</span><br><span class="line">        return ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建MyBatisConfig配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class MyBatisConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource)&#123;</span><br><span class="line">        SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean();</span><br><span class="line">        factoryBean.setDataSource(dataSource);</span><br><span class="line">        factoryBean.setTypeAliasesPackage(&quot;com.blog.domain&quot;);</span><br><span class="line">        return factoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MapperScannerConfigurer mapperScannerConfigurer()&#123;</span><br><span class="line">        MapperScannerConfigurer msc = new MapperScannerConfigurer();</span><br><span class="line">        msc.setBasePackage(&quot;com.blog.dao&quot;);</span><br><span class="line">        return msc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建SpringConfig配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.blog.service&quot;)</span><br><span class="line">@PropertySource(&quot;jdbc.properties&quot;)</span><br><span class="line">@EnableTransactionManagement</span><br><span class="line">@Import(&#123;JdbcConfig.class, MyBatisConfig.class&#125;)</span><br><span class="line">public class SpringConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建SpringMvcConfig配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.blog.controller&quot;)</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class SpringMvcConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建ServletContainersInitConfig配置类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer &#123;</span><br><span class="line">    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        return new Class[]&#123;SpringConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        return new Class[]&#123;SpringMvcConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected String[] getServletMappings() &#123;</span><br><span class="line">        return new String[]&#123;&quot;/&quot;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Filter[] getServletFilters() &#123;</span><br><span class="line">        CharacterEncodingFilter filter = new CharacterEncodingFilter();</span><br><span class="line">        filter.setEncoding(&quot;utf-8&quot;);</span><br><span class="line">        return new Filter[]&#123;filter&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="功能模块开发"><a href="#功能模块开发" class="headerlink" title="功能模块开发"></a>功能模块开发</h2><p>需求：对表t_book进行新增、修改、删除、根据ID查询和查询所有</p><ol><li><p>创建数据库及表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">create database ssm_db;</span><br><span class="line">use ssm_db;</span><br><span class="line">create table tbl_book</span><br><span class="line">(</span><br><span class="line">    id          int primary key auto_increment,</span><br><span class="line">    type        varchar(20),</span><br><span class="line">    `name`      varchar(50),</span><br><span class="line">    description varchar(255)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">insert into `tbl_book`(`id`, `type`, `name`, `description`)</span><br><span class="line">values (1, &#x27;计算机理论&#x27;, &#x27;Spring实战 第五版&#x27;, &#x27;Spring入门经典教程，深入理解Spring原理技术内幕&#x27;),</span><br><span class="line">       (2, &#x27;计算机理论&#x27;, &#x27;Spring 5核心原理与30个类手写实践&#x27;, &#x27;十年沉淀之作，手写Spring精华思想&#x27;),</span><br><span class="line">       (3, &#x27;计算机理论&#x27;, &#x27;Spring 5设计模式&#x27;, &#x27;深入Spring源码刨析Spring源码中蕴含的10大设计模式&#x27;),</span><br><span class="line">       (4, &#x27;计算机理论&#x27;, &#x27;Spring MVC+Mybatis开发从入门到项目实战&#x27;,</span><br><span class="line">        &#x27;全方位解析面向Web应用的轻量级框架，带你成为Spring MVC开发高手&#x27;),</span><br><span class="line">       (5, &#x27;计算机理论&#x27;, &#x27;轻量级Java Web企业应用实战&#x27;, &#x27;源码级刨析Spring框架，适合已掌握Java基础的读者&#x27;),</span><br><span class="line">       (6, &#x27;计算机理论&#x27;, &#x27;Java核心技术 卷Ⅰ 基础知识(原书第11版)&#x27;,</span><br><span class="line">        &#x27;Core Java第11版，Jolt大奖获奖作品，针对Java SE9、10、11全面更新&#x27;),</span><br><span class="line">       (7, &#x27;计算机理论&#x27;, &#x27;深入理解Java虚拟机&#x27;, &#x27;5个纬度全面刨析JVM,大厂面试知识点全覆盖&#x27;),</span><br><span class="line">       (8, &#x27;计算机理论&#x27;, &#x27;Java编程思想(第4版)&#x27;, &#x27;Java学习必读经典，殿堂级著作！赢得了全球程序员的广泛赞誉&#x27;),</span><br><span class="line">       (9, &#x27;计算机理论&#x27;, &#x27;零基础学Java(全彩版)&#x27;, &#x27;零基础自学编程的入门图书，由浅入深，详解Java语言的编程思想和核心技术&#x27;),</span><br><span class="line">       (10, &#x27;市场营销&#x27;, &#x27;直播就这么做:主播高效沟通实战指南&#x27;, &#x27;李子柒、李佳奇、薇娅成长为网红的秘密都在书中&#x27;),</span><br><span class="line">       (11, &#x27;市场营销&#x27;, &#x27;直播销讲实战一本通&#x27;, &#x27;和秋叶一起学系列网络营销书籍&#x27;),</span><br><span class="line">       (12, &#x27;市场营销&#x27;, &#x27;直播带货:淘宝、天猫直播从新手到高手&#x27;, &#x27;一本教你如何玩转直播的书，10堂课轻松实现带货月入3W+&#x27;);</span><br></pre></td></tr></table></figure></li><li><p>编写模型类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class Book &#123;</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String type;</span><br><span class="line">    private String name;</span><br><span class="line">    private String description;</span><br><span class="line">    </span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getType() &#123;</span><br><span class="line">        return type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setType(String type) &#123;</span><br><span class="line">        this.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDescription() &#123;</span><br><span class="line">        return description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDescription(String description) &#123;</span><br><span class="line">        this.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Book&#123;&quot; +</span><br><span class="line">                &quot;id=&quot; + id +</span><br><span class="line">                &quot;, type=&#x27;&quot; + type + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, description=&#x27;&quot; + description + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写Dao接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public interface BookDao &#123;</span><br><span class="line">    @Insert(&quot;insert into tbl_book values (null, #&#123;type&#125;, #&#123;name&#125;, #&#123;description&#125;)&quot;)</span><br><span class="line">    void save(Book book);</span><br><span class="line"></span><br><span class="line">    @Update(&quot;update tbl_book set type=#&#123;type&#125;, `name`=#&#123;name&#125;, `description`=#&#123;description&#125; where id=#&#123;id&#125;&quot;)</span><br><span class="line">    void update(Book book);</span><br><span class="line"></span><br><span class="line">    @Delete(&quot;delete from tbl_book where id=#&#123;id&#125;&quot;)</span><br><span class="line">    void delete(Integer id);</span><br><span class="line"></span><br><span class="line">    @Select(&quot;select * from tbl_book where id=#&#123;id&#125;&quot;)</span><br><span class="line">    void getById(Integer id);</span><br><span class="line"></span><br><span class="line">    @Select(&quot;select * from tbl_book&quot;)</span><br><span class="line">    void getAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写Service接口及其实现类</p><ul><li><p>Service接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">public interface BookService &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 保存</span><br><span class="line">     * @param book</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    boolean save(Book book);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 修改</span><br><span class="line">     * @param book</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    boolean update(Book book);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 按id删除</span><br><span class="line">     * @param id</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    boolean delete(Integer id);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 按id查询</span><br><span class="line">     * @param id</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    Book getById(Integer id);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 查询所有</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    List&lt;Book&gt; getAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>BookServiceImpl 实现类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class BookServiceImpl implements BookService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    public boolean save(Book book) &#123;</span><br><span class="line">        bookDao.save(book);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean update(Book book) &#123;</span><br><span class="line">        bookDao.update(book);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean delete(@PathVariable Integer id) &#123;</span><br><span class="line">        bookDao.delete(id);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Book getById(Integer id) &#123;</span><br><span class="line">        return bookDao.getById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;Book&gt; getAll() &#123;</span><br><span class="line">        return bookDao.getAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>编写Controller类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/books&quot;)</span><br><span class="line">public class BookController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private BookService bookService;</span><br><span class="line"></span><br><span class="line">    @PostMapping</span><br><span class="line">    public boolean save(@RequestBody Book book) &#123;</span><br><span class="line">        return bookService.save(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PutMapping</span><br><span class="line">    public boolean update(@RequestBody Book book) &#123;</span><br><span class="line">        return bookService.update(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public boolean delete(@PathVariable Integer id) &#123;</span><br><span class="line">        return bookService.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public Book getById(@PathVariable Integer id) &#123;</span><br><span class="line">        return bookService.getById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping</span><br><span class="line">    public List&lt;Book&gt; getAll() &#123;</span><br><span class="line">        return bookService.getAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><ol><li><p>新建测试类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(classes = SpringConfig.class)</span><br><span class="line">public class BookServiceTest &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注入Service</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(classes = SpringConfig.class)</span><br><span class="line">public class BookServiceTest &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private BookService bookService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写测试方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(classes = SpringConfig.class)</span><br><span class="line">public class BookServiceTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private BookService bookService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testGetById() &#123;</span><br><span class="line">        Book book = bookService.getById(1);</span><br><span class="line">        System.out.println(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testGetAll() &#123;</span><br><span class="line">        for (Book book : bookService.getAll()) &#123;</span><br><span class="line">            System.out.println(book);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试方法，可以查询到对应的数据</p></li></ol><h1 id="统一结果封装"><a href="#统一结果封装" class="headerlink" title="统一结果封装"></a>统一结果封装</h1><h2 id="表现层与前端数据传输协议定义"><a href="#表现层与前端数据传输协议定义" class="headerlink" title="表现层与前端数据传输协议定义"></a>表现层与前端数据传输协议定义</h2><p>SSM整合以及功能模块开发完成后，接下来我们在上述案例的基础上，分析一下有哪些问题需要我们解决。</p><p>在Controller层增删改操作完成后，返回给前端的是boolean类型的数据：true</p><p>在Controller层查询单个，返回给前端的是对象</p><p>在Controller层查询所有，返回给前端的是集合对象</p><p>目前我们就已经有<code>三种数据类型</code>返回给前端了，随着业务的增长，我们需要返回的数据类型就会<code>越来越多</code>。那么前端开发人员在解析数据的时候就比较<code>凌乱</code>了，所以对于前端来说，如果后端能返回一个<code>统一的数据结果</code>，前端在解析的时候就可以按照一种方式进行解析，开发就会变得更加简单</p><p>所以现在我们需要解决的问题就是<code>如何将返回的结果数据进行统一</code>，具体如何来做，大体思路如下</p><ul><li><p>为了封装返回的结果数据：创建结果模型类，封装数据到data属性中</p><blockquote><p>我们可以设置data的数据类型为<code>Object</code>，这样data中就可以放任意的结果类型了，包括但不限于上面的<code>boolean</code>、<code>对象</code>、<code>集合对象</code></p></blockquote></li><li><p>为了封装返回的数据是何种操作，以及是否操作成功：封装操作结果到code属性中</p><blockquote><p>例如增删改操作返回的都是<code>true</code>，那我们怎么分辨这个<code>true</code>到底是<code>增</code>还是<code>删</code>还是<code>改</code>呢？我们就通过这个<code>code</code>来区分</p></blockquote><blockquote><p>操作失败后，需要封装返回错误信息提示给用户：封装特殊消息到message(msg)属性中</p></blockquote><p>例如查询或删除的目标不存在，会返回null，那么此时我们需要提示<code>查询/删除的目标不存在，请重试！</code></p></li></ul><p>那么之前的三种返回方式就可以变为如下形式</p><div class="tabs" id="1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#1-1">boolean</button></li><li class="tab"><button type="button" data-href="#1-2">对象</button></li><li class="tab"><button type="button" data-href="#1-3">集合</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><p>规则可以自己定<br>这里前三位是固定的<br>第四位表示不同的操作<br>末位表示成功&#x2F;失败，1成功，0失败</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="number">20011</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-2"><p>这里的末尾是0，表示失败操作<br>第四位是2，区别于上面的1，表示是不同的操作类型<br>msg给用户提示信息，不是必有项</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="number">20020</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span><span class="string">&quot;数据查询失败，请重试！&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-3"><p>这里末尾操作是1，表示成功操作<br>data中显示的是对象集合<br>没有msg</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="number">20031</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;计算机理论&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Spring实战 第5版&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;Spring入门经典教程&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;计算机理论&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Spring 5核心原理与30个类手写实战&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;十年沉淀之作&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>根据分析，我们可以设置统一数据返回结果类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span>&#123;</span><br><span class="line"><span class="keyword">private</span> Object data;</span><br><span class="line"><span class="keyword">private</span> Integer code;</span><br><span class="line"><span class="keyword">private</span> String msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：Result类名及类中的字段并不是固定的，可以根据需要自行增减提供若干个构造方法，方便操作。</p><h2 id="表现层与前端数据传输协议实现"><a href="#表现层与前端数据传输协议实现" class="headerlink" title="表现层与前端数据传输协议实现"></a>表现层与前端数据传输协议实现</h2><p>前面我们已经分析了如何封装返回结果数据，现在我们来具体实现一下</p><p>对于结果封装，我们应该是在表现层进行处理，所以我们把结果类放在controller包下，当然你也可以放在domain包，这个都是可以的，具体如何实现结果封装，具体的步骤如下</p><ol><li><p>创建Result类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public class Result &#123;</span><br><span class="line">    //描述统一格式中的编码，用于区分操作，可以简化配置0或1表示成功失败</span><br><span class="line">    private Integer code;</span><br><span class="line">    //描述统一格式中的数据</span><br><span class="line">    private Object data;</span><br><span class="line">    //描述统一格式中的消息，可选属性</span><br><span class="line">    private String msg;</span><br><span class="line"></span><br><span class="line">    public Result() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //构造器可以根据自己的需要来编写</span><br><span class="line">    public Result(Integer code, Object data) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Result(Integer code, Object data, String msg) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">        this.data = data;</span><br><span class="line">        this.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getCode() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCode(Integer code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object getData() &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setData(Object data) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getMsg() &#123;</span><br><span class="line">        return msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMsg(String msg) &#123;</span><br><span class="line">        this.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Result&#123;&quot; +</span><br><span class="line">                &quot;code=&quot; + code +</span><br><span class="line">                &quot;, data=&quot; + data +</span><br><span class="line">                &quot;, msg=&#x27;&quot; + msg + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>定义返回码Code类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Code &#123;</span><br><span class="line">    public static final Integer SAVE_OK = 20011;</span><br><span class="line">    public static final Integer UPDATE_OK = 20021;</span><br><span class="line">    public static final Integer DELETE_OK = 20031;</span><br><span class="line">    public static final Integer GET_OK = 20041;</span><br><span class="line">    </span><br><span class="line">    public static final Integer SAVE_ERR = 20010;</span><br><span class="line">    public static final Integer UPDATE_ERR = 20020;</span><br><span class="line">    public static final Integer DELETE_ERR = 20030;</span><br><span class="line">    public static final Integer GET_ERR = 20040;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：code类中的常量设计也不是固定的，可以根据需要自行增减，例如将查询再进行细分为<code>GET_OK</code>，<code>GET_ALL_OK</code>，<code>GET_PAGE_OK</code>等。</p></li><li><p>修改Controller类的返回值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/books&quot;)</span><br><span class="line">public class BookController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private BookService bookService;</span><br><span class="line"></span><br><span class="line">    @PostMapping</span><br><span class="line">    public Result save(@RequestBody Book book) &#123;</span><br><span class="line">        boolean flag = bookService.save(book);</span><br><span class="line">        return new Result(flag ? Code.SAVE_OK : Code.SAVE_ERR, flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PutMapping</span><br><span class="line">    public Result update(@RequestBody Book book) &#123;</span><br><span class="line">        boolean flag = bookService.update(book);</span><br><span class="line">        return new Result(flag ? Code.UPDATE_OK : Code.UPDATE_ERR, flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public Result delete(@PathVariable Integer id) &#123;</span><br><span class="line">        boolean flag = bookService.delete(id);</span><br><span class="line">        return new Result(flag ? Code.DELETE_OK : Code.DELETE_ERR, flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public Result getById(@PathVariable Integer id) &#123;</span><br><span class="line">        Book book = bookService.getById(id);</span><br><span class="line">        Integer code = book == null ? Code.GET_ERR : Code.GET_OK;</span><br><span class="line">        String msg = book == null ? &quot;数据查询失败，请重试！&quot; : &quot;&quot;;</span><br><span class="line">        return new Result(code, book, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping</span><br><span class="line">    public Result getAll() &#123;</span><br><span class="line">        List&lt;Book&gt; bookList = bookService.getAll();</span><br><span class="line">        Integer code = bookList == null ? Code.GET_ERR : Code.GET_OK;</span><br><span class="line">        String msg = bookList == null ? &quot;数据查询失败，请重试！&quot; : &quot;&quot;;</span><br><span class="line">        return new Result(code, bookList, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动服务测试<br>五个方法的测试结果如下</p><div class="tabs" id="2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2-1">save</button></li><li class="tab"><button type="button" data-href="#2-2">update</button></li><li class="tab"><button type="button" data-href="#2-3">delete</button></li><li class="tab"><button type="button" data-href="#2-4">getById</button></li><li class="tab"><button type="button" data-href="#2-5">getAll</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 20011,</span><br><span class="line">    &quot;data&quot;: true,</span><br><span class="line">    &quot;msg&quot;: null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 20021,</span><br><span class="line">    &quot;data&quot;: true,</span><br><span class="line">    &quot;msg&quot;: null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2-3"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 20031,</span><br><span class="line">    &quot;data&quot;: true,</span><br><span class="line">    &quot;msg&quot;: null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2-4"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 20041,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;id&quot;: 1,</span><br><span class="line">        &quot;type&quot;: &quot;计算机理论&quot;,</span><br><span class="line">        &quot;name&quot;: &quot;Spring实战 第五版&quot;,</span><br><span class="line">        &quot;description&quot;: &quot;Spring入门经典教程，深入理解Spring原理技术内幕&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;msg&quot;: &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2-5"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 20041,</span><br><span class="line">    &quot;data&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 1,</span><br><span class="line">            &quot;type&quot;: &quot;计算机理论&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;Spring实战 第五版&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;Spring入门经典教程，深入理解Spring原理技术内幕&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 2,</span><br><span class="line">            &quot;type&quot;: &quot;计算机理论&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;Spring 5核心原理与30个类手写实践&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;十年沉淀之作，手写Spring精华思想&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 3,</span><br><span class="line">            &quot;type&quot;: &quot;计算机理论&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;Spring 5设计模式&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;深入Spring源码刨析Spring源码中蕴含的10大设计模式&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 4,</span><br><span class="line">            &quot;type&quot;: &quot;计算机理论&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;Spring MVC+Mybatis开发从入门到项目实战&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;全方位解析面向Web应用的轻量级框架，带你成为Spring MVC开发高手&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 5,</span><br><span class="line">            &quot;type&quot;: &quot;计算机理论&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;轻量级Java Web企业应用实战&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;源码级刨析Spring框架，适合已掌握Java基础的读者&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 6,</span><br><span class="line">            &quot;type&quot;: &quot;计算机理论&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;Java核心技术 卷Ⅰ 基础知识(原书第11版)&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;Core Java第11版，Jolt大奖获奖作品，针对Java SE9、10、11全面更新&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 7,</span><br><span class="line">            &quot;type&quot;: &quot;计算机理论&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;深入理解Java虚拟机&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;5个纬度全面刨析JVM,大厂面试知识点全覆盖&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 8,</span><br><span class="line">            &quot;type&quot;: &quot;计算机理论&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;Java编程思想(第4版)&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;Java学习必读经典，殿堂级著作！赢得了全球程序员的广泛赞誉&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 9,</span><br><span class="line">            &quot;type&quot;: &quot;计算机理论&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;零基础学Java(全彩版)&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;零基础自学编程的入门图书，由浅入深，详解Java语言的编程思想和核心技术&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 10,</span><br><span class="line">            &quot;type&quot;: &quot;市场营销&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;直播就这么做:主播高效沟通实战指南&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;李子柒、李佳奇、薇娅成长为网红的秘密都在书中&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 11,</span><br><span class="line">            &quot;type&quot;: &quot;市场营销&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;直播销讲实战一本通&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;和秋叶一起学系列网络营销书籍&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 12,</span><br><span class="line">            &quot;type&quot;: &quot;市场营销&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;直播带货:淘宝、天猫直播从新手到高手&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;一本教你如何玩转直播的书，10堂课轻松实现带货月入3W+&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 14,</span><br><span class="line">            &quot;type&quot;: &quot;类别测试数据&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;书名测试数据9527&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;描述测试数据&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 15,</span><br><span class="line">            &quot;type&quot;: &quot;类别测试数据&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;书名测试数据&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;描述测试数据&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: 16,</span><br><span class="line">            &quot;type&quot;: &quot;类别测试数据&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;书名测试数据&quot;,</span><br><span class="line">            &quot;description&quot;: &quot;描述测试数据&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;msg&quot;: &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></li></ol><h1 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h1><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>先人为弄一个异常出来</p><p>修改<code>BookController</code>的<code>getById()</code>方法，手写一个异常</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">public Result getById(@PathVariable Integer id) &#123;</span><br><span class="line">    //当id为1的时候，手动添加了一个错误信息</span><br><span class="line">    if (id == 1)&#123;</span><br><span class="line">        int a = 1 / 0;</span><br><span class="line">    &#125;</span><br><span class="line">    Book book = bookService.getById(id);</span><br><span class="line">    Integer code = book == null ? Code.GET_ERR : Code.GET_OK;</span><br><span class="line">    String msg = book == null ? &quot;数据查询失败，请重试！&quot; : &quot;&quot;;</span><br><span class="line">    return new Result(code, book, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新启动服务器，使用<code>PostMan</code>发送请求，当传入的<code>id为1</code>时，会出现如下效果</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310201941126.png"></p><p>前端接收到这个信息后，和我们之前约定的格式不一致，怎么解决呢？</p><h2 id="异常的种类"><a href="#异常的种类" class="headerlink" title="异常的种类"></a>异常的种类</h2><p>在解决问题之前，我们先来看一下异常的种类，以及出现异常的原因：</p><ul><li>框架内部抛出的异常：因<code>使用不合规</code>导致</li><li>数据层抛出的异常：因使用<code>外部服务器故障</code>导致（例如：服务器访问超时）</li><li>业务层抛出的异常：因<code>业务逻辑书写错误</code>导致（例如：遍历业务书写操作，导致索引越界异常等）</li><li>表现层抛出的异常：因<code>数据收集</code>、<code>校验</code>等规则导致（例如：不匹配的数据类型间转换导致异常）</li><li>工具类抛出的异常：因工具类<code>书写不严谨</code>，<code>健壮性不足</code>导致（例如：必要时放的连接，长时间未释放等）</li></ul><p>了解完上面这些出现<code>异常的位置</code>，我们发现，在我们开发的<code>任何一个位置</code>都可能会出现异常，而且这些异常是<code>不能避免的</code>，所以我们就需要对这些异常来<code>进行处理</code>。</p><ol><li>各个层级均出现异常，那么异常处理代码要写在哪一层？<ul><li>所有的异常均抛出到表现层进行处理</li></ul></li><li>异常的种类很多，表现层如何将所有的异常都处理到呢？<ul><li>异常分类</li></ul></li><li>表现层处理异常，每个方法中单独书写，代码书写两巨大，且意义不强，如何解决呢？<ul><li>AOP</li></ul></li></ol><p>对于上面这些问题以及解决方案，SpringMVC已经为我们提供了一套了：<strong>异常处理器</strong></p><p>异常处理器：集中的、统一的处理项目中出现的异常</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RestControllerAdvice</span><br><span class="line">public class ProjectExceptionAdvice &#123;</span><br><span class="line">    @ExceptionHandler(Exception.class)</span><br><span class="line">    public Result doException(Exception ex) &#123;</span><br><span class="line">        return new Result(666, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常处理器的使用"><a href="#异常处理器的使用" class="headerlink" title="异常处理器的使用"></a>异常处理器的使用</h2><ol><li><p>创建异常处理器类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RestControllerAdvice</span><br><span class="line">public class ProjectExceptionAdvice &#123;</span><br><span class="line">    @ExceptionHandler(Exception.class)</span><br><span class="line">    public void doException(Exception ex) &#123;</span><br><span class="line">        System.out.println(&quot;嘿嘿，逮到一个异常~&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：要确保SpringMvcConfig能够扫描到异常处理器类，之前放controller包里面就顺带一起扫了</p></li><li><p>让程序抛出异常</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">public Result getById(@PathVariable Integer id) &#123;</span><br><span class="line">    //当id为1的时候，手动添加了一个错误信息</span><br><span class="line">    if (id == 1)&#123;</span><br><span class="line">        int a = 1 / 0;</span><br><span class="line">    &#125;</span><br><span class="line">    Book book = bookService.getById(id);</span><br><span class="line">    Integer code = book == null ? Code.GET_ERR : Code.GET_OK;</span><br><span class="line">    String msg = book == null ? &quot;数据查询失败，请重试！&quot; : &quot;&quot;;</span><br><span class="line">    return new Result(code, book, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>PostMan</code>发送<code>GET</code>请求访问<code>localhost:8080/books/1</code><br>控制台输出如下，说明异常已经被拦截，且执行了<code>doException()</code>方法</p><p>但是现在没有返回数据给前端，为了统一返回结果，我们继续修改异常处理器类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@RestControllerAdvice</span><br><span class="line">public class ProjectExceptionAdvice &#123;</span><br><span class="line">    @ExceptionHandler(Exception.class)</span><br><span class="line">    public Result doException(Exception ex) &#123;</span><br><span class="line">        System.out.println(&quot;有一个异常&quot;);</span><br><span class="line">        return new Result(666, null, &quot;有一个异常&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启服务器，使用PostMan发送请求，此时就能接收到结果了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 666,</span><br><span class="line">    &quot;data&quot;: null,</span><br><span class="line">    &quot;msg&quot;: &quot;有一个异常&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>知识点：<code>@RestControllerAdvice</code></p><p>说明：此注解自带<code>@ResponseBody</code>注解与<code>@Component</code>注解，具备对应的功能</p><table><thead><tr><th align="center">名称</th><th align="center">@RestControllerAdvice</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">类注解</td></tr><tr><td align="center">位置</td><td align="center">Rest风格开发的控制器增强类定义上方</td></tr><tr><td align="center">作用</td><td align="center">为Rest风格开发的控制器类做增强</td></tr></tbody></table><p>知识点：<code>@ExceptionHandler</code></p><p>说明：此类方法可以根据处理的异常不同，制作多个方法分别处理对应的异常</p><table><thead><tr><th align="center">名称</th><th align="center">@ExceptionHandler</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">方法注解</td></tr><tr><td align="center">位置</td><td align="center">专用于异常处理的控制器方法上方</td></tr><tr><td align="center">作用</td><td align="center">设置指定异常的处理方案，功能等同于控制器方法， 出现异常后终止原始控制器执行,并转入当前方法执行</td></tr></tbody></table><h2 id="项目异常处理方案"><a href="#项目异常处理方案" class="headerlink" title="项目异常处理方案"></a>项目异常处理方案</h2><p>异常处理器我们已经能够使用了，那么我们如何在项目中来处理异常呢?</p><h3 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h3><p>因为异常的种类有很多，如果每一个异常都对应一个<code>@ExceptionHandler</code>，那得写多少个方法来处理各自的异常，所以我们在处理异常之前，需要对异常进行一个分类:</p><p>将异常分类以后，针对不同类型的异常，要提供具体的解决方案</p><div class="tabs" id="3"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#3-1">业务异常</button></li><li class="tab"><button type="button" data-href="#3-2">业务异常</button></li><li class="tab"><button type="button" data-href="#3-3">其他异常</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="3-1"><p>规范的用户行为产生的异常</p><ul><li>用户在页面输入内容的时候未按照指定格式进行数据填写，如在年龄框输入的是字符串</li></ul><p>不规范的用户行为操作产生的异常</p><ul><li>如用户手改URL，故意传递错误数据<code>localhost:8080/books/略略略</code></li></ul><p>异常解决方案</p><ul><li>发送对应消息传递给用户，提醒规范操作<ul><li>大家常见的就是提示用户名已存在或密码格式不正确等</li></ul></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3-2"><p>项目运行过程中可预计，但无法避免的异常</p><ul><li>如服务器宕机</li></ul><p>异常解决方案</p><ul><li>发送固定消息传递给用户，安抚用户<ul><li>系统繁忙，请稍后再试</li><li>系统正在维护升级，请稍后再试</li><li>系统出问题，请联系系统管理员等</li></ul></li><li>发送特定消息给运维人员，提醒维护<ul><li>可以发送短信、邮箱或者是公司内部通信软件</li></ul></li><li>记录日志<ul><li>发消息给运维和记录日志对用户来说是不可见的，属于后台程序</li></ul></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3-3"><p>编程人员未预期到的异常</p><ul><li>如：系统找不到指定文件</li></ul><p>异常解决方案</p><ul><li>发送固定消息传递给用户，安抚用户</li><li>发送特定消息给编程人员，提醒维护（纳入预期范围内）<ul><li>一般是程序没有考虑全，比如未做非空校验等</li></ul></li><li>记录日志</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>思路:</p><ol><li>先通过自定义异常，完成BusinessException和SystemException的定义</li><li>将其他异常包装成自定义异常类型</li><li>在异常处理器类中对不同的异常进行处理</li></ol><p>实现：</p><ol><li><p>自定义异常类</p><div class="tabs" id="4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#4-1">SystemException</button></li><li class="tab"><button type="button" data-href="#4-2">BusinessException</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="4-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class SystemException extends RuntimeException &#123;</span><br><span class="line">    private Integer code;</span><br><span class="line"></span><br><span class="line">    public Integer getCode() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCode(Integer code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SystemException() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SystemException(Integer code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SystemException(Integer code, String message) &#123;</span><br><span class="line">        super(message);</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SystemException(Integer code, String message, Throwable cause) &#123;</span><br><span class="line">        super(message, cause);</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="4-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class BusinessException extends RuntimeException&#123;</span><br><span class="line">    private Integer code;</span><br><span class="line"></span><br><span class="line">    public Integer getCode() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCode(Integer code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BusinessException() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BusinessException(Integer code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BusinessException(Integer code, String message) &#123;</span><br><span class="line">        super(message);</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public BusinessException(Integer code, String message, Throwable cause) &#123;</span><br><span class="line">        super(message, cause);</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>说明：</p><ul><li>让自定义异常类继承<code>RuntimeException</code>的好处是，后期在抛出这两个异常的时候，就不用在<code>try..catch..</code>或<code>throws</code>了</li><li>自定义异常类中添加<code>code</code>属性的原因是为了更好的区分异常是来自哪个业务的</li></ul></li><li><p>将其他异常包成自定义异常</p><p>假如在<code>BookServiceImpl</code>的<code>getById</code>方法抛异常了，该如何来包装呢?</p><p>具体的包装方式有：</p><ol><li><code>try&#123;&#125;catch()&#123;&#125;</code>在catch中重新throw我们自定义异常即可。</li><li>直接<code>throw</code>自定义异常即可</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public Book getById(Integer id) &#123;</span><br><span class="line">    //模拟业务异常，包装成自定义异常</span><br><span class="line">    if(id == 1)&#123;</span><br><span class="line">        throw new BusinessException(Code.BUSINESS_ERR,&quot;你别给我乱改URL噢&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //模拟系统异常，将可能出现的异常进行包装，转换成自定义异常</span><br><span class="line">    try&#123;</span><br><span class="line">        int i = 1/0;</span><br><span class="line">    &#125;catch (Exception e)&#123;</span><br><span class="line">        throw new SystemException(Code.SYSTEM_TIMEOUT_ERR,&quot;服务器访问超时，请重试!&quot;,e);</span><br><span class="line">    &#125;</span><br><span class="line">    return bookDao.getById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面为了使<code>code</code>看着更专业些，我们在Code类中再新增需要的属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Code &#123;</span><br><span class="line">    public static final Integer SAVE_OK = 20011;</span><br><span class="line">    public static final Integer UPDATE_OK = 20021;</span><br><span class="line">    public static final Integer DELETE_OK = 20031;</span><br><span class="line">    public static final Integer GET_OK = 20041;</span><br><span class="line"></span><br><span class="line">    public static final Integer SAVE_ERR = 20010;</span><br><span class="line">    public static final Integer UPDATE_ERR = 20020;</span><br><span class="line">    public static final Integer DELETE_ERR = 20030;</span><br><span class="line">    public static final Integer GET_ERR = 20040;</span><br><span class="line"></span><br><span class="line">    public static final Integer SYSTEM_ERR = 50001;</span><br><span class="line">    public static final Integer SYSTEM_TIMEOUT_ERR = 50002;</span><br><span class="line">    public static final Integer SYSTEM_UNKNOW_ERR = 59999;</span><br><span class="line"></span><br><span class="line">    public static final Integer BUSINESS_ERR = 60001;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>处理器类中处理自定义异常</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@RestControllerAdvice</span><br><span class="line">public class ProjectExceptionAdvice &#123;</span><br><span class="line">    @ExceptionHandler(SystemException.class)</span><br><span class="line">    public Result doSystemException(SystemException ex) &#123;</span><br><span class="line">        return new Result(ex.getCode(), null, ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ExceptionHandler(BusinessException.class)</span><br><span class="line">    public Result doBusinessException(BusinessException ex) &#123;</span><br><span class="line">        return new Result(ex.getCode(), null, ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ExceptionHandler(Exception.class)</span><br><span class="line">    public Result doException(Exception ex) &#123;</span><br><span class="line">        return new Result(Code.SYSTEM_UNKNOW_ERR, null, &quot;系统繁忙，请稍后再试！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行程序<br>根据ID查询，如果传入的参数为1，会报<code>BusinessException</code></p><p>如果传入的是其他参数，会报<code>SystemException</code>，错误信息应为<code>服务器访问超时，请重试!</code></p><p>那么对于异常我们就已经处理完成了，不管后台哪一层抛出异常，都会以我们与前端约定好的方式进行返回，前端只需要把信息获取到，根据返回的正确与否来展示不同的内容即可。</p></li></ol><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310202001983.png"></p><h1 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h1><h2 id="拦截器概念"><a href="#拦截器概念" class="headerlink" title="拦截器概念"></a>拦截器概念</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310202002007.png"></p><ol><li>浏览器发送一个请求，会先到Tomcat服务器的web服务器</li><li>Tomcat服务器接收到请求后，会先去判断请求的是<code>静态资源</code>还是<code>动态资源</code></li><li>如果是静态资源，会直接到Tomcat的项目部署目录下直接访问</li><li>如果是动态资源，就需要交给项目的后台代码进行处理</li><li>在找到具体的方法之前，我们可以去配置过滤器（可以配置多个），按照顺序进行执行（在这里就可以进行权限校验）</li><li>然后进入到中央处理器（SpringMVC中的内容），SpringMVC会根据配置的规则进行拦截</li><li>如果满足规则，则进行处理，找到其对应的<code>Controller</code>类中的方法进行之星，完成后返回结果</li><li>如果不满足规则，则不进行处理</li><li>这个时候，如果我们需要在每个Controller方法执行的前后添加业务，具体该如何来实现？<ul><li>这个就是拦截器要做的事</li></ul></li></ol><p>拦截器（Interceptor）是一种动态拦截方法调用的机制，在SpringMVC中动态拦截控制器方法的</p><ul><li><p>作用：</p><ul><li><p>在指定的方法调用前后执行预先设定的代码</p></li><li><p>阻止原始方法的执行</p></li><li><p><code>总结：</code>拦截器就是用来作增强</p></li></ul></li><li><p>但是这个拦截器貌似跟我们之前学的过滤器很像啊，不管是从作用上来看还是从执行顺序上来看</p><ul><li>那么拦截器和过滤器之间的区别是什么呢？<ul><li><code>归属不同：</code>Filter属于Servlet技术，而Interceptor属于SpringMVC技术</li><li><code>拦截内容不同：</code>Filter对所有访问进行增强，Interceptor仅对SpringMVC的访问进行增强</li></ul></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310202003631.png"></p><h2 id="拦截器入门案例"><a href="#拦截器入门案例" class="headerlink" title="拦截器入门案例"></a>拦截器入门案例</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ol><li><p>创建一个Web的Maven项目</p></li><li><p>导入坐标</p><p>SpringMvcConfig</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.blog.controller&quot;)</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class SpringMvcConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServletContainersInitConfig</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer &#123;</span><br><span class="line"></span><br><span class="line">    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        return new Class[0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        return new Class[]&#123;SpringMvcConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected String[] getServletMappings() &#123;</span><br><span class="line">        return new String[]&#123;&quot;/&quot;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Filter[] getServletFilters() &#123;</span><br><span class="line">        CharacterEncodingFilter filter = new CharacterEncodingFilter();</span><br><span class="line">        filter.setEncoding(&quot;utf-8&quot;);</span><br><span class="line">        return new Filter[]&#123;filter&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写Controller类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/books&quot;)</span><br><span class="line">public class BookController &#123;</span><br><span class="line"></span><br><span class="line">    @PostMapping</span><br><span class="line">    public String save(@RequestBody Book book)&#123;</span><br><span class="line">        System.out.println(&quot;book save ..&quot; + book);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;book save&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public String delete(@PathVariable Integer id)&#123;</span><br><span class="line">        System.out.println(&quot;book delete ..&quot; + id);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;book delete&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PutMapping</span><br><span class="line">    public String update(@RequestBody Book book)&#123;</span><br><span class="line">        System.out.println(&quot;book update ..&quot; + book);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;book update&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">    public String getById(@PathVariable Integer id)&#123;</span><br><span class="line">        System.out.println(&quot;book getById ..&quot; + id);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;book getById&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping</span><br><span class="line">    public String getAll()&#123;</span><br><span class="line">        System.out.println(&quot;book getAll ..&quot;);</span><br><span class="line">        return &quot;&#123;&#x27;module&#x27;:&#x27;book getAll&#x27;&#125;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用PostMan测试，没有问题的话就可以继续往下看了</p></li></ol><h2 id="拦截器开发"><a href="#拦截器开发" class="headerlink" title="拦截器开发"></a>拦截器开发</h2><ol><li><p>创建拦截器类<br>在<code>com.blog.controller.interceptor</code>下创建<code>ProjectInterceptor</code>类，实现<code>HandlerInterceptor</code>接口，并重写其中的三个方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">//注意当前类必须受Spring容器控制</span><br><span class="line">public class ProjectInterceptor implements HandlerInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    //原始方法调用前执行的内容</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;preHandle&quot;);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //原始方法调用后执行的内容</span><br><span class="line">    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;postHandle&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //原始方法调用完成后执行的内容</span><br><span class="line">    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;afterCompletion&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置拦截器类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class SpringMvcSupport extends WebMvcConfigurationSupport &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ProjectInterceptor projectInterceptor;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">        registry.addResourceHandler(&quot;/pages/**&quot;).addResourceLocations(&quot;/pages/&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        //配置拦截器,拦截路径是/books，只会拦截/books，拦截不到/books/1</span><br><span class="line">        registry.addInterceptor(projectInterceptor).addPathPatterns(&quot;/books&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>SpringMvc添加SpringMvcSupport包扫描</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&#123;&quot;com.blog.controller&quot;, &quot;com.blog.config&quot;&#125;)</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class SpringMvcConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行程序测试</p><p>使用PostMan发送请求给<code>localhost:8080/books</code>，控制台输出如下，说明已经成功拦截</p><blockquote><p>preHandle<br>book update …Book{书名&#x3D;‘书名测试数据9527’, 价格&#x3D;0.0}<br>postHandle<br>afterCompletion</p></blockquote><p>使用PostMan发送请求给<code>localhost:8080/books/9527</code>，控制台输出如下，说明没有拦截，若想拦截，则继续修改拦截器的拦截规则</p><blockquote><p>book getById …9527</p></blockquote></li><li><p>修改拦截器拦截规则</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class SpringMvcSupport extends WebMvcConfigurationSupport &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ProjectInterceptor projectInterceptor;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">        registry.addResourceHandler(&quot;/pages/**&quot;).addResourceLocations(&quot;/pages/&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        //配置拦截器，查看源码发现，参数是个可变形参，可以设置任意多个拦截路径</span><br><span class="line">        registry.addInterceptor(projectInterceptor).addPathPatterns(&quot;/books&quot;,&quot;/books/*&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们再次使用PostMan发送请求给<code>localhost:8080/books/9527</code>，控制台输出如下，说明已经成功拦截</p><blockquote><p>preHandle<br>book getById …9527<br>postHandle<br>afterCompletion</p></blockquote><p><strong>就是拦截器中的<code>preHandler</code>方法，如果返回true，则代表放行，会执行原始<code>Controller</code>类中要请求的方法，如果返回<code>false</code>，则代表拦截，后面的就不会再执行了。</strong> </p></li><li><p>简化SpringMvcSupport的编写</p><p>我们可以让<code>SpringMvcConfig</code>类实现<code>WebMvcConfigurer</code>接口，然后直接在<code>SpringMvcConfig</code>中写<code>SpringMvcSupport</code>的东西，这样我们就不用再写<code>SpringMvcSupport</code>类了，全都在<code>SpringMvcConfig</code>中写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;com.blog.controller&quot;)</span><br><span class="line">@EnableWebMvc</span><br><span class="line">//实现WebMvcConfigurer接口可以简化开发，但具有一定的侵入性</span><br><span class="line">public class SpringMvcConfig implements WebMvcConfigurer &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private ProjectInterceptor projectInterceptor;</span><br><span class="line"></span><br><span class="line">    public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">        //对静态资源放行</span><br><span class="line">        registry.addResourceHandler(&quot;/pages/**&quot;).addResourceLocations(&quot;/pages/&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        //配置拦截器</span><br><span class="line">        registry.addInterceptor(projectInterceptor).addPathPatterns(&quot;/books&quot;, &quot;/books/*&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="拦截器的执行流程"><a href="#拦截器的执行流程" class="headerlink" title="拦截器的执行流程"></a>拦截器的执行流程</h3><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310202024542.png"></p><p>当有拦截器后，请求会先进入preHandle方法</p><ul><li>如果方法返回<code>true</code>，则放行继续执行后面的handle(Controller的方法)和后面的方法</li><li>如果返回<code>false</code>，则直接跳过后面方法的执行。</li></ul><h2 id="拦截器参数"><a href="#拦截器参数" class="headerlink" title="拦截器参数"></a>拦截器参数</h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>原始方法之前运行preHandle</p><div class="tabs" id="5"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#5-1">前置处理方法</button></li><li class="tab"><button type="button" data-href="#5-2">后置处理方法</button></li><li class="tab"><button type="button" data-href="#5-3">完成处理方法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="5-1"><p>原始方法之前运行preHandle</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">    System.out.println(&quot;preHandle&quot;);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>request:</code>请求对象</li><li><code>response:</code>响应对象</li><li><code>handler:</code>被调用的处理器对象，本质上是一个方法对象，对反射中的Method对象进行了再包装</li></ul><p>使用request对象可以获取请求数据中的内容，如获取请求头的<code>Content-Type</code>，成功输出了Content-Type<code>application/json</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">    String name = request.getHeader(&quot;Content-Type&quot;);</span><br><span class="line">    System.out.println(&quot;preHandle..&quot; + name);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用handler参数，可以获取方法的相关信息，成功输出了方法名<code>save</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line">    HandlerMethod handlerMethod = (HandlerMethod) handler;</span><br><span class="line">    String methodName = handlerMethod.getMethod().getName();</span><br><span class="line">    System.out.println(&quot;preHandle..&quot; + methodName);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5-2"><p>原始方法运行后运行，如果原始方法被拦截，则不执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//原始方法调用后执行的内容</span><br><span class="line">public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;</span><br><span class="line">    System.out.println(&quot;postHandle&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前三个参数和上面的是一致的。<br><code>modelAndView:</code>如果处理器执行完成具有返回结果，可以读取到对应数据与页面信息，并进行调整<br>因为我们现在都是返回json数据，所以该参数的使用率不高。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5-3"><p>拦截器最后执行的方法，无论原始方法是否执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//原始方法调用完成后执行的内容</span><br><span class="line">public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;</span><br><span class="line">    System.out.println(&quot;afterCompletion&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前三个参数与上面的是一致的。但是有第四个参数ex</p><p>ex：如果处理器执行过程中出现异常对象，可以针对异常情况进行单独处理</p><p>因为我们现在已经有全局异常处理器类，所以该参数的使用率也不高。</p><p>这三个方法中，最常用的是<code>preHandle</code>，在这个方法中可以通过返回值来决定是否要进行放行，我们可以把业务逻辑放在该方法中，如果满足业务则返回<code>true</code>放行，不满足则返回<code>false</code>拦截。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="拦截器链配置"><a href="#拦截器链配置" class="headerlink" title="拦截器链配置"></a>拦截器链配置</h2><p>目前，我们在项目中只添加了一个拦截器，如果有多个，该如何配置?配置多个后，执行顺序是什么?</p><ul><li>当配置多个拦截器时，形成拦截器链</li><li>拦截器链的运行顺序参照拦截器添加顺序为准</li><li>当拦截器中出现对原始处理器的拦截，后面的拦截器均终止运行</li><li>当拦截器运行中断，仅运行配置在前面的拦截器的afterCompletion操作</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310202029609.png"></p><ul><li><code>preHandle：</code>与配置顺序相同，必定运行</li><li><code>postHandle:</code>与配置顺序相反，可能不运行</li><li><code>afterCompletion:</code>与配置顺序相反，可能不运行。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
            <tag> SSM整合 </tag>
            
            <tag> 拦截器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-整合MVC</title>
      <link href="/2023/09/15/Spring08MVC/"/>
      <url>/2023/09/15/Spring08MVC/</url>
      
        <content type="html"><![CDATA[<h1 id="Javaweb三大组件及环境特点"><a href="#Javaweb三大组件及环境特点" class="headerlink" title="Javaweb三大组件及环境特点"></a>Javaweb三大组件及环境特点</h1><p>在Java语言范畴内，没有使用前端框架时，web层框架都是基于Javaweb基础组件完成的</p><table><thead><tr><th>组件</th><th>作用</th><th>特点</th></tr></thead><tbody><tr><td>Servlet</td><td>服务端小程序，负责接收客户端 请求并作出响应的</td><td>单例对象，默认第一次访问创建，可以通过配置指定服务器启动就创建，Servlet 创建完毕会执行初始化init方法。每个Servlet有一个service方法，每次访问都会 执行service方法，但是缺点是一个业务功能就需要配置一个Servlet</td></tr><tr><td>Filter</td><td>过滤器，负责对客户端请求进行 过滤操作的</td><td>单例对象，服务器启动时就创建，对象创建完毕执行init方法，对客户端的请求 进行过滤，符合要求的放行，不符合要求的直接响应客户端，执行过滤的核心 方法doFilter</td></tr><tr><td>Listener</td><td>监听器，负责对域对象的创建和 属性变化进行监听的</td><td>根据类型和作用不同，又可分为监听域对象创建销毁和域对象属性内容变化的， 根据监听的域不同，又可以分为监听Request域的，监听Session域的，监听 ServletContext域的</td></tr></tbody></table><h1 id="Spring整合web环境的思路及实现"><a href="#Spring整合web环境的思路及实现" class="headerlink" title="Spring整合web环境的思路及实现"></a>Spring整合web环境的思路及实现</h1><p>在进行Java开发时要遵循三层架构+MVC，Spring操作最核心的就是Spring容器，web层需要注入Service， service层需要注入Dao（Mapper），web层使用Servlet技术充当，需要在Servlet中获得Spring容器，并且每一个servlet实现类都要获得Spring容器一次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.itheima.config.SpringConfig;</span><br><span class="line"><span class="keyword">import</span> com.itheima.service.AccountService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得Spring容器</span></span><br><span class="line">        <span class="comment">//xml版容器</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext2.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注解版容器</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//IOC注入Service实现类</span></span><br><span class="line">        <span class="type">AccountService</span> <span class="variable">accountService</span> <span class="operator">=</span> app.getBean(AccountService.class);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        业务功能</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="tabs" id="1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#1-1">需求分析</button></li><li class="tab"><button type="button" data-href="#1-2">诉求分析</button></li><li class="tab"><button type="button" data-href="#1-3">解决办法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><ol><li>目前1个 servlet 只能实现一个功能 ，导致servlet 很多</li><li>每1个 servlet 都要获得Spring容器，代码重复度太高</li><li>每次都运行时才创建容器，等待时间长</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-2"><ol><li>Spring容器创建一次，配置类加载一次</li><li>最好web服务器启动时，就执行第1步操作，后续直接从容器中获取Bean使用即可</li><li>ApplicationContext的引用需要在web层任何位置都可以获取到</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-3"><ol><li><p>创建好的Spring容器存储到ServletContext域中，整个web层任何位置都能访问</p></li><li><p>在ServletContextListener的contextInitialized方法中执行Spring容器的创建</p><p>或在Servlet的init 方法中执行Spring容器的创建</p><p>并给Servlet的load-on-startup属性一个数字值，确保服务器启动 Servlet就创建</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="模拟实现Spring整合web环境"><a href="#模拟实现Spring整合web环境" class="headerlink" title="模拟实现Spring整合web环境"></a>模拟实现Spring整合web环境</h2><ol><li><p>创建Listener</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountListener</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent sce)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建容器</span></span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(ApplicationContextConfig.class);</span><br><span class="line">        <span class="comment">//把容器放域里面</span></span><br><span class="line">        sce.getServletContext().setAttribute(<span class="string">&quot;applicationContext&quot;</span>,app);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建servlet实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span>&#123;</span><br><span class="line">        <span class="comment">//创建域对象</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> request.getServletContext();</span><br><span class="line">        <span class="comment">//创建容器，从域对象里面接受存储的容器</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> (ApplicationContext) servletContext.getAttribute(<span class="string">&quot;applicationContext&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*业务功能*/</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置listener</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com\itheima\listener\AccountListener.java<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="Spring的web开发组件spring-web"><a href="#Spring的web开发组件spring-web" class="headerlink" title="Spring的web开发组件spring-web"></a>Spring的web开发组件spring-web</h1><p>Spring其实定义了一个ContextLoaderListener，使用方式跟上面模拟的大体一样，但是功能要强百倍，直接使用Spring提供的就可以了</p><ol><li><p>先导入Spring-web的坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在web.xml中去配置ContextLoaderListener，并指定配置文件的位置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果核心配置类使用的是注解形式的，如下配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAnnotationConfigWebApplicationContext</span> <span class="keyword">extends</span></span><br><span class="line">    <span class="title class_">AnnotationConfigWebApplicationContext</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyAnnotationConfigWebApplicationContext</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//注册核心配置类</span></span><br><span class="line">        <span class="built_in">super</span>.register(ApplicationContextConfig.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.itheima.web.MyAnnotationConfigWebApplicationContext<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在Servlet中直接使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/accountServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> request.getServletContext();</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span></span><br><span class="line">            WebApplicationContextUtils.getWebApplicationContext(servletContext);</span><br><span class="line">        <span class="type">AccountService</span> <span class="variable">accountService</span> <span class="operator">=</span> applicationContext.getBean(AccountService.class);</span><br><span class="line">        accountService.transferMoney(<span class="string">&quot;tom&quot;</span>,<span class="string">&quot;lucy&quot;</span>,<span class="number">500</span>);&#125;&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="web层MVC思想"><a href="#web层MVC思想" class="headerlink" title="web层MVC思想"></a>web层MVC思想</h1><p>Java程序在开发一般都是MVC+三层架构，MVC是web开发模式，传统的Javaweb技术栈实现的MVC如下</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231208144335507.png" alt="image-20231208144335507"></p><p>原始Javaweb开发中，Servlet充当Controller的角色，Jsp充当View角色，JavaBean充当模型角色，后期Ajax异 步流行后，在加上现在前后端分离开发模式成熟后，View就被原始Html+Vue替代。原始Javaweb开发中， Service充当Controller有很多弊端，显而易见的有如下几个</p><table><thead><tr><th>Servlet作为Controller的问题</th><th>解决思路和方案</th></tr></thead><tbody><tr><td>每个业务功能请求都对应一个Servlet</td><td>根据业务模块去划分Controller</td></tr><tr><td>每个Servlet的业务操作太繁琐</td><td>将通用的行为，功能进行抽取封装</td></tr><tr><td>Servlet获得Spring容器的组件只能通过客户端代码去获取，不能优雅的整合</td><td>通过Spring的扩展点，去封装一个框架，从原有的Servlet完全接手过来web层的业务</td></tr></tbody></table><blockquote><p>简单来说就是：servlet太多了，而且功能重复的地方有点多。service也实现业务，还要在servlet再进行一次集成，而且集成耦合度也高</p></blockquote><h2 id="MVC框架思想及其设计思路"><a href="#MVC框架思想及其设计思路" class="headerlink" title="MVC框架思想及其设计思路"></a>MVC框架思想及其设计思路</h2><p>负责共有行为的Servlet称之为前端控制器，负责业务行为的JavaBean称之为控制器Controller</p><p>分析前端控制器基本功能如下：</p><ol><li>具备可以映射到业务Bean的能力</li><li>具备可以解析请求参数、封装实体 等共有功能</li><li>具备响应视图及响应其他数据的功 能</li></ol><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231208144839359.png" alt="image-20231208144839359"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 框架 </tag>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web组件及Sping整合</title>
      <link href="/2023/09/11/Spring07%E6%95%B4%E5%90%88web/"/>
      <url>/2023/09/11/Spring07%E6%95%B4%E5%90%88web/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h1><h2 id="请求格式数据"><a href="#请求格式数据" class="headerlink" title="请求格式数据"></a>请求格式数据</h2><p>请求数据总共分为三部分内容，分别是<code>请求行</code>、<code>请求头</code>、<code>请求体</code></p><ul><li><p>请求行: </p><p>HTTP请求中的第一行数据，请求行包含三块内容，分别是 GET[请求方式] &#x2F;[请求URL路径] HTTP&#x2F;1.1[HTTP协议及版本]</p><p>请求方式有七种,最常用的是GET和POST</p></li><li><p>请求头: </p><p>第二行开始，格式为key: value形式，请求头中会包含若干个属性</p></li><li><p>请求体: </p><p>POST请求的最后一部分，存储请求参数<br>请求体和请求头之间是有一个空行隔开。</p><p>GET和POST两个请求之间的区别:</p><ul><li>GET请求请求参数在请求行中，没有请求体，POST请求请求参数在请求体中</li><li>GET请求请求参数大小有限制，POST没有</li></ul></li></ul><div class="tabs" id="2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2-1">Get</button></li><li class="tab"><button type="button" data-href="#2-2">Post</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2-1"><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;#&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">            用户名<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            密码<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;注册&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>用<code>F12</code>打开开发者工具，点击<code>Network</code>来查看请求的请求数据和响应数据具体的格式，得到如下结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GET /tomcat_demo_war/index.html?username=suger1201&amp;password=dsaasd HTTP/1.1</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Cookie: Hm_lvt_f8440b73b5064587c92bcc0ec23ce01c=1653785840,1653981339,1654172967,1654398744; Idea-72a17a30=9bc0eee2-8943-4e0e-b750-ac83c65bb51a; Idea-5587b4ce=bd97b98f-3ea3-4e0c-95e8-12bb1b3b1abb</span><br><span class="line">DNT: 1</span><br><span class="line">Host: localhost:8080</span><br><span class="line">Referer: http://localhost:8080/tomcat_demo_war/index.html</span><br><span class="line">Sec-Fetch-Dest: document</span><br><span class="line">Sec-Fetch-Mode: navigate</span><br><span class="line">Sec-Fetch-Site: same-origin</span><br><span class="line">Sec-Fetch-User: ?1</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.81 Mobile Safari/537.36 Edg/104.0.100.0</span><br><span class="line">sec-ch-ua: &quot;Chromium&quot;;v=&quot;104&quot;, &quot; Not A;Brand&quot;;v=&quot;99&quot;, &quot;Microsoft Edge&quot;;v=&quot;104&quot;</span><br><span class="line">sec-ch-ua-mobile: ?1</span><br><span class="line">sec-ch-ua-platform: &quot;Android&quot;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2-2"><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;#&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">            用户名<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            密码<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;注册&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>用<code>F12</code>打开开发者工具，点击<code>Network</code>来查看请求的请求数据和响应数据具体的格式，得到如下结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">POST /tomcat_demo_war/a.html HTTP/1.1</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Length: 37</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Cookie: Hm_lvt_f8440b73b5064587c92bcc0ec23ce01c=1653785840,1653981339,1654172967,1654398744; Idea-72a17a30=9bc0eee2-8943-4e0e-b750-ac83c65bb51a; Idea-5587b4ce=bd97b98f-3ea3-4e0c-95e8-12bb1b3b1abb</span><br><span class="line">DNT: 1</span><br><span class="line">Host: localhost:8080</span><br><span class="line">Origin: http://localhost:8080</span><br><span class="line">Referer: http://localhost:8080/tomcat_demo_war/a.html</span><br><span class="line">Sec-Fetch-Dest: document</span><br><span class="line">Sec-Fetch-Mode: navigate</span><br><span class="line">Sec-Fetch-Site: same-origin</span><br><span class="line">Sec-Fetch-User: ?1</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.5112.81 Mobile Safari/537.36 Edg/104.0.100.0</span><br><span class="line">sec-ch-ua: &quot;Chromium&quot;;v=&quot;104&quot;, &quot; Not A;Brand&quot;;v=&quot;99&quot;, &quot;Microsoft Edge&quot;;v=&quot;104&quot;</span><br><span class="line">sec-ch-ua-mobile: ?1</span><br><span class="line">sec-ch-ua-platform: &quot;Android&quot;</span><br><span class="line"></span><br><span class="line">username=Cyderpunk2077%40gmail.com&amp;password=asdasdasd</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>GET请求请求参数在请求行（注意看第一行）中，没有请求体，POST请求请求参数在请求体中</p><h2 id="响应格式数据"><a href="#响应格式数据" class="headerlink" title="响应格式数据"></a>响应格式数据</h2><p>响应数据总共分为三部分内容，分别是<code>响应行</code>、<code>响应头</code>、<code>响应体</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: Apache-Coyote/1.1</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">ETag: W/&quot;323-1660647748000&quot;</span><br><span class="line">Last-Modified: Tue, 16 Aug 2022 11:02:28 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 323S</span><br><span class="line">Date: Tue, 16 Aug 2022 11:18:20 GMT</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;#&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">            用户名<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            密码<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;注册&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>响应行：响应数据的第一行,响应行包含三块内容，分别是 </p><p>HTTP&#x2F;1.1[HTTP协议及版本] 200[响应状态码] ok[状态码的描述]</p></li><li><p>响应头：第二行开始，格式为key：value形式</p></li><li><p>响应体：最后一部分，存放响应数据。</p><p>上面的代码中<code>&lt;html&gt;...&lt;/html&gt;</code>这部分内容就是响应体，它和响应头之间有一个空行隔开</p></li></ul><h3 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h3><table><thead><tr><th>状态码分类</th><th>说明</th></tr></thead><tbody><tr><td>1xx</td><td><strong>响应中</strong>——临时状态码，表示请求已经接受，告诉客户端应该继续请求或者如果它已经完成则忽略它</td></tr><tr><td>2xx</td><td><strong>成功</strong>——表示请求已经被成功接收，处理已完成</td></tr><tr><td>3xx</td><td><strong>重定向</strong>——重定向到其它地方：它让客户端再发起一个请求以完成整个处理。</td></tr><tr><td>4xx</td><td><strong>客户端错误</strong>——处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等</td></tr><tr><td>5xx</td><td><strong>服务器端错误</strong>——处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP版本不支持等</td></tr></tbody></table><h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><p>什么是Web服务器？<br>Web服务器是一个应用程序（软件），对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作，让Web开发更加便捷。主要功能是”提供网上信息浏览服务”。</p><p>我们可以把自己写的Web项目部署到Web Tomcat服务器软件中，当Web服务器软件启动后，部署在Web服务器软件中的页面就可以直接通过浏览器来访问了。</p><p><strong>Web服务器软件使用步骤</strong></p><ul><li>准备静态资源</li><li>下载安装Web服务器软件</li><li>将静态资源部署到Web服务器上</li><li>启动Web服务器使用浏览器访问对应的资源</li></ul><p>Tomcat的相关概念:</p><ul><li>Tomcat是Apache软件基金会一个核心项目，是一个开源免费的轻量级Web服务器，支持Servlet&#x2F;JSP少量JavaEE规范。</li><li>因为Tomcat支持Servlet&#x2F;JSP规范，所以Tomcat也被称为Web容器、Servlet容器。Servlet需要依赖Tomcat才能运行。</li><li>Tomcat的官网: <a href="https://tomcat.apache.org/">https://tomcat.apache.org/</a> 从官网上可以下载对应的版本进行使用。现在可以通过倒依赖使用</li></ul><h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><ul><li>Servlet是JavaWeb最为核心的内容，它是Java提供的一门动态web资源开发技术。</li><li>使用Servlet就可以实现，根据不同的登录用户在页面上动态显示不同内容。</li><li>Servlet是JavaEE规范之一，其实就是一个接口，将来我们需要定义Servlet类实现Servlet接口，并由web服务器运行Servlet</li></ul><h2 id="Servlet入门案例"><a href="#Servlet入门案例" class="headerlink" title="Servlet入门案例"></a>Servlet入门案例</h2><p>需求分析: 编写一个Servlet类，并使用IDEA中Tomcat插件进行部署，最终通过浏览器访问所编写的Servlet程序。</p><p>具体的实现步骤为:</p><ol><li><p>创建Web项目<code>web-demo</code>，导入Servlet依赖坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此处需要添加<code>&lt;scope&gt;provided&lt;/scope&gt;</code>，因为Tomcat的lib目录中已经有servlet-api这个jar包，如果在生成war包的时候生效就会和Tomcat中的jar包冲突，导致报错</p></li><li><p>定义一个类，实现Servlet接口，并重写接口中所有方法，并在service方法中输入一句话</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello servlet&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在类上使用@WebServlet注解，配置该Servlet的访问路径（web的访问路径）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/demo1&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello servlet&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动Tomcat，浏览器中输入URL地址访问该Servlet，查看结果</p></li></ol><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><ul><li>浏览器发出<code>http://localhost:8080/web-demo/demo1</code>请求，从请求中可以解析出三部分内容，分别是localhost：8080、web-demo、demo1<ul><li>根据<code>localhost:8080</code>可以找到要访问的Tomcat Web服务器</li><li>根据<code>web-demo</code>可以找到部署在Tomcat服务器上的web-demo项目</li><li>根据<code>demo1</code>可以找到要访问的是项目中的哪个Servlet类，根据@WebServlet后面的值进行匹配</li></ul></li><li>找到ServletDemo这个类后，Tomcat Web服务器就会为ServletDemo这个类创建一个对象，然后调用对象中的service方法<ul><li>ServletDemo实现了Servlet接口，所以类中必然会重写service方法供Tomcat Web服务器进行调用</li><li>service方法中有ServletRequest和ServletResponse两个参数，ServletRequest封装的是请求数据，ServletResponse封装的是响应数据，后期我们可以通过这两个参数实现前后端的数据交互</li></ul></li></ul><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>Servlet运行在Servlet容器(web服务器)中，其生命周期由容器来管理，分为4个阶段：</p><ol><li><p>加载和实例化：默认情况下，当Servlet第一次被访问时，由容器创建Servlet对象</p><p>默认情况，Servlet会在第一次访问被容器创建，但是如果创建Servlet比较耗时的话，那么第一个访问的人等待的时间就比较长，用户的体验就比较差，那么我们能不能把Servlet的创建放到服务器启动的时候来创建，具体如何来配置?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/demo1&quot;,loadOnStartup = 1)</span></span><br></pre></td></tr></table></figure><p>loadOnstartup的取值有两类情况</p><ul><li>负整数:第一次访问时创建Servlet对象</li><li>0或正整数:服务器启动时创建Servlet对象，数字越小优先级越高</li></ul></li><li><p>初始化：在Servlet实例化之后，容器将调用Servlet的init()方法初始化这个对象，完成一些如加载配置文件、创建连接等初始化的工作。该方法只调用一次</p></li><li><p>请求处理：每次请求Servlet时，Servlet容器都会调用Servlet的service()方法对请求进行处理</p></li><li><p>服务终止：当需要释放内存或者容器关闭时，容器就会调用Servlet实例的destroy()方法完成资源的释放。在destroy()方法调用之后，容器会释放这个Servlet实例，该实例随后会被Java的垃圾收集器所回收</p></li></ol><h3 id="总结案例："><a href="#总结案例：" class="headerlink" title="总结案例："></a>总结案例：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置为1之后，在我们访问http://localhost:8080/web-demo/demo之前，就会进行初始化操作了，第一个人访问的时候就不会等那么久了</span></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/demo&quot;,loadOnStartup = 1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化方法</span></span><br><span class="line"><span class="comment">     * 1.调用时机：默认情况下，Servlet被第一次访问时，调用</span></span><br><span class="line"><span class="comment">     * * loadOnStartup: 默认为-1，修改为0或者正整数，则会在服务器启动的时候，调用</span></span><br><span class="line"><span class="comment">     * 2.调用次数: 1次</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> servletConfig</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供服务</span></span><br><span class="line"><span class="comment">     * 1.调用时机:每一次Servlet被访问时，调用</span></span><br><span class="line"><span class="comment">     * 2.调用次数: 多次</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> servletRequest</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> servletResponse</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello servlet&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销毁方法</span></span><br><span class="line"><span class="comment">     * 1.调用时机：内存释放或者服务器关闭的时候，Servlet对象会被销毁，调用</span></span><br><span class="line"><span class="comment">     * 2.调用次数: 1次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Servlet对象默认是第一次访问的时候被创建，可以修改<code>loadOnStartup</code>，修改成在服务器启动的时候创建</li><li>Servlet生命周期中涉及到的三个方法：<ol><li>init方法：在Servlet对象被创建的时候执行，只执行1次</li><li>service方法：在Servlet被访问的时候调用，每访问1次就调用1次(每刷新一次界面，控制台就会输出一次)</li><li>destroy方法：在Servlet对象被销毁的时候调用，只执行1次</li></ol></li></ul><h2 id="Servlet方法介绍"><a href="#Servlet方法介绍" class="headerlink" title="Servlet方法介绍"></a>Servlet方法介绍</h2><p>Servlet中总共有5个方法，剩下的两个方法是:</p><ul><li><p>getServletInfo() ：获取Servlet信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getServletInfo</span><span class="params">()</span> </span><br><span class="line"><span class="comment">//该方法用来返回Servlet的相关信息，没有什么太大的用处，一般我们返回一个空字符串即可</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>getServletConfig()：获取ServletConfig对象</p><p>ServletConfig对象，在init方法的参数中有，而Tomcat Web服务器在创建Servlet对象的时候会调用init方法，必定会传入一个ServletConfig对象，我们需要将服务器传过来的ServletConfig进行返回</p></li></ul><h3 id="5方法总结"><a href="#5方法总结" class="headerlink" title="5方法总结"></a>5方法总结</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/demo&quot;, loadOnStartup = 1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line">    <span class="comment">//创建ServletConfig对象</span></span><br><span class="line">    <span class="keyword">private</span> ServletConfig servletConfig;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="comment">//将init方法传入的ServletConfig对象赋给我们创建的ServletConfig</span></span><br><span class="line">        <span class="built_in">this</span>.servletConfig = servletConfig;</span><br><span class="line">        System.out.println(<span class="string">&quot;init..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//返回ServletConfig对象</span></span><br><span class="line">        <span class="keyword">return</span> servletConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello servlet&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承体系结构"><a href="#继承体系结构" class="headerlink" title="继承体系结构"></a>继承体系结构</h2><p>编写一个Servlet就必须要实现Servlet接口，重写接口中的5个方法，因为我们更关注的其实只有service方法，重写所有方法还是比较麻烦的，一般用写好的实现类简化</p><p>因为我们将来开发web项目，都是针对HTTP协议，所以自定义Servlet，一般会继承<code>HttpServlet</code></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231121101849261.png" alt="image-20231121101849261"></p><p>HttpServlet中为什么要根据请求方式的不同，调用不同的方法？如何调用？</p><ul><li>GET和POST参数的位置不一致，GET请求参数在请求行中，POST请求参数在请求体中，为了能处理不同的请求方式，我们得在service方法中进行判断，然后写不同的业务处理，可以把相似的代码写入一个方法，用来简化。</li><li>HttpServlet中的service方法，首先先获取请求方法，随后根据不同的请求方法来进行不同的操作。</li><li>前面说过一共有7种请求方法，HttpServlet类中已经包含了这7种，不仅可以处理GET和POST还可以处理其他五种请求方式。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> req.getMethod();</span><br><span class="line">    <span class="type">long</span> lastModified;</span><br><span class="line">    <span class="keyword">if</span> (method.equals(<span class="string">&quot;GET&quot;</span>)) &#123;</span><br><span class="line">        lastModified = <span class="built_in">this</span>.getLastModified(req);</span><br><span class="line">        <span class="keyword">if</span> (lastModified == -<span class="number">1L</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.doGet(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">ifModifiedSince</span> <span class="operator">=</span> req.getDateHeader(<span class="string">&quot;If-Modified-Since&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (ifModifiedSince &lt; lastModified) &#123;</span><br><span class="line">                <span class="built_in">this</span>.maybeSetLastModified(resp, lastModified);</span><br><span class="line">                <span class="built_in">this</span>.doGet(req, resp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resp.setStatus(<span class="number">304</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;HEAD&quot;</span>)) &#123;</span><br><span class="line">        lastModified = <span class="built_in">this</span>.getLastModified(req);</span><br><span class="line">        <span class="built_in">this</span>.maybeSetLastModified(resp, lastModified);</span><br><span class="line">        <span class="built_in">this</span>.doHead(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;POST&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.doPost(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;PUT&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.doPut(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;DELETE&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.doDelete(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;OPTIONS&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.doOptions(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;TRACE&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.doTrace(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">errMsg</span> <span class="operator">=</span> lStrings.getString(<span class="string">&quot;http.method_not_implemented&quot;</span>);</span><br><span class="line">        Object[] errArgs = <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;method&#125;;</span><br><span class="line">        errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line">        resp.sendError(<span class="number">501</span>, errMsg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="urlPattern配置"><a href="#urlPattern配置" class="headerlink" title="urlPattern配置"></a>urlPattern配置</h2><p>Servlet类编写好后，要想被访问到，就需要配置其访问路径<code>urlPattern</code></p><p>一个Servlet,可以配置多个urlPattern，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &#123;&quot;/demo1&quot;,&quot;/demo2&quot;&#125;)</span></span><br></pre></td></tr></table></figure><h3 id="配置规则"><a href="#配置规则" class="headerlink" title="配置规则"></a>配置规则</h3><p>urlPattern总共有四种配置方式，分别是精确匹配、目录匹配、扩展名匹配、任意匹配</p><p>五种配置的优先级为 精确匹配 &gt; 目录匹配&gt; 扩展名匹配 &gt; &#x2F;* &gt; &#x2F; ，以最终运行结果为准。</p><ul><li><p>精确匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/user/select&quot;)</span></span><br></pre></td></tr></table></figure><p>访问路径<code>http://localhost:8080/web-demo/user/select</code></p></li><li><p>目录匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/user/*&quot;)</span></span><br></pre></td></tr></table></figure><p>访问路径<code>http://localhost:8080/web-demo/user/任意</code></p></li><li><p>扩展名匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;*.do&quot;)</span>   <span class="comment">//注意这里没加斜杠</span></span><br></pre></td></tr></table></figure><p>访问路径<code>http://localhost:8080/web-demo/任意.do</code></p></li><li><p>任意匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/&quot;)</span>  </span><br><span class="line"><span class="comment">//或</span></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/*&quot;)</span></span><br></pre></td></tr></table></figure><p>访问路径<code>http://localhost:8080/demo-web/任意</code></p></li></ul><p>注意:<code>/</code>和<code>/*</code>的区别</p><ol><li>当我们的项目中的Servlet配置了 “&#x2F;”，会覆盖掉tomcat中的DefaultServlet,当其他的url-pattern都匹配不上时都会走这个Servlet</li><li>当我们的项目中配置了”&#x2F;*”,意味着匹配任意访问路径</li><li>DefaultServlet是用来处理静态资源，如果配置了”&#x2F;“会把默认的覆盖掉，就会引发请求静态资源的时候没有走默认的而是走了自定义的Servlet类，最终导致静态资源不能被访问</li></ol><h1 id="Request和Response"><a href="#Request和Response" class="headerlink" title="Request和Response"></a>Request和Response</h1><p>Request是请求对象，用来封装请求数据的对象，Response是响应对象，用来封装响应数据的对象</p><ul><li>request：获取请求数据<ul><li>浏览器会发送HTTP请求到后台服务器（Tomcat）</li><li>HTTP的请求中会包含很多请求数据（请求行+请求头+请求体）</li><li>后台服务器（Tomcat）会对HTTP请求的数据进行解析，并把解析解惑存入到一个对象中</li><li>所存入的对象即为request对象，我们可以从request对象中获取请求的相关参数</li><li>获取到数据后就可以继续后续的业务，比如获取用户名和密码就可以实现登录操作的相关业务</li></ul></li><li>response：设置响应数据<ul><li>业务处理完后，后台就需要给前端返回业务处理的结果，即响应数据</li><li>把响应数据封装到response对象中</li><li>后台服务器（Tomcat）会解析response对象，按照<code>响应行+响应头+响应体</code>的格式拼接结果</li><li>浏览器最终解析结果，把内容展示在浏览器给用户浏览</li></ul></li></ul><h2 id="Request对象"><a href="#Request对象" class="headerlink" title="Request对象"></a>Request对象</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231121104247541.png" alt="image-20231121104247541"></p><p>ServletRequest和HttpServletRequest是继承关系，并且两个都是接口，接口是无法创建对象，对象都是RequestFacade创建的</p><p>RequestFacade实现类：</p><ul><li>该类实现了HttpServletRequest接口，也间接实现了ServletRequest接口。</li><li>Servlet类中的service方法、doGet方法或者是doPost方法最终都是由Web服务器（Tomcat）来调用的，所以Tomcat提供了方法参数接口的具体实现类，并完成了对象的创建</li><li>要想了解RequestFacade中都提供了哪些方法，我们可以直接查看JavaEE的API文档中关于ServletRequest和HttpServletRequest的接口文档，因为RequestFacade实现了其接口就需要重写接口中的方法</li></ul><h3 id="Request获取请求数据"><a href="#Request获取请求数据" class="headerlink" title="Request获取请求数据"></a>Request获取请求数据</h3><p>HTTP请求数据总共分为三部分内容，分别是请求行、请求头、请求体</p><h4 id="获取请求行数据"><a href="#获取请求行数据" class="headerlink" title="获取请求行数据"></a>获取请求行数据</h4><p>请求行包含三块内容，分别是<code>请求方式</code>、<code>请求资源路径</code>、<code>HTTP协议及版本</code>，例如<br><code>GET /tomcat_demo_war/index.html?username=suger1201&amp;password=dsaasd HTTP/1.1</code></p><p>对于这三部分内容，request对象都提供了对应的API方法来获取</p><ul><li><p>获取请求方式: <code>GET</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getMethod</span><span class="params">()</span></span><br></pre></td></tr></table></figure></li><li><p>获取虚拟目录(项目访问路径): <code>/request-demo</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getContextPath</span><span class="params">()</span></span><br></pre></td></tr></table></figure></li><li><p>获取URL(统一资源定位符): <code>http://localhost:8080/request-demo/req1</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer <span class="title function_">getRequestURL</span><span class="params">()</span></span><br></pre></td></tr></table></figure></li><li><p>获取URI(统一资源标识符): <code>/request-demo/req1</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getRequestURI</span><span class="params">()</span></span><br></pre></td></tr></table></figure></li><li><p>获取请求参数(GET方式): <code>username=zhangsan&amp;password=123</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getQueryString</span><span class="params">()</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="获取请求头数据"><a href="#获取请求头数据" class="headerlink" title="获取请求头数据"></a>获取请求头数据</h4><p>对于请求头的数据，格式为<code>key: value</code>，所以根据请求头名称获取对应值的方法为</p><p><code>String getHeader(String name) </code></p><h4 id="获取请求体数据"><a href="#获取请求体数据" class="headerlink" title="获取请求体数据"></a>获取请求体数据</h4><p>浏览器在发送GET请求的时候是没有请求体的，所以需要把请求方式变更为POST</p><p>对于请求体中的数据，Request对象提供了如下两种方式来获取其中的数据，分别是：</p><ol><li><p>获取字节输入流，如果前端发送的是字节数据，比如传递的是文件数据，则使用该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServletInputStream <span class="title function_">getInputStream</span><span class="params">()</span></span><br></pre></td></tr></table></figure></li><li><p>获取字符输入流，如果前端发送的是纯文本数据，则使用该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader <span class="title function_">getReader</span><span class="params">()</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="获取请求参数的通用方式"><a href="#获取请求参数的通用方式" class="headerlink" title="获取请求参数的通用方式"></a>获取请求参数的通用方式</h4><ul><li><p>GET方式：<code>String getQueryString()</code></p></li><li><p>POST方式：<code>BufferedReader getReader();</code></p></li></ul><p>GET请求方式和POST请求方式区别主要在于获取请求参数的方式不一样，能否统一doGet和doPost方法内的代码?</p><ol><li><p>使用request的getMethod()来获取请求方式，根据请求方式的不同分别获取请求参数值，这样就可以解决上述问题，但是以后每个Servlet都需要这样写代码，实现起来比较麻烦，这种方案我们不采用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//获取请求方式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> req.getMethod();</span><br><span class="line">        <span class="type">String</span> <span class="variable">param</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//根据请求方式来获取请求参数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;GET&quot;</span>.equals(method)) &#123;</span><br><span class="line">            param = req.getQueryString();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;POST&quot;</span>.equals(method)) &#123;</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> req.getReader();</span><br><span class="line">            param = bufferedReader.readLine();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将请求参数进行打印控制台</span></span><br><span class="line">        System.out.println(param);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>request对象已经将上述获取请求参数的方法进行了封装</p><ol><li>根据不同的请求方式获取请求参数，<code>username=zhangsan&amp;password=asd123&amp;hobby=1&amp;hobby=2</code></li><li>把获取到的内容进行分割，<code>username=zhangsan&amp;password=asd123&amp;hobby=1</code> -&gt; <code>username=zhangsan password=asd123 hobby=1 hobby=2</code> -&gt; <code>username zhangsan password asd123 hobby 1 hobby 2</code></li><li>把分割后端数据，存入到一个Map集合中，其中Map集合的泛型为<code>&lt;String,String[]&gt;</code>，因为参数的值可能是一个，也可能有多个，所以value的值的类型为String数组。</li></ol><p>基于上述理论，有如下方法:</p><ul><li><p>获取所有参数Map集合<code>Map&lt;String,String[]&gt; getParameterMap()</code></p></li><li><p>根据名称(Key)获取参数值(Value)（数组）<code>String[] getParameterValues(String name)</code></p></li><li><p>根据名称(Key)获取参数值(Value)(单个值)<code>String getParameter(String name)</code></p></li></ul></li></ol><h3 id="Request请求转发"><a href="#Request请求转发" class="headerlink" title="Request请求转发"></a>Request请求转发</h3><p>求转发(forward):一种在服务器内部的资源跳转方式。</p><ol><li>浏览器发送请求给服务器，服务器中对应的资源A接收到请求</li><li>资源A处理完请求后将请求发给资源B</li><li>资源B处理完后将结果响应给浏览器</li><li>请求从资源A到资源B的过程就叫请求转发</li></ol><h4 id="请求转发的特点"><a href="#请求转发的特点" class="headerlink" title="请求转发的特点"></a>请求转发的特点</h4><ul><li>浏览器地址栏路径不发生变化<br>虽然后台从<code>/路径1</code>转发到&#96;&#96;&#x2F;路径2<code>,但是浏览器的地址一直是</code>&#x2F;路径1&#96;,未发生变化</li><li>只能转发到当前服务器的内部资源<br>不能从一个服务器通过转发访问另一台服务器</li><li>一次请求，可以在转发资源间使用request共享数据<br>虽然后台从<code>/路径1</code>转发到&#96;&#96;&#x2F;路径2&#96;，但是这个只有一次请求</li></ul><h1 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h1><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231121112945682.png" alt="image-20231121112945682"></p><h2 id="Response设置响应数据功能介绍"><a href="#Response设置响应数据功能介绍" class="headerlink" title="Response设置响应数据功能介绍"></a>Response设置响应数据功能介绍</h2><p>HTTP响应数据总共分为三部分内容，分别是响应行、响应头、响应体，对于这三部分内容的数据，respone对象提供方法来进行设置</p><ol><li><p>响应行<br>响应行包含三块内容，分别是 HTTP&#x2F;1.1[HTTP协议及版本] 200[响应状态码] ok[状态码的描述]<br>对于响应头，比较常用的就是设置响应状态码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setStatus</span><span class="params">(<span class="type">int</span> sc)</span>;</span><br></pre></td></tr></table></figure></li><li><p>响应头<br>响应头的格式为key：value形式<br>设置响应头键值对：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setHeader</span><span class="params">(String name,String value)</span>;</span><br></pre></td></tr></table></figure></li><li><p>响应体<br>对于响应体，是通过字符、字节输出流的方式往浏览器写，<br>获取字符输出流:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter <span class="title function_">getWriter</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>获取字节输出流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServletOutputStream <span class="title function_">getOutputStream</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li></ol><h3 id="Response请求重定向"><a href="#Response请求重定向" class="headerlink" title="Response请求重定向"></a>Response请求重定向</h3><p>Response重定向(redirect):一种资源跳转方式。</p><ol><li>浏览器发送请求给服务器，服务器中对应的资源A接收到请求</li><li>资源A现在无法处理该请求，就会给浏览器响应一个302的状态码+location的一个访问资源B的路径(要加上资源B的虚拟目录)</li><li>浏览器接收到响应状态码为302就会重新发送请求到location对应的访问地址去访问资源B</li><li>资源B接收到请求后进行处理并最终给浏览器响应结果，这整个过程就叫重定向</li></ol><h4 id="重定向的特点"><a href="#重定向的特点" class="headerlink" title="重定向的特点"></a>重定向的特点</h4><ul><li>浏览器地址栏路径发送变化<br>当进行重定向访问的时候，由于是由浏览器发送的两次请求，所以地址会发生变化</li><li>可以重定向到任何位置的资源(服务内容、外部均可)<br>因为第一次响应结果中包含了浏览器下次要跳转的路径，所以这个路径是可以任意位置资源。</li><li>两次请求，不能在多个资源使用request共享数据<br>因为浏览器发送了两次请求，是两个不同的request对象，就无法通过request对象进行共享数据</li></ul><p>重定向和请求转发比较：</p><table><thead><tr><th align="center">重定向特点</th><th align="center">请求转发特点</th></tr></thead><tbody><tr><td align="center">浏览器地址栏路径发生变化</td><td align="center">浏览器地址栏路径不发生变化</td></tr><tr><td align="center">可以重定向到任意位置的资源（服务器内部、外部均可)</td><td align="center">只能转发到当前服务器的内部资源</td></tr><tr><td align="center">两次请求，不能在多个资源使用request共享数据</td><td align="center">一次请求，可以在转发的资源间使用request共享数据</td></tr></tbody></table><h3 id="路径问题"><a href="#路径问题" class="headerlink" title="路径问题"></a>路径问题</h3><p>转发的时候路径上没有加虚拟目录<code>web_demo_war_exploded</code>，而重定向加了，那么到底什么时候需要加，什么时候不需要加?</p><p>其实判断的依据很简单，只需要记住下面的规则即可:</p><ul><li>浏览器使用：需要加虚拟目录(项目访问路径)</li><li>服务端使用：不需要加虚拟目录</li></ul><blockquote><p>对于转发来说，因为是在服务端进行的，所以不需要加虚拟目录<br>对于重定向来说，路径最终是由浏览器来发送请求，就需要添加虚拟目录。</p></blockquote><p>在重定向的代码中，&#96;&#96;web_demo_war_exploded&#96;是固定编码的，如果后期通过Tomcat插件配置了项目的访问路径，那么所有需要重定向的地方都需要重新修改，该如何优化?</p><p>可以去pom.xml配置文件中配置项目的访问地址，然后在代码中动态去获取项目访问的虚拟目录，request对象中提供了getContextPath()方法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">path</span>&gt;</span></span><br><span class="line">                    /web_demo_war_exploded</span><br><span class="line">                <span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/ResponseDemo1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseDemo1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这里是ResponseDemo1&quot;</span>);</span><br><span class="line">        <span class="comment">//获取虚拟目录</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">contextPath</span> <span class="operator">=</span> request.getContextPath();</span><br><span class="line">        <span class="comment">//把虚拟目录拼在前面</span></span><br><span class="line">        response.sendRedirect(contextPath + <span class="string">&quot;/RequestDemo2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Spring整合web环境"><a href="#Spring整合web环境" class="headerlink" title="Spring整合web环境"></a>Spring整合web环境</h1><h2 id="Javaweb三大组件及环境特点"><a href="#Javaweb三大组件及环境特点" class="headerlink" title="Javaweb三大组件及环境特点"></a>Javaweb三大组件及环境特点</h2><p>在Java语言范畴内，web层框架都是基于Javaweb基础组件完成的，所以有必要复习一下Javaweb组件的特点</p><table><thead><tr><th>组件</th><th>作用</th><th>特点</th></tr></thead><tbody><tr><td>Servlet</td><td>服务端小程序，负责接收客户端 请求并作出响应的</td><td><strong>单例对象，默认第一次访问创建</strong>，可以通过配置指定服务器启动就创建，Servlet创建完毕会执行初始化init方法。<br>每个Servlet有一个service方法，每次访问都会执行service方法，但是缺点是一个业务功能就需要配置一个Servlet</td></tr><tr><td>Filter</td><td>过滤器，负责对客户端请求进行过滤操作的</td><td><strong>单例对象，服务器启动时就创建</strong>，对象创建完毕执行init方法，对客户端的请求进行过滤，符合要求的放行，不符合要求的直接响应客户端，执行过滤的核心方法doFilter</td></tr><tr><td>Listener</td><td>监听器，负责对域对象的创建和属性变化进行监听的</td><td>根据类型和作用不同，又可分为监听域对象创建销毁和域对象属性内容变化的， 根据监听的域不同，又可以分为监听Request域的，监听Session域的，监听 ServletContext域的</td></tr></tbody></table><h3 id="三大组件"><a href="#三大组件" class="headerlink" title="三大组件"></a>三大组件</h3><p>Servlet</p><ul><li>服务端程序</li><li>功能:用于接受客户端请求并做出响应</li><li>作用范围:多例,每个请求都会实例化一个Servlet对象来处理。不同请求的Servlet实例是独立的，相互之间没有影响</li><li>创建时机:默认第一次访问时,Servlet创建，缓存到web容器当中，类似于延迟加载的bean对象，可以配置load-on-starup指定创建时机，Servlet创建时会执行init方法，每次访问Servlet时会执行service方法。</li></ul><p>Filter</p><ul><li>过滤器</li><li>功能:负责请求和响应进行过滤处理，放行或者拦截</li><li>作用范围:单例,一个Web应用通常只有一个过滤器实例</li><li>创建时机:服务器启动时就会创建,创建完毕时会执行init方法</li></ul><p>Listener</p><ul><li>监听器</li><li>功能:用于监听Web应用中的事件,主要监听域对象的创建与销毁，最常监听ServletContext域</li><li>作用范围:单例,监听器是单例的，一个Web应用通常只有一个监听器实例，它在整个应用的生命周期中起作用。</li><li>创建时机:服务器启动时就会创建</li></ul><p>在服务器启动时想执行一些逻辑代码可以选择：Servlet，filter的init方法，listener监听application域的监听代码中</p><h3 id="JSP中的四大域对象"><a href="#JSP中的四大域对象" class="headerlink" title="JSP中的四大域对象"></a>JSP中的四大域对象</h3><ul><li>page域对象（只在当前页面中有效）</li><li>request域对象（只在一次请求中有效，服务端跳转有效，客户端跳转无效）</li><li>session域对象（在一次会话中有效，服务端客户端跳转都有效）</li><li>application域对象（在整个应用程序中都有效）服务器启动时就会创建，就会有监听器监听application域的创建</li></ul><h2 id="Spring整合web环境的思路及实现"><a href="#Spring整合web环境的思路及实现" class="headerlink" title="Spring整合web环境的思路及实现"></a>Spring整合web环境的思路及实现</h2><p>在进行Java开发时要遵循三层架构+MVC</p><p>Spring操作最核心的就是Spring容器，web层需要注入Service， service层需要注入Dao（Mapper），web层使用Servlet技术充当的话，需要在Servlet中获得Spring容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/accountServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//web层调用service层 获得AccountService 获得AccountService存在于spring容器总</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">AccountService</span> <span class="variable">bean</span> <span class="operator">=</span> applicationContext.getBean(AccountService.class);</span><br><span class="line">        bean.transferMoney(<span class="string">&quot;luck&quot;</span>,<span class="string">&quot;bad&quot;</span>,<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在的问题：</p><ol><li>上述代码的耦合度过高</li><li>每一个Servlet的doget方法都需要创建一次容器，加载一个配置类，才获得bean对象。极大的影响开发性能</li></ol><p>改进：</p><ul><li><p>ApplicationContext创建一次，配置类加载一次，也就是容器只创建一次</p></li><li><p>最好在web服务器启动时就执行第一步操作，避免第一个访问等待时间过长，后续直接从容器中获取Bean即可</p><blockquote><p>Servlet，filter的init方法，listener监听等</p></blockquote></li><li><p>ApplicationContext的引用需要存在web层的任何位置都能获取到</p></li></ul><h2 id="模拟ContextLoaderListener"><a href="#模拟ContextLoaderListener" class="headerlink" title="模拟ContextLoaderListener"></a>模拟ContextLoaderListener</h2><p>思路：</p><ol><li><p>可以在Listener监听器中的contextInitialized方法中执行创建applicationContext代码。</p><p>或者在Servlet的init方法中执行applicationContext的创建</p></li><li><p>在web.xml中设置Servlet的load-on-starup属性值确保服务器启动时Servlet就创建执行init方法</p></li><li><p>将创建好的applicationContext存储到ServletContext中这样在整个web层都可以获取到</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContextLoaderListener</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ContextLoaderListener contextInitialized...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建Spring容器</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.将容器创建到ServletContext域中</span></span><br><span class="line">        sce.getServletContext().setAttribute(<span class="string">&quot;applicationContext&quot;</span>,applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>contextInitialized这个方法只执行一次，故只创建一次spring容器</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置Listener--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.heima.listener.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>新的问题：耦合度过高，需要解决两个解耦问题</p><ol><li><p>在监听器listener中获取applicationContext时将配置文件名写死了，这就导致在开发过程中我们只能以这种命名方式，这是不被允许的，所以我们需要在web.xml文件中配置全局参数，将配置文件名从代码中解耦出来，之后只用在web.xml文件中进行修改即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContextLoaderListener</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">CONTEXT_CONFIG_LOCATION</span> <span class="operator">=</span> <span class="string">&quot;contextConfigLocation&quot;</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ContextLoaderListener contextInitialized...&quot;</span>);</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> sce.getServletContext();</span><br><span class="line">        <span class="comment">//获取ContextConfigLocation配置文件名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">contextConfigLocation</span> <span class="operator">=</span> servletContext.getInitParameter(CONTEXT_CONFIG_LOCATION);</span><br><span class="line">        <span class="comment">//解析出配置文件名称</span></span><br><span class="line">        contextConfigLocation = contextConfigLocation.substring(<span class="string">&quot;classpath:&quot;</span>.length());</span><br><span class="line">        <span class="comment">//1.创建Spring容器</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(contextConfigLocation);</span><br><span class="line">        <span class="comment">//2.将容器创建到ServletContext域中</span></span><br><span class="line">        servletContext.setAttribute(<span class="string">&quot;applicationContext&quot;</span>,applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义全局参数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--类加载路径--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置Listener--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>从ServletContext获取applicationContext时是通过字符串获取的，在自定义框架时尽可能不要有特殊字符串需要程序员自己去记，需要将耦合死的字符串隐藏一下，框架内部去消化，或者通过一个工具类直接获取进行解耦</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebApplicationContextUtils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ApplicationContext <span class="title function_">getWebApplicationContext</span><span class="params">(ServletContext servletContext)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (ApplicationContext) servletContext.getAttribute(<span class="string">&quot;applicationContext&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/accountServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//web层调用service层 获得AccountService 获得AccountService存在于spring容器总</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> request.getServletContext();</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> WebApplicationContextUtils.getWebApplicationContext(servletContext);</span><br><span class="line">        <span class="type">AccountService</span> <span class="variable">bean</span> <span class="operator">=</span> applicationContext.getBean(AccountService.class);</span><br><span class="line">        bean.transferMoney(<span class="string">&quot;luck&quot;</span>,<span class="string">&quot;bad&quot;</span>,<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Spring的web开发组件spring-web"><a href="#Spring的web开发组件spring-web" class="headerlink" title="Spring的web开发组件spring-web"></a>Spring的web开发组件spring-web</h2><p>pom.xml中直接导入spring-web的jar包，之后替换掉模拟的ContextLoaderListener和web.xml的全路径名</p>]]></content>
      
      
      
        <tags>
            
            <tag> 框架 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-事务</title>
      <link href="/2023/09/06/Spring06%E4%BA%8B%E5%8A%A1/"/>
      <url>/2023/09/06/Spring06%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h1><p>事务作用：在数据层保障一系列的数据库操作同成功同失败</p><p>Spring事务作用：在数据层或业务层保障一系列的数据库操作同成功同失败</p><p>数据层有事务我们可以理解，为什么业务层也需要处理事务呢？举个简单的例子</p><ul><li>转账业务会有两次数据层的调用，一次是加钱一次是减钱</li><li>把事务放在数据层，加钱和减钱就有两个事务</li><li>没办法保证加钱和减钱同时成功或者同时失败</li><li>这个时候就需要将事务放在业务层进行处理。</li></ul><p>Spring为了管理事务，提供了一个平台事务管理器<code>PlatformTransactionManager</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PlatformTransactionManager</span> <span class="keyword">extends</span> <span class="title class_">TransactionManager</span> &#123;</span><br><span class="line">    TransactionStatus <span class="title function_">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition var1)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>commit是用来提交事务，rollback是用来回滚事务。</p><p>PlatformTransactionManager只是一个接口，Spring还为其提供了一个具体的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceTransactionManager</span> <span class="keyword">extends</span> <span class="title class_">AbstractPlatformTransactionManager</span> <span class="keyword">implements</span> <span class="title class_">ResourceTransactionManager</span>, InitializingBean &#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> enforceReadOnly;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从名称上可以看出，我们只需要给它一个DataSource对象，它就可以帮你去在业务层管理事务。其内部采用的是JDBC的事务。所以说如果你持久层采用的是JDBC相关的技术，就可以采用这个事务管理器来管理你的事务。而Mybatis内部采用的就是JDBC的事务，所以后期我们Spring整合Mybatis就采用的这个<code>DataSourceTransactionManager</code>事务管理器。</p><h2 id="转账案例–需求分析"><a href="#转账案例–需求分析" class="headerlink" title="转账案例–需求分析"></a>转账案例–需求分析</h2><p>接下来通过一个案例来学习下Spring是如何来管理事务的。</p><p>先来分析下需求:</p><ul><li>需求: 实现任意两个账户间转账操作</li><li>需求微缩: A账户减钱，B账户加钱</li></ul><p>为了实现上述的业务需求，我们可以按照下面步骤来实现下:</p><ol><li>数据层提供基础操作，指定账户减钱（outMoney），指定账户加钱（inMoney）</li><li>业务层提供转账操作（transfer），调用减钱与加钱的操作</li><li>提供2个账号和操作金额执行转账操作</li><li>基于Spring整合MyBatis环境搭建上述操作</li></ol><h3 id="转账案例–环境搭建"><a href="#转账案例–环境搭建" class="headerlink" title="转账案例–环境搭建"></a>转账案例–环境搭建</h3><ol><li><p>准备数据表<br>Tom和Jerry初始金额都是1000</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE spring_db <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8;</span><br><span class="line">USE spring_db;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl_account(</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">    NAME <span class="type">VARCHAR</span>(<span class="number">35</span>),</span><br><span class="line">    money <span class="keyword">DOUBLE</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tbl_account(`name`,money) <span class="keyword">VALUES</span>(<span class="string">&#x27;Tom&#x27;</span>,<span class="number">1000</span>),(<span class="string">&#x27;Jerry&#x27;</span>,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure></li><li><p>创建项目导入jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.46<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>根据表创建模型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(Integer id, String name, Double money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(Double money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Account&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, money=&quot;</span> + money +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Dao接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&quot;update tbl_account set money = money + #&#123;money&#125; where name = #&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">inMoney</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name,<span class="meta">@Param(&quot;money&quot;)</span> Double money)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&quot;update tbl_account set money = money - #&#123;money&#125; where name = #&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">outMoney</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name, <span class="meta">@Param(&quot;money&quot;)</span> Double money)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Service接口和实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> &#123;    </span><br><span class="line"><span class="comment">/**     </span></span><br><span class="line"><span class="comment">* 转账操作     </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> out 转出方     </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> in 转入方     </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> money 金额     </span></span><br><span class="line"><span class="comment">*/</span>    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out,String in,Double money)</span>;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">protected</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out, String in, Double money)</span> &#123;</span><br><span class="line">        accountDao.outMoney(out, money);</span><br><span class="line">        accountDao.inMoney(in, money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加jdbc.properties文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:13306/spring_db?useSSL=false</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">poassword.</span></span><br></pre></td></tr></table></figure></li><li><p>创建JdbcConfig配置类</p></li></ol>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li><p>创建MybatisConfig配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactoryBean</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        factory.setTypeAliasesPackage(<span class="string">&quot;com.blog.domain&quot;</span>);</span><br><span class="line">        factory.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MapperScannerConfigurer <span class="title function_">mapperScannerConfigurer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MapperScannerConfigurer</span> <span class="variable">msc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperScannerConfigurer</span>();</span><br><span class="line">        msc.setBasePackage(<span class="string">&quot;com.blog.dao&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> msc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建SpringConfig配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.blog&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;JdbcConfig.class, MyBatisConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = SpringConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTransfer</span><span class="params">()</span> &#123;</span><br><span class="line">        accountService.transfer(<span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Jerry&quot;</span>, <span class="number">100D</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="事务管理-1"><a href="#事务管理-1" class="headerlink" title="事务管理"></a>事务管理</h3><p>上述环境，运行单元测试类，会执行转账操作，<code>Tom</code>的账户会减少100，<code>Jerry</code>的账户会加100。</p><p>这是正常情况下的运行结果，但是如果在转账的过程中出现了异常，如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">protected</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out, String in, Double money)</span> &#123;</span><br><span class="line">        accountDao.outMoney(out, money);</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        accountDao.inMoney(in, money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候就模拟了转账过程中出现异常的情况，此时进行转账，<code>Tom</code>的账户会减少100，而<code>Jerry</code>的账户却不会增加100<br>那我们来分析一下刚才的结果</p><ul><li>程序正常执行时，账户金额A减B加，没有问题</li><li>程序出现异常后，转账失败，但是异常之前操作成功，异常之后操作失败，整体业务失败</li></ul><p>当程序出问题后，我们需要让事务进行回滚，而且这个事务应该是加在业务层上，而Spring的事务管理就是用来解决这类问题的。</p><p>Spring事务管理具体的实现步骤如下：</p><ol><li><p>在需要被事务管理的方法上添加<code>@Transactional</code>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">protected</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out, String in, Double money)</span> &#123;</span><br><span class="line">        accountDao.outMoney(out, money);</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        accountDao.inMoney(in, money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意:<code>@Transactional</code>可以写在接口类上、接口方法上、实现类上和实现类方法上</p><ul><li>写在接口类上，该接口的所有实现类的所有方法都会有事务</li><li>写在接口方法上，该接口的所有实现类的该方法都会有事务</li><li>写在实现类上，该类中的所有方法都会有事务</li><li>写在实现类方法上，该方法上有事务</li><li><code>建议写在实现类或实现类的方法上</code></li></ul></blockquote></li><li><p>在JdbcConfig类中配置事务管理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置事务管理器，mybatis使用的是jdbc事务</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PlatformTransactionManager <span class="title function_">platformTransactionManager</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">DataSourceTransactionManager</span> <span class="variable">transactionManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">        transactionManager.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> transactionManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：事务管理器要根据使用技术进行选择，Mybatis框架使用的是JDBC事务，可以直接使用<code>DataSourceTransactionManager</code></p></blockquote></li><li><p>开启事务注解<code>@EnableTransactionManagement</code></p></li><li><p>运行测试类<br>运行程序之后，我们去数据库查看Tom和Jerry的金额，发现没有变化<br>那么说明在转换的业务出现错误后，事务就可以控制回滚，保证数据的正确性</p></li></ol><h3 id="注解介绍"><a href="#注解介绍" class="headerlink" title="注解介绍"></a>注解介绍</h3><p>知识点1：<code>@EnableTransactionManagement</code></p><table><thead><tr><th align="center">名称</th><th align="center">@EnableTransactionManagement</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">配置类注解</td></tr><tr><td align="center">位置</td><td align="center">配置类定义上方</td></tr><tr><td align="center">作用</td><td align="center">设置当前Spring环境中开启注解式事务支持</td></tr></tbody></table><p>知识点2：<code>@Transactional</code></p><table><thead><tr><th align="center">名称</th><th align="center">@Transactional</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">接口注解 类注解 方法注解</td></tr><tr><td align="center">位置</td><td align="center">业务层接口上方 业务层实现类上方 业务方法上方</td></tr><tr><td align="center">作用</td><td align="center">为当前业务层方法添加事务（如果设置在类或接口上方则类或接口中所有方法均添加事务）</td></tr></tbody></table><h2 id="Spring事务角色"><a href="#Spring事务角色" class="headerlink" title="Spring事务角色"></a>Spring事务角色</h2><p>这部分我们重点要理解两个概念，分别是<code>事务管理员</code>和<code>事务协调员</code>。</p><p>当未开启Spring事务之前</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310072142554.png"></p><p>AccountDao的outMoney因为是修改操作，会开启一个事务T1</p><p>AccountDao的inMoney因为是修改操作，会开启一个事务T2</p><p>AccountService的transfer没有事务，</p><ul><li>运行过程中如果没有抛出异常，则T1和T2都正常提交，数据正确</li><li>如果在两个方法中间抛出异常，T1因为执行成功提交事务，T2因为抛异常不会被执行</li><li>就会导致数据出现错误</li></ul><p>当开启Spring的事务管理后<br><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310072143681.png"></p><p>transfer上添加了@Transactional注解，在该方法上就会有一个事务T</p><p>AccountDao的outMoney方法的事务T1加入到transfer的事务T中</p><p>AccountDao的inMoney方法的事务T2加入到transfer的事务T中</p><p>这样就保证他们在同一个事务中，当业务层中出现异常，整个事务就会回滚，保证数据的准确性。</p><p>通过上面例子的分析，我们就可以得到如下概念:</p><ul><li>事务管理员：发起事务方，在Spring中通常指代业务层开启事务的方法</li><li>事务协调员：加入事务方，在Spring中通常指代数据层方法，也可以是业务层方法</li></ul><blockquote><p>注意：目前的事务管理是基于<code>DataSourceTransactionManager</code>和<code>SqlSessionFactoryBean</code>使用的是同一个数据源。</p></blockquote><h2 id="Spring事务属性"><a href="#Spring事务属性" class="headerlink" title="Spring事务属性"></a>Spring事务属性</h2><p>这部分我们主要学习三部分内容<code>事务配置</code>、<code>转账业务追加日志</code>、<code>事务传播行为</code>。</p><h3 id="事务配置"><a href="#事务配置" class="headerlink" title="事务配置"></a>事务配置</h3><table><thead><tr><th align="center">属性</th><th align="center">作用</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">readOnly</td><td align="center">设置是否为只读事务</td><td align="center">readOnly &#x3D; true 只读事务</td></tr><tr><td align="center">timeout</td><td align="center">设置事务超时时间</td><td align="center">timeout &#x3D; -1(永不超时)</td></tr><tr><td align="center">rollbackFor</td><td align="center">设置事务回滚异常(class)</td><td align="center">rollbackFor{NullPointException.class}</td></tr><tr><td align="center">rollbackForClassName</td><td align="center">设置事务回滚异常（String)</td><td align="center">同上格式为字符串</td></tr><tr><td align="center">noRollbackFor</td><td align="center">设置事务不回滚异常(class)</td><td align="center">noRollbackFor{NullPointExceptior.class}</td></tr><tr><td align="center">noRollbackForClassName</td><td align="center">设置事务不回滚异常(String)</td><td align="center">同上格式为字符串</td></tr><tr><td align="center">isolation</td><td align="center">设置事务隔离级别</td><td align="center">isolation &#x3D; Isolation. DEFAULT</td></tr><tr><td align="center">propagation</td><td align="center">设置事务传播行为</td><td align="center">…</td></tr></tbody></table><p>上面这些属性都可以在<code>@Transactional</code>注解的参数上进行设置。</p><ul><li><p>readOnly：true只读事务，false读写事务，增删改要设为false,查询设为true。</p></li><li><p>timeout:设置超时时间单位秒，在多长时间之内事务没有提交成功就自动回滚，-1表示不设置超时时间。</p></li><li><p>rollbackFor:当出现指定异常进行事务回滚</p></li><li><p>noRollbackFor:当出现指定异常不进行事务回滚</p><ul><li><p>思考:出现异常事务会自动回滚，这个是我们之前就已经知道的</p></li><li><p>noRollbackFor是设定对于指定的异常不回滚，这个好理解</p></li><li><p>rollbackFor是指定回滚异常，对于异常事务不应该都回滚么，为什么还要指定?</p><ul><li><p>事实上Spring的事务只会对<code>Error异常</code>和<code>RuntimeException异常</code>及其子类进行事务回顾，其他的异常类型是不会回滚的，如下面的代码就不会回滚</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">protected</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out, String in, Double money)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        accountDao.outMoney(out, money);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">true</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>();</span><br><span class="line">        accountDao.inMoney(in, money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>有些异常它真不回滚</strong>，此时就可以使用rollbackFor属性来设置出现IOException异常不回滚</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">protected</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = &#123;IOException.class&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out, String in, Double money)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        accountDao.outMoney(out, money);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">true</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>();</span><br><span class="line">        accountDao.inMoney(in, money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>rollbackForClassName等同于rollbackFor,只不过属性为异常的类全名字符串</p></li><li><p>noRollbackForClassName等同于noRollbackFor，只不过属性为异常的类全名字符串</p></li><li><p>isolation设置事务的隔离级别</p><ul><li>DEFAULT :默认隔离级别, 会采用数据库的隔离级别</li><li>READ_UNCOMMITTED : 读未提交</li><li>READ_COMMITTED : 读已提交</li><li>REPEATABLE_READ : 重复读取</li><li>SERIALIZABLE: 串行化</li></ul></li></ul></li></ul></li></ul><p>介绍完上述属性后，还有最后一个事务的传播行为，为了讲解该属性的设置，我们需要完成下面的案例。</p><h3 id="转账业务追加日志案例"><a href="#转账业务追加日志案例" class="headerlink" title="转账业务追加日志案例"></a>转账业务追加日志案例</h3><p> 需求分析</p><ul><li><p>在前面的转账案例的基础上添加新的需求，完成转账后记录日志。</p><ul><li>需求：实现任意两个账户间转账操作，并对每次转账操作在数据库进行留痕</li><li>需求微缩：A账户减钱，B账户加钱，数据库记录日志</li></ul></li><li><p>基于上述的业务需求，我们来分析下该如何实现：</p><ol><li>基于转账操作案例添加日志模块，实现数据库中记录日志</li><li>业务层转账操作（transfer），调用减钱、加钱与记录日志功能</li></ol></li><li><p>需要注意一点就是，我们这个案例的预期效果为:</p><ul><li><strong><code>无论转账操作是否成功，均进行转账操作的日志留痕</code></strong></li></ul></li></ul><p>环境准备：</p><ol><li><p>创建日志表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tbl_log(</span><br><span class="line">   id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">   info <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">   createDate datetime</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>添加LogDao接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LogDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into tbl_log(info, createDate) VALUES (#&#123;info&#125;,now())&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String info)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加LogService接口和实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LogService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String out, String in, Double money)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">LogService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LogDao logDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String out, String in, Double money)</span> &#123;</span><br><span class="line">        logDao.log(out + <span class="string">&quot;向&quot;</span> + in + <span class="string">&quot;转账&quot;</span> + money + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在转账的业务中添加记录日志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">protected</span> AccountDao accountDao;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">protected</span> LogService logService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = &#123;IOException.class&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out, String in, Double money)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            accountDao.outMoney(out, money);</span><br><span class="line">            accountDao.inMoney(in, money);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            logService.log(out, in, money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行程序</p><ul><li>当程序正常运行，tbl_account表中转账成功，tbl_log表中日志记录成功</li><li>当转账业务之间出现异常(int i &#x3D;1 &#x2F; 0),转账失败，tbl_account成功回滚，但是tbl_log表未添加数据，说明也回滚了</li><li>这个结果和我们想要的不一样，什么原因?该如何解决?<ul><li>失败原因：日志的记录与转账操作隶属同一个事务，同成功同失败（同回滚）</li><li>解决方案：继续往下看</li><li>预期效果：无论转账操作是否成功，日志必须保留</li></ul></li></ul></li></ol><h3 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h3><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310072149242.png"></p><p>对于上述案例的分析:</p><ul><li>log方法、inMoney方法和outMoney方法都属于增删改，分别有事务T1,T2,T3</li><li>transfer因为加了<code>@Transactional</code>注解，也开启了事务T</li><li>前面我们讲过Spring事务会把T1,T2,T3都加入到事务T中</li><li>所以当转账失败后，<code>所有的事务都回滚</code>，导致日志没有记录下来</li><li>这和我们的需求不符，这个时候我们就想能不能让log方法单独是一个事务呢?</li></ul><p>要想解决这个问题，就需要用到事务传播行为，所谓的事务传播行为指的是:</p><ul><li><p>事务传播行为：事务协调员对事务管理员所携带事务的处理态度。</p><ul><li>具体如何解决，就需要用到之前我们没有说的<code>propagation属性</code>。</li></ul></li><li><p>修改logService改变事务的传播行为</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">LogService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LogDao logDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String out, String in, Double money)</span> &#123;</span><br><span class="line">        logDao.log(out + <span class="string">&quot;向&quot;</span> + in + <span class="string">&quot;转账&quot;</span> + money + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后，就能实现我们想要的结果，不管转账是否成功，都会记录日志。</p><p>事务传播行为的可选值</p><table><thead><tr><th>传播属性</th><th>事务管理员</th><th>事务协调员</th></tr></thead><tbody><tr><td>REQUIRED(默认)</td><td>开启T</td><td>加入T</td></tr><tr><td>无</td><td>新建T2</td><td></td></tr><tr><td>REQUIRES_NEW</td><td>开启T</td><td>新建T2</td></tr><tr><td>无</td><td>新建T2</td><td></td></tr><tr><td>SUPPORTS</td><td>开启T</td><td>加入T</td></tr><tr><td>无</td><td>无</td><td></td></tr><tr><td>NOT_SUPPORTED</td><td>开启T</td><td>无</td></tr><tr><td>无</td><td>无</td><td></td></tr><tr><td>MANDTORY</td><td>开启T</td><td>加入T</td></tr><tr><td>无</td><td>ERROR</td><td></td></tr><tr><td>NEVER</td><td>开启T</td><td>ERROR</td></tr><tr><td>无</td><td>无</td><td></td></tr><tr><td>NESTED</td><td>设置savePoint,一旦事务回滚，事务将回滚到savePoint处，交由客户响应提交&#x2F;回滚</td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
            <tag> Spring </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-AOP</title>
      <link href="/2023/09/04/Spring05AOP/"/>
      <url>/2023/09/04/Spring05AOP/</url>
      
        <content type="html"><![CDATA[<h1 id="AOP概念"><a href="#AOP概念" class="headerlink" title="AOP概念"></a>AOP概念</h1><p>AOP，Aspect Oriented Programming，面向切面编程，是对面向对象编程OOP的升华。OOP是纵向对一个事物的抽象，一个对象包括静态的属性信息，包括动态的方法信息等。而AOP是横向的对不同事物的抽象，属性与属性、方法与方法、对象与对象都可以组成一个切面，而用这种思维去设计编程的方式叫做面向切面编程</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231111221215308.png" alt="image-20231111221215308"></p><h2 id="AOP核心概念"><a href="#AOP核心概念" class="headerlink" title="AOP核心概念"></a>AOP核心概念</h2><ol><li>前面一直在强调，Spring的AOP是对一个类的方法在不进行任何修改的前提下实现增强。对于上面的案例中BookServiceImpl中有<code>save</code>,<code>update</code>,<code>delete</code>和<code>select</code>方法,这些方法我们给起了一个名字叫<code>连接点</code></li><li>在BookServiceImpl的四个方法中，<code>update</code>和<code>delete</code>只有打印没有计算万次执行消耗时间，但是在运行的时候已经有该功能，那也就是说<code>update</code>和<code>delete</code>方法都已经被增强，所以对于需要增强的方法我们给起了一个名字叫<code>切入点</code></li><li>执行BookServiceImpl的update和delete方法的时候都被添加了一个计算万次执行消耗时间的功能，将这个功能抽取到一个方法中，换句话说就是存放共性功能的方法，我们给起了个名字叫<code>通知</code></li><li>通知是要增强的内容，会有多个，切入点是需要被增强的方法，也会有多个，那哪个切入点需要添加哪个通知，就需要提前将它们之间的关系描述清楚，那么对于通知和切入点之间的关系描述，我们给起了个名字叫<code>切面</code></li><li>通知是一个方法，方法不能独立存在需要被写在一个类中，这个类我们也给起了个名字叫<code>通知类</code></li></ol><p>总结如下：</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310071525128.png"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231111222800685.png" alt="image-20231111222800685"></p><table><thead><tr><th>概念</th><th>单词</th><th>解释</th></tr></thead><tbody><tr><td>目标对象</td><td>Target</td><td>被增强的方法所在的对象</td></tr><tr><td>代理对象</td><td>Proxy</td><td>对目标对象进行增强后的对象，客户端实际调用的对象</td></tr><tr><td>连接点</td><td>Joinpoint</td><td>目标对象中可以被增强的方法</td></tr><tr><td>切入点</td><td>Pointcut</td><td>目标对象中实际被增强的方法</td></tr><tr><td>通知\增强</td><td>Advice</td><td>增强部分的代码逻辑</td></tr><tr><td>切面</td><td>Aspect</td><td>增强和切入点的组合</td></tr><tr><td>织入</td><td>Weaving</td><td>将通知和切入点组合动态组合的过程</td></tr></tbody></table><ul><li><p>连接点(JoinPoint)：程序执行过程中的任意位置，粒度为执行方法、抛出异常、设置变量等。在SpringAOP中，理解为方法的执行</p></li><li><p>切入点(Pointcut)：匹配连接点的式子。在SpringAOP中，一个切入点可以描述一个具体方法，也可也匹配多个方法</p><ul><li><p>一个具体的方法：如com.blog.dao包下的BookDao接口中的无形参无返回值的save方法</p></li><li><p>匹配多个方法：所有的save方法&#x2F;所有的get开头的方法&#x2F;所有以Dao结尾的接口中的任意方法&#x2F;所有带有一个参数的方法</p></li><li><p>连接点范围要比切入点范围大，是切入点的方法也一定是连接点，但是是连接点的方法就不一定要被增强，所以可能不是切入点。</p></li></ul></li><li><p>通知(Advice)：在切入点处执行的操作，也就是共性功能（加强的那部分功能）。在SpringAOP中，功能最终以方法的形式呈现</p></li><li><p>通知类：定义通知的类</p></li><li><p>切面(Aspect)：描述通知与切入点的对应关系。</p></li></ul><p>这部分需要掌握的内容是</p><ul><li>什么是AOP?</li><li>AOP的作用是什么?</li><li>AOP中核心概念分别指的是什么?<ul><li>连接点</li><li>切入点</li><li>通知</li><li>通知类</li><li>切面</li></ul></li></ul><h1 id="AOP入门案例"><a href="#AOP入门案例" class="headerlink" title="AOP入门案例"></a>AOP入门案例</h1><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">环境准备</button></li><li class="tab"><button type="button" data-href="#test1-2">AOP实现</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><ol><li><p>创建一个Maven项目</p></li><li><p>pom.xml添加Spring依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加BookDao和BookDaoImpl类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao update ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Spring的配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.blog&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写App运行类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> context.getBean(BookDao.class);</span><br><span class="line">        bookDao.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>说明:</strong></p><ul><li>目前打印save方法的时候，因为方法中有打印系统时间，所以运行的时候是可以看到系统时间</li><li>对于update方法来说，就没有该功能</li><li>我们要使用SpringAOP的方式在不改变update方法的前提下让其具有打印系统时间的功能。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><ol><li><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为<code>spring-context</code>中已经导入了<code>spring-aop</code>,所以不需要再单独导入<code>spring-aop</code><br>导入AspectJ的jar包,AspectJ是AOP思想的一个具体实现，Spring有自己的AOP实现，但是相比于AspectJ来说比较麻烦，所以我们直接采用Spring整合ApsectJ的方式进行AOP开发。</p></li><li><p>定义接口和实现类<br>准备环境的时候我们已经完成了</p></li><li><p>定义通知类和通知<br>通知就是将共性功能抽取出来后形成的方法，共性功能指的就是当前系统时间的打印。<br>类名和方法名没有要求，可以任意。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义切入点<br>BookDaoImpl中有两个方法，分别是update()和save()，我们要增强的是update方法，那么该如何定义呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.blog.dao.impl.BookDaoImpl.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>切入点定义依托一个不具有实际意义的方法进行，即无参数、无返回值、方法体无实际逻辑。</li><li>execution及后面编写的内容，之后我们会专门去学习。</li></ul></li><li><p>制作切面<br>切面是用来描述通知和切入点之间的关系，如何进行关系的绑定?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.blog.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绑定切入点与通知关系，并指定通知添加到原始连接点的具体执行<code>位置</code></p><p>说明：<code>@Before</code>翻译过来是之前，也就是说通知会在切入点方法执行之前执行，除此之前还有其他四种类型，后面会讲。<br>那这里就会在执行update()之前，来执行我们的method()，输出当前毫秒值</p></li><li><p>将通知类配给容器并标识其为切面类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.blog.dao.impl.BookDaoImpl.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开启注解格式AOP功能。使用<code>@EnableAspectJAutoProxy</code>注解</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="AOP使用"><a href="#AOP使用" class="headerlink" title="AOP使用"></a>AOP使用</h1><h2 id="xml方式"><a href="#xml方式" class="headerlink" title="xml方式"></a>xml方式</h2><h3 id="xml方式AOP快速入门"><a href="#xml方式AOP快速入门" class="headerlink" title="xml方式AOP快速入门"></a>xml方式AOP快速入门</h3><p>通过配置文件的方式去解决上述问题</p><ol><li>配置哪些包、哪些类、哪些方法需要被增强</li><li>配置目标方法要被哪些通知方法所增强，在目标方法执行之前还是之后执行增强</li></ol><p>配置方式的设计、配置文件（注解）的解析工作，Spring已经帮我们封装好了</p><p>步骤： </p><ol><li><p>导入AOP相关坐标</p><p>Spring-context坐标下已经包含spring-aop的包了，所以就不用额外导入</p><p>但要导入aspectj包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>准备目标类、准备增强类，并配置给Spring管理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show1...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show2...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeAdvice</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;beforeAdvice&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterAdvice</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterAdvice&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置目标类,内部的方法是连接点--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.UserServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置通知类,内部的方法是增强方法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">“myAdvice</span>&quot; <span class="attr">class</span>=<span class="string">&quot;com.itheima.advice.MyAdvice&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置切点表达式（哪些方法被增强）</p></li><li><p>配置织入（切点被哪些通知方法增强，是前置增强还是后置增强）</p><p>这个需要自定义命名空间</p><p>配置方法的时候方法名字不重要，确定方法的是属性不是方法名字</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置切点表达式,对哪些方法进行增强--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;myPointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(void com.itheima.service.impl.UserServiceImpl.show1())&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置织入--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--切面=切点+通知--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAdvice&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定前置通知方法是&quot;beforeAdvice&quot;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;beforeAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointcut&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定后置通知方法是afterAdvice--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;afterAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointcut&quot;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="xml方式AOP配置详解"><a href="#xml方式AOP配置详解" class="headerlink" title="xml方式AOP配置详解"></a>xml方式AOP配置详解</h3><p>AOP详细配置的细节： </p><ol><li>切点表达式的配置方式 </li><li>切点表达式的配置语法 </li><li>通知的类型 </li><li>AOP的配置的两种方式</li></ol><h4 id="切点表达式的配置方式"><a href="#切点表达式的配置方式" class="headerlink" title="切点表达式的配置方式"></a>切点表达式的配置方式</h4><p>切点表达式的配置方式有两种，直接将切点表达式配置在通知上，也可以将切点表达式抽取到外面，在通知上进行引用</p><div class="tabs" id="2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2-1">直接配置</button></li><li class="tab"><button type="button" data-href="#2-2">抽取引用</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2-1"><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;afterAdvice&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(void com.itheima.service.impl.UserServiceImpl.show1())&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>after-returning method：指出是增强什么的方法</p><p>pointcut：指出什么包的什么类的什么方法需要用到增强</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2-2"><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置切点表达式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;myPointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(void com.itheima.service.impl.UserServiceImpl.show1())&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 引用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAdvice&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;beforeAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointcut&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种方式用的多，一方面在配置多的时候简化编写，另一方面降低耦合</p><p>before method：指出是增强什么的方法</p><p>pointcut：指出什么包的什么类的什么方法需要用到增强</p><p>pointcut-ref：指出引用我们编好的哪一个切点</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h4 id="切点表达式的语法"><a href="#切点表达式的语法" class="headerlink" title="切点表达式的语法"></a>切点表达式的语法</h4><p>切点表达式是配置要对哪些连接点（哪些类的哪些方法）进行通知的增强，语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution([访问修饰符]返回值类型 包名.类名.方法名(参数))</span><br></pre></td></tr></table></figure><ol><li>访问修饰符可以省略不写</li><li>返回值类型、某一级包名、类名、方法名 可以使用 * 表示任意</li><li>包名与类名之间使用单点 . 表示该包下的类，使用双点 .. 表示该包及其子包下的类</li><li>参数列表可以使用两个点 .. 表示任意参数。</li></ol><p>切点表达式举几个例子方便理解，读的时候建议从后向前读</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示访问修饰符为public、无返回值、在com.itheima.aop包下的TargetImpl类的无参方法show</span></span><br><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com.itheima.aop.TargetImpl.show());</span><br><span class="line"><span class="comment">//表述com.itheima.aop包下的TargetImpl类的任意方法</span></span><br><span class="line">execution(* com.itheima.aop.TargetImpl.*(..));</span><br><span class="line"><span class="comment">//表示com.itheima.aop包下的任意类的任意方法</span></span><br><span class="line">execution(* com.itheima.aop.*.*(..));</span><br><span class="line"><span class="comment">//表示com.itheima.aop包及其子包下的任意类的任意方法</span></span><br><span class="line">execution(* com.itheima.aop..*.*(..));</span><br><span class="line"><span class="comment">//表示任意包中的任意类的任意方法</span></span><br><span class="line">execution(* *..*.*(..));</span><br></pre></td></tr></table></figure><h4 id="通知的类型"><a href="#通知的类型" class="headerlink" title="通知的类型"></a>通知的类型</h4><table><thead><tr><th>通知名称</th><th>配置方式</th><th>执行时机</th></tr></thead><tbody><tr><td>前置通知</td><td>&lt; aop:before &gt;</td><td>目标方法执行之前执行</td></tr><tr><td>后置通知</td><td>&lt; aop:after-returning &gt;</td><td>目标方法执行之后执行，目标方法异常时，不在执行</td></tr><tr><td>环绕通知</td><td>&lt; aop:around &gt;</td><td>目标方法执行前后执行，目标方法异常时，环绕后方法不在执行</td></tr><tr><td>异常通知</td><td>&lt; aop:after-throwing &gt;</td><td>目标方法抛出异常时执行</td></tr><tr><td>最终通知</td><td>&lt; aop:after &gt;</td><td>不管目标方法是否有异常，最终都会执行</td></tr></tbody></table><ul><li><p>环绕通知（常用）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">//环绕前</span></span><br><span class="line">    System.out.println(<span class="string">&quot;环绕前通知&quot;</span>);</span><br><span class="line">    <span class="comment">//目标方法</span></span><br><span class="line">    joinPoint.proceed();</span><br><span class="line">    <span class="comment">//环绕后</span></span><br><span class="line">    System.out.println(<span class="string">&quot;环绕后通知&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;around&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointcut&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>异常通知</p><p>当目标方法抛出异常时，异常通知方法执行，且后置通知和环绕后通知不在执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;目标方法抛出异常了，后置通知和环绕后通知不在执行&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;afterThrowing&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointcut&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>异常通知</p><p>类似异常捕获中的finally，不管目标方法有没有异常，最终都会执行的通知</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;不管目标方法有无异常，我都会执行&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointcut&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="通知方法传参"><a href="#通知方法传参" class="headerlink" title="通知方法传参"></a>通知方法传参</h4><p>通知方法在被调用时，Spring可以为其传递一些必要的参数</p><table><thead><tr><th>参数类型</th><th>作用</th></tr></thead><tbody><tr><td>JoinPoint</td><td>连接点对象，任何通知都可使用，可以获得当前目标对象、目标方法参数等信息</td></tr><tr><td>ProceedingJoinPoint</td><td>JoinPoint子类对象，主要是在环绕通知中执行proceed()，进而执行目标方法</td></tr><tr><td>Throwable</td><td>异常对象，使用在异常通知中，需要在配置文件中指出异常对象名称</td></tr></tbody></table><p>JoinPoint 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> 通知方法名称(JoinPoint joinPoint)&#123;</span><br><span class="line">    <span class="comment">//获得目标方法的参数</span></span><br><span class="line">    System.out.println(joinPoint.getArgs());</span><br><span class="line">    <span class="comment">//获得目标对象</span></span><br><span class="line">    System.out.println(joinPoint.getTarget());</span><br><span class="line">    <span class="comment">//获得精确的切点表达式信息</span></span><br><span class="line">    System.out.println(joinPoint.getStaticPart());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProceedingJoinPoint对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">//获得目标方法的参数</span></span><br><span class="line">    System.out.println(joinPoint.getArgs());</span><br><span class="line">    <span class="comment">//获得目标对象</span></span><br><span class="line">    System.out.println(joinPoint.getTarget());</span><br><span class="line">    <span class="comment">//获得精确的切点表达式信息</span></span><br><span class="line">    System.out.println(joinPoint.getStaticPart());</span><br><span class="line">    <span class="comment">//执行目标方法</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> joinPoint.proceed();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Throwable对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(JoinPoint joinPoint,Throwable th)</span>&#123;</span><br><span class="line">    <span class="comment">//获得异常信息</span></span><br><span class="line">    System.out.println(<span class="string">&quot;异常对象是：&quot;</span>+th+<span class="string">&quot;异常信息是：&quot;</span>+th.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;afterThrowing&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointcut&quot;</span> <span class="attr">throwing</span>=<span class="string">&quot;th&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="AOP的Advicor方式"><a href="#AOP的Advicor方式" class="headerlink" title="AOP的Advicor方式"></a>AOP的Advicor方式</h3><p>该方式需要通知类实现Advicor的子功能接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Advice</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>Advice的子功能接口</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231111230428820.png" alt="image-20231111230428820"></p><ol><li><p>通知类实现了前置通知和后置通知接口，通过实现不同的子接口，指明该类中的方法在哪里增强</p><p>这些接口有编写规范，里面的方法固定和增强方法绑定，如before方法就是前置通知</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现子接口来实现通知</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Advices</span> <span class="keyword">implements</span> <span class="title class_">MethodBeforeAdvice</span>, AfterReturningAdvice &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(Method method, Object[] objects, Object o)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is before Advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(Object o, Method method, Object[] objects, Object o1)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is afterReturn Advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>切面使用advisor标签配</p><p>因为接口有一定的规范，所以配置XML时不用指明通知方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 将通知和切点进行结合 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;advices&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(void com.itheima.aop.TargetImpl.show())&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="aspect和advisor配置区别"><a href="#aspect和advisor配置区别" class="headerlink" title="aspect和advisor配置区别"></a>aspect和advisor配置区别</h4><ol><li><p>配置语法不同：</p><p>使用advisor配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- advice-ref:通知Bean的id --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;advices&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(void com.itheima.aop.TargetImpl.show())&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用aspect配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ref:通知Bean的id --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;advices&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(void com.itheima.aop.TargetImpl.show())&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>通知类的定义要求不同</p><p>advisor 需要的通知类需要实现Advice的子功能接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Advices</span> <span class="keyword">implements</span> <span class="title class_">MethodBeforeAdvice</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(Method method, Object[] objects, Object o)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is before Advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(Object o, Method method, Object[] objects, Object o1)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is afterReturn Advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>aspect 不需要通知类实现任何接口，在配置的时候指定哪些方法属于哪种通知类型即可，更加灵活方便：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Advices</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is before Advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;This is afterReturn Advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可配置的切面数量不同</p><p>一个advisor只能配置一个固定通知和一个切点表达式 </p><p>一个aspect可以配置多个通知和多个切点表达式任意组合，粒度更细。</p></li><li><p>使用场景不同</p><ul><li>如果通知类型多、允许随意搭配情况下可以使用aspect进行配置</li><li>如果通知类型单一、且通知类中通知方法一次性都会使用到的情况下可以使用advisor进行配置</li><li><strong>在通知类型已经固定，不用人为指定通知类型时，可以使用advisor进行配置，例如后面要学习的Spring事务控制的配置，等导入第三方配置</strong></li></ul></li></ol><blockquote><p>由于实际开发中，自定义aop功能的配置大多使用aspect的配置方式，所以我们后面主要讲解aspect的配置， advisor是为了后面Spring声明式事务控制做铺垫，此处大家了解即可。</p></blockquote><h3 id="xml方式AOP原理剖析"><a href="#xml方式AOP原理剖析" class="headerlink" title="xml方式AOP原理剖析"></a>xml方式AOP原理剖析</h3><p>通过xml方式配置AOP时，我们引入了AOP的命名空间，根据讲解的，要去找spring-aop包下的META-INF，在去 找spring.handlers文件，最终加载的是 AopNamespaceHandler，该Handler的init方法中注册了config标签对应的解析器</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231112115711785.png" alt="image-20231112115711785"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http\://www.springframework.org/schema/aop=org.springframework.aop.config.AopNamespaceHandler</span><br></pre></td></tr></table></figure><p>最终加载的是 AopNamespaceHandler，该Handler的init方法中注册了config标签对应的解析器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">   registerBeanDefinitionParser(<span class="string">&quot;config&quot;</span>, <span class="keyword">new</span> <span class="title class_">ConfigBeanDefinitionParser</span>());</span><br><span class="line">   registerBeanDefinitionParser(<span class="string">&quot;aspectj-autoproxy&quot;</span>, <span class="keyword">new</span> <span class="title class_">AspectJAutoProxyBeanDefinitionParser</span>());</span><br><span class="line">   registerBeanDefinitionDecorator(<span class="string">&quot;scoped-proxy&quot;</span>, <span class="keyword">new</span> <span class="title class_">copedProxyBeanDefinitionDecorator</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基于注解配置的AOP"><a href="#基于注解配置的AOP" class="headerlink" title="基于注解配置的AOP"></a>基于注解配置的AOP</h2><h3 id="注解方式AOP基本使用"><a href="#注解方式AOP基本使用" class="headerlink" title="注解方式AOP基本使用"></a>注解方式AOP基本使用</h3><p>xml配置AOP时，我们主要配置了三部分：</p><ol><li>目标类被Spring容器管理</li><li>通知类被Spring管理</li><li>通知与切点的织入（切面）</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置目标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;target&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.aop.TargetImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置通知--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;advices&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.aop.Advices&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置织入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;advices&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;around&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.itheima.aop.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中，<strong>目标类被Spring容器管理</strong>和<strong>通知类被Spring管理</strong>通过注解放入spring容器中就能完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;target&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TargetImpl</span> <span class="keyword">implements</span> <span class="title class_">Target</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show Target running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnoAdvice</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕前通知...&quot;</span>);</span><br><span class="line">        joinPoint.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕后通知...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要修改的主要是第三部分，还是使用注解实现</p><ol start="0"><li><p>开启组件扫描</p></li><li><p>在类上加注解 </p></li><li><p>在方法上加注解</p></li><li><p>配置xml，告诉spring我们要使用注解，开启aop的自动地代理功能<code>&lt;aop:aspectj-autoproxy/&gt;</code></p><p>或者可以在核心配置类上加注解<code>@EnableAspectJAutoProxy</code></p></li></ol><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231112122954205.png" alt="image-20231112122954205"></p><h3 id="注解方式AOP配置详解"><a href="#注解方式AOP配置详解" class="headerlink" title="注解方式AOP配置详解"></a>注解方式AOP配置详解</h3><h4 id="各种注解方式通知类型"><a href="#各种注解方式通知类型" class="headerlink" title="各种注解方式通知类型"></a>各种注解方式通知类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前置通知</span></span><br><span class="line"><span class="meta">@Before(&quot;execution(* com.itheima.aop.*.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置通知</span></span><br><span class="line"><span class="meta">@AfterReturning(&quot;execution(* com.itheima.aop.*.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">AfterReturning</span><span class="params">(JoinPoint joinPoint)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//环绕通知</span></span><br><span class="line"><span class="meta">@Around(&quot;execution(* com.itheima.aop.*.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//异常通知</span></span><br><span class="line"><span class="meta">@AfterThrowing(&quot;execution(* com.itheima.aop.*.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">AfterThrowing</span><span class="params">(JoinPoint joinPoint)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最终通知</span></span><br><span class="line"><span class="meta">@After(&quot;execution(* com.itheima.aop.*.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">After</span><span class="params">(JoinPoint joinPoint)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="切点表达式的抽取"><a href="#切点表达式的抽取" class="headerlink" title="切点表达式的抽取"></a>切点表达式的抽取</h4><p>使用一个空方法，将切点表达式标注在空方法上，其他通知方法引用即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnoAdvice</span> &#123;</span><br><span class="line">    <span class="comment">//切点表达式抽取</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.itheima.aop.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointcut</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前置通知</span></span><br><span class="line">    <span class="comment">//这里引的时候用的方法名</span></span><br><span class="line">    <span class="meta">@Before(&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后置通知</span></span><br><span class="line">    <span class="comment">//这里用的时候类似静态方法</span></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;AnnoAdvice.pointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">AfterReturning</span><span class="params">(JoinPoint joinPoint)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注解讲解"><a href="#注解讲解" class="headerlink" title="注解讲解"></a>注解讲解</h3><table><thead><tr><th>名称</th><th>类型</th><th>位置</th><th>作用</th><th>属性</th></tr></thead><tbody><tr><td>@EnableAspectJAutoProxy</td><td>配置类注解</td><td>配置类定义上方</td><td>开启注解格式AOP功能</td><td></td></tr><tr><td>@Aspect</td><td>类注解</td><td>切面类定义上方</td><td>设置当前类为AOP切面类</td><td></td></tr><tr><td>@Pointcut</td><td>方法注解</td><td>切入点方法定义上方</td><td>设置切入点方法</td><td>value（默认）：切入点表达式</td></tr><tr><td>@Before</td><td>方法注解</td><td>通知方法定义上方</td><td>置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前运行</td><td></td></tr><tr><td>@After</td><td>方法注解</td><td>通知方法定义上方</td><td>设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法后运行</td><td></td></tr><tr><td>@AfterReturning</td><td>方法注解</td><td>通知方法定义上方</td><td>设置当前通知方法与切入点之间绑定关系，当前通知方法在原始切入点方法正常执行完毕后执行</td><td></td></tr><tr><td>@AfterThrowing</td><td>方法注解</td><td>通知方法定义上方</td><td>设置当前通知方法与切入点之间绑定关系，当前通知方法在原始切入点方法运行抛出异常后执行</td><td></td></tr><tr><td>@Around</td><td>方法注解</td><td>通知方法定义上方</td><td>设置当前通知方法与切入点之间的绑定关系，当前通知方法在原始切入点方法前后运行</td><td></td></tr></tbody></table><h1 id="AOP配置管理"><a href="#AOP配置管理" class="headerlink" title="AOP配置管理"></a>AOP配置管理</h1><h2 id="AOP切入点表达式（给谁加）"><a href="#AOP切入点表达式（给谁加）" class="headerlink" title="AOP切入点表达式（给谁加）"></a>AOP切入点表达式（给谁加）</h2><p>首先我们先要明确两个概念:</p><ul><li>切入点：要进行增强的方法</li><li>切入点表达式：要进行增强的方法的描述方式</li></ul><p>对于AOP中切入点表达式，我们总共会学习三个内容，分别是<code>语法格式</code>、<code>通配符</code>和<code>书写技巧</code>。</p><p>对于切入点的描述，我们其实是有两中方式的，先来看下前面的例子</p><p>由于BookDaoImpl类实现了BookDao接口，那么有如下两种方式来描述：</p><ol><li><p>执行com.blog.dao包下的BookDao<strong>接口</strong>中的无参数update方法</p></li><li><p>执行com.blog.dao.impl包下的BookDaoImpl<strong>实现类</strong>中的无参数update方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">execution(<span class="keyword">void</span> com.blog.dao.BookDao.update())</span><br><span class="line">execution(<span class="keyword">void</span> com.blog.dao.impl.BookDaoImpl.update())</span><br></pre></td></tr></table></figure><p>因为调用接口方法的时候最终运行的还是其实现类的方法，所以上面两种描述方式都是可以的。</p></li></ol><p>对于切入点表达式的语法为:</p><p>切入点表达式标准格式：动作关键字(访问修饰符 返回值 包名.类&#x2F;接口名.方法名(参数) 异常名）<br>对于这个格式，我们不需要硬记，通过一个例子，理解它:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(<span class="keyword">public</span> User com.blog.service.UserService.findById(<span class="type">int</span>))</span><br></pre></td></tr></table></figure><ul><li>execution：动作关键字，描述切入点的行为动作，例如execution表示执行到指定切入点</li><li>public:访问修饰符,还可以是public，private等，可以省略</li><li>User：返回值，写返回值类型</li><li>com.blog.service：包名，多级包使用点连接</li><li>UserService:类&#x2F;接口名称</li><li>findById：方法名</li><li>int:参数，直接写参数的类型，多个类型用逗号隔开</li><li>异常名：方法定义中抛出指定异常，可以省略</li></ul><p>切入点表达式就是要找到需要增强的方法，所以它就是对一个具体方法的描述，但是方法的定义会有很多，所以如果每一个方法对应一个切入点表达式，想想这块就会觉得将来编写起来会比较麻烦，有没有更简单的方式呢?</p><blockquote><p>使用通配符</p></blockquote><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><ol><li><p><code>*</code>:单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现<br>匹配com.blog包下的任意包中的UserService类或接口中所有find开头的带有一个参数的方法</p></li><li><p><code>..</code>：多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写<br>匹配com包下的任意包中的UserService类或接口中所有名称为findById的方法</p></li><li><p><code>+</code>：专用于匹配子类类型<br>这个使用率较低，描述子类的，<code>*Service+</code>，表示所有以Service结尾的接口的子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">execution（<span class="keyword">public</span> * com.blog.*.UserService.find*(*))</span><br><span class="line">execution（<span class="keyword">public</span> User com..UserService.findById(..))</span><br><span class="line">execution(* *..*Service+.*(..))</span><br></pre></td></tr></table></figure></li></ol><p>练习：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">匹配接口，能匹配到</span><br><span class="line">execution(<span class="keyword">void</span> com.blog.dao.BookDao.update())</span><br><span class="line"></span><br><span class="line">匹配实现类，能匹配到</span><br><span class="line">execution(<span class="keyword">void</span> com.blog.dao.impl.BookDaoImpl.update())</span><br><span class="line"></span><br><span class="line">返回值任意，能匹配到</span><br><span class="line">execution(* com.blog.dao.impl.BookDaoImpl.update())</span><br><span class="line"></span><br><span class="line">返回值任意，但是update方法必须要有一个参数，无法匹配，要想匹配需要在update接口和实现类添加参数</span><br><span class="line">execution(* com.blog.dao.impl.BookDaoImpl.update(*))</span><br><span class="line"></span><br><span class="line">返回值为<span class="keyword">void</span>,com包下的任意包三层包下的任意类的update方法，匹配到的是实现类，能匹配</span><br><span class="line">execution(<span class="keyword">void</span> com.*.*.*.*.update())</span><br><span class="line"></span><br><span class="line">返回值为<span class="keyword">void</span>,com包下的任意两层包下的任意类的update方法，匹配到的是接口，能匹配</span><br><span class="line">execution(<span class="keyword">void</span> com.*.*.*.update())</span><br><span class="line"></span><br><span class="line">返回值为<span class="keyword">void</span>，方法名是update的任意包下的任意类，能匹配</span><br><span class="line">execution(<span class="keyword">void</span> *..update())</span><br><span class="line"></span><br><span class="line">匹配项目中任意类的任意方法，能匹配，但是不建议使用这种方式，影响范围广</span><br><span class="line">execution(* *..*(..))</span><br><span class="line"></span><br><span class="line">匹配项目中任意包任意类下只要以u开头的方法，update方法能满足，能匹配</span><br><span class="line">execution(* *..u*(..))</span><br><span class="line"></span><br><span class="line">匹配项目中任意包任意类下只要以e结尾的方法，update和save方法能满足，能匹配</span><br><span class="line">execution(* *..*e(..))</span><br><span class="line"></span><br><span class="line">返回值为<span class="keyword">void</span>，com包下的任意包任意类任意方法，能匹配，*代表的是方法</span><br><span class="line">execution(<span class="keyword">void</span> com..*())</span><br><span class="line"></span><br><span class="line">将项目中所有业务层方法的以find开头的方法匹配</span><br><span class="line">execution(* com.blog.*.*Service.find*(..))</span><br><span class="line"></span><br><span class="line">将项目中所有业务层方法的以save开头的方法匹配</span><br><span class="line">execution(* com.blog.*.*Service.save*(..))</span><br></pre></td></tr></table></figure><h3 id="书写技巧"><a href="#书写技巧" class="headerlink" title="书写技巧"></a>书写技巧</h3><p>对于切入点表达式的编写其实是很灵活的，那么在编写的时候，有没有什么好的技巧让我们用用:</p><ul><li>所有代码按照标准规范开发，否则以下技巧全部失效</li><li>描述切入点通常<code>描述接口</code>，而不描述实现类,如果描述到实现类，就出现紧耦合了</li><li>访问控制修饰符针对接口开发均采用public描述（<code>可省略访问控制修饰符描述</code>）</li><li>返回值类型对于增删改类使用精准类型加速匹配，对于查询类使用<code>*</code>通配快速描述</li><li><code>包名</code>书写尽量不使用<code>..</code>匹配，效率过低，常用<code>*</code>做单个包描述匹配，或精准匹配</li><li><code>接口名/类名</code>书写名称与模块相关的采用<code>*</code>匹配，例如UserService书写成<code>*Service</code>，绑定业务层接口名</li><li>方法名书写以<code>动词</code>进行<code>精准匹配</code>，名词采用<code>*</code>匹配，例如<code>getById</code>书写成<code>getBy*</code>，<code>selectAll</code>书写成<code>selectAll</code></li><li>参数规则较为复杂，根据业务方法灵活调整</li><li>通常<code>不使用异常</code>作为<code>匹配</code>规则</li></ul><h2 id="AOP通知类型（往哪加）"><a href="#AOP通知类型（往哪加）" class="headerlink" title="AOP通知类型（往哪加）"></a>AOP通知类型（往哪加）</h2><p>AOP通知:</p><p>AOP通知描述了抽取的共性功能，根据共性功能抽取的位置不同，最终运行代码时要将其加入到合理的位置</p><p>共提供了5种通知类型</p><ul><li>前置通知 before</li><li>后置通知 after</li><li><code>环绕通知(重点)</code> around</li><li>返回后通知(了解) </li><li>抛出异常后通知(了解)</li></ul><p>环绕通知注意事项</p><ol><li>环绕通知必须依赖形参ProceedingJoinPoint才能实现对原始方法的调用，进而实现原始方法调用前后同时添加通知</li><li>通知中如果未使用ProceedingJoinPoint对原始方法进行调用将跳过原始方法的执行</li><li>对原始方法的调用可以不接收返回值，通知方法设置成void即可，如果接收返回值，最好设定为Object类型</li><li>原始方法的返回值如果是void类型，通知方法的返回值类型可以设置成void,也可以设置成Object</li><li>由于无法预知原始方法运行后是否会抛出异常，因此环绕通知方法必须要处理Throwable异常</li></ol><h3 id="环绕通知使用"><a href="#环绕通知使用" class="headerlink" title="环绕通知使用"></a>环绕通知使用</h3><p>因为环绕通知需要在原始方法的前后进行增强，所以环绕通知就必须要能对原始操作进行调用，具体如何实现?</p><p>在方法参数中添加<code>ProceedingJoinPoint</code>，同时在需要的位置使用<code>proceed()</code>调用原始操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.blog.dao.BookDao.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;around before advice ...&quot;</span>);</span><br><span class="line">        <span class="comment">//表示对原始操作的调用</span></span><br><span class="line">        pjp.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;around after advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学习完这5种通知类型，我们来思考下环绕通知是如何实现其他通知类型的功能的?</p><p>因为环绕通知是可以控制原始方法执行的，所以我们把增强的代码写在调用原始方法的不同位置就可以实现不同的通知类型的功能，如</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310071701617.png"></p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
            <tag> Spring </tag>
            
            <tag> Aop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-注解开发</title>
      <link href="/2023/09/03/Spring04%E6%B3%A8%E8%A7%A3/"/>
      <url>/2023/09/03/Spring04%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h1><p>Spring的IOC&#x2F;DI对应的配置开发就已经讲解完成，但是使用起来相对来说还是比较复杂的，复杂的地方在<code>配置文件</code>。<br>要想真正简化开发，就需要用到Spring的注解开发，Spring对注解支持的版本历程:</p><ul><li>2.0版开始支持注解</li><li>2.5版注解功能趋于完善</li><li>3.0版支持纯注解开发</li></ul><p>关于注解开发，这里会讲解两块内容<code>注解开发定义bean</code>和<code>纯注解开发</code>。<br>注解开发定义bean用的是2.5版提供的注解，纯注解开发用的是3.0版提供的注解。</p><blockquote><p><strong>项目环境和依赖注入处相同</strong></p></blockquote><h2 id="注解开发案例"><a href="#注解开发案例" class="headerlink" title="注解开发案例"></a>注解开发案例</h2><ol><li><p>删除原有的XML配置<br>将配置文件中的bean标签删除掉</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在Dao上添加注解<br>在BookDaoImpl类上添加<code>@Component</code>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;bookDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：@Component注解不可以添加在接口上，因为接口是无法创建对象的。</p></blockquote><p>Service上添加注解<br>在BookServiceImpl类上也添加<code>@Component</code>交给Spring框架管理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置Spring的注解包扫描<br>为了让Spring框架能够扫描到写在类上的注解，需要在配置文件上进行包扫描</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.blog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>说明：component-scan</p><ul><li>component:组件，Spring将管理的bean视作自己的一个组件</li><li>scan:扫描<br>base-package指定Spring框架扫描的包路径，它会扫描指定包及其子包中的所有类上的注解。</li><li>包路径越多<code>如:com.blog.dao.impl</code>，扫描的范围越小速度越快</li><li>包路径越少<code>如:com.blog</code>，扫描的范围越大速度越慢</li><li>一般扫描到项目的组织名称即Maven的groupId下<code>如:com.blog</code>即可</li></ul></li><li><p>运行程序</p><p>在App类中，从IOC容器中获取对应的bean对象</p><p>因为注解的不同，获取方式也不同，分为<strong>名称</strong>和<strong>类型</strong></p><ul><li>BookServiceImpl类没有起名称，所以在App中是按照类型来获取bean对象</li><li><code>@Component</code>注解如果不起名称，会有一个默认值就是<code>当前类名首字母小写</code>，所以也可以按照名称获取</li></ul><p>对于@Component注解，还衍生出了其他三个注解<code>@Controller</code>、<code>@Service</code>、<code>@Repository</code><br>通过查看源码会发现：这三个注解和@Component注解的作用是一样的，为什么要衍生出这三个呢?<br>这是方便我们后期在编写类的时候能很好的区分出这个类是属于<code>表现层</code>、<code>业务层</code>还是<code>数据层</code>的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//按照名称获取bean</span></span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) context.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        <span class="comment">//按照类型获取bean</span></span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> context.getBean(BookService.class);</span><br><span class="line">        bookDao.save();</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="纯注解开发模式"><a href="#纯注解开发模式" class="headerlink" title="纯注解开发模式"></a>纯注解开发模式</h2><p>上面已经可以使用注解来配置bean，但是依然有用到配置文件，在配置文件中对包进行了扫描，Spring在3.0版已经支持纯注解开发，使用Java类替代配置文件，开启了Spring快速开发赛道，那么具体如何实现?</p><p>实现思路为：将配置文件applicationContext.xml删掉，用配置类来替换</p><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol><li><p>创建配置类<br>创建一个配置类SpringConfig，这个名字就标识该类为配置类</p></li><li><p>在配置类上面加一个<code>@Configuration</code>注解，将其标识为一个配置类，用于替换掉<code>applicationContext.XML</code></p></li><li><p>用注解替换包扫描配置<br>在配置类上添加包扫描注解<code>@ComponentScan</code>替换<code>&lt;context:component-scan base-package=&quot;&quot;/&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.blog&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建运行类并执行<br>创建一个新的运行类<code>AppForAnnotation</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForAnnotation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) context.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> context.getBean(BookService.class);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行AppForAnnotation，可以看到两个对象依然被获取成功</p></li></ol><p>至此，纯注解开发的方式就已经完成了，主要内容包括：</p><ul><li><p>Java类替换Spring核心配置文件</p><ul><li><code>@Configuration</code>注解用于设定当前类为配置类</li><li><code>@ComponentScan</code>注解用于设定扫描路径，此注解只能添加一次，多个数据请用数组格式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(&#123;com.blog.service&quot;,&quot;com.blog.dao&quot;&#125;)</span></span><br></pre></td></tr></table></figure></li><li><p>读取Spring核心配置文件初始化容器对象切换为读取Java配置类初始化容器对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310061715496.png"></p><p>知识点：<code>@Configuration</code></p><table><thead><tr><th align="center">名称</th><th align="center">@Configuration</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">类注解</td></tr><tr><td align="center">位置</td><td align="center">类定义上方</td></tr><tr><td align="center">作用</td><td align="center">设置该类为spring配置类</td></tr><tr><td align="center">属性</td><td align="center">value（默认）：定义bean的id</td></tr></tbody></table><p>知识点：<code>@ComponentScan</code></p><table><thead><tr><th align="center">名称</th><th align="center">@ComponentScan</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">类注解</td></tr><tr><td align="center">位置</td><td align="center">类定义上方</td></tr><tr><td align="center">作用</td><td align="center">设置spring配置类扫描路径，用于加载使用注解格式定义的bean</td></tr><tr><td align="center">属性</td><td align="center">value（默认）：扫描路径，此路径可以逐层向下扫描</td></tr></tbody></table><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这部分要重点掌握的是使用注解完成Spring的bean管理，需要掌握的内容为:</p><ul><li>记住<code>@Component</code>、<code>@Controller</code>、<code>@Service</code>、<code>@Repository</code>这四个注解</li><li>applicationContext.xml中<code>&lt;context:component-san/&gt;</code>的作用是指定扫描包路径，注解为<code>@ComponentScan</code></li><li><code>@Configuration</code>标识该类为配置类，使用类替换<code>applicationContext.xml</code>文件</li><li><code>ClassPathXmlApplicationContext</code>是加载XML配置文件</li><li><code>AnnotationConfigApplicationContext</code>是加载配置类</li></ul><h2 id="注解开发bean的作用范围和生命周期"><a href="#注解开发bean的作用范围和生命周期" class="headerlink" title="注解开发bean的作用范围和生命周期"></a>注解开发bean的作用范围和生命周期</h2><p>使用注解已经完成了bean的管理，接下来按照前面所学习的内容，将通过配置实现的内容都换成对应的注解实现，包含两部分内容:<code>bean作用范围(scope)</code>和<code>bean生命周期(init和destroy)</code>。</p><h3 id="bean的作用范围"><a href="#bean的作用范围" class="headerlink" title="bean的作用范围"></a>bean的作用范围</h3><p>修改<code>AppForAnnotation</code>类，并运行查看结果</p><ul><li><p>默认情况下bean是单例</p></li><li><p>要想将BookDaoImpl变成非单例，只需要在其类上添加<code>@scope</code>注解</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForAnnotation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao1</span> <span class="operator">=</span> (BookDao) context.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao2</span> <span class="operator">=</span> (BookDao) context.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        System.out.println(bookDao1);</span><br><span class="line">        System.out.println(bookDao2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;bookDao&quot;)</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知识点：<code>@scope</code></p><table><thead><tr><th align="center">名称</th><th align="center">@Scope</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">类注解</td></tr><tr><td align="center">位置</td><td align="center">类定义上方</td></tr><tr><td align="center">作用</td><td align="center">设置该类创建对象的作用范围，可用于设置创建出的bean是否为单例对象</td></tr><tr><td align="center">属性</td><td align="center">value（默认）：定义bean作用范围，默认值singleton（单例），可选值prototype（非单例）</td></tr></tbody></table><h3 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h3><p>在BookDaoImpl中添加两个方法，<code>init</code>和<code>destroy</code>，方法名可以任意，再添加一个构造方法</p><ul><li><p>如何对方法进行标识，哪个是初始化方法，哪个是销毁方法?<br>只需要在对应的方法上添加<code>@PostConstruct</code>和<code>@PreDestroy</code>注解即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;bookDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookDaoImpl</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;construct ... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span>  <span class="comment">// 在构造方法之后执行，替换 init-method</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init ... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span> <span class="comment">// 在销毁方法之前执行，替换 destroy-method</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy ... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>要想看到两个方法执行，需要注意的是<code>destroy</code>只有在容器关闭的时候，才会执行，所以需要修改App的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForAnnotation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) context.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        System.out.println(bookDao);</span><br><span class="line">        context.registerShutdownHook();<span class="comment">//关闭容器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意：JDK8版本以上，如果找不到<code>@PostConstruct</code>和<code>@PreDestroy</code>注解，需要导入下面的jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.annotation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.annotation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>找不到的原因是，从JDK9以后jdk中的javax.annotation包被移除了，这两个注解刚好就在这个包中。</p></blockquote><p>知识点<code>@PostConstruct</code></p><table><thead><tr><th align="center">名称</th><th align="center">@PostConstruct</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">方法注解</td></tr><tr><td align="center">位置</td><td align="center">方法上</td></tr><tr><td align="center">作用</td><td align="center">设置该方法为初始化方法</td></tr><tr><td align="center">属性</td><td align="center">无</td></tr></tbody></table><p>知识点<code>PreDestroy</code></p><table><thead><tr><th align="center">名称</th><th align="center">@PreDestroy</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">方法注解</td></tr><tr><td align="center">位置</td><td align="center">方法上</td></tr><tr><td align="center">作用</td><td align="center">设置该方法为销毁方法</td></tr><tr><td align="center">属性</td><td align="center">无</td></tr></tbody></table><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>配置文件中的bean标签中的<br><code>id</code>对应<code>@Component(&quot;&quot;)</code>，<code>@Controller(&quot;&quot;)</code>，<code>@Service(&quot;&quot;)</code>，<code>@Repository(&quot;&quot;)</code><br><code>scope</code>对应<code>@scope()</code><br><code>init-method</code>对应<code>@PostConstruct</code><br><code>destroy-method</code>对应<code>@PreDestroy</code></p><h2 id="注解开发依赖注入"><a href="#注解开发依赖注入" class="headerlink" title="注解开发依赖注入"></a>注解开发依赖注入</h2><p>Spring为了使用注解简化开发，并没有提供<code>构造函数注入</code>、<code>setter注入</code>对应的注解，只提供了自动装配的注解实现。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ol><li>创建一个Maven项目</li><li>pom.xml添加Spring的依赖</li><li>添加一个配置类<code>SpringConfig</code></li><li>添加BookDao、BookDaoImpl、BookService、BookServiceImpl类</li><li>创建运行类AppForAnnotation</li><li>环境准备好后，直接运行App类会有问题，因为还没有提供配置注入BookDao的，所以bookDao对象为Null，调用其save方法就会报<code>控指针异常</code>。</li></ol><h3 id="注解实现按照类型注入"><a href="#注解实现按照类型注入" class="headerlink" title="注解实现按照类型注入"></a>注解实现按照类型注入</h3><p>在BookServiceImpl类的bookDao属性上添加<code>@Autowired</code>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public void setBookDao(BookDao bookDao) &#123;</span></span><br><span class="line"><span class="comment">//        this.bookDao = bookDao;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li><p><code>@Autowired</code>可以写在属性上，也可也写在setter方法上，最简单的处理方式是<code>写在属性上并将setter方法删除掉</code></p></li><li><p><code>@Autowired</code>是按照类型注入，那么对应BookDao接口如果有多个实现类，比如添加BookDaoImpl2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl2</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候再次运行App，就会报错<code>NoUniqueBeanDefinitionException</code><br>此时，按照类型注入就无法区分到底注入哪个对象，解决方案:<code>按照名称注入</code></p><ul><li><p>先给两个Dao类分别起个名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;bookDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository(&quot;bookDao2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl2</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...2&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>此时就可以注入成功，但是得思考个问题:</p><ul><li>@Autowired是按照类型注入的，给BookDao的两个实现起了名称，它还是有两个bean对象，为什么不报错?</li><li>@Autowired默认按照类型自动装配，如果IOC容器中同类的Bean找到多个，就按照变量名和Bean的名称匹配。因为变量名叫<code>bookDao</code>而容器中也有一个<code>booDao</code>，所以可以成功注入。</li></ul></li><li><p>为什么setter方法可以删除呢?</p><ul><li>自动装配基于反射设计创建对象并通过<code>暴力反射</code>为私有属性进行设值</li><li>普通反射只能获取public修饰的内容</li><li>暴力反射除了获取public修饰的内容还可以获取private修改的内容</li><li>所以此处无需提供setter方法</li></ul></li></ul><h3 id="注解实现按照名称注入"><a href="#注解实现按照名称注入" class="headerlink" title="注解实现按照名称注入"></a>注解实现按照名称注入</h3><p>当根据类型在容器中找到多个bean，注入参数的属性名又和容器中bean的名称不一致，这个时候该如何解决，就需要使用到<code>@Qualifier</code>来指定注入哪个名称的bean对象。<code>@Qualifier</code>注解后的值就是需要注入的bean的名称。</p><p>当根据类型在容器中找到多个bean，注入参数的属性名又和容器中bean的名称不一致，这个时候该如何解决，就需要使用到<code>@Qualifier</code>来指定注入哪个名称的bean对象。<code>@Qualifier</code>注解后的值就是需要注入的bean的名称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;bookDao1&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>@Qualifier不能独立使用，必须和@Autowired一起使用</p></blockquote><h3 id="简单数据类型注入"><a href="#简单数据类型注入" class="headerlink" title="简单数据类型注入"></a>简单数据类型注入</h3><p>引用类型看完，简单类型注入就比较容易懂了。简单类型注入的是基本数据类型或者字符串类型，下面在<code>BookDaoImpl</code>类中添加一个<code>name</code>属性，用其进行简单类型注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据类型换了，对应的注解也要跟着换，这次使用<code>@Value</code>注解，将值写入注解的参数中就行了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;Stephen&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意数据格式要匹配，如将”abc”注入给int值，这样程序就会报错。</p></blockquote><p>介绍完后，会有一种感觉就是这个注解好像没什么用，跟直接赋值是一个效果，还没有直接赋值简单，所以这个注解存在的意义是什么?继续往下看</p><h3 id="注解读取properties配置文件"><a href="#注解读取properties配置文件" class="headerlink" title="注解读取properties配置文件"></a>注解读取properties配置文件</h3><p><code>@Value</code>一般会被用在从properties配置文件中读取内容进行使用，具体如何实现?</p><ol><li><p>在resource下准备一个properties文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name</span>=<span class="string">Stephen</span></span><br></pre></td></tr></table></figure></li><li><p>使用注解加载properties配置文件，在配置类上添加<code>@PropertySource</code>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.blog&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用@Value读取配置文件中的内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>注意:</strong></p><ul><li>如果读取的properties配置文件有多个，可以使用<code>@PropertySource</code>的属性来指定多个</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&#123;&quot;jdbc.properties&quot;,&quot;xxx.properties&quot;&#125;)</span></span><br></pre></td></tr></table></figure><ul><li><code>@PropertySource</code>注解属性中不支持使用通配符<code>*</code>，运行会报错</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&#123;&quot;*.properties&quot;&#125;)</span></span><br></pre></td></tr></table></figure><ul><li><code>@PropertySource</code>注解属性中可以把<code>classpath:</code>加上，代表从当前项目的根路径找文件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&#123;&quot;classpath:jdbc.properties&quot;&#125;)</span></span><br></pre></td></tr></table></figure><p>知识点1：<code>@Autowired</code></p><table><thead><tr><th align="center">名称</th><th align="center">@Autowired</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">属性注解 或 方法注解（了解） 或 方法形参注解（了解）</td></tr><tr><td align="center">位置</td><td align="center">属性定义上方 或 标准set方法上方 或 类set方法上方 或 方法形参前面</td></tr><tr><td align="center">作用</td><td align="center">为引用类型属性设置值</td></tr><tr><td align="center">属性</td><td align="center">required：true&#x2F;false，定义该属性是否允许为null</td></tr></tbody></table><p>知识点2：<code>@Qualifier</code></p><table><thead><tr><th align="center">名称</th><th align="center">@Qualifier</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">属性注解 或 方法注解（了解）</td></tr><tr><td align="center">位置</td><td align="center">属性定义上方 或 标准set方法上方 或 类set方法上方</td></tr><tr><td align="center">作用</td><td align="center">为引用类型属性指定注入的beanId</td></tr><tr><td align="center">属性</td><td align="center">value（默认）：设置注入的beanId</td></tr></tbody></table><p>知识点3：<code>@Value</code></p><table><thead><tr><th align="center">名称</th><th align="center">@Value</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">属性注解 或 方法注解（了解）</td></tr><tr><td align="center">位置</td><td align="center">属性定义上方 或 标准set方法上方 或 类set方法上方</td></tr><tr><td align="center">作用</td><td align="center">为 基本数据类型 或 字符串类型 属性设置值</td></tr><tr><td align="center">属性</td><td align="center">value（默认）：要注入的属性值</td></tr></tbody></table><p>知识点4：<code>@PropertySource</code></p><table><thead><tr><th align="center">名称</th><th align="center">@PropertySource</th></tr></thead><tbody><tr><td align="center">类型</td><td align="center">类注解</td></tr><tr><td align="center">位置</td><td align="center">类定义上方</td></tr><tr><td align="center">作用</td><td align="center">加载properties文件中的属性值</td></tr><tr><td align="center">属性</td><td align="center">value（默认）：设置加载的properties文件对应的文件名或文件名组成的数组</td></tr></tbody></table><h2 id="注解开发总结"><a href="#注解开发总结" class="headerlink" title="注解开发总结"></a>注解开发总结</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310061950274.png"></p><h1 id="基于注解的Spring应用"><a href="#基于注解的Spring应用" class="headerlink" title="基于注解的Spring应用"></a>基于注解的Spring应用</h1><p>Spring除了xml配置文件进行配置之外，还可以使用注解方式进行配置，注解方式慢慢成为xml配置的替代方案</p><p>Spring提供的注解有三个版本：</p><ul><li>2.0时代，Spring开始出现注解</li><li>2.5时代，Spring的Bean配置可以使用注解完成</li><li>3.0时代，Spring其他配置也可以使用注解完成，我们进入全注解时代</li></ul><p>但是XML和他的原理是spring的根基，spring的很多强大功能都是<strong>基于XML</strong>，通过几个<strong>后处理器</strong>增强的</p><h2 id="注解开发IOC"><a href="#注解开发IOC" class="headerlink" title="注解开发IOC"></a>注解开发IOC</h2><p>Bean注解开发实质：</p><ol><li>用注解的方式替代原有的xml标签及其标签属性的配置</li><li>用核心配置类替换Xml文件</li></ol><h3 id="Bean标签替换"><a href="#Bean标签替换" class="headerlink" title="Bean标签替换"></a>Bean标签替换</h3><p>使用@Component 注解替代Bean标签，被该注解标识的类，会在指定扫描范围内被Spring加载并注册成Bean</p><table><thead><tr><th></th><th>BeanName</th><th>路径</th></tr></thead><tbody><tr><td>xml</td><td>id</td><td>class</td></tr><tr><td>注解</td><td>value</td><td>直接配置在相应类上，指出类的路径</td></tr></tbody></table><p>XML中：</p><ul><li>id：Bean的名字</li><li>class：Bean对应的类的全类名，通过反射创建对象</li></ul><p>@Component：</p><ul><li><p>value属性指定当前Bean实例的beanName，也可以省略不写，不写的情况下为当前类名首字母小写</p><p><code>@Component(value=&quot;userDao&quot;)</code> <code>@Component(&quot;userDao&quot;)</code> <code>@Component()</code>都可以</p></li><li><p>@Component直接配置在相应类上，指出类的路径</p></li></ul><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><ol><li><p>用注解定义bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取方式：applicationContext.getBean(&quot;userDao&quot;);</span></span><br><span class="line"><span class="meta">@Component(&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取方式：applicationContext.getBean(&quot;userDaoImpl&quot;);</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置xml文件，声明要使用注解，并指出扫描的基本包和其子包，要配置组件扫描路径</p><p>这个也能被标签替代</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 告知Spring框架去itheima包及其子包下去扫描使用了注解的类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>底层是通过后处理器来实现扫包的效果</p></li></ol><h3 id="Bean其他属性"><a href="#Bean其他属性" class="headerlink" title="Bean其他属性"></a>Bean其他属性</h3><p>@Component注解仅包含value属性，这个属性配置了Bean的名字，其余属性也可以通过注解方式去配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;&quot;</span> <span class="attr">lazy-init</span>=<span class="string">&quot;&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">abstract</span>=<span class="string">&quot;&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>xml配置</th><th>注解</th><th>描述</th></tr></thead><tbody><tr><td>&lt; bean scope&#x3D;””&gt;</td><td>@Scope</td><td>在类上或使用了@Bean标注的方法上，标注Bean的作用范围，取值为 singleton或prototype</td></tr><tr><td>&lt; bean lazy-init&#x3D;””&gt;</td><td>@Lazy</td><td>在类上或使用了@Bean标注的方法上，标注Bean是否延迟加载，取值为 true和false</td></tr><tr><td>&lt; bean init-method&#x3D;””&gt;</td><td>@PostConstruct</td><td>在方法上使用，标注Bean的实例化后执行的方法</td></tr><tr><td>&lt; bean destroy-method&#x3D;””&gt;</td><td>@PreDestroy</td><td>在方法上使用，标注Bean的销毁前执行方法</td></tr></tbody></table><p>使用上述注解完成UserDaoImpl的基本配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;userDao&quot;)</span></span><br><span class="line"><span class="meta">@Scope(&quot;singleton&quot;)</span></span><br><span class="line"><span class="meta">@Lazy(true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分层设计"><a href="#分层设计" class="headerlink" title="分层设计"></a>分层设计</h3><p>由于JavaEE开发是分层的，为了每层Bean标识的注解语义化更加明确，@Component又衍生出如下三个注解</p><table><thead><tr><th>@Component衍生注解</th><th>描述</th></tr></thead><tbody><tr><td>@Repository</td><td>在Dao层类上使用</td></tr><tr><td>@Service</td><td>在Service层类上使用</td></tr><tr><td>@Controller</td><td>在Web层类上使用</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service(&quot;userService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller(&quot;userService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="注解开发DI"><a href="#注解开发DI" class="headerlink" title="注解开发DI"></a>注解开发DI</h2><p>XML中，原来用&lt; porperty&gt; 给Bean配置，中间用value和ref属性来配置普通类型和引用对象</p><p>Spring主要提供如下注解，用于在Bean内部进行属性注入的</p><table><thead><tr><th>属性注入注解</th><th>描述</th></tr></thead><tbody><tr><td>@Value</td><td>使用在字段或方法上，用于注入普通数据</td></tr><tr><td>@Autowired</td><td>使用在字段或方法上，用于根据类型（byType）注入引用数据</td></tr><tr><td>@Qualifier</td><td>使用在字段或方法上，结合@Autowired，根据名称注入</td></tr><tr><td>@Resource</td><td>使用在字段或方法上，根据类型或名称进行注入</td></tr></tbody></table><ul><li><p>通过@Value 直接注入普通属性，通过反射暴力创建的对象，可以在属性或者方法上配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//属性上配置</span></span><br><span class="line"><span class="meta">@Value(&quot;haohao&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法上配置</span></span><br><span class="line"><span class="meta">@Value(&quot;haohao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span>&#123;</span><br><span class="line">    System.out.println(username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样就写死了，没意义而且加大了复杂度，下面的使用有一定的意义</p></li><li><p>通过@Value 注入properties文件中的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span>&#123;</span><br><span class="line">    System.out.println(username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加载properties文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>@Autowired注解，用于根据类型进行注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用在属性上直接注入</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用在方法上直接注入</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span>&#123;</span><br><span class="line">    System.out.println(userDao);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当容器中同一类型的Bean实例有多个时，会尝试自动根据名字进行匹配，没有名字一样的就会报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配当前Bean</span></span><br><span class="line"><span class="meta">@Repository(&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository(&quot;userDao2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl2</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>@Qualifier配合@Autowired可以完成根据名称注入Bean实例，使用@Qualifier指定名称</p><p>@Qualifier是可以单用的，只是这里联合使用了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;userDao2&quot;)</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;userDao2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span>&#123;</span><br><span class="line">    System.out.println(userDao);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@Resource注解既可以根据类型注入，也可以根据名称注入，无参就是根据类型注入，有参数就是根据名称注入，本来是Java的注解，但是被spring拿来用了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource(name = &quot;userDao2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span>&#123;</span><br><span class="line">    System.out.println(userDao);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Resource注解存在与 javax.annotation 包中，Spring对其进行了解析</p></li></ul><h2 id="非自定义Bean"><a href="#非自定义Bean" class="headerlink" title="非自定义Bean"></a>非自定义Bean</h2><p>非自定义Bean一般存在于jar包中，不能像自定义Bean一样使用@Component进行管理，要使用@Bean通过工厂方式进行实例化，@Bean(“Bean的名字”)</p><p>@Bean的参数 &#x3D; 方法返回值的名字 &#x3D; Bean名字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将方法返回值Bean实例以@Bean注解指定的名称存储到Spring容器中</span></span><br><span class="line"><span class="meta">@Bean(&quot;dataSource&quot;)</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">    dataSource.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">    dataSource.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span>);</span><br><span class="line">    dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">    dataSource.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂方法所在类必须要被Spring管理</p><p>如果@Bean工厂方法需要参数的话，则有如下三种注入方式：</p><ol><li>使用@Autowired 根据类型自动进行Bean的匹配，@Autowired可以省略 </li><li>使用@Qualifier 根据名称进行Bean的匹配</li><li>使用@Value 根据名称进行普通数据类型匹配</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Autowired</span> <span class="comment">//根据类型匹配参数</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">objectDemo01</span><span class="params">(UserDao userDao)</span>&#123;</span><br><span class="line">    System.out.println(userDao);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">objectDemo02</span><span class="params">(<span class="meta">@Qualifier(&quot;userDao&quot;)</span> UserDao userDao,</span></span><br><span class="line"><span class="params">                           <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span> String username)</span>&#123;</span><br><span class="line">    System.out.println(userDao);</span><br><span class="line">    System.out.println(username);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>细节：</p><ol><li><p>不加名字行不行？</p><p>可以的，默认名字是方法的名字，注意，是<strong>方法的名字</strong></p></li><li><p>这是用工厂方法生产的，方法存在于对象中，所以，对象bean必须要能扫到</p></li><li><p>需要其他参数时候怎么办？</p><p>和前面给bean配置参数一样，前面怎么配置，这里怎么配置</p></li></ol><h2 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h2><p>@Component等注解替代了标签，但是像<code>&lt;import&gt;</code>、 <code>&lt;context:componentScan&gt;</code>等非标签怎 去使用注解替代呢？</p><p>定义一个配置类替代原有的xml配置文件，标签以外的标签，一般都是在配置类上使用注解完成的</p><div class="tabs" id=""><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#-1"><i class="Configuration" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#-2"><i class="ComponentScan" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#-3"><i class="PropertySource" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#-4"><i class="Import" style="text-align: center;"></i></button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="-1"><p>@Configuration：标识的类为配置类，替代原有xml配置文件，有2个作用</p><ol><li><p>标识该类是一个配置类</p></li><li><p>具备@Component作用，配置类也是一个组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextConfig</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-2"><p>@ComponentScan：组件扫描配置，替代原有xml文件中的&lt;context:component-scan base-package&#x3D;””&#x2F;&gt;，指出扫描的基本类路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(base-package = &#123;&quot;com.itheima.service&quot;,&quot;com.itheima.dao&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextConfig</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>base-package的配置方式：</p><ol><li>指定一个或多个包名：扫描指定包及其子包下使用注解的类</li><li>不配置包名：扫描当前@componentScan注解配置类所在包及其子包下的类</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-3"><p>@PropertySource：用于加载外部properties资源配置，替代原有xml中的&lt;context:propertyplaceholder location&#x3D;“位置”&#x2F;&gt; 配置，指出去哪里找配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@PropertySource(&#123;&quot;classpath:jdbc.properties&quot;,&quot;classpath:xxx.properties&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextConfig</span> &#123;&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-4"><p>@Import 用于加载其他配置类，替代原有xml中的&lt; import resource&#x3D;”classpath:beans.xml”&#x2F;&gt;配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@Import(OtherConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextConfig</span> &#123;&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="更换spring容器实现类"><a href="#更换spring容器实现类" class="headerlink" title="更换spring容器实现类"></a>更换spring容器实现类</h3><p>原先使用的是根据路径加载配置的spring容器实现类<code>ClassPathXmlApplicationContext</code> 和 <code>FileSystemXmlApplicationContext</code></p><p>现在配置文件都没了，更换为用注解加载配置的spring容器实现类<code>AnnotationConfigApplicationContext</code></p><h2 id="Spring-配置其他注解"><a href="#Spring-配置其他注解" class="headerlink" title="Spring 配置其他注解"></a>Spring 配置其他注解</h2><h3 id="Primary"><a href="#Primary" class="headerlink" title="@Primary"></a>@Primary</h3><p>@Primary注解用于标注相同类型的Bean优先被使用权</p><p>@Primary 是Spring3.0引入的，与@Component 和@Bean一起使用，标注该Bean的优先级更高，则在通过类型获取Bean或通过@Autowired根据类型进行注入时， 会选用优先级更高的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;&#125;</span><br><span class="line"><span class="meta">@Repository(&quot;userDao2&quot;)</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl2</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> UserDao <span class="title function_">userDao01</span><span class="params">()</span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="keyword">public</span> UserDao <span class="title function_">userDao02</span><span class="params">()</span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl2</span>();&#125;</span><br></pre></td></tr></table></figure><h3 id="Profile"><a href="#Profile" class="headerlink" title="@Profile"></a>@Profile</h3><p>@Profile 注解的作用同于xml配置时学习profile属性，是进行环境切换使用的</p><p>注解 @Profile 标注在类或方法上，标注当前产生的Bean从属于哪个环境，只有激活了当前环境，被标注的Bean才能被注册到Spring容器里，不指定环境的Bean，即没有加这个注解的Bean，任何环境下都能注册到Spring容器里</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;userDao&quot;)</span></span><br><span class="line"><span class="meta">@Profile(&quot;test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;&#125;</span><br><span class="line"><span class="meta">@Repository(&quot;userDao2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl2</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>可以使用以下两种方式指定被激活的环境：</p><ol><li>使用命令行动态参数，虚拟机参数位置加载 -Dspring.profiles.active&#x3D;test</li><li>使用代码的方式设置环境变量 System.setProperty(“spring.profiles.active”,”test”);</li></ol><h1 id="Spring注解的解析原理"><a href="#Spring注解的解析原理" class="headerlink" title="Spring注解的解析原理"></a>Spring注解的解析原理</h1><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231110210128599.png" alt="image-20231110210128599"></p><p> 使用@Component等注解配置完毕后，要配置组件扫描才能使注解生效</p><ol><li><p>xml配置组件扫描</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置类配置组件扫描</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231119181600269.png" alt="image-20231119181600269"></p><h2 id="xml方式"><a href="#xml方式" class="headerlink" title="xml方式"></a>xml方式</h2><p><a href="https://www.cnblogs.com/question-sky/p/6953315.html%EF%BC%8C%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E8%AE%B2%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E7%9C%8B">https://www.cnblogs.com/question-sky/p/6953315.html，这篇文章讲相关内容，可以看看</a></p><p>component-scan是一个context命名空间下的自定义标签，最终对应他的命名空间处理器NamespaceHandler 和 解析器</p><p>查看spring-context包下的spring.handlers文件：ExtrrnalLibraries -&gt; Maven…:spring-context -&gt; META INF -&gt; spring.handlers</p><p>对应的是ComponentScanBeanDefinitionParser类，它内部的Parse方法会被解析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> BeanDefinition <span class="title function_">parse</span><span class="params">(Element element, ParserContext parserContext)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析base-package属性值，扫描的包可以,;分隔</span></span><br><span class="line">    String[] basePackages = StringUtils.tokenizeToStringArray(element.getAttribute(BASE_PACKAGE_ATTRIBUTE),ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Actually scan for bean definitions and register them.</span></span><br><span class="line">    <span class="type">ClassPathBeanDefinitionScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> configureScanner(parserContext, element);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过ClassPathBeanDefinitionScanner扫描类来获取包名下的所有class并将他们注册到spring的bean工厂中</span></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册其他注解组件</span></span><br><span class="line">    registerComponents(parserContext.getReaderContext(), beanDefinitions, element);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中doScan的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">doScan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">    <span class="comment">//表明base-package属性是需要被指定的</span></span><br><span class="line">    Assert.notEmpty(basePackages, <span class="string">&quot;At least one base package must be specified&quot;</span>);</span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;BeanDefinitionHolder&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">        <span class="comment">//对每个基础包都进行扫描寻找并且对基础包下的所有class都注册为BeanDefinition</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                        **</span></span><br><span class="line"><span class="comment">                        **并对得到的candidates集合进行过滤，此处便用到include-filters和exclude-filters</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">        Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">        <span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">            <span class="comment">//解析一个bean的scope属性，代表作用范围</span></span><br><span class="line">            <span class="comment">//prototype-&gt;每次请求都创建新的对象 singleton-&gt;单例模式，处理多请求</span></span><br><span class="line">            <span class="type">ScopeMetadata</span> <span class="variable">scopeMetadata</span> <span class="operator">=</span> <span class="built_in">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">            candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">            <span class="comment">//使用beanName生成器生成</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> <span class="built_in">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="built_in">this</span>.registry);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">**对注册的bean进行另外的赋值处理，比如默认属性的配置</span></span><br><span class="line"><span class="comment">*返回的candidate类型为ScannedGenericBeanDefinition，下面两者</span></span><br><span class="line"><span class="comment">*条件满足</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">            <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">                <span class="comment">//设置lazy-init/autowire-code默认属性，从spring配置的&lt;beans&gt;节点属性读取</span></span><br><span class="line">                postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">                <span class="comment">//读取bean上的注解，比如`@Lazy`、`@Dependson`的值设置相应的属性</span></span><br><span class="line">                AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//查看是否已注册</span></span><br><span class="line">            <span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">                <span class="type">BeanDefinitionHolder</span> <span class="variable">definitionHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(candidate, beanName);</span><br><span class="line">                <span class="comment">//默认采取cglib来做代理</span></span><br><span class="line">                definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line">                beanDefinitions.add(definitionHolder);</span><br><span class="line">                <span class="comment">//**</span></span><br><span class="line">                <span class="comment">//注册bean信息到工厂中</span></span><br><span class="line">                registerBeanDefinition(definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>registerBeanDefinition(definitionHolder, this.registry);</code>是真正实现注册的那一行</p><p>这个时候把注解标记内容加入BeanDefinitionMap，根据前面的后处理器和生命周期内容，我们可知，最总会产生相关的bean实例</p><h2 id="配置类方式"><a href="#配置类方式" class="headerlink" title="配置类方式"></a>配置类方式</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109190337461.png" alt="image-20231109190337461"></p><p>AnnotationConfigApplicationContext容器在进行创建时，所有的有参构造方法第一步都是执行自己的无参构造方法</p><p>无参构造源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 在执行此行代码之前, 先执行了父类的构造方法</span></span><br><span class="line">    <span class="comment">// 此段代码做的事情:</span></span><br><span class="line">    <span class="comment">// 1. 初始化bean工厂</span></span><br><span class="line">    <span class="comment">// 2. 初始化一个注解BeanDefinition读取器</span></span><br><span class="line">    <span class="comment">// 3. 将spring内置的6个类封装成RootBeanDefinition并注册到bean工厂, </span></span><br><span class="line">    <span class="built_in">this</span>.reader = <span class="keyword">new</span> <span class="title class_">AnnotatedBeanDefinitionReader</span>(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并没啥用, 虽然ClassPathBeanDefinitionScanner</span></span><br><span class="line">    <span class="comment">// 类的作用是扫描@ComponentScan注解提供的包路径。</span></span><br><span class="line">    <span class="comment">// 但实际上它并没有做扫描工作, spring内部扫描路径</span></span><br><span class="line">    <span class="comment">// 的时候, 是在内部新new了一个ClassPathBeanDefinitionScanner,</span></span><br><span class="line">    <span class="comment">// 这个属性目前没啥用, 当然我们可以获取这个对象</span></span><br><span class="line">    <span class="comment">// 调用它的scan方法, 但是没有必要! 因为</span></span><br><span class="line">    <span class="comment">// @ComponentScan可以支持多个扫描路径。 </span></span><br><span class="line">    <span class="comment">// 那这个类有什么用呢？跟刚刚的解释一样, </span></span><br><span class="line">    <span class="comment">// 我们可以自己new一个ClassPathBeanDefinitionScanner对象或者扩展他, </span></span><br><span class="line">    <span class="comment">// 利用它的扫描功能(因为它是使用ASM来扫描的)</span></span><br><span class="line">    <span class="comment">// Mybatis源码中就是自己扩展了</span></span><br><span class="line">    <span class="comment">// ClassPathBeanDefinitionScanner类</span></span><br><span class="line">    <span class="built_in">this</span>.scanner = <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="整合第三方框架"><a href="#整合第三方框架" class="headerlink" title="整合第三方框架"></a>整合第三方框架</h1><h2 id="注解方式整合第三方框架"><a href="#注解方式整合第三方框架" class="headerlink" title="注解方式整合第三方框架"></a>注解方式整合第三方框架</h2><p>xml方式整合MyBatis，大致分为3步 3fenzhong</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置数据源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置SqlSessionFactoryBean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置Mapper包扫描--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.itheima.dao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>用配置方式替换</p><ol><li>使用@Bean将DataSource和SqlSessionFactoryBean存储到Spring容器中</li><li>MapperScannerConfigurer使用注解@MapperScan进行指明需要扫描的Mapper在哪个包下</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&lt;!--配置Mapper包扫描--&gt;</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.itheima.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationContextConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//&lt;!--配置数据源--&gt;</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        <span class="comment">//省略部分代码</span></span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//&lt;!--配置SqlSessionFactoryBean--&gt;</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactoryBean</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">sqlSessionFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Import整合三方框架"><a href="#Import整合三方框架" class="headerlink" title="@Import整合三方框架"></a>@Import整合三方框架</h2><p>@Import可以导入如下三种类：</p><ol><li>普通的配置类</li><li>实现ImportSelector接口的类</li><li>实现ImportBeanDefinitionRegistrar接口的类</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 框架 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-概述</title>
      <link href="/2023/08/29/Spring01%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/08/29/Spring01%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring家族"><a href="#Spring家族" class="headerlink" title="Spring家族"></a>Spring家族</h1><p>官网:<a href="https://spring.io,/">https://spring.io</a> 从官网我们可以大概了解到：</p><ul><li><p>Spring能做什么：用以开发web、微服务以及分布式系统等，光这三块就已经占了JavaEE开发的九成多</p></li><li><p>Spring并不是单一的一个技术，而是一个大家族，可以从官网的<code>Projects</code>中查看其包含的所有技术</p></li><li><p>Spring发展到今天已经形成了一种开发的生态圈，Spring提供了若干个项目，每个项目用于完成特定的功能</p><ul><li>Spring已形成了完整的生态圈，也就是说我们可以完全使用Spring技术完成整个项目的构建、设计与开发。</li><li>Spring有若干个项目，可以根据需要自行选择，把这些个项目组合起来，起了一个名称叫Spring全家桶</li></ul></li></ul><p><img src="/https%EF%BC%9A/icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309122209999.png"></p><p>重点关注<code>Spring Framework</code>、<code>SpringBoot</code>和<code>SpringCloud</code></p><ul><li>Spring Framework：Spring框架，是Spring中最早最核心的技术，也是所有其他技术的基础。</li><li>SpringBoot：Spring是来简化开发，而SpringBoot是来帮助Spring在简化的基础上能更快速进行开发。</li><li>SpringCloud：这个是用来做分布式之微服务架构的相关开发。</li></ul><p>Spring Framework架构图以4的架构图</p><p><img src="/https%EF%BC%9A/icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309122211853.png"></p><ol><li>核心层<ul><li>Core Container：核心容器，这个模块是Spring最核心的模块，其他的都需要依赖该模块</li></ul></li><li>AOP层<ul><li>AOP(Aspect Oriented Programming)：面向切面编程，它依赖核心层容器，目的是在不改变原有代码的前提下对其进行功能增强</li><li>Aspects：AOP是思想，Aspects是对AOP思想的具体实现</li></ul></li><li>数据层<ul><li>Data Access：数据访问，Spring全家桶中有对数据访问的具体实现技术</li><li>Data Integration：数据集成，Spring支持整合其他的数据层解决方案，比如Mybatis</li><li>Transactions：事务，Spring中事务管理是Spring AOP的一个具体实现，也是后期学习的重点内容</li></ul></li><li>Web层<ul><li>这一层的内容将在SpringMVC框架具体学习</li></ul></li><li>Test层<ul><li>Spring主要整合了Junit来完成单元测试和集成测试</li></ul></li></ol><h1 id="Spring核心概念"><a href="#Spring核心概念" class="headerlink" title="Spring核心概念"></a>Spring核心概念</h1><p>在Spring核心概念这部分内容中主要包含<code>IOC/DI</code>、<code>IOC容器</code>和<code>Bean</code></p><h2 id="IoC、DI和AOP思想提出"><a href="#IoC、DI和AOP思想提出" class="headerlink" title="IoC、DI和AOP思想提出"></a>IoC、DI和AOP思想提出</h2><p>传统开发2个问题</p><p><img src="/https%EF%BC%9A/icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109170011596.png" alt="image-20231109170011596"></p><div class="tabs" id="1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#1-1">IoC</button></li><li class="tab"><button type="button" data-href="#1-2">DI</button></li><li class="tab"><button type="button" data-href="#1-3">AOP</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><p>IoC思想： Inversion of Control，翻译为<strong>控制反转</strong>，强调的是原来在程序中创建Bean的权利反转给第三方。</p><p>根据IoC思想的指导， 寻求一个第三方去创建<code>UserServiceImpl对象</code>和<code>UserDaoImpl对象</code>。这样程序与具体对象就失去的直接联系。</p><p>谁去充当第三方角色呢？ </p><ul><li>工厂设计模式，BeanFactory来充当第三方的角色，来产生Bean实例</li></ul><p>BeanFactory怎么知道产生哪些Bean实例呢？</p><ul><li>可以使用配置文件配置Bean的基本信息，BeanFactory根据配置文件来生产Bean实例</li></ul><p><img src="/https%EF%BC%9A/icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109165542356.png" alt="image-20231109165542356"></p><p>IOC概念：</p><ul><li>什么是控制反转<ul><li>使用对象时，由主动new产生对象转换为由<code>外部</code>提供对象，此过程中对象创建控制权由程序转移到外部，此思想称为控制反转。</li><li>业务层要用数据层的类对象，以前是自己<code>new</code>的，现在自己不new了，交给<code>别人[外部]</code>来创建对象，<code>别人[外部]</code>就反转控制了数据层对象的创建权，这种思想就是控制反转。</li><li>别人[外部]指的就是Spring容器</li></ul></li><li>Spring和IOC之间的关系<ul><li>Spring技术对IOC思想进行了实现</li><li>Spring提供了一个容器，用来充当IOC思想中的<strong>外部</strong></li><li>IOC思想中的<code>别人[外部]</code>指的就是Spring的IOC容器</li></ul></li><li>IOC容器的作用以及内部存放的是什么?<ul><li>IOC容器负责对象的创建、初始化等一系列工作，其中包含了数据层和业务层的类对象</li><li>被创建或被管理的对象在IOC容器中统称为Bean</li><li>IOC容器中放的就是一个个的Bean对象</li></ul></li><li>当IOC容器中创建好service和dao对象后，程序能正确执行么?<ul><li>不行，因为service运行需要依赖dao对象，IOC容器中虽然有service和dao对象，但是目前service对象和dao对象没有任何关系</li><li>需要把dao对象交给service，也就是说要绑定service和dao对象之间的关系</li><li>像这种在容器中建立对象与对象之间的绑定关系就要用到DI(Dependency Injection)依赖注入</li></ul></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-2"><p>DI 依赖注入思想的提出</p><p>将 UserDao的创建权也反转给BeanFactory，与此同时UserService内部还需要用到UserDao实例对象，那应该怎 样操作呢？ </p><ol><li>在程序中，通过BeanFactory获得UserService</li><li>在程序中，通过BeanFactory获得UserDao</li><li>在程序中，将UserDao设置给UserService</li></ol><p>将UserDao在BeanFactory内部设置 给UserService的过程叫做<strong>注入</strong> ，而UserService需要依赖UserDao的注入才能正常工作，这个过程叫做 <strong>依赖注入</strong></p><p>DI(Dependency Injection)依赖注入概念：</p><ul><li>什么是依赖注入呢?<ul><li>在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入<ul><li>业务层要用数据层的类对象，以前是自己<code>new</code>的现在自己不new了，靠<code>别人[外部其实指的就是IOC容器]</code>来给注入进来</li><li>这种思想就是依赖注入</li></ul></li></ul></li><li>IOC容器中哪些bean之间要建立依赖关系呢?<ul><li>这个需要程序员根据业务需求提前建立好关系，如业务层需要依赖数据层，service就要和dao建立依赖关系</li></ul></li><li>介绍完Spring的IOC和DI的概念后，我们会发现这两个概念的最终目标就是：充分解耦，具体实现靠：<ul><li>使用IOC容器管理bean（IOC)</li><li>在IOC容器内将有依赖关系的bean进行关系绑定（DI）</li><li>最终结果为：使用对象时不仅可以直接从IOC容器中获取，并且获取到的bean已经绑定了所有的依赖关系.</li></ul></li></ul><p><a href="https://zhuanlan.zhihu.com/p/33492169">理解文章</a></p><p>重点要理解<code>什么是IOC/DI思想</code>、<code>什么是IOC容器</code>和<code>什么是Bean</code>：</p><ol><li>什么IOC&#x2F;DI思想?<ul><li>IOC：控制反转，控制反转的是对象的创建权</li><li>DI：依赖注入，绑定对象与对象之间的依赖关系</li></ul></li><li>什么是IOC容器?<ul><li>Spring创建了一个容器用来存放所创建的对象，这个容器就叫IOC容器</li></ul></li><li>什么是Bean?<ul><li>容器中所存放的一个个对象就叫Bean或Bean对象</li></ul></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-3"><p>AOP思想：Aspect Oriented Programming，面向切面编程，是对面向对象编程OOP的升华。</p><p>OOP是<strong>纵向</strong>对一个事物的抽象，一个对象包括静态的属性信息，包括动态的方法信息等。</p><p>AOP是<strong>横向</strong>的对不同事物的抽象，属 性与属性、方法与方法、对象与对象都可以组成一个切面，而用这种思维去设计编程的方式叫做面向切面编程</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>三种思想总结</p><ol><li>IoC控制反转，是将程序创建Bean的权利反转给第三方</li><li>DI依赖注入，某个完整Bean需要依赖于其他Bean（或属性）的注入</li><li>AOP面向切面编程，用横向抽取方法（属性、对象等）思想，组装成一个功能性切面</li></ol><p>面试题：IoC 和 DI 的关系？</p><ol><li>回答IoC和DI的是什么：<ul><li>IoC： Inversion of Control，控制反转，将Bean的创建权由原来程序反转给第三方 </li><li>DI：Dependency Injection，依赖注入，某个Bean的完整创建依赖于其他Bean（或普通参数）的注入</li></ul></li><li>回答IoC和DI的关系：<ul><li>第一种观点：IoC强调的是Bean创建权的反转，而DI强调的是Bean的依赖关系，认为不是一回事 </li><li>第二种观点：IoC强调的是Bean创建权的反转，而DI强调的是通过注入的方式反转Bean的创建权，认为DI是IoC的其中一种实现方式</li></ul></li></ol><h1 id="Spring框架结构"><a href="#Spring框架结构" class="headerlink" title="Spring框架结构"></a>Spring框架结构</h1><h2 id="Spring-Framework技术栈"><a href="#Spring-Framework技术栈" class="headerlink" title="Spring Framework技术栈"></a>Spring Framework技术栈</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231116092050110.png" alt="image-20231116092050110"><br><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231116092105753.png" alt="image-20231116092105753"></p><table><thead><tr><th>模块</th><th>作用</th></tr></thead><tbody><tr><td>Data Access</td><td>数据访问</td></tr><tr><td>Data Integration</td><td>数据集成</td></tr><tr><td>Web</td><td>Web开发</td></tr><tr><td>AOP</td><td>面向切面编程</td></tr><tr><td>Aspects</td><td>AOP思想实现</td></tr><tr><td>Core Container</td><td>核心容器</td></tr><tr><td>Test</td><td>单元测试与集成测试</td></tr></tbody></table><h2 id="Spring-的容器"><a href="#Spring-的容器" class="headerlink" title="Spring 的容器"></a>Spring 的容器</h2><p>主要有2个BeanFactory与ApplicationContext</p><ul><li><p>BeanFactory是Spring的早期接口，称为Spring的Bean工厂，ApplicationContext是后期更高级接口，称之为 Spring容器；核心还是Bean工厂</p></li><li><p>ApplicationContext在BeanFactory基础上对功能进行了扩展，例如：监听功能、国际化功能等。</p><p>BeanFactory的 API更偏向底层，ApplicationContext的API大多数是对这些底层API的封装；</p></li><li><p>Bean创建的主要逻辑和功能都被封装在BeanFactory中，ApplicationContext不仅继承了BeanFactory，而且 ApplicationContext内部还维护着BeanFactory的引用，所以，ApplicationContext与BeanFactory既有继承关系，又有融合关系</p></li><li><p>Bean的初始化时机不同，原始BeanFactory是在首次调用getBean时才进行Bean的创建，而ApplicationContext则是配置文件加载，容器一创建就将Bean都实例化并初始化好</p></li><li><p>ApplicationContext除了继承了BeanFactory外，还继承了ApplicationEventPublisher（事件发布器）、 ResouresPatternResolver（资源解析器）、MessageSource（消息资源）等。</p></li><li><p>但是ApplicationContext的核心功能还是BeanFactory。</p></li></ul><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109203334542.png" alt="image-20231109203334542"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109203343674.png" alt="image-20231109203343674"></p><h3 id="继承体系"><a href="#继承体系" class="headerlink" title="继承体系"></a>继承体系</h3><div class="tabs" id="继承体系"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#继承体系-1">BeanFactory</button></li><li class="tab"><button type="button" data-href="#继承体系-2">ApplicationContext</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="继承体系-1"><p>BeanFactory是核心接口，项目运行过程中肯定有具体实现参与，这个具体实现就是DefaultListableBeanFactory ，而ApplicationContext内部维护的Beanfactory的实现类也是它</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109203910999.png" alt="image-20231109203910999"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="继承体系-2"><p>只在Spring基础环境下，即只导入spring-context坐标时，此时ApplicationContext的继承体系</p><p>下图三个是常用的实现类，从上到下为：</p><ol><li>使用注解进行加载的实现类，<strong>注解的</strong></li><li>根据文件在电脑中的绝对位置进行加载的实现类，<strong>XML的</strong></li><li>根据文件在项目中的相对位置进行加载的实现类，<strong>XML的</strong></li></ol><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109203931158.png" alt="image-20231109203931158"></p><p>如果Spring基础环境中加入了其他组件解决方案，如web层解决方案，即导入spring-web坐标，此时 ApplicationContext的继承体系</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109204046565.png" alt="image-20231109204046565"></p><p>常用的几个ApplicationContext作用如下：</p><table><thead><tr><th>实现类</th><th>功能描述</th></tr></thead><tbody><tr><td>ClassPathXmlApplicationContext</td><td>加载类路径下的xml配置的ApplicationContext</td></tr><tr><td>FileSystemXmlApplicationContext</td><td>加载磁盘路径下的xml配置的ApplicationContext</td></tr><tr><td>AnnotationConfigApplicationContext</td><td>加载注解配置类的ApplicationContext</td></tr><tr><td>XmlWebApplicationContext</td><td>web环境下，加载类路径下的xml配置的ApplicationContext</td></tr><tr><td>AnnotationConfigWebApplicationContext</td><td>web环境下，加载磁盘路径下的xml配置的ApplicationContext</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="BeanFactory-快速入门"><a href="#BeanFactory-快速入门" class="headerlink" title="BeanFactory 快速入门"></a>BeanFactory 快速入门</h3><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109165542356.png" alt="image-20231109165542356"></p><div class="tabs" id="2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2-1">IoC</button></li><li class="tab"><button type="button" data-href="#2-2">DI</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2-1"><ol><li><p>导入Spring的jar包或Maven坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Spring核心--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>定义UserService接口及其UserServiceImpl实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建beans.xml配置文件，将UserServiceImpl的信息配置到该xml中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.UserServiceImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写测试代码，创建BeanFactory，加载配置文件，获取UserService实例对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建BeanFactory</span></span><br><span class="line"><span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建读取器</span></span><br><span class="line"><span class="type">XmlBeanDefinitionReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载配置文件</span></span><br><span class="line">reader.loadBeanDefinitions(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取Bean实例对象</span></span><br><span class="line"><span class="type">UserDao</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) beanFactory.getBean(<span class="string">&quot;userService&quot;</span>);</span><br></pre></td></tr></table></figure></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2-2"><ol><li><p>定义UserDao接口及其UserDaoImpl实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改UserServiceImpl代码，添加一个setUserDao(UserDao userDao)用于接收注入的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        System.out.println(userDao);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义UserDao接口及其UserDaoImpl实现类</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>请回忆2个userDao的区别</p></blockquote></li><li><p>编写测试代码，创建BeanFactory，加载配置文件，获取UserService实例对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建BeanFactory</span></span><br><span class="line"><span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建读取器</span></span><br><span class="line"><span class="type">XmlBeanDefinitionReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载配置文件</span></span><br><span class="line">reader.loadBeanDefinitions(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取Bean实例对象</span></span><br><span class="line"><span class="type">UserDao</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) beanFactory.getBean(<span class="string">&quot;userService&quot;</span>);</span><br></pre></td></tr></table></figure></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="ApplicationContext快速入门"><a href="#ApplicationContext快速入门" class="headerlink" title="ApplicationContext快速入门"></a>ApplicationContext快速入门</h3><p>ApplicationContext 称为Spring容器，内部封装了BeanFactory（本质还是用的BeanFactory），比BeanFactory功能更丰富更强大，使用 ApplicationContext 进行开发时，xml配置文件的名称习惯写成<code>applicationContext.xml</code>，但这个名字不是强制要求。</p><p>其余配置过程和BeanFactory的一样，仅核心容器配置不同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建ApplicationContext,加载配置文件，实例化容器</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ClassPathxmlApplicationContext</span>(“applicationContext.xml<span class="string">&quot;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//根据beanName获得容器中的Bean实例</span></span><br><span class="line"><span class="string">UserService userService = (UserService) applicationContext.getBean(&quot;</span>userService<span class="string">&quot;);</span></span><br><span class="line"><span class="string">System.out.println(userService);</span></span><br></pre></td></tr></table></figure><h3 id="容器的创建方式"><a href="#容器的创建方式" class="headerlink" title="容器的创建方式"></a>容器的创建方式</h3><p>案例中创建<code>ApplicationContext</code>的方式如下：</p><p>这两种都是针对配置文件的核心容器</p><p>这种方式翻译为：类路径下的XML配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure><p>除了上面这种方式，Spring还提供了另外一种创建方式</p><p>这种方式翻译为：文件系统下的XML配置文件，路径需要写绝对路径</p><p>这种方式虽能实现，但是当项目的位置发生变化后，代码也需要跟着改，耦合度高，不推荐使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(<span class="string">&quot;D:\xxx/xxx\applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-DI</title>
      <link href="/2023/08/29/Spring03DI/"/>
      <url>/2023/08/29/Spring03DI/</url>
      
        <content type="html"><![CDATA[<h1 id="DI依赖注入"><a href="#DI依赖注入" class="headerlink" title="DI依赖注入"></a>DI依赖注入</h1><ol><li><p>向一个类中传递数据的方式有几种?</p><ul><li>set方法</li><li>构造方法</li></ul></li><li><p>依赖注入描述了在容器中建立Bean与Bean之间的依赖关系的过程，如果bean运行需要的是数字或字符串呢?</p><ul><li>引用类型</li><li>简单类型(基本数据类型与String)</li></ul></li></ol><p>Spring就是基于上面这些知识点，为我们提供了两种注入方式，分别是:</p><ol><li><p>setter注入</p><ul><li>简单类型</li><li>引用类型</li></ul></li><li><p>构造器注入</p><ul><li>简单类型</li><li>引用类型</li></ul></li></ol><p><strong>思考:</strong></p><ul><li><p>引用类型使用的是<code>&lt;property name=&quot;&quot; ref=&quot;&quot;/&gt;</code>，简单数据类型还是使用ref吗?</p></li><li><p>ref是指向Spring的IOC容器中的另一个bean对象的，对于简单数据类型，没有对应的bean对象，该如何配置呢?</p><p>使用value来配置<code>&lt;property name=&quot;&quot; value=&quot;&quot;/&gt;</code></p></li></ul><h2 id="setter注入"><a href="#setter注入" class="headerlink" title="setter注入"></a>setter注入</h2><p>对于setter方式注入引用类型的方式之前已经学习过，快速回顾下:</p><ol><li><p>在bean中定义引用类型属性，并提供可访问的set方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置中使用property标签ref属性注入引用类型对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>回顾一下配置中的两个bookDao的含义：</p><p>配置中的两个bookDao的含义是不一样的</p><ul><li><code>name=&quot;bookDao&quot;</code>中bookDao的作用是让Spring的IOC容器在获取到名称后，将首字母大写，前面加set找对应的setBookDao()方法进行对象注入</li><li><code>ref=&quot;bookDao&quot;</code>中bookDao的作用是让Spring能在IOC容器中找到id为bookDao的Bean对象给bookService进行注入</li></ul></li></ol><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">环境准备</button></li><li class="tab"><button type="button" data-href="#test1-2">引用数据类型</button></li><li class="tab"><button type="button" data-href="#test1-3">简单数据类型</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><ol><li><p>在dao包下新建一个UserDao接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后新建一个UserDaoImpl类实现UserDao接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后修改我们之前的BookDao等类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置文件如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.dao.impl.BookDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改App运行类，加载Spring的IOC容器，并从中获取对应的bean对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService) context.getBean(<span class="string">&quot;bookService&quot;</span>);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p>需求：在bookServiceImpl对象中注入userDao</p><p>步骤：</p><ol><li><p>在BookServiceImpl中声明userDao属性，为userDao属性提供setter方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="comment">//声明属性</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="comment">//提供setter</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在配置文件中注入配置<br>在applicationContext.xml配置文件中使用property标签注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.dao.impl.BookDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.dao.impl.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p>需求：给BookDaoImpl注入一些简单数据类型的数据</p><p>步骤：</p><ol><li><p>声明对应的简单数据类型的属性，为这些属性提供对应的setter方法</p><p>这里举例就用<code>String dataBaseName</code>和<code>int connectionCount</code>这两个属性，同时在save()方法的输出语句中加上这两个属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String dataBaseName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> connectionCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDataBaseName</span><span class="params">(String dataBaseName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dataBaseName = dataBaseName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setConnectionCount</span><span class="params">(<span class="type">int</span> connectionCount)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.connectionCount = connectionCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span> + dataBaseName + <span class="string">&quot;,&quot;</span> + connectionCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在配置文件中进行注入配置<br>在applicationContext.xml配置文件中使用property标签注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataBaseName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connectionCount&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.dao.impl.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>value：后面跟的是简单数据类型，对于参数类型，Spring在注入的时候会自动转换，但是不能写一个错误的类型，例如<code>connectionCount</code>是<code>int</code>类型，你却给他传一个<code>abc</code>，这样的话，spring在将<code>abc</code>转换成int类型的时候就会报错。</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ol><li><p>修改BookDao、BookDaoImpl、UserDao、UserDaoImpl、BookService和BookServiceImpl类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String databaseName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> connectionNum;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="构造器注入引用数据类型"><a href="#构造器注入引用数据类型" class="headerlink" title="构造器注入引用数据类型"></a>构造器注入引用数据类型</h3><blockquote><p>需求：将BookServiceImpl类中的bookDao修改成使用构造器的方式注入。</p><ol><li>将bookDao的setter方法删除掉</li><li>添加带有bookDao参数的构造方法</li><li>在applicationContext.xml中配置</li></ol></blockquote><ol><li><p>删除setter方法并提供构造方法</p><p>在BookServiceImpl类中将bookDao的setter方法删除掉，并添加带有bookDao参数的构造方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class BookServiceImpl implements BookService&#123;</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    public BookServiceImpl(BookDao bookDao) &#123;</span><br><span class="line">        this.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置文件中进行配置构造方式注入<br>在applicationContext.xml中配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>说明：在标签<code>&lt;constructor-arg&gt;</code>中</p><ul><li>name属性对应的值为构造函数中方法<code>形参的参数名</code>，必须要保持一致。</li><li>ref属性指向的是spring的IOC容器中其他bean对象。</li></ul></li><li><p>运行程序</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310061510539.png"></p></li></ol><h3 id="构造器注入多个引用数据类型"><a href="#构造器注入多个引用数据类型" class="headerlink" title="构造器注入多个引用数据类型"></a>构造器注入多个引用数据类型</h3><blockquote><p>需求：在BookServiceImpl使用构造函数注入多个引用数据类型，比如userDao</p><ol><li>声明userDao属性</li><li>生成一个带有bookDao和userDao参数的构造函数</li><li>在applicationContext.xml中配置注入</li></ol></blockquote><ol><li><p>提供多个属性的构造函数<br>在BookServiceImpl声明userDao并提供多个参数的构造函数，save方法中记得调用userDao.save()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class BookServiceImpl implements BookService &#123;</span><br><span class="line">    private BookDao bookDao;</span><br><span class="line">    private UserDao userDao;</span><br><span class="line"></span><br><span class="line">    public BookServiceImpl(BookDao bookDao, UserDao userDao) &#123;</span><br><span class="line">        this.bookDao = bookDao;</span><br><span class="line">        this.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book service save ...&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在配置文件中配置多参数注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="构造器注入多个简单数据类型"><a href="#构造器注入多个简单数据类型" class="headerlink" title="构造器注入多个简单数据类型"></a>构造器注入多个简单数据类型</h3><blockquote><p>需求:在BookDaoImpl中，使用构造函数注入databaseName和connectionNum两个参数。<br>参考引用数据类型的注入，我们可以推出具体的步骤为:</p><ol><li>提供一个包含这两个参数的构造方法</li><li>在applicationContext.xml中进行注入配置</li></ol></blockquote><ol><li><p>添加多个简单属性并提供构造方法<br>修改BookDaoImpl类，添加构造方法，同时在save()方法中输出这两个属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class BookDaoImpl implements BookDao &#123;</span><br><span class="line"></span><br><span class="line">    private String databaseName;</span><br><span class="line">    private int connectionNum;</span><br><span class="line"></span><br><span class="line">    public BookDaoImpl(String databaseName, int connectionNum) &#123;</span><br><span class="line">        this.databaseName = databaseName;</span><br><span class="line">        this.connectionNum = connectionNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void save() &#123;</span><br><span class="line">        System.out.println(&quot;book dao save ...&quot; + databaseName + &quot;,&quot; + connectionNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置完成多个属性构造器注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;databaseName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;connectionNum&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>也是用 VALUE 属性</p></blockquote></li></ol><h3 id="目前存在的问题"><a href="#目前存在的问题" class="headerlink" title="目前存在的问题"></a>目前存在的问题</h3><p><code>&lt;constructor-arg&gt;</code>标签内的name，必须与构造函数中的参数名一致，这两块存在紧耦合。</p><p>那么我们怎么解决这个问题呢？</p><p>在解决这个问题之前，需要提前说明的是，这个参数名发生变化的情况并不多，所以上面的还是比较主流的配置方式，下面介绍的，我们以了解为主。</p><p>方式一：删除name属性，添加type属性，按照类型注入</p><ul><li><p>这种方式可以解决构造函数形参名发生变化带来的耦合问题</p></li><li><p>但是如果构造方法参数中有类型相同的参数，这种方式就不太好实现了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>=<span class="string">&quot;9421&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>方式二：删除type属性，添加index属性，按照索引下标注入，下标从0开始</p><ul><li><p>这种方式可以解决参数类型重复问题</p></li><li><p>但是如果构造方法参数顺序发生变化后，这种方式又带来了耦合问题</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;9421&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>介绍完两种参数的注入方式，具体我们该如何选择呢?</p><ol><li>强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现<ul><li>强制依赖指对象在创建的过程中必须要注入指定的参数</li></ul></li><li>可选依赖使用setter注入进行，灵活性强<ul><li>可选依赖指对象在创建过程中注入的参数可有可无</li></ul></li><li>Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨</li><li>如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入</li><li>实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入</li><li>自己开发的模块推荐使用setter注入</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这部分主要讲解的是Spring的依赖注入的实现方式:</p><p>setter注入</p><ul><li><p>简单数据类型</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>引用数据类型</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>构造器注入</p><ul><li><p>简单数据类型</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">index</span>=<span class="string">&quot;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>引用数据类型</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">index</span>=<span class="string">&quot;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>依赖注入的方式选择上</p><ul><li>建议使用setter注入</li><li>第三方技术根据情况选择</li></ul><h2 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h2><p>前面花了大量的时间把Spring的注入去学习了下，总结起来就两个字<code>麻烦</code>。</p><ul><li>问:麻烦在哪?<ul><li>答:配置文件的编写配置上。</li></ul></li><li>问:有更简单方式么?<ul><li>答:有，自动配置</li></ul></li></ul><p>什么是依赖自动装配？</p><p>IOC容器根据bean所依赖的资源在容器中<code>自动查找并注入</code>到bean中的过程称为自动装配</p><h3 id="自动装配方式有哪些？"><a href="#自动装配方式有哪些？" class="headerlink" title="自动装配方式有哪些？"></a>自动装配方式有哪些？</h3><ul><li>按类型（常用）</li><li>按名称</li><li>按构造方法</li><li>不启用自动装配</li></ul><h3 id="环境准备-1"><a href="#环境准备-1" class="headerlink" title="环境准备"></a>环境准备</h3><ol><li><p>修改BookDao、BookDaoImpl、UserDao、UserDaoImpl、BookService和BookServiceImpl类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String databaseName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> connectionNum;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="自动装配实现"><a href="#自动装配实现" class="headerlink" title="自动装配实现"></a>自动装配实现</h3><p>自动装配只需要修改applicationContext.xml配置文件即可:</p><ol><li><p>将<code>&lt;property&gt;</code>标签删除</p></li><li><p>在<code>&lt;bean&gt;</code>标签中添加autowire属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.service.impl.BookServiceImpl&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><p>注意事项：</p><ul><li>需要注入属性的类中对应属性的<code>setter</code>方法不能省略</li><li>被注入的对象必须要被Spring的IOC容器管理</li><li>按照类型在Spring的IOC容器中如果找到多个对象，会报<code>NoUniqueBeanDefinitionException</code></li></ul></blockquote><p>当一个类型在IOC中有多个对象，还想要注入成功，这个时候就需要按照名称注入，配置方式如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--这里就有两个同一类型的bean，但是id不一样--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.service.impl.BookServiceImpl&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同时修改BookServiceImpl类汇总的<code>setBookDao</code>方法，将其重命名为<code>setBookDao1</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao1</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么刚刚修改的是setBookDao的方法名，而不是将bookDao属性修改为bookDao1呢？按照名称注入中的名称指的是什么?</p><ul><li>因为bookDao是private修饰的，外部类无法直接访问</li><li>所以外部类只能通过属性的set方法进行访问</li><li>对外部类来说，setBookDao方法名，去掉set后首字母小写是其属性名<ul><li>为什么是去掉set首字母小写?</li><li>这个规则是set方法生成的<code>默认规则</code>，set方法的生成是把属性名首字母大写前面加set形成的方法名</li></ul></li><li>所以按照名称注入，其实是和对应的set方法有关，但是如果按照标准起名称，属性名和set对应的名是一致的</li></ul><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul><li>如果按照名称去找对应的bean对象，找不到则注入Null（空指针）</li><li>当某一个类型在IOC容器中有多个对象，按照名称注入只找其指定名称对应的bean对象，不会报错</li><li>两种方式介绍完后，以后用的更多的是<code>按照类型</code>注入。</li><li>最后对于依赖注入，需要注意一些其他的配置特征:<ol><li>自动装配用于引用类型依赖注入，不能对简单类型进行操作</li><li>使用按类型装配时（byType）必须保障容器中相同类型的bean唯一，推荐使用</li><li>使用按名称装配时（byName）必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用</li><li>自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效</li></ol></li></ul><h2 id="集合注入"><a href="#集合注入" class="headerlink" title="集合注入"></a>集合注入</h2><p>前面我们已经能完成引入数据类型和简单数据类型的注入，但是还有一种数据类型<code>集合</code>，集合中既可以装简单数据类型也可以装引用数据类型，对于集合，在Spring中该如何注入呢?</p><p>先来回顾下，常见的集合类型有哪些?</p><ul><li>数组</li><li>List</li><li>Set</li><li>Map</li><li>Properties</li></ul><p>针对不同的集合类型，实现注入</p><h4 id="注入数组类型"><a href="#注入数组类型" class="headerlink" title="注入数组类型"></a>注入数组类型</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;array&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>100<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>200<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>300<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="注入List类型"><a href="#注入List类型" class="headerlink" title="注入List类型"></a>注入List类型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;list&quot;&gt;</span><br><span class="line">    &lt;list&gt;</span><br><span class="line">        &lt;value&gt;张三&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;ABC&lt;/value&gt;</span><br><span class="line">        &lt;value&gt;123&lt;/value&gt;</span><br><span class="line">    &lt;/list&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><h4 id="注入Set类型"><a href="#注入Set类型" class="headerlink" title="注入Set类型"></a>注入Set类型</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;set&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>100<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>200<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>ABC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>ABC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="注入Map类型"><a href="#注入Map类型" class="headerlink" title="注入Map类型"></a>注入Map类型</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;探路者&quot;</span> <span class="attr">value</span>=<span class="string">&quot;马文&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;次元游记兵&quot;</span> <span class="attr">value</span>=<span class="string">&quot;恶灵&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;易位窃贼&quot;</span> <span class="attr">value</span>=<span class="string">&quot;罗芭&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="注入Properties类型"><a href="#注入Properties类型" class="headerlink" title="注入Properties类型"></a>注入Properties类型</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;暴雷&quot;</span>&gt;</span>沃尔特·菲茨罗伊<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;寻血猎犬&quot;</span>&gt;</span>布洛特·亨德尔<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;命脉&quot;</span>&gt;</span>阿杰·切<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>property标签表示setter方式注入，构造方式注入constructor-arg标签内部也可以写<code>&lt;array&gt;</code>、<code>&lt;list&gt;</code>、<code>&lt;set&gt;</code>、<code>&lt;map&gt;</code>、<code>&lt;props&gt;</code>标签</li><li>List的底层也是通过数组实现的，所以<code>&lt;list&gt;</code>和<code>&lt;array&gt;</code>标签是可以混用</li><li>集合中要添加引用类型，只需要把<code>&lt;value&gt;</code>标签改成<code>&lt;ref&gt;</code>标签，这种方式用的比较少</li></ul><h1 id="DI注入标签"><a href="#DI注入标签" class="headerlink" title="DI注入标签"></a>DI注入标签</h1><div class="tabs" id="di注入标签"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#di注入标签-1">constructor-arg</button></li><li class="tab"><button type="button" data-href="#di注入标签-2">property</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="di注入标签-1"><p>指定创建类对象时使用哪个构造函数，每一对或者每一个constructor-arg子标签配置一个参数列表中的参数值；如果不配置子标签，则默认使用无参构造方法实例化对象</p><p>属性：</p><ul><li>name属性：通过参数名找到参数列表中对应参数</li><li>index属性：通过参数在参数列表中的索引找到参数列表中对应参数，index从0开始：</li><li>type属性：通过参数数据类型找到参数列表中对应参数</li><li>value属性：设置参数列表参数对应的值，用于设定基本数据类型和String类型的数据</li><li>ref属性：如果参数值为非基本数据类型，则可通过ref为参数注入值，其值为另一个bean标签id或name属性的属性值</li></ul><p>子标签：</p><ul><li>ref子标签：对应ref属性，该标签name属性的属性值为另一个bean标签id或name属性的属性值；</li><li>value子标签：对应value属性,用于设置基本数据类型或String类型的参数值；</li><li>list子标签：为数组或List类型的参数赋值</li><li>set子标签：为Set集合类型参数赋值</li><li>map子标签：为Map集合类型参数赋值</li><li>props子标签：为Properties类型的参数赋值</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="di注入标签-2"><p>Bean定义可以具有零个或多个属性。属性元素对应于bean类公开的 JavaBean setter方法。 Spring支持原语，对相同或相关工厂中的其他bean的引用，列表，映射和属性</p><p>属性：</p><ul><li>name属性：通过参数名找到参数列表中对应参数</li><li>value子标签：对应value属性,用于设置基本数据类型或String类型的参数值</li><li>ref属性：如果参数值为非基本数据类型，则可通过ref为参数注入值，其值为另一个bean标签id或name属性的属性值</li></ul><p>子标签：</p><ul><li>ref子标签：对应ref属性，该标签name属性的属性值为另一个bean标签id或name属性的属性值；</li><li>value子标签：对应value属性,用于设置基本数据类型或String类型的参数值；</li><li>list子标签：为数组或List类型的参数赋值</li><li>set子标签：为Set集合类型参数赋值</li><li>map子标签：为Map集合类型参数赋值</li><li>props子标签：为Properties类型的参数赋值</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>constructor-arg和property的区别：</p><ul><li>constructor-arg：通过构造函数注入</li><li>property：通过setter对应的方法注入</li></ul><h2 id="Bean的依赖注入配置"><a href="#Bean的依赖注入配置" class="headerlink" title="Bean的依赖注入配置"></a>Bean的依赖注入配置</h2><div class="tabs" id="3"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#3-1">set方法注入</button></li><li class="tab"><button type="button" data-href="#3-2">构造方法进行注入</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="3-1"><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">value</span>=<span class="string">&quot;haohao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3-2"><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;haohao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>ref 是 reference 的缩写，用于引用其他Bean的id。</p><p>value 用于注入普通属性值。</p><p>依赖注入的数据类型有如下三种：</p><ol><li>普通数据类型，例如：String、int、boolean等，通过value属性指定</li><li>引用数据类型，例如：UserDaoImpl、DataSource等，通过ref属性指定</li><li>集合数据类型，例如：List、Map、Properties等，有单独的格式</li></ol><h2 id="自动装配方式"><a href="#自动装配方式" class="headerlink" title="自动装配方式"></a>自动装配方式</h2><p>如果被注入的属性类型是Bean引用的话，那么可以在标签中使用 autowire 属性去配置自动注入方式，属性值有两个：</p><ol><li>byName：通过属性名自动装配，即去匹配 setXxx 与 id&#x3D;”xxx”（name&#x3D;”xxx”）是否一致</li><li>byType：通过Bean的类型从容器中匹配，匹配出多个相同Bean类型时，报错</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.UserServiceImpl&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.UserServiceImpl&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 框架 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-IOC</title>
      <link href="/2023/08/29/Spring02IOC/"/>
      <url>/2023/08/29/Spring02IOC/</url>
      
        <content type="html"><![CDATA[<h1 id="IOC相关内容"><a href="#IOC相关内容" class="headerlink" title="IOC相关内容"></a>IOC相关内容</h1><h2 id="bean基础配置"><a href="#bean基础配置" class="headerlink" title="bean基础配置"></a>bean基础配置</h2><p>对于bean的配置中，主要是<code>bean基础配置</code>，<code>bean的别名配置</code>，<code>bean的作用范围配置</code>(重点)，这三部分内容</p><table><thead><tr><th>属性</th><th>功能描述</th></tr></thead><tbody><tr><td>id</td><td>Bean的id</td></tr><tr><td>class</td><td>Bean的全限定类名</td></tr><tr><td>name</td><td>通过name设置Bean的别名，通过别名也能直接获取到Bean实例</td></tr><tr><td>scope</td><td>Bean的作用范围，BeanFactory作为容器时取值singleton和prototype</td></tr><tr><td>lazy-init</td><td>Bean的实例化时机，是否延迟加载。BeanFactory作为容器时无效</td></tr><tr><td>init-method</td><td>Bean实例化后自动执行的初始化方法，method指定方法名</td></tr><tr><td>destroy-method</td><td>Bean实例销毁前的方法，method指定方法名</td></tr><tr><td>autowire</td><td>设置自动注入模式<br>常用的有按照类型byType，按照名字byName</td></tr><tr><td>factory-bean</td><td>指定<strong>哪个工厂Bean</strong>完成Bean的创建</td></tr><tr><td>factory-method</td><td>指定工厂Bean的<strong>哪个方法</strong>完成Bean的创建</td></tr></tbody></table><ul><li><p>Bean的基础配置：id 和 class</p><p>id：bean的名字，但进后面的容器后 id 会转变为 name</p><p>class：bean的全路径，通过反射创建的bean对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">applicationContext.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br></pre></td></tr></table></figure><p>此时存储到<strong>singleObjects单例池</strong>中的Bean的beanName是userDao，值是UserDaoImpl对象，可以根据beanName获取Bean实例，如果不配置id，则Spring会把当前Bean实例的全限定名作为beanName</p><blockquote><p>debug中可以看见，key对应id，value对应值</p></blockquote></li><li><p>Bean的别名配置：name</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">name</span>=<span class="string">&quot;aaa,bbb&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>可以为当前Bean指定多个别名，根据别名也可以获得Bean对象，此时多个名称都可以获得UserDaoImpl实例对象，使用时优先id</p></li><li><p>Bean的范围配置：单例和非单例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//singleton</span></span><br><span class="line">&lt;bean id=<span class="string">&quot;userDao&quot;</span> class=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span> scope=<span class="string">&quot;singleton&quot;</span>/&gt;</span><br><span class="line"><span class="type">Object</span> <span class="variable">userDao</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">userDao2</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">System.out.println(userDao); <span class="comment">//com.itheima.dao.impl.UserDaoImpl@631330c</span></span><br><span class="line">System.out.println(userDao2); <span class="comment">//com.itheima.dao.impl.UserDaoImpl@631330c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//prototype</span></span><br><span class="line">&lt;bean id=<span class="string">&quot;userDao&quot;</span> class=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span> scope=<span class="string">&quot;prototype&quot;</span>/&gt;</span><br><span class="line"><span class="type">Object</span> <span class="variable">userDao</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">userDao2</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">System.out.println(userDao); <span class="comment">//com.itheima.dao.impl.UserDaoImpl@4d50efb8</span></span><br><span class="line">System.out.println(userDao2); <span class="comment">//com.itheima.dao.impl.UserDaoImpl@7e2d773b</span></span><br></pre></td></tr></table></figure><p>singleton：默认值，Spring容器创建的时候，就会进行Bean的实例化，并存储到容器内部的单例池中 ，每次getBean时都是从单例池中获取相同的Bean实例；</p><p>prototype：Spring容器初始化时不会创建Bean实例，当调用getBean时才会实例化Bean，每次 getBean都会创建一个新的Bean实例，即用即创，用后回收</p></li><li><p>Bean的延迟加载</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span> <span class="attr">lazy-init</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>当lazy-init设置为true时为延迟加载，也就是当Spring容器创建的时候，不会立即创建Bean实例，等待用到时在创建Bean实例并存储到单例池中去，后续在使用该Bean直接从单例池获取即可，本质上该Bean还是单例的</p></li><li><p>Bean的初始化和销毁方法配置</p><p>Bean在<strong>被实例化后</strong>，可以执行指定的初始化方法完成一些初始化的操作，Bean在销毁之前也可以执行指定的销毁方法完成一些操作，初始化方法名称和销毁方法名称通过 init-method 和 destroy-method 指明</p><p>后面的学习中会遇到其他的功能增强，不同增强发生的时机不同。初始化和销毁方法是比较靠后的增强</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">destroy-method</span>=<span class="string">&quot;destroy&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">UserDaoImpl</span><span class="params">()</span> &#123; System.out.println(<span class="string">&quot;UserDaoImpl创建了...&quot;</span>); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123; System.out.println(<span class="string">&quot;初始化方法...&quot;</span>); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123; System.out.println(<span class="string">&quot;销毁方法...&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是销毁方法不一定有机会使用，就像关电视一样，直接断电源是来不及调用方法的</p></li><li><p>实现 InitializingBean 接口，完成一些Bean的初始化操作</p><p>InitializingBean是个规范，定义好了一堆抽象方法和他们的使用时机，我们使用的时候完成相应方法的功能即可，没有多余配置，执行时机早于init-method，在属性设置之后执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>, InitializingBean &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">UserDaoImpl</span><span class="params">()</span> &#123;System.out.println(<span class="string">&quot;UserDaoImpl创建了...&quot;</span>);&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;System.out.println(<span class="string">&quot;初始化方法...&quot;</span>);&#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;System.out.println(<span class="string">&quot;销毁方法...&quot;</span>);&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//执行时机早于init-method配置的方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;InitializingBean...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>import导入配置文件</p><p>用于导入其他配置文件，项目变大后，就会导致一个配置文件内容过多，可以将一个配置文件根据业务模块进行拆分，拆分后，最终通过&lt; import&gt;标签导入到一个主配置文件中，项目加载主配置文件就连同 &lt; import&gt;导入的文件一并加载了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入用户模块配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;classpath:UserModuleApplicationContext.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--导入商品模块配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;classpath:ProductModuleApplicationContext.xml&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>alias 标签是为某个Bean添加别名:</p><p>在beanFactory中维护着一个名为aliasMap的Map集合，存储别名和beanName 之间的映射关系</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置UserService--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">name</span>=<span class="string">&quot;bbb&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--指定别名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;xxx&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;yyy&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="别名配置"><a href="#别名配置" class="headerlink" title="别名配置"></a>别名配置</h3><p>可以在bean标签中配置name属性充当别名</p><ol><li><p>配置别名<br>打开spring的配置文件<code>applicationContext.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--name:为bean指定别名，别名可以有多个，使用逗号，分号，空格进行分隔--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">name</span>=<span class="string">&quot;service1 service2 service3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>根据名称容器中获取bean对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//此处根据bean标签的id属性和name属性的任意一个值来获取bean对象</span></span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService) context.getBean(<span class="string">&quot;service2&quot;</span>);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>注意事项：</p><ul><li><p>bean依赖注入的ref属性指定bean，必须在容器中存在，而ref的值也可以是name里的别名，不过还是建议用id值来注入</p></li><li><p>如果我们在调用getBean(String name)方法时，传入了一个不存在该名称的bean对象，则会报错<code>NoSuchBeanDefinitionException</code>，此时我们要检查一下是哪边写错了</p><p>例如bean的id和name都没有service100，而getBean的参数却写了service100</p></li></ul><h3 id="作用范围配置"><a href="#作用范围配置" class="headerlink" title="作用范围配置"></a>作用范围配置</h3><p>关于bean的作用范围是bean属性配置的一个重点内容。<br>bean的scope有两个取值：</p><ul><li>singleton：单例（默认）</li><li>prototype：非单例</li></ul><p>验证IOC容器中对象是否为单例：</p><p>验证思路：对同一个bean创建两个对象，然后打印二者的地址值，看看是否一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//我这里使用了别名，其实还是同一个bean</span></span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService2</span> <span class="operator">=</span> (BookService) context.getBean(<span class="string">&quot;service2&quot;</span>);</span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService3</span> <span class="operator">=</span> (BookService) context.getBean(<span class="string">&quot;service3&quot;</span>);</span><br><span class="line">        System.out.println(bookService2);</span><br><span class="line">        System.out.println(bookService3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想创建出来非单例的bean对象，在Spring的配置文件中，修改<code>&lt;bean&gt;</code>的scope属性为prototype</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">name</span>=<span class="string">&quot;service1 service2 service3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.service.impl.BookServiceImpl&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>介绍完<code>scope</code>属性以后，我们来思考几个问题:</p><ol><li><p>为什么bean默认为单例?</p><ul><li>bean为单例的意思是在Spring的IOC容器中只会有该类的一个对象</li><li>bean对象只有一个就避免了对象的频繁创建与销毁，达到了bean对象的复用，性能高</li></ul></li><li><p>bean在容器中是单例的，会不会产生线程安全问题?</p><ul><li>如果对象是有状态对象，即该对象有成员变量可以用来存储数据的，因为所有请求线程共用一个bean对象，所以会存在线程安全问题。</li><li>如果对象是无状态对象，即该对象没有成员变量没有进行数据存储的，因方法中的局部变量在方法调用完成后会被销毁，所以不会存在线程安全问题。</li></ul></li><li><p>哪些bean对象适合交给容器进行管理?</p><ul><li>表现层对象（controller）</li><li>业务层对象（service）</li><li>数据层对象（dao）</li><li>工具对象（util）</li></ul></li><li><p>哪些bean对象不适合交给容器进行管理?</p><p>封装实例的域对象（domain，pojo），因为会引发线程安全问题，所以不适合。</p></li></ol><h3 id="其他配置标签"><a href="#其他配置标签" class="headerlink" title="其他配置标签"></a>其他配置标签</h3><p>Spring 的 xml 标签大体上分为两类，一种是默认标签，一种是自定义标签 </p><div class="tabs" id="标签"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#标签-1">默认标签</button></li><li class="tab"><button type="button" data-href="#标签-2">自定义标签</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="标签-1"><p>默认标签：就是不用额外导入其他命名空间约束的标签，Spring的默认标签用到的是Spring的默认命名空间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述代码解读：</p><ol><li><p>xml第一行必须定义为文档声明</p><p>version：版本号  </p><p>encoding：编码方式，告知解析引擎当前文档使用的字符集</p></li><li><p>xml文档中有且仅有一个根标签</p><p>根标签&lt; beans&gt;&lt; &#x2F;beans&gt;</p><p>xsd文件的前面部分就是它的命名空间</p><p>如spring-beans.xsd的命名空间就是：<code>http://www.springframework.org/schema/beans/spring-beans</code></p></li><li><p>属性值必须使用引号(单双都可)引起来</p></li><li><p>标签必须正确关闭</p></li><li><p>xml标签名称区分大小写</p></li></ol><p>该命名空间约束下的默认标签如下：</p><table><thead><tr><th>标签</th><th>作用</th></tr></thead><tbody><tr><td>&lt; beans&gt;</td><td>一般作为 xml 配置根标签，其他标签都是该标签的子标签<br>嵌套在根标签内，使用profile属性切换开发环境</td></tr><tr><td>&lt; bean&gt;</td><td>Bean的配置标签，上面已经详解了，此处不再阐述</td></tr><tr><td>&lt; import&gt;</td><td>外部资源导入标签</td></tr><tr><td>&lt; alias&gt;</td><td>指定Bean的别名标签，使用较少</td></tr></tbody></table><p>beans切换开发环境：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置测试环境下，需要加载的Bean实例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">&quot;test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置开发环境下，需要加载的Bean实例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">&quot;dev&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以使用以下两种方式指定被激活的环境：</p><ol><li>使用命令行动态参数，虚拟机参数位置加载 -Dspring.profiles.active&#x3D;test</li><li>使用代码的方式设置环境变量 System.setProperty(“spring.profiles.active”,”test”)</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="标签-2"><p>schema引入</p><p>自定义标签：就是需要额外引入其他命名空间约束，并通过前缀引用的标签</p><p>在配置外部的命名空间时 需要提前在pom中导入对应的依赖</p><p>自定义标签的 xmlns和xsi:schemaLocation是成对配置的</p><ul><li><code>xmlns:别名</code>：用来声明引入某个jar包一类的，然后就能用&lt;别名 : 标签名&gt;使用对应的标签</li><li><code>xsi:schemaLocation</code>：后跟着的看着像一个网页地址，但实际上定位是我们引入的jar包地址</li></ul><p>需要的自定义标签可以去对应的官网找</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="获取Bean"><a href="#获取Bean" class="headerlink" title="获取Bean"></a>获取Bean</h2><h3 id="getBean方法"><a href="#getBean方法" class="headerlink" title="getBean方法"></a>getBean方法</h3><table><thead><tr><th>方法定义</th><th>返回值和参数</th></tr></thead><tbody><tr><td>Object getBean (String beanName)</td><td>根据beanName从容器中获取Bean实例，要求容器中Bean唯一，返回值为Object，需要强转</td></tr><tr><td>T getBean (Class type)</td><td>根据Class类型从容器中获取Bean实例，要求容器中Bean类型唯一，返回值为Class类型实例， 无需强转</td></tr><tr><td>T getBean (String beanName，Class type)</td><td>根据beanName从容器中获得Bean实例，返回值为Class类型实例，无需强转</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据beanName获取容器中的Bean实例，需要手动强转</span></span><br><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) applicationContext.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据Bean类型去容器中匹配对应的Bean实例，如存在多个匹配Bean则报错</span></span><br><span class="line"><span class="type">UserService</span> <span class="variable">userService2</span> <span class="operator">=</span> applicationContext.getBean(UserService.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据beanName获取容器中的Bean实例，指定Bean的Type类型</span></span><br><span class="line"><span class="type">UserService</span> <span class="variable">userService3</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;userService&quot;</span>,</span><br><span class="line">UserService.class);</span><br></pre></td></tr></table></figure><h3 id="Bean实例化"><a href="#Bean实例化" class="headerlink" title="Bean实例化"></a>Bean实例化</h3><p>对象已经能交给Spring的IOC容器来创建了，但是容器是如何来创建对象的呢?</p><p>就需要研究下bean的实例化过程，在这块内容中主要解决两部分内容，分别是</p><ul><li>bean是如何创建的</li><li>实例化bean的三种方式，<code>构造方法</code>，<code>静态工厂</code>和<code>实例工厂</code></li></ul><p>在讲解这三种创建方式之前，我们需要先确认一件事:</p><ul><li>bean本质上就是对象，对象在new的时候会使用构造方法完成，那创建bean也是使用构造方法完成的。</li></ul><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">构造方法</button></li><li class="tab"><button type="button" data-href="#test1-2">静态工厂</button></li><li class="tab"><button type="button" data-href="#test1-3">实例工厂</button></li><li class="tab"><button type="button" data-href="#test1-4">FactoryBean延迟实例化</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p>构造方法实例化：底层通过构造方法对Bean进行实例化</p><p>构造方式实例化Bean又分为<strong>无参构造方法实例化</strong>和<strong>有参构造方法实例化</strong>，Spring中配置的几乎都是无参构造该方式</p><p>有参构造在实例化Bean时，需要参数的注入，通过标签，嵌入在标签内部提供构造参数</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;haohao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>例子：</p><ul><li><p>在之前的BookDaoImpl类中添加一个无参构造函数，并打印一句话，方便观察结果，运行程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookDaoImpl</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao constructor is running ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>如果将构造器私有化继续测试，结果仍然会成功，说明内部走的依然是构造函数，能访问到类中的私有构造方法，显而易见Spring底层用的是反射</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p>创建一个工厂类BookDaoFactory并提供一个静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态工厂创建对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BookDao <span class="title function_">getBookDaoImpl</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BookDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改App运行类，在类中通过工厂获取对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//通过静态工厂创建对象</span></span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> BookDaoFactory.getBookDaoImpl();</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将这种方式交给Spring来管理，需要用到Spring中的静态工厂实例化的知识了，具体实现步骤为：</p><ol><li><p>在spring的配置文件<code>application.properties</code>修改bookDao的bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.factory.BookDaoFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getBookDaoImpl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>class：工厂类的类全名<br>factory-mehod：具体工厂类中创建对象的方法名</p></li><li><p>在App运行类，使用从IOC容器中获取bean的方法进行运行测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        BookDao bookDao = (BookDao) context.getBean(&quot;bookDao&quot;);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行后，结果如下</p><p>与我们自己直接new对象没太大区别，而且还麻烦了，那这种方式的意义是什么呢？</p><p>在工厂的静态方法中，我们除了new对象还可以做其他的一些业务操作，而之前new对象的方式就无法添加其他的业务内容</p><blockquote><p>介绍完静态工厂实例化后，这种方式一般是用来兼容早期的一些老系统，所以<code>了解为主</code>。</p></blockquote></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><ol><li><p>在spring配置文件中修改bookDao的bean</p><p>先引入工厂的bean，再引入对象的bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDaoFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.factory.BookDaoFactory&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;bookDaoFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getBookDaoImpl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改工厂和运行类的方法</p><p>改工厂类<code>BookDaoFactory</code>的get方法，注意此处和静态工厂的工厂类不一样的地方是方法<code>不是静态方法</code></p><p>因为不是静态方法，所以要有<strong>工厂对象</strong>才能使用方法，所以引入了创造工厂的bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoFactory</span> &#123;</span><br><span class="line">    <span class="comment">//唯一的区别就是去掉的static</span></span><br><span class="line">    <span class="keyword">public</span> BookDao <span class="title function_">getBookDaoImpl</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao factory setup ...&quot;</span>);<span class="comment">//模拟必要的业务操作</span></span><br><span class="line">        <span class="comment">//这里还可以加一大堆业务逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BookDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改App运行类，在类中通过工厂获取对象，由于不是静态方法了，所以我们需要先创建实例工厂对象，然后再用实例工厂对象调用方法</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建实例工厂对象</span></span><br><span class="line">        <span class="type">BookDaoFactory</span> <span class="variable">bookDaoFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BookDaoFactory</span>();</span><br><span class="line">        <span class="comment">//通过实例工厂对象创建对象</span></span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> bookDaoFactory.getBookDaoImpl();</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>实例化工厂运行的顺序是:</p><ul><li>创建实例化工厂对象，对应的是第一行配置</li><li>调用对象中的方法来创建bean，对应的是第二行配置<ul><li>factory-bean:工厂的实例对象</li><li>factory-method:工厂对象中的具体创建对象的方法名</li></ul></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><p>底层用的多，开发中用的少</p><p>上面不管是静态工厂方式还是非静态工厂方式，都是自定义的工厂方法，Spring提供了FactoryBean的接口规范， FactoryBean接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FactoryBean</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">OBJECT_TYPE_ATTRIBUTE</span> <span class="operator">=</span> “factoryBeanObjectType”;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获得实例对象方法</span></span><br><span class="line">    T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获得实例对象类型方法</span></span><br><span class="line">    Class&lt;?&gt; getObjectType(); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置对象为单例</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FactoryBean接口其实会有三个方法：</p><ul><li>方法一：getObject()，被重写后，在方法中进行对象的创建并返回</li><li>方法二：getObjectType()，被重写后，主要返回的是被创建类的Class对象</li><li>方法三：没有被重写，因为它已经给了默认值，从方法名中可以看出其作用是设置对象是否为单例，默认true，这里就不加以验证了</li></ul><p>定义工厂实现FactoryBean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoFactoryBean3</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;UserDao&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> UserDao <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> UserDao.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置FactoryBean交由Spring管理即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.factory.UserDaoFactoryBean3&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>通过Spring容器根据beanName可以正常获得UserDaoImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathxmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">userDao</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">System.out.println(userDao);</span><br></pre></td></tr></table></figure><p>延迟解读：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathxmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>); </span><br><span class="line"><span class="type">Object</span> <span class="variable">userDao</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br></pre></td></tr></table></figure><ol><li>加载配置文件创建spring容器的时候，getBean方法没有执行，上述代码第一行</li><li>执行到getBean方法时，才运用这个方法，然后把对象存入factoryBeanObjectCache中。也就是说，真正要用的时候才创建bean</li></ol><p>好处：缓存需求，真正要用的时候才创建</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231116105646310.png" alt="image-20231116105646310"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="配置非自定义Bean"><a href="#配置非自定义Bean" class="headerlink" title="配置非自定义Bean"></a>配置非自定义Bean</h3><p>实际开发中有些 功能类并不是我们自己定义的，而是使用的第三方jar包中的，那么，这些Bean要想让Spring进行管理，也需要对其进行配置</p><p>配置非自定义的Bean需要考虑如下两个问题：</p><ol><li>被配置的Bean的实例化方式是什么？无参构造、有参构造、静态工厂方式还是实例工厂方式</li><li>被配置的Bean是否需要注入必要属性</li></ol><p>以德鲁伊为例</p><ul><li>实例化方式：无参构造</li><li>必要属性：4个基本属性</li></ul><p>步骤：</p><ol><li><p>引入依赖</p></li><li><p>加载启动，配置 Druid 数据源交由Spring管理，配置 DruidDataSource</p><p>查看源码，它有无参构造和有参构造，用无参构造的方法可以直接在XML中配置bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置 DruidDataSource数据源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置必要属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc://localhost:3306/mybatis&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置Connection交由Spring管理</p><p>Connection 的产生是通过DriverManager的静态方法getConnection获取的，可以视为静态工厂方式配置</p><p>这只是用来理解配置第三方bean的，开发不可能用这个方式，connection是被封装好了的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;java.lang.Class&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;forName&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;className&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;connection&quot;</span> <span class="attr">class</span>=<span class="string">&quot;java.sql.DriverManager&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getConnection&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///mybatis&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置MyBatis的SqlSessionFactory交由Spring管理</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--mybatis框架--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- mysql驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.49<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置MyBatis的SqlSessionFactory交由Spring管理 MyBatis原始获得SqlSessionFactory的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载mybatis核心配置文件，使用Spring静态工厂方式</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Resources.getResourceAsStream(“mybatis-conifg.xml”);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建SqlSessionFactoryBuilder对象，使用Spring无参构造方式</span></span><br><span class="line"><span class="type">SqlSessionFactoryBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用SqlSessionFactoryBuilder的build方法，使用Spring实例工厂方式</span></span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> builder.build(in);</span><br></pre></td></tr></table></figure></li><li><p>SqlSessionFactory交由Spring管理配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--静态工厂方式产生Bean实例--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">“inputStream”</span> <span class="attr">class</span>=<span class="string">“org.apache.ibatis.io.Resources</span>&quot; <span class="attr">factorymethod</span>=<span class="string">“getResourceAsStream”</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">“resource”</span> <span class="attr">value</span>=<span class="string">“mybatis-config.xml/</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--无参构造方式产生Bean实例--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactoryBuilder&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.ibatis.session.SqlSessionFactoryBuilder&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--实例工厂方式产生Bean实例--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;sqlSessionFactoryBuilder&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;build&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;inputStream&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;inputStream&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>于bean的相关知识还有最后一个是<code>bean的生命周期</code>，对于生命周期，我们主要围绕着<code>bean生命周期控制</code>来讲解</p><p>首先理解下什么是生命周期?</p><ul><li>从创建到消亡的完整过程，例如人从出生到死亡的整个过程就是一个生命周期。</li></ul><p>bean生命周期是什么?</p><ul><li>bean对象从创建到销毁的整体过程。</li></ul><p>bean生命周期控制是什么?</p><ul><li>在bean创建后到销毁前做一些事情。</li></ul><p>现在我们面临的问题是如何在bean的创建之后和销毁之前把我们需要添加的内容添加进去。</p><h3 id="生命周期设置"><a href="#生命周期设置" class="headerlink" title="生命周期设置"></a>生命周期设置</h3><p>具体的控制有两个阶段:</p><ul><li>bean创建之后，想要添加内容，比如用来初始化需要用到资源</li><li>bean销毁之前，想要添加内容，比如用来释放用到的资源</li></ul><ol><li><p>添加初始化和销毁方法</p><p>针对这两个阶段，我们在BookDaoImpl类中分别添加两个方法，方法名随便取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init ... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy ... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置生命周期<br>修改bookDao的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.blog.dao.impl.BookDaoImpl&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>运行</p><p>从结果中可以看出，init方法执行了，但是destroy方法却未执行，因为：</p><ul><li>Spring的IOC容器是运行在JVM中</li><li>运行main方法后，JVM启动，Spring加载配置文件生成IOC容器，从容器获取bean对象，然后调方法执行</li><li>main方法执行完后，JVM退出，这个时候IOC容器中的bean还没有来得及销毁就已经结束了</li><li>所以没有调用对应的destroy方法</li></ul></li></ol><h4 id="close关闭容器"><a href="#close关闭容器" class="headerlink" title="close关闭容器"></a>close关闭容器</h4><ul><li><p>ApplicationContext中没有close方法，它的子类中有close方法</p></li><li><p>所以需要将ApplicationContext更换成ClassPathXmlApplicationContext，然后调用close方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span></span><br><span class="line">        <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) context.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="注册钩子关闭容器"><a href="#注册钩子关闭容器" class="headerlink" title="注册钩子关闭容器"></a>注册钩子关闭容器</h4><ul><li><p>在容器未关闭之前，提前设置好回调函数，让JVM在退出之前回调此函数来关闭容器</p></li><li><p>调用context的registerShutdownHook()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) context.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">        context.registerShutdownHook();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：registerShutdownHook在ApplicationContext中也没有，还是要用其子类</p></blockquote></li></ul><p>那两种方式介绍完后，close和registerShutdownHook选哪个?</p><p>相同点：这两种都能用来关闭容器</p><p>不同点：close()是在调用的时候关闭，registerShutdownHook()是在JVM退出前调用关闭。</p><ul><li>那么registerShutdownHook()方法可以在任意位置调用，下面的代码中将其放在了第二行，仍能正常输出，但要是将其换成close()方法，则会报错<code>BeanFactory not initialized or already closed</code>，这里就是already closed</li></ul><p>开发中到底用哪个呢？</p><ul><li>答案是两个都不用</li><li>分析上面的实现过程，会发现添加初始化和销毁方法，即需要编码也需要配置，实现起来步骤比较多也比较乱。</li><li>Spring给我们提供了两个接口来完成生命周期的控制，好处是可以不用再进行配置<code>init-method</code>和<code>destroy-method</code></li></ul><p>接下来在BookServiceImpl完成这两个接口的使用</p><ol><li><p>修改BookServiceImpl类，添加两个接口<code>InitializingBean</code>， <code>DisposableBean</code>并实现接口中的两个方法<code>afterPropertiesSet</code>和<code>destroy</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>, InitializingBean, DisposableBean &#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;set ... &quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service destroy ... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service init ... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>BookServiceImpl的bean配置如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;bookService&quot;</span> class=<span class="string">&quot;com.blog.service.impl.BookServiceImpl&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;bookDao&quot;</span> ref=<span class="string">&quot;bookDao&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="bean生命周期小结"><a href="#bean生命周期小结" class="headerlink" title="bean生命周期小结"></a>bean生命周期小结</h3><ol><li><p>关于Spring中对bean生命周期控制提供了两种方式:</p><ul><li>在配置文件中的bean标签中添加<code>init-method</code>和<code>destroy-method</code>属性</li><li>类实现<code>InitializingBean</code>与<code>DisposableBean</code>接口</li></ul></li><li><p>对于bean的生命周期控制在bean的整个生命周期中所处的位置如下</p><ul><li>初始化容器<ul><li>1.创建对象(内存分配)</li><li>2.执行构造方法</li><li>3.执行属性注入(set操作)（<code>set ...</code>）</li><li>4.执行bean初始化方法（<code>service init ...</code>）</li></ul></li><li>使用bean<ul><li>执行业务操作（<code>book dao save ...</code>）</li></ul></li><li>关闭&#x2F;销毁容器<ul><li>执行bean销毁方法（<code>service destroy ...</code>）</li></ul></li></ul></li><li><p>关闭容器的两种方式：</p><p>ConfigurableApplicationContext是ApplicationContext的子类，子类才有下面两种方法</p><ul><li>close()方法</li><li>registerShutdownHook()方法</li></ul></li></ol><h2 id="自定义命名空间使用"><a href="#自定义命名空间使用" class="headerlink" title="自定义命名空间使用"></a>自定义命名空间使用</h2><p>外部命名空间标签的执行流程</p><ul><li>将自定义标签的约束 与 物理约束文件与网络约束名称的约束 以键值对形式存储到一个spring.schemas文件里<br>，该文件存储在类加载路径的 META-INF里，Spring会自动加载到;</li><li>将自定义命名空间的名称 与 自定义命名空间的处理器映射关系 以键值对形式存在到一个叫spring.handlers文<br>件里，该文件存储在类加载路径的 META-INF里，Spring会自动加载到;</li><li>准备好NamespaceHandler，如果命名空间只有一个标签，那么直接在parse方法中进行解析即可，一般解析结果就是注册该标签对应的BeanDefinition。</li><li>如果命名空间里有多个标签，那么可以在init方法中为每个标签都注册一个BeanDefinitionParser，在执行NamespaceHandler的parse方法时在分流给不同的BeanDefinitionParser进行解析(重写doParse方法即可)</li></ul><h1 id="Bean的创建使用底层"><a href="#Bean的创建使用底层" class="headerlink" title="Bean的创建使用底层"></a>Bean的创建使用底层</h1><h2 id="实例化的基本流程"><a href="#实例化的基本流程" class="headerlink" title="实例化的基本流程"></a>实例化的基本流程</h2><p>Spring容器在进行初始化时，会将xml配置的的信息封装成一个<strong>BeanDefinition</strong>对象，所有的 BeanDefinition存储到一个名为<strong>beanDefinitionMap</strong>的Map集合中去，Spring框架在对该Map进行遍历，使用反射创建<strong>Bean实例对象</strong></p><p>创建好的Bean对象存储在一个名为<strong>singletonObjects（单例池）</strong>的Map集合中，当调用getBean方法 时则最终从该Map集合中取出Bean实例对象返回</p><table><thead><tr><th>java对象</th><th>作用</th></tr></thead><tbody><tr><td><strong>Bean</strong>对象</td><td>封装我们需要的对象</td></tr><tr><td><strong>BeanDefinition</strong>对象</td><td>封装bean的对象，每个bean都有一个BeanDefinition与之对应</td></tr><tr><td><strong>beanDefinitionMap</strong></td><td>集中存储BeanDefinition对象的Map</td></tr><tr><td><strong>singletonObjects</strong></td><td>集中存储完全体Bean对象的Map</td></tr></tbody></table><p><strong>单例 Bean 实例化的基本流程</strong>：</p><ol><li>加载xml配置文件，解析获取配置中的每个的信息，封装成一个个的BeanDefinition对象</li><li>将BeanDefinition存储在一个名为beanDefinitionMap的Map中</li><li>ApplicationContext底层遍历beanDefinitionMap，创建Bean实例对象</li><li>创建好的Bean实例对象，被存储到一个名为singletonObjects的Map中</li><li>当执行applicationContext.getBean(beanName)时，从singletonObjects去匹配Bean实例返回</li></ol><p>DefaultListableBeanFactory对象内部维护着一个Map用于存储封装好的BeanDefinitionMap</p><blockquote><p>DefaultListableBeanFactory眼熟不，最开始提到的Bean工厂的实现类</p></blockquote><p>Spring框架会取出beanDefinitionMap中的每个BeanDefinition信息，反射构造方法或调用指定的工厂方法生成Bean实例对象，所以只要将BeanDefinition注册到beanDefinitionMap这个Map中，Spring就会进行对应的Bean的实例化操作</p><p>Bean实例及单例池singletonObjects， beanDefinitionMap中的BeanDefinition会被转化成对应的Bean实例对象 ，存储到单例池singletonObjects中去，在DefaultListableBeanFactory的上四级父类 DefaultSingletonBeanRegistry中，维护着singletonObjects，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultSingletonBeanRegistry</span> extends ... implements ... &#123;</span><br><span class="line">    <span class="comment">//存储Bean实例的单例池</span></span><br><span class="line">    <span class="comment">//key:是Bean的beanName，value:是Bean的实例对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>(<span class="number">256</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109190337461.png" alt="image-20231109190337461"></p><h3 id="debug查看"><a href="#debug查看" class="headerlink" title="debug查看"></a>debug查看</h3><p>可以对创建spring容器的那一步进行debug，查看内部存放内容</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231118143106703.png" alt="image-20231118143106703"></p><p>其中，存放的对象不是对象本身，是BeanDefinition，真正的对象在上面两行的singletonObjects里面</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231118143221334.png" alt="image-20231118143221334"></p><h2 id="后处理器"><a href="#后处理器" class="headerlink" title="后处理器"></a>后处理器</h2><p>（我这里记的不是很清晰，建议网上另找文章）</p><p><a href="https://blog.csdn.net/qwer123451234123/article/details/124353567">https://blog.csdn.net/qwer123451234123/article/details/124353567</a></p><p><a href="https://zhuanlan.zhihu.com/p/623041363">https://zhuanlan.zhihu.com/p/623041363</a></p><p><a href="https://zhuanlan.zhihu.com/p/84413599">https://zhuanlan.zhihu.com/p/84413599</a></p><p>Spring的后处理器是Spring对外开发的重要扩展点，允许我们介入到Bean的整个实例化流程中来，以达到动态注册 BeanDefinition，动态修改BeanDefinition，以及动态修改Bean的作用。</p><p>Spring主要有四种后处理器：</p><ol><li><strong>BeanDefinitionRegistryPostProcessor</strong>：beanDefinition后置处理器，可以动态注册自己的beanDefinition，可以加载classpath之外的bean</li><li><strong>BeanFactoryPostProcessor</strong>：Bean工厂后处理器，在BeanDefinitionMap填充完毕，Bean实例化之前执行，它修改的对象是BeanDefinition，可以认为是模具，后面所有的bean都会受影响</li><li><strong>BeanPostProcessor</strong>：Bean后处理器，一般在Bean实例化之后，填充到单例池singletonObjects之前执行。它修改的对象是单个Bean，只影响一个</li><li><strong>InitializingBean</strong>：</li></ol><blockquote><p>根据上面各个处理器的功能作用描述可以得到三个处理器的执行顺序：</p><p>BeanDefinitionRegistryPostProcessor → BeanFactoryPostProcessor → BeanPostProcessor</p></blockquote><div class="tabs" id="6"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#6-1">BeanFactoryPostProcessor</button></li><li class="tab"><button type="button" data-href="#6-2">BeanDefinitionRegistryPostProcessor</button></li><li class="tab"><button type="button" data-href="#6-3">BeanPostProcessor</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="6-1"><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109193430419.png" alt="image-20231109193430419"></p><p>BeanFactoryPostProcessor是一个接口规范，实现了该接口的类只要交由Spring容器管理的话，那么Spring就会回调该接口的方法，用于对BeanDefinition注册和修改的功能</p><p>postProcessBeanFactory 参数本质就是 DefaultListableBeanFactory，拿到BeanFactory的引用，自然就可对beanDefinitionMap中的BeanDefinition进行操作了</p><p>BeanFactoryPostProcessor接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟使用BeanFactoryPostProcessor：</p><ol><li><p>编写BeanFactoryPostProcessor实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyBeanFactoryPostProcessor执行了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里拿到了beanFactory，那自然可以对内部的Map进行处理，但是为了安全起见，它不让我们拿到整个Map，我们只能单个BD的拿（内部方法 <code>getBeanDefinition(beanName)</code>）</p><ul><li><p>比如对UserDaoImpl的BeanDefinition进行修改操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">//获得UserDao定义对象</span></span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">userDaoBD</span> <span class="operator">=</span> beanFactory.getBeanDefinition(“userDao”);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改class</span></span><br><span class="line">        userDaoBD.setBeanClassName(<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl2&quot;</span>); </span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改初始化方法</span></span><br><span class="line">        <span class="comment">//userDaoBD.setInitMethodName(methodName); </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改是否懒加载</span></span><br><span class="line">        <span class="comment">//userDaoBD.setLazyInit(true); </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对BeanDefiition进行注册操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory configurableListableBeanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//强转成子类DefaultListableBeanFactory，不然没有registerBeanDefinition方法</span></span><br><span class="line">        <span class="keyword">if</span>(configurableListableBeanFactory <span class="keyword">instanceof</span> DefaultListableBeanFactory)&#123;</span><br><span class="line">            <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> (DefaultListableBeanFactory) configurableListableBeanFactory;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//注册beanDefinition对象</span></span><br><span class="line">            <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取bean对象信息</span></span><br><span class="line">            beanDefinition.setBeanClassName(<span class="string">&quot;com.itheima.dao.UserDaoImpl2&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//进行注册操作</span></span><br><span class="line">            beanFactory.registerBeanDefinition(<span class="string">&quot;userDao2&quot;</span>,beanDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>配置BeanFactoryPostProcessor</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.processor.MyBeanFactoryPostProcessor&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6-2"><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109193430419.png" alt="image-20231109193430419"></p><p>Spring 提供了一个BeanFactoryPostProcessor的子接口BeanDefinitionRegistryPostProcessor专门用于注册 BeanDefinition操作，想实现注册直接用这个子接口就行了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactoryPostProcessor2</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//这个是父接口BeanFactoryPostProcessor的，所以一定要实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory configurableListableBeanFactory)</span> <span class="keyword">throws</span> BeansException &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//这个是专门用来这次的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry beanDefinitionRegistry)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">//注册beanDefinition对象</span></span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>();</span><br><span class="line">        <span class="comment">//获取bean对象信息</span></span><br><span class="line">        beanDefinition.setBeanClassName(<span class="string">&quot;com.itheima.dao.UserDaoImpl2&quot;</span>);</span><br><span class="line">        <span class="comment">//进行注册操作</span></span><br><span class="line">        beanDefinitionRegistry.registerBeanDefinition(<span class="string">&quot;userDao2&quot;</span>,beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="6-3"><p>Bean被实例化后，到最终缓存到名为singletonObjects单例池之前，中间会经过Bean的初始化过程</p><p>例如：属性的填充、初始方法init的执行等，其中有一个对外进行扩展的点BeanPostProcessor，我们称为Bean后处理。</p><p>跟上面的 Bean工厂后处理器相似，它也是一个接口，实现了该接口并被容器管理的BeanPostProcessor，会在流程节点上被 Spring自动调用。</p><p>BeanPostProcessor的接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="comment">//在属性注入完毕，初始化方法执行之前被回调</span></span><br><span class="line">    <span class="keyword">default</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="comment">//在初始化方法执行之后，被添加到单例池singletonObjects之前被回调</span></span><br><span class="line">    <span class="keyword">default</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span></span><br><span class="line">        BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义MyBeanPostProcessor，完成快速入门测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 参数： bean是当前被实例化的Bean，beanName是当前Bean实例在容器中的名称</span></span><br><span class="line"><span class="comment">返回值：当前Bean实例对象 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BeanPostProcessor的before方法...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 参数： bean是当前被实例化的Bean，beanName是当前Bean实例在容器中的名称</span></span><br><span class="line"><span class="comment">返回值：当前Bean实例对象 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BeanPostProcessor的after方法...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置MyBeanPostProcessor</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.processors.MyBeanPostProcessor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109193635396.png" alt="image-20231109193635396"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231116111100188.png" alt="image-20231116111100188"></p><p>Spring Bean的生命周期是从 Bean 实例化之后，即通过反射创建出对象之后，到Bean成为一个完整对象，最终存储到单例池中，这个过程被称为Spring Bean的生命周期。Spring Bean的生命周期大体上分为三个阶段：</p><ol><li><p>实例化阶段</p><p>Spring框架会取出BeanDefinition的信息进行判断当前Bean的范围是否是singleton的， 是否不是延迟加载的，是否不是FactoryBean等一系列的 if 判断，以及一些其他方法，最终将一个普通的singleton的Bean通过反射进行实例化</p></li><li><p>初始化阶段</p><p>Bean创建之后还仅仅是个”半成品”，还需要对Bean实例的属性进行填充、执行一些 Aware 接口方法、执行BeanPostProcessor方法、执行InitializingBean接口的初始化方法、执行自定义初始化init方法 等。</p><p>该阶段是Spring最具技术含量和复杂度的阶段，Aop增强功能，Spring的注解功能等都是通过这里实现的</p></li><li><p>完成阶段</p><p>经过初始化阶段，Bean就成为了一个完整的Spring Bean，被存储到单例池 singletonObjects中去了，即完成了Spring Bean的整个生命周期</p></li></ol><h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><p>Spring Bean的初始化过程涉及如下几个过程：</p><ul><li>Bean实例的属性填充</li><li>Aware接口属性注入</li><li>BeanPostProcessor 的 before() 方法回调 </li><li>InitializingBean 接口的初始化方法回调</li><li>自定义初始化方法init回调</li><li>BeanPostProcessor的after()方法回调</li></ul><h4 id="Bean实例的属性填充"><a href="#Bean实例的属性填充" class="headerlink" title="Bean实例的属性填充"></a>Bean实例的属性填充</h4><p>BeanDefinition 中有对当前Bean实体的注入信息通过属性propertyValues进行了存储，这些属性也被封装了</p><p>Spring容器中有一个BeanFactory，BeanFactory中有BeanDefinitionMap，BeanDefinitionMap中有propertyValues</p><p>例如UserService的属性信息如下</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109193947579.png" alt="image-20231109193947579"></p><p>Spring在进行属性注入时，会分为如下三种情况：</p><ul><li>注入普通属性，String、int或存储基本类型的集合时，直接通过set方法的反射设置进去</li><li>注入单向对象引用属性时，从容器中getBean获取后通过set方法反射设置进去，如果容器中没有，则先创建被注入对象Bean实例（完成整个生命周期）后，在进行注入操作</li><li>注入双向对象引用属性时，就比较复杂了，涉及了循环引用（循环依赖）问题</li></ul><h5 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h5><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109194114161.png" alt="image-20231109194114161"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109194313661.png" alt="image-20231109194313661"></p><p>Bean只需要其他的Bean完成自己的创建，但是不会去干涉其他Bean的创建，可以把半成品的Bean拿去先凑个数然后实现自己的创建（用结果当条件去证结果）</p><p>因为new以后地址不会变，所以能保证半成品和成品都在同一个位置，不影响使用</p><p>Spring提供了<strong>三级缓存</strong>，保存<strong>完整Bean对象</strong> 和 <strong>半成品Bean对象</strong> ，用于解决循环引用问题，在DefaultListableBeanFactory的上四级父类DefaultSingletonBeanRegistry中提供如下三个Map：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultSingletonBeanRegistry ... &#123;</span><br><span class="line">  //1、最终存储单例Bean成品的容器，即实例化和初始化都完成的Bean，称之为&quot;一级缓存&quot;</span><br><span class="line">  Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap(256);</span><br><span class="line">  //2、早期Bean单例池，缓存半成品对象，且当前对象已经被其他对象引用了，称之为&quot;二级缓存&quot;</span><br><span class="line">  Map&lt;String, Object&gt; earlySingletonObjects = new ConcurrentHashMap(16);</span><br><span class="line">  //3、单例Bean的工厂池，缓存半成品对象，对象未被引用，使用时在通过工厂创建Bean，称之为&quot;三级缓存&quot;</span><br><span class="line">  Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap(16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一级缓存：最终存储单例Bean成品的容器，即实例化和初始化都完成的Bean，容量256</li><li>二级缓存：早期Bean单例池，缓存半成品对象，且当前对象已经被其他对象引用了，容量16</li><li>三级缓存：单例Bean的工厂池，缓存半成品对象，对象未被引用，使用时在通过工厂创建Bean，容量16</li></ul><p>UserService和UserDao循环依赖的过程结合上述三级缓存描述一下：</p><ol><li>UserService 实例化对象，但尚未初始化，将UserService存储到三级缓存</li><li>UserService 属性注入，需要UserDao，从缓存中获取，没有UserDao</li><li>UserDao实例化对象，但尚未初始化，将UserDao存储到到三级缓存</li><li>UserDao属性注入，需要UserService，从三级缓存获取UserService，UserService从三级缓存移入二级缓存</li><li>UserDao执行其他生命周期过程，最终成为一个完成Bean，存储到一级缓存，删除二三级缓存</li><li>UserService 注入UserDao</li><li>UserService执行其他生命周期过程，最终成为一个完成Bean，存储到一级缓存，删除二三级缓存</li></ol><h4 id="Aware接口属性注入"><a href="#Aware接口属性注入" class="headerlink" title="Aware接口属性注入"></a>Aware接口属性注入</h4><p>Aware接口是一种框架辅助属性注入的一种思想，其他框架中也可以看到类似的接口。框架具备高度封装性，我们接触到的一般都是业务代码，一个底层功能API不能轻易的获取到，但是这不意味着永远用不到这些对象，如果用到了，就可以使用框架提供的类似Aware的接口，让框架给我们注入该对象</p><p>大致就是普通人（普通bean）想访问机密文件，本来应该是不允许的，但是这个普通人在这个时候有了权限（实现相关方法），就能访问机密文件</p><table><thead><tr><th>Aware接口</th><th>回调方法</th><th>作用</th></tr></thead><tbody><tr><td>ServletContextAware</td><td>setServletContext(ServletContext context)</td><td>Spring框架回调方法注入ServletContext对象，web环境下才生效</td></tr><tr><td>BeanFactoryAware</td><td>setBeanFactory(BeanFactory factory)</td><td>Spring框架回调方法注入beanFactory对象</td></tr><tr><td>BeanNameAware</td><td>setBeanName(String beanName)</td><td>Spring框架回调方法注入当前Bean在容器中的beanName</td></tr><tr><td>ApplicationContextAware</td><td>setApplicationContext(ApplicationContext applicationContext)</td><td>Spring框架回调方法注入applicationContext对象</td></tr></tbody></table><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231116111100188.png" alt="image-20231116111100188"></p><h2 id="Bean创建整体流程总结"><a href="#Bean创建整体流程总结" class="headerlink" title="Bean创建整体流程总结"></a>Bean创建整体流程总结</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109190337461.png" alt="image-20231109190337461"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109221132853.png" alt="image-20231109221132853"></p><p>功能增强都是基于这张图实现的，在相应的地方增强功能。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 框架 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb-会话</title>
      <link href="/2023/08/27/JavaWeb-%E4%BC%9A%E8%AF%9D%E3%80%81%E8%BF%87%E6%BB%A4%E5%99%A8%E3%80%81%E7%9B%91%E5%90%AC%E5%99%A8/"/>
      <url>/2023/08/27/JavaWeb-%E4%BC%9A%E8%AF%9D%E3%80%81%E8%BF%87%E6%BB%A4%E5%99%A8%E3%80%81%E7%9B%91%E5%90%AC%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h1><h2 id="会话管理概述"><a href="#会话管理概述" class="headerlink" title="会话管理概述"></a>会话管理概述</h2><p>HTTP是无状态协议</p><ul><li>无状态就是不保存状态，即无状态协议(stateless)，HTTP协议自身不对请求和响应之间的通信状态进行保存，也就是说，在HTTP协议这个级别，协议对于发送过的请求或者响应都不做持久化处理</li><li>简单理解:浏览器发送请求，服务器接收并响应，但是服务器不记录请求是否来自哪个浏览器，服务器没记录浏览器的特征，就是客户端的状态</li></ul><blockquote><p>举例: 张三去一家饭馆点了几道菜，觉得味道不错，第二天又去了，对老板说，还点上次的那几道菜</p><ul><li>无状态: 老板没有记录张三是否来过，更没有记录上次他点了那些菜，张三只能重新再点一遍</li><li>有状态: 老板把每次来吃饭的用户都做好记录，查阅一下之前的记录，查到了张三之前的菜单，直接下单</li></ul></blockquote><h3 id="会话管理实现的手段"><a href="#会话管理实现的手段" class="headerlink" title="会话管理实现的手段"></a>会话管理实现的手段</h3><p>Cookie和Session配合解决</p><ul><li>cookie是在客户端保留少量数据的技术，主要通过响应头向客户端响应一些客户端要保留的信息</li><li>session是在服务端保留更多数据的技术，主要通过HttpSession对象保存一些和客户端相关的信息</li><li>cookie和session配合记录请求状态</li></ul><blockquote><p>举例: 张三去银行办业务</p><ul><li>张三第一次去某个银行办业务，银行会为张三开户(Session)，并向张三发放一张银行卡(cookie)</li><li>张三后面每次去银行，就可以携带之间的银行卡(cookie)，银行根据银行卡找到之前张三的账户(session)</li></ul></blockquote><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="Cookie概述"><a href="#Cookie概述" class="headerlink" title="Cookie概述"></a>Cookie概述</h3><p>cookie是一种客户端会话技术，cookie由<strong>服务端产生</strong>，它是服务器<strong>存放在浏览器</strong>的一小份数据，浏览器以后每次访问该服务器的时候都会将这小份数据携带到服务器去</p><ul><li>服务端创建cookie，将cookie放入响应对象中，Tomcat容器将cookie转化为set-cookie响应头，响应给客户端</li><li>客户端在收到cookie的响应头时，在下次请求该服务的资源时，会以cookie请求头的形式携带之前收到的Cookie</li><li>cookie是一种键值对格式的数据，从tomcat8.5开始可以保存中文，但是不推荐</li><li>由于cookie是存储于客户端的数据，比较容易暴露，一般不存储一些敏感或者影响安全的数据</li></ul><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231206180311405.png" alt="image-20231206180311405"></p><h3 id="Cookie的使用"><a href="#Cookie的使用" class="headerlink" title="Cookie的使用"></a>Cookie的使用</h3><div class="tabs" id=""><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#-1">增加Cookie</button></li><li class="tab"><button type="button" data-href="#-2">读取Cookie</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="-1"><p>创建 cookie 直接 new 一个，以键值对的方式存储名字和内容，可以生成多个 cookie，浏览器就会接受多个，并全存储</p><p>response对象调用addCookie方法就能将 cookie 放入响应体里面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletA&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletA</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req， HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException， IOException &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建Cookie</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie1</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;c1&quot;</span>，<span class="string">&quot;c1_message&quot;</span>);</span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie2</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;c2&quot;</span>，<span class="string">&quot;c2_message&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将cookie放入响应对象</span></span><br><span class="line">        resp.addCookie(cookie1);</span><br><span class="line">        resp.addCookie(cookie2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-2"><p>接收cookie的时候，如果没有cookie，用来接受的数组是 null，而不是长度为0，小心空指针异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletB&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletB</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req， HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException， IOException &#123;</span><br><span class="line">        <span class="comment">//获取请求中的cookie</span></span><br><span class="line">        Cookie[] cookies = req.getCookies();</span><br><span class="line">        <span class="comment">//迭代cookies数组</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != cookies &amp;&amp; cookies.length!= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">                System.out.println(cookie.getName()+<span class="string">&quot;:&quot;</span>+cookie.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>cookie单独用的不多，session用得多，这个包含了cookie</p><p>session存放在后台，cookie存放在浏览器</p><h3 id="Cookie的时效性"><a href="#Cookie的时效性" class="headerlink" title="Cookie的时效性"></a>Cookie的时效性</h3><p>默认情况下Cookie的有效期是关闭浏览器就失效的，我们可以通过cookie的setMaxAge()方法让Cookie持久化保存到浏览器上</p><p>cookie.setMaxAge(int expiry)参数单位是秒，表示cookie的持久化时间，如果设置参数为0，表示将浏览器中保存的该cookie删除</p><ul><li>会话级Cookie<ul><li>服务器端并没有明确指定Cookie的存在时间</li><li>在浏览器端，Cookie数据存在于内存中</li><li>只要浏览器还开着，Cookie数据就一直都在</li><li>浏览器关闭，内存中的Cookie数据就会被释放</li></ul></li><li>持久化Cookie<ul><li>服务器端明确设置了Cookie的存在时间</li><li>在浏览器端，Cookie数据会被保存到硬盘上</li><li>Cookie在硬盘上存在的时间根据服务器端限定的时间来管控，不受浏览器关闭的影响</li><li>持久化Cookie到达了预设的时间会被释放</li></ul></li></ul><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><h3 id="HttpSession概述"><a href="#HttpSession概述" class="headerlink" title="HttpSession概述"></a>HttpSession概述</h3><p>HttpSession是一种保留更多信息在服务端的一种技术，服务器会为每一个客户端开辟一块内存空间，即session对象，客户端在发送请求时，都可以使用自己的session. 这样服务端就可以通过session来记录某个客户端的状态了</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231206181249230.png" alt="image-20231206181249230"></p><ul><li>服务端在为客户端创建session时，会同时将 session对象的id，即 JSESSIONID 以 cookie 的形式放入响应对象</li><li>后端创建完 session 后，客户端会收到一个特殊的 cookie，叫做 JSESSIONID</li><li>客户端下一次请求时携带 JSESSIONID，后端收到后，根据 JSESSIONID 找到对应的 session对象</li><li>通过该机制，服务端通过 session 就可以存储一些专门针对某个客户端的信息了</li><li>session也是域对象</li></ul><blockquote><p>session对象只能由服务器创建，用getSession() 方法获得，然后调用</p><p>getSession() 实现判断有没有一个叫JSESSIONID的cookie，这个cookie的值是一个session的编号，用这个cookie查找用哪个session</p><p>如果使用的session是同一个，那么称为同一个对话，不然就不是同一个对话，同一个对话不止一个请求，这些请求之间可以共享数据</p></blockquote><p>getSession方法的处理逻辑</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231206182053177.png" alt="image-20231206182053177"></p><h3 id="HttpSession的使用"><a href="#HttpSession的使用" class="headerlink" title="HttpSession的使用"></a>HttpSession的使用</h3><div class="tabs" id=""><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#-1">存入session</button></li><li class="tab"><button type="button" data-href="#-2">读取session</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="-1"><p>定义ServletA，将用户名存入session</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletA&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletA</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req， HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException， IOException &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取请求中的参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取session对象</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">        </span><br><span class="line">         <span class="comment">// 获取Session的ID</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jSessionId</span> <span class="operator">=</span> session.getId();</span><br><span class="line">        System.out.println(jSessionId);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断session是不是新创建的session</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isNew</span> <span class="operator">=</span> session.isNew();</span><br><span class="line">        System.out.println(isNew);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 向session对象中存入数据</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;username&quot;</span>，username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>响应中收到了一个JSESSIONID的cookie</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231206182002542.png" alt="image-20231206182002542"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-2"><p>定义其他Servlet，从session中读取用户名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletB&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletB</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req， HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException， IOException &#123;</span><br><span class="line">        <span class="comment">// 获取session对象</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">         <span class="comment">// 获取Session的ID</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jSessionId</span> <span class="operator">=</span> session.getId();</span><br><span class="line">        System.out.println(jSessionId);</span><br><span class="line">        <span class="comment">// 判断session是不是新创建的session</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isNew</span> <span class="operator">=</span> session.isNew();</span><br><span class="line">        System.out.println(isNew);</span><br><span class="line">        <span class="comment">// 从session中取出数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String)session.getAttribute(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求中携带了一个JSESSIONID的cookie</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231206182023468.png" alt="image-20231206182023468"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="HttpSession时效性"><a href="#HttpSession时效性" class="headerlink" title="HttpSession时效性"></a>HttpSession时效性</h3><p>为什么要设置session的时效</p><ul><li>用户量很大之后，Session对象相应的也要创建很多。如果一味创建不释放，那么服务器端的内存迟早要被耗尽。</li><li>客户端关闭行为无法被服务端直接侦测，或者客户端较长时间不操作也经常出现，类似这些的情况，就需要对session的时限进行设置了</li></ul><blockquote><p>默认的session最大闲置时间（两次使用同一个session中的间隔时间)）在tomcat 的 web.xml中，为30分钟</p><p>我们可以在自己项目的web.xml对最大闲置时间进行重新设定</p><p>或者通过HttpSession的<code>setMaxInactiveInterval(90);</code>方法 对最大闲置时间进行设定</p><p>也可以直接让session失效<code>session.invalidate();</code></p></blockquote><h2 id="三大域对象"><a href="#三大域对象" class="headerlink" title="三大域对象"></a>三大域对象</h2><h3 id="域对象概述"><a href="#域对象概述" class="headerlink" title="域对象概述"></a>域对象概述</h3><p>域对象：一些用于存储数据和传递数据的对象，传递数据不同的范围，我们称之为不同的域，不同的域对象代表不同的域，共享数据的范围也不同</p><p>用来是4大域，现在还剩3个</p><ul><li>请求域：HttpServletRequest ，传递数据的范围是一次请求之内及请求转发</li><li>会话域：HttpSession，传递数据的范围是一次会话之内，可以跨多个请求</li><li>应用域：ServletContext，传递数据的范围是本应用之内，可以跨多个会话</li></ul><div class="tabs" id=""><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#-1">请求域</button></li><li class="tab"><button type="button" data-href="#-2">会话域</button></li><li class="tab"><button type="button" data-href="#-3">应用域</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="-1"><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231206182804543.png" alt="image-20231206182804543"></p><p>浏览器只有一次请求能传递数据，因为请求转发不是浏览器做出来的后续请求，所以也能传递数据。但重定向就不行了</p><p>请求域可以直接通过request对象进行访问</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-2"><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231206182809521.png" alt="image-20231206182809521"></p><p>前面提到的session，只要是同一个session，并且session没失效，就在一个会话里面，能互相传递数据</p><p>会话域需要先得到 session对象，再用 session对象访问</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-3"><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231206182813432.png" alt="image-20231206182813432"></p><p>应用域是只要是同一个项目就能交换数据</p><p>应用域要先得到 application对象在进行操作</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>所有域在一起</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231206183104848.png" alt="image-20231206183104848"></p><h3 id="域对象的使用"><a href="#域对象的使用" class="headerlink" title="域对象的使用"></a>域对象的使用</h3><table><thead><tr><th>API</th><th>功能</th></tr></thead><tbody><tr><td>void setAttribute(String name，String value)</td><td>向域对象中添加&#x2F;修改数据</td></tr><tr><td>Object getAttribute(String name);</td><td>从域对象中获取数据</td></tr><tr><td>removeAttribute(String name);</td><td>移除域对象中的数据</td></tr></tbody></table><h4 id="向三大域中放入数据"><a href="#向三大域中放入数据" class="headerlink" title="向三大域中放入数据"></a>向三大域中放入数据</h4><p>setAttribute（）是给域中填充数据的方法，但不同的域调用方法的对象不同，分别是：request对象、session对象、application对象</p><p>后两个要先获取相应的对象在调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletA&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletA</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req， HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException， IOException &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 向请求域中放入数据</span></span><br><span class="line">        req.setAttribute(<span class="string">&quot;request&quot;</span>，<span class="string">&quot;request-message&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//请求转发</span></span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;servletB&quot;</span>).forward(req，resp);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 向会话域中放入数据</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">        session.setAttribute(<span class="string">&quot;session&quot;</span>，<span class="string">&quot;session-message&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 向应用域中放入数据</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> getServletContext();</span><br><span class="line">        application.setAttribute(<span class="string">&quot;application&quot;</span>，<span class="string">&quot;application-message&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="从三大于中取出数据"><a href="#从三大于中取出数据" class="headerlink" title="从三大于中取出数据"></a>从三大于中取出数据</h4><p>getAttribute（）是获取域中数据的方法，不同的域有不同的对象执行操作，分别是：request对象、session对象、application对象<br>后两个要先获取相应的对象在调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletB&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletB</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req， HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException， IOException &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从请求域中获取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">reqMessage</span> <span class="operator">=</span>(String)req.getAttribute(<span class="string">&quot;request&quot;</span>);</span><br><span class="line">        System.out.println(reqMessage);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从会话域中获取数据</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">        <span class="type">String</span> <span class="variable">sessionMessage</span> <span class="operator">=</span>(String)session.getAttribute(<span class="string">&quot;session&quot;</span>);</span><br><span class="line">        System.out.println(sessionMessage);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从应用域中获取数据</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> getServletContext();</span><br><span class="line">        <span class="type">String</span> <span class="variable">applicationMessage</span> <span class="operator">=</span>(String)application.getAttribute(<span class="string">&quot;application&quot;</span>);</span><br><span class="line">        System.out.println(applicationMessage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>请求转发时，请求域可以传递数据<code>请求域内一般放本次请求业务有关的数据，如:查询到的所有的部门信息</code></li><li>同一个会话内，不用请求转发，会话域可以传递数据<code>会话域内一般放本次会话的客户端有关的数据，如:当前客户端登录的用户</code> </li><li>同一个APP内，不同的客户端，应用域可以传递数据<code>应用域内一般放本程序应用有关的数据 如:Spring框架的IOC容器</code></li></ul><h1 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h1><h2 id="过滤器概述"><a href="#过滤器概述" class="headerlink" title="过滤器概述"></a>过滤器概述</h2><p>Filter过滤器，是JAVAEE技术规范之一，作用目标资源的请求进行过滤的一套技术规范</p><ul><li>Filter接口定义了过滤器的开发规范，所有的过滤器都要实现该接口</li><li>Filter的工作位置是项目中所有目标资源之前，在容器创建HttpServletRequest和HttpServletResponse对象后。产生请求和响应对象之后，servlet生效之前</li><li>Filter的doFilter方法可以控制请求是否继续，如果放行，则请求继续，如果拒绝，则请求到此为止，由过滤器本身做出响应</li><li>Filter不仅可以对请求做出过滤，也可以在目标资源做出响应前，对响应再次进行处理，分担了一部分servlet的功能</li></ul><p>过滤器开发中应用的场景</p><ul><li>日志的记录</li><li>性能的分析</li><li>乱码的处理</li><li>事务的控制</li><li>登录的控制</li><li>跨域的处理</li></ul><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231207145603079.png" alt="image-20231207145603079"></p><h2 id="Filter接口API"><a href="#Filter接口API" class="headerlink" title="Filter接口API"></a>Filter接口API</h2><p>源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jakarta.servlet;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request， ServletResponse response， FilterChain chain)</span> <span class="keyword">throws</span> IOException， ServletException;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th>方法</th><th>目标</th></tr></thead><tbody><tr><td>default public void init(FilterConfig filterConfig)</td><td>初始化方法，由容器调用并传入初始配置信息filterConfig对象</td></tr><tr><td>public void doFilter(ServletRequest request， ServletResponse response， FilterChain chain)</td><td>过滤方法，核心方法，过滤请求，决定是否放行，响应之前的其他处理等都在该方法中</td></tr><tr><td>default public void destroy()</td><td>销毁方法，容器在回收过滤器对象之前调用的方法</td></tr></tbody></table><h2 id="过滤器使用"><a href="#过滤器使用" class="headerlink" title="过滤器使用"></a>过滤器使用</h2><ol><li><p>实现Filter接口，就像实现servlet接口一样，里面的doFilter方法执行业务功能</p></li><li><p>重写过滤方法</p><ul><li>doFilter方法中的请求和响应对象是以父接口的形式声明的，实际传入的实参就是HttpServletRequest和HttpServletResponse子接口级别的，可以安全强转</li><li>filterChain.doFilter(request，response); 这行代码的功能是放行请求，如果没有这一行代码，则请求到此为止，里面的参数是第一步生成的<strong>请求对象和响应对象</strong></li><li>filterChain.doFilter(request，response);在放行时需要传入request和response，意味着请求和响应对象要继续传递给后续的资源，这里没有产生新的request和response对象</li></ul></li><li><p>配置过滤器<br>web. xml方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;5.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置filter，并为filter起别名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>loggingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.atguigu.filters.LoggingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--为别名对应的filter配置要过滤的目标资源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>loggingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--通过映射路径确定过滤资源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servletA<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--通过后缀名确定过滤资源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.html<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--通过servlet别名确定过滤资源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servletBName<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>filter-mapping标签中定义了过滤器对那些资源进行过滤</li><li>子标签url-pattern通过映射路径确定过滤范围<ul><li>&#x2F;servletA ：精确匹配，表示对servletA资源的请求进行过滤</li><li>*.action：表示对以.action结尾的路径进行过滤</li><li>&#x2F;* ：表示对所有资源进行过滤</li><li>一个filter-mapping下可以配置多个url-pattern</li></ul></li><li>子标签servlet-name通过servlet别名确定对那些servlet进行过滤<ul><li>使用该标签确定目标资源的前提是servlet已经起了别名</li><li>一个filter-mapping下可以定义多个servlet-name</li><li>一个filter-mapping下，servlet-name和url-pattern子标签可以同时存在</li></ul></li></ul><p>注解：@WebFilter</p></li></ol><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231207150346137.png" alt="image-20231207150346137"></p><h2 id="注解方式配置过滤器"><a href="#注解方式配置过滤器" class="headerlink" title="注解方式配置过滤器"></a>注解方式配置过滤器</h2><p>@WebFilter注解的使用</p><p>源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jakarta.servlet.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.DispatcherType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> WebFilter &#123;</span><br><span class="line">    String <span class="title function_">description</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">displayName</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    WebInitParam[] initParams() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">filterName</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">smallIcon</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">largeIcon</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    String[] servletNames() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] urlPatterns() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    DispatcherType[] dispatcherTypes() <span class="keyword">default</span> &#123;DispatcherType.REQUEST&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">asyncSupported</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主要的属性有三个</p><ol><li><p>initParams</p><p>初始参数，替换init-param标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置filter的初始参数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>dateTimePattern<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>yyyy-MM-dd HH:mm:ss<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>servletNames</p><p>通过servlet别名过滤，替换servlet-name标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--通过servlet别名确定过滤资源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servletBName<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>urlPatterns</p><p>通过url路径过滤，替换url-pattern标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--通过映射路径确定过滤资源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/路径<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>完整的将xml配置转换成注解方式实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(</span></span><br><span class="line"><span class="meta">        filterName = &quot;loggingFilter&quot;，</span></span><br><span class="line"><span class="meta">        initParams = &#123;@WebInitParam(name=&quot;dateTimePattern&quot;，value=&quot;yyyy-MM-dd HH:mm:ss&quot;)&#125;，</span></span><br><span class="line"><span class="meta">        urlPatterns = &#123;&quot;/servletA&quot;，&quot;*.html&quot;&#125;，</span></span><br><span class="line"><span class="meta">        servletNames = &#123;&quot;servletBName&quot;&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure><h2 id="过滤器生命周期"><a href="#过滤器生命周期" class="headerlink" title="过滤器生命周期"></a>过滤器生命周期</h2><p>过滤器作为web项目的组件之一，和Servlet的生命周期类似，但没有servlet的load-on-startup的配置，默认就是系统启动立刻构造</p><table><thead><tr><th>阶段</th><th>对应方法</th><th>执行时机</th><th>执行次数</th></tr></thead><tbody><tr><td>创建对象</td><td>构造器</td><td>web应用启动时</td><td>1</td></tr><tr><td>初始化方法</td><td>void init(FilterConfig filterConfig)</td><td>构造完毕</td><td>1</td></tr><tr><td>过滤请求</td><td>void doFilter(ServletRequest servletRequest， ServletResponse servletResponse， FilterChain filterChain)</td><td>每次请求</td><td>多次</td></tr><tr><td>销毁</td><td>default void destroy()</td><td>web应用关闭时</td><td>1次</td></tr></tbody></table><h2 id="过滤器链的使用"><a href="#过滤器链的使用" class="headerlink" title="过滤器链的使用"></a>过滤器链的使用</h2><p>一个web项目中，可以同时定义多个过滤器，多个过滤器对同一个资源进行过滤时，工作位置有先后，整体形成一个工作链，称之为过滤器链，和栈的顺序一样，先进后出</p><ul><li>过滤器链中的过滤器的顺序由filter-mapping顺序决定</li><li>每个过滤器过滤的范围不同，针对同一个资源来说，过滤器链中的过滤器个数可能是不同的</li><li>如果某个Filter是使用ServletName进行匹配规则的配置，那么这个Filter执行的优先级要更低</li></ul><p>过滤器配置代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;5.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--填充3个过滤器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.atguigu.filters.Filter1<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.atguigu.filters.Filter2<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter3<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.atguigu.filters.Filter3<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置3个过滤器顺序--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--filter-mapping的顺序决定了过滤器的工作顺序--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter1<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servletC<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servletC<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter3<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servletC<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231207150622014.png" alt="image-20231207150622014"></p><h1 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h1><h2 id="监听器概述"><a href="#监听器概述" class="headerlink" title="监听器概述"></a>监听器概述</h2><p>监听器：专门用于对域对象对象身上发生的事件或状态改变进行监听和相应处理的对象</p><ul><li><p>监听器是GOF设计模式中，观察者模式的典型案例</p></li><li><p>观察者模式: 当被观察的对象发生某些改变时， 观察者自动采取对应的行动的一种设计模式</p></li><li><p>监听器使用的感受类似JS中的事件，被观察的对象发生某些情况时，自动触发代码的执行</p></li><li><p>监听器并不监听web项目中的所有组件，仅仅是对三大域对象做相关的事件监听</p></li></ul><h2 id="监听器的分类"><a href="#监听器的分类" class="headerlink" title="监听器的分类"></a>监听器的分类</h2><p>web中定义八个监听器接口作为监听器的规范，这八个接口按照不同的标准可以形成不同的分类</p><ul><li>按监听的对象划分<ul><li>application域监听器 ServletContextListener  ServletContextAttributeListener</li><li>session域监听器 HttpSessionListener  HttpSessionAttributeListener  HttpSessionBindingListener  HttpSessionActivationListener  </li><li>request域监听器 ServletRequestListener  ServletRequestAttributeListener</li></ul></li><li>按监听的事件分<ul><li>域对象的创建和销毁监听器 ServletContextListener   HttpSessionListener   ServletRequestListener  </li><li>域对象数据增删改事件监听器 ServletContextAttributeListener  HttpSessionAttributeListener   ServletRequestAttributeListener </li><li>其他监听器  HttpSessionBindingListener  HttpSessionActivationListener</li></ul></li></ul><h2 id="监听器的六个主要接口"><a href="#监听器的六个主要接口" class="headerlink" title="监听器的六个主要接口"></a>监听器的六个主要接口</h2><h3 id="application域监听器"><a href="#application域监听器" class="headerlink" title="application域监听器"></a>application域监听器</h3><div class="tabs" id=""><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#-1">ServletContextListener</button></li><li class="tab"><button type="button" data-href="#-2">ServletContextAttributeListener</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="-1"><p>ServletContextListener：监听ServletContext对象的创建与销毁</p><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>contextInitialized(ServletContextEvent sce)</td><td>ServletContext创建时调用</td></tr><tr><td>contextDestroyed(ServletContextEvent sce)</td><td>ServletContext销毁时调用</td></tr></tbody></table><p>ServletContextListener的形参对象ServletContextEvent</p><p>该对象代表从ServletContext对象身上捕获到的事件，通过这个事件对象我们可以获取到ServletContext对象。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-2"><p>ServletContextAttributeListener：监听ServletContext中属性的添加、移除和修改</p><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>attributeAdded(ServletContextAttributeEvent scab)</td><td>向ServletContext中添加属性时调用</td></tr><tr><td>attributeRemoved(ServletContextAttributeEvent scab)</td><td>从ServletContext中移除属性时调用</td></tr><tr><td>attributeReplaced(ServletContextAttributeEvent scab)</td><td>当ServletContext中的属性被修改时调用</td></tr></tbody></table><p>ServletContextAttributeListener的形参对象ServletContextAttributeEvent </p><p>该对象代表属性变化事件，它包含的方法如下：</p><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>getName()</td><td>获取修改或添加的属性名</td></tr><tr><td>getValue()</td><td>获取被修改或添加的属性值</td></tr><tr><td>getServletContext()</td><td>获取ServletContext对象</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="session域监听器"><a href="#session域监听器" class="headerlink" title="session域监听器"></a>session域监听器</h3><div class="tabs" id=""><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#-1">HttpSessionListener</button></li><li class="tab"><button type="button" data-href="#-2">HttpSessionAttributeListener</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="-1"><p>HttpSessionListener ：监听HttpSession对象的创建与销毁</p><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>sessionCreated(HttpSessionEvent hse)</td><td>HttpSession对象创建时调用</td></tr><tr><td>sessionDestroyed(HttpSessionEvent hse)</td><td>HttpSession对象销毁时调用</td></tr></tbody></table><p>HttpSessionEvent对象代表从HttpSession对象身上捕获到的事件，通过这个事件对象我们可以获取到触发事件的HttpSession对象。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-2"><p>HttpSessionAttributeListener 监听HttpSession中属性的添加、移除和修改</p><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>attributeAdded(HttpSessionBindingEvent se)</td><td>向HttpSession中添加属性时调用</td></tr><tr><td>attributeRemoved(HttpSessionBindingEvent se)</td><td>从HttpSession中移除属性时调用</td></tr><tr><td>attributeReplaced(HttpSessionBindingEvent se)</td><td>当HttpSession中的属性被修改时调用</td></tr></tbody></table><ul><li>HttpSessionBindingEvent对象代表属性变化事件，它包含的方法如下：</li></ul><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>getName()</td><td>获取修改或添加的属性名</td></tr><tr><td>getValue()</td><td>获取被修改或添加的属性值</td></tr><tr><td>getSession()</td><td>获取触发事件的HttpSession对象</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="request域监听器"><a href="#request域监听器" class="headerlink" title="request域监听器"></a>request域监听器</h3><div class="tabs" id=""><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#-1">ServletRequestListener</button></li><li class="tab"><button type="button" data-href="#-2">2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="-1"><blockquote><p>ServletRequestListener 监听ServletRequest对象的创建与销毁</p></blockquote><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>requestInitialized(ServletRequestEvent sre)</td><td>ServletRequest对象创建时调用</td></tr><tr><td>requestDestroyed(ServletRequestEvent sre)</td><td>ServletRequest对象销毁时调用</td></tr></tbody></table><ul><li>ServletRequestEvent对象代表从HttpServletRequest对象身上捕获到的事件，通过这个事件对象我们可以获取到触发事件的HttpServletRequest对象。另外还有一个方法可以获取到当前Web应用的ServletContext对象。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-2"><blockquote><p>ServletRequestAttributeListener 监听ServletRequest中属性的添加、移除和修改</p></blockquote><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>attributeAdded(ServletRequestAttributeEvent srae)</td><td>向ServletRequest中添加属性时调用</td></tr><tr><td>attributeRemoved(ServletRequestAttributeEvent srae)</td><td>从ServletRequest中移除属性时调用</td></tr><tr><td>attributeReplaced(ServletRequestAttributeEvent srae)</td><td>当ServletRequest中的属性被修改时调用</td></tr></tbody></table><ul><li>ServletRequestAttributeEvent对象代表属性变化事件，它包含的方法如下：</li></ul><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>getName()</td><td>获取修改或添加的属性名</td></tr><tr><td>getValue()</td><td>获取被修改或添加的属性值</td></tr><tr><td>getServletRequest ()</td><td>获取触发事件的ServletRequest对象</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="session域的两个特殊监听器"><a href="#session域的两个特殊监听器" class="headerlink" title="session域的两个特殊监听器"></a>session域的两个特殊监听器</h2><h3 id="session绑定监听器"><a href="#session绑定监听器" class="headerlink" title="session绑定监听器"></a>session绑定监听器</h3><p>HttpSessionBindingListener 监听当前监听器对象在Session域中的增加与移除</p><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>valueBound(HttpSessionBindingEvent event)</td><td>该类的实例被放到Session域中时调用</td></tr><tr><td>valueUnbound(HttpSessionBindingEvent event)</td><td>该类的实例从Session中移除时调用</td></tr></tbody></table><ul><li>HttpSessionBindingEvent对象代表属性变化事件，它包含的方法如下：</li></ul><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>getName()</td><td>获取当前事件涉及的属性名</td></tr><tr><td>getValue()</td><td>获取当前事件涉及的属性值</td></tr><tr><td>getSession()</td><td>获取触发事件的HttpSession对象</td></tr></tbody></table><h3 id="钝化活化监听器"><a href="#钝化活化监听器" class="headerlink" title="钝化活化监听器"></a>钝化活化监听器</h3><blockquote><p>HttpSessionActivationListener  监听某个对象在Session中的序列化与反序列化。</p></blockquote><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>sessionWillPassivate(HttpSessionEvent se)</td><td>该类实例和Session一起钝化到硬盘时调用</td></tr><tr><td>sessionDidActivate(HttpSessionEvent se)</td><td>该类实例和Session一起活化到内存时调用</td></tr></tbody></table><ul><li>HttpSessionEvent对象代表事件对象，通过getSession()方法获取事件涉及的HttpSession对象。</li></ul><blockquote><p>什么是钝化活化</p></blockquote><ul><li>session对象在服务端是以对象的形式存储于内存的，session过多，服务器的内存也是吃不消的</li><li>而且一旦服务器发生重启，所有的session对象都将被清除，也就意味着session中存储的不同客户端的登录状态丢失</li><li>为了分摊内存 压力并且为了保证session重启不丢失，我们可以设置将session进行钝化处理</li><li>在关闭服务器前或者到达了设定时间时，对session进行序列化到磁盘，这种情况叫做session的钝化</li><li>在服务器启动后或者再次获取某个session时，将磁盘上的session进行反序列化到内存，这种情况叫做session的活化</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Maven高级</title>
      <link href="/2023/08/25/Maven%E9%AB%98%E7%BA%A7/"/>
      <url>/2023/08/25/Maven%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="分模块开发"><a href="#分模块开发" class="headerlink" title="分模块开发"></a>分模块开发</h1><h2 id="分模块开发设计"><a href="#分模块开发设计" class="headerlink" title="分模块开发设计"></a>分模块开发设计</h2><ol><li>按照功能拆分<ul><li>我们之前的项目都是在一个模块中，比如上篇文章的SSM整合，虽然这样做，功能也都实现了，但是也存在一些问题，我们拿银行的项目举例，来聊聊这件事<ul><li>网络没有那么发达的时候，我们需要到银行柜台或者取款机进行业务操作</li><li>随着互联网的发展，我们有了电脑之后，就可以在网页上登录银行网站使用U盾进行业务操作</li><li>再来就是随着智能手机的普及，我们只需要用手机登录App就可以进行业务操作</li></ul></li><li>上面三个场景出现的时间轴是不同的，如果非要把三个场景的模块代码放到同一个项目，那么当其中某一个模块代码出现问题，就会导致整个项目都无法正常启动，从而导致银行的多个业务都无法正常办理，所以我们会<code>按照功能</code>将项目进行炒粉</li></ul></li><li>按照模块拆分<ul><li>比如电商项目中，有订单和商品两个模块，订单中需要包含商品的详细信息，所以需要商品的模型类，商品模块也会用到商品的模型类，这个时候如果两个模块中都写模型类，就会出现重复代码，后期维护的成本就比较高。我们就想能不能把它们公共的部分抽取成一个独立的模块，其他模块想要使用就可以像<code>导入第三方依赖的坐标</code>一样来使用我们自己抽取的模块，这样就解决了代码重复的问题，这种拆分方式就是我们所说的<code>按照模块</code>拆分</li></ul></li></ol><p>之前的项目包结构如下：</p><ul><li><code>com.blog.config</code>目录存放的是相关的配置类</li><li><code>com.blog.controller</code>编写的是Controller类</li><li><code>com.blog.dao</code>存放的是Dao接口，因为使用的是Mapper接口代理方式，所以没有实现类包</li><li><code>com.blog.service</code>存的是Service接口，<code>com.blog.service.impl</code>存放的是Service实现类</li></ul><p>那我们现在就可以把这些包按照功能拆分成若干个子模块，方便模块之间的相互调用，接口供销，这样的话，项目中的每一层都可以单独维护，也可以很方便的被别人使用。</p><p>那么关于分模块开发的意义，我们就讲完了，说了这么多好处，那么该如何实现呢?</p><h2 id="分模块开发实现"><a href="#分模块开发实现" class="headerlink" title="分模块开发实现"></a>分模块开发实现</h2><p>前面我们已经完成了SSM整合，接下来，我们就基于SSM整合的项目来实现对项目的拆分。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>复制一份之前的ssm项目</p><h3 id="抽取domain层"><a href="#抽取domain层" class="headerlink" title="抽取domain层"></a>抽取domain层</h3><ul><li><p>步骤一：</p><p>创建新模块：</p><ul><li>创建一个名为<code>maven_02_pojo</code>的maven项目</li></ul></li><li><p>步骤二：</p><p>项目中创建domain包：</p><ul><li>在<code>maven_02_pojo</code>中创建<code>com.blog.domain</code>包，并将<code>maven_01_ssm</code>的Book类拷贝到该包中</li></ul></li><li><p>步骤三：</p><p>删除原项目中的domain包：</p><ul><li>删除后，<code>maven_01_ssm</code>项目中用到<code>Book</code>的类中都会爆红</li><li>要想解决上述问题，我们需要在<code>maven_01_ssm</code>中添加<code>maven_02_pojo</code>的依赖。</li></ul></li><li><p>步骤四：</p><p>在<code>maven_01_ssm</code>项目的pom.xml添加<code>maven_02_pojo</code>的依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven_02_pojo&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>因为添加了依赖，所以在<code>maven_01_ssm</code>中就已经能找到Book类，所以刚才的爆红提示就会消失。</p></li></ul><ul><li><p>步骤五：编译maven_01_ssm项目</p><p>控制台会报错，意思就是找不到maven_02_pojo这个jar包</p><p>为啥找不到呢？</p><ul><li>原因是Maven会从本地仓库找对应的jar包，但是本地仓库又不存在该jar包所以会报错。</li><li>在IDEA中是有<code>maven_02_pojo</code>这个项目，所以我们只需要将<code>maven_02_pojo</code>项目安装到本地仓库即可。</li></ul></li><li><p>步骤六：将项目安装本地仓库</p><p>将需要被依赖的项目<code>maven_02_pojo</code>，使用maven的<code>install</code>命令，把其安装到Maven的本地仓库中</p><p>之后再次执行<code>maven_01_ssm</code>的<code>compile</code>的命令后，就已经能够成功编译。</p></li></ul><h3 id="抽取dao层"><a href="#抽取dao层" class="headerlink" title="抽取dao层"></a>抽取dao层</h3><ul><li><p><code>步骤一：</code>创建新模块</p><ul><li>创建一个名为<code>maven_03_dao</code>的maven项目</li></ul></li><li><p><code>步骤二：</code>项目中创建<code>dao</code>包</p><ul><li><p>在<code>maven_03_dao</code>项目中创建<code>com.blog.dao</code>包，并将<code>maven_01_ssm</code>中BookDao类拷贝到该包中</p></li><li><p>在maven_03_dao中会有如下几个问题需要解决下</p><p>项目maven_03_dao的BookDao接口中Book类找不到报错</p><p>解决方案在<code>maven_03_dao</code>项目的pom.xml中添加<code>maven_02_pojo</code>项目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven_02_pojo&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>项目<code>maven_03_dao</code>的BookDao接口中，Mybatis的增删改查注解报错</p><p>解决方案在<code>maven_03_dao</code>项目的pom.xml中添加<code>mybatis</code>的相关依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.5.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.46&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>最后记得使用maven的<code>install</code>命令，把其安装到Maven的本地仓库中</p></li></ul></li><li><p><code>步骤三：</code>删除原项目中的<code>dao</code>包</p><ul><li><p>删除Dao包以后，因为<code>maven_01_ssm</code>中的BookServiceImpl类中有使用到Dao的内容，所以需要在<code>maven_01_ssm</code>的pom.xml添加<code>maven_03_dao</code>的依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven_03_dao&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>步骤四：</code>运行测试</p><ul><li>启动Tomcat服务器，访问<code>http://localhost:8080/pages/books.html</code></li><li>将抽取后的项目进行运行，测试之前的增删改查功能依然能够使用。</li></ul></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>对于项目的拆分，大致会有如下几个步骤</p><ol><li>创建Maven模块</li><li>书写模块代码<ul><li>分模块开发需要先针对模块功能进行设计，再进行编码。不会先将工程开发完毕，然后进行拆分。拆分方式可以按照功能拆也可以按照模块拆。</li></ul></li><li>通过maven指令安装模块到本地仓库(install 指令)<ul><li>由于maven指令只能安装到自己电脑的仓库里，那么团队内部开发需要发布模块功能，需要到团队内部可共享的仓库中(私服)，私服我们后面会讲解。</li></ul></li></ol><h1 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h1><p>我们现在已经能把项目拆分成一个个独立的模块，当在其他项目中想要使用独立出来的这些模块，只需要在其pom.xml使用<code>&lt;dependency&gt;</code>标签来进行jar包的引入即可。<br><code>&lt;dependency&gt;</code>其实就是依赖，关于依赖管理里面涉及的内容有：</p><ul><li>依赖传递</li><li>可选依赖</li><li>排除依赖</li></ul><p>依赖:</p><ul><li><p>依赖指当前项目运行所需的jar一个项目可以设置多个依赖。</p></li><li><p>格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--设置当前项目所依赖的所有jar--&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!--设置具体的依赖--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;!--依赖所属群组id--&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;!--依赖所属项目id--&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">        &lt;!--依赖版本号--&gt;</span><br><span class="line">        &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="依赖传递与冲突问题"><a href="#依赖传递与冲突问题" class="headerlink" title="依赖传递与冲突问题"></a>依赖传递与冲突问题</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310241026863.png"></p><p>依赖是具有传递性的</p><p>A代表自己的项目；B，C，D，E，F，G代表的是项目所依赖的jar包；D1和D2、E1和E2代表是相同jar包的不同版本</p><ol><li>A依赖了B和C，B和C有分别依赖了其他jar包，所以在A项目中就可以使用上面所有jar包，这就是所说的依赖传递</li><li>依赖传递有直接依赖和间接依赖<ul><li>相对于A来说，A直接依赖B和C，间接依赖了D1，E1，G，F，D2和E2</li><li>相对于B来说，B直接依赖了D1和E1，间接依赖了G</li><li>直接依赖和间接依赖是一个相对的概念</li></ul></li><li>因为有依赖传递的存在，就会导致jar包在依赖的过程中出现冲突问题，具体什么是冲突？Maven是如何解决冲突的？</li></ol><p>这里所说的<code>依赖冲突</code>是指项目依赖的某一个jar包，有多个不同的版本，因而造成类包版本冲突。</p><ul><li><p>情况一：在maven_01_ssm的pom.xml中添加两个不同版本的Junit依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">      &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;4.11&lt;/version&gt;</span><br><span class="line">      &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>调换位置，刷新maven面板，我们会发现，maven的dependencies面板上总是显示使用的是后加载的jar包<br>于是我们得出一个结论：</p><ul><li>特殊优先：当同级配置了相同资源的不同版本，后配置的覆盖先配置的。</li></ul></li><li><p>情况二：路径优先：当依赖中出现相同的资源时，层级越深，优先级越低，层级越浅，优先级越高</p><ul><li>A通过B间接依赖到E1</li><li>A通过C间接依赖到E2</li><li>A就会间接依赖到E1和E2，Maven会按照层级来选择，E1是2度，E2是3度，所以最终会选择E1</li></ul></li><li><p>情况三：声明优先：当资源在相同层级被依赖时，配置顺序靠前的覆盖配置顺序靠后的</p><ul><li>A通过B间接依赖到D1</li><li>A通过C间接依赖到D2</li><li>D1和D2都是两度，这个时候就不能按照层级来选择，需要按照声明来，谁先声明用谁，也就是说B在C之前声明，这个时候使用的是D1，反之则为D2</li></ul><p>但是对于上面的结果，我们也不用刻意去记，一切以maven的dependencies面板上显示的为准</p></li></ul><h2 id="可选依赖和排除依赖"><a href="#可选依赖和排除依赖" class="headerlink" title="可选依赖和排除依赖"></a>可选依赖和排除依赖</h2><p>依赖传递介绍完以后，我们来思考一个问题，假如</p><ul><li><code>maven_01_ssm</code> 依赖了 <code>maven_03_dao</code></li><li><code>maven_03_dao</code> 依赖了 <code>maven_02_pojo</code></li><li>因为现在有依赖传递，所以<code>maven_01_ssm</code>能够使用到<code>maven_02_pojo</code>的内容</li><li>如果说现在不想让<code>maven_01_ssm</code>依赖到<code>maven_02_pojo</code>，有哪些解决方案?</li></ul><p><code>方案一：</code>可选依赖</p><ul><li><p>可选依赖指对外隐藏当前所依赖的资源—<code>不透明</code></p></li><li><p>在<code>maven_03_dao</code>的pom.xml，在引入<code>maven_02_pojo</code>的时候，添加<code>optional</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven_02_pojo&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;!--可选依赖是隐藏当前工程所依赖的资源，隐藏后对应资源将不具有依赖传递--&gt;</span><br><span class="line">    &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ul><p><code>方案二：</code>排除依赖</p><ul><li><p>排除依赖指主动断开依赖的资源，被排除的资源无需指定版本—<code>不需要</code></p></li><li><p>前面我们已经通过可选依赖实现了阻断<code>maven_02_pojo</code>的依赖传递，对于排除依赖，则指的是已经有依赖的事实，也就是说<code>maven_01_ssm</code>项目中已经通过依赖传递用到了<code>maven_02_pojo</code>，此时我们需要做的是将其进行排除，所以接下来需要修改<code>maven_01_ssm</code>的pom.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven_03_dao&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;!--排除依赖是隐藏当前资源对应的依赖关系--&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;!--这里可以排除多个依赖，只要你有需求--&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven_02_pojo&lt;/artifactId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ul><p>介绍完这两种方式后，简单来梳理下，就是</p><ul><li><code>A依赖B，B依赖C</code>，<code>C</code>通过依赖传递会被<code>A</code>使用到，现在要想办法让<code>A</code>不去依赖<code>C</code></li><li>可选依赖是在B上设置<code>&lt;optional&gt;</code>，<code>A</code>不知道有<code>C</code>的存在，</li><li>排除依赖是在A上设置<code>&lt;exclusions&gt;</code>，<code>A</code>知道有<code>C</code>的存在，主动将其排除掉。</li></ul><blockquote><p>可选依赖就像抄答案，我抄完了不像让别人抄</p><p>排除依赖就像有答案，但我是个好学生，主动不抄</p></blockquote><h1 id="聚合与继承"><a href="#聚合与继承" class="headerlink" title="聚合与继承"></a>聚合与继承</h1><p>我们的项目已经从以前的单模块，变成了现在的多模块开发。项目一旦变成了多模块开发以后，就会引发一些问题，在这一节中我们主要会学习两个内容<code>聚合</code>和<code>继承</code>，用这两个知识来解决下分模块后的一些问题。</p><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310241039145.png"></p><ul><li>分模块开发后，需要将这四个项目都安装到本地仓库，目前我们只能通过项目Maven面板的install来安装，并且需要安装四个，如果我们的项目足够多，那一个个install也挺麻烦的</li><li>如果四个项目都已经安装成功，当ssm_pojo发生变化后，我们就得将ssm_pojo重新安装到maven仓库，但是为了确保我们对ssm_pojo的修改不会影响到其他模块（比如我们将pojo类中的一个属性删除，如果其他模块调用了这个属性，那必然报错），我们需要对所有模块重新编译，看看有没有问题。然后还需要将所有模块再install一遍</li></ul><p>项目少的话还好，但是如果项目多的话，一个个操作项目就容易出现漏掉或重复操作的问题，所以我们就像能不能抽取一个项目，把所有的项目管理起来，以后再想操作这些项目，做需要操作我们抽取的这个项目，这样就省事儿多了</p><p>这就要用到我们接下来讲的<code>聚合</code>了</p><ul><li>所谓聚合：将多个模块组织成一个整体，同时进行项目构建的过程称为聚合</li><li>聚合工程：通常是一个不具有业务功能的<code>空</code>工程</li><li>作用：使用聚合工程可以将多个工程编组，通过对聚合工程的构建，实现对所包含的所有模块进行同步构建<ul><li>当工程中某个模块发生更新后，必须保障工程中与更新模块关联的模块同步更新，此时就可以使用聚合工程来解决批量模块同步构建的问题</li></ul></li></ul><p>具体实现步骤如下：</p><ul><li><p><code>步骤一：</code>创建一个空的maven项目</p></li><li><p><code>步骤二：</code>将项目打包方式改为<code>pom</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven_00_parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;!--设置打包方式--&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li></ul><p>说明：项目的打包方式，我们接触到的有三种，分别是</p><ol><li>jar:默认情况，说明该项目为java项目</li><li>war:说明该项目为web项目</li><li>pom:说明该项目为聚合或继承(后面会讲)项目</li></ol><ul><li><p><code>步骤三：</code>pom.xml添加所要管理的项目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven_00_parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;!--设置打包方式--&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--设置管理的项目名称--&gt;</span><br><span class="line">    &lt;modules&gt;</span><br><span class="line">        &lt;module&gt;../maven_01_ssm&lt;/module&gt;</span><br><span class="line">        &lt;module&gt;../maven_02_pojo&lt;/module&gt;</span><br><span class="line">        &lt;module&gt;../maven_03_dao&lt;/module&gt;</span><br><span class="line">    &lt;/modules&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>步骤四：</code>使用聚合统一管理项目<br>在maven面板上点击compile，会发现所有受管理的项目都会被执行编译，这就是聚合工程的作用</p></li></ul><p>说明：聚合工程管理的项目在进行运行的时候，会按照项目与项目之间的依赖关系来自动决定执行的顺序和配置的顺序无关。虽然我们配置的顺序是<code>123</code>，但是执行的时候按照依赖关系编译是<code>231</code>。</p><blockquote><p>将每个项目当做资源，没有前置资源的最优先，然后是当前资源能够满足的项目，直到完成</p></blockquote><p>最后总结一句话就是，<strong>聚合工程主要是用来管理项目</strong>。</p><blockquote><p>超市买东西，最后再<strong>买</strong>个袋子打包</p></blockquote><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>我们已经完成了使用聚合工程去管理项目，聚合工程进行某一个构建操作，其他被其管理的项目也会执行相同的构建操作。那么接下来，我们再来分析下，多模块开发存在的另外一个问题，<code>重复配置</code>的问题，我们先来看张图:</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310241043314.png"></p><ul><li><code>spring-webmvc</code>、<code>spring-jdbc</code>在三个项目模块中都有出现，这样就出现了重复的内容</li><li><code>spring-test</code>只在ssm_crm和ssm_goods中出现，而在ssm_order中没有，这里是部分重复的内容</li><li>我们使用的spring版本目前是<code>5.2.10.RELEASE</code>，假如后期要想升级spring版本，所有跟Spring相关jar包都得被修改，涉及到的项目越多，维护成本越高</li></ul><p>面对上面这些问题，我们就得用到接下来要学习的<code>继承</code>（类似 java 语言中的继承）</p><ul><li>所谓继承：描述的是两个工程间的关系，与java中的继承类似，子工程可以继承父工程中的配置信息，常见于依赖关系的继承</li><li>作用：<ul><li>简化配置</li><li>减少版本冲突</li></ul></li></ul><p>实现步骤：</p><ul><li><p><code>步骤一：</code>创建一个空的Maven项目并将其打包方式设置为pom</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven_00_parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;!--设置打包方式--&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>步骤二：</code>在子工程中设置其父工程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置当前工程继承自parent工程--&gt;</span><br><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;artifactId&gt;maven_00_parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;!--配置父项目的pom.xml路径--&gt;</span><br><span class="line">    &lt;relativePath&gt;../maven_00_parent/pom.xml&lt;/relativePath&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>步骤三：</code>优化子项目共有依赖导入问题</p><ol><li><p>将子项目共同使用的jar包都抽取出来，维护在父项目的pom.xml中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">        xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven_00_parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;!--设置打包方式--&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--设置管理的项目名称--&gt;</span><br><span class="line">    &lt;modules&gt;</span><br><span class="line">        &lt;module&gt;../maven_01_ssm&lt;/module&gt;</span><br><span class="line">        &lt;module&gt;../maven_02_pojo&lt;/module&gt;</span><br><span class="line">        &lt;module&gt;../maven_03_dao&lt;/module&gt;</span><br><span class="line">    &lt;/modules&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.5.6&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.3.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.46&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.16&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.1.0&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.9.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></li><li><p>删除子项目中已经被抽取到父项目的pom.xml中的jar包</p><ul><li>删除完后，你会发现父项目中有依赖对应的jar包，子项目虽然已经将重复的依赖删除掉了，但是刷新的时候，子项目中所需要的jar包依然存在。</li><li>当项目的<code>&lt;parent&gt;</code>标签被移除掉，会发现多出来的jar包依赖也会随之消失。</li></ul></li><li><p>在父项目中修改jar包的版本，刷新后，子项目中的jar包版本也随之变化</p><p>那么现在我们就可以解决了刚才提到的第一个问题，将子项目中的公共jar包抽取到父工程中进行统一添加依赖，这样做的可以简化配置，并且当父工程中所依赖的jar包版本发生变化，所有子项目中对应的jar包版本也会跟着更新。</p></li></ol></li></ul><ul><li><p><code>步骤四：</code>优化子项目依赖版本问题</p><p>如果把所有用到的jar包都管理在父项目的pom.xml，看上去更简单些，但是这样就会导致有很多项目引入了过多自己不需要的jar包。如上面看到的这张图:</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310241051435.png"></p><p>如果把所有的依赖都放在了父工程中进行统一维护，就会导致ssm_order项目中多引入了<code>spring-test</code>的jar包，如果这样的jar包过多的话，对于ssm_order来说也是一种”负担”。</p></li></ul><p>那针对于这种部分项目有的jar包，我们该如何管理优化呢?</p><ol><li><p>那针对于这种部分项目有的jar包，我们该如何管理优化呢?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--定义依赖管理--&gt;</span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure></li><li><p>将maven_01_ssm的pom.xml中的junit依赖删除掉，刷新Maven<br>刷新后，在maven_01_ssm项目中找不到junit依赖，所以我们得出一个结论<br><code>&lt;dependencyManagement&gt;</code>标签不真正引入jar包，而是配置可供子项目选择的jar包依赖<br>子项目要想使用它所提供的这些jar包，需要自己添加依赖，并且不需要指定<code>&lt;version&gt;</code></p></li><li><p>在在maven_01_ssm的pom.xml添加junit的依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里就不需要添加版本了，这样做的好处就是当父工程<code>dependencyManagement</code>标签中的版本发生变化后，子项目中的依赖版本也会跟着发生变化</p></blockquote></li><li><p>在maven_03_dao的pom.xml添加junit的依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>这个时候，maven_01_ssm和maven_03_dao这两个项目中的junit版本就会跟随着父项目中的标签<code>dependencyManagement</code>中junit的版本发生变化而变化。不需要junit的项目就不需要添加对应的依赖即可（maven_02_pojo中就没添加）</p><p>至此继承就已经学习完了，总结来说，继承可以帮助做两件事</p><ul><li><p>将所有项目公共的jar包依赖提取到父工程的pom.xml中，子项目就可以不用重复编写，简化开发</p></li><li><p>将所有项目的jar包配置到父工程的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dependencyManagement</span><br></pre></td></tr></table></figure><p>标签下，实现版本管理，方便维护</p><ul><li><code>dependencyManagement</code>标签不真正引入jar包，只是管理jar包的版本</li><li>子项目在引入的时候，只需要指定groupId和artifactId，不需要加version</li><li>当<code>dependencyManagement</code>标签中jar包版本发生变化，所有子项目中有用到该jar包的地方对应的版本会自动随之更新</li></ul></li></ul><p>最后总结一句话就是，<code>父工程主要是用来快速配置依赖jar包和管理项目中所使用的资源</code>。</p></li></ol><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>继承的实现步骤:</p><ul><li><p>创建Maven模块，设置打包类型为pom</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;packaging&gt;pom&lt;/packaging&gt;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>在父工程的pom文件中配置依赖关系(子工程将沿用父工程中的依赖关系),一般只抽取子项目中公有的jar包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></li><li><p>在父工程中配置子工程中可选的依赖关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.16&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>在子工程中配置当前工程所继承的父工程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--定义该工程的父工程--&gt;</span><br><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven_01_parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;!--填写父工程的pom文件,可以不写--&gt;</span><br><span class="line">    &lt;relativePath&gt;../maven_01_parent/pom.xml&lt;/relativePath&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure></li><li><p>在子工程中配置使用父工程中可选依赖的坐标</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></li></ul><p>注意事项:</p><ol><li>子工程中使用父工程中的可选依赖时，<strong>仅需要提供群组id和项目id，无需提供版本</strong>，版本由父工程统一提供，避免版本冲突</li><li>子工程中还可以定义父工程中没有定义的依赖关系，只不过不能被父工程进行版本统一管理。</li></ol><h2 id="聚合与继承的区别"><a href="#聚合与继承的区别" class="headerlink" title="聚合与继承的区别"></a>聚合与继承的区别</h2><p>聚合与继承分别的作用:</p><ul><li>聚合用于快速构建项目，对项目进行管理</li><li>继承用于快速配置和管理子项目中所使用jar包的版本</li></ul><p>聚合和继承的相同点:</p><ul><li>聚合与继承的pom.xml文件打包方式均为pom，可以将两种关系制作到同一个pom文件中</li><li>聚合与继承均属于设计型模块，并无实际的模块内容</li></ul><p>聚合和继承的不同点:</p><ul><li>聚合是在当前模块中配置关系，聚合可以感知到参与聚合的模块有哪些</li><li>继承是在子模块中配置关系，父模块无法感知哪些子模块继承了自己</li></ul><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p>属性中会继续解决分模块开发项目存在的问题，版本管理主要是认识下当前主流的版本定义方式。</p><h2 id="属性引入"><a href="#属性引入" class="headerlink" title="属性引入"></a>属性引入</h2><p>问题分析：</p><p>前面我们已经在父工程中的dependencyManagement标签中对项目中所使用的jar包版本进行了统一的管理，但是如果在标签中有如下的内容:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.5.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>如果我们现在想更新Spring的版本，就会发现我们依然需要更新多个jar包的版本，这样的话还是有可能出现漏改导致程序出问题，而且改起来也是比较麻烦。<br>问题清楚后，我们需要解决的话，就可以参考咱们java基础所学习的变量，声明一个变量，在其他地方使用该变量，当变量的值发生变化后，所有使用变量的地方也会跟着变化<br>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String spring_version = &quot;5.2.10.RELEASE&quot;;</span><br></pre></td></tr></table></figure><p>然后将依赖的版本号替换成<code>spring_version</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;spring_version&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>解决步骤</p><ul><li><p><code>步骤一：</code>父工程中定义属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">        &lt;spring.version&gt;5.2.10.RELEASE&lt;/spring.version&gt;</span><br><span class="line">        &lt;mybatis.version&gt;3.5.6&lt;/mybatis.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>步骤二：</code>修改依赖的version</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>此时，我们只需要更新父工程中properties标签中所维护的jar包版本，所有子项目中的版本也就跟着更新。当然除了将spring相关版本进行维护，我们可以将其他的jar包版本也进行抽取，这样就可以对项目中所有jar包的版本进行统一维护</p></li></ul><p>说明：</p><p>使用<code>properties</code>标签来定义属性，在<code>properties</code>标签内自定义标签名当做属性名，自定义标签内的值即为属性值<br>例如：</p><p><code>&lt;spring.version&gt;5.2.10.RELEASE&lt;/spring.version&gt;</code>，属性名为<code>spring.version</code>，属性值为<code>5.2.10.RELEASE</code>，在其他地方引用变量时用<code>$&#123;变量名&#125;</code></p><h2 id="配置文件加载属性"><a href="#配置文件加载属性" class="headerlink" title="配置文件加载属性"></a>配置文件加载属性</h2><p>Maven中的属性我们已经介绍过了，现在也已经能够通过Maven来集中管理Maven中依赖jar包的版本。但是又有新的需求，就是想让Maven对于属性的管理范围能更大些，比如我们之前项目中的<code>jdbc.properties</code>，这个配置文件中的属性，能不能也来让Maven进行管理呢?</p><p>答案是肯定的，具体的实现步骤如下</p><ul><li><p><code>步骤一：</code>父工程定义属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;spring.version&gt;5.2.10.RELEASE&lt;/spring.version&gt;</span><br><span class="line">    &lt;mybatis.version&gt;3.5.6&lt;/mybatis.version&gt;</span><br><span class="line">    &lt;jdbc.driver&gt;com.mysql.jdbc.Driver&lt;/jdbc.driver&gt;</span><br><span class="line">    &lt;jdbc.url&gt;jdbc:mysql://localhost:13306/ssm_db?useSSL=false&lt;/jdbc.url&gt;</span><br><span class="line">    &lt;jdbc.username&gt;root&lt;/jdbc.username&gt;</span><br><span class="line">    &lt;jdbc.password&gt;PASSWORD&lt;/jdbc.password&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>步骤二：</code>jdbc.properties文件中引用属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driver=$&#123;jdbc.driver&#125;</span><br><span class="line">jdbc.url=$&#123;jdbc.url&#125;</span><br><span class="line">jdbc.username=$&#123;jdbc.username&#125;</span><br><span class="line">jdbc.password=$&#123;jdbc.password&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>步骤三：</code>设置maven过滤文件范围<br>直接在properties中引用属性，看起来怪怪的，properties怎么能直接用到maven中配置的属性呢？<br>所以我们还需要来配置一下，让<code>maven_01_ssm/src/main/resources</code>目录下的<code>jdbc.properties</code>文件可以解析<code>$&#123;&#125;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;resources&gt;</span><br><span class="line">        &lt;!--设置资源目录--&gt;</span><br><span class="line">        &lt;resource&gt;</span><br><span class="line">            &lt;directory&gt;../maven_01_ssm/src/main/resources&lt;/directory&gt;</span><br><span class="line">            &lt;!--设置能够解析$&#123;&#125;，默认是false --&gt;</span><br><span class="line">            &lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">        &lt;/resource&gt;</span><br><span class="line">    &lt;/resources&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>步骤四：</code>测试是否生效<br>测试的时候，只需要将maven_01_ssm项目进行打包，然后在本地仓库观察打包结果中最终生成的内容是否为Maven中配置的内容。</p></li><li><p><code>存在的问题</code><br>如果不只是<code>maven_01_ssm</code>项目需要有属性被父工程管理，如果还有多个项目需要配置，该如何实现呢?</p><ul><li><p><code>方式一</code>：可以一个一个配，但是项目足够多的话，这样还是比较繁琐的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;resources&gt;</span><br><span class="line">        &lt;!--设置资源目录，并设置能够解析$&#123;&#125;--&gt;</span><br><span class="line">        &lt;resource&gt;</span><br><span class="line">            &lt;directory&gt;../maven_01_ssm/src/main/resources&lt;/directory&gt;</span><br><span class="line">            &lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">        &lt;/resource&gt;</span><br><span class="line">        &lt;resource&gt;</span><br><span class="line">            &lt;directory&gt;../maven_02_pojo/src/main/resources&lt;/directory&gt;</span><br><span class="line">            &lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">        &lt;/resource&gt;</span><br><span class="line">        ...</span><br><span class="line">    &lt;/resources&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>方式二：</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;resources&gt;</span><br><span class="line">        &lt;!--</span><br><span class="line">            $&#123;project.basedir&#125;: 当前项目所在目录,子项目继承了父项目，</span><br><span class="line">            相当于所有的子项目都添加了资源目录的过滤</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;resource&gt;</span><br><span class="line">            &lt;directory&gt;$&#123;project.basedir&#125;/src/main/resources&lt;/directory&gt;</span><br><span class="line">            &lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">        &lt;/resource&gt;</span><br><span class="line">    &lt;/resources&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>说明：如果打包过程中出现错误<code>Error assembling WAR: webxml attribute is required</code><br>原因就是Maven发现你的项目为web项目，就会去找web项目的入口web.xml(配置文件配置的方式)，发现没有找到，就会报错。</p><ul><li><p><code>解决方案1：</code>在maven_02_ssm项目的<code>src\main\webapp\WEB-INF\</code>添加一个web.xml文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;</span><br><span class="line">         version=&quot;3.1&quot;&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>解决方案2:</code> 配置maven打包war时，忽略web.xml检查</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.2.3&lt;/version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure></li></ul><p>上面我们所使用的都是Maven的自定义属性，除了<code>$&#123;project.basedir&#125;</code>,它属于Maven的内置系统属性。</p><p>在Maven中的属性分为:</p><ul><li>自定义属性（常用）</li><li>内置属性</li><li>Setting属性</li><li>Java系统属性</li><li>环境变量属性</li></ul><table><thead><tr><th align="center">属性分类</th><th align="center">引用格式</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">自定义属性</td><td align="center">${自定义属性名}</td><td align="center">${spring.vension}</td></tr><tr><td align="center">内置属性</td><td align="center">${内置属性名}</td><td align="center">${basedir}、${version}</td></tr><tr><td align="center">setting属性</td><td align="center">${setting.属性名}</td><td align="center">${settings.localRepository}</td></tr><tr><td align="center">ava系统属性</td><td align="center">${系统属性分类.系统属性名}</td><td align="center">${user.home}</td></tr><tr><td align="center">环境变量属性</td><td align="center">${env.环境变量属性名}</td><td align="center">${env.JAVA_HOME}</td></tr></tbody></table><h2 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h2><p>关于这个版本管理解决的问题是，在Maven创建项目和引用别人项目的时候，我们都看到过如下内容:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;maven_00_parent&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;5.2.10.RELEASE&lt;/version&gt;</span><br></pre></td></tr></table></figure><p>这里面有两个单词，SNAPSHOT和RELEASE，它们所代表的含义是什么呢?</p><ul><li>SNAPSHOT（快照版本）<ul><li>项目开发过程中临时输出的版本，称为快照版本</li><li>快照版本会随着开发的进展不断更新</li></ul></li><li>RELEASE（发布版本）<ul><li>项目开发到一定阶段里程碑后，向团队外部发布较为稳定的版本，这种版本所对应的构件文件是稳定的</li><li>即便进行功能的后续开发，也不会改变当前发布版本内容，这种版本称为发布版本</li></ul></li></ul><p>除了上面的工程版本，我们还经常能看到一些发布版本：</p><ul><li>alpha版：内测版，bug多不稳定内部版本不断添加新功能</li><li>beta版：公测版，不稳定(比alpha稳定些)，bug相对较多不断添加新功能，相信你更新QQ的时候，一定见过QQ的beta测试版</li><li>纯数字版</li></ul><h1 id="多环境配置与应用"><a href="#多环境配置与应用" class="headerlink" title="多环境配置与应用"></a>多环境配置与应用</h1><h2 id="多环境开发"><a href="#多环境开发" class="headerlink" title="多环境开发"></a>多环境开发</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310241117970.png"></p><p>我们平常都是在自己的开发环境进行开发</p><p>当开发完成后，需要把开发的功能部署到测试环境供测试人员进行测试使用</p><p>等测试人员测试通过后，我们会将项目部署到生成环境上线使用。</p><p>这个时候就有一个问题是，不同环境的配置是不相同的，如不可能让三个环境都用一个数据库，所以就会有三个数据库的url配置，</p><p>我们在项目中如何配置?</p><p>要想实现不同环境之间的配置切换又该如何来实现呢?</p><p>maven提供配置多种环境的设定，帮助开发者在使用过程中快速切换环境。具体实现步骤如下</p><ul><li><p><code>步骤一：</code>父工程配置多个环境，并指定默认激活环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;profiles&gt;</span><br><span class="line">    &lt;!--开发环境--&gt;</span><br><span class="line">    &lt;profile&gt;</span><br><span class="line">        &lt;id&gt;env_dep&lt;/id&gt;</span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">            &lt;jdbc.url&gt;jdbc:mysql://127.1.1.1:3306/ssm_db&lt;/jdbc.url&gt;</span><br><span class="line">        &lt;/properties&gt;</span><br><span class="line">        &lt;!--设定是否为默认环境--&gt;</span><br><span class="line">        &lt;activation&gt;</span><br><span class="line">            &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;</span><br><span class="line">        &lt;/activation&gt;</span><br><span class="line">    &lt;/profile&gt;</span><br><span class="line">    &lt;!--生产环境--&gt;</span><br><span class="line">    &lt;profile&gt;</span><br><span class="line">        &lt;id&gt;env_pro&lt;/id&gt;</span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">            &lt;jdbc.url&gt;jdbc:mysql://127.2.2.2:3306/ssm_db&lt;/jdbc.url&gt;</span><br><span class="line">        &lt;/properties&gt;</span><br><span class="line">    &lt;/profile&gt;</span><br><span class="line">    &lt;!--测试环境--&gt;</span><br><span class="line">    &lt;profile&gt;</span><br><span class="line">        &lt;id&gt;env_test&lt;/id&gt;</span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">            &lt;jdbc.url&gt;jdbc:mysql://127.3.3.3:3306/ssm_db&lt;/jdbc.url&gt;</span><br><span class="line">        &lt;/properties&gt;</span><br><span class="line">    &lt;/profile&gt;</span><br><span class="line">&lt;/profiles&gt;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>步骤二：</code>执行install查看env_dep环境是否生效<br>在你本地仓库找到打包的war包，看看jdbc.properties配置文件中的url是否为<code>jdbc:mysql://127.1.1.1:3306/ssm_db</code></p></li><li><p><code>步骤三：</code>切换默认环境为生产环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;profiles&gt;</span><br><span class="line">    &lt;!--开发环境--&gt;</span><br><span class="line">    &lt;profile&gt;</span><br><span class="line">        &lt;id&gt;env_dep&lt;/id&gt;</span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">            &lt;jdbc.url&gt;jdbc:mysql://127.1.1.1:3306/ssm_db&lt;/jdbc.url&gt;</span><br><span class="line">        &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/profile&gt;</span><br><span class="line">    &lt;!--生产环境--&gt;</span><br><span class="line">    &lt;profile&gt;</span><br><span class="line">        &lt;id&gt;env_pro&lt;/id&gt;</span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">            &lt;jdbc.url&gt;jdbc:mysql://127.2.2.2:3306/ssm_db&lt;/jdbc.url&gt;</span><br><span class="line">        &lt;/properties&gt;</span><br><span class="line">        &lt;!--设定是否为默认环境--&gt;</span><br><span class="line">        &lt;activation&gt;</span><br><span class="line">            &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;</span><br><span class="line">        &lt;/activation&gt;</span><br><span class="line">    &lt;/profile&gt;</span><br><span class="line">    &lt;!--测试环境--&gt;</span><br><span class="line">    &lt;profile&gt;</span><br><span class="line">        &lt;id&gt;env_test&lt;/id&gt;</span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">            &lt;jdbc.url&gt;jdbc:mysql://127.3.3.3:3306/ssm_db&lt;/jdbc.url&gt;</span><br><span class="line">        &lt;/properties&gt;</span><br><span class="line">    &lt;/profile&gt;</span><br><span class="line">&lt;/profiles&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>步骤四：</code>执行install并查看env_pro环境是否生效<br>查看到的结果为<code>jdbc:mysql://127.2.2.2:3306/ssm_db</code><br>虽然已经能够实现不同环境的切换，但是每次切换都是需要手动修改，如何来实现在不改变代码的前提下完成环境的切换呢?</p></li><li><p><code>步骤无：</code>命令行实现环境切换<br>在命令后加上环境id<code>mvn install -P env_test</code></p></li><li><p><code>步骤六：</code>执行安装并查看env_test环境是否生效<br>查看到的结果为<code>jdbc:mysql://127.3.3.3:3306/ssm_db</code></p></li></ul><p>所以总结来说，对于多环境切换只需要两步即可:</p><ul><li><p>父工程中定义多环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;profiles&gt;</span><br><span class="line">&lt;profile&gt;</span><br><span class="line">    &lt;id&gt;环境名称&lt;/id&gt;</span><br><span class="line">        &lt;properties&gt;</span><br><span class="line">        &lt;key&gt;value&lt;/key&gt;</span><br><span class="line">        &lt;/properties&gt;</span><br><span class="line">        &lt;activation&gt;</span><br><span class="line">        &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;</span><br><span class="line">        &lt;/activation&gt;</span><br><span class="line">    &lt;/profile&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/profiles&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用多环境(构建过程)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn 指令 -P 环境定义ID</span><br></pre></td></tr></table></figure></li></ul><h2 id="跳过测试"><a href="#跳过测试" class="headerlink" title="跳过测试"></a>跳过测试</h2><p>前面在执行<code>install</code>指令的时候，Maven都会按照顺序从上往下依次执行，每次都会执行<code>test</code>,</p><p>对于<code>test</code>来说有它存在的意义，</p><ul><li>可以确保每次打包或者安装的时候，程序的正确性，假如测试已经通过在我们没有修改程序的前提下再次执行打包或安装命令，由于顺序执行，测试会被再次执行，就有点耗费时间了。</li><li>功能开发过程中有部分模块还没有开发完毕，测试无法通过，但是想要把其中某一部分进行快速打包，此时由于测试环境失败就会导致打包失败。</li></ul><p>遇到上面这些情况的时候，我们就想跳过测试执行下面的构建命令，具体实现方式有很多：</p><ul><li><p><code>方式一：</code>IDEA工具实现跳过测试<br>IDEA的maven面板上有一个按钮，点击之后可以跳过测试，不过此种方式会跳过所有的测试，如果我们想更精细的控制哪些跳过，哪些不跳过，那么就需要使用配置插件的方式来完成了</p></li><li><p><code>方式二：</code>配置插件实现跳过测试<br>在父工程中的pom.xml中添加测试插件配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.12.4&lt;/version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;skipTests&gt;false&lt;/skipTests&gt;</span><br><span class="line">                &lt;!--排除掉不参与测试的内容--&gt;</span><br><span class="line">                &lt;excludes&gt;</span><br><span class="line">                    &lt;exclude&gt;**/BookServiceTest.java&lt;/exclude&gt;</span><br><span class="line">                &lt;/excludes&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p><code>skipTests：</code>如果为true，则跳过所有测试，如果为false，则不跳过测试<br><code>excludes：</code>哪些测试类不参与测试，即排除，针对skipTests为false来设置的<br><code>includes：</code>哪些测试类要参与测试，即包含,针对skipTests为true来设置的</p></li><li><p><code>方式三：</code>命令行跳过测试<br>使用Maven的命令行，<code>mvn 指令 -D skipTests</code></p></li></ul><p>注意事项:</p><ul><li>执行的项目构建指令必须包含测试生命周期，否则无效果。例如执行compile生命周期，不经过test生命周期。</li><li>该命令可以不借助IDEA，直接使用cmd命令行进行跳过测试，需要注意的是cmd要在pom.xml所在目录下进行执行。</li></ul><h1 id="私服"><a href="#私服" class="headerlink" title="私服"></a>私服</h1><h2 id="私服简介"><a href="#私服简介" class="headerlink" title="私服简介"></a>私服简介</h2><p>团队开发现状分析</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310241126067.png"></p><ol><li>张三负责ssm_crm的开发，自己写了一个ssm_pojo模块，要想使用直接将ssm_pojo安装到本地仓库即可</li><li>李四负责ssm_order的开发，需要用到张三所写的ssm_pojo模块，这个时候如何将张三写的ssm_pojo模块交给李四呢?</li><li>如果直接拷贝，那么团队之间的jar包管理会非常混乱而且容器出错，这个时候我们就想能不能将写好的项目上传到中央仓库，谁想用就直接联网下载即可</li><li>Maven的中央仓库不允许私人上传自己的jar包,那么我们就得换种思路，自己搭建一个类似于中央仓库的东西，把自己的内容上传上去，其他人就可以从上面下载jar包使用</li><li>这个类似于中央仓库的东西就是我们接下来要学习的私服</li></ol><p>所以到这就有两个概念，一个是私服，一个是中央仓库</p><ul><li><code>私服:</code>公司内部搭建的用于存储Maven资源的服务器</li><li><code>远程仓库:</code>Maven开发团队维护的用于存储Maven资源的服务器</li></ul><p>结论：私服是一台独立的服务器，用于解决团队内部的资源共享与资源同步问题</p><h2 id="私服仓库分类"><a href="#私服仓库分类" class="headerlink" title="私服仓库分类"></a>私服仓库分类</h2><p>私服资源操作流程分析：</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310241127829.png"></p><ol><li>在没有私服的情况下，我们自己创建的服务都是安装在Maven的本地仓库中</li><li>私服中也有仓库，我们要把自己的资源上传到私服，最终也是放在私服的仓库中</li><li>其他人要想使用你所上传的资源，就需要从私服的仓库中获取</li><li>当我们要使用的资源不是自己写的，是远程中央仓库有的第三方jar包，这个时候就需要从远程中央仓库下载，每个开发者都去远程中央仓库下速度比较慢(中央仓库服务器在国外)</li><li>私服就再准备一个仓库，用来专门存储从远程中央仓库下载的第三方jar包，第一次访问没有就会去远程中央仓库下载，下次再访问就直接走私服下载</li><li>前面在介绍版本管理的时候提到过有<code>SNAPSHOT</code>和<code>RELEASE</code>，如果把这两类的都放到同一个仓库，比较混乱，所以私服就把这两个种jar包放入不同的仓库</li><li>上面我们已经介绍了有三种仓库，一种是存放<code>SNAPSHOT</code>的，一种是存放<code>RELEASE</code>还有一种是存放从远程仓库下载的第三方jar包，那么我们在获取资源的时候要从哪个仓库种获取呢?</li><li>为了方便获取，我们将所有的仓库编成一个组，我们只需要访问仓库组去获取资源。</li></ol><p>所有私服仓库总共分为三大类:</p><ol><li>宿主仓库hosted<ul><li>保存无法从中央仓库获取的资源</li><li>自主研发</li><li>第三方非开源项目,比如Oracle,因为是付费产品，所以中央仓库没有</li></ul></li><li>代理仓库proxy<ul><li>代理远程仓库，通过nexus访问其他公共仓库，例如中央仓库</li></ul></li><li>仓库组group<ul><li>将若干个仓库组成一个群组，简化配置</li><li>仓库组不能保存资源，属于设计型仓库</li></ul></li></ol><table><thead><tr><th align="center">仓库类别</th><th align="center">英文名称</th><th align="center">功能</th><th align="center">关联操作</th></tr></thead><tbody><tr><td align="center">宿主仓库</td><td align="center">hosted</td><td align="center">保存自主研发+第三方资源</td><td align="center">上传</td></tr><tr><td align="center">代理仓库</td><td align="center">proxy</td><td align="center">代理连接中央仓库</td><td align="center">下载</td></tr><tr><td align="center">仓库组</td><td align="center">group</td><td align="center">为仓库编组简化下载操作</td><td align="center">下载</td></tr></tbody></table><h2 id="本地仓库访问私服配置"><a href="#本地仓库访问私服配置" class="headerlink" title="本地仓库访问私服配置"></a>本地仓库访问私服配置</h2><ul><li>我们通过IDEA将开发的模块上传到私服，中间是要经过本地Maven的</li><li>本地Maven需要知道私服的访问地址以及私服访问的用户名和密码</li><li>私服中的仓库很多，Maven最终要把资源上传到哪个仓库?</li><li>Maven下载的时候，又需要携带用户名和密码到私服上找对应的仓库组进行下载，然后再给IDEA</li><li>上面所说的这些内容，我们需要在本地Maven的配置文件<code>settings.xml</code>中进行配置。</li></ul><p>实现：</p><ul><li><p><code>步骤一：</code>私服上配置仓库<br>新建两个仓库，type选hosted，version policy 一个选release，一个选snapshot</p></li><li><p><code>步骤二：</code>配置本地Maven对私服的访问权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;server&gt;</span><br><span class="line">    &lt;!--id就是刚刚创建的仓库名--&gt;</span><br><span class="line">    &lt;id&gt;blog-snapshot&lt;/id&gt;</span><br><span class="line">    &lt;username&gt;admin&lt;/username&gt;</span><br><span class="line">    &lt;password&gt;7d1f6527-cf26-4be3-974a-de177d75cb87&lt;/password&gt;</span><br><span class="line">&lt;/server&gt;</span><br><span class="line">&lt;server&gt;</span><br><span class="line">    &lt;id&gt;blog-release&lt;/id&gt;</span><br><span class="line">    &lt;username&gt;admin&lt;/username&gt;</span><br><span class="line">    &lt;password&gt;7d1f6527-cf26-4be3-974a-de177d75cb87&lt;/password&gt;</span><br><span class="line">&lt;/server&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>步骤三：</code>配置私服的访问路径</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;mirror&gt;</span><br><span class="line">    &lt;!--配置仓库组的ID--&gt;</span><br><span class="line">    &lt;id&gt;maven-public&lt;/id&gt;</span><br><span class="line">    &lt;!--*代表所有内容都从私服获取--&gt;</span><br><span class="line">    &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;</span><br><span class="line">    &lt;!--私服仓库组maven-public的访问路径--&gt;</span><br><span class="line">    &lt;url&gt;http://localhost:8081/repository/maven-public/&lt;/url&gt;</span><br><span class="line">&lt;/mirror&gt;</span><br></pre></td></tr></table></figure><p>最后记得将新创建的两个仓库加入到maven-public的成员中，至此本地仓库就能与私服进行交互了</p><h2 id="私服资源的下载和上传"><a href="#私服资源的下载和上传" class="headerlink" title="私服资源的下载和上传"></a>私服资源的下载和上传</h2><p>本地仓库与私服已经建立了连接，接下来我们就需要往私服上上传资源和下载资源，具体的实现步骤如下</p><ul><li><p><code>步骤一：</code>配置工程上传私服的具体位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;distributionManagement&gt;</span><br><span class="line">    &lt;repository&gt;</span><br><span class="line">        &lt;id&gt;blog-release&lt;/id&gt;</span><br><span class="line">        &lt;url&gt;http://localhost:8081/repository/blog-release/&lt;/url&gt;</span><br><span class="line">    &lt;/repository&gt;</span><br><span class="line">    &lt;snapshotRepository&gt;</span><br><span class="line">        &lt;id&gt;blog-snapshot&lt;/id&gt;</span><br><span class="line">        &lt;url&gt;http://localhost:8081/repository/blog-snapshot/&lt;/url&gt;</span><br><span class="line">    &lt;/snapshotRepository&gt;</span><br><span class="line">&lt;/distributionManagement&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>步骤二：</code>发布资源到私服<br>maven面板中运行<code>deploy</code>，或者执行maven命令<code>mvn deploy</code></p><p>发布成功，在私服中就能看到了</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310241138794.png"></p><p>现在发布是在blog-snapshot仓库中，如果想发布到blog-release仓库中就需要将项目pom.xml中的version修改成RELEASE即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;groupId&gt;com.blog&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;maven_00_parent&lt;/artifactId&gt;</span><br><span class="line">&lt;!--&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;--&gt;</span><br><span class="line">&lt;version&gt;1.0-RELEASE&lt;/version&gt;</span><br></pre></td></tr></table></figure><p>如果私服中没有对应的jar，会去中央仓库下载，速度很慢。可以配置让私服去阿里云中下载依赖。<br>修改maven-central的Remote storage为<code>http://maven.aliyun.com/nexus/content/groups/public</code></p><p>至此私服的搭建就已经完成，相对来说有点麻烦，但是步骤都比较固定，后期忘了就常回来看</p><p>注意:</p><ul><li>要发布的项目都需要配置<code>distributionManagement</code>标签，要么在自己的pom.xml中配置，要么在其父项目中配置，然后子项目中继承父项目即可。</li><li>如果报401错误，尝试将maven的setting.xml文件复制到<code>C:\Users\username\.m2</code>目录下，然后在重新进行deploy</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven</title>
      <link href="/2023/08/21/Maven%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/08/21/Maven%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Maven简介"><a href="#Maven简介" class="headerlink" title="Maven简介"></a>Maven简介</h1><h2 id="Maven是什么"><a href="#Maven是什么" class="headerlink" title="Maven是什么"></a>Maven是什么</h2><p>在开发中，需要使用大量的jar包，我们手动去导入；如何能够让一个东西自动帮我导入和配置这个jar包。由此，Maven诞生了</p><ul><li>Maven的本质是一个项目管理工具，将项目开发和管理过程抽象成-一个项目对象模型(POM)</li><li>Maven是用Java语言编写的。他管理的东西统统以面向对象的形式进行设计，最终它把一个项目看成一个对象，而这个对象叫做<strong>POM</strong>(project object model)，即项目对象模型</li><li>POM (Project Object Model)：项目对象模型</li></ul><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309091528718.png"></p><p>图中蓝色部分为核心，其余部分都是可以替换的。</p><p>Maven通过<strong>依赖管理</strong>进行项目资源管理的。这也是它的第二个核心！</p><ul><li>所谓依赖管理就是maven对项目所有依赖资源的一种管理，它和项目之间是一种双向关系，即当我们做项目的时候maven的依赖管理可以帮助你去管理你所需要的其他资源，当其他的项目需要依赖我们项目的时候，maven也会把我们的项目当作一种资源去进行管理，这就是一种双向关系。</li><li>那maven的依赖管理它管理的这些资源存在哪儿呢？主要有三个位置：本地仓库，私服，中央仓库</li><li>本地仓库顾名思义就是存储在本地的一种资源仓库，如果本地仓库中没有相关资源，可以去私服上获取，私服也是一个资源仓库，只不过不在本地，是一种远程仓库，如果私服上也没有相关资源，可以去中央仓库去获取，中央仓库也是一种远程仓库。</li><li>Maven除了帮我们管理项目资源之外还能帮助我们对项目进行构建，管理项目的整个生命周期，当然它的这些功能需要使用一些相关的插件来完成，当然整个生命周期过程中插件是需要配合使用的，单独一个无法完成完整的生命周期。</li></ul><h2 id="Maven的作用"><a href="#Maven的作用" class="headerlink" title="Maven的作用"></a>Maven的作用</h2><ul><li>项目构建:提供标准的、跨平台的自动化项目构建方式</li><li>依赖管理:方便快捷的管理项目依赖的资源(jar包) ， 避免资源间的版本冲突问题</li><li>统一开发结构:提供标准的、统-的项目结构</li></ul><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309091536970.png"></p><p>各目录存放资源类型说明：</p><p>src&#x2F;main&#x2F;java：项目java源码</p><p>src&#x2F;main&#x2F;resources：项目的相关配置文件（比如mybatis配置，xml映射配置，自定义配置文件等）</p><p>src&#x2F;main&#x2F;webapp：web资源（比如html，css，js等）</p><p>src&#x2F;test&#x2F;java：测试代码</p><p>src&#x2F;test&#x2F;resources：测试相关配置文件</p><p>src&#x2F;pom.xml：项目pom文件</p><h1 id="Maven安装"><a href="#Maven安装" class="headerlink" title="Maven安装"></a>Maven安装</h1><p><a href="https://maven.apache.org/">官网</a></p><p>maven是一个绿色软件，解压即安装。</p><p>配置环境变量：</p><ul><li>依赖Java，需要配置JAVA_ HOME</li><li>设置MAVEN自身的运行环境，需要配置MAVEN_ HOME</li></ul><p>环境变量配置好之后需要测试环境配置结果，我们需要在DOS命令窗口下输入以下命令查看输出，如果能够看到输出的maven的版本信息代表配置成功<code>mvn -v</code></p><h1 id="Maven概念"><a href="#Maven概念" class="headerlink" title="Maven概念"></a>Maven概念</h1><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p>用于存储资源，主要是各种jar包</p><p>关于仓库，有三种：本地仓库，私服，中央仓库，其中私服和中央仓库都属于远程仓库</p><p><strong>中央仓库</strong>：maven团队自身维护的仓库，属于开源的，包含几乎全部的jar包</p><p><strong>私服</strong>：各公司&#x2F;部门等小范围内存储资源的仓库，私服也可以从中央仓库获取资源，私服中有公司自己的未开源的jar包，也加快了速度</p><p><strong>本地仓库</strong>：开发者自己电脑上存储资源的仓库，也可从远程仓库获取资源</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20230909154543369.png" alt="image-20230909154543369"></p><h2 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h2><p>maven中的坐标用于描述仓库中资源的位置</p><p>maven坐标的主要组成如下：GAV</p><ul><li>groupId：定义当前资源隶属组织名称（通常是域名反写，如：org.mybatis；com.itheima）</li><li>artifactId：定义当前资源的名称（通常是项目或模块名称，如：crm，sms）</li><li>version：定义当前资源的版本号</li><li>packaging：定义资源的打包方式，取值一般有如下三种<ul><li>jar：该资源打成jar包，默认是jar java工程打包为jar</li><li>war：该资源打成war包 web工程打包为war</li><li>pom：该资源是一个父资源（表明使用maven分模块管理），打包时只生成一个pom.xml不生成jar或其他包结构</li></ul></li></ul><blockquote><p>有一个很重要的网站<code>mvnrepository.com</code>，里面收纳了所有能被maven使用的公开jar包，需要的时候去里面复制依赖</p></blockquote><h1 id="Maven项目创建"><a href="#Maven项目创建" class="headerlink" title="Maven项目创建"></a>Maven项目创建</h1><ol><li>修改idea默认的maven设置</li><li>创建maven项目</li></ol><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309121920416.png"></p><h1 id="Maven依赖管理"><a href="#Maven依赖管理" class="headerlink" title="Maven依赖管理"></a>Maven依赖管理</h1><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><p>依赖是指在当前项目中运行所需的jar，依赖配置的格式如下，需要配置GAV</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--设置当前项目所依赖的所有jar--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置具体的依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--依赖所属群组id--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>Junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--依赖所属项目id--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--依赖版本号--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可选依赖：可选依赖指的是对外隐藏当前所依赖的资源（不让别人看），加一个<code>&lt;optional&gt;</code> 标签就能使用，但是很多时候使用别人的依赖，无法修改，所以只能排除</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>Junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="排除依赖"><a href="#排除依赖" class="headerlink" title="排除依赖"></a>排除依赖</h2><p>排除依赖指主动断开依赖的资源，被排除的资源无需指定版本，使用一个大依赖，排除中间的一个小依赖</p><p>用标签&lt; exclusions&gt;这是个复数标签，里面用多个&lt; exclusion&gt;，这个指出具体的排除项</p><p>排除依赖不写版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;Junit&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;Junit&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">        &lt;exclusions&gt;</span><br><span class="line">            &lt;exclusion&gt;</span><br><span class="line">                &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">            &lt;/exclusion&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h2 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a>依赖传递</h2><p>依赖具有传递性，分两种</p><ol><li>直接依赖：在当前项目中通过依赖配置建立的依赖关系</li><li>间接依赖：被依赖的资源如果依赖其他资源，则表明当前项目间接依赖其他资源</li></ol><blockquote><p>依赖别人刷新后自己肯定能看见改变</p><p>别人依赖自己，自己是不知道的</p></blockquote><h3 id="依赖传递冲突"><a href="#依赖传递冲突" class="headerlink" title="依赖传递冲突"></a>依赖传递冲突</h3><p>在依赖传递过程中产生了冲突，我们有三种优先法则</p><ol><li>路径优先：当依赖中出现相同资源时，越靠近当前项目，优先度越高</li><li>声明优先：当资源在<strong>相同度数</strong>被依赖时，按顺序加载，先加载的生效</li><li>特殊优先：当<strong>相同配置文件</strong>配置了相同资源的不同版本时，后配置的覆盖先配置的</li></ol><p>这东西没记的意义，开发里面最终要调到能用为止</p><p>以一个项目为根，直接依赖称为1度资源，直接依赖的直接依赖称为2度资源，直接依赖的直接依赖的直接依赖称为3度资源。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309121927528.png"></p><h2 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h2><p>依赖的jar默认情况可以在任何地方可用，可以通过scope标签设定其作用范围</p><p>这里的范围主要是指以下四种范围，用&lt; scope&gt;指明范围</p><ol><li>compile：主程序范围有效（src&#x2F;main目录范围内），不用写，这个项目在编译，测试，运行阶段都需要这个jar包在classpath中。</li><li>test：测试程序范围内有效（src&#x2F;test目录范围内）作用在测试时，不作用在运行时。 只在测试时使用，用于编译和运行测试代码。不会随项目发布。</li><li>provided：是否参与打包（package指令范围内），可以认为这个provided是目标容器已经provide这个jar，在运行阶段，假定目标的容器（比如我们这里的tomcat容器）已经提供了这个jar包，app可以直接使用容器提供的jar，所以无需我们打包对应的jar包了。</li><li>runtime：表示dependency不作用在编译时，但会作用在运行和测试时，如JDBC驱动，适用运行和测试阶段</li></ol><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309121932057.png"></p><h1 id="Maven生命周期与插件"><a href="#Maven生命周期与插件" class="headerlink" title="Maven生命周期与插件"></a>Maven生命周期与插件</h1><p>Maven对项目构建的生命周期大体划分为3套</p><ol><li>clear：清理工作</li><li>default：核心工作，例如编译、测试、打包、部署等</li><li>site：产生报告、发布站点等</li></ol><h2 id="clear生命周期"><a href="#clear生命周期" class="headerlink" title="clear生命周期"></a>clear生命周期</h2><p>clean：清理工作</p><ul><li>pre-clean：执行一些在clean之前的工作</li><li>clean：移除上一次构建产生的所有文件</li><li>post-clean：执行一些在clean之后立刻完成的工作</li></ul><h2 id="default生命周期"><a href="#default生命周期" class="headerlink" title="default生命周期"></a>default生命周期</h2><p>default：核心工作，例如编译，测试，打包，部署等</p><p><strong>对于default生命周期，每个事件在执行之前都会将之前的所有事件依次执行一遍</strong></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20230912193439258.png" alt="image-20230912193439258"></p><h2 id="site生命周期"><a href="#site生命周期" class="headerlink" title="site生命周期"></a>site生命周期</h2><ul><li>site：产生报告，发布站点等</li><li>pre-site：执行一些在生成站点文档之前的工作</li><li>site：生成项目的站点文档</li><li>post-site：执行一些在生成站点文档之后完成的工作，为部署做准备</li><li>site-deploy：将生成的站点文档部署到特定的服务器上</li></ul><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>生命周期是阶段，创建是为了支持生命周期而做的行为</p><ul><li>插件与生命周期内的阶段绑定，在执行到对应生命周期时执行对应的插件</li><li>maven默认在各个生命周期上都绑定了预先设定的插件来完成相应功能</li><li>插件还可以完成一些自定义功能</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.2.1&lt;/version&gt;</span><br><span class="line">            &lt;executions&gt;</span><br><span class="line">                &lt;excution&gt;</span><br><span class="line">                    &lt;goals&gt;</span><br><span class="line">                        &lt;!--当goal属性的值为test-jar时，是对测试代码打包--&gt;</span><br><span class="line">                        &lt;goal&gt;jar&lt;/goal&gt;</span><br><span class="line">                    &lt;/goals&gt;</span><br><span class="line">                    &lt;phase&gt;generate-test-resources&lt;/phase&gt;</span><br><span class="line">                &lt;/excution&gt;</span><br><span class="line">            &lt;/executions&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p>如果配置成功，在IDEA右侧<code>maven-project</code>操作面板上可以看到</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309121941120.png"></p><hr><blockquote><p>没有接触过spring开发方不建议现在这部分</p></blockquote><hr><h1 id="分模块开发"><a href="#分模块开发" class="headerlink" title="分模块开发"></a>分模块开发</h1><ol><li>按照功能拆分<ul><li>我们之前的项目都是在一个模块中，这样做，虽然功能也都实现了，但是也存在一些问题，我们拿银行举例<ul><li>网络没有那么发达的时候，我们需要到银行柜台或者取款机进行业务操作</li><li>随着互联网的发展，我们有了电脑之后，就可以在网页上登录银行网站使用U盾进行业务操作</li><li>再来就是随着智能手机的普及，我们只需要用手机登录App就可以进行业务操作</li></ul></li><li>上面三个场景出现的时间轴是不同的，如果非要把三个场景的模块代码放到同一个项目，那么当其中某一个模块代码出现问题，就会导致整个项目都无法正常启动，从而导致银行的多个业务都无法正常办理，所以我们会<code>按照功能</code>将项目进行拆分</li></ul></li><li>按照模块拆分<ul><li>比如电商项目中，有订单和商品两个模块，订单中需要包含商品的详细信息，所以需要商品的模型类，商品模块也会用到商品的模型类，这个时候如果两个模块中都写模型类，就会出现重复代码，后期维护的成本就比较高。</li><li>我们能把公共的部分抽取成一个独立的模块，其他模块想要使用就可以像<code>导入第三方依赖的坐标</code>一样来使用我们自己抽取的模块，这样就解决了代码重复的问题，这种拆分方式就是我们所说的<code>按照模块</code>拆分</li></ul></li></ol><p>之前的项目包结构如下：</p><ul><li><code>com.blog.config</code>目录存放的是相关的配置类</li><li><code>com.blog.controller</code>编写的是Controller类</li><li><code>com.blog.dao</code>存放的是Dao接口，因为使用的是Mapper接口代理方式，所以没有实现类包</li><li><code>com.blog.service</code>存的是Service接口，<code>com.blog.service.impl</code>存放的是Service实现类</li></ul><p>那我们现在就可以把这些包按照功能拆分成若干个子模块，方便模块之间的相互调用，接口供销，这样的话，项目中的每一层都可以单独维护，也可以很方便的被别人使用。</p><h1 id="聚合与继承"><a href="#聚合与继承" class="headerlink" title="聚合与继承"></a>聚合与继承</h1><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>在前面，我们把项目进行拆分，项目由一个变成了多个，相应会有一些问题</p><h3 id="多模块维护"><a href="#多模块维护" class="headerlink" title="多模块维护"></a>多模块维护</h3><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310241039145.png"></p><ol><li>分模块开发后，需要将这四个项目都安装到本地仓库，如果我们的项目足够多，那一个个install也挺麻烦的</li><li>四个项目互相依赖，有一个改变后其他几个也要相应修改，而且其他模块在运行前夜不知道有模块被修改</li></ol><p>所以，这些模块最好视为一个集体，一起更新，把他们组成一个集合</p><ul><li>聚合：将多个模块组织成一个整体，同时进行项目构建的过程称为聚合</li><li>聚合工程：通常是一个不具有业务功能的<code>空</code>工程</li><li>作用：使用聚合工程可以将多个工程编组，通过对聚合工程的构建，实现对所包含的所有模块进行同步构建</li></ul><blockquote><p>当工程中某个模块发生更新后，必须保障工程中与更新模块关联的模块同步更新，此时就可以使用聚合工程来解决批量模块同步构建的问题</p></blockquote><p>实现步骤：</p><ol><li><p>创建一个空的maven项目，将项目打包方式改为<code>pom</code></p><p>项目的打包方式，我们接触到的有三种，分别是</p><ol><li>jar:默认情况，说明该项目为java项目</li><li>war:说明该项目为web项目</li><li>pom:说明该项目为聚合或继承项目</li></ol></li><li><p>pom.xml添加所要管理的项目</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.blog<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_00_parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--设置打包方式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--设置管理的项目名称--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>../maven_01_ssm<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>../maven_02_pojo<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>../maven_03_dao<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用聚合统一管理项目</p><p>在maven面板上点击compile，会发现所有受管理的项目都会被执行编译，这就是聚合工程的作用</p></li></ol><p>聚合工程管理的项目在进行运行的时候，会按照项目与项目之间的依赖关系来自动决定执行的顺序和配置的顺序无关。虽然我们配置的顺序是<code>123</code>，但是执行的时候按照依赖关系编译是<code>231</code></p><blockquote><p>将每个项目当做资源，没有前置资源的最优先，然后是当前资源能够满足的项目，直到完成</p></blockquote><p>最后总结一句话就是，<strong>聚合工程主要是用来管理项目</strong>。就像超市买东西，最后再<strong>买</strong>个袋子打包</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul><li>所谓继承：描述的是两个工程间的关系，与java中的继承类似，子工程可以继承父工程中的配置信息，常见于依赖关系的继承</li><li>作用：<ul><li>简化配置</li><li>减少版本冲突</li></ul></li></ul><p>实现步骤：</p><ol><li><p>创建父工程，打包方式设置为pom</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC-共享模型</title>
      <link href="/2023/08/12/JUC%E4%B8%AD%E7%AF%87/"/>
      <url>/2023/08/12/JUC%E4%B8%AD%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="共享模型之内存"><a href="#共享模型之内存" class="headerlink" title="共享模型之内存"></a>共享模型之内存</h1><p>上一章讲解的Monitor主要关注的是访问共享变量时，保证临界区代码的原子性</p><p>这一章我们进一步深入学习共享变量在多线程间的<strong>可见性</strong>问题与多条指令执行时的<strong>有序性</strong>问题</p><h2 id="Java-内存模型（JMM）"><a href="#Java-内存模型（JMM）" class="headerlink" title="Java 内存模型（JMM）"></a>Java 内存模型（JMM）</h2><p>JMM 即 Java Memory Model，它定义了主存（共享内存）、工作内存（线程私有）抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、 CPU 指令优化等。</p><ul><li>主内存：计算机的内存，也就是经常提到的 8G 内存，16G 内存，存储所有共享变量的值</li><li>工作内存：存储该线程使用到的共享变量在主内存的的值的副本拷贝</li></ul><blockquote><p><strong>JVM 和 JMM 之间的关系</strong>：JMM 中的主内存、工作内存与 JVM 中的 Java 堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的</p></blockquote><p>JMM 体现在以下几个方面</p><ul><li>原子性 - 保证指令不会受到线程上下文切换的影响</li><li>可见性 - 保证指令不会受 cpu 缓存的影响</li><li>有序性 - 保证指令不会受 cpu 指令并行优化的影响</li></ul><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><h4 id="退不出的循环"><a href="#退不出的循环" class="headerlink" title="退不出的循环"></a>退不出的循环</h4><p>首先看一段代码：</p><p>public static boolean run &#x3D; true;</p><pre><code>public static void main(String[] args) &#123;    Thread t1 = new Thread(() -&gt; &#123;        while(run) &#123;        &#125;    &#125;, &quot;t1&quot;);    t1.start();    try &#123;        Thread.sleep(1000);    &#125; catch (InterruptedException e) &#123;        e.printStackTrace();    &#125;    log.info(&quot;t1 Stop&quot;);    run = false;&#125;</code></pre><p>首先 t1 线程运行，然后过一秒，主线程设置 run 的值为 false，想让 t1 线程停止下来，但是 t1 线程并没有停，分析如下图：<img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20210202131314474.png"></p><ol><li>初始状态，t 线程刚开始从主内存读取了run的值到工作内存。</li><li>因为t线程要频繁从主内存中读取run的值，JIT 编译器会将run的值缓存至自己工作内存中的高速缓存中，减少对主存中run的访问，提高效率</li><li>1秒之后，main线程修改了run的值，并同步至主存，而t是从自己工作内存中的高速缓存中读取这个变<br>量的值，结果永远是B值</li></ol><blockquote></blockquote><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ul><li>使用 volatile （易变关键字）</li><li>volatile 可以用来修饰成员变量和静态成员变量（放在主存中的变量），他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存</li></ul><h3 id="可见性与原子性"><a href="#可见性与原子性" class="headerlink" title="可见性与原子性"></a>可见性与原子性</h3><p>上面例子体现的实际就是可见性，它保证的是在多个线程之间，一个线程对volatile 变量的修改对另一个线程可见， 不能保证原子性，仅用在一个写线程，多个读线程的情况。</p><p>字节码</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li><p>synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是synchronized 是属于重量级操作，性能相对更低。</p></li><li><p>如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到对 run 变量的修改了，想一想为什么？</p><p>因为 printIn() 方法使用了 synchronized 同步代码块，可以保证原子性与可见性，它是 PrintStream 类的方法。</p></li></ul><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><h4 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h4><p>首先看一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 可以重排的例子 </span><br><span class="line">int a = 10; </span><br><span class="line">int b = 20; </span><br><span class="line">System.out.println( a + b );</span><br><span class="line"></span><br><span class="line">// 不能重排的例子 </span><br><span class="line">int a = 10;</span><br><span class="line">int b = a - 5;</span><br></pre></td></tr></table></figure><p>指令重排简单来说可以，在程序结果不受影响的前提下，可以调整指令语句执行顺序。多线程下指令重排会影响正确性。</p><h4 id="多线程下指令重排问题"><a href="#多线程下指令重排问题" class="headerlink" title="多线程下指令重排问题"></a>多线程下指令重排问题</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int num = 0;</span><br><span class="line"></span><br><span class="line">// volatile 修饰的变量，可以禁用指令重排 volatile boolean ready = false; 可以防止变量之前的代码被重排序</span><br><span class="line">boolean ready = false; </span><br><span class="line">// 线程1 执行此方法</span><br><span class="line">public void actor1(I_Result r) &#123;</span><br><span class="line"> if(ready) &#123;</span><br><span class="line"> r.r1 = num + num;</span><br><span class="line"> &#125; </span><br><span class="line"> else &#123;</span><br><span class="line"> r.r1 = 1;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 线程2 执行此方法</span><br><span class="line">public void actor2(I_Result r) &#123;</span><br><span class="line"> num = 2;</span><br><span class="line"> ready = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在多线程环境下，以上的代码 r1 的值有三种情况：</p><ol><li>线程 2 先执行，然后线程 1 后执行，r1 的结果为 4</li><li>线程 1 先执行，然后线程 2 后执行，r1 的结果为 1</li><li>线程 2 先执行，但是发送了指令重排，num &#x3D; 2 与 ready &#x3D; true 这两行代码语序发生装换，然后执行 ready &#x3D; true 后，线程 1 运行了，那么 r1 的结果是为 0。</li></ol><blockquote><p>volatile 修饰的变量，可以禁用指令重排，禁止的是加 volatile 关键字变量<strong>之前的代码</strong>重排序</p></blockquote><h4 id="原理之-volatile"><a href="#原理之-volatile" class="headerlink" title="原理之 volatile"></a>原理之 volatile</h4><p>volatile 的底层实现原理是内存屏障，Memory Barrier（Memory Fence）</p><ul><li>对 volatile 变量的写指令后会加入写屏障</li><li>对 volatile 变量的读指令前会加入读屏障</li></ul><h5 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h5><ul><li><p>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void actor2(I_Result r) &#123;</span><br><span class="line">    num = 2;</span><br><span class="line">    ready = true; // ready 是 volatile 赋值带写屏障</span><br><span class="line">    // 写屏障</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void actor1(I_Result r) &#123;</span><br><span class="line">    // 读屏障</span><br><span class="line">    // ready 是 volatile 读取值带读屏障</span><br><span class="line">    if(ready) &#123;</span><br><span class="line">        r.r1 = num + num;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        r.r1 = 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231107101828845.png" alt="image-20231107101828845"></p><h5 id="如何保证有序性"><a href="#如何保证有序性" class="headerlink" title="如何保证有序性"></a>如何保证有序性</h5><ul><li><p>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void actor2(I_Result r) &#123;</span><br><span class="line">    num = 2;</span><br><span class="line">    ready = true; // ready 是 volatile 赋值带写屏障</span><br><span class="line">    // 写屏障</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void actor1(I_Result r) &#123;</span><br><span class="line">    // 读屏障</span><br><span class="line">    // ready 是 volatile 读取值带读屏障</span><br><span class="line">    if(ready) &#123;</span><br><span class="line">        r.r1 = num + num;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        r.r1 = 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JUC-进程基础</title>
      <link href="/2023/08/04/JUC%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/08/04/JUC%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="进程与进程"><a href="#进程与进程" class="headerlink" title="进程与进程"></a>进程与进程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ul><li>程序由指令和数据组成，但是这些指令要运行， 数据要读写，就必须将指令加载到cpu，数据加载至内存。在指令运行过程中还需要用到磁盘，网络等设备，进程就是用来加载指令管理内存管理IO的</li><li>当一个指令被运行，从磁盘加载这个程序的代码到内存，这时候就开启了一个进程</li><li>进程就可以视为程序的一个实例，大部分程序都可以运行多个实例进程（例如记事本，浏览器等），部分只可以运行一个实例进程（例如360安全卫士）</li></ul><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul><li>一个进程之内可以分为一到多个线程。</li><li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行</li><li>Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作 为线程的容器（这里感觉要学了计算机组成原理之后会更有感觉吧！）</li></ul><h2 id="二者对比"><a href="#二者对比" class="headerlink" title="二者对比"></a>二者对比</h2><ul><li>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集</li><li>进程拥有共享的资源，如内存空间等，供其内部的线程共享</li><li>进程间通信较为复杂<ul><li>同一台计算机的进程通信称为 IPC（Inter-process communication）</li><li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP</li></ul></li><li>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量</li><li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</li></ul><h1 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h1><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>在单核 cpu 下，线程实际还是串行执行的。操作系统中有一个组件叫做任务调度器，将 cpu 的时间片（windows 下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于 cpu 在线程间（时间片很短）的切换非常快，人类感 觉是同时运行的 。一般会将这种线程轮流使用 CPU 的做法称为并发（concurrent）</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231104220315117.png" alt="image-20231104220315117"></p><h2 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h2><p>多核 cpu下，每个核（core） 都可以调度运行线程，这时候线程可以是并行的，不同的线程同时使用不同的cpu在执行。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231104220315117.png"></p><h2 id="二者对比-1"><a href="#二者对比-1" class="headerlink" title="二者对比"></a>二者对比</h2><p>引用 Rob Pike 的一段描述：并发（concurrent）是同一时间应对（dealing with）多件事情的能力，并行（parallel）是同一时间动手做（doing）多件事情的能力</p><ul><li>家庭主妇做饭、打扫卫生、给孩子喂奶，她一个人轮流交替做这多件事，这时就是并发</li><li>雇了3个保姆，一个专做饭、一个专打扫卫生、一个专喂奶，互不干扰，这时是并行</li><li>家庭主妇雇了个保姆，她们一起这些事，这时既有并发，也有并行（这时会产生竞争，例如锅只有一口，一 个人用锅时，另一个人就得等待）</li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="同步和异步的概念"><a href="#同步和异步的概念" class="headerlink" title="同步和异步的概念"></a>同步和异步的概念</h3><p>以调用方的角度讲，如果</p><ul><li>需要等待结果返回才能继续运行的话就是同步</li><li>不需要等待就是异步</li></ul><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>多线程可以使方法的执行变成异步的，比如说读取磁盘文件时，假设读取操作花费了5秒，如果没有线程的调度机制，这么cpu只能等5秒，啥都不能做。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程</li><li>tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞 tomcat 的工作线程</li><li>ui 程序中，开线程进行其他操作，避免阻塞 ui 线程</li></ul><h1 id="java线程"><a href="#java线程" class="headerlink" title="java线程"></a>java线程</h1><h2 id="创建和运行线程"><a href="#创建和运行线程" class="headerlink" title="创建和运行线程"></a>创建和运行线程</h2><div class="tabs" id="1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#1-1">Thread</button></li><li class="tab"><button type="button" data-href="#1-2">Runnable 配合 Thread</button></li><li class="tab"><button type="button" data-href="#1-3">FutureTask配合Thread</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 构造方法的参数是给线程指定名字，，推荐给线程起个名字</span><br><span class="line">Thread t1 = new Thread(&quot;t1&quot;) &#123;</span><br><span class="line"> @Override</span><br><span class="line"> // run 方法内实现了要执行的任务</span><br><span class="line"> public void run() &#123;</span><br><span class="line"> log.debug(&quot;hello&quot;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-2"><p>把线程和任务分开，Thread 代表线程，Runnable 可运行的任务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 创建任务对象</span><br><span class="line">Runnable task2 = new Runnable() &#123;</span><br><span class="line"> @Override</span><br><span class="line"> public void run() &#123;</span><br><span class="line"> log.debug(&quot;hello&quot;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 参数1 是任务对象; 参数2 是线程名字，推荐给线程起个名字</span><br><span class="line">Thread t2 = new Thread(task2, &quot;t2&quot;);</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure><p>把线程和任务分开了，用 Runnable 更容易与线程池等高级 API 配合，用 Runnable 让任务类脱离了 Thread 继承体系，更灵活。通过查看源码可以发现，方法二其实到底还是通过方法一执行的！</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-3"><p>FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况</p><pre><code>public static void main(String[] args) throws ExecutionException, InterruptedException {    // 实现多线程的第三种方法可以返回数据    FutureTask futureTask = new FutureTask&lt;&gt;(new Callable&lt;Integer&gt;() {        @Override        public Integer call() throws Exception {            log.debug(&quot;多线程任务&quot;);            Thread.sleep(100);            return 100;        }    });    // 主线程阻塞，同步等待 task 执行完毕的结果    new Thread(futureTask,&quot;我的名字&quot;).start();    log.debug(&quot;主线程&quot;);    log.debug(&quot;{}&quot;,futureTask.get());}</code></pre><p>Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface Future&lt;V&gt; &#123;</span><br><span class="line">    boolean cancel(boolean mayInterruptIfRunning);</span><br><span class="line">    boolean isCancelled();</span><br><span class="line">    boolean isDone();</span><br><span class="line">    V get() throws InterruptedException, ExecutionException;</span><br><span class="line">    V get(long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Future提供了三种功能：</p><ol><li>判断任务是否完成；</li><li>能够中断任务；</li><li>能够获取任务执行结果。</li></ol><p><a href="https://mp.weixin.qq.com/s/RX5rVuGr6Ab0SmKigmZEag">FutureTask是Future和Runable的实现</a></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="查看进程的方法"><a href="#查看进程的方法" class="headerlink" title="查看进程的方法"></a>查看进程的方法</h2><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><ul><li>任务管理器可以查看进程和线程数，也可以用来杀死进程</li><li>tasklist 查看进程</li><li>taskkill 杀死进程</li></ul><h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><ul><li>ps -fe 查看所有进程</li><li>ps -fT -p 查看某个进程（PID）的所有线程</li><li>kill 杀死进程</li><li>top 按大写 H 切换是否显示线程</li><li>top -H -p 查看某个进程（PID）的所有线程</li></ul><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><ul><li>ps 命令查看所有 Java 进程</li><li>jstack 查看某个 Java 进程（PID）的所有线程状态</li><li>jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</li></ul><h1 id="线程运行原理"><a href="#线程运行原理" class="headerlink" title="线程运行原理"></a>线程运行原理</h1><h2 id="虚拟机栈与栈帧"><a href="#虚拟机栈与栈帧" class="headerlink" title="虚拟机栈与栈帧"></a>虚拟机栈与栈帧</h2><p>虚拟机栈描述的是Java方法执行的内存模型.</p><p>每个方法被执行的时候都会同时创建一个栈帧(stack frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息，是属于线程的私有的。</p><p>当java中使用多线程时，每个线程都会维护它自己的栈帧！每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202311042044622.png"></p><h2 id="线程上下文切换（Thread-Context-Switch）"><a href="#线程上下文切换（Thread-Context-Switch）" class="headerlink" title="线程上下文切换（Thread Context Switch）"></a>线程上下文切换（Thread Context Switch）</h2><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p><ul><li>线程的 cpu 时间片用完(每个线程轮流执行，看前面并行的概念)</li><li>垃圾回收</li><li>有更高优先级的线程需要运行</li><li>线程自己调用了 <code>sleep</code>、<code>yield</code>、<code>wait</code>、<code>join</code>、<code>park</code>、<code>synchronized</code>、<code>lock</code> 等方法</li></ul><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念 就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</p><ul><li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li><li>Context Swich频繁发生会影响性能</li></ul><h1 id="Thread的常见方法"><a href="#Thread的常见方法" class="headerlink" title="Thread的常见方法"></a>Thread的常见方法</h1><table><thead><tr><th>方法名</th><th>static</th><th>功能说明</th></tr></thead><tbody><tr><td>start()</td><td>否</td><td>启动一个新线程，在新的线程运行run方法中的代码。<br>start方法只是让线程进入就绪，里面的代码不一定立刻运行（CUP的时间片还没有分给他）。每个线程对象的start方法只能调用一次，如果调用多次会出现illegalThreadStateException</td></tr><tr><td>run()</td><td>否</td><td>新线程启用后会调用的方法<br>如果在构造Thread对象时传递了Runnable参数，则线程启动后调用Runnable中的run方法，否则默认不执行任何操作。但可以穿件Thread的子类对象，来覆盖默认行为</td></tr><tr><td>join()</td><td>否</td><td>等待线程运行结束</td></tr><tr><td>join(long n)</td><td>否</td><td>等待线程运行结束，最多等待n毫秒</td></tr><tr><td>getId()</td><td>否</td><td>获取线程长整型的id。<br>id唯一</td></tr><tr><td>getName()</td><td>否</td><td>获取线程名</td></tr><tr><td>setName(String)</td><td>否</td><td>修改线程名</td></tr><tr><td>getPriority()</td><td>否</td><td>获取线程优先级</td></tr><tr><td>getPriority(int)</td><td>否</td><td>修改线程优先级<br>java中规定优先级是1~10的整数，比较大优先级能提高该线程被CPU调用的几率</td></tr><tr><td>getState()</td><td>否</td><td>获取线程状态<br> Java 中线程状态是用 6 个 enum 表示，分别为： NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED</td></tr><tr><td>isInterrupted()</td><td>否</td><td>判断是否被打断，不会清除 “打断标记”</td></tr><tr><td>isAlive()</td><td>否</td><td>线程是否存活 （还没有运行完 毕）</td></tr><tr><td>interrupt()</td><td>否</td><td>打断线程<br>如果被打断线程正在 sleep，wait，join 会导致被打断 的线程抛出 InterruptedException，并清除 打断标 记 ；如果打断的正在运行的线程，则会设置 打断标 记 ；park 的线程被打断，也会设置 打断标记</td></tr><tr><td>interrupted()</td><td>static</td><td>判断当前线程是 否被打断<br>会清除 打断标记</td></tr><tr><td>currentThread()</td><td>static</td><td>获取当前正在执 行的线程</td></tr><tr><td>sleep(long n)</td><td>static</td><td>让当前执行的线 程休眠n毫秒， 休眠时让出 cpu 的时间片给其它 线程</td></tr><tr><td>yield()</td><td>static</td><td>提示线程调度器 让出当前线程对 CPU的使用<br>主要是为了测试和调试</td></tr></tbody></table><h2 id="start-与-run"><a href="#start-与-run" class="headerlink" title="start 与 run"></a>start 与 run</h2><h4 id="调用start（能不能运行任务调度器说了算）"><a href="#调用start（能不能运行任务调度器说了算）" class="headerlink" title="调用start（能不能运行任务调度器说了算）"></a>调用start（能不能运行任务调度器说了算）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;我是一个新建的线程正在运行中&quot;</span>);</span><br><span class="line">            FileReader.read(fileName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    thread.setName(<span class="string">&quot;新建线程&quot;</span>);</span><br><span class="line">    thread.start();</span><br><span class="line">    log.debug(<span class="string">&quot;主线程&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：程序在 t1 线程运行， <code>run()</code>方法里面内容的调用是异步的 Test4.java</p><h4 id="调用run"><a href="#调用run" class="headerlink" title="调用run"></a>调用run</h4><p>将上面代码的<code>thread.start();</code>改为 <code>thread.run();</code>程序仍在 <strong>main 线程</strong>运行， <code>run()</code>方法里面内容的调用还是同步的</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>直接调用 <code>run()</code> 是在主线程中执行了 <code>run()</code>，没有启动新的线程 使用 <code>start()</code> 是启动新的线程，通过新的线程间接执行 <code>run()</code>方法 中的代码</p><p>当调用start方法后，线程状态会由“NEW”变为“RUNABLE”，此时再次调用start方法会报错 IllegalThreadStateException（非法的状态异常）</p><h2 id="sleep-与-yield"><a href="#sleep-与-yield" class="headerlink" title="sleep 与 yield"></a>sleep 与 yield</h2><h4 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h4><ol><li>调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞）</li><li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，那么被打断的线程这时就会抛出 <code>InterruptedException</code>异常【注意：这里打断的是正在休眠的线程，而不是其它状态的线程】</li><li>睡眠结束后的线程未必会立刻得到执行(需要分配到cpu时间片)</li><li>建议用 TimeUnit 的 <code>sleep()</code> 代替 Thread 的 <code>sleep()</code>来获得更好的可读性</li></ol><h4 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h4><ol><li>调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程</li><li>具体的实现依赖于操作系统的任务调度器(就是可能没有其它的线程正在执行，虽然调用了yield方法，但是也没有用)</li></ol><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>yield使cpu调用其它线程，但是cpu可能会再分配时间片给该线 ；而sleep需要等过了休眠时间之后才有可能被分配cpu时间片</p><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它 如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</p><h1 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h1><p>默认情况下，java进程需要等待所有的线程结束后才会停止，但是有一种特殊的线程，叫做守护线程，在其他线程全部结束的时候即使守护线程还未结束代码未执行完java进程也会停止。普通线程t1可以调用<code>t1.setDeamon(true);</code> 方法变成守护线程</p><blockquote><p>注意 垃圾回收器线程就是一种守护线程 Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等 待它们处理完当前请求</p></blockquote><h2 id="线程状态之五种状态"><a href="#线程状态之五种状态" class="headerlink" title="线程状态之五种状态"></a>线程状态之五种状态</h2><p>五种状态的划分主要是从操作系统的层面进行划分的</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202311042114047.png"></p><ol><li>初始状态，仅仅是在语言层面上创建了线程对象，即<code>Thead thread = new Thead();</code>，还未与操作系统线程关联</li><li>可运行状态，也称就绪状态，指该线程已经被创建，与操作系统相关联，等待cpu给它分配时间片就可运行</li><li>运行状态，指线程获取了CPU时间片，正在运行<ul><li>当CPU时间片用完，线程会转换至可运行状态，等待 CPU再次分配时间片，会导致我们前面讲到的上下文切换</li></ul></li><li>阻塞状态<ul><li>如果调用了阻塞API，如BIO读写文件，那么线程实际上不会用到CPU，不会分配CPU时间片，会导致上下文切换，进入阻塞状态</li><li>等待BIO操作完毕，会由操作系统唤醒阻塞的线程，转换至可运行状态</li><li>与可运行状态的区别是，只要操作系统一直不唤醒线程，调度器就一直不会考虑调度它们，CPU就一直不会分配时间片</li></ul></li><li>终止状态，表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</li></ol><h2 id="线程状态之六种状态"><a href="#线程状态之六种状态" class="headerlink" title="线程状态之六种状态"></a>线程状态之六种状态</h2><p>这是从 Java API 层面来描述的，这门课主要讲这种</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202311042116626.png"></p><ol><li>NEW 跟五种状态里的初始状态是一个意思</li><li>RUNNABLE 是当调用了 <code>start()</code> 方法之后的状态，注意，Java API 层面的 <code>RUNNABLE</code> 状态涵盖了操作系统层面的可运行状态、运行状态和io阻塞状态（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为是可运行）</li><li><code>BLOCKED</code> ， <code>WAITING</code> ， <code>TIMED_WAITING</code> 都是 Java API 层面对阻塞状态的细分</li><li>TERMINATED</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JUC-共享模型</title>
      <link href="/2023/08/02/JUC%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B/"/>
      <url>/2023/08/02/JUC%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="线程问题"><a href="#线程问题" class="headerlink" title="线程问题"></a>线程问题</h1><p>线程出现问题的根本原因是因为线程上下文切换，导致线程里的指令没有执行完就切换执行其它线程了，下面是一个经典例子</p><pre><code>static int count = 0;public static void main(String[] args) throws InterruptedException &#123;    Thread t1 = new Thread(()-&gt;&#123;        for (int i = 1;i&lt;5000;i++)&#123;            count++;        &#125;    &#125;);    Thread t2 =new Thread(()-&gt;&#123;        for (int i = 1;i&lt;5000;i++)&#123;            count--;        &#125;    &#125;);    t1.start();    t2.start();    t1.join();    t2.join();    log.debug(&quot;count的值是&#123;&#125;&quot;,count);&#125;</code></pre><p>++和– 的字节码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">getstatic i // 获取静态变量i的值</span><br><span class="line">iconst_1 // 准备常量1</span><br><span class="line">iadd // 自增</span><br><span class="line">putstatic i // 将修改后的值存入静态变量i</span><br><span class="line">    </span><br><span class="line">getstatic i // 获取静态变量i的值</span><br><span class="line">iconst_1 // 准备常量1</span><br><span class="line">isub // 自减</span><br><span class="line">putstatic i // 将修改后的值存入静态变量i</span><br></pre></td></tr></table></figure><p>可以看到<code>count++</code> 和 <code>count--</code> 操作实际都是需要这个4个指令完成的，那么这里问题就来了！Java 的内存模型如下，完成静态变量的自增，自减需要在主存和工作内存中进行数据交换，如果代码是正常按顺序运行的，那么count的值不会计算错</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202206261903116.png" alt="img"></p><div class="tabs" id="1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#1-1">正常顺序</button></li><li class="tab"><button type="button" data-href="#1-2">出现负数</button></li><li class="tab"><button type="button" data-href="#1-3">出现正数</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202206261903878.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-2"><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202206261903246.png" alt="1583569380639"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-3"><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202206261903410.png" alt="1583569416016"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="临界区和竞态条件"><a href="#临界区和竞态条件" class="headerlink" title="临界区和竞态条件"></a>临界区和竞态条件</h2><p>一个程序运行多线程本身是没有问题的问题出现在多个线程共享资源的时候</p><ol><li>多个线程同时对共享资源进行读操作本身也没有问题</li><li>问题出现在对共享资源同时进行读写操作时就有问题了</li></ol><p>临界区：一段代码内如果存在对共享资源的多线程读写操作，那么称这段代码为临界区</p><p>竞态条件：多个线程在临界区执行，那么由于代码指令的执行不确定而导致的结果问题，称为竞态条件</p><h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><p>为了避免临界区中的竞态条件发生，由多种手段可以达到，大致分2类</p><ol><li>阻塞式解决方案：synchronized ，Lock（都是互斥）</li><li>非阻塞式解决方案：原子变量</li></ol><p>现在讨论使用synchronized来进行解决，即俗称的<strong>对象锁</strong>，它采用互斥的方式让同一时刻至多只有一个线程持有对象锁，其他线程如果想获取这个锁就会阻塞住，这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换</p><blockquote><p>注意 虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的：</p><ul><li>互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区的代码</li><li>同步是由于线程执行的先后，顺序不同但是需要一个线程等待其它线程运行到某个点。</li></ul></blockquote><h2 id="synchronized语法"><a href="#synchronized语法" class="headerlink" title="synchronized语法"></a>synchronized语法</h2><ol><li><p>加在对象上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronized(对象) // 线程1获得锁， 那么线程2的状态是(blocked)</span><br><span class="line">&#123;</span><br><span class="line"> 临界区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>加在方法上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Test&#123;</span><br><span class="line">    public synchronized void test() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//等价于</span><br><span class="line">class Test&#123;</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> class Test&#123;</span><br><span class="line">     public synchronized static void test() &#123;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">// 等价于</span><br><span class="line"> class Test&#123;</span><br><span class="line">     public static void test() &#123;</span><br><span class="line">         synchronized(Test.class) &#123;</span><br><span class="line">    </span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ol><p>把上面的5000次++–上锁后，结果就一定正确了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static int counter = 0;</span><br><span class="line">static final Object room = new Object();</span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">     Thread t1 = new Thread(() -&gt; &#123;</span><br><span class="line">         for (int i = 0; i &lt; 5000; i++) &#123;</span><br><span class="line">             synchronized (room) &#123;</span><br><span class="line">             counter++;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;, &quot;t1&quot;);</span><br><span class="line">     Thread t2 = new Thread(() -&gt; &#123;</span><br><span class="line">         for (int i = 0; i &lt; 5000; i++) &#123;</span><br><span class="line">             synchronized (room) &#123;</span><br><span class="line">             counter--;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     &#125;, &quot;t2&quot;);</span><br><span class="line">     t1.start();</span><br><span class="line">     t2.start();</span><br><span class="line">     t1.join();</span><br><span class="line">     t2.join();</span><br><span class="line">     log.debug(&quot;&#123;&#125;&quot;,counter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上方代码，synchronized加在了循环体内，所以我们一共上了5000+5000次锁，但是加在循环外，就只上了2次锁</p><h2 id="synchronized原理"><a href="#synchronized原理" class="headerlink" title="synchronized原理"></a>synchronized原理</h2><p><strong>synchronized实际上利用对象保证了临界区代码的原子性，临界区内的代码在外界看来是不可分割的，不会被线程切换所打断</strong></p><p>你可以做这样的类比： </p><ul><li><code>synchronized(对象)</code> 中的对象，可以想象为一个房间（room），有唯一入口（门）房间只能一次进入一人进行计算，线程 t1，t2 想象成两个人 </li><li>当线程 t1 执行到 <code>synchronized(room)</code> 时就好比 t1 进入了这个房间，并锁住了门拿走了钥匙，在门内执行<code>count++</code> 代码 </li><li>这时候如果 t2 也运行到了 <code>synchronized(room)</code> 时，它发现门被锁住了，只能在门外等待，发生了上下文切换，阻塞住了 </li><li>这中间即使 t1 的 cpu 时间片不幸用完，被踢出了门外（不要错误理解为锁住了对象就能一直执行下去哦），这时门还是锁住的，t1 仍拿着钥匙，t2 线程还在阻塞状态进不来，只有下次轮到 t1 自己再次获得时间片时才能开门进入 </li><li>当 t1 执行完 <code>synchronized&#123;&#125;</code> 块内的代码，这时候才会从 obj 房间出来并解开门上的锁，唤醒 t2 线程把钥匙给他。t2 线程这时才可以进入 obj 房间，锁住了门拿上钥匙，执行它的 <code>count--</code> 代码.</li></ul><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202206261903104.png"></p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>synchronized 实际是用<strong>对象锁</strong>保证了<strong>临界区内代码的原子性</strong>，临界区内的代码对外是不可分割的，不会被线程切换所打断。 </p><p>为了加深理解，请思考下面的问题</p><ul><li>如果把 <code>synchronized(obj) </code>放在 for 循环的外面，如何理解？– 原子性 <ul><li>会对整个for循环进行加锁，只有当t2的for循环执行完成之后，t1才会继续执行</li></ul></li><li>如果 t1 <code>synchronized(obj1)</code> 而 t2 <code>synchronized(obj2)</code> 会怎样运作？– 锁对象 <ul><li>两个线程使用了不同的对象锁，仍然会出现被打断的现象</li></ul></li><li>如果 t1 <code>synchronized(obj)</code> 而 t2 没有加会怎么样？如何理解？– 锁对象<ul><li>和上面的问题类型，t1虽然能获得<strong>对象锁</strong>，但是t2执行时不会检测是否已经加锁，仍然会出现大段的现象</li></ul></li></ul><h2 id="线程八锁"><a href="#线程八锁" class="headerlink" title="线程八锁"></a>线程八锁</h2><p>线程八锁就是考察 synchronized 锁住的是哪个对象，直接百度搜索相关的实例</p><p>说明：主要关注锁住的对象是不是同一个</p><ul><li>锁住类对象，所有类的实例的方法都是安全的，类的所有实例都相当于同一把锁</li><li>锁住 this 对象，只有在当前实例对象的线程内是安全的，如果有多个实例就不安全</li></ul><ol><li><p>调用同一个对象，方法顺序随机</p><p>被synchronized修饰的方法，锁的对象是方法的调用者。因为两个方法的调用者是同一个，所以两个方法用的是同一个锁，先调用方法的先执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j(topic = &quot;c.Number&quot;)</span><br><span class="line">class Number&#123;</span><br><span class="line">    public synchronized void a() &#123;</span><br><span class="line">        log.debug(&quot;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized void b() &#123;</span><br><span class="line">        log.debug(&quot;2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Number n1 = new Number();</span><br><span class="line">    new Thread(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">    new Thread(()-&gt;&#123; n1.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用同一个对象，方法顺序随机</p><p>被synchronized修饰的方法，锁的对象是方法的调用者。因为两个方法的调用者是同一个，所以两个方法用的是同一个锁，先调用方法的先执行，第二个方法只有在第一个方法执行完释放锁之后才能执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j(topic = &quot;c.Number&quot;)</span><br><span class="line">class Number&#123;</span><br><span class="line">    public synchronized void a() &#123;</span><br><span class="line">        sleep(1);</span><br><span class="line">        log.debug(&quot;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized void b() &#123;</span><br><span class="line">        log.debug(&quot;2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Number n1 = new Number();</span><br><span class="line">    new Thread(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">    new Thread(()-&gt;&#123; n1.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>2个上锁，1个没有。没上的这个跟前面俩并发，上锁的两个并行</p><p>新增的方法没有被synchronized修饰，不是同步方法，不受锁的影响，所以不需要等待。其他线程共用了一把锁，所以还需要等待</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j(topic = &quot;c.Number&quot;)</span><br><span class="line">class Number&#123;</span><br><span class="line">    public synchronized void a() &#123;</span><br><span class="line">        sleep(1);</span><br><span class="line">        log.debug(&quot;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized void b() &#123;</span><br><span class="line">        log.debug(&quot;2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void c() &#123;</span><br><span class="line">        log.debug(&quot;3&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Number n1 = new Number();</span><br><span class="line">    new Thread(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">    new Thread(()-&gt;&#123; n1.b(); &#125;).start();</span><br><span class="line">    new Thread(()-&gt;&#123; n1.c(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建2个对象，但是这两个对象之间不互斥</p><p>被synchronized修饰的方法，锁的对象是方法的调用者。因为用了两个对象调用各自的方法，所以两个方法的调用者不是同一个，所以两个方法用的不是同一个锁，后调用的方法不需要等待先调用的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j(topic = &quot;c.Number&quot;)</span><br><span class="line">class Number&#123;</span><br><span class="line">    public synchronized void a() &#123;</span><br><span class="line">        sleep(1);</span><br><span class="line">        log.debug(&quot;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized void b() &#123;</span><br><span class="line">        log.debug(&quot;2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Number n1 = new Number();</span><br><span class="line">    Number n2 = new Number();</span><br><span class="line">    new Thread(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">    new Thread(()-&gt;&#123; n2.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>和4一样</p><p>被synchronized和static修饰的方法，锁的对象是类的class对象。仅仅被synchronized修饰的方法，锁的对象是方法的调用者。因为两个方法锁的对象不是同一个，所以两个方法用的不是同一个锁，后调用的方法不需要等待先调用的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j(topic = &quot;c.Number&quot;)</span><br><span class="line">class Number&#123;</span><br><span class="line">    public static synchronized void a() &#123;</span><br><span class="line">        sleep(1);</span><br><span class="line">        log.debug(&quot;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized void b() &#123;</span><br><span class="line">        log.debug(&quot;2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Number n1 = new Number();</span><br><span class="line">    new Thread(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">    new Thread(()-&gt;&#123; n1.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类方法上锁，实例化对象不重要</p><p>synchronized和static修饰的方法，锁的对象是类的class对象。因为两个同步方法都被static修饰了，所以两个方法用的是同一个锁，后调用的方法需要等待先调用的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j(topic = &quot;c.Number&quot;)</span><br><span class="line">class Number&#123;</span><br><span class="line">    public static synchronized void a() &#123;</span><br><span class="line">        sleep(1);</span><br><span class="line">        log.debug(&quot;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static synchronized void b() &#123;</span><br><span class="line">        log.debug(&quot;2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Number n1 = new Number();</span><br><span class="line">    new Thread(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">    new Thread(()-&gt;&#123; n1.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将两个方法中有Thread.sleep()的方法设置为static方法，另一个方法去掉static修饰，让两个线程用两个对象调用两个方法</p><p>被synchronized和static修饰的方法，锁的对象是类的class对象。仅仅被synchronized修饰的方法，锁的对象是方法的调用者。即便是用同一个对象调用两个方法，锁的对象也不是同一个，所以两个方法用的不是同一个锁，后调用的方法不需要等待先调用的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j(topic = &quot;c.Number&quot;)</span><br><span class="line">class Number&#123;</span><br><span class="line">    public static synchronized void a() &#123;</span><br><span class="line">        sleep(1);</span><br><span class="line">        log.debug(&quot;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized void b() &#123;</span><br><span class="line">        log.debug(&quot;2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Number n1 = new Number();</span><br><span class="line">    Number n2 = new Number();</span><br><span class="line">    new Thread(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">    new Thread(()-&gt;&#123; n2.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将两个方法均设置为static方法，并且让两个线程用同一个对象调用两个方法</p><p>被synchronized和static修饰的方法，锁的对象是类的class对象。因为两个同步方法都被static修饰了，即便用了两个不同的对象调用方法，两个方法用的还是同一个锁，后调用的方法需要等待先调用的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j(topic = &quot;c.Number&quot;)</span><br><span class="line">class Number&#123;</span><br><span class="line">    public static synchronized void a() &#123;</span><br><span class="line">        sleep(1);</span><br><span class="line">        log.debug(&quot;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static synchronized void b() &#123;</span><br><span class="line">        log.debug(&quot;2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Number n1 = new Number();</span><br><span class="line">    Number n2 = new Number();</span><br><span class="line">    new Thread(()-&gt;&#123; n1.a(); &#125;).start();</span><br><span class="line">    new Thread(()-&gt;&#123; n2.b(); &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="线程安全分析"><a href="#线程安全分析" class="headerlink" title="线程安全分析"></a>线程安全分析</h1><h2 id="成员变量和静态变量的线程安全分析"><a href="#成员变量和静态变量的线程安全分析" class="headerlink" title="成员变量和静态变量的线程安全分析"></a>成员变量和静态变量的线程安全分析</h2><ul><li>如果没有变量没有在线程间共享，那么变量是安全的</li><li>如果变量在线程间共享<ul><li>如果只有读操作，则线程安全</li><li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li></ul></li></ul><h2 id="局部变量线程安全分析"><a href="#局部变量线程安全分析" class="headerlink" title="局部变量线程安全分析"></a>局部变量线程安全分析</h2><ul><li>基本数据类型的局部变量是安全的</li><li>局部变量引用的对象未必是安全的<ul><li>如果局部变量引用的对象没有引用线程共享的对象，那么是线程安全的</li><li>如果局部变量引用的对象引用了一个线程共享的对象，那么要考虑线程安全的</li></ul></li></ul><h2 id="线程安全的情况"><a href="#线程安全的情况" class="headerlink" title="线程安全的情况"></a>线程安全的情况</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void test1() &#123;</span><br><span class="line">     int i = 10;</span><br><span class="line">     i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个线程调用 test1() 方法时局部变量 i，会在每个线程的栈帧内存中被创建多份，因此不存在共享</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202206261903715.png" alt="1583587166210"></p><h2 id="线程不安全的情况"><a href="#线程不安全的情况" class="headerlink" title="线程不安全的情况"></a>线程不安全的情况</h2><p>如果局部变量引用的对象逃离方法的范围，那么要考虑线程安全的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Test15 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        UnsafeTest unsafeTest = new UnsafeTest();</span><br><span class="line">        for (int i =0;i&lt;100;i++)&#123;</span><br><span class="line">            new Thread(()-&gt;&#123;</span><br><span class="line">                unsafeTest.method1();</span><br><span class="line">            &#125;,&quot;线程&quot;+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class UnsafeTest&#123;</span><br><span class="line">    ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;();</span><br><span class="line">    public void method1()&#123;</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            method2();</span><br><span class="line">            method3();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void method2() &#123;</span><br><span class="line">        arrayList.add(&quot;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private void method3() &#123;</span><br><span class="line">        arrayList.remove(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不安全原因分析：</p><p>上面案例中的ArrayList是非局部变量，无论哪个线程中的 method2 和method3 引用的都是同一个对象中的 list 成员变量：一个 ArrayList ，在添加一个元素的时候，它可能会有两步来完成：</p><ol><li>第一步，在 arrayList[Size] 的位置存放此元素； 第二步增大 Size 的值。</li><li>在<strong>单线程</strong>运行的情况下，如果 Size &#x3D; 0，添加一个元素后，此元素在位置 0，而且 Size&#x3D;1；</li><li>而如果是在<strong>多线程</strong>情下，比如有两个线程，线程 A 先将元素存放在位置 0。但是此时 CPU 调线程A暂停，线程 B 得到运行的机会。线程B也向此 ArrayList 添加元素，因为此时 Size 仍等于 0 （注意，假设的是添加一个元素是要两个步骤，而线程A仅仅完成了步骤1），所以线程B也将元素存放在位置0。然后线程A和线程B都继续运行，都增加 Size 的值。那好，现在我们来看看 ArrayList 的情况，元素实际上只有一个，存放在位置 0，而 Size 却等于 2。这就是<strong>线程不安全</strong></li></ol><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231105221111986.png" alt="image-20231105221111986"></p><p>解决方法：</p><p>可以将list修改成局部变量，这样每个线程都创建自己的 ArrayList，不会出现前面的情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class safeTest&#123;</span><br><span class="line">    public void method1()&#123;</span><br><span class="line">        ArrayList&lt;String&gt; arrayList = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">        method2(arrayList);</span><br><span class="line">        method3(arrayList);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void method2(ArrayList arrayList) &#123;</span><br><span class="line">        arrayList.add(&quot;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private void method3(ArrayList arrayList) &#123;</span><br><span class="line">        arrayList.remove(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="private-或-final的重要性"><a href="#private-或-final的重要性" class="headerlink" title="private 或 final的重要性"></a>private 或 final的重要性</h2><p>方法访问修饰符带来的思考，如果把 method2 和 method3 的方法修改为 public 会不会导致线程安全问题？</p><ol><li><p>有其它线程调用 method2 和 method3；</p></li><li><p>在1的基础上，为 ThreadSafe 类添加子类，子类覆盖 method2 或 method3 方法，即如下所示： 从这个例子可以看出 private 或 final 提供【安全】的意义所在，请体会开闭原则中的【闭】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class ThreadSafe &#123;</span><br><span class="line">    public final void method1(int loopNumber) &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            method2(list);</span><br><span class="line">            method3(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void method2(ArrayList&lt;String&gt; list) &#123;</span><br><span class="line">        list.add(&quot;1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private void method3(ArrayList&lt;String&gt; list) &#123;</span><br><span class="line">        list.remove(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class ThreadSafeSubClass extends ThreadSafe&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void method3(ArrayList&lt;String&gt; list) &#123;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            list.remove(0);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h2><ol><li>String</li><li>Integer</li><li>StringBuffer</li><li>Random</li><li>Vector</li><li>Hashtable</li><li>java.util.concurrent 包下的类</li></ol><p>这里说它们是线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的。也可以理解为它们的每个方法是原子的。但它们多个方法的组合不是原子的</p><h1 id="锁原理"><a href="#锁原理" class="headerlink" title="锁原理"></a>锁原理</h1><h2 id="Java-对象头"><a href="#Java-对象头" class="headerlink" title="Java 对象头"></a>Java 对象头</h2><p>以 32 位虚拟机为例,普通对象的对象头结构如下，其中的Klass Word为指针，指向对应的Class对象；</p><p>普通对象<img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202206261904173.png" alt="1583651065372"></p><p>数组对象：主要是多了个长度的属性<img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202206261904688.png" alt="1583651088663"></p><p>Mark Word<img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202206261904643.png" alt="1583651590160"></p><p>一个对象的结构如下</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202206261904168.png" alt="1583678624634"></p><ul><li>Object Head：对象头</li><li>Mark Word：没有锁的时候是 normal，根据不同情况会和偏向锁、轻量级锁、重量级锁交换内容</li><li>Klass Word：一个指针，指向对应的Class对象</li><li>hashcode：该对象的哈希码</li><li>age：年龄，GC时使用</li><li>biased_lock：表明是否使用偏向锁，另外2个锁直接交换Mark Word</li></ul><blockquote><p>题外话，int的大小是4B，而Interger的实例化对象有8（对象头）+4（大小）&#x3D;12B，所以内存不够的时候别用Interger</p></blockquote><h2 id="Monitor-原理"><a href="#Monitor-原理" class="headerlink" title="Monitor 原理"></a>Monitor 原理</h2><p>Monitor被翻译为监视器或者说管程</p><p>OS提供的，不是java的，jdk1.6以前上锁默认这个，1.6时为了优化引入了轻量级锁和偏向锁</p><p>每个java对象都可以关联一个Monitor，如果使用<code>synchronized</code>给对象上锁（重量级），该对象头的Mark Word中就被设置为指向Monitor对象的指针</p><ul><li><p>Owner：哪个线程上的重量级锁，Owner就指向谁</p></li><li><p>EntryList：等待队列，对象已经上重量级锁后，再有线程要访问就放入等待队列，<strong>双向链表</strong></p></li><li><p>WaitSet ：当前线执行的执行的时候，遇到了wait方法，就会释放锁，进入阻塞状态，这个线程就会被放到waitset存起来，其实这个waitset是不存在的一个数据结构，只是方便理解，有些人就提出了这么个概念</p><p>wait set几点说明</p><ol><li>所有对象都会由有个wait set，用来存放该对象wait方法之后的进入block状态的线程</li><li>线程被notify之后，不一定立即执行，需要抢锁</li><li>线程从wait set被唤醒的顺序不一定是FIFO</li><li>线程被唤醒后，必须重新获取锁，但是并不是从获取锁的地方执行，而是从wait的地方开始执行，也就说jvm会记录每个线程wait的位置</li></ol></li></ul><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202206261904369.png" alt="1583652360228"></p><ul><li>刚开始时Monitor中的Owner为null，之后那个线程用到这个锁，Owner就指向那个线程</li><li>Monitor 是每个重量级锁有一个，但整个程序可有有多个</li><li>当Thread-2 执行synchronized(obj){}代码时就会将Monitor的所有者Owner 设置为 Thread-2，上锁成功，Monitor中同一时刻只能有一个Owner</li><li>当Thread-2 占据锁时，如果线程Thread-3，Thread-4也来执行synchronized(obj){}代码，就会进入EntryList（阻塞队列）中变成BLOCKED状态</li><li>Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争时是非公平的</li><li>图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程</li></ul><blockquote><p>注意：synchronized 必须是进入同一个对象的 monitor 才有上述的效果不加 synchronized 的对象不会关联监视器，不遵从以上规则</p></blockquote><h2 id="synchronized原理-1"><a href="#synchronized原理-1" class="headerlink" title="synchronized原理"></a>synchronized原理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static final Object lock=new Object();</span><br><span class="line">static int counter = 0;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    synchronized (lock) &#123;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后的部分字节码，方法级别的 synchronized 不会在字节码指令中有所体现。字节码中还有异常处理机制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> 0 getstatic #2 &lt;com/concurrent/test/Test17.lock&gt;</span><br><span class="line"> # 取得lock的引用（synchronized开始了）</span><br><span class="line"> 3 dup    </span><br><span class="line"> # 复制操作数栈栈顶的值放入栈顶，即复制了一份lock的引用</span><br><span class="line"> 4 astore_1</span><br><span class="line"> # 操作数栈栈顶的值弹出，即将lock的引用存到局部变量表中</span><br><span class="line"> 5 monitorenter</span><br><span class="line"> # 将lock对象的Mark Word置为指向Monitor指针</span><br><span class="line"> 6 getstatic #3 &lt;com/concurrent/test/Test17.counter&gt;</span><br><span class="line"> 9 iconst_1</span><br><span class="line">10 iadd</span><br><span class="line">11 putstatic #3 &lt;com/concurrent/test/Test17.counter&gt;</span><br><span class="line">14 aload_1</span><br><span class="line"># 从局部变量表中取得lock的引用，放入操作数栈栈顶</span><br><span class="line">15 monitorexit</span><br><span class="line"># 将lock对象的Mark Word重置，唤醒EntryList</span><br><span class="line">16 goto 24 (+8)</span><br><span class="line"># 下面是异常处理指令，可以看到，如果出现异常，也能自动地释放锁</span><br><span class="line">19 astore_2</span><br><span class="line">20 aload_1</span><br><span class="line">21 monitorexit</span><br><span class="line">22 aload_2</span><br><span class="line">23 athrow</span><br><span class="line">24 return</span><br></pre></td></tr></table></figure><h2 id="CAS机制（先了解）"><a href="#CAS机制（先了解）" class="headerlink" title="CAS机制（先了解）"></a>CAS机制（先了解）</h2><p>CAS算法的作用：解决多线程条件下使用锁造成性能损耗问题的算法，保证了原子性，这个原子操作是由CPU来完成的<br>CAS的原理：CAS算法有三个操作数，通过内存中的值（V）、预期原始值（A)、修改后的新值。</p><ol><li>如果内存中的值和预期原始值相等， 就将修改后的新值保存到内存中。</li><li>如果内存中的值和预期原始值不相等，说明共享数据已经被修改，放弃已经所做的操作，然后重新执行刚才的操作，直到重试成功。</li></ol><p>注意：</p><ol><li>预期原始值（A）是从偏移位置读取到三级缓存中让CPU处理的值，修改后的新值是预期原始值经CPU处理暂时存储在CPU的三级缓存中的值，而内存指定偏移位置中的原始值。</li><li>比较从指定偏移位置读取到缓存的值与指定内存偏移位置的值是否相等，如果相等则修改指定内存偏移位置的值，这个操作是操作系统底层汇编的一个原子指令实现的，保证了原子性</li></ol><h2 id="三类锁和锁膨胀"><a href="#三类锁和锁膨胀" class="headerlink" title="三类锁和锁膨胀"></a>三类锁和锁膨胀</h2><p>偏向级锁、轻量锁、重量级锁：<strong>这三种锁只针对synchronized</strong></p><p> Java中锁主要存在四种状态：<strong>无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态</strong>，随着竞争的激烈而逐渐升级。<strong>锁只能升级而不能降级</strong>，即一个锁从偏向级锁升级到轻量锁时，不能再重新回到偏向级锁。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁的使用场景是：如果一个对象虽然有多个线程要对它进行加锁，但是加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来进行优化。轻量级锁对使用者是透明的，即语法仍然是<code>synchronized</code>，假设有两个方法同步块，利用同一个对象加锁</p><p>CAS</p><ol><li><p>每次指向到synchronized代码块时，都会创建锁记录（Lock Record）对象，每个线程都会包括一个锁记录的结构，锁记录内部可以储存对象的Mark Word和对象引用reference<img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202206261904048.png" alt="1583755737580"></p></li><li><p>让锁记录中的Object reference指向对象，并且尝试用cas(compare and sweep)替换Object对象的Mark Word ，将Mark Word 的值存入锁记录中<img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202206261904627.png" alt="1583755888236"></p></li><li><p>如果cas替换成功，那么对象的对象头储存的就是锁记录的地址和状态00，如下所示</p><p><img src="https://piplong-img.oss-cn-hangzhou.aliyuncs.com/blog-img/202206261904394.png" alt="1583755964276"></p></li><li><p>如果cas失败，有两种情况</p><ol><li><p>如果是其它线程已经持有了该Object的轻量级锁，那么表示有竞争，将进入锁膨胀阶段</p></li><li><p>如果是自己的线程已经执行了synchronized进行加锁，那么那么再添加一条 Lock Record 作为重入的计数</p><p><img src="https://piplong-img.oss-cn-hangzhou.aliyuncs.com/blog-img/202206261904108.png" alt="1583756190177"></p></li></ol></li><li><p>当线程退出synchronized代码块的时候，</p><p>如果获取的是取值为 null 的锁记录 ，表示有重入，这时重置锁记录，表示重入计数减一</p><p><img src="https://piplong-img.oss-cn-hangzhou.aliyuncs.com/blog-img/202206261904255.png" alt="1583756357835"></p></li><li><p>当线程退出synchronized代码块的时候，如果获取的锁记录取值不为 null，那么使用cas将Mark Word的值恢复给对象</p><ol><li>成功则解锁成功</li><li>失败，则说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li></ol></li></ol><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>当多个线程竞争同一个锁时，会导致除锁的拥有者外，其余线程都会自旋，这将导致自旋次数过多，cpu效率下降，所以会将锁升级为重量级锁。</p><p>重量级锁需要操作系统的介入，依赖操作系统底层的Muptex Lock。JVM会创建一个monitor对象，把这个对象的地址更新到Mark Word中。</p><p>当一个线程获取了该锁后，其余线程想要获取锁，必须等到这个线程释放锁后才可能获取到，没有获取到锁的线程，就进入了阻塞状态。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>在轻量级的锁中，我们可以发现，如果同一个线程对同一个对象进行重入锁时，也需要执行CAS操作，这是有点耗时的，那么java6开始引入了偏向锁，只有第一次使用CAS时将对象的Mark Word头设置为入锁线程ID，<strong>之后这个入锁线程再进行重入锁时，发现线程ID是自己的，那么就不用再进行CAS了</strong></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202206261905552.png" alt="1583760728806"></p><h4 id="偏向状态"><a href="#偏向状态" class="headerlink" title="偏向状态"></a>偏向状态</h4><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202206261905389.png" alt="1583762169169"></p><p>一个对象的创建过程</p><ol><li>如果开启了偏向锁（默认是开启的），那么对象刚创建之后，Mark Word 最后三位的值101，并且这是它的Thread，epoch，age都是0，在加锁的时候进行设置这些的值.</li><li>偏向锁默认是延迟的，不会在程序启动的时候立刻生效，如果想避免延迟，可以添加虚拟机参数来禁用延迟：-<code>XX:BiasedLockingStartupDelay=0</code>来禁用延迟</li><li>注意：处于偏向锁的对象解锁后，线程 id 仍存储于对象头中</li><li>实验Test18.java，加上虚拟机参数-XX:BiasedLockingStartupDelay&#x3D;0进行测试</li></ol><h4 id="撤销偏向锁"><a href="#撤销偏向锁" class="headerlink" title="撤销偏向锁"></a>撤销偏向锁</h4><div class="tabs" id="2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2-1">hashcode方法</button></li><li class="tab"><button type="button" data-href="#2-2">其它线程使用对象</button></li><li class="tab"><button type="button" data-href="#2-3">调用 wait/notify</button></li><li class="tab"><button type="button" data-href="#2-4">批量重偏向</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2-1"><p>hashcode方法</p><p>调用对象的hashcode方法的时候就会撤销这个对象的偏向锁，因为使用偏向锁时没有位置存<code>hashcode</code>的值了</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2-2"><p>其它线程使用对象</p><p>这里我们演示的是偏向锁撤销变成轻量级锁的过程，那么就得满足轻量级锁的使用条件，就是没有线程对同一个对象进行锁竞争，我们使用<code>wait</code> 和 <code>notify</code> 来辅助实现</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2-3"><p>调用 wait&#x2F;notify</p><p>不管什么锁，只要调用 wait&#x2F;notify方法，就会使对象的锁变成重量级锁，因为wait&#x2F;notify方法之后重量级锁才支持</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2-4"><p>批量重偏向</p><p>如果对象被多个线程访问，但是没有竞争，这时候偏向了线程一的对象又有机会重新偏向线程二，即可以不用升级为轻量级锁，可这和我们之前做的实验矛盾了呀，其实要实现重新偏向是要有条件的：就是超过20对象对同一个线程如线程一撤销偏向时，那么第20个及以后的对象才可以将撤销对线程一的偏向这个动作变为将第20个及以后的对象偏向线程二</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h3><p>如果在尝试加轻量级锁的过程中，操作无法成功，这是有一种情况就是其它线程已经为这个对象加上了轻量级锁，这是就要进行锁膨胀，将轻量级锁变成重量级锁。</p><ol><li><p>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202206261904499.png" alt="1583757433691"></p></li><li><p>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程</p><p>即为对象申请Monitor锁，让Object指向重量级锁地址，然后自己进入Monitor 的EntryList 变成BLOCKED状态</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202206261904936.png" alt="1583757586447"></p></li><li><p>当Thread-0 推出synchronized同步块时，使用cas将Mark Word的值恢复给对象头，失败，那么会进入重量级锁的解锁过程，即按照Monitor的地址找到Monitor对象，将Owner设置为null，唤醒EntryList 中的Thread-1线程</p></li></ol><h3 id="自旋优化"><a href="#自旋优化" class="headerlink" title="自旋优化"></a>自旋优化</h3><p>简单类比，回家没带钥匙，敲门让里面的人开门。第一次没人开门，可能是还没反应过来。多敲几次还没开门我们就能假设没人，过一段时间再来。</p><p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功，即在自旋的期间，持锁的线程释放了锁，该对象现在空闲了，那么当前线程就可以不用进行上下文切换就使用这个对象，再上锁</p><ol><li><p>自旋重试成功的情况<img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202206261904963.png" alt="1583758113724"></p></li><li><p>自旋重试失败的情况，自旋了一定次数还是没有等到持锁的线程释放锁<img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202206261905380.png" alt="1583758136650"></p></li></ol><p>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。Java 7 之后不能控制是否开启自旋功能</p><h2 id="wait和notify"><a href="#wait和notify" class="headerlink" title="wait和notify"></a>wait和notify</h2><p>wait</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> 管型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-字节码</title>
      <link href="/2023/07/19/JVM%E5%AD%97%E8%8A%82%E7%A0%81/"/>
      <url>/2023/07/19/JVM%E5%AD%97%E8%8A%82%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><div class="tabs" id="t1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#t1-1">.java文件</button></li><li class="tab"><button type="button" data-href="#t1-2">.class文件</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="t1-1"><p>我们写的文件</p><p>HelloWorld.java</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;Hello, World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="t1-2"><p>经过javac 编译以后生成字节码文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09</span><br><span class="line">0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07</span><br><span class="line">0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29</span><br><span class="line">0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e</span><br><span class="line">0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63</span><br><span class="line">0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01</span><br><span class="line">0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63</span><br><span class="line">0000160 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f</span><br><span class="line">0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16</span><br><span class="line">0000220 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72</span><br><span class="line">0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13</span><br><span class="line">0000260 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69</span><br><span class="line">0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61</span><br><span class="line">0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46</span><br><span class="line">0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64</span><br><span class="line">0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e</span><br><span class="line">0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64</span><br><span class="line">0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74</span><br><span class="line">0000440 63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c</span><br><span class="line">0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61</span><br><span class="line">0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61</span><br><span class="line">0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f</span><br><span class="line">0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72</span><br><span class="line">0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76</span><br><span class="line">0000600 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d</span><br><span class="line">0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a</span><br><span class="line">0000640 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b</span><br><span class="line">0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01</span><br><span class="line">0000700 00 07 00 08 00 01 00 09 00 00 00 2f 00 01 00 01</span><br><span class="line">0000720 00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 0a 00</span><br><span class="line">0000740 00 00 06 00 01 00 00 00 04 00 0b 00 00 00 0c 00</span><br><span class="line">0000760 01 00 00 00 05 00 0c 00 0d 00 00 00 09 00 0e 00</span><br><span class="line">0001000 0f 00 02 00 09 00 00 00 37 00 02 00 01 00 00 00</span><br><span class="line">0001020 09 b2 00 02 12 03 b6 00 04 b1 00 00 00 02 00 0a</span><br><span class="line">0001040 00 00 00 0a 00 02 00 00 00 06 00 08 00 07 00 0b</span><br><span class="line">0001060 00 00 00 0c 00 01 00 00 00 09 00 10 00 11 00 00</span><br><span class="line">0001100 00 12 00 00 00 05 01 00 10 00 00 00 01 00 13 00</span><br><span class="line">0001120 00 00 02 00 14</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>根据JVM规范，类文件结构如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4 magic;                  // 魔数，用于标识文件类型</span><br><span class="line">    u2 minor_version;          // Java虚拟机的次版本号</span><br><span class="line">    u2 major_version;          // Java虚拟机的主版本号</span><br><span class="line">    u2 constant_pool_count;    // 常量池大小</span><br><span class="line">    cp_info constant_pool[constant_pool_count-1]; // 常量池数组</span><br><span class="line">    u2 access_flags;           // 访问标识符，用于表示类或接口的访问控制</span><br><span class="line">    u2 this_class;             // 当前类或接口的索引</span><br><span class="line">    u2 super_class;            // 当前类的超类(父类)索引</span><br><span class="line">    u2 interfaces_count;       // 接口数量</span><br><span class="line">    u2 interfaces[interfaces_count]; // 接口索引列表</span><br><span class="line">    u2 fields_count;           // 字段数量</span><br><span class="line">    field_info fields[fields_count]; // 字段信息数组</span><br><span class="line">    u2 methods_count;          // 方法数量</span><br><span class="line">    method_info methods[methods_count]; // 方法信息数组</span><br><span class="line">    u2 attributes_count;       // 类或接口的附加属性数量</span><br><span class="line">    attribute_info attributes[attributes_count]; // 类或接口的附加属性信息数组</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上面的字节码文件，按顺序逐个进行分析</p><h2 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h2><ul><li>0-3字节，表示它是否是class类型的文件<ul><li>0000000 <code>ca fe ba be</code> 00 00 00 34 00 22 0a 00 06 00 14 09</li></ul></li><li>在Java中，所有的.class文件都以魔数<code>ca fe ba be</code>开头，这个魔数的前4个字节用于识别该文件是否为Java类文件，如果这个魔数不匹配，那么Java虚拟机将无法加载该文件。</li></ul><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><ul><li>4-7字节，表示类的版本 <code>00 34(52)</code>对应十进制为52，表示的是<code>Java 8</code></li></ul><h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><table><thead><tr><th align="center">Constant Type</th><th align="center">Value</th></tr></thead><tbody><tr><td align="center">CONSTANT_Utf8</td><td align="center">1</td></tr><tr><td align="center">CONSTANT_Integer</td><td align="center">3</td></tr><tr><td align="center">CONSTANT_Float</td><td align="center">4</td></tr><tr><td align="center">CONSTANT_Long</td><td align="center">5</td></tr><tr><td align="center">CONSTANT_Double</td><td align="center">6</td></tr><tr><td align="center">CONSTANT_Class</td><td align="center">7</td></tr><tr><td align="center">CONSTANT_String</td><td align="center">8</td></tr><tr><td align="center">CONSTANT_Fieldref</td><td align="center">9</td></tr><tr><td align="center">CONSTANT_Methodref</td><td align="center">10</td></tr><tr><td align="center">CONSTANT_InterfaceMethodref</td><td align="center">11</td></tr><tr><td align="center">CONSTANT_NameAndType</td><td align="center">12</td></tr><tr><td align="center">CONSTANT_MethodHandle</td><td align="center">15</td></tr><tr><td align="center">CONSTANT_MethodType</td><td align="center">16</td></tr><tr><td align="center">CONSTANT_InvokeDynamic</td><td align="center">18</td></tr></tbody></table><ul><li>8-9字节，表示常量池长度<ul><li>0000000 ca fe ba be 00 00 00 34 <code>00 22</code> 0a 00 06 00 14 09</li><li><code>00 22(34)</code>，表示常量池有<code>#1-#33</code>项，注意#0项不计入，也没有值</li></ul></li></ul><ol><li><code>第#1项</code> 0a 表示一个 Method 信息，00 06 和 00 14（20） 表示它引用了常量池中 #6 和 #20 项来获得这个方法的<code>所属类</code>和<code>方法名</code><ul><li>0000000 ca fe ba be 00 00 00 34 00 22 <code>0a 00 06 00 14</code> 09</li></ul></li><li><code>第#2项</code> 09 表示一个 Field 信息，00 16（22）和 00 17（23） 表示它引用了常量池中 #22 和 ## 23 项来获得这个成员变量的<code>所属类</code>和<code>成员变量名</code><ul><li>0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 <code>09</code></li><li>0000020 <code>00 16 00 17</code> 08 00 18 0a 00 19 00 1a 07 00 1b 07</li></ul></li><li><code>第#3项</code> 08 表示一个字符串常量名称，00 18（24）表示它引用了常量池中 #24 项<ul><li>0000020 00 16 00 17 <code>08 00 18</code> 0a 00 19 00 1a 07 00 1b 07</li></ul></li><li><code>第#4项</code> 0a 表示一个 Method 信息，00 19（25） 和 00 1a（26） 表示它引用了常量池中 #25 和 #26项来获得这个方法的<code>所属类</code>和<code>方法名</code><ul><li>0000020 00 16 00 17 08 00 18 <code>0a 00 19 00 1a</code> 07 00 1b 07</li></ul></li><li><code>第#5项</code> 07 表示一个 Class 信息，00 1b（27） 表示它引用了常量池中 #27 项<ul><li>0000020 00 16 00 17 08 00 18 0a 00 19 00 1a <code>07 00 1b</code> 07</li></ul></li><li><code>第#6项</code> 07 表示一个 Class 信息，00 1c（28） 表示它引用了常量池中 #28 项<ul><li>0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b <code>07</code></li><li>0000040 <code>00 1c</code> 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29</li></ul></li><li><code>第#7项</code> 01 表示一个 utf8 串，00 06 表示长度，3c 69 6e 69 74 3e 是<code>&lt;init&gt;</code><ul><li>0000040 00 1c 01 <code>00 06 3c 69 6e 69 74 3e</code> 01 00 03 28 29</li></ul></li><li><code>第#8项</code> 01 表示一个 utf8 串，00 03 表示长度，28 29 56 是<code>()V</code>其实就是表示无参、无返回值<ul><li>0000040 00 1c 01 00 06 3c 69 6e 69 74 3e <code>01 00 03 28 29</code></li><li>0000060 <code>56</code> 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e</li></ul></li><li><code>第#9项</code> 01 表示一个 utf8 串，00 04 表示长度，43 6f 64 65 是<code>Code</code><ul><li>0000060 56 <code>01 00 04 43 6f 64 65</code> 01 00 0f 4c 69 6e 65 4e</li></ul></li><li><code>第#10项</code> 01 表示一个 utf8 串，00 0f（15） 表示长度，4c 69 6e 65 4e 75 6d 62 65 72 54 61 62 6c 65 是<code>LineNumberTable</code><ul><li>0000060 56 01 00 04 43 6f 64 <code>65 01 00 0f 4c 69 6e 65 4e</code></li><li>0000100 <code>75 6d 62 65 72 54 61 62 6c 65</code> 01 00 12 4c 6f 63</li></ul></li><li><code>第#11项</code> 01 表示一个 utf8 串，00 12（18） 表示长度，4c 6f 63 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65是<code>LocalVariableTable</code><ul><li>0000100 75 6d 62 65 72 54 61 62 6c 65 <code>01 00 12 4c 6f 63</code></li><li>0000120 <code>61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65</code> 01</li></ul></li><li><code>第#12项</code> 01 表示一个 utf8 串，00 04 表示长度，74 68 69 73 是<code>this</code><ul><li>0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 <code>01</code></li><li>0000140 <code>00 04 74 68 69 73</code> 01 00 1d 4c 63 6e 2f 69 74 63</li></ul></li><li><code>第#13项</code> 01 表示一个 utf8 串，00 1d（29） 表示长度，是<code>Lcn/itcast/jvm/t5/HelloWorld;</code><ul><li>0000140 00 04 74 68 69 73 <code>01 00 1d 4c 63 6e 2f 69 74 63</code></li><li>0000160 <code>61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f</code></li><li>0000200 <code>57 6f 72 6c 64 3b</code> 01 00 04 6d 61 69 6e 01 00 16</li></ul></li><li><code>第#14项</code> 01 表示一个 utf8 串，00 04 表示长度，74 68 69 73 是<code>main</code><ul><li>0000200 57 6f 72 6c 64 3b <code>01 00 04 6d 61 69 6e</code> 01 00 16</li></ul></li><li><code>第#15项</code> 01 表示一个 utf8 串，00 16（22） 表示长度，是<code>([Ljava/lang/String;)V</code>其实就是参数为字符串数组，无返回值<ul><li>0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e <code>01 00 16</code></li><li>0000220 <code>28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72</code></li><li>0000240 <code>69 6e 67 3b 29 56</code> 01 00 04 61 72 67 73 01 00 13</li></ul></li><li><code>第#16项</code> 01 表示一个 utf8 串，00 04 表示长度，是<code>args</code><ul><li>0000240 69 6e 67 3b 29 56 <code>01 00 04 61 72 67 73</code> 01 00 13</li></ul></li><li><code>第#17项</code> 01 表示一个 utf8 串，00 13（19） 表示长度，是<code>[Ljava/lang/String;</code><ul><li>0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 <code>01 00 13</code></li><li>0000260 <code>5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69</code></li><li>0000300 <code>6e 67 3b</code> 01 00 10 4d 65 74 68 6f 64 50 61 72 61</li></ul></li><li><code>第#18项</code> 01 表示一个 utf8 串，00 10（16） 表示长度，是<code>MethodParameters</code><ul><li>0000300 6e 67 3b <code>01 00 10 4d 65 74 68 6f 64 50 61 72 61</code></li><li>0000320 <code>6d 65 74 65 72 73</code> 01 00 0a 53 6f 75 72 63 65 46</li></ul></li><li><code>第#19项</code> 01 表示一个 utf8 串，00 0a（10） 表示长度，是<code>SourceFile</code><ul><li>0000320 6d 65 74 65 72 73 <code>01 00 0a 53 6f 75 72 63 65 46</code></li><li>0000340 <code>69 6c 65</code> 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64</li></ul></li><li><code>第#20项</code> 01 表示一个 utf8 串，00 0f（15） 表示长度，是<code>HelloWorld.java</code><ul><li>0000340 69 6c 65 <code>01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64</code></li><li>0000360 <code>2e 6a 61 76 61</code> 0c 00 07 00 08 07 00 1d 0c 00 1e</li></ul></li><li><code>第#21项</code> 0c 表示一个 <code>名+类型</code>，00 07 00 08 引用了常量池中 #7 #8 两项<ul><li>0000360 2e 6a 61 76 61 <code>0c 00 07 00 08</code> 07 00 1d 0c 00 1e</li></ul></li><li><code>第#22项</code> 07 表示一个 Class 信息，00 1d（29） 引用了常量池中 #29 项<ul><li>0000360 2e 6a 61 76 61 0c 00 07 00 08 <code>07 00 1d</code> 0c 00 1e</li></ul></li><li><code>第#23项</code> 0c 表示一个 <code>名+类型</code>，00 1e（30） 00 1f （31）引用了常量池中 #30 #31 两项<ul><li>0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d <code>0c 00 1e</code></li><li>0000400 <code>00 1f</code> 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64</li></ul></li><li><code>第#24项</code> 01 表示一个 utf8 串，00 0f（15） 表示长度，是<code>hello world</code><ul><li>0000400 00 1f <code>01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64</code></li></ul></li><li><code>第#25项</code> 07 表示一个 Class 信息，00 20（32） 引用了常量池中 #32 项<ul><li>0000420 <code>07 00 20</code> 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74</li></ul></li><li><code>第#26项</code> 0c 表示一个 <code>名+类型</code>，00 21（33） 00 22（34）引用了常量池中 #33 #34 两项<ul><li>0000420 07 00 20 <code>0c 00 21 00 22</code> 01 00 1b 63 6e 2f 69 74</li></ul></li><li><code>第#27项</code> 01 表示一个 utf8 串，00 1b（27） 表示长度，是<code>cn/itcast/jvm/t5/HelloWorld</code><ul><li>0000420 07 00 20 0c 00 21 00 22 01 <code>00 1b 63 6e 2f 69 74</code></li><li>0000440 <code>63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c</code></li><li>0000460 <code>6f 57 6f 72 6c 64</code> 01 00 10 6a 61 76 61 2f 6c 61</li></ul></li><li><code>第#28项</code> 01 表示一个 utf8 串，00 10（16） 表示长度，是<code>java/lang/Object</code><ul><li>0000460 6f 57 6f 72 6c 64 <code>01 00 10 6a 61 76 61 2f 6c 61</code></li><li>0000500 <code>6e 67 2f 4f 62 6a 65 63 74</code> 01 00 10 6a 61 76 61</li></ul></li><li><code>第#29项</code> 01 表示一个 utf8 串，00 10（16） 表示长度，是<code>java/lang/System</code><ul><li>0000500 6e 67 2f 4f 62 6a 65 63 74 <code>01 00 10 6a 61 76 61</code></li><li>0000520 <code>2f 6c 61 6e 67 2f 53 79 73 74 65 6d</code> 01 00 03 6f</li></ul></li><li><code>第#30项</code> 01 表示一个 utf8 串，00 03 表示长度，是<code>out</code><ul><li>0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d <code>01 00 03 6f</code></li><li>0000540 <code>75 74</code> 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72</li></ul></li><li><code>第#31项</code> 01 表示一个 utf8 串，00 15（21） 表示长度，是<code>Ljava/io/PrintStream;</code><ul><li>0000540 75 74 <code>01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72</code></li><li>0000560 <code>69 6e 74 53 74 72 65 61 6d 3b</code> 01 00 13 6a 61 76</li></ul></li><li><code>第#32项</code> 01 表示一个 utf8 串，00 13（19） 表示长度，是<code>java/io/PrintStream</code><ul><li>0000560 69 6e 74 53 74 72 65 61 6d 3b <code>01 00 13 6a 61 76</code></li><li>0000600 <code>61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d</code></li></ul></li><li><code>第#33项</code> 01 表示一个 utf8 串，00 07 表示长度，是<code>println</code><ul><li>0000620 <code>01 00 07 70 72 69 6e 74 6c 6e</code> 01 00 15 28 4c 6a</li></ul></li><li><code>第#34项</code> 01 表示一个 utf8 串，00 15（21） 表示长度，是<code>(Ljava/lang/String;)V</code><ul><li>0000620 01 00 07 70 72 69 6e 74 6c 6e <code>01 00 15 28 4c 6a</code></li><li>0000640 <code>61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b</code></li><li>0000660 <code>29 56</code> 00 21 00 05 00 06 00 00 00 00 00 02 00 01</li></ul></li></ol><h2 id="访问标识与继承信息"><a href="#访问标识与继承信息" class="headerlink" title="访问标识与继承信息"></a>访问标识与继承信息</h2><ul><li>访问标识符：21表示class是一个类，公共的<ul><li>0000660 29 56 <code>00 21</code> 00 05 00 06 00 00 00 00 00 02 00 01</li></ul></li><li>当前类或接口的索引：05表示根据常量池中的#5找到本类的全限定名<ul><li>0000660 29 56 00 21 <code>00 05</code> 00 06 00 00 00 00 00 02 00 01</li></ul></li><li>当前类的超类（父类）索引：06表示根据常量池中的#6找到父类全限定名<ul><li>0000660 29 56 00 21 00 05 <code>00 06</code> 00 00 00 00 00 02 00 01</li></ul></li><li>接口数量：本类为0<ul><li>0000660 29 56 00 21 00 05 00 06 <code>00 00</code> 00 00 00 02 00 01</li></ul></li></ul><table><thead><tr><th align="center">Flag Name</th><th align="center">Value</th><th>Interpretation</th></tr></thead><tbody><tr><td align="center">ACC_PUBLIC</td><td align="center">0x0001</td><td>Declared public; may be accessed from outside its package.</td></tr><tr><td align="center">ACC_FINAL</td><td align="center">0x0010</td><td>Declared final; no subclasses allowed.</td></tr><tr><td align="center">ACC_SUPER</td><td align="center">0x0020</td><td>Treat superclass methods specially when invoked by the invokespecial instruction.</td></tr><tr><td align="center">ACC_INTERFACE</td><td align="center">0x0200</td><td>Is an interface, not a class.</td></tr><tr><td align="center">ACC_ABSTRACT</td><td align="center">0x0400</td><td>Declared abstract; must not be instantiated.</td></tr><tr><td align="center">ACC_SYNTHETIC</td><td align="center">0x1000</td><td>Declared synthetic; not present in the source code.</td></tr><tr><td align="center">ACC_ANNOTATION</td><td align="center">0x2000</td><td>Declared as an annotation type.</td></tr><tr><td align="center">ACC_ENUM</td><td align="center">0x4000</td><td>Declared as an enum type.</td></tr></tbody></table><h2 id="Field信息"><a href="#Field信息" class="headerlink" title="Field信息"></a>Field信息</h2><ul><li>字段数量（成员变量数量），本类为0<ul><li>0000660 29 56 00 21 00 05 00 06 00 00 <code>00 00</code> 00 02 00 01</li></ul></li></ul><h2 id="Method信息"><a href="#Method信息" class="headerlink" title="Method信息"></a>Method信息</h2><ul><li>方法数量：本类为2，构造方法和main方法<ul><li>0000660 29 56 00 21 00 05 00 06 00 00 00 00 <code>00 02</code> 00 01</li></ul></li><li>一个方法由访问修饰符、名称、参数描述、方法苏属性数量、方法属性组成</li><li>00 01表示访问修饰符（本类中为public）<ul><li>0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 <code>00 01</code></li></ul></li><li>00 07表示引用了常量池中的#07项作为方法名称<ul><li>0000700 <code>00 07</code> 00 08 00 01 00 09 00 00 00 2f 00 01 00 01</li></ul></li><li>00 08表示引用了常量池中的#08项作为方法参数描述<ul><li>0000700 00 07 <code>00 08</code> 00 01 00 09 00 00 00 2f 00 01 00 01</li></ul></li><li>01表示引方法属性数量，本方法是1<ul><li>0000700 00 07 00 08 <code>00 01</code> 00 09 00 00 00 2f 00 01 00 01</li></ul></li><li>00 09表示引用常量池#09项，发现是<code>code</code>属性<ul><li>0000700 00 07 00 08 00 01 <code>00 09</code> 00 00 00 2f 00 01 00 01</li></ul></li><li>00 00 00 2f表示此属性的长度是47<ul><li>0000700 00 07 00 08 00 01 00 09 <code>00 00 00 2f</code> 00 01 00 01</li></ul></li><li>00 01表示操作数栈最大深度<ul><li>0000700 00 07 00 08 00 01 00 09 00 00 00 2f <code>00 01</code> 00 01</li></ul></li><li>00 01表示局部变量最大槽(slot)数<ul><li>0000700 00 07 00 08 00 01 00 09 00 00 00 2f 00 01 <code>00 01</code></li></ul></li><li>00 00 00 05表示字节码长度，本例为5<ul><li>0000720 <code>00 00 00 05</code> 2a b7 00 01 b1 00 00 00 02 00 0a 00</li></ul></li><li>2a b7 00 01 b1 是字节码指令<ul><li>0000720 00 00 00 05 <code>2a b7 00 01 b1</code> 00 00 00 02 00 0a 00</li></ul></li><li>00 00 00 02 表示方法细节属性数量，本例为2<ul><li>0000720 00 00 00 05 2a b7 00 01 b1 <code>00 00 00 02</code> 00 0a 00</li></ul></li><li>00 0a表示引用了常量池#10项，发现是LineNumberTable属性<ul><li>0000720 00 00 00 05 2a b7 00 01 b1 00 00 00 02 <code>00 0a</code> 00</li><li>00 00 00 06表示此属性的总长度，本例是6<ul><li>0000720 00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 0a <code>00</code></li><li>0000740 <code>00 00 06</code> 00 01 00 00 00 04 00 0b 00 00 00 0c 00</li></ul></li><li>00 01表示LineNumberTable长度<ul><li>0000740 00 00 06 <code>00 01</code> 00 00 00 04 00 0b 00 00 00 0c 00</li></ul></li><li>00 00 表示字节码行号<ul><li>0000740 00 00 06 00 01 <code>00 00</code> 00 04 00 0b 00 00 00 0c 00</li></ul></li><li>00 04表示Java源码行号<ul><li>0000740 00 00 06 00 01 00 00 <code>00 04</code> 00 0b 00 00 00 0c 00</li></ul></li></ul></li><li>00 0b表示引用了常量池#11项，发现是LocalVariableTable属性<ul><li>0000740 00 00 06 00 01 00 00 00 04 <code>00 0b</code> 00 00 00 0c 00</li><li>00 00 00 0c 表示此属性总长度，本例为12<ul><li>0000740 00 00 06 00 01 00 00 00 04 00 0b <code>00 00 00 0c</code> 00</li></ul></li><li>00 01 表示LocalVariableTable长度<ul><li>0000740 00 00 06 00 01 00 00 00 04 00 0b 00 00 00 0c <code>00</code></li><li>0000760 <code>01</code> 00 00 00 05 00 0c 00 0d 00 00 00 09 00 0e 00</li></ul></li><li>00 00 表示局部变量生命周期开始，相对于字节码的偏移量<ul><li>0000760 01 <code>00 00</code> 00 05 00 0c 00 0d 00 00 00 09 00 0e 00</li></ul></li><li>00 05 表示局部变量覆盖的范围长度<ul><li>0000760 01 00 00 <code>00 05</code> 00 0c 00 0d 00 00 00 09 00 0e 00</li></ul></li><li>00 0c 表示局部变量的名称，引用常量池#12项<ul><li>0000760 01 00 00 00 05 <code>00 0c</code> 00 0d 00 00 00 09 00 0e 00</li></ul></li><li>00 0d 表示局部变量的类型，本例引用了常量池 #13 项，是Lcn&#x2F;itcast&#x2F;jvm&#x2F;t5&#x2F;HelloWorld;<ul><li>0000760 01 00 00 00 05 00 0c <code>00 0d</code> 00 00 00 09 00 0e 00</li></ul></li><li>00 00 表述局部变量占有的槽位(slot)编号，本例是0<ul><li>0000760 01 00 00 00 05 00 0c 00 0d <code>00 00</code> 00 09 00 0e 00</li></ul></li></ul></li><li>00 09代表访问修饰符（本类中是 public static）</li><li>00 0e 代表引用了常量池 #14 项作为方法名称</li><li>00 0f 代表引用了常量池 #15 项作为方法参数描述</li><li>00 02 代表方法属性数量，本方法是 2</li><li>其余代表方法属性（属性1）<ul><li>00 09 表示引用了常量池 #09 项，发现是<code>Code</code>属性</li><li>00 00 00 37 表示此属性的长度是 55</li><li>00 02 表示<code>操作数栈</code>最大深度</li><li>00 01 表示<code>局部变量表</code>最大槽（slot）数</li><li>00 00 00 05 表示字节码长度，本例是 9</li><li>b2 00 02 12 03 b6 00 04 b1 是字节码指令</li><li>00 00 00 02 表示方法细节属性数量，本例是 2</li><li>00 0a 表示引用了常量池 #10 项，发现是LineNumberTable属性<ul><li>00 00 00 0a 表示此属性的总长度，本例是 10</li><li>00 02 表示<code>LineNumberTable</code>长度</li><li>00 00 表示<code>字节码</code>行号 00 06 表示<code>java 源码</code>行号</li><li>00 08 表示<code>字节码</code>行号 00 07 表示<code>java 源码</code>行号</li></ul></li></ul></li><li>00 0b 表示引用了常量池 #11 项，发现是<code>LocalVariableTable</code>属性<ul><li>00 00 00 0c 表示此属性的总长度，本例是 12</li><li>00 01 表示<code>LocalVariableTable</code>长度</li><li>00 00 表示局部变量生命周期开始，相对于字节码的偏移量</li><li>00 09 表示局部变量覆盖的范围长度</li><li>00 10 表示局部变量名称，本例引用了常量池 #16 项，是<code>args</code></li><li>00 11 表示局部变量的类型，本例引用了常量池 #17 项，是<code>[Ljava/lang/String;</code></li><li>00 00 表示局部变量占有的槽位（slot）编号，本例是 0</li></ul></li><li>0000760 01 00 00 00 05 00 0c 00 0d 00 00 <code>00 09 00 0e 00</code></li><li>0001000 <code>0f 00 02 00 09 00 00 00 37 00 02 00 01 00 00 00</code></li><li>0001020 <code>09 b2 00 02 12 03 b6 00 04 b1 00 00 00 02 00 0a</code></li><li>0001040 <code>00 00 00 0a 00 02 00 00 00 06 00 08 00 07 00 0b</code></li><li>0001060 <code>00 00 00 0c 00 01 00 00 00 09 00 10 00 11 00 00</code></li><li>红色代表方法属性（属性2）<ul><li>00 12 表示引用了常量池 #18 项，发现是<code>MethodParameters</code>属性</li><li>00 00 00 05 表示此属性的总长度，本例是 5</li><li>01 参数数量</li><li>00 10 表示引用了常量池 #16 项，是<code>args</code></li><li>00 00 访问修饰符</li><li>0001100 <code>00 12 00 00 00 05 01 00 10 00 00</code> 00 01 00 13 00</li></ul></li></ul><h2 id="附加属性"><a href="#附加属性" class="headerlink" title="附加属性"></a>附加属性</h2><ul><li>00 01 表示附加属性数量</li><li>00 13 表示引用了常量池 #19 项，即<code>SourceFile</code></li><li>00 00 00 02 表示此属性的长度</li><li>00 14 表示引用了常量池 #20 项，即HelloWorld.java<ul><li>0001100 00 12 00 00 00 05 01 00 10 00 00 <code>00 01 00 13 00</code></li><li>0001120 <code>00 00 02 00 14</code>分</li></ul></li></ul><h1 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h1><h2 id="javap工具"><a href="#javap工具" class="headerlink" title="javap工具"></a>javap工具</h2><ul><li><p>自己分析类文件结构太麻烦了，Oracle提供了javap工具来反编译class文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">$ javap -v HelloWorld.class</span><br><span class="line">Classfile /D:/Workspace/JVM/demo/target/classes/com/demo/HelloWorld.class</span><br><span class="line">  Last modified 2023-4-5; size 551 bytes</span><br><span class="line">  MD5 checksum 1389d939c65ba536eb81d1a5c61d99be</span><br><span class="line">  Compiled from &quot;HelloWorld.java&quot;              </span><br><span class="line">public class com.demo.HelloWorld               </span><br><span class="line">  minor version: 0                             </span><br><span class="line">  major version: 52                            </span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #6.#20         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #21.#22        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #3 = String             #23            // hello world</span><br><span class="line">   #4 = Methodref          #24.#25        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = Class              #26            // com/demo/HelloWorld</span><br><span class="line">   #6 = Class              #27            // java/lang/Object</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Lcom/demo/HelloWorld;</span><br><span class="line">  #14 = Utf8               main</span><br><span class="line">  #15 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #16 = Utf8               args</span><br><span class="line">  #17 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #18 = Utf8               SourceFile</span><br><span class="line">  #19 = Utf8               HelloWorld.java</span><br><span class="line">  #20 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #21 = Class              #28            // java/lang/System</span><br><span class="line">  #22 = NameAndType        #29:#30        // out:Ljava/io/PrintStream;</span><br><span class="line">  #23 = Utf8               hello world</span><br><span class="line">  #24 = Class              #31            // java/io/PrintStream</span><br><span class="line">  #25 = NameAndType        #32:#33        // println:(Ljava/lang/String;)V</span><br><span class="line">  #26 = Utf8               com/demo/HelloWorld</span><br><span class="line">  #27 = Utf8               java/lang/Object</span><br><span class="line">  #28 = Utf8               java/lang/System</span><br><span class="line">  #29 = Utf8               out</span><br><span class="line">  #30 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #31 = Utf8               java/io/PrintStream</span><br><span class="line">  #32 = Utf8               println</span><br><span class="line">  #33 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  public com.demo.HelloWorld();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3                  // String hello world</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 5: 0</span><br><span class="line">        line 6: 8</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       9     0  args   [Ljava/lang/String;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;HelloWorld.java&quot;</span><br></pre></td></tr></table></figure></li></ul><h2 id="图解方法执行流程"><a href="#图解方法执行流程" class="headerlink" title="图解方法执行流程"></a>图解方法执行流程</h2><ol><li><p>原始Java代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 演示 字节码指令 和 操作数栈、常量池的关系</span><br><span class="line"> */</span><br><span class="line">public class Demo_20 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a = 10;</span><br><span class="line">        int b = Short.MAX_VALUE + 1;</span><br><span class="line">        int c = a + b;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编译后的字节码文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">$ javap -v Demo_20.class</span><br><span class="line">Classfile /D:/Workspace/JVM/demo/target/classes/com/demo/Demo_20.class</span><br><span class="line">  Last modified 2023-4-7; size 601 bytes       </span><br><span class="line">  MD5 checksum 0f9e41fb2a7334a69c89d2661540f4f1</span><br><span class="line">  Compiled from &quot;Demo_20.java&quot;                 </span><br><span class="line">public class com.demo.Demo_20                  </span><br><span class="line">  minor version: 0                             </span><br><span class="line">  major version: 52                            </span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER                 </span><br><span class="line">Constant pool:                                 </span><br><span class="line">   #1 = Methodref          #7.#25         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V             </span><br><span class="line">   #2 = Class              #26            // java/lang/Short                           </span><br><span class="line">   #3 = Integer            32768                                                       </span><br><span class="line">   #4 = Fieldref           #27.#28        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #5 = Methodref          #29.#30        // java/io/PrintStream.println:(I)V</span><br><span class="line">   #6 = Class              #31            // com/demo/Demo_20</span><br><span class="line">   #7 = Class              #32            // java/lang/Object</span><br><span class="line">   #8 = Utf8               &lt;init&gt;</span><br><span class="line">   #9 = Utf8               ()V</span><br><span class="line">  #10 = Utf8               Code</span><br><span class="line">  #11 = Utf8               LineNumberTable</span><br><span class="line">  #12 = Utf8               LocalVariableTable</span><br><span class="line">  #13 = Utf8               this</span><br><span class="line">  #14 = Utf8               Lcom/demo/Demo_20;</span><br><span class="line">  #15 = Utf8               main</span><br><span class="line">  #16 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #17 = Utf8               args</span><br><span class="line">  #18 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #19 = Utf8               a</span><br><span class="line">  #20 = Utf8               I</span><br><span class="line">  #21 = Utf8               b</span><br><span class="line">  #22 = Utf8               c</span><br><span class="line">  #23 = Utf8               SourceFile</span><br><span class="line">  #24 = Utf8               Demo_20.java</span><br><span class="line">  #25 = NameAndType        #8:#9          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #26 = Utf8               java/lang/Short</span><br><span class="line">  #27 = Class              #33            // java/lang/System</span><br><span class="line">  #28 = NameAndType        #34:#35        // out:Ljava/io/PrintStream;</span><br><span class="line">  #29 = Class              #36            // java/io/PrintStream</span><br><span class="line">  #30 = NameAndType        #37:#38        // println:(I)V</span><br><span class="line">  #31 = Utf8               com/demo/Demo_20</span><br><span class="line">  #32 = Utf8               java/lang/Object</span><br><span class="line">  #33 = Utf8               java/lang/System</span><br><span class="line">  #34 = Utf8               out</span><br><span class="line">  #35 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #36 = Utf8               java/io/PrintStream</span><br><span class="line">  #37 = Utf8               println</span><br><span class="line">  #38 = Utf8               (I)V</span><br><span class="line">&#123;</span><br><span class="line">  public com.demo.Demo_20();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 6: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom/demo/Demo_20;</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=4, args_size=1</span><br><span class="line">         0: bipush        10</span><br><span class="line">         2: istore_1</span><br><span class="line">         3: ldc           #3                  // int 32768</span><br><span class="line">         5: istore_2</span><br><span class="line">         6: iload_1</span><br><span class="line">         7: iload_2</span><br><span class="line">         8: iadd</span><br><span class="line">         9: istore_3</span><br><span class="line">        10: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        13: iload_3</span><br><span class="line">        14: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        17: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 8: 0</span><br><span class="line">        line 9: 3</span><br><span class="line">        line 10: 6</span><br><span class="line">        line 11: 10</span><br><span class="line">        line 12: 17</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      18     0  args   [Ljava/lang/String;</span><br><span class="line">            3      15     1     a   I</span><br><span class="line">            6      12     2     b   I</span><br><span class="line">           10       8     3     c   I</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;Demo_20.java&quot;</span><br></pre></td></tr></table></figure></li><li><p>常量池载入运行时常量池</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310271921123.png"></p></li><li><p>方法字节码载入方法区</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310271921811.png"></p></li><li><p>main线程开始运行、分配栈帧内存</p><p>stack&#x3D;2, locals&#x3D;4</p><ul><li><p>操作数栈的深度为2，也就是说，在执行该方法时，最多可以将两个值压入栈中进行操作。</p></li><li><p>包含四个局部变量</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310271922837.png"></p></li></ul></li><li><p>执行引擎开始执行字节码</p></li></ol><blockquote><p>不知道这算不算汇编语言，但是跟我学过的汇编语言原理基本上一样</p></blockquote><div class="tabs" id="t2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#t2-1">bipush 10</button></li><li class="tab"><button type="button" data-href="#t2-2">istore_1</button></li><li class="tab"><button type="button" data-href="#t2-3">ldc #3</button></li><li class="tab"><button type="button" data-href="#t2-4">iload_1</button></li><li class="tab"><button type="button" data-href="#t2-5">iadd</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="t2-1"><ul><li>将一个byte压入操作数栈（其长度会补齐为4个字节），类似的指令还有</li><li>sipush：将一个short压入操作数栈（其长度会补齐为4个字节）</li><li>ldc：将一个int压入操作数栈</li><li>ldc2_w：将一个long压入操作数栈（分两次压入，因为long占8个字节）</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310271923333.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="t2-2"><p>将操作数栈顶数据弹出，存入局部变量表slot 1</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310271924884.png"> </p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="t2-3"><p>从常量池加载#3数据到操作数栈</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310271927272.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="t2-4"><p>将局部变量表slot 1的值加载到操作数栈中</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="t2-5"><p>从操作数栈顶部弹出两个int类型的数值，将这两个数值相加，并将其结果压入操作数栈顶部；</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310271929673.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="例子-分析-i"><a href="#例子-分析-i" class="headerlink" title="例子.分析 i++"></a>例子.分析 i++</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Demo_21 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a = 10;</span><br><span class="line">        int b = a++ + ++a + a--;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请问，b是多少，为什么。</p><p>主要部分字节码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> 0: bipush        10        // 将一个byte压入操作数栈，此时就是将10压入操作数栈</span><br><span class="line"> 2: istore_1                // 将操作数栈顶部数据弹出，存入局部变量表 slot 1</span><br><span class="line"> 3: iload_1                 // 将局部变量表slot 1的值加载到操作数栈中，也就是将10加载到栈中</span><br><span class="line"> 4: iinc          1, 1      // 在当前局部变量上进行运算，自增1，此时局部变量 a = 11   至此 a++ 执行完毕</span><br><span class="line"> 7: iinc          1, 1      // 在当前局部变量上进行运算，自增1，此时局部变量 a = 12</span><br><span class="line">10: iload_1                 // 将局部变量表slot 1的值加载到操作数栈中，也就是将12加载到栈中</span><br><span class="line">11: iadd                    // 将栈内两个元素相加，10 + 12 = 22，将结果22加载到栈中</span><br><span class="line">12: iload_1                 // 将局部变量表slot 1的值加载到操作数栈中，也就是将12加载到栈中</span><br><span class="line">13: iinc          1, -1     // 在当前局部变量上进行运算，自减1，此时局部变量 a = 11</span><br><span class="line">16: iadd                    // 将栈内两个元素相加，22 + 12 = 34，结果为34</span><br><span class="line">17: istore_2                // 将操作数栈顶部数据弹出，存入局部变量表slot 2</span><br><span class="line">18: getstatic     #2        // 下面就不分析了，就是输出a和b的值</span><br><span class="line">21: iload_1</span><br><span class="line">22: invokevirtual #3                  </span><br><span class="line">25: getstatic     #2                  </span><br><span class="line">28: iload_2</span><br><span class="line">29: invokevirtual #3                  </span><br><span class="line">32: return</span><br></pre></td></tr></table></figure><p><code>iinc</code>指令是直接在局部变量slot上进行运算</p><ul><li>那么最终的结果<code>a = 11</code>，<code>b = 34</code></li><li>注意a++和++a的区别为<ul><li><code>a++</code>是先执行<code>iload</code>，再执行<code>iinc</code></li><li><code>++a</code>是先执行<code>iinc</code>，再执行<code>iload</code></li></ul></li></ul><h2 id="条件判断指令"><a href="#条件判断指令" class="headerlink" title="条件判断指令"></a>条件判断指令</h2><table><thead><tr><th align="center">指令</th><th align="center">助记符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">0x99</td><td align="center">ifeq</td><td align="center">判断是否 &#x3D;&#x3D; 0</td></tr><tr><td align="center">0x9a</td><td align="center">ifne</td><td align="center">判断是否 !&#x3D; 0</td></tr><tr><td align="center">0x9b</td><td align="center">iflt</td><td align="center">判断是否 &lt; 0</td></tr><tr><td align="center">0x9c</td><td align="center">ifge</td><td align="center">判断是否 &gt;&#x3D; 0</td></tr><tr><td align="center">0x9d</td><td align="center">ifgt</td><td align="center">判断是否 &gt; 0</td></tr><tr><td align="center">0x9e</td><td align="center">ifle</td><td align="center">判断是否 &lt;&#x3D; 0</td></tr><tr><td align="center">0x9f</td><td align="center">if_icmpeq</td><td align="center">两个int是否 &#x3D;&#x3D;</td></tr><tr><td align="center">0xa0</td><td align="center">if_icmpne</td><td align="center">两个int是否 !&#x3D;</td></tr><tr><td align="center">0xa1</td><td align="center">if_icmplt</td><td align="center">两个int是否 &lt;</td></tr><tr><td align="center">0xa2</td><td align="center">if_icmpge</td><td align="center">两个int是否 &gt;&#x3D;</td></tr><tr><td align="center">0xa3</td><td align="center">if_icmpgt</td><td align="center">两个int是否 &gt;</td></tr><tr><td align="center">0xa4</td><td align="center">if_icmple</td><td align="center">两个int是否 &lt;&#x3D;</td></tr><tr><td align="center">0xa5</td><td align="center">if_acmpeq</td><td align="center">两个引用是否 &#x3D;&#x3D;</td></tr><tr><td align="center">0xa6</td><td align="center">if_acmpne</td><td align="center">两个引用是否 !&#x3D;</td></tr><tr><td align="center">0xc6</td><td align="center">ifnull</td><td align="center">判断是否 &#x3D;&#x3D; null</td></tr><tr><td align="center">0xc7</td><td align="center">ifnonnull</td><td align="center">判断是否 !&#x3D; null</td></tr></tbody></table><div class="tabs" id="3"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#3-1">条件判断</button></li><li class="tab"><button type="button" data-href="#3-2">循环控制</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="3-1"><ul><li>原始Java代码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">复制成功public class Demo_22 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a = 0;</span><br><span class="line">        if (a == 0) &#123;</span><br><span class="line">            a = 10;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            a = 20;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译后的字节码文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AWK</span><br><span class="line"> 0: iconst_0             // 将整数常量值0（int类型）压入操作数栈中。</span><br><span class="line"> 1: istore_1             // 将栈顶数据存入局部变量表 slot 1</span><br><span class="line"> 2: iload_1              // 将局部变量表slot 1的值压入操作数栈</span><br><span class="line"> 3: ifne           12    // 判断不等于0，成立跳转至12行，不成立则执行下一行</span><br><span class="line"> 6: bipush         10    // 将10压入操作数栈</span><br><span class="line"> 8: istore_1             // 将栈顶数据存入局部变量表 slot 1</span><br><span class="line"> 9: goto           15    // 跳转至第15行</span><br><span class="line">12: bipush        20     // 将20压入操作数栈，对应 a = 20</span><br><span class="line">14: istore_1             // 将栈顶数据存入局部变量表 slot 1</span><br><span class="line">15: return</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3-2"><ul><li>原始Java代码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class Demo_23 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int a = 0;</span><br><span class="line">        while (a &lt; 10) &#123;</span><br><span class="line">            a++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译后的字节码文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AWK</span><br><span class="line"> 0: iconst_0                // 将整数常量值0（int类型）压入操作数栈中。</span><br><span class="line"> 1: istore_1                // 将栈顶数据存入局部变量表 slot 1</span><br><span class="line"> 2: iload_1                 // 将局部变量表slot 1的值压入操作数栈</span><br><span class="line"> 3: bipush        10        // 将10压入操作数栈</span><br><span class="line"> 5: if_icmpge     14        // 判断 i &gt;= 10 ，成立则跳转到14行，不成立则执行下一行</span><br><span class="line"> 8: iinc          1, 1      // i自增</span><br><span class="line">11: goto          2         // 跳转到第2行</span><br><span class="line">14: return</span><br></pre></td></tr></table></figure><ul><li>再比如<code>do while</code>循环</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class Demo_24 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        do &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; while (i &lt; 10);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译后的字节码文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AWK</span><br><span class="line"> 0: iconst_0                // 将整数常量值0（int类型）压入操作数栈中。</span><br><span class="line"> 1: istore_1                // 将栈顶数据存入局部变量表 slot 1</span><br><span class="line"> 2: iinc          1, 1      // i自增</span><br><span class="line"> 5: iload_1                 // 将局部变量表slot 1加载到操作数栈</span><br><span class="line"> 6: bipush        10        // 将10加载到操作数栈</span><br><span class="line"> 8: if_icmplt     2         // 判断 i &lt; 10，成立则跳转到第2行，不成立执行下一行</span><br><span class="line">11: return</span><br></pre></td></tr></table></figure><ul><li>最后再来看看for循环</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line">public class Demo_25 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译后的字节码文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NESTEDTEXT</span><br><span class="line"> 0: iconst_0</span><br><span class="line"> 1: istore_1</span><br><span class="line"> 2: iload_1</span><br><span class="line"> 3: bipush        10</span><br><span class="line"> 5: if_icmpge     14</span><br><span class="line"> 8: iinc          1, 1</span><br><span class="line">11: goto          2</span><br><span class="line">14: return</span><br></pre></td></tr></table></figure><blockquote><p>注意到while和for的字节码，它们是一模一样的</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><div class="tabs" id="4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#4-1">< cinit >()V</button></li><li class="tab"><button type="button" data-href="#4-2">< init >()V</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="4-1"><ul><li>编译器会按照从上至下的顺序，收集所有的static静态代码块和静态成员赋值的代码，合并成一个特殊的方法<code>&lt;cinit&gt;()V</code></li><li><code>&lt;cinit&gt;()V</code>方法会在类加载的初始化阶段被调用</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="4-2"><ul><li>编译器会按照从上至下的顺序，收集所有代码块和所有成员变量赋值的代码，形成新的构造方法，但原始构造方法内的代码总是会在最后</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>看一下几种不同方法调用对应的字节码指令，私有方法，final方法，公共方法，静态方法</p><ul><li><p>其中静态方法包括对象调静态方法和类直接调静态方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Demo_29 &#123;</span><br><span class="line">    public Demo_29()&#123;&#125;</span><br><span class="line">    private void test1()&#123;&#125;</span><br><span class="line">    private final void test2()&#123;&#125;</span><br><span class="line">    public void test3()&#123;&#125;</span><br><span class="line">    public static void test4()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Demo_29 demo = new Demo_29();</span><br><span class="line">        demo.test1();</span><br><span class="line">        demo.test2();</span><br><span class="line">        demo.test3();</span><br><span class="line">        demo.test4();</span><br><span class="line">        Demo_29.test4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编译后的字节码文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> 0: new           #2                  // class com/demo/Demo_29</span><br><span class="line"> 3: dup</span><br><span class="line"> 4: invokespecial #3                  // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line"> 7: astore_1</span><br><span class="line"> 8: aload_1</span><br><span class="line"> 9: invokespecial #4                  // Method test1:()V</span><br><span class="line">12: aload_1</span><br><span class="line">13: invokespecial #5                  // Method test2:()V</span><br><span class="line">16: aload_1</span><br><span class="line">17: invokevirtual #6                  // Method test3:()V</span><br><span class="line">20: aload_1</span><br><span class="line">21: pop</span><br><span class="line">22: invokestatic  #7                  // Method test4:()V</span><br><span class="line">25: invokestatic  #7                  // Method test4:()V</span><br><span class="line">28: return</span><br></pre></td></tr></table></figure></li><li><p>new #2是创建Demo_29对象，给对象分配内存，执行成功会将<code>对象引用</code>压入操作数栈</p></li><li><p>dup是赋值操作数栈顶的内容，本例为对象引用。那为什么需要两份引用呢？</p><ul><li>一个是要配合<code>invokespecial</code>调用该对象的构造方法<code>&quot;&lt;init&gt;:()V&quot;</code>，会消耗掉栈顶一个引用</li><li>另一个要配合<code>astore_1</code>赋值给局部变量</li></ul></li><li><p>final方法、私有方法、构造方法，都是由invokespecial指令来调用，属于静态绑定</p></li><li><p>普通成员方法是由invokevirtual调用，属于动态绑定，即支持多态</p></li><li><p>成员方法与静态方法调用的另一个区别是，执行方法前是否需要<code>对象引用</code></p></li><li><p>比较有意思的是，执行demo.test4()时，是通过<code>对象引用</code>调用的静态方法，可以看到在调用前执行了pop指令，把对象引用从操作数栈弹掉了，因为静态方法不需要对象引用来掉，通过这种方式，反而会增加两步无用的字节码指令</p></li></ul><h2 id="多态的原理"><a href="#多态的原理" class="headerlink" title="多态的原理"></a>多态的原理</h2><p>原始Java代码</p><ul><li>定义了一个抽象类Animal，还有其两个子类Cat和Dog</li></ul><h1 id="编译期处理（语法糖）"><a href="#编译期处理（语法糖）" class="headerlink" title="编译期处理（语法糖）"></a>编译期处理（语法糖）</h1><ul><li>所谓<code>语法糖</code>，其实就是指Java编译器把<code>.java</code>编译为<code>.class</code>字节码的过程中，自动生成的和转换的一些代码，主要是为了减轻程序员的负担，算是Java编译器给我们的一个额外福利</li><li>下面的代码分析，借助了javap工具、idea的反编译功能、idea插件jclasslib等工具。另外，编译器转换的结果直接就是class字节码，只是为了便于阅读，给出了<code>几乎等价</code>的Java源码</li></ul><h2 id="默认构造器"><a href="#默认构造器" class="headerlink" title="默认构造器"></a>默认构造器</h2><p>如果一个类没有声明任何构造函数，Java 编译器会自动为该类生成一个无参构造函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Candy01 &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译成class后的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Candy1 &#123;</span><br><span class="line"></span><br><span class="line">    // 这个无参构造是编译器帮助我们加上的</span><br><span class="line">    public Candy1() &#123;</span><br><span class="line">        super(); // 即调用父类 Object 的无参构造方法，即调用 java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h2><p>这个特性是 <code>JDK 5</code> 开始加入的，<code>代码片段1：</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Candy02 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer x = 1;</span><br><span class="line">        int y = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这段代码在<code>JDK 5</code>之前是无法编译通过的，比如改写为如下形式，<code>代码片段2</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Candy02 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer x = Integer.valueOf(1);</span><br><span class="line">        int y = x.intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>显然之前版本的代码太麻烦了，需要在基本类型和包装类型之间相互转换（尤其是集合类中的操作都是包装类型），因此这些转换的事情在<code>JDK 5</code>以后都由编译器在编译阶段完成。即<code>代码片段1</code>都会在编译阶段转换成<code>代码片段2</code></p><h2 id="泛型集合取值"><a href="#泛型集合取值" class="headerlink" title="泛型集合取值"></a>泛型集合取值</h2><p>泛型也是<code>JDK 5</code>开始加入的特性，但Java在编译泛型后会执行<code>泛型擦除</code>的动作，即泛型信息在编译为字节码后就丢失了，实际的类型都当做Object类型来处理</p><blockquote><p>注意是编译后，编译前编译器帮你确保类型不会出问题才擦除的</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Candy03 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(10);               // 实际调用的是 List.add(Object e)</span><br><span class="line">        Integer x = list.get(0);    // 实际调用的是 Object obj = List.get(int index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>可变参数也是<code>JDK 5</code>开始加入的新特性，示例代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Candy04 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        foo(&quot;hello&quot;, &quot;world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void foo(String... args) &#123;</span><br><span class="line">        String[] array = args;</span><br><span class="line">        System.out.println(array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可变参数String… args 其实是一个String[] args，同样Java编译器会在编译期间将上述代码转换为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Candy04 &#123;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        foo(new String[]&#123;&quot;hello&quot;, &quot;world&quot;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void foo(String[] args) &#123;</span><br><span class="line">        String[] array = args;          // 直接赋值</span><br><span class="line">        System.out.println(array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意如果调用foo()时没有提供任何参数，那么则等价为foo(new String)，创建了一个空的数组，而不是传一个null进去</p></blockquote><h2 id="foreach循环"><a href="#foreach循环" class="headerlink" title="foreach循环"></a>foreach循环</h2><p>仍然是JDK 5开始引入的语法糖，数组的循环</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Candy05 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] array = &#123;1, 2, 3, 4, 5&#125;;      // 数组的赋初值的简化，也是语法糖 new int[]&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">        for (int a : array) &#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会被编译器转换为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Candy05 &#123;</span><br><span class="line">    public Candy05() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] array = new int[]&#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">        for(int i = 0; i &lt; array.length; ++i) &#123;</span><br><span class="line">            int e = array[i];</span><br><span class="line">            System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而集合的循环</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Candy06 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5);</span><br><span class="line">        for (Integer integer : list) &#123;</span><br><span class="line">            System.out.println(integer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上会被编译器转换为对迭代器的调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Candy06 &#123;</span><br><span class="line">    public Candy06() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5);</span><br><span class="line">        Iterator iterator = list.iterator();</span><br><span class="line">        while (iterator.hasNext())&#123;</span><br><span class="line">            Integer next = (Integer) iterator.next();</span><br><span class="line">            System.out.println(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>foreach循环写法，能够配合数组，以及所有实现了Iterable接口的集合类一起使用，其中Iterable用来获取集合的迭代器Iterator</p></blockquote><h2 id="switch字符串"><a href="#switch字符串" class="headerlink" title="switch字符串"></a>switch字符串</h2><p>从<code>JDK 7</code>开始，switch可以作用于字符串和枚举类，这个功能其实也是语法糖</p><div class="tabs" id="5"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#5-1">字符串</button></li><li class="tab"><button type="button" data-href="#5-2">枚举类</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="5-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Candy07 &#123;</span><br><span class="line">    public static void choose(String str) &#123;</span><br><span class="line">        switch (str) &#123;</span><br><span class="line">            case &quot;hello&quot;: &#123;</span><br><span class="line">                System.out.println(&quot;h&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case &quot;world&quot;: &#123;</span><br><span class="line">                System.out.println(&quot;w&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会被编译器转换为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Candy07 &#123;</span><br><span class="line">    public Candy07() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void choose(String str) &#123;</span><br><span class="line">        byte x = -1;</span><br><span class="line">        switch (str.hashCode()) &#123;</span><br><span class="line">            case 99162322:                  // hello 的 hashCode</span><br><span class="line">                if (str.equals(&quot;hello&quot;)) &#123;</span><br><span class="line">                    x = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case 113318802:                 // world 的 hashCode</span><br><span class="line">                if (str.equals(&quot;world&quot;)) &#123;</span><br><span class="line">                    x = 1;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        switch (x) &#123;</span><br><span class="line">            case 0:</span><br><span class="line">                System.out.println(&quot;h&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case 1:</span><br><span class="line">                System.out.println(&quot;w&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看到，执行了两遍switch，第一遍是根据字符串的hashCode和queals将字符串转换为相应byte类型，第二遍才是利用byte进行比较</li><li>那为什么第一遍既要比较hashCode又利用equals比较呢？<ul><li>hashCode是为了提高效率，减少可能的比较</li><li>而equals是为了防止哈希冲突，例如<code>BM</code>和<code>C.</code>这两个字符串的hashCode值都是2123，例如下面的代码</li></ul></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="5-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">enum Sex &#123;</span><br><span class="line">    MALE, FEMALE</span><br><span class="line">&#125;</span><br><span class="line">public  static void foo(Sex sex)&#123;</span><br><span class="line">    switch (sex)&#123;</span><br><span class="line">        case MALE:</span><br><span class="line">            System.out.println(&quot;男&quot;);</span><br><span class="line">            break;</span><br><span class="line">        case FEMALE:</span><br><span class="line">            System.out.println(&quot;女&quot;);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Candy08 &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 定义一个合成类（仅 jvm 使用，对我们不可见）</span><br><span class="line">     * 用来映射枚举的 ordinal 与数组元素的关系</span><br><span class="line">     * 枚举的 ordinal 表示枚举对象的序号，从 0 开始</span><br><span class="line">     * 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1</span><br><span class="line">     */</span><br><span class="line">    static class $MAP &#123;</span><br><span class="line">        // 数组大小即为枚举元素个数，里面存储case用来对比的数字</span><br><span class="line">        static int[] map = new int[2];</span><br><span class="line"></span><br><span class="line">        static &#123;</span><br><span class="line">            map[Sex.MALE.ordinal()] = 1;</span><br><span class="line">            map[Sex.FEMALE.ordinal()] = 2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void foo(Sex sex) &#123;</span><br><span class="line">        int x = $MAP.map[sex.ordinal()];</span><br><span class="line">        switch (x) &#123;</span><br><span class="line">            case 1:</span><br><span class="line">                System.out.println(&quot;男&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                System.out.println(&quot;女&quot;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>JDK 7 新增了枚举类，以前面的性别枚举为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum Sex &#123;</span><br><span class="line">    MALE, FEMALE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换后的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public final class Sex extends Enum&lt;Sex&gt; &#123;</span><br><span class="line">    public static final Sex MALE;</span><br><span class="line">    public static final Sex FEMALE;</span><br><span class="line">    private static final Sex[] $VALUES;</span><br><span class="line">    static &#123;</span><br><span class="line">        MALE = new Sex(&quot;MALE&quot;, 0);</span><br><span class="line">        FEMALE = new Sex(&quot;FEMALE&quot;, 1);</span><br><span class="line">        $VALUES = new Sex[]&#123;MALE, FEMALE&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Sole constructor. Programmers cannot invoke this constructor.</span><br><span class="line">     * It is for use by code emitted by the compiler in response to</span><br><span class="line">     * enum type declarations.</span><br><span class="line">     *</span><br><span class="line">     * @param name    - The name of this enum constant, which is the identifier</span><br><span class="line">     *                used to declare it.</span><br><span class="line">     * @param ordinal - The ordinal of this enumeration constant (its position</span><br><span class="line">     *                in the enum declaration, where the initial constant is</span><br><span class="line">     *                assigned</span><br><span class="line">     */</span><br><span class="line">    private Sex(String name, int ordinal) &#123;</span><br><span class="line">        super(name, ordinal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Sex[] values() &#123;</span><br><span class="line">        return $VALUES.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Sex valueOf(String name) &#123;</span><br><span class="line">        return Enum.valueOf(Sex.class, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Sex</code>被声明为一个<code>final</code>类，它继承了<code>Enum&lt;Sex&gt;</code>类，Enum是Java中定义枚举的抽象类。MALE和FEMALE是Sex类的两个枚举值，它们被定义为静态常量。</li><li>除此之外，还有一个私有的、<code>final</code>的<code>Sex</code>类型数组<code>$VALUES</code>，它用于存储Sex类的所有枚举值。在类的静态块中，<code>$VALUES</code>数组被初始化为一个包含<code>MALE</code>和<code>FEMALE</code>的数组。</li><li>构造函数<code>Sex(String name, int ordinal)</code>是私有的，这意味着无法在类的外部使用这个构造函数来创建<code>Sex</code>的实例。只有Java编译器生成的代码才能调用这个构造函数来创建Sex的实例。</li><li><code>values()</code>和<code>valueOf(String name)</code>是从Enum类继承的两个静态方法。<code>values()</code>方法返回一个包含Sex类所有枚举值的数组，<code>valueOf(String name)</code>方法返回指定名称的枚举值。</li><li>当我们使用MALE或者FEMALE时，其实底层调用的是<code>Enum.valueOf(Sex.class, &quot;MALE&quot;)</code>和<code>Enum.valueOf(Sex.class, &quot;FEMALE&quot;)</code></li></ul><h2 id="方法重写时的桥接方法"><a href="#方法重写时的桥接方法" class="headerlink" title="方法重写时的桥接方法"></a>方法重写时的桥接方法</h2><p>方法重写时，对返回值分两种情况</p><ol><li>父类与子类的返回值完全一致</li><li>子类返回值可以是父类返回值的子类（比较绕口，直接看下面的例子来理解）</li></ol><p>这也是为什么重写不能拓展父类方法的返回范围</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    public Number m() &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A &#123;</span><br><span class="line">    @Override</span><br><span class="line">    // 父类A方法的返回值是Number类型，子类B方法的返回值是Integer类型，Integer是Number的子类</span><br><span class="line">    public Integer m() &#123;</span><br><span class="line">        return 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>那么对于子类，编译器会做如下处理</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class B extends A &#123;</span><br><span class="line">    public Integer m() &#123;</span><br><span class="line">        return 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 此方法才是真正重写了父类 public Number m() 方法</span><br><span class="line">    public synthetic bridge Number m() &#123;</span><br><span class="line">        // 调用 public Integer m()</span><br><span class="line">        return m();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的桥接方法比较特殊，仅对Java虚拟机课件，并且与原来的public Integer m()没有命名冲突</p><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>原始Java代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Candy10 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Runnable runnable = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;ok&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换后代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 额外生成的类</span><br><span class="line">final class Candy10$1 implements Runnable &#123;</span><br><span class="line">    Candy10$1() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;ok&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Candy10 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Runnable runnable = new Candy10$1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于匿名内部类，它的底层实现是类似于普通内部类的，只不过没有命名而已。在生成匿名内部类的class文件时，Java编译器会自动为该类生成一个类名，在原始类名上加后缀<code>$1</code>，如果有多个匿名内部类，则<code>$2</code>、<code>$3</code>以此类推</p><p>引用局部变量的匿名内部类，原始Java代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Candy11 &#123;</span><br><span class="line">    public static void test(final  int x)&#123;</span><br><span class="line">        Runnable runnable = new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(&quot;ok&quot; + x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换后代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 额外生成的类</span><br><span class="line">final class Candy11$1 implements Runnable &#123;</span><br><span class="line">    int val$x;</span><br><span class="line">    Candy11$1(int x) &#123;</span><br><span class="line">        this.val$x = x;</span><br><span class="line">    &#125;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;ok:&quot; + this.val$x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Candy11 &#123;</span><br><span class="line">    public static void test(final int x) &#123;</span><br><span class="line">        Runnable runnable = new Candy11$1(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：这也解释了为什么匿名内部类引用局部变量时，局部变量必须为final的</p><ul><li>因为在创建Candy$11对象时，将x的值赋给了val$x属性，所以x不应该再发生变化了</li><li>如果变化，那么$val$x属性没有机会再跟着一起变化</li></ul><h1 id="类加载阶段"><a href="#类加载阶段" class="headerlink" title="类加载阶段"></a>类加载阶段</h1><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>将类的字节码载入方法区中，内部采用C++的instanceKlass描述Java类，它的重要field有</p><ol><li>_java_mirror：Java的类镜像，例如对String来说，就是String.class，作用是把klass暴露给Java使用</li><li>_super：父类</li><li>_fields：成员变量</li><li>_methods：方法</li><li>_constants：常量池</li><li>_class_loader：类加载器</li><li>_vtable：需方发表</li><li>_itable：接口方法表</li></ol><p>如果这个类还有父类没有加载，先加载父类</p><p>加载和链接可能是交替运行的</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><ul><li>验证类是否符合JVM规范，安全性检查</li><li>使用支持二进制的编辑器修改HelloWorld.class的魔数<code>ca fe ba be</code>，在控制台运行后一定报错</li></ul><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>为static变量分配空间，设置默认值</p><ul><li>static变量在<code>JDK 7</code>之前存储于instanceKlass末尾，从<code>JDK 7</code>开始，存储于_java_mirror末尾</li><li>static变量分配空间和赋值是两个步骤，分配空间在准备阶段完成，赋值在初始化阶段完成</li><li>如果static遍历是final的基本类型以及字符串常量，那么编译阶段值就确定了，赋值在准备阶段完成</li><li>如果static遍历是final的，但属于引用类型，那么赋值也会在初始化阶段完成</li></ul><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>将常量池中的符号引用解析为直接引用</p><ul><li>默认情况下，类的加载都是懒惰式的，如果用到了类C，没有用到类D的话，那么类D是不会主动加载的</li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul><li>初始化即调用<code>&lt;cinit&gt;()V</code> 方法，虚拟机ui保证这个类的<code>构造方法</code>的线程安全</li></ul><p>发生的时机：总的来说，类的初始化是懒惰的</p><ol><li>main方法所在的类，总会被首先初始化</li><li>首次访问这个类的静态变量或静态方法时，会进行初始化</li><li>子类初始化，如果父类还没未初始化，则父类也会进行初始化</li><li>默认的Class.forName会导致初始化</li><li>new对象会导致初始化</li></ol><p>不会导致类初始化的情况</p><ol><li>访问类的 static final 静态常量（基本类型和字符串） 不会触发初始化</li><li>调用类对象.class不会触发初始化</li><li>类加载器的loadClass方法不会触发初始化</li><li>Class.forName的参数2为false时(initalize &#x3D; false)，不会触发初始化</li></ol><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><ul><li>以<code>JDK 8</code>为例</li></ul><table><thead><tr><th align="center">名称</th><th align="center">加载哪的类</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Bootstrap ClassLoader</td><td align="center">JAVA_HOME&#x2F;jre&#x2F;lib</td><td align="center">无法直接访问</td></tr><tr><td align="center">Extension ClassLoader</td><td align="center">JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext</td><td align="center">上级为 Bootstrap，显示为 null</td></tr><tr><td align="center">Application ClassLoader</td><td align="center">classpath</td><td align="center">上级为 Extension</td></tr><tr><td align="center">自定义类加载器</td><td align="center">自定义 上级为</td><td align="center">Application</td></tr></tbody></table><ul><li>当JVM需要加载一个类时，它会首先委托父类加载器去加载这个类，如果父类加载器无法加载这个类，就会由当前类加载器来加载。如果所有的父类加载器都无法加载这个类，那么就会抛出ClassNotFoundException异常。</li></ul><h2 id="引导类加载器"><a href="#引导类加载器" class="headerlink" title="引导类加载器"></a>引导类加载器</h2><ul><li><code>Bootstrap ClassLoader</code>是所有类加载器中最早的一个，负责加载JRE&#x2F;lib下的核心类库，如java.lang.Object、java.lang.String等。</li></ul><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><h3 id="双亲"><a href="#双亲" class="headerlink" title="双亲"></a>双亲</h3><ul><li>所谓双亲委派机制，就是指调用类加载器的loadClass方法时，查找类的规则</li><li>既然称为双亲委派机制，则双亲是必须存在的。ClassLoader类存在一个parent属性。因此可以配置双亲。这个双亲是指ExtClassLoader和AppClassLoader，在JDK中则是这样设置：</li><li>ExtClassLoader.parent&#x3D;null;</li><li>AppClassLoader.parent&#x3D;ExtClassLoader</li><li>XXXClassLoader.parent&#x3D;AppClassLoader</li><li>自定义的类加载器在构建时，如果未指定parent，则使用getSystemClassLoader()来获取父类加载器，而该方法默认获取的就是AppClassLoader。</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310272038937.png"></p><h3 id="委派"><a href="#委派" class="headerlink" title="委派"></a>委派</h3><p>委派过程也就是类文件加载过程，</p><p>加载类文件之前，先验证是否被加载过了，如果加载过就不再加载，防止被覆盖掉，也防止多次加载浪费资源。然后获取类加载器的parent</p><ul><li>如果parent不存在，则说明本身已经是ExtClassLoader了，则查询下类文件是否被Bootstrap ClassLoader加载过，找到就返回，否则返回null。</li><li>如果parent存在，则让父类加载器去加载类文件，这个过程是往上递推的，如 parent-&gt;parent-&gt;parent</li><li>以上流程处理完毕，如果发现返回的是null则说明已经递推到了Bootstrap ClassLoader且仍不能加载，则说明该类文件不符合所有的父类加载器的加载条件，于是便轮到自己来加载了。</li></ul><p>上面说明中往上递推的过程就是委派了，而递推的方式是parent，于是就称为双亲委派机制。当然通俗理解是父类加载器优先加载模式。</p><h2 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h2><p>我们在使用JDBC时，都需要加载Driver驱动，但是我们好像并没有显示的调用Class.forName来加载Driver类</p><p>追一下源码，这里只看最核心的部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class DriverManager &#123;</span><br><span class="line"></span><br><span class="line">    private final static CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    ···</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        loadInitialDrivers();</span><br><span class="line">        println(&quot;JDBC DriverManager initialized&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ···</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出一下DirverManager的类加载器是谁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(DriverManager.class.getClassLoader());</span><br></pre></td></tr></table></figure><ul><li>输出的结果是<code>null</code>，那么说明它是由<code>Bootstrap ClassLoader</code>加载的，那么按理说应该是去<code>JAVA_HOMT/jre/lib</code>下搜索驱动类。</li><li>但<code>JAVA_HOMT/jre/lib</code>显然没有mysql-connector-java-5.7.31.jar包，在DriverManager的静态代码块中，是如何正确加载<code>com.mysql.jdbc.Driver</code>的呢？</li><li>继续来看看loadInitialDrivers()方法的源码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">private static void loadInitialDrivers() &#123;</span><br><span class="line">    String drivers;</span><br><span class="line">    try &#123;</span><br><span class="line">        drivers = AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() &#123;</span><br><span class="line">            public String run() &#123;</span><br><span class="line">                return System.getProperty(&quot;jdbc.drivers&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; catch (Exception ex) &#123;</span><br><span class="line">        drivers = null;</span><br><span class="line">    &#125;</span><br><span class="line">    // If the driver is packaged as a Service Provider, load it.</span><br><span class="line">    // Get all the drivers through the classloader</span><br><span class="line">    // exposed as a java.sql.Driver.class service.</span><br><span class="line">    // ServiceLoader.load() replaces the sun.misc.Providers()</span><br><span class="line"></span><br><span class="line">    // 1. 使用 ServiceLoader 机制加载驱动，即 SPI</span><br><span class="line">    AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">        public Void run() &#123;</span><br><span class="line"></span><br><span class="line">            ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</span><br><span class="line">            Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span><br><span class="line"></span><br><span class="line">            /* Load these drivers, so that they can be instantiated.</span><br><span class="line">             * It may be the case that the driver class may not be there</span><br><span class="line">             * i.e. there may be a packaged driver with the service class</span><br><span class="line">             * as implementation of java.sql.Driver but the actual class</span><br><span class="line">             * may be missing. In that case a java.util.ServiceConfigurationError</span><br><span class="line">             * will be thrown at runtime by the VM trying to locate</span><br><span class="line">             * and load the service.</span><br><span class="line">             *</span><br><span class="line">             * Adding a try catch block to catch those runtime errors</span><br><span class="line">             * if driver not available in classpath but it&#x27;s</span><br><span class="line">             * packaged as service and that service is there in classpath.</span><br><span class="line">             */</span><br><span class="line">            try&#123;</span><br><span class="line">                while(driversIterator.hasNext()) &#123;</span><br><span class="line">                    driversIterator.next();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch(Throwable t) &#123;</span><br><span class="line">            // Do nothing</span><br><span class="line">            &#125;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    println(&quot;DriverManager.initialize: jdbc.drivers = &quot; + drivers);</span><br><span class="line"></span><br><span class="line">    // 2. 使用 jdbc.drivers 定义的驱动名加载驱动</span><br><span class="line">    if (drivers == null || drivers.equals(&quot;&quot;)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] driversList = drivers.split(&quot;:&quot;);</span><br><span class="line">    println(&quot;number of Drivers:&quot; + driversList.length);</span><br><span class="line">    for (String aDriver : driversList) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            println(&quot;DriverManager.Initialize: loading &quot; + aDriver);</span><br><span class="line">            Class.forName(aDriver, true,</span><br><span class="line">                    ClassLoader.getSystemClassLoader());</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            println(&quot;DriverManager.Initialize: load failed: &quot; + ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>先看2，它最后是使用的Class.forName完成类的加载和初始化，关联的是应用类加载器，因此可以顺利完成驱动类的加载</p></li><li><p>在看1，它就是大名鼎鼎的Service Provider Interface（SPI）</p><ul><li>约定如下，在jar包的META-INF&#x2F;services包下，以接口全限定名名为文件，文件内容是实现类名称</li><li>这样就可以使用如下代码遍历来得到实现类</li></ul></li><li><p>体现的是面向接口编程 + 解耦的思想，在下面的一些框架中都运用了此思想</p><ul><li>JDBC</li><li>Servlet初始化器</li><li>Spring容器</li><li>Dubbo（对SPI进行了扩展）</li></ul></li></ul><h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><p>先来思考一下：什么时候需要自定义类加载器</p><ol><li>自定义类加载器可用于加载非 Classpath 路径中的类文件，例如外部配置文件夹、网络资源或其他自定义路径。这种需求在一些动态扩展或插件化的场景中比较常见。</li><li>在应用程序中使用的类可以通过接口来使用，而不是直接引用类。这种做法可以减少应用程序之间的依赖，从而提高代码的灵活性和可维护性。同时，这种做法也使得框架的设计更加清晰和可扩展。</li><li>在Tomcat容器中，每个Web应用程序都使用自己的类加载器，从而避免了不同Web应用程序之间的类冲突问题。</li></ol><p>步骤</p><ol><li>继承ClassLoader类</li><li>遵从双亲委派机制，重写findClass方法<ul><li>注意不要重写loadClass方法，否则不会走双亲委派机制</li></ul></li><li>读取类文件的字节码</li><li>调用父类的defineClass方法来加载类</li><li>使用者调用类加载器的loadClass方法</li></ol><h1 id="运行期优化"><a href="#运行期优化" class="headerlink" title="运行期优化"></a>运行期优化</h1><h2 id="即时编译"><a href="#即时编译" class="headerlink" title="即时编译"></a>即时编译</h2><h3 id="分层编译（TieredComlilation）"><a href="#分层编译（TieredComlilation）" class="headerlink" title="分层编译（TieredComlilation）"></a>分层编译（TieredComlilation）</h3><p>JVM将执行状态分为5个层次</p><ul><li>0层：解释执行（Interpreter）<ul><li>在0层，JVM使用解释器来直接解释Java字节码，并执行程序。这种方式简单但效率较低，因为解释器需要逐条解释字节码指令，并执行它们，每次执行时都需要对字节码进行解析</li></ul></li></ul><ul><li>1层：使用C1即时编译器编译执行（不带profilling）<ul><li>在1层，JVM会使用即时编译器（JIT）将Java字节码编译成本地机器码，然后直接执行机器码。这种方式相比于解释器，可以提供更高的执行速度。C1即时编译器适合编译执行热点代码，即被频繁执行的代码</li></ul></li><li>2层：使用C1即时编译器编译执行（带基本的profilling）<ul><li>在2层，JVM会收集一些基本的执行状态数据，即profilling。例如方法的调用次数、循环的回边次数等，然后根据这些数据来决定哪些代码块需要被编译执行。这种方式可以更加精确地编译热点代码，从而提高程序的执行速度</li></ul></li><li>3层：使用C1即时编译器编译执行（带完全的profilling）<ul><li>在3层，JVM会收集更加详细的执行状态数据，例如内联调用的次数、方法的参数类型等，以便更好地优化代码。这种方式可以进一步提高程序的执行速度，但同时也会增加编译的开销</li></ul></li><li>4层：使用C2即时编译器编译执行<ul><li>在4层，JVM会使用更高级别的即时编译器（C2）来对代码进行优化，包括对循环、分支和递归等结构的优化。C2编译器的编译时间比C1场，但编译出来的代码执行速度更快。</li></ul></li></ul><h4 id="即时编译器（JIT）和解释器的区别"><a href="#即时编译器（JIT）和解释器的区别" class="headerlink" title="即时编译器（JIT）和解释器的区别"></a>即时编译器（JIT）和解释器的区别</h4><ul><li>解释器是将字节码解释为机器码，下次即使遇到相同的字节码，仍会执行重复的解释</li><li>JIT是将一些字节码编译为机器码，并存入<code>Code Cache</code>，下次遇到相同的代码，<code>直接执行</code>，无需再次编译</li><li>解释器是将字节码解释为针对所有平台都通用的机器码</li><li>JIT会根据平台类型，生成平台特定的机器码</li></ul><p>对于占据大部分的不常用的代码，我们无需耗费时间将其编译成<code>机器码</code>，而是采用<code>解释器执行</code>的方法运行；</p><p>另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成<code>机器码</code>，以达到理想的运行<code>速度</code>。</p><p>执行效率上简单比较一下：<code>Interceptor &lt; C1 &lt; C2</code></p><p>上面代码中最后的耗时都在300附近，这是C2即时编译器做了逃逸分析，因为上面的代码中，我们仅仅是创建了Object对象，而并没有使用它，也就是没有逃逸出当前作用域</p><ul><li>在进行逃逸分析时，JVM会分析对象是否可能被线程外的代码引用，如果对象不会逃逸出当前方法的作用域，那么JVM会将对象的分配<code>优化为栈上分配</code>，从而避免了堆内存的分配和垃圾回收的压力。</li></ul><p>将对象分配在栈上的优点是：</p><ol><li><code>快速分配和回收</code>：栈内存的分配和回收都非常快，比堆内存要快得多。如果对象可以在栈上分配，那么它的分配和回收都可以更快，从而提高程序的性能。</li><li><code>减少垃圾回收</code>：在Java中，对象的分配和回收是由垃圾回收器来完成的。如果对象可以在栈上分配，那么它就不会对堆内存的使用和垃圾回收产生影响，从而可以减少垃圾回收的频率和时间，提高程序的性能。</li></ol><h3 id="方法内联-Inlining"><a href="#方法内联-Inlining" class="headerlink" title="方法内联(Inlining)"></a>方法内联(Inlining)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static int square(int i) &#123;</span><br><span class="line">    return i * i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(square(9));</span><br></pre></td></tr></table></figure><ul><li>如果发现square是热点方法，且长度不太长时，会进行内联，所谓的内联就是把方法内代码拷贝，并粘贴到调用者的位置</li></ul><h2 id="反射优化"><a href="#反射优化" class="headerlink" title="反射优化"></a>反射优化</h2><ul><li><p>示例代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public class Reflect1 &#123;</span><br><span class="line">    public static void foo() &#123;</span><br><span class="line">        System.out.println(&quot;foo...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Method foo = Reflect1.class.getMethod(&quot;foo&quot;);</span><br><span class="line">        for (int i = 0; i &lt;= 16; i++) &#123;</span><br><span class="line">            System.out.printf(&quot;%d\t&quot;, i);</span><br><span class="line">            foo.invoke(null);</span><br><span class="line">        &#125;</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>首先定义了一个名为<code>foo</code>的静态方法，该方法只是简单地输出一条字符串。</p></li><li><p>然后在main方法中，使用<code>Reflect1</code>类的<code>getMethod</code>方法获取名为<code>foo</code>的<code>Method</code>对象，以便之后进行反射调用。</p></li><li><p>接着使用循环调用反射方法，循环次数从0到16，每次循环都调用反射获取的Method对象的<code>invoke</code>方法，传入<code>null</code>作为静态方法的调用者。因为<code>foo</code>方法是静态方法，所以调用者可以为null。</p></li><li><p>最后使用<code>System.in.read()</code>方法暂停程序的运行，以便我们可以观察程序的输出结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package sun.reflect;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import sun.reflect.misc.ReflectUtil;</span><br><span class="line"></span><br><span class="line">class NativeMethodAccessorImpl extends MethodAccessorImpl &#123;</span><br><span class="line">    private final Method method;</span><br><span class="line">    private DelegatingMethodAccessorImpl parent;</span><br><span class="line">    private int numInvocations;</span><br><span class="line"></span><br><span class="line">    NativeMethodAccessorImpl(Method var1) &#123;</span><br><span class="line">        this.method = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object invoke(Object var1, Object[] var2) throws IllegalArgumentException, InvocationTargetException &#123;</span><br><span class="line">        if (++this.numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(this.method.getDeclaringClass())) &#123;</span><br><span class="line">            MethodAccessorImpl var3 = (MethodAccessorImpl)(new MethodAccessorGenerator()).generateMethod(this.method.getDeclaringClass(), this.method.getName(), this.method.getParameterTypes(), this.method.getReturnType(), this.method.getExceptionTypes(), this.method.getModifiers());</span><br><span class="line">            this.parent.setDelegate(var3);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return invoke0(this.method, var1, var2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void setParent(DelegatingMethodAccessorImpl var1) &#123;</span><br><span class="line">        this.parent = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static native Object invoke0(Method var0, Object var1, Object[] var2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>前15次调用使用的是NativeMethodAccessorImpl实现的MethodAccessor，该实现类使用JNI调用底层的C&#x2F;C++代码实现方法调用。由于NativeMethodAccessorImpl的实现开销较大，因此前15次的反射调用的性能相对较差。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static int inflationThreshold = 15;</span><br></pre></td></tr></table></figure></li><li><p>而第16次调用则采用了GeneratedMethodAccessor1实现的MethodAccessor，这个实现类通常是使用Java字节码动态生成的，因此方法调用的性能比NativeMethodAccessorImpl更好。这是因为在第15次调用时，生成了一个新的MethodAccessorImpl实现类（MethodAccessorGenerator），并在下一次方法调用时使用该实现类，即第16次调用。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 字节码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-垃圾回收</title>
      <link href="/2023/07/16/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
      <url>/2023/07/16/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="如何判断对象可以回收"><a href="#如何判断对象可以回收" class="headerlink" title="如何判断对象可以回收"></a>如何判断对象可以回收</h1><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><ul><li><p>当一个对象被引用是，就当引用对象的值<code>+1</code>，当引用对象的值为<code>0</code>时，则说明该对象没有被引用，那么就可以被垃圾回收器回收</p></li><li><p>这个引用计数法听起来很不错，而且实现起来也非常的简单，可是它有一个弊端，如下图所示，当两个对象循环引用时，两个对象的计数都未1，就导致这两个对象都无法被释放</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310261833901.png"></p></li></ul><h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>JVM垃圾回收机制的可达性分析算法，是一种基于引用的垃圾回收算法。其基本思想是通过一系列被称为”GC Roots”的根对象作为起点，寻找所有被根对象直接或间接引用的对象，将这些对象称为”可达对象”，而没有被找到的对象则被视为”不可达对象”，需要被回收。</p><blockquote><p>形象一点理解就是我有一串葡萄，我把这串葡萄拿起来，连在根上的葡萄就是好的(可达对象)，而掉在盘子里的葡萄就是坏的(不可达对象)，需要被回收</p></blockquote><p>在JVM中，有四种类型的GC Roots对象：</p><ol><li><code>虚拟机栈中引用的对象</code>：虚拟机栈是用于存储方法调用和执行的栈空间。当一个方法被调用时，会在栈中创建一个栈帧，用于存储该方法的局部变量、参数和返回值等信息。如果栈帧中包含对某个对象的引用，那么这个对象就被视为GC Roots对象。</li><li><code>方法区中类静态属性引用的对象</code>：方法区是用于存储类信息、常量池、静态变量等信息的内存区域。当一个类被加载到方法区时，其中的静态属性会被分配在方法区中，如果这些静态属性中包含对某个对象的引用，那么这个对象就被视为GC Roots对象。</li><li><code>方法区中常量引用的对象</code>：常量池是方法区的一部分，用于存储常量。如果常量池中包含对某个对象的引用，那么这个对象就被视为GC Roots对象。</li><li><code>本地方法栈中JNI引用的对象</code>：JNI是Java Native Interface的缩写，用于在Java程序中调用本地方法（即由C或C++等语言编写的方法）。当本地方法被调用时，会在本地方法栈中创建一个栈帧，如果该栈帧中包含对某个对象的引用，那么这个对象就被视为GC Roots对象。</li></ol><ul><li>可达性分析算法基于这些GC Roots对象，通过遍历所有的引用链，找到所有可达对象，将它们标记为存活对象，而没有被找到的对象则被视为不可达对象，需要被回收。</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>主要优点：可以处理复杂的引用结构，例如循环引用、交叉引用等情况，能够识别出所有可达对象，从而准确地进行垃圾回收。</li><li>缺点：例如需要耗费较多的时间进行垃圾回收、可能会出现漏标和误标等问题。为了解决这些问题，JVM中还采用了其他的垃圾回收算法，如标记-清除算法、复制算法、标记-整理算法等，以提高垃圾回收的效率和准确性。</li></ul><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><ul><li><p>在Java中，对象不仅可以被正常引用，还可以被特殊的引用类型引用。这些引用类型决定了垃圾回收器如何对对象进行回收。</p></li><li><p>JVM中共有五种引用类型，它们分别是</p><ol><li><p>强引用（Strong Reference）：</p><p>是最常见的引用类型，也是默认的引用类型。如果一个对象具有强引用，那么即使内存空间不足，垃圾回收器也不会回收它。只有当该对象的所有强引用都失效时，对象才会被回收</p></li><li><p>软引用（Soft Reference）：</p><p>是一种比强引用弱一些的引用类型。如果一个对象只具有软引用，那么当内存空间不足时，垃圾回收器可能会回收它。软引用通常用于实现内存敏感的缓存</p><p>可以配合引用队列来释放软引用自身</p></li><li><p>弱引用（Weak Reference）：</p><p>是一种比软引用更弱一些的引用类型。如果一个对象只具有</p><p>弱银用，那么垃圾回收器在下一次运行时，无论内存空间是否足够，都会回收该对象。若引用通常用于实现在对象可用时进行操作的场景</p><p>可以配合引用队列来释放软引用自身</p></li><li><p>虚引用（Phantom Reference）：</p><p>是最弱的一种引用类型。如果一个对象只具有虚引用，那么在任何时候都可能被垃圾回收器回收。虚引用通常用于追踪对象被垃圾回收的状态</p><p>必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存</p></li><li><p><code>终结器引用（Final Reference）：</code>是一种特殊的弱引用类型，它只在对象被回收时被添加到引用队列中。当垃圾回收器准备回收一个对象时，会先执行对象的finallize()方法，如果finalize()方法中没有重新让对象与其他对象建立联系，那么这个对象就会被回收，并且它的Final引用会被加入到引用队列中。Final引用通常用于对象回收后的清理工作</p></li></ol></li><li><p>软引用、弱引用和虚引用则是用于管理一些比较特殊的对象。使用引用队列可以方便地跟踪这些特殊对象的垃圾回收状态，帮助我们及时释放对象占用的资源。</p></li><li><p>使用引用队列来管理这些特殊对象的方式是，在创建这些对象时，同时指定一个引用队列。当垃圾回收器回收这些对象时，会自动将其添加到与之关联的引用队列中。我们可以在某个时刻检查引用队列中是否有特殊对象，并对其进行处理，比如将其从相应的数据结构中删除，以便释放特殊对象占用的资源。</p></li></ul><h2 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h2><h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><div class="tabs" id="1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#1-1">标记清除</button></li><li class="tab"><button type="button" data-href="#1-2">标记整理</button></li><li class="tab"><button type="button" data-href="#1-3">复制</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><ul><li>标记清除是一种常见的垃圾回收算法之一，其工作原理如下：<ol><li><code>标记阶段（Mark）</code>：从根对象开始遍历内存中的所有对象，将所有能够被访问到的对象做上标记，表示这些对象是活动的。</li><li><code>清除阶段（Sweep）</code>：遍历整个内存空间，将未被标记的对象视为垃圾，将其占用的内存资源进行回收。</li></ol></li><li>标记清除算法的优点在于它简单易用，可以快速地回收大量的垃圾对象。但是，它也存在一些缺点，例如在清除和压缩阶段中可能会产生较大的内存碎片，从而影响后续的内存分配效率。此外，标记清除算法无法处理循环引用的情况，需要借助其他算法来处理循环引用问题，例如标记-压缩算法和复制算法等。</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310261839933.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-2"><ul><li>在标记整理算法中，标记和清除阶段和标记清除算法是一样的，只有在内存整理阶段不同。在整理阶段，标记整理算法会将所有存活的对象向内存的一端移动，之后将移动后的内存末尾地址作为堆的新起始地址，之前的地址空间被标记为空闲，可以用来分配新的对象。</li><li>需要注意的是，标记整理算法的整理阶段可能会比较耗时，因为它需要移动对象，这也是它的一个缺点。但是，由于它可以消除内存碎片，提高内存利用率，所以在需要长时间运行的应用程序中，标记整理算法通常比标记清除算法更加适用。</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310261840029.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-3"><ul><li>复制算法是一种基于内存分区的垃圾回收算法，它将内存分成两个区域：From空间和To空间。在正常情况下，所有的对象都被分配在From空间中。当需要进行垃圾回收时，算法会扫描From空间中的所有对象，并将存活的对象复制到To空间中。复制完成后，From空间中的对象都可以被视为垃圾，并可以被回收。</li><li>接下来，详细介绍一下复制算法的工作原理：<ol><li><code>内存分配：</code>在程序运行过程中，对象的内存分配只在From空间中进行。当From空间快要用完时，算法会触发一次垃圾回收操作。</li><li><code>扫描存活对象：</code>在进行垃圾回收时，算法会遍历From空间中的所有对象，并标记存活的对象。为了标记存活对象，复制算法使用了一种叫做<code>可达性分析</code>的技术，这个技术可以判断一个对象是否是存活对象。与标记清除算法和标记整理算法不同的是，复制算法并不需要进行标记和清除的分离过程，因为复制算法是将存活对象复制到To空间中，所以只要扫描完From空间中的所有对象，并将存活对象复制到To空间中，就可以直接清除From空间了。</li><li><code>复制存活对象：</code>在扫描存活对象之后，算法会将所有存活对象从From空间复制到To空间。复制的过程是按照对象的存活顺序进行的，也就是说，如果对象A引用了对象B，那么对象B会被先复制到To空间中。复制完成后，To空间的使用量会变得很满，From空间的使用量则变得很少。</li><li><code>交换空间：</code>在复制完所有存活对象之后，From空间中剩余的对象都可以视为垃圾，并可以被回收。为了保证下一次的内存分配，To空间和From空间会进行交换，也就是说，To空间成为了新的From空间，From空间成为了新的To空间。这样一来，内存分配就可以在新的From空间中进行了。</li></ol></li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310261840582.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>总结一下这三种垃圾回收算法的优缺点</p><ol><li><code>标记清除：</code>速度较快，但会产生内存碎片</li><li><code>标记整理：</code>速度较慢，但是不会产生内存碎片</li><li><code>复制：</code>不会产生内存碎片，但是需要占用双倍内存空间</li></ol><h1 id="分代垃圾回收"><a href="#分代垃圾回收" class="headerlink" title="分代垃圾回收"></a>分代垃圾回收</h1><p>JVM（Java虚拟机）的分代垃圾回收是一种优化内存回收的技术。它利用对象的生命周期来将堆（heap）分为不同的区域，然后针对不同区域的特点采用不同的垃圾回收算法。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310261841314.png"></p><ol><li>对象首先分配在伊甸园区域</li><li>新生代空间不足时，触发<code>minor gc</code>，<code>伊甸园</code>和<code>from</code>存活的对象使用<code>copy</code>复制到<code>to</code>中，存活的对象年龄<code>+1</code>并且交换<code>from</code>和<code>to</code></li><li><code>minor gc</code>会引发<code>stop the world（砸瓦鲁多！！）</code>，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</li><li>当对象寿命超过阈值时，会晋升至老年代，最大寿命是15<ul><li>Java中的对象头中确实分配了一定的字节用来记录对象的年龄，而这个字节的位数是4，因此其二进制最大值为1111，即十进制的15</li></ul></li><li>当老年代空间不足，会先尝试触发<code>minor gc</code>，如果之后空间仍不足，那么触发<code>full gc</code>，STW的时间更长</li></ol><h2 id="相关VM参数"><a href="#相关VM参数" class="headerlink" title="相关VM参数"></a>相关VM参数</h2><table><thead><tr><th align="center">含义</th><th align="center">参数</th></tr></thead><tbody><tr><td align="center">堆初始大小</td><td align="center">-Xms</td></tr><tr><td align="center">堆最大大小</td><td align="center">-Xmx 或 -XX:MaxHeapSize&#x3D;size</td></tr><tr><td align="center">新生代大小</td><td align="center">-Xmn 或 (-XX:NewSize&#x3D;size + -XX:MaxNewSize&#x3D;size )</td></tr><tr><td align="center">幸存区比例（动态）</td><td align="center">-XX:InitialSurvivorRatio&#x3D;ratio 和 -XX:+UseAdaptiveSizePolicy</td></tr><tr><td align="center">幸存区比例</td><td align="center">-XX:SurvivorRatio&#x3D;ratio</td></tr><tr><td align="center">晋升阈值</td><td align="center">-XX:MaxTenuringThreshold&#x3D;threshold</td></tr><tr><td align="center">晋升详情</td><td align="center">-XX:+PrintTenuringDistribution</td></tr><tr><td align="center">GC 详情</td><td align="center">-XX:+PrintGCDetails -verbose:gc</td></tr><tr><td align="center">Full GC 前 Minor GC</td><td align="center">-XX:+ScavengeBeforeFullGC</td></tr></tbody></table><h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><h2 id="早期回收器"><a href="#早期回收器" class="headerlink" title="早期回收器"></a>早期回收器</h2><div class="tabs" id="2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#2-1">串行收集器（Serial收集器）</button></li><li class="tab"><button type="button" data-href="#2-2">吞吐量优先收集器（Parallel收集器）</button></li><li class="tab"><button type="button" data-href="#2-3">CMS收集器（响应时间优先）</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="2-1"><ul><li>这是最简单的垃圾回收器，它通过一个单线程进行垃圾回收，因此它的优点是简单高效，但缺点是在大型应用程序中可能会出现停顿时间过长的问题。</li><li>串行收集器的缺点主要是单线程执行垃圾回收操作，不能充分利用多核CPU的计算能力，同时垃圾回收操作会阻塞应用程序的运行，可能会导致长时间的停顿。因此，在大型的、多线程的应用程序中，通常不适合使用串行收集器进行垃圾回收。</li><li>对应的VM参数：<code>-XX:+UseSerialGC = Serial + SerialOld</code></li><li>下图中，其他CPU需要等待<code>CPU 2</code>执行完垃圾回收后，才能继续运行</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310261842860.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2-2"><ul><li><p>JDK 1.8 默认采用的就是这种垃圾回收器</p></li><li><p>它是一种基于多线程并行执行的垃圾回收器，它的主要目标是提高应用程序的吞吐量，即在单位时间内处理更多的请求。</p></li><li><p>相关VM参数</p><ol><li><pre><code>-XX:+UseParallelGC ~ -XX:+UseParallelOldGC：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   - 这两个参数分别用于开启并行垃圾回收器和并行老年代垃圾回收器。其中，-XX:+UseParallelGC用于开启并行垃圾回收器，-XX:+UseParallelOldGC用于开启并行老年代垃圾回收器。使用这两个参数可以开启Parallel收集器。</span><br><span class="line"></span><br><span class="line">2. ```</span><br><span class="line">   -XX:+UseAdaptiveSizePolicy：</span><br></pre></td></tr></table></figure>- 这个参数用于自适应地调整Java堆大小和垃圾收集器的参数，以达到更好的垃圾回收效果。当开启该参数时，JVM会自动调整Eden区、Survivor区、老年代的大小以及垃圾回收线程的数量等参数，以达到更高的垃圾回收效率。</code></pre></li><li><pre><code>-XX:GCTimeRatio=ratio：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   - 这个参数用于设置垃圾回收所占用CPU时间和应用程序运行时间的比率。默认值是99，表示垃圾回收时间最多可以占用1%的CPU时间，计算公式为`1/(1 + ratio)`</span><br><span class="line"></span><br><span class="line">4. ```</span><br><span class="line">   -XX:MaxGCPauseMillis=ms：</span><br></pre></td></tr></table></figure>- 这个参数用于设置最大垃圾回收暂停时间。默认值是200ms。如果设置该参数，JVM会尽可能地控制垃圾回收暂停的时间不超过该值。如果需要更短的垃圾回收暂停时间，则可以将该值设置为较小的数值。</code></pre></li><li><pre><code>-XX:ParallelGCThreads=n：</code></pre><ul><li>这个参数用于设置垃圾回收线程的数量。默认值是CPU核心数的1&#x2F;4。可以根据应用程序的需求和硬件环境来调整该参数的值，以达到更好的垃圾回收效果。</li></ul></li></ol></li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/pphfXnO.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="2-3"><p>概述</p><ul><li>CMS（Concurrent Mark Sweep）是一种垃圾回收算法，它的设计目标是在最短的停顿时间内回收垃圾。它通过在一个线程中进行垃圾回收并在应用程序线程中同时运行，从而减少停顿时间。下面详细介绍CMS垃圾收集器的工作原理和优缺点。</li></ul><p>工作流程</p><ul><li>CMS垃圾收集器的工作可以分为以下几个阶段：<ol><li>初始标记阶段（Initial Marking）：在这个阶段中，CMS垃圾收集器会暂停所有应用程序线程，并且在内存中标记出所有被直接引用的对象。这个过程由一个线程来完成，因此它的停顿时间比较短。</li><li>并发标记阶段（Concurrent Marking）：在这个阶段中，CMS垃圾收集器会在应用程序线程运行的同时标记出所有被间接引用的对象。这个过程由多个线程并发执行，因此它的停顿时间比较短。</li><li>重新标记阶段（Remark）：在这个阶段中，CMS垃圾收集器会暂停所有应用程序线程，并且重新标记出在并发标记阶段中有变化的对象。这个过程由一个线程来完成，因此它的停顿时间比较短。</li><li>并发清除阶段（Concurrent Sweeping）：在这个阶段中，CMS垃圾收集器会在应用程序线程运行的同时清除所有标记为垃圾的对象。这个过程由多个线程并发执行，因此它的停顿时间比较短。</li><li>最终标记阶段（Final Remark）：在这个阶段中，CMS垃圾收集器会暂停所有应用程序线程，并且重新标记出在并发清除阶段中有变化的对象。这个过程由一个线程来完成，因此它的停顿时间比较短。</li></ol></li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310261843307.png"></p><ul><li>优点<ol><li>可以在最短的停顿时间内回收垃圾，不会出现长时间的停顿现象，因此适合响应时间比较敏感的应用程序。</li><li>采用并发的垃圾收集方式，能够与应用程序并发执行，不会阻塞应用程序的执行，因此对于需要保证应用程序响应性能的场景非常适用。</li></ol></li><li>缺点<ol><li>对 CPU 的使用比较敏感，在高负载情况下可能会影响应用程序的性能。</li><li>由于并发清除阶段无法整理内存，可能会出现内存碎片化的问题，导致后续垃圾回收过程需要更多的时间。</li><li>在处理大量的垃圾时可能会导致应用程序的性能下降，因为需要占用一定的 CPU 资源。</li></ol></li></ul><p>相关VM参数</p><ol><li>-XX:ParallelGCThreads&#x3D;n：<ul><li>指定并行垃圾回收器的线程数。默认值是处理器核心数。</li></ul></li><li>-XX:ConcGCThreads&#x3D;threads：<ul><li>指定并发垃圾回收器的线程数。默认值是处理器核心数的<code>1/4</code>。</li></ul></li><li>-XX:CMSInitiatingOccupancyFraction&#x3D;percent：<ul><li>指定 CMS 垃圾回收器开始执行垃圾回收的阈值。当老年代空间使用达到指定百分比时，CMS 垃圾回收器会开始执行垃圾回收。</li></ul></li><li>-XX:+CMSScavengeBeforeRemark：<ul><li>启用 CMS 垃圾回收器在进行重新标记之前执行新生代的垃圾回收。这可以减少重新标记的时间，从而减少应用程序暂停的时间。</li></ul></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li><p>G1（Garbage-First）是一种现代化的垃圾回收器，它在JDK 7中首次引入，并在JDK 9</p><p>中被标记为默认垃圾回收器。</p></li><li><p>与之前的垃圾回收器相比，G1的最大优势在于它可以更好地处理占据大量堆内存的Java应用程序，从而避免了传统垃圾回收器在大内存情况下可能出现的停顿</p></li></ul><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ul><li>G1采用了一种不同于传统垃圾回收器的回收方式，它将内存划分为大小相等的多个区域（Region），每个区域的大小通常为<code>1MB</code>到<code>32MB</code>。G1将这些区域分为新生代和老年代，其中新生代通常占整个堆内存的5%到10%，老年代则占90%到95%。</li><li>G1将堆内存划分为多个区域后，它就可以对每个区域分别进行垃圾回收，从而避免了FULL GC带来的长时间停顿。</li></ul><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ul><li>G1的垃圾回收流程如下<ol><li><code>初始标记（Initial Mark）：</code>G1在此阶段会扫描堆内存中的根对象，并标记所有的根对象，以便后续回收时可以快速定位到这些根对象</li><li><code>并发标记（Concurrent Mark）：</code>在此阶段，G1会与应用程序并发的执行，扫描堆内存中的所有存活对象，并标记这些对象。在整个过程中，应用程序可以继续执行，因此在这个阶段不会产生长时间的停顿</li><li><code>确定标记（Remark）：</code>在并发标记结束后，G1需要在一个短暂的停顿期间重新扫描堆内存，以便确定所有的存活对象已经被标记</li><li><code>清除（Cleanup）：</code>在确定标记阶段结束后，G1会对未标记的区域进行回收，并将回收得到的空闲区域加入到空闲列表中，以便下次回收内存时使用</li></ol></li></ul><h3 id="垃圾回收阶段"><a href="#垃圾回收阶段" class="headerlink" title="垃圾回收阶段"></a>垃圾回收阶段</h3><ul><li>在G1垃圾回收器中，垃圾回收的过程可以分为三种阶段：<code>Young Collection</code>、<code>Young Collection + Concurrent Mark</code>（简称Young Collection + CM）和<code>Mixed Collection</code>。</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310261845573.png"></p><h4 id="三种垃圾回收阶段"><a href="#三种垃圾回收阶段" class="headerlink" title="三种垃圾回收阶段"></a>三种垃圾回收阶段</h4><div class="tabs" id="3"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#3-1">Young Collection</button></li><li class="tab"><button type="button" data-href="#3-2">Young Collection + Concurrent Mark</button></li><li class="tab"><button type="button" data-href="#3-3">Mixed Collection</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="3-1"><p>Young Collection（年轻代垃圾回收）</p><ul><li>Young Collection是指对年轻代（Young Generation）的垃圾回收。在G1垃圾回收器中，年轻代通常是由几个连续的Region组成的。在年轻代垃圾回收期间，G1垃圾回收器会扫描年轻代内的所有对象，并标记那些被引用的对象。然后，它会将未被引用的对象回收掉，并将被引用的对象移动到下一个垃圾回收周期的存活区域（Survivor Region）中。</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310261847838.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3-2"><p>年轻代垃圾回收 + 并发标记</p><ul><li>Young Collection + CM是：指在Young GC 时会进行GC Root 的初始标记，当老年代占用堆空间比例达到阈值时，对整个堆内存进行并发标记。由下面的VM参数决定<ul><li>-XX:InitiatingHeapOccupancyPercent&#x3D;percent （默认45%）</li></ul></li><li>在并发标记过程中，G1垃圾回收器会扫描所有的可达对象，并标记它们。并发标记可以与应用程序并行进行，不会停顿应用程序的线程。当并发标记完成后，G1垃圾回收器就可以知道哪些对象是存活的，哪些对象是垃圾</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310261857656.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="3-3"><p>Mixed Collection（混合垃圾回收）</p><p>Mixed Collection是指对整个堆内存进行垃圾回收，包括年轻代和老年代（Old Generation）的垃圾回收。在Mixed Collection期间，G1垃圾回收器会尽可能地回收那些垃圾占用空间较大的Region，并将它们标记为”空闲”状态，以便在以后的内存分配中使用。与Young Collection不同，Mixed Collection不仅回收年轻代的对象，还回收老年代的对象，因此它需要更长的停顿时间。同时，Mixed Collection也会和并发标记一起执行，以最小化应用程序的停顿时间。</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310261857645.png"></p><ul><li>新生代内存不足发生的垃圾收集：minor gc</li><li>当G1垃圾回收器的回收速度跟不上Java应用程序产生垃圾的速度时，垃圾对象在堆内存中不断增加，导致堆内存空间的压力增大。当堆内存空间的压力达到G1垃圾回收器的阈值时，会触发FULL GC。</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="跨代引用"><a href="#跨代引用" class="headerlink" title="跨代引用"></a>跨代引用</h3><ul><li>当进行新生代垃圾回收时，需要找到新生代对象的跟对象来确定哪些对象是存活的，那些对象需要被回收。然而根对象中可能有一部分存活在老年代中，如果每次都要遍历老年代来查找这些根对象，将会导致效率低下</li><li>为了解决这个问题，G1垃圾回收器采用了一种卡表技术，将老年代划分为多个区域，并将每个区域划分为一组成为<code>卡</code>的块。每个卡的大小约为512KB，如果老年代中的一个对象引用了新生代中的对象，那么该卡就被标记为脏卡</li><li>在新生代对象引用发生变化时，使用post-write barrier和dirty card queue技术来更新卡表，将引用变更信息添加到Remembered Set中，标记为脏卡</li><li>在进行新生代垃圾回收时，只需要扫描这些脏卡中的对象，即可找到所有的跨代引用对象，避免了对整个老年代进行遍历的开销，提高了垃圾回收的效率。</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310261858746.png"></p><h3 id="重新标记阶段"><a href="#重新标记阶段" class="headerlink" title="重新标记阶段"></a>重新标记阶段</h3><ul><li>在G1垃圾回收器的remark阶段中，它使用三色标记法来标记存活对象，并结合SATB和写屏障来跟踪对象的引用关系，以便在标记阶段中更准确地标记存活对象。</li><li>remark阶段开始时，G1垃圾回收器会将所有被标记为灰色的对象加入到处理队列中，然后开始遍历处理队列中的对象。对于每个灰色对象，G1垃圾回收器会扫描其所有引用域，并将任何未被标记为黑色的引用加入到SATB中，以便在后续标记阶段中更准确地跟踪引用关系。</li><li>同时，在遍历处理队列中的对象时，G1垃圾回收器会将灰色对象的引用对象标记为灰色，将灰色对象标记为黑色，并将其从处理队列中移除。这个过程会一直持续，直到处理队列中不再有灰色对象。</li><li>在remark阶段中，SATB写屏障起到了重要作用。当程序在运行时修改一个对象的引用时，SATB写屏障会记录这个修改，并将相关信息保存到一个记录缓存中。在remark阶段中，G1垃圾回收器会遍历记录缓存中所有被标记为脏的对象，并遍历这些对象的引用域，以确定它们所引用的对象是否需要被标记为灰色。</li><li>通过三色标记法、SATB和写屏障的结合使用，G1垃圾回收器可以更准确地标记存活对象，并且在标记阶段中只标记那些需要被标记的对象，从而提高垃圾回收器的性能和效率。</li></ul><h3 id="字符串去重"><a href="#字符串去重" class="headerlink" title="字符串去重"></a>字符串去重</h3><ul><li>当新生代中的对象被晋升到老年代时，如果这些对象是字符串类型，那么会将它们放入一个特殊的队列中，而不是直接将它们放入老年代中。这个队列称为String Deduplication Queue，可以理解为字符串去重队列。</li><li>G1垃圾回收器在remark阶段中会扫描String Deduplication Queue中的所有字符串，检查是否有重复的字符串。如果发现有重复的字符串，就会让它们引用同一个<code>char[]</code>，以达到字符串去重的目的。需要注意的是，这里去重的对象是<code>char[]</code>，而不是String对象本身，与<code>String.intern()</code>不同。</li><li>为了实现这一功能，G1垃圾回收器内部维护了一个字符串表，用来存储所有已经去重的<code>char[]</code>。当遍历String Deduplication Queue时，G1垃圾回收器会将每个字符串的<code>char[]</code>进行哈希，然后在字符串表中查找是否存在相同哈希值的<code>char[]</code>，如果存在，就会比较这两个<code>char[]</code>的内容是否相同，从而确定是否是同一个字符串。如果是同一个字符串，就将这个字符串对象的引用指向字符串表中的<code>char[]</code>，从而达到字符串去重的目的。</li><li>总之，G1垃圾回收器的字符串去重功能可以大幅度减少堆内存中的重复字符串，从而降低垃圾回收器的内存占用和垃圾回收的开销，提高程序的性能。<ul><li>优点：节省大量内存</li><li>缺点：稍微多占用了CPU时间，新生代回收时间略微增加</li></ul></li></ul><h3 id="类卸载"><a href="#类卸载" class="headerlink" title="类卸载"></a>类卸载</h3><ul><li>在 G1 垃圾回收器进行并发标记后，它可以识别出哪些类不再被使用。当一个类加载器的所有类都不再被使用时，就可以卸载该类加载器所加载的所有类。</li><li>G1 垃圾回收器默认开启了类卸载功能，可以通过 <code>JVM</code> 参数 <code>-XX:+ClassUnloadingWithConcurrentMark</code> 显式启用。</li></ul><h3 id="回收巨型对象"><a href="#回收巨型对象" class="headerlink" title="回收巨型对象"></a>回收巨型对象</h3><ul><li>对象大小超过了G1 Heap中的Region大小的一半时，被称为巨型对象（Huge Object）。</li><li>G1不会将巨型对象分配到Region中，而是直接分配在Humongous区域中。Humongous区域是一组连续的Region，大小为2的幂次方倍。如果一个巨型对象的大小超过了Humongous区域的大小，则会跨越多个Humongous区域。</li><li>在标记阶段，G1会优先处理巨型对象，以便在回收过程中更好地利用它们的空间。这样可以避免因巨型对象被其他对象占用而导致的内存浪费。</li><li>在G1中，老年代中所有的incoming引用会被跟踪，如果某个巨型对象的incoming引用计数为0，说明该对象不再被其他对象引用，可以直接被回收。这个过程发生在新生代回收之前，可以帮助释放空间。</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310261859672.png"></p><h3 id="动态调整阈值"><a href="#动态调整阈值" class="headerlink" title="动态调整阈值"></a>动态调整阈值</h3><ul><li>前面说如果G1垃圾回收器的回收速度跟不上Java应用程序产生垃圾的速度时，垃圾对象在堆内存中不断增加，导致堆内存空间的压力增大。当堆内存空间的压力达到G1垃圾回收器的阈值时，会触发<code>FULL GC</code>。</li><li>并发标记阶段是 G1 垃圾回收的一个重要阶段，需要在堆空间占满之前完成，否则就会退化为 FullGC。为了避免这种情况的发生，JDK 9 之前需要使用 <code>-XX:InitiatingHeapOccupancyPercent</code> 参数来手动设置并发标记的触发阈值（默认为45%），以确保在这个阈值之前就完成并发标记。而在 JDK 9 及以后的版本中，可以根据实际情况动态调整并发标记的触发阈值，以避免 <code>Full GC</code> 的发生。</li><li><code>-XX:InitiatingHeapOccupancyPercent</code> 参数用于设置并发标记的初始触发阈值，但是 G1 在进行并发标记时会进行数据采样，并根据采样数据动态调整并发标记的触发阈值，以确保并发标记可以在堆空间不被填满的情况下完成。同时，G1 还会在堆空间中留出一定的安全空档空间，以避免因为堆空间占满而触发 <code>Full GC</code>。</li></ul><h3 id="G1总结"><a href="#G1总结" class="headerlink" title="G1总结"></a>G1总结</h3><p>优点：</p><ol><li><code>分区回收：</code>G1将堆内存划分为多个区域，并对每个区域分别进行回收，从而避免<code>FULL GC</code>带来的长时间停顿</li><li><code>并发回收：</code>G1在标记和清除阶段都可以与应用程序并发执行，从而避免了长时间的停顿</li><li><code>预测性停顿：</code>G1可以根据应用程序的内存使用情况预测合适需要进行<code>FULL GC</code>，从而在垃圾回收过程中尽可能地减少停顿时间</li><li><code>空间整合：</code>G1可以在回收过程中对空间进行整合，从而可以更好的利用堆内存</li><li><code>可预测性：</code>G1可以设置预期的停顿时间，以便开发人员可以更好地控制应用程序的性能</li></ol><p>缺点</p><ol><li>初始标记和确定标记阶段需要短暂的停顿时间，虽然停顿时间短暂，但是仍然可能影响应用程序的性能</li><li>G1需要更多的CPU资源来完成垃圾回收，因为它需要同时处理多个分区</li><li>对于小型应用程序，G1可能会产生过多的内存分配和垃圾回收开销，从而导致应用程序性能下降</li></ol><h1 id="垃圾回收调优"><a href="#垃圾回收调优" class="headerlink" title="垃圾回收调优"></a>垃圾回收调优</h1><p>调优跟应用、环境有关，没有放之四海而皆准的法则，都是具体情况具体分析</p><h2 id="调优领域"><a href="#调优领域" class="headerlink" title="调优领域"></a>调优领域</h2><ul><li>JVM的GC调优是Java应用程序性能调优的一个重要方面。在进行GC调优之前，需要先确定应用程序的性能瓶颈，通常可以从内存、锁竞争、CPU占用和IO等方面入手进行调优。</li></ul><ol><li><code>内存调优</code><ul><li>内存调优主要是针对JVM的堆内存和非堆内存进行调优。在Java应用程序中，大部分的对象都是分配在堆内存中的。因此，对于堆内存的调优非常重要。</li><li>如果堆内存的大小设置过小，就会频繁地进行垃圾回收，导致应用程序的性能下降。如果堆内存的大小设置过大，就会浪费系统资源。</li><li>对于非堆内存，可以考虑调整JVM的元空间大小来减少元数据的内存占用。</li></ul></li><li><code>锁竞争调优</code><ul><li>Java中的锁机制是实现并发的重要手段，但是锁的竞争会导致应用程序的性能下降。因此，锁竞争调优是Java应用程序性能调优的一个重要方面。</li><li>可以通过使用synchronized关键字和Lock接口来进行锁竞争调优。synchronized关键字是Java中实现锁的一种简单方式，但是在高并发场景下，由于锁粒度较大，容易导致锁竞争。</li><li>因此，在高并发场景下，可以考虑使用Lock接口来实现锁。Lock接口支持更细粒度的锁，并且可以控制锁的获取和释放。</li></ul></li><li><code>CPU占用调优</code><ul><li>CPU占用调优是指通过优化代码来减少CPU的占用率，提高应用程序的性能。</li><li>可以通过以下方式来进行CPU占用调优：<ol><li><code>减少线程数：</code>线程数过多会导致CPU占用率上升，因此可以通过减少线程数来降低CPU占用率。</li><li><code>避免无用循环：</code>无用循环会导致CPU占用率上升，因此可以通过优化代码来减少无用循环的出现。</li><li><code>避免递归调用：</code>递归调用会导致CPU占用率上升，因此可以通过优化代码来避免递归调用的出现。</li></ol></li></ul></li><li><code>IO调优</code><ul><li>IO调优是指通过优化IO操作来提高应用程序的性能。</li><li>可以通过以下方式来进行IO调优：<ol><li><code>减少IO操作：</code>减少IO操作可以减少IO调用的次数，从而提高应用程序的性能。</li><li><code>使用缓存：</code>缓存可以减少IO调用的次数，从而提高应用程序的性能。</li><li><code>使用异步IO：</code>异步IO可以在IO操作期间释放CPU资源，从而提高应用程序的性能。</li></ol></li></ul></li></ol><h2 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a>确定目标</h2><p>我们首先要清楚我们的应用程序是干什么的，即确定一个垃圾回收的目标</p><ul><li>如果是做一些科学运算、批量处理，那么追求的就是高吞吐量，延长一点点响应时间对我们没有太大影响</li><li>如果是做一些互联网、金融、电子商务项目，那么响应时间就是一个非常重要的指标了，如果每次垃圾回收都延长了响应时间，就会给用户造成不好的体验</li></ul><p>确定了目标以后，我们再来选择合适的垃圾回收器</p><ul><li>对于高吞吐量的应用程序，通常可以选择 <code>Parallel GC</code> 等并行垃圾回收器来实现高效的垃圾回收。</li><li>而对于需要低延迟、高响应时间的应用程序，可以选择 <code>CMS</code>、<code>G1</code>、<code>ZGC</code>、<code>Zing</code> 等低延迟垃圾回收器来实现。</li></ul><h2 id="最快的GC"><a href="#最快的GC" class="headerlink" title="最快的GC"></a>最快的GC</h2><p>最快的GC是不发生GC，即尽可能减少内存分配和回收的次数。因此，建议在代码中尽量避免频繁地创建和销毁对象，或者使用不必要的大型数据结构。</p><h2 id="GC之前检查"><a href="#GC之前检查" class="headerlink" title="GC之前检查"></a>GC之前检查</h2><ol><li>数据是不是太多<ul><li>查询大表时，如果数据量太大，会占用大量的内存空间，导致频繁的GC，甚至可能直接内存溢出，建议在查询时加上限制条件（如limit）来减小数据量。</li></ul></li><li>数据表示是否太臃肿？<ul><li>如果数据结构过于庞大，例如包含大量不必要的字段或者对象引用，也会占用大量内存空间。</li><li>例如在Java中，Integer是一个对象，而int是一个基本数据类型。因此，当我们使用Integer时，实际上是创建了一个对象来存储整数值。相对地，使用int时，只需要直接在栈上分配一个内存空间来存储整数值，不需要再创建对象，因此内存占用更小。<ul><li>Integer对象占用的内存空间包含了对象头、对象的值等信息，一般需要占据16个字节</li><li>而int类型只需要占用4个字节的内存空间。</li></ul></li></ul></li><li>是否存在内存泄露？<ul><li>一直向静态Map中存储数据，会导致静态Map中的内存占用越来越大，可能导致频繁的GC和内存溢出。因为静态变量属于类，不会被垃圾回收器自动释放。这种情况可以使用软引用或弱引用来引用该对象，以便在内存不足时自动释放缓存数据。</li><li>但还是不建议使用Java来实现缓存，而是推荐使用第三方缓存实现，例如Redis等</li></ul></li></ol><h2 id="新生代调优"><a href="#新生代调优" class="headerlink" title="新生代调优"></a>新生代调优</h2><p>在新生代调优之前，我们先来回顾一下新生代的特点</p><ol><li>所有的new操作的内存分配都非常廉价，即分配速度很快。</li><li>死亡对象的回收：Java虚拟机有自动垃圾回收机制，用于回收不再被使用的对象。在新生代中，回收死亡对象的代价为零，因为它们可以很容易地被回收。</li><li>大部分对象用过即死：大部分对象的生命周期很短，使用一次就被丢弃了，这是因为Java中的对象通常用于执行一些特定的任务，而不是被持续使用。</li><li>Minor GC：Java虚拟机会周期性地进行垃圾回收操作，其中一种是Minor GC，用于回收新生代中的对象。由于新生代中的对象生命周期短，因此Minor GC的时间通常比Full GC（用于回收老年代中的对象）短很多。</li></ol><p>那么是设置的越大越好吗？不是的，官方文档中给出的解释如下：</p><ul><li><p>-Xmn</p><ul><li>Sets the initial and maximum size (in bytes) of the heap for the young generation (nursery). GC isperformed in this region more often than in other regions. If the size for the young generation is too small, then a lot of minor garbage collections are performed. If the size is too large, then only full garbage collections are performed, which can take a long time to complete. Oracle recommends that you keep the size for the young generation greater than 25% and less than 50% of the overall heap size.</li><li>设置新生代堆的初始大小和最大大小（以字节为单位）。垃圾回收在新生代中比其他区域更频繁地进行。如果新生代的大小过小，则会执行很多次<code>Minor GC</code>。如果大小过大，则只执行<code>FULL GC</code>，这可能需要很长时间才能完成。Oracle 建议您将新生代的大小保持在总堆大小的 25% 以上且低于 50%。</li></ul></li><li><p>新生代大小最好能容纳所有<code>并发量 * (请求-响应)</code>的数据</p><ul><li>例如一次请求响应需要<code>512KB</code>内存，并发量为<code>10000</code>，那么差不多就是<code>5GB</code></li></ul></li><li><p>幸存区要大到能够保留<code>当前活跃的对象 + 需要晋升的对象</code></p><ul><li>如果幸存区过小，JVM会灵活调整晋升的阈值，从而可能导致某些对象被提前晋升到老年代，从而将其从幸存区释放。当幸存区不足以容纳所有存活的对象时，垃圾回收器会选择将一部分对象直接晋升到老年代，而不是等待这些对象达到晋升的阈值再晋升。</li><li>这样做的问题在于，新生代中的对象通常比老年代中的对象生命周期短，如果过早地将这些对象晋升到老年代，可能会导致老年代中存在许多生命周期很短的对象，从而增加垃圾回收的压力，甚至导致堆内存溢出。</li><li>因此，为了变过早地将对象晋升到老年代，通常建议将幸存区设置的足够大，以便能够<code>容纳当前活跃对象与需要晋升对象的总和</code>。这也可以减少对象直接晋升到老年代的情况，提高了年轻代的空间利用率，并减轻垃圾回收的压力。</li></ul></li><li><p>调整晋升阈值是为了让存活时间较长的对象能尽早进入老年代，这样可以减少在幸存区进行复制操作的次数和数量。</p></li></ul><h2 id="老年代调优"><a href="#老年代调优" class="headerlink" title="老年代调优"></a>老年代调优</h2><p>以CMS为例</p><ul><li>CMS的老年代内存越大越好</li><li>先不进行调优，如果没有发生FULL GC，那么说明程序运行良好，应该先尝试新生代调优</li><li>观察发生FULL GC时老年代内存占用，将老年代内存预设增加 1&#x2F;4 ~ 1&#x2F;3。<ul><li>然后逐步调整-XX:CMSInitiatingOccupancyFraction参数的值，找到一个合适的设置值。</li><li>一般来说，可以将该参数设置在75% ~ 85%之间</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 垃圾回收 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-内存结构</title>
      <link href="/2023/07/12/JVM.%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
      <url>/2023/07/12/JVM.%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p>Java Virtual Machine ，Java 程序的<strong>运行环境</strong>（Java 二进制字节码的运行环境）</p><p>JVM好处</p><ul><li>一次编译，处处执行</li><li>自动的内存管理，垃圾回收机制</li><li>数组下标越界检查</li></ul><p>JVM、JRE、JDK 的关系如下图所示</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309122015679.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309122016720.png"></p><p>ClassLoader：Java 代码编译成二进制后，会经过类加载器，这样才能加载到 JVM 中运行。<br>Method Area：类是放在方法区中。<br>Heap：类的实例对象。<br>当类调用方法时，会用到 JVM Stack、PC Register、本地方法栈。<br>方法执行时的每行代码是有执行引擎中的解释器逐行执行，方法中的热点代码频繁调用的方法，由 JIT 编译器优化后执行，GC 会对堆中不用的对象进行回收。需要和操作系统打交道就需要使用到本地方法接口</p><h1 id="程序计数器（PC）"><a href="#程序计数器（PC）" class="headerlink" title="程序计数器（PC）"></a>程序计数器（PC）</h1><p>Program Counter Register 程序计数器（寄存器）</p><p>定义：</p><ul><li>JVM中的程序计数器(Program Counter Register)是一块较小的内存空间，它用来保存当前线程下一条要执行的指令的地址。每个线程都有自己独立的程序计数器，它是线程私有的，生命周期与线程相同。程序计数器是JVM中的一种轻量级的内存区域，因为它不会发生内存溢出（OutOfMemoryError）的情况。</li><li>程序计数器也是唯一一个在Java虚拟机规范中没有规定任何<code>OutOfMemoryError（内存溢出）</code>情况的区域。因为程序计数器是线程私有的，所以它所占用的内存空间非常小，一般不会导致内存溢出的问题。</li></ul><p>作用：</p><ul><li><p>是记录下一条 jvm 指令的执行地址行号。（下一条指令一定由PC指出）</p><blockquote><p>因为在Java虚拟机的多线程环境下，为了支持线程切换后能够恢复到正确的执行位置，每个线程都需要有一个独立的程序计数器，否则就会出现线程切换后执行位置混乱的问题。</p></blockquote></li></ul><p>特点：</p><ul><li><p>是线程私有的</p></li><li><p>不会存在内存溢出</p></li><li><p>Java源代码首先编译成二进制字节码，然后交由解释器解释成机器码，最终由CPU执行机器码</p><ul><li>程序计数器在其中的作用就是记住下一条JVM指令的执行地址，解释器从程序计数器取到下一条指令地址</li></ul></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>程序计数器</p><ul><li>作用：保存当前线程下一条要执行的指令的地址</li><li>特点：<ul><li>线程私有</li><li>不存在内存溢出</li></ul></li></ul><h1 id="虚拟机栈（Stack）"><a href="#虚拟机栈（Stack）" class="headerlink" title="虚拟机栈（Stack）"></a>虚拟机栈（Stack）</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>Java虚拟机栈（Java Virtual Machine Stacks）是Java虚拟机为每个线程分配的一块内存区域，用于存储线程的方法调用和局部变量等信息。</li><li>每个线程在运行时都有自己的Java虚拟机栈，线程开始时会创建一个新的栈帧（Stack Frame），用于存储该线程的方法调用信息。当方法调用完成后，该栈帧会被弹出，回到上一次方法调用的位置。每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法。</li></ul><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>Java虚拟机栈</p><ol><li>每个线程运行是所需的内存，就称为虚拟机栈</li><li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时占用的内存</li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li></ol><div class="tabs" id="问题1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#问题1-1">问题1</button></li><li class="tab"><button type="button" data-href="#问题1-2">问题2</button></li><li class="tab"><button type="button" data-href="#问题1-3">问题3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="问题1-1"><p>垃圾回收是否涉及栈内存？</p><p>垃圾回收通常不涉及栈内存。栈内存是在程序运行时自动分配和释放的，因此不需要垃圾回收来处理。相反，垃圾回收主要关注堆内存中的对象，以及这些对象是否还在被引用。垃圾回收器通常会扫描堆内存中的对象，并标记哪些对象仍然被引用，哪些对象可以被清理。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="问题1-2"><p>栈内存分配越大越好吗？</p><ul><li>栈内存的分配大小应该根据实际需要来确定。栈内存的分配是由操作系统负责的。栈内存划的越大，会让线程数变少，因为物理内存大小是一定的。栈内存划分大了，通常只是能够进行更多次的方法递归调用，而不会增强运行效率，反而会使线程数量变少，一般采用系统默认的栈内存就好</li></ul><ul><li>栈内存的分配大小应该根据实际需要来确定。栈内存的分配是由操作系统负责的<ul><li>Linux&#x2F;x64（64 位）：1024 KB</li><li>macOS（64 位）：1024 KB</li><li>Oracle Solaris&#x2F;x64（64 位）：1024 KB</li><li>Windows：默认值取决于虚拟内存</li></ul></li><li>当然我们也可以手动设置线程堆栈大小为1024kb</li></ul><blockquote><p>K M G T 在这里都是能直接用的</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Xss1m</span><br><span class="line">-Xss1024k</span><br><span class="line">-Xss1048576</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="问题1-3"><p>方法内的局部变量是否线程安全？</p><p>方法内的局部变量通常是线程安全的，因为它们只能在方法内部访问。每个线程都有自己的栈帧，栈帧包含方法的参数、局部变量和返回值等信息，因此不同的线程可以在不相互干扰的情况下同时访问相同的方法。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="栈内存溢出"><a href="#栈内存溢出" class="headerlink" title="栈内存溢出"></a>栈内存溢出</h2><p>栈内存溢出有两种情况</p><ol><li><p>栈帧过多导致栈内存溢出</p><ul><li>死循环递归</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    static int count = 0;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            method();</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void method() &#123;</span><br><span class="line">        count++;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>栈帧过多导致栈内存溢出</p><ul><li>下面这个例子中，Emp中引入了Dept，而Dept中又引入了Emp，他们现在在循环引用，导致json解析时会出现StackOverFlow</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">import com.fasterxml.jackson.annotation.JsonIgnore;</span><br><span class="line">import com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line">import com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Demo_03 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws JsonProcessingException &#123;</span><br><span class="line">        Dept d = new Dept();</span><br><span class="line">        d.setName(&quot;Market&quot;);</span><br><span class="line"></span><br><span class="line">        Emp e1 = new Emp();</span><br><span class="line">        e1.setName(&quot;zhang&quot;);</span><br><span class="line">        e1.setDept(d);</span><br><span class="line"></span><br><span class="line">        Emp e2 = new Emp();</span><br><span class="line">        e2.setName(&quot;li&quot;);</span><br><span class="line">        e2.setDept(d);</span><br><span class="line"></span><br><span class="line">        d.setEmps(Arrays.asList(e1, e2));</span><br><span class="line"></span><br><span class="line">        // &#123; name: &#x27;Market&#x27;, emps: [&#123; name:&#x27;zhang&#x27;, dept:&#123; name:&#x27;&#x27;, emps: [ &#123;&#125;]&#125; &#125;,] &#125;</span><br><span class="line">        ObjectMapper mapper = new ObjectMapper();</span><br><span class="line">        System.out.println(mapper.writeValueAsString(d));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Emp &#123;</span><br><span class="line">    private String name;</span><br><span class="line">//    @JsonIgnore</span><br><span class="line">    private Dept dept;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Dept getDept() &#123;</span><br><span class="line">        return dept;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDept(Dept dept) &#123;</span><br><span class="line">        this.dept = dept;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dept &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private List&lt;Emp&gt; emps;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;Emp&gt; getEmps() &#123;</span><br><span class="line">        return emps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setEmps(List&lt;Emp&gt; emps) &#123;</span><br><span class="line">        this.emps = emps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><ul><li>本地方法<ul><li><code>本地方法</code>是指由非Java语言编写的代码，如C或C++，并被编译为本地二进制代码。</li></ul></li><li>因为<code>JAVA</code>没法直接和操作系统底层交互，所以需要用到本地方法栈来调用本地的C或C++的方法</li><li>例如Object类的源码中就有本地方法，用<strong>native</strong>关键字修饰本地方法<ul><li>本地方法只有函数声明，没有函数体，因为函数体是C或C++写的，通常是通过JNI（Java Native Interface）技术来实现的。</li></ul></li></ul><h1 id="堆-heap"><a href="#堆-heap" class="headerlink" title="堆(heap)"></a>堆(heap)</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><ul><li>JVM的堆（Heap）是Java虚拟机（JVM）在内存中用来存放对象的区域，是Java程序中最大的一块内存区域。JVM的堆被所有线程共享，在JVM启动时就已经被创建，并且一直存在于JVM的整个生命周期中。</li><li>堆可以被分成两部分：新生代（Young Generation）和老年代（Old Generation）。新生代又被进一步分为Eden空间、幸存区From空间和幸存区To空间。</li><li>新生代是用来存放新创建的对象的，其中大部分对象都很快就会被垃圾回收掉。当堆空间不足时，JVM会触发垃圾回收机制（GC），对新生代的对象进行清理。清理过程一般是将存活的对象移到老年代或幸存区，而其余的对象则被回收。</li><li>老年代是用来存放生命周期较长的对象的，这些对象一般是从新生代晋升而来，或者是本身就比较大的对象。老年代的对象存活时间较长，因此垃圾回收的频率比新生代低得多。</li><li>JVM堆的大小可以通过启动JVM时的参数进行调整，如-Xms和-Xmx参数分别控制堆的初始大小和最大大小。如果应用程序需要创建大量的对象，而堆空间不足，则会抛出OutOfMemoryError异常。</li></ul><p>特点：</p><ul><li><p>通过new关键字创建的对象都会使用堆空间</p></li><li><p>它是线程共享的，堆空间内的对象都需要考虑线程安全的问题</p></li><li><p>有垃圾回收机制（GC Garbage Collection）</p></li></ul><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><ul><li>Heap堆<ul><li>通过new关键字创建的对象都会使用堆空间</li></ul></li><li>特点<ul><li>它是线程共享的，堆空间内的对象都需要考虑线程安全的问题</li><li>有垃圾回收机制</li></ul></li></ul><h2 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 演示堆内存溢出：java.lang.OutOfMemoryError: Java heap space</span><br><span class="line"> */</span><br><span class="line">public class Demo_04 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        try &#123;</span><br><span class="line">            ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); //Hello, HelloHello, HelloHelloHelloHello ···</span><br><span class="line">            String a = &quot;Hello&quot;;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                list.add(a);</span><br><span class="line">                a = a + a;  // HelloHelloHelloHello</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>list对象的作用域是在try块中，list对象是通过new出来的，所以占用的是堆空间。</li><li>由于a的字符串长度是指数增长的，所以堆空间很快就会不足，此时会触发垃圾回收机制，尝试清理新生代对象，但由于list对象一直处于存活状态，无法释放，最终导致堆内存溢出，最终我这里输出的i为<code>27</code></li><li>但是由于堆空间很大，所以有些堆内存溢出的情况可能不是很容易能诊断出来，所以我们可以通过添加JVM参数，将堆空间修改的小一些来进行测试，此时最终输出的i为<code>17</code></li></ul><h2 id="堆内存诊断"><a href="#堆内存诊断" class="headerlink" title="堆内存诊断"></a>堆内存诊断</h2><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">jps工具</button></li><li class="tab"><button type="button" data-href="#test1-2">jmap工具</button></li><li class="tab"><button type="button" data-href="#test1-3">jconsole工具</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p>查看当前系统中有哪些Java进程</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p>查看堆内存占用情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap 进程id ## 进程id就是jps查出来的进程</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p>图形化界面的多功能监测工具，可以连续监测</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202309122058984.png"></p><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><ul><li>在JVM中，方法区是一块用于存储类信息、常量、静态变量、即时编译器编译后的代码等数据的内存区域，它是Java虚拟机规范中的一个概念。<code>Java SE 7</code>及之前版本中，方法区被称为<code>永久代</code>，但在<code>Java SE 8</code>之后的版本中，<code>永久代</code>被废弃了，被<code>元空间</code>所替代。</li><li>元空间是JVM在<code>Java SE 8</code>之后引入的一个新的概念，它与永久代类似，都是用于存储类信息、常量、静态变量、即时编译器编译后的代码等数据的内存区域，但元空间的实现方式与永久代有所不同。</li><li>与永久代不同的是，元空间使用的是<code>本地内存（Native Memory）</code>，而不是<code>虚拟机内存（堆内存）</code>，这样就避免了OutOfMemoryError错误，因为在使用本地内存时，可以动态地调整大小，而且可以使用操作系统的虚拟内存机制，使得Java应用程序不会被限制在固定的内存大小中。</li><li>此外，元空间还引入了一些新的概念和机制，例如MetaspaceSize、MaxMetaspaceSize、CompressedClassSpaceSize等，这些概念和机制都是为了更好地管理元空间的内存使用和性能。</li></ul><h3 id="方法区内存溢出"><a href="#方法区内存溢出" class="headerlink" title="方法区内存溢出"></a>方法区内存溢出</h3><p>1.8之后会导致源空间内存溢出，测试代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import jdk.internal.org.objectweb.asm.ClassWriter;</span><br><span class="line">import jdk.internal.org.objectweb.asm.Opcodes;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 演示元空间内存溢出 java.lang.OutOfMemoryError: Metaspace</span><br><span class="line"> * -XX:MaxMetaspaceSize=50m</span><br><span class="line"> */</span><br><span class="line">public class Demo_07 extends ClassLoader &#123; // 可以用来加载类的二进制字节码</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int j = 0;</span><br><span class="line">        try &#123;</span><br><span class="line">            Demo_07 test = new Demo_07();</span><br><span class="line">            for (int i = 0; i &lt; 100000; i++, j++) &#123;</span><br><span class="line">                // ClassWriter 作用是生成类的二进制字节码</span><br><span class="line">                ClassWriter cw = new ClassWriter(0);</span><br><span class="line">                // 版本号， public， 类名, 包名, 父类， 接口</span><br><span class="line">                cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, &quot;Class&quot; + i, null, &quot;java/lang/Object&quot;, null);</span><br><span class="line">                // 返回 byte[]</span><br><span class="line">                byte[] code = cw.toByteArray();</span><br><span class="line">                // 执行了类的加载</span><br><span class="line">                test.defineClass(&quot;Class&quot; + i, code, 0, code.length); // Class 对象</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加VM参数<code>-XX:MaxMetaspaceSize=50m</code>，然后运行上面的代码，结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">70801</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Metaspace</span><br><span class="line">at java.lang.ClassLoader.defineClass1(Native Method)</span><br><span class="line">at java.lang.ClassLoader.defineClass(ClassLoader.java:756)</span><br><span class="line">at java.lang.ClassLoader.defineClass(ClassLoader.java:635)</span><br><span class="line">at com.demo.Demo_07.main(Demo_07.java:23)</span><br></pre></td></tr></table></figure><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>常量池就是一行表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息</p><p>我们先来编写一个简单的HelloWorld类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;Hello, World!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过命令将编译后的.class文件反汇编成可读的Java代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">$ javap -v D:/Workspace/JVM/demo/target/classes/com/demo/HelloWorld.class</span><br><span class="line">Classfile /D:/Workspace/JVM/demo/target/classes/com/demo/HelloWorld.class</span><br><span class="line">  Last modified 2023-3-30; size 553 bytes</span><br><span class="line">  MD5 checksum a920c142d5bb891e2b9fc1ff43b55128                                               </span><br><span class="line">  Compiled from &quot;HelloWorld.java&quot;                                                             </span><br><span class="line">public class com.demo.HelloWorld                                                              </span><br><span class="line">  minor version: 0                                                                            </span><br><span class="line">  major version: 52                                                                           </span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER                                                                </span><br><span class="line">Constant pool:                                                                                </span><br><span class="line">   #1 = Methodref          #6.#20         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V                    </span><br><span class="line">   #2 = Fieldref           #21.#22        // java/lang/System.out:Ljava/io/PrintStream;       </span><br><span class="line">   #3 = String             #23            // Hello, World!                                    </span><br><span class="line">   #4 = Methodref          #24.#25        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = Class              #26            // com/demo/HelloWorld                              </span><br><span class="line">   #6 = Class              #27            // java/lang/Object                                 </span><br><span class="line">   #7 = Utf8               &lt;init&gt;                                                             </span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Lcom/demo/HelloWorld;</span><br><span class="line">  #14 = Utf8               main</span><br><span class="line">  #15 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #16 = Utf8               args</span><br><span class="line">  #17 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #18 = Utf8               SourceFile</span><br><span class="line">  #19 = Utf8               HelloWorld.java</span><br><span class="line">  #20 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #21 = Class              #28            // java/lang/System</span><br><span class="line">  #22 = NameAndType        #29:#30        // out:Ljava/io/PrintStream;</span><br><span class="line">  #23 = Utf8               Hello, World!</span><br><span class="line">  #24 = Class              #31            // java/io/PrintStream</span><br><span class="line">  #25 = NameAndType        #32:#33        // println:(Ljava/lang/String;)V</span><br><span class="line">  #26 = Utf8               com/demo/HelloWorld</span><br><span class="line">  #27 = Utf8               java/lang/Object</span><br><span class="line">  #28 = Utf8               java/lang/System</span><br><span class="line">  #29 = Utf8               out</span><br><span class="line">  #30 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #31 = Utf8               java/io/PrintStream</span><br><span class="line">  #32 = Utf8               println</span><br><span class="line">  #33 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  public com.demo.HelloWorld();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom/demo/HelloWorld;</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3                  // String Hello, World!</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 5: 0</span><br><span class="line">        line 6: 8</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       9     0  args   [Ljava/lang/String;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;HelloWorld.java&quot;</span><br></pre></td></tr></table></figure><p>上面的结果中主要包含三部分</p><div class="tabs" id="test2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test2-1">类的基本信息</button></li><li class="tab"><button type="button" data-href="#test2-2">常量池</button></li><li class="tab"><button type="button" data-href="#test2-3">类的方法</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test2-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Classfile /D:/Workspace/JVM/demo/target/classes/com/demo/HelloWorld.class</span><br><span class="line">  Last modified 2023-3-30; size 553 bytes</span><br><span class="line">  MD5 checksum a920c142d5bb891e2b9fc1ff43b55128                                               </span><br><span class="line">  Compiled from &quot;HelloWorld.java&quot;                                                             </span><br><span class="line">public class com.demo.HelloWorld                                                              </span><br><span class="line">  minor version: 0                                                                            </span><br><span class="line">  major version: 52                                                                           </span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER        </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:                                                                                </span><br><span class="line">   #1 = Methodref          #6.#20         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V                    </span><br><span class="line">   #2 = Fieldref           #21.#22        // java/lang/System.out:Ljava/io/PrintStream;       </span><br><span class="line">   #3 = String             #23            // Hello, World!                                    </span><br><span class="line">   #4 = Methodref          #24.#25        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = Class              #26            // com/demo/HelloWorld                              </span><br><span class="line">   #6 = Class              #27            // java/lang/Object                                 </span><br><span class="line">   #7 = Utf8               &lt;init&gt;                                                             </span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Lcom/demo/HelloWorld;</span><br><span class="line">  #14 = Utf8               main</span><br><span class="line">  #15 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #16 = Utf8               args</span><br><span class="line">  #17 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #18 = Utf8               SourceFile</span><br><span class="line">  #19 = Utf8               HelloWorld.java</span><br><span class="line">  #20 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #21 = Class              #28            // java/lang/System</span><br><span class="line">  #22 = NameAndType        #29:#30        // out:Ljava/io/PrintStream;</span><br><span class="line">  #23 = Utf8               Hello, World!</span><br><span class="line">  #24 = Class              #31            // java/io/PrintStream</span><br><span class="line">  #25 = NameAndType        #32:#33        // println:(Ljava/lang/String;)V</span><br><span class="line">  #26 = Utf8               com/demo/HelloWorld</span><br><span class="line">  #27 = Utf8               java/lang/Object</span><br><span class="line">  #28 = Utf8               java/lang/System</span><br><span class="line">  #29 = Utf8               out</span><br><span class="line">  #30 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #31 = Utf8               java/io/PrintStream</span><br><span class="line">  #32 = Utf8               println</span><br><span class="line">  #33 = Utf8               (Ljava/lang/String;)V</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-3"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:                                                                                </span><br><span class="line">   #1 = Methodref          #6.#20         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V                    </span><br><span class="line">   #2 = Fieldref           #21.#22        // java/lang/System.out:Ljava/io/PrintStream;       </span><br><span class="line">   #3 = String             #23            // Hello, World!                                    </span><br><span class="line">   #4 = Methodref          #24.#25        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = Class              #26            // com/demo/HelloWorld                              </span><br><span class="line">   #6 = Class              #27            // java/lang/Object                                 </span><br><span class="line">   #7 = Utf8               &lt;init&gt;                                                             </span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Lcom/demo/HelloWorld;</span><br><span class="line">  #14 = Utf8               main</span><br><span class="line">  #15 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #16 = Utf8               args</span><br><span class="line">  #17 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #18 = Utf8               SourceFile</span><br><span class="line">  #19 = Utf8               HelloWorld.java</span><br><span class="line">  #20 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #21 = Class              #28            // java/lang/System</span><br><span class="line">  #22 = NameAndType        #29:#30        // out:Ljava/io/PrintStream;</span><br><span class="line">  #23 = Utf8               Hello, World!</span><br><span class="line">  #24 = Class              #31            // java/io/PrintStream</span><br><span class="line">  #25 = NameAndType        #32:#33        // println:(Ljava/lang/String;)V</span><br><span class="line">  #26 = Utf8               com/demo/HelloWorld</span><br><span class="line">  #27 = Utf8               java/lang/Object</span><br><span class="line">  #28 = Utf8               java/lang/System</span><br><span class="line">  #29 = Utf8               out</span><br><span class="line">  #30 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #31 = Utf8               java/io/PrintStream</span><br><span class="line">  #32 = Utf8               println</span><br><span class="line">  #33 = Utf8               (Ljava/lang/String;)V</span><br></pre></td></tr></table></figure><p>其中如下内容就表示虚拟机的指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">复制成功0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">3: ldc           #3                  // String Hello, World!    </span><br><span class="line">5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">8: return                            </span><br></pre></td></tr></table></figure><p>解释器去翻译虚拟机指令的时候，看到的只有这些</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">getstatic     #2</span><br><span class="line">ldc           #3</span><br><span class="line">invokevirtual #4</span><br></pre></td></tr></table></figure><p>解释器在解释的时候，就是拿着#2、#3、#4去查表翻译，查的就是常量池中的内容</p><ul><li>用#2举例，查表内容如下</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">getstatic     #2                        // 获取静态变量System.out</span><br><span class="line">#2 = Fieldref            #21.#22        // java/lang/System.out:Ljava/io/PrintStream;     </span><br><span class="line">#21 = Class              #28            // java/lang/System</span><br><span class="line">#28 = Utf8               java/lang/System</span><br><span class="line">#22 = NameAndType        #29:#30        // out:Ljava/io/PrintStream;</span><br><span class="line">#29 = Utf8               out</span><br><span class="line">#30 = Utf8               Ljava/io/PrintStream;</span><br></pre></td></tr></table></figure><ul><li>用#3举例，查表内容如下</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">ldc           #3                        // 加载参数Hello, World!</span><br><span class="line">#3 = String              #23            // Hello, World!        </span><br><span class="line">#23 = Utf8               Hello, World!</span><br></pre></td></tr></table></figure><ul><li>用#4举例，查表内容如下</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PLAINTEXT</span><br><span class="line">invokevirtual #4                        // 执行虚方法调用，调用println，输出Hello, World!</span><br><span class="line">#4 = Methodref           #24.#25        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">#24 = Class              #31            // java/io/PrintStream</span><br><span class="line">#31 = Utf8               java/io/PrintStream</span><br><span class="line">#25 = NameAndType        #32:#33        // println:(Ljava/lang/String;)V</span><br><span class="line">#32 = Utf8               println</span><br><span class="line">#33 = Utf8               (Ljava/lang/String;)V</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p><strong>常量池</strong>：<br>就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息<br><strong>运行时常量池</strong>：<br>常量池是 *.class 文件中的，当该类被加载以后，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</p><h2 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h2><ul><li>常量池中的字符串仅是符号，只有在被用到时才会转化为对象</li><li>利用串池的机制，来避免重复创建字符串对象</li><li>字符串变量拼接的原理是StringBuilder</li><li>字符串常量拼接的原理是编译器优化</li><li>可以使用intern方法，主动将串池中还没有的字符串对象放入串池中</li></ul><h3 id="intern方法"><a href="#intern方法" class="headerlink" title="intern方法"></a><strong>intern方法</strong></h3><p>调用字符串对象的 intern 方法，会将该字符串对象尝试放入到串池中</p><ul><li>如果串池中没有该字符串对象，则放入成功</li><li>如果有该字符串对象，则放入失败</li><li>无论放入是否成功，都会返回串池中的字符串对象</li></ul><p>注意：此时如果调用 intern 方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个对象</p><h3 id="StringTable-的位置"><a href="#StringTable-的位置" class="headerlink" title="StringTable 的位置"></a>StringTable 的位置</h3><ul><li>在 <code>JDK 1.6</code> 中，字符串常量池（也就是 StringTable）是位于<code>永久代</code>中的。而在 <code>JDK 1.8</code> 中，永久代已经被移除，取而代之的是元空间（Metaspace），而字符串常量池也随之移动到了<code>堆</code>中。这意味着在 JDK 1.8 中，字符串常量池中的字符串也可以被垃圾回收器回收，而在 JDK 1.6 中则不行。</li></ul><h3 id="StringTable-垃圾回收"><a href="#StringTable-垃圾回收" class="headerlink" title="StringTable 垃圾回收"></a>StringTable 垃圾回收</h3><ul><li><p>指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-Xmx10m 指定堆内存大小</span><br><span class="line">-XX:+PrintStringTableStatistics 打印字符串常量池信息</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-verbose:gc 打印 gc 的次数，耗费时间等信息</span><br></pre></td></tr></table></figure></li></ul><ul><li>在 Java 8 及更高版本中，字符串常量池位于堆中，而堆是 JVM 中的一部分，因此字符串常量池中的字符串可以被垃圾回收器回收。具体来说，只有当字符串没有被任何对象引用时，它才能被垃圾回收。当字符串被回收时，它的存储空间将被释放并可以被重新利用。</li></ul><h3 id="StringTable性能调优"><a href="#StringTable性能调优" class="headerlink" title="StringTable性能调优"></a>StringTable性能调优</h3><p>JVM内部，字符串常量池就是通过哈希表（数组 + 链表）实现的。</p><ul><li><p>添加VM参数-XX:StringTableSize&#x3D;1024，实际上设置的是哈希表的大小（数组的数量）。较小的哈希表意味着更多的哈希冲突。这会增加查找字符串的开销，因为需要在链表中进行顺序搜索才能找到一个字符串。因此，这将会导致字符串查找速度变慢。</p></li><li><p>如果应用需要存储大量字符串常量信息，而且这些字符串常量包含大量重复内容，可以使用Java中的字符串常量池机制，通过调用intern()方法将常量放入常量池中，以节省内存空间并提高性能。</p></li><li><p>实际应用：</p><ul><li>根据推特的工程师们所说，推特在存储用户地址信息时采用了字符串常量池的方法。推特上有大量的用户地址信息，而这些信息中有大量的重复内容，如街道名称、城市、州等。通过将这些常见的地址信息存储在字符串常量池中，推特可以节省大量的内存空间。</li><li>推特使用了Guava库中的Interners工具类来实现字符串常量池。该工具类提供了线程安全的字符串常量池实现，支持不同的策略和配置，例如并发级别、最大容量等。推特选择了使用一个全局的、不限容量的字符串常量池来存储用户地址信息。在存储用户信息时，推特使用了String.intern()方法来将地址信息存储在字符串常量池中，而不是直接使用新的字符串对象。这样，推特可以确保相同的地址信息只会在内存中存在一份拷贝，从而减少内存的占用。</li><li>通过这种方法，推特成功地实现了在存储大量用户信息时，有效地减少了内存占用。</li></ul></li></ul><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>如果我们需要存储大量字符串常量信息，而且这些字符串常量包含大量重复内容，可以使用Java中的字符串常量池机制，通过调用intern()方法将常量放入常量池中，以节省内存空间并提高性能。</p><h1 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h1><p><strong>定义：</strong></p><ul><li>JVM的直接内存是指JVM中的一个内存区域，也被称为NIO直接缓冲区。和Java堆不同，直接内存并不是由JVM自动管理的，而是由操作系统直接管理的。直接内存的访问速度比Java堆要快，因为它们可以利用操作系统提供的一些优化机制来提高I&#x2F;O的效率。</li><li>在Java程序中，可以通过ByteBuffer.allocateDirect()方法来创建直接缓冲区。当调用该方法创建直接缓冲区时，JVM会向操作系统申请一块直接内存，用于存储该缓冲区的数据。这个过程不会像在Java堆中创建对象一样，需要进行垃圾回收和堆内存分配的操作，因此创建直接缓冲区的效率要高于在Java堆中创建对象。</li><li>需要注意的是，直接内存是不受JVM的内存管理机制控制的，因此如果使用不当，可能会导致内存泄漏等问题。此外，因为直接内存的访问速度快，但申请和释放直接内存的开销较大，因此需要谨慎使用，避免频繁创建和销毁直接缓冲区。</li></ul><p>特点：</p><ol><li>常见于NIO操作时，用于数据缓冲区</li><li>分配回收成本较高，但读写性能高</li><li>不收JVM内存回收管理</li></ol><h2 id="为什么使用它"><a href="#为什么使用它" class="headerlink" title="为什么使用它"></a>为什么使用它</h2><p>使用直接内存比传统IO快</p><p>原因是直接内存使用的是操作系统的文件映射机制，而传统IO则需要将文件内容读取到内存中再进行操作。直接内存可以避免将文件数据复制到Java堆内存中的过程，减少了不必要的数据复制，从而提高了效率。</p><ul><li>传统IO，将文件读取到系统缓冲区中，但是Java代码不能直接读取系统缓冲区，所以需要在堆内存中分配一块Java缓冲区，将数据从系统缓冲区读取到Java缓冲区后，才能进行写操作</li><li>直接内存的Direct Memory对Java堆内存和系统内存是共享的一块内存区，那么磁盘文件就可以直接读取到Direct Memory，而Java堆内存也可以直接访问Direct Memory</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310252201792.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310252202817.png"></p><h2 id="直接内存溢出"><a href="#直接内存溢出" class="headerlink" title="直接内存溢出"></a>直接内存溢出</h2><ul><li>直接内存（Direct Memory）是一种Java NIO中用于高性能I&#x2F;O操作的内存分配方式，与Java虚拟机中的Java堆不同，它不会受到Java堆大小的限制。直接内存是通过操作系统的内存来分配和释放，因此它不会受到Java堆大小限制的影响，可以更加灵活地使用。</li><li>然而，如果过度使用直接内存，也可能会导致直接内存溢出。直接内存的使用需要手动进行管理，如果不注意及时释放已经使用的直接内存，或者申请过多的直接内存，就会导致直接内存溢出。</li><li>当直接内存溢出时，通常会抛出java.lang.OutOfMemoryError异常。为了避免直接内存溢出，建议在使用完直接内存后及时进行释放</li></ul><h2 id="分配和回收原理"><a href="#分配和回收原理" class="headerlink" title="分配和回收原理"></a>分配和回收原理</h2><p>直接内存不受JVM的管理，所以垃圾回收gc()对直接内存无效，那么直接内存是如何分配和回收的呢？</p><ul><li>Java里有一个非常底层的类<code>Unsafe</code>，它可以分配直接内存和释放直接内存，但是一般不建议我们直接使用Unsafe类，都是JDK内部自己去使用这个类的。</li></ul><ul><li><p>所以对于直接内存需要使用<code>Unsafe</code>对象完成直接内存的分配回收，并且回收需要主动调用<code>freeMemory</code>方法</p></li><li><p>ByteBuffer.allocateDirect()的底层实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Allocates a new direct byte buffer.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt; The new buffer&#x27;s position will be zero, its limit will be its</span><br><span class="line"> * capacity, its mark will be undefined, and each of its elements will be</span><br><span class="line"> * initialized to zero.  Whether or not it has a</span><br><span class="line"> * &#123;@link #hasArray backing array&#125; is unspecified.</span><br><span class="line"> *</span><br><span class="line"> * @param  capacity</span><br><span class="line"> *         The new buffer&#x27;s capacity, in bytes</span><br><span class="line"> *</span><br><span class="line"> * @return  The new byte buffer</span><br><span class="line"> *</span><br><span class="line"> * @throws  IllegalArgumentException</span><br><span class="line"> *          If the &lt;tt&gt;capacity&lt;/tt&gt; is a negative integer</span><br><span class="line"> */</span><br><span class="line">public static ByteBuffer allocateDirect(int capacity) &#123;</span><br><span class="line">    return new DirectByteBuffer(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>找到<code>DirectByteBuffer</code>对象的源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// Primary constructor</span><br><span class="line">//</span><br><span class="line">DirectByteBuffer(int cap) &#123;                   // package-private</span><br><span class="line">    super(-1, 0, cap, cap);</span><br><span class="line">    boolean pa = VM.isDirectMemoryPageAligned();</span><br><span class="line">    int ps = Bits.pageSize();</span><br><span class="line">    long size = Math.max(1L, (long)cap + (pa ? ps : 0));</span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">    long base = 0;</span><br><span class="line">    try &#123;</span><br><span class="line">        base = unsafe.allocateMemory(size);</span><br><span class="line">    &#125; catch (OutOfMemoryError x) &#123;</span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        throw x;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.setMemory(base, size, (byte) 0);</span><br><span class="line">    if (pa &amp;&amp; (base % ps != 0)) &#123;</span><br><span class="line">        // Round up to page boundary</span><br><span class="line">        address = base + ps - (base &amp; (ps - 1));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    cleaner = Cleaner.create(this, new Deallocator(base, size, cap));</span><br><span class="line">    att = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>从底层源码中我们可以看到，这里就是使用Unsafe对象对直接内存的分配，但是却没有看到回收方法<code>freeMemory</code></li></ul><ul><li><p>其实释放的方法是在Deallocator()这个回调方法中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private static class Deallocator</span><br><span class="line">    implements Runnable</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    private static Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line">    private long address;</span><br><span class="line">    private long size;</span><br><span class="line">    private int capacity;</span><br><span class="line"></span><br><span class="line">    private Deallocator(long address, long size, int capacity) &#123;</span><br><span class="line">        assert (address != 0);</span><br><span class="line">        this.address = address;</span><br><span class="line">        this.size = size;</span><br><span class="line">        this.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void run() &#123;</span><br><span class="line">        if (address == 0) &#123;</span><br><span class="line">            // Paranoia</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        unsafe.freeMemory(address);</span><br><span class="line">        address = 0;</span><br><span class="line">        Bits.unreserveMemory(size, capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>而它是由Cleaner调用的， Cleaner（虚引用类型）是用来监测<code>ByteBuffer</code>对象的，一旦<code>ByteBuffer</code>对象被垃圾<code>回收</code>，那么就会由<code>ReferenceHandler</code>线程通过<code>Cleaner</code>的<code>clean</code>方法调用<code>freeMemory</code>来释放直接内存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void clean() &#123;</span><br><span class="line">    if (remove(this)) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            this.thunk.run();</span><br><span class="line">        &#125; catch (final Throwable var2) &#123;</span><br><span class="line">            AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                public Void run() &#123;</span><br><span class="line">                    if (System.err != null) &#123;</span><br><span class="line">                        (new Error(&quot;Cleaner terminated abnormally&quot;, var2)).printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.exit(1);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="禁用垃圾回收对直接内存的影响"><a href="#禁用垃圾回收对直接内存的影响" class="headerlink" title="禁用垃圾回收对直接内存的影响"></a>禁用垃圾回收对直接内存的影响</h2><ul><li>由于垃圾回收是一个相对昂贵的操作，需要消耗CPU时间和系统资源。频繁调用System.gc()可能会导致性能下降，并且在某些情况下可能会造成应用程序的不稳定性。</li><li>所以为了避免有些程序员老是手动调用垃圾回收，我们一般会进制显式手动垃圾回收，添加VM参数<code>-XX:+DisableExplicitGC</code>禁用显式的垃圾回收</li><li>那么加上这个参数以后，可能就会影响到我们的直接内存的回收机制，例如下面的代码中，执行完System.gc()后（被禁用，相当于没执行），由于内存很充裕，所以ByteBuffer对象并不会被回收，那么ByteBuffer对象对应的那块直接内存，也不会被回收</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Demo_16 &#123;</span><br><span class="line">    static int _1GB = 1024 * 1024 * 1024;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1GB);</span><br><span class="line">        System.out.println(&quot;分配完毕&quot;);</span><br><span class="line">        byteBuffer = null;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(&quot;释放完毕&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程</title>
      <link href="/2023/07/04/Java16%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2023/07/04/Java16%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>程序：为完成特定任务，用某种语言编写的一组指令的集合。</p><p>进程：运行中的程序。当你运行一个程序，系统就会为该进程分配空间。进程是程序的一次执行过程。是一个动态过程，有其自身产生、存在、消亡的过程。</p><p>线程：由进程创建的，进程的一个实体。一个进程可以有多个线程。</p><p>单线程：同一时刻，只允许执行一个线程。</p><p>多线程：同一时刻，可以执行多个线程。</p><p>并发：同一时刻，多个任务交替执行，造成一种貌似并行的状态。单核 CPU 实现的多任务就是并发。</p><p>并行：同一时刻，多个任务同时进行。多核 CPU 可以实现并行。</p><blockquote><p>进程即是程序在处理机中的一次运行。在这样一个结构中不仅包含程序代码，也包括了系统资源的概念。</p><p>在单 CPU 计算机内部，微观上讲，同一时间只能有一个线程运行。实现多线程即从宏观上使多个作业同时执行。</p></blockquote><h2 id="用户线程和守护线程"><a href="#用户线程和守护线程" class="headerlink" title="用户线程和守护线程"></a>用户线程和守护线程</h2><ul><li><p>用户线程：也叫工作线程。当线程任务执行完毕或通知方式结束</p></li><li><p>守护线程：一般是为工作线程服务的。当所有线程结束，守护线程自动结束</p><p>常见的守护线程：垃圾回收机制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread thraed = new Thread(bullet);</span><br><span class="line">thread.setDeamon(true);//这样，子线程被设置为主线程的守护线程</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure></li></ul><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><blockquote><p>Java 的线程是通过包 java.lang 中定义的类 Thread 或者 接口 Runnable来实现的。当生成了一个 Thread 类后就产生了一个线程。通过该对象实例，可以启动线程、终止线程，或暂时挂起线程</p></blockquote><p>线程共有 4 种状态：新建（New）、可运行（Runnable）、死亡（Dead）、阻塞（Blocked）</p><ul><li><p><strong>新建（New）：</strong></p><p>线程对象刚刚创建，还未启动（New）。此时还处于不可运行状态，但已有了相应内存空间及其他资源</p></li><li><p><strong>可运行（Runnable）：</strong></p><p>此时线程已经启动，处于线程的 run() 方法中。这种情况下线程可能正在运行；也可能没有运行，但只要 CPU 空闲就会立刻运行。</p><p>可以运行但没在运行的线程都排在一个队列中，这个队列称为就绪队列。</p><p>可运行状态下，运行中的线程处于运行状态（Running），未运行线程处于就绪状态（Ready）。</p><p>调用 start() 方法可以让线程进入可运行状态。</p></li><li><p><strong>死亡（Dead）：</strong></p><p>线程死亡（Terminated）的原因有两个：一是 run() 方法最后一个语句执行完毕，二是线程遇到异常退出</p></li><li><p><strong>阻塞（Blocked）：</strong></p><p>一个正常运行的线程因为特殊原因被暂停执行，就进入阻塞状态（Blocked）。</p><p>阻塞时线程不能进入就绪对流排队，必须等到引起阻塞的原因消除，才能重新进入队列排队。</p><p>引起阻塞的方法很多，sleep() 和 wait() 是两个常用的阻塞方法</p></li><li><p><strong>中断线程：</strong></p><ul><li><p>void interrupt()：向一个线程发送一个中断请求，并把该线程的 interruptd 状态变为 true。</p><p>中断阻塞线程的场合，会抛出 InterruptException 异常</p></li><li><p>static boolean interrupted()：检测当前线程是否被中断，并重置状态 interrupted 的值。</p><p>连续调用该方法的场合，第二次调用会返回 false</p></li><li><p>boolean isInterrupted()：检测当前线程是否中断。不改变 interrupted 的值</p></li></ul></li></ul><h1 id="线程的创建和使用"><a href="#线程的创建和使用" class="headerlink" title="线程的创建和使用"></a>线程的创建和使用</h1><h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h2><p>在 Java 中线程使用有两种方法：</p><ol><li><p>继承 Thread 类，重写 run 方法</p></li><li><p>实现 Runable 接口，重写 run 方法</p></li></ol><blockquote><p>public class Thread implements RunnableThread 也是实现了 Runable 接口</p></blockquote><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310142038052.png"></p><h3 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h3><blockquote><p>Thread 类是 Java 用于表示线程的类。那么，一个类被定义为其子类，则该类也能用来表示线程</p></blockquote><ol><li>当一个类继承了 Thread 类， 该类就可以当做线程使用</li><li>run方法，Thread 类实现了 Runnable 接口的run方法</li><li>我们需要重写 run方法，写上自己的业务代码</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class Thread01 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        //创建Cat对象，可以当做线程使用</span><br><span class="line">        Cat cat = new Cat();</span><br><span class="line">        cat.start();//启动线程-&gt; 最终会执行cat的run方法</span><br><span class="line">        </span><br><span class="line">        //说明: 当main线程启动一个子线程 Thread-0, 主线程不会阻塞, 会继续执行</span><br><span class="line">        //这时 主线程和子线程是交替执行..</span><br><span class="line">        System.out.println(&quot;主线程继续执行&quot; + Thread.currentThread().getName());//名字main</span><br><span class="line">        for(int i = 0; i &lt; 60; i++) &#123;</span><br><span class="line">            System.out.println(&quot;主线程 i=&quot; + i);</span><br><span class="line">            //让主线程休眠</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat extends Thread &#123;</span><br><span class="line">    int times = 0;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;//重写run方法，写上自己的业务逻辑</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            //该线程每隔1秒。在控制台输出 “喵喵, 我是小猫咪”</span><br><span class="line">            System.out.println(&quot;喵喵, 我是小猫咪&quot; + (++times) + &quot; 线程名=&quot; +  Thread.currentThread().getName());</span><br><span class="line">            //让该线程休眠1秒 ctrl+alt+t</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            if(times == 80) &#123;</span><br><span class="line">                break;//当times 到80, 退出while, 这时线程也就退出..</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现-Runable-接口"><a href="#实现-Runable-接口" class="headerlink" title="实现 Runable 接口"></a>实现 Runable 接口</h3><blockquote><p>Runnable 是 Java 用以实现线程的接口。任何实现线程的类都必须实现该接口。</p></blockquote><ol><li><p>java是单继承的，在某些情况下一一个类可能已经继承了某个父类，这时在用继承Thread类方法来创建线程显然不可能了。</p></li><li><p>java设计者们提供了另外个方式创建线程，就是通过实现Runnable接口来创建线程</p></li><li><p>但是，实现接口这里，因为类没有 start 方法，所以创建线程的方法有所不同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//dog.start(); 这里不能调用start，dog类里面没有这个方法啊</span><br><span class="line">//创建了Thread对象，把 dog对象(实现Runnable),放入Thread</span><br><span class="line">Thread thread = new Thread(dog);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><blockquote><p>这里底层使用了设计模式</p></blockquote></li></ol><p><strong>运用看上方代码</strong></p><p><strong>原理看下方代码</strong></p><p>例.模拟实现设计模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//模拟一个 Thread 类</span><br><span class="line">class ThreadProxy implements Runnable &#123;//你可以把Proxy类当做 ThreadProxy</span><br><span class="line"></span><br><span class="line">    private Runnable target = null;//属性，类型是 Runnable</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        if (target != null) &#123;</span><br><span class="line">            target.run();//动态绑定（运行类型Tiger）</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //构造器，所有实现了 Runnable 接口的类都能传来</span><br><span class="line">    public ThreadProxy(Runnable target) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //模拟的 start 方法</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        start0();//这个方法时真正实现多线程方法</span><br><span class="line">    &#125;</span><br><span class="line">    public void start0() &#123;</span><br><span class="line">        run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图中构造器参数显示，可以接受 Runnable 的实现类，实现 Thread 对象接受相应的实现类，运行线程的方法</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310142118198.png"></p><h3 id="继承-Thread-和-实现-Runable-的区别"><a href="#继承-Thread-和-实现-Runable-的区别" class="headerlink" title="继承 Thread 和 实现 Runable 的区别"></a>继承 Thread 和 实现 Runable 的区别</h3><ol><li>从 Java 设计来看，两者本质上没有区别。Thread 类本身就实现了 Runable 接口，但是 java 是单继承的</li><li>实现 Runable 接口的方式更加适合多个线程共享一个资源的情况，配合Thread类创建新线程，避免了单继承的限制。建议使用</li></ol><h2 id="run-和-start"><a href="#run-和-start" class="headerlink" title="run() 和 start()"></a>run() 和 start()</h2><p>对象.start(); 启动线程，最终会执行cat的run方法，那为什么不直接执行 run方法呢？</p><p>对象.run() 相当于调用类中的 run方法，没有启动线程的功能。这个方法运行完以后，才会继续执行该线程后续的代码。</p><p>run里面只写了要执行的功能。而对象.start()才是真正创建线程并调用该对象的run方法</p><p>start() 源码：</p><ol><li>start() 方法调用了一个 start0() 底层方法</li><li>start0() 是本地方法，由 JVM 调用，底层是 c&#x2F;c++ 实现</li><li>真正的多线程效果，是 start0()，而不是 run()</li><li>start() 方法调用 start0() 方法后，该线程不一定会立刻执行，只是将线程变成了可运行状态。具体何时运行，由 CPU 统一调度</li></ol><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310142101834.png"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310142059184.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void start() &#123;</span><br><span class="line">  start0();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//start0() 是本地方法，是JVM调用, 底层是c/c++实现</span><br><span class="line">//真正实现多线程的效果， 是start0(), 而不是 run</span><br><span class="line">private native void start0();</span><br></pre></td></tr></table></figure><h2 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h2><p>线程有2种终止原因：</p><ol><li><p>当线程结束后，会自动退出（自然行为）</p></li><li><p>还可以通过使用变量来控制 run 方法退出的方式来停止线程，即 <strong>通知方式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadExit_ &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        T t1 = new T();</span><br><span class="line">        t1.start();</span><br><span class="line">        //如果希望main线程去控制t1 线程的终止, 必须可以修改 loop</span><br><span class="line">        //让t1 退出run方法，从而终止 t1线程 -&gt; 通知方式      </span><br><span class="line">        //让主线程休眠 10 秒，再通知 t1线程退出</span><br><span class="line">        System.out.println(&quot;main线程休眠10s...&quot;);</span><br><span class="line">        Thread.sleep(10 * 1000);</span><br><span class="line">        t1.setLoop(false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class T extends Thread &#123;</span><br><span class="line">    private int count = 0;</span><br><span class="line">    //设置一个控制变量</span><br><span class="line">    private boolean loop = true;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (loop) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(50);// 让当前线程休眠50ms</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;T 运行中....&quot; + (++count));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setLoop(boolean loop) &#123;</span><br><span class="line">        this.loop = loop;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="线程常用方法"><a href="#线程常用方法" class="headerlink" title="线程常用方法"></a>线程常用方法</h2><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><ul><li><p>setName(name)：设置线程名称，使之与参数 name 相同</p></li><li><p>getName()：返回线程名称</p></li><li><p>start()：线程开始执行。JVM 调用 start0 方法。该方法会创建新的线程，新线程调用 run。</p></li><li><p>run()调用线程的 run 方法，接口给出，需要我们重写成我们的逻辑</p></li><li><p>sleep(int millsecond)让线程休眠指定的时间，该方法是 Thread 类的静态方法，可以直接调用</p></li><li><p>interrupt()中断线程（不是 中止）</p></li><li><p>wait()：导致当前线程等待</p><p>直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法才能唤醒此线程</p></li><li><p>notify()：唤醒因 wait() 阻塞的线程。</p><p>notifyAll()：唤醒因 wait() 阻塞的线程。</p><p>这些方法（wait()、notify()、notifyAll()）只能在 synchrnized 方法或代码块中调用</p></li><li><p>isAlive()：测试当前线程是否在活动</p></li><li><p>Thread.currentThread()：引用当前运行中的线程</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadMethod01 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        //测试相关的方法</span><br><span class="line">        T t = new T();</span><br><span class="line">        t.setName(&quot;老韩&quot;);</span><br><span class="line">        t.setPriority(Thread.MIN_PRIORITY);//1</span><br><span class="line">        t.start();//启动子线程</span><br><span class="line">        //主线程打印5 hi ,然后我就中断 子线程的休眠</span><br><span class="line">        for(int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            System.out.println(&quot;hi &quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(t.getName() + &quot; 线程的优先级 =&quot; + t.getPriority());//1</span><br><span class="line">        t.interrupt();//当执行到这里，就会中断 t线程的休眠.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class T extends Thread &#123; //自定义的线程类</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">                //Thread.currentThread().getName() 获取当前线程的名称</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;  吃包子~~~~&quot; + i);</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot; 休眠中~~~&quot;);</span><br><span class="line">                Thread.sleep(20000);//20秒</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                //当该线程执行到一个interrupt 方法时，就会catch 一个 异常, 可以加入自己的业务代码</span><br><span class="line">                //InterruptedException 是捕获到一个中断异常.</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + &quot;被 interrupt了&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="切换线程"><a href="#切换线程" class="headerlink" title="切换线程"></a>切换线程</h3><ul><li><p>yield()：线程的礼让。让出 CPU 让其他线程执行。因为礼让的时间不确定，所以不一定礼让成功。本质是 RUNNING 切换为 READY，即让当前线程放弃执行权</p></li><li><p>join()：线程的插队。插队的线程一旦插入成功，则必定先执行完插队线程的所有任务将导致其他线程的等待，直到 join() 方法的线程结束</p></li><li><p>join(long timeout)：join，但是时间到后也能结束其他线程的等待</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadMethod02 &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        T2 t2 = new T2();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        for(int i = 1; i &lt;= 20; i++) &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">            System.out.println(&quot;主线程(小弟) 吃了 &quot; + i  + &quot; 包子&quot;);</span><br><span class="line">            if(i == 5) &#123;</span><br><span class="line">                System.out.println(&quot;主线程(小弟) 让 子线程(老大) 先吃&quot;);</span><br><span class="line">                //join, 线程插队</span><br><span class="line">                //t2.join();// 这里相当于让t2 线程先执行完毕</span><br><span class="line">                //Thread.yield();//礼让，不一定成功..</span><br><span class="line">                System.out.println(&quot;线程(老大) 吃完了 主线程(小弟) 接着吃..&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class T2 extends Thread &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 1; i &lt;= 20; i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);//休眠1秒</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;子线程(老大) 吃了 &quot; + i +  &quot; 包子&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><ul><li><p>setPriority(int priority)：更改线程优先级</p></li><li><p>getPriority()：获取线程优先级</p><p>priority 范围：</p><ul><li>MAX_PRIORITY：最高优先级（10）</li><li>MIN_PRIORITY：最低优先级（1）</li><li>NORM_PRIORITY：不高不低，真是好极了的优先级（5）</li></ul><blockquote><p>每个线程都有一个<strong>优先级</strong>。Java 线程调度采用如下优先级策略：</p></blockquote><ul><li>优先级高的先执行，优先级低的后执行</li><li>每个线程创建时会被自动分配一个优先级。默认的场合，继承父类优先级</li><li>任务紧急的线程，优先级较高</li><li>同优先级线程按 “先进先出” 原则调度</li></ul></li></ul><h2 id="多线程机制"><a href="#多线程机制" class="headerlink" title="多线程机制"></a>多线程机制</h2><ul><li>main线程：程序运行时运行到 main 方法时，会创建 main线程</li><li>子线程：程序运行到 start() 方法时，会开启一个新线程</li></ul><p>Thread.currentThread().getName()：获取当前线程的名字</p><p>各线程间相互独立，某个线程的结束不会影响其他线程。各线程会继续按逻辑运行自己的代码，所有线程都关闭后，进程关闭。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310142052479.png"></p><h3 id="买票案例"><a href="#买票案例" class="headerlink" title="买票案例"></a>买票案例</h3><p>编程模拟三个售票窗口售票100，分别使用继承Thread和实现Runnable方式，并分析有什么问题?</p><p>如图，出现了资源超出的现象，这个问题需要通过线程同步来解决。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public class SellTicket &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">//        这里我们会出现超卖..</span><br><span class="line"></span><br><span class="line">//        System.out.println(&quot;===使用继承Thread方式来售票=====&quot;);</span><br><span class="line">//        SellTicket01 sellTicket01 = new SellTicket01();</span><br><span class="line">//        SellTicket01 sellTicket02 = new SellTicket01();</span><br><span class="line">//        SellTicket01 sellTicket03 = new SellTicket01();</span><br><span class="line">//        sellTicket01.start();//启动售票线程</span><br><span class="line">//        sellTicket02.start();//启动售票线程</span><br><span class="line">//        sellTicket03.start();//启动售票线程</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;===使用实现接口方式来售票=====&quot;);</span><br><span class="line">        SellTicket02 sellTicket02 = new SellTicket02();</span><br><span class="line">        new Thread(sellTicket02).start();//第1个线程-窗口</span><br><span class="line">        new Thread(sellTicket02).start();//第2个线程-窗口</span><br><span class="line">        new Thread(sellTicket02).start();//第3个线程-窗口</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//使用Thread方式</span><br><span class="line">class SellTicket01 extends Thread &#123;</span><br><span class="line">    private static int ticketNum = 100;//让多个线程共享 ticketNum</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (ticketNum &lt;= 0) &#123;</span><br><span class="line">                System.out.println(&quot;售票结束...&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //休眠50毫秒, 模拟</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(50);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;窗口 &quot; + Thread.currentThread().getName() + &quot; 售出一张票&quot;</span><br><span class="line">                    + &quot; 剩余票数=&quot; + (--ticketNum));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//实现接口方式</span><br><span class="line">class SellTicket02 implements Runnable &#123;</span><br><span class="line">    private int ticketNum = 100;//让多个线程共享 ticketNum</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (ticketNum &lt;= 0) &#123;</span><br><span class="line">                System.out.println(&quot;售票结束...&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //休眠50毫秒, 模拟</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(50);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;窗口 &quot; + Thread.currentThread().getName() + &quot; 售出一张票&quot;</span><br><span class="line">                    + &quot; 剩余票数=&quot; + (--ticketNum));//1 - 0 - -1  - -2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310142126917.png"></p><h1 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h1><p>线程的状态有（ java 官方枚举中给出的线程状态）：6种</p><ul><li><p><strong>新建（New）：</strong></p><p>线程对象刚刚创建，还未启动（New）。此时还处于不可运行状态，但已有了相应内存空间及其他资源</p></li><li><p><strong>可运行（Runnable）：</strong></p><p>此时线程已经启动，处于线程的 run() 方法中。这种情况下线程可能正在运行；也可能没有运行，但只要 CPU 空闲就会立刻运行。</p><p>可以运行但没在运行的线程都排在一个队列中，这个队列称为就绪队列。</p><p>可运行状态下，运行中的线程处于运行状态（Running），未运行线程处于就绪状态（Ready）。</p><p>调用 start() 方法可以让线程进入可运行状态。</p></li><li><p><strong>阻塞（Blocked）：</strong></p><p>一个正常运行的线程因为特殊原因被暂停执行，就进入阻塞状态（Blocked）。</p><p>阻塞时线程不能进入就绪对流排队，必须等到引起阻塞的原因消除，才能重新进入队列排队。</p><p>引起阻塞的方法很多，sleep() 和 wait() 是两个常用的阻塞方法</p></li><li><p>WAITING：正等待另一个线程执行特定动作的线程</p></li><li><p>TIMED_WAITING：正等待另一个线程执行特定动作达到等待时间的线程</p></li><li><p>TERMINATED：已退出的线程</p></li></ul><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310142205682.png"></p><h1 id="线程同步机制"><a href="#线程同步机制" class="headerlink" title="线程同步机制"></a>线程同步机制</h1><p>在多线程编程，一些敏感数据不允许被多个线程同时访问。此时就用同步访问技术，保证数据在任意时刻，最多有一个线程同时访问，以保证数据的完整性。</p><p>也可以这样理解：线程同步，即当有一个线程对内存进行操作时，其他线程都不能对这个内存地址进行操作（被阻塞），直到该线程完成操作，再让下一线程进行操作。</p><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><ol><li>Java语言中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。</li><li>每个对象都对应于一个可称为互斥锁的标记，这个标记用来保证在任一时刻,， 只能有一个线程访问该对象。</li><li>关键宇synchronized来与对象的互斥锁联系。当某个对象用synchronized修饰时，表明该对象在任一时刻只能由一 个线程访问</li><li>同步的局限性：导致程序的执行效率要降低</li><li>同步方法(非静态的)的锁可以是this，也可以是其他对象(要求是同一个对象)。</li><li>同步方法(静态的)的锁为当前类本身。同步方法(静态的)的锁为当前类本身。</li></ol><blockquote><p>同步方法如果没有使用static修饰，默认锁对象：this</p><p>如果方法使用static修饰，默认锁对象：当前类.class</p></blockquote><p>Java 语言中，有 2 种方式实现互斥锁：</p><ol><li><p>synchronized 关键字</p><p>同步代码块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized (对象) &#123;//得到对象的锁，才能操作同步代码</span><br><span class="line">需要被同步代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步方法：放在方法声明中，表示整个方法为同步方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void method()&#123;</span><br><span class="line">代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用关键字 volatile 声明一个共享数据（变量）。一般很少使用该关键字</p></li></ol><p>前面买票的改进</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">public class SellTicket &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SellTicket03 sellTicket03 = new SellTicket03();</span><br><span class="line">        new Thread(sellTicket03).start();//第1个线程-窗口</span><br><span class="line">        new Thread(sellTicket03).start();//第2个线程-窗口</span><br><span class="line">        new Thread(sellTicket03).start();//第3个线程-窗口</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//实现接口方式, 使用synchronized实现线程同步</span><br><span class="line">class SellTicket03 implements Runnable &#123;</span><br><span class="line">    private int ticketNum = 100;//让多个线程共享 ticketNum</span><br><span class="line">    private boolean loop = true;//控制run方法变量</span><br><span class="line">    Object object = new Object();</span><br><span class="line"></span><br><span class="line">    //同步方法（静态的）的锁为当前类本身</span><br><span class="line">    //1. public synchronized static void m1() &#123;&#125; 锁是加在 SellTicket03.class</span><br><span class="line">    //2. 如果在静态方法中，实现一个同步代码块.</span><br><span class="line">    public static  void m2() &#123;</span><br><span class="line">        synchronized (SellTicket03.class) &#123;</span><br><span class="line">            System.out.println(&quot;m2&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //1. public synchronized void sell() &#123;&#125; 就是一个同步方法</span><br><span class="line">    //2. 这时锁在 this对象</span><br><span class="line">    //3. 也可以在代码块上写 synchronize ,同步代码块, 互斥锁还是在this对象</span><br><span class="line">    public /*synchronized*/ void sell() &#123; //同步方法, 在同一时刻， 只能有一个线程来执行sell方法</span><br><span class="line">        synchronized (/*this*/ object) &#123;</span><br><span class="line">            if (ticketNum &lt;= 0) &#123;</span><br><span class="line">                System.out.println(&quot;售票结束...&quot;);</span><br><span class="line">                loop = false;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            //休眠50毫秒, 模拟</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(50);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;窗口 &quot; + Thread.currentThread().getName() + &quot; 售出一张票&quot;</span><br><span class="line">                    + &quot; 剩余票数=&quot; + (--ticketNum));//1 - 0 - -1  - -2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (loop) &#123;</span><br><span class="line">            sell();//sell方法是一共同步方法</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用Thread方式</span><br><span class="line">class SellTicket01 extends Thread &#123;</span><br><span class="line"></span><br><span class="line">    private static int ticketNum = 100;//让多个线程共享 ticketNum</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (ticketNum &lt;= 0) &#123;</span><br><span class="line">                System.out.println(&quot;售票结束...&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //休眠50毫秒, 模拟</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(50);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;窗口 &quot; + Thread.currentThread().getName() + &quot; 售出一张票&quot;</span><br><span class="line">                    + &quot; 剩余票数=&quot; + (--ticketNum));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//实现接口方式</span><br><span class="line">class SellTicket02 implements Runnable &#123;</span><br><span class="line">    private int ticketNum = 100;//让多个线程共享 ticketNum</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (ticketNum &lt;= 0) &#123;</span><br><span class="line">                System.out.println(&quot;售票结束...&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            //休眠50毫秒, 模拟</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(50);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;窗口 &quot; + Thread.currentThread().getName() + &quot; 售出一张票&quot;</span><br><span class="line">                    + &quot; 剩余票数=&quot; + (--ticketNum));//1 - 0 - -1  - -2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h2><p>多个线程都占用了对方的资源，不肯相让，就导致了死锁。编程时要避免死锁的产生。</p><p>上锁是要消耗资源的，应尽量减少上锁的次数，优化代码。</p><p>如一个循环，锁在循环体内和循环体外差距极大</p><ul><li><p>释放锁操作</p><ol><li>当前线程的同步方法、同步代码块执行结束。</li><li>当前线程在同步方法、同步代码块中遇到 break、return</li><li>当前线程在同步方法、同步代码块中出现了未处理的 Error</li><li>当前线程在同步方法、同步代码块中执行了 wait() 方法，当前线程暂停，并释放锁</li></ol></li><li><p><strong>不会</strong>释放锁操作</p><ol><li><p>执行同步方法、同步代码块时，程序调用 Thread.sleep() 或 Thread.yield() 方法暂停当前线程的执行，不会释放锁</p></li><li><p>线程执行同步代码块时，其他线程调用了该线程的 suspend() 方法将该线程挂起，该线程不会释放锁</p><p>所以，应尽量避免使用 suspend() 和 resume() 来控制线程</p></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java反射</title>
      <link href="/2023/07/01/Java15%E5%8F%8D%E5%B0%84/"/>
      <url>/2023/07/01/Java15%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="反射引出"><a href="#反射引出" class="headerlink" title="反射引出"></a>反射引出</h1><ol><li><p>根据配置文件re.properties指定信息，创建Cat对象并调用方法hi</p><p>classfullpath&#x3D; com.hspedu.Cat</p><p>method&#x3D; hi</p><p>使用现有技术，你能做的吗?</p></li><li><p>这样的需求在学习框架时特别多，即通过外部文件配置，在不修改源码情况下来控制程序，也符合设计模式的 ocp原则</p><p>开闭原则：不修改源码，扩容功能</p></li></ol><p>传统的方式 new 对象 -》 调用方法</p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">传统的方式</button></li><li class="tab"><button type="button" data-href="#test1-2">使用Properties 类</button></li><li class="tab"><button type="button" data-href="#test1-3">反射机制</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p>new对象调用方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cat cat = new Cat();</span><br><span class="line">cat.hi();   //cat.cry() 修改要修改源码，耦合度高</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p>使用Properties 类, 可以读写配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\re.properties&quot;</span>));</span><br><span class="line"><span class="type">String</span> <span class="variable">classfullpath</span> <span class="operator">=</span> properties.get(<span class="string">&quot;classfullpath&quot;</span>).toString();<span class="comment">//&quot;com.hspedu.Cat&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> properties.get(<span class="string">&quot;method&quot;</span>).toString();<span class="comment">//&quot;hi&quot;</span></span><br><span class="line">System.out.println(<span class="string">&quot;classfullpath=&quot;</span> + classfullpath);</span><br><span class="line">System.out.println(<span class="string">&quot;method=&quot;</span> + methodName);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 创建对象 , 传统的方法，行不通</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">classfullpath</span>();  <span class="comment">//虽然 classfullpath = com.hspedu.Cat，但是这东西不是类的构造方法，不能这么用</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//(1) 加载类, 返回Class类型的对象cls</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(classfullpath);</span><br><span class="line"><span class="comment">//(2) 通过 cls 得到你加载的类 com.hspedu.Cat 的对象实例</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> cls.newInstance();</span><br><span class="line">System.out.println(<span class="string">&quot;o的运行类型=&quot;</span> + o.getClass()); <span class="comment">//运行类型</span></span><br><span class="line"><span class="comment">//(3) 通过 cls 得到你加载的类 com.hspedu.Cat 的 methodName&quot;hi&quot;  的方法对象</span></span><br><span class="line"><span class="comment">//    即：在反射中，可以把方法视为对象（万物皆对象）</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method1</span> <span class="operator">=</span> cls.getMethod(methodName);</span><br><span class="line"><span class="comment">//(4) 通过method1 调用方法： 即通过方法对象来实现调用方法</span></span><br><span class="line">System.out.println(<span class="string">&quot;=============================&quot;</span>);</span><br><span class="line">method1.invoke(o); <span class="comment">//传统方法 对象.方法() , 反射机制 方法.invoke(对象)</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h1><ol><li>反射机制允许程序在执行期借助于 Reflection API 取得任何类的内部信息(比如成员变量，构造器，成员方法等等)，并能操作对象的属性及方法。反射在设计模式和框架底层都会用到</li><li>加载完类之后，在堆中就产生了一个 Class 类型的对象(一个类只有个 Class 对象) ，这个对象包含了类的完整结构信息。通过这个对象得到类的结构。这个对象就像一面镜子， 透过这个镜子看到类的结构，所以，形象的称之为：反射</li></ol><blockquote><p>Class类是一个特殊的类，反射相关的类都在 Java.lang.reflect 包中</p><p>除了Class，还有Method、Field、Constructor类</p></blockquote><h2 id="反射原理"><a href="#反射原理" class="headerlink" title="反射原理"></a>反射原理</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310151310761.png"></p><h2 id="反射功能"><a href="#反射功能" class="headerlink" title="反射功能"></a>反射功能</h2><ol><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时得到任意一个类所具有的成员变量和方法</li><li>在运行时调用任意一个对象的成员变量和方法</li><li>生成动态代理</li></ol><h2 id="反射相关类"><a href="#反射相关类" class="headerlink" title="反射相关类"></a>反射相关类</h2><ul><li><p>java.lang.Class：代表一个类。Class 对象表示某个类加载后在堆中的对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class cls = Class.forName(classFullPath);//1</span><br><span class="line">Object o = cls.newInstance();//2</span><br></pre></td></tr></table></figure><ol><li>通过完整类名得到一个类的 Class 对象</li><li>通过该 Class 对象创建一个该类的 对象实例</li></ol></li><li><p>java.lang.reflect.Method：代表类的方法。Method 对象表示某个类的某个方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method method = cls.getMethod(methodName);//[1]</span><br><span class="line">method.invoke(o);//[2]</span><br></pre></td></tr></table></figure><ol><li>通过该 Class 对象得到一个 方法对象</li><li>方法对象.invoke：调用该方法</li></ol></li><li><p>java.lang.reflect.Field：代表类的成员变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Field field = cls.getField(fieldName);</span><br></pre></td></tr></table></figure><ol><li>该方法只能得到非私有对象</li></ol></li><li><p>java.lang.reflect.Constructor：代表类的构造方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Constructor constructor = cls.getConstructor();         //[1]</span><br><span class="line">Constructor constructor2 = cls.getConstructor(String.class)  //[2]</span><br></pre></td></tr></table></figure><ol><li>得到一个无参构造器</li><li>得到一个形参是 (String str) 的构造器</li></ol></li></ul><h2 id="反射的优点和缺点"><a href="#反射的优点和缺点" class="headerlink" title="反射的优点和缺点"></a>反射的优点和缺点</h2><ul><li>优点：可以动态地创建和使用对象（也是框架底层核心），使用灵活。没有反射机制，框架技术就失去底层支撑</li><li>缺点：使用反射基本是解释执行。这对执行速度有影响。</li></ul><h3 id="反射调用优化"><a href="#反射调用优化" class="headerlink" title="反射调用优化"></a>反射调用优化</h3><ol><li>Method 和 Field、Constructor 对象都有 setAccessible() 方法</li><li>setAccessible() 作用是启动和禁用访问安全检查的开关</li><li>参数值为 true，表示反射对象在使用时取消访问检查，这样能提高反射效率。</li><li>参数值为 false 表示执行访问检查</li></ol><blockquote><p>后面的爆破也是这个方法</p></blockquote><h1 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h1><p><img src="/https%EF%BC%9A/raw.githubusercontent.com/icyhalo/picgo/main/202310311233755.png"></p><ol><li>Class 是一个特殊的类，在 java 中，任何类都至少有一个父类：Object</li><li>Class 类的对象不是 new 出来的，加载类的时候系统自动创建</li><li>对于某个类的Class类对象，在内存中只有一份， 因为类只加载一次</li><li>每个类的实例都会记得自己是由哪个Class实例所生成</li><li>通过Class对象可以完整地得到一个类的完整结构，通过一系列API</li><li>Class对象是存放在堆的</li><li>类的字节码二进制数据，是放在方法区的，有的地方称为类的元数据(包括 方法代码，变量名，方法名，访问权限等等)</li></ol><h2 id="Class-类的常用方法"><a href="#Class-类的常用方法" class="headerlink" title="Class 类的常用方法"></a>Class 类的常用方法</h2><p>首先要用 Class.forName() 获得类对象，不然一切免谈</p><ul><li><p>Class.forName(String)：返回指定类名的 Class 对象</p></li><li><p>newInstance()：返回一个无参构造器创建的实例</p></li><li><p>getName()：返回该 Class 对象表示的实体的全类名</p></li><li><p>getClass()：返回该 Class 对象的运行类型 java.lang.Class</p></li><li><p>getPackage()：返回该 Class 对象所在的包</p></li><li><p>getSuperClass()：返回该 Class 对象的父类 Class 对象</p></li><li><p>getInterface()：返回该 Class 对象的接口（数组）</p></li><li><p>getAnnotations()：返回注解信息（Annotation[]）</p></li><li><p>getClassLoader()：返回该 Class 对象的加载器（ClassLoader 类型）</p></li><li><p>getSuperclass()：返回该 Class 对象实体的超类的 Class</p></li><li><p>getConstructors()：返回本类所有包含 public 修饰的构造器的 Constructor 对象数组</p><p>该方法返回的构造器不含父类构造器！</p></li><li><p>getDeclaredConstructer()：返回本类所有构造器的 Constructor 对象数组</p></li><li><p>getFileds()：返回一个包含 public 修饰的属性的 Field 对象的数组</p><p>getFiled(String name)：返回指定的 Field</p></li><li><p>getDeclaredFields()：获取本类中所有属性</p></li><li><p>field.get(instance)：返回指定实例的指定属性</p></li><li><p>field.set(instance, ..)：给指定实例的指定属性赋值</p></li><li><p>getMethod()：获得所有 public 修饰的方法的 Method 对象</p></li><li><p>getMethod(String name, Class paramTypes, …)：返回一个 Method 对象，其形参类型为 paramType</p></li><li><p>getDeclaredMethod()：获取本类中所有方法</p></li></ul><div class="tabs" id="test2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test2-1">方法类</button></li><li class="tab"><button type="button" data-href="#test2-2">Car类</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test2-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Class02 &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchFieldException &#123;</span><br><span class="line">        String classAllPath = &quot;com.hspedu.Car&quot;;</span><br><span class="line">        //1 . 获取到Car类 对应的 Class对象</span><br><span class="line">        //&lt;?&gt; 表示不确定的Java类型</span><br><span class="line">        Class&lt;?&gt; cls = Class.forName(classAllPath);</span><br><span class="line">        //2. 输出cls</span><br><span class="line">        System.out.println(cls); //显示cls对象, 是哪个类的Class对象 com.hspedu.Car</span><br><span class="line">        System.out.println(cls.getClass());//输出cls运行类型 java.lang.Class</span><br><span class="line">        //3. 得到包名</span><br><span class="line">        System.out.println(cls.getPackage().getName());//包名</span><br><span class="line">        //4. 得到全类名</span><br><span class="line">        System.out.println(cls.getName());</span><br><span class="line">        //5. 通过cls创建对象实例</span><br><span class="line">        Car car = (Car) cls.newInstance();</span><br><span class="line">        System.out.println(car);//car.toString()</span><br><span class="line">        //6. 通过反射获取属性 brand</span><br><span class="line">        Field brand = cls.getField(&quot;brand&quot;);</span><br><span class="line">        System.out.println(brand.get(car));//宝马</span><br><span class="line">        //7. 通过反射给属性赋值</span><br><span class="line">        brand.set(car, &quot;奔驰&quot;);</span><br><span class="line">        System.out.println(brand.get(car));//奔驰</span><br><span class="line">        //8 我希望大家可以得到所有的属性(字段)</span><br><span class="line">        System.out.println(&quot;=======所有的字段属性====&quot;);</span><br><span class="line">        Field[] fields = cls.getFields();</span><br><span class="line">        for (Field f ： fields) &#123;</span><br><span class="line">            System.out.println(f.getName());//名称</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Car &#123;</span><br><span class="line">    public String brand = &quot;宝马&quot;;//品牌</span><br><span class="line">    public int price = 500000;</span><br><span class="line">    public String color = &quot;白色&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Car&#123;&quot; +</span><br><span class="line">                &quot;brand=&#x27;&quot; + brand + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, price=&quot; + price +</span><br><span class="line">                &quot;, color=&#x27;&quot; + color + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="获取-Class-类对象"><a href="#获取-Class-类对象" class="headerlink" title="获取 Class 类对象"></a>获取 Class 类对象</h2><p>总共有6种，但主要运用4种</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202311011028778.png"></p><ol><li><p>已知一一个类的全类名，且该类在类路径下，可通过Class类的静态方法 forName 获取，可能抛出ClassNotFoundException</p><p>应用场景：多用于配置文件，读取类全路径，加载类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//1. Class.forName</span><br><span class="line">String classAllPath = &quot;com.hspedu.Car&quot;; //通过读取配置文件获取</span><br><span class="line">Class&lt;?&gt; cls1 = Class.forName(classAllPath);</span><br><span class="line">System.out.println(cls1);</span><br></pre></td></tr></table></figure></li><li><p>若已知具体的类，通过类的class获取，该方式最为安全可靠，程序性能</p><p>最高实例：Class cls2 &#x3D; Cat.class; </p><p>应用场景：多用于参数传递，比如通过反射得到对应构造器对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//2. 类名.class , 应用场景： 用于参数传递</span><br><span class="line">Class cls2 = Car.class;</span><br><span class="line">System.out.println(cls2);</span><br></pre></td></tr></table></figure></li><li><p>已知某个类的实例，调用该实例的 getClass 方法获取Class对象</p><p>应用场景：通过创建好的对象，获取Class对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//3. 对象.getClass(), 应用场景，有对象实例</span><br><span class="line">Car car = new Car();</span><br><span class="line">Class cls3 = car.getClass();</span><br><span class="line">System.out.println(cls3);</span><br></pre></td></tr></table></figure></li><li><p>通过类加载器（4种）来获取到类的Class对象</p><ol><li>拿到类加载器</li><li>拿到Class对象</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//4. 通过类加载器【4种】来获取到类的Class对象</span><br><span class="line">//(1)先得到类加载器 car</span><br><span class="line">ClassLoader classLoader = car.getClass().getClassLoader();</span><br><span class="line">//(2)通过类加载器得到Class对象</span><br><span class="line">Class cls4 = classLoader.loadClass(classAllPath);</span><br><span class="line">System.out.println(cls4);</span><br></pre></td></tr></table></figure></li><li><p>基本数据 XXX.Class</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//5. 基本数据(int, char,boolean,float,double,byte,long,short) 按如下方式得到Class类对象</span><br><span class="line">Class&lt;Integer&gt; integerClass = int.class;</span><br><span class="line">Class&lt;Character&gt; characterClass = char.class;</span><br><span class="line">Class&lt;Boolean&gt; booleanClass = boolean.class;</span><br><span class="line">System.out.println(integerClass);//int</span><br></pre></td></tr></table></figure></li><li><p>包装类 XXX.TYPE</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//6. 基本数据类型对应的包装类，可以通过 .TYPE 得到Class类对象</span><br><span class="line">Class&lt;Integer&gt; type1 = Integer.TYPE;</span><br><span class="line">Class&lt;Character&gt; type2 = Character.TYPE; //其它包装类BOOLEAN, DOUBLE, LONG,BYTE等待</span><br><span class="line">System.out.println(type1);</span><br></pre></td></tr></table></figure></li></ol><h2 id="如下类型有Class对象"><a href="#如下类型有Class对象" class="headerlink" title="如下类型有Class对象"></a>如下类型有Class对象</h2><ol><li><p>外部类，成员内部类，静态内部类，局部内部类，匿名内部类</p></li><li><p>interface：接口</p></li><li><p>数组</p></li><li><p>enum：枚举</p></li><li><p>annotation：注解</p></li><li><p>基本数据类型</p></li><li><p>void</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class AllTypeClass &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;String&gt; cls1 = String.class;//外部类</span><br><span class="line">        Class&lt;Serializable&gt; cls2 = Serializable.class;//接口</span><br><span class="line">        Class&lt;Integer[]&gt; cls3 = Integer[].class;//数组</span><br><span class="line">        Class&lt;float[][]&gt; cls4 = float[][].class;//二维数组</span><br><span class="line">        Class&lt;Deprecated&gt; cls5 = Deprecated.class;//注解</span><br><span class="line">        //枚举</span><br><span class="line">        Class&lt;Thread.State&gt; cls6 = Thread.State.class;</span><br><span class="line">        Class&lt;Long&gt; cls7 = long.class;//基本数据类型</span><br><span class="line">        Class&lt;Void&gt; cls8 = void.class;//void数据类型</span><br><span class="line">        Class&lt;Class&gt; cls9 = Class.class;//</span><br><span class="line"></span><br><span class="line">        System.out.println(cls1);</span><br><span class="line">        System.out.println(cls2);</span><br><span class="line">        System.out.println(cls3);</span><br><span class="line">        System.out.println(cls4);</span><br><span class="line">        System.out.println(cls5);</span><br><span class="line">        System.out.println(cls6);</span><br><span class="line">        System.out.println(cls7);</span><br><span class="line">        System.out.println(cls8);</span><br><span class="line">        System.out.println(cls9);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><p>反射机制是java实现动态语言的关键，也就是通过反射实现类动态加载。</p><p>静态加载：编译时加载相关的类，如果没有则报错，依赖性太强</p><blockquote><p>现代编译器帮你排除静态加载的问题了，找不到连编译都不让你干</p></blockquote><p>动态加载：运行时加载需要的类，如果运行时不用该类，则不报错，降低了依赖性</p><p>类加载时机：</p><ol><li>当创建对象时(new)</li><li>当子类被加载时，自动加载父类</li><li>调用类中的静态成员时</li><li>通过反射（只有这个是动态加载，上面3个都是静态的）</li></ol><h2 id="类加载流程"><a href="#类加载流程" class="headerlink" title="类加载流程"></a>类加载流程</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202311011044511.png"></p><ul><li><p>加载</p><p>JVM在该阶段的主要目的是将字节码从不同的数据源(可能是class文件、也可能是jar包，甚至网络)转化为进制字节流加载到内存中，并生成一个代表该类的java.lang.Class对象</p><p>此过程由类加载器完成</p></li><li><p>连接</p><ol><li><p>验证</p><p>目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><p>包括：文件格式验证(是否以魔数oxcafebabe开头)、元数据验证、字节码验证和符号引用验证</p></li><li><p>准备</p><p>JVM会在该阶段对静态变量，分配内存并默认初始化（对应数据类型的默认初始值，如0、0L、null、 false等）这些变量所使用的内存都将在方法区中进行分配</p><blockquote><p>注意，静态常量这一步直接到位，因为常量赋值后不变</p></blockquote></li><li><p>解析</p><p>虚拟机将常量池内的符号引用替换为直接引用的过程。</p></li></ol></li><li><p>初始化</p><p>JVM负责对类进行初始化，这里主要是指静态成员<br>到初始化阶段，才真正开始执行类中定义的Java程序代码，此段是执行&lt; clinit&gt; 方法的过程。</p><blockquote><p>&lt;  clinit&gt; 方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中的所有静态变量的赋值动作和静态代码块中的语句，并进行合并，绝对按顺序执行赋值<br>虚拟机会保证一个类的&lt; clinit&gt; 方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类， 那么只会有一个线程去执行这个类的&lt; clinit&gt; 方法，其他线程都需要阻塞等待，直到活动线程执行<clinit> 0方法完毕</p></blockquote></li></ul><h2 id="获取类结构信息"><a href="#获取类结构信息" class="headerlink" title="获取类结构信息"></a>获取类结构信息</h2><ol><li><p>得到Class对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; personCls = Class.forName(&quot;com.hspedu.reflection.Person&quot;);</span><br></pre></td></tr></table></figure></li><li><p>获取全类名 getName</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(personCls.getName());</span><br></pre></td></tr></table></figure></li><li><p>获取简单类名 getSimpleName</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(personCls.getSimpleName());</span><br></pre></td></tr></table></figure></li><li><p>获取所有public修饰的属性，包含本类以及父类的 getFields</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Field[] fields = personCls.getFields();</span><br><span class="line">for (Field field ： fields) &#123;//增强for</span><br><span class="line">    System.out.println(&quot;本类以及父类的属性=&quot; + field.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取本类中所有属性（包括私有的）getDeclaredFields</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Field[] declaredFields = personCls.getDeclaredFields();</span><br><span class="line">for (Field declaredField ： declaredFields) &#123;</span><br><span class="line">    System.out.println(&quot;本类中所有属性=&quot; + declaredField.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取所有public修饰的方法，包含本类以及父类的 getMethods</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Method[] methods = personCls.getMethods();</span><br><span class="line">for (Method method ： methods) &#123;</span><br><span class="line">    System.out.println(&quot;本类以及父类的方法=&quot; + method.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取本类中所有方法 getDeclaredMethods</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Method[] declaredMethods = personCls.getDeclaredMethods();</span><br><span class="line">for (Method declaredMethod ： declaredMethods) &#123;</span><br><span class="line">    System.out.println(&quot;本类中所有方法=&quot; + declaredMethod.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取所有public修饰的构造器 getConstructors</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;?&gt;[] constructors = personCls.getConstructors();</span><br><span class="line">for (Constructor&lt;?&gt; constructor ： constructors) &#123;</span><br><span class="line">    System.out.println(&quot;本类的构造器=&quot; + constructor.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取本类中所有构造器 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;?&gt;[] declaredConstructors = personCls.getDeclaredConstructors();</span><br><span class="line">for (Constructor&lt;?&gt; declaredConstructor ： declaredConstructors) &#123;</span><br><span class="line">    System.out.println(&quot;本类中所有构造器=&quot; + declaredConstructor.getName());//这里只输出名为例</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>以Package形式返回包信息 getPackage</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(personCls.getPackage());</span><br></pre></td></tr></table></figure></li><li><p>以Class形式返回父类信息 getSuperClass</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; superclass = personCls.getSuperclass();</span><br><span class="line">System.out.println(&quot;父类的class对象=&quot; + superclass);</span><br></pre></td></tr></table></figure></li><li><p>以Class[]形式返回接口信息 getInterfaces</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt;[] interfaces = personCls.getInterfaces();</span><br><span class="line">for (Class&lt;?&gt; anInterface ： interfaces) &#123;</span><br><span class="line">    System.out.println(&quot;接口信息=&quot; + anInterface);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>以Annotation[] 形式返回注解信息 getAnnotations</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Annotation[] annotations = personCls.getAnnotations();</span><br><span class="line">for (Annotation annotation ： annotations) &#123;</span><br><span class="line">    System.out.println(&quot;注解信息=&quot; + annotation);//注解</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="java-lang-reflect-Field类"><a href="#java-lang-reflect-Field类" class="headerlink" title="java.lang.reflect.Field类"></a>java.lang.reflect.Field类</h3><ol><li><p>getModifiers：以int形式返回修饰符</p><p>默认修饰符是0 , public 是1 , private 是2，protected 是4,static是8 , final是16</p></li><li><p>getType：以Class形式返回类型</p></li><li><p>getName：返回属性名</p></li></ol><h1 id="爆破"><a href="#爆破" class="headerlink" title="爆破"></a>爆破</h1><p>通过反射创建对象方法</p><ul><li>方式一：调用类中的public修饰的无参构造器</li><li>方式二：调用类中的指定构造器</li></ul><p>Class类相关方法</p><ul><li>newInstance ：调用类中的无参构造器，获取对应类的对象（就是上面方法1）</li><li>getConstructor(as..clazz)：根据参数列表，获取对应的构造器对象（就是上面方法2）</li><li>getDecalaredConstructor(as..clazz)：根据参数列表，获取对应的构造器对象（就是上面方法2）</li></ul><p>Constructor类相关方法</p><ul><li>setAccessible：暴破</li><li>newlnstance(Objetc…obj)：调用构造器</li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>先获取到User类的Class对象</p><div class="tabs" id="test3"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test3-1">无参构造器</button></li><li class="tab"><button type="button" data-href="#test3-2">public有参构造器</button></li><li class="tab"><button type="button" data-href="#test3-3">private有参构造器</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test3-1"><p>通过public的无参构造器创建实例</p><p>Object o &#x3D; userClass.newInstance();</p><p>注意这个 o 后面用得到</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-2"><ol><li><p>先得到对应构造器</p><p>Constructor&lt;?&gt; constructor &#x3D; userClass.getConstructor(String.class);</p></li><li><p>创建实例，并传入实参</p><p>Object hsp &#x3D; constructor.newInstance(“hsp”);</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-3"><ol><li><p>得到private的构造器对象</p><p>Constructor&lt;?&gt; constructor1 &#x3D; userClass.getDeclaredConstructor(int.class, String.class);</p><p>因为是 private 的，所以要用 getDeclaredConstructor 方法</p></li><li><p>创建实例</p><p>这里用 3 中方法一定会报错，因为构造器是私有的，但是可以通过爆破强行使用</p><p> constructor1.setAccessible(true); &#x2F;&#x2F;这一句表示使用爆破<br> Object user2 &#x3D; constructor1.newInstance(100, “张三丰”); &#x2F;&#x2F;然后就能用了</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class ReflecCreateInstance &#123;</span><br><span class="line">    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line"></span><br><span class="line">        //1. 先获取到User类的Class对象</span><br><span class="line">        Class&lt;?&gt; userClass = Class.forName(&quot;com.hspedu.reflection.User&quot;);</span><br><span class="line">        //2. 通过public的无参构造器创建实例</span><br><span class="line">        Object o = userClass.newInstance();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">        //3. 通过public的有参构造器创建实例</span><br><span class="line">        /*</span><br><span class="line">            constructor 对象就是</span><br><span class="line">            public User(String name) &#123;//public的有参构造器</span><br><span class="line">                this.name = name;</span><br><span class="line">            &#125;</span><br><span class="line">         */</span><br><span class="line">         //3.1 先得到对应构造器</span><br><span class="line">         Constructor&lt;?&gt; constructor = userClass.getConstructor(String.class);</span><br><span class="line">         //3.2 创建实例，并传入实参</span><br><span class="line">         Object hsp = constructor.newInstance(&quot;hsp&quot;);</span><br><span class="line">         System.out.println(&quot;hsp=&quot; + hsp);</span><br><span class="line">        //4. 通过非public的有参构造器创建实例</span><br><span class="line">        //4.1 得到private的构造器对象</span><br><span class="line">        Constructor&lt;?&gt; constructor1 = userClass.getDeclaredConstructor(int.class, String.class);</span><br><span class="line">        //4.2 创建实例</span><br><span class="line">        //暴破，使用反射可以访问private构造器/方法/属性, 反射面前，都是纸老虎</span><br><span class="line">        constructor1.setAccessible(true);</span><br><span class="line">        Object user2 = constructor1.newInstance(100, &quot;张三丰&quot;);</span><br><span class="line">        System.out.println(&quot;user2=&quot; + user2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class User &#123; //User类</span><br><span class="line">    private int age = 10;</span><br><span class="line">    private String name = &quot;韩顺平教育&quot;;</span><br><span class="line"></span><br><span class="line">    public User() &#123;//无参 public</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public User(String name) &#123;//public的有参构造器</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private User(int age, String name) &#123;//private 有参构造器</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User [age=&quot; + age + &quot;, name=&quot; + name + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h2><ol><li><p>根据属性名获取Field对象<br>Field f &#x3D; clazz对象.getDeclaredField(属性名);</p><p>注意 f 是个 Field对象</p></li><li><p>暴破: f.setAccessible(true);   </p><p>f是上面那个对象</p><p>o 是更上面的那个 newInstance 的对象</p></li><li><p>访问<br>f.set(o,值);<br>syso(f.get(o));</p></li><li><p>如果是静态属性，则set和get中的参数o, 可以写成null</p><p>这里的 o 就是上面的对象，因为静态属性是类的，不需要对象</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//1. 得到Student类对应的 Class对象</span><br><span class="line">Class&lt;?&gt; stuClass = Class.forName(&quot;com.hspedu.reflection.Student&quot;);</span><br><span class="line"></span><br><span class="line">//2. 创建对象</span><br><span class="line">Object o = stuClass.newInstance();//o 的运行类型就是Student</span><br><span class="line">System.out.println(o.getClass());//Student</span><br><span class="line"></span><br><span class="line">//3. 使用反射得到age 属性对象</span><br><span class="line">Field age = stuClass.getField(&quot;age&quot;);</span><br><span class="line">age.set(o, 88);//通过反射来操作属性</span><br><span class="line">System.out.println(o);//</span><br><span class="line">System.out.println(age.get(o));//返回age属性的值</span><br><span class="line"></span><br><span class="line">//4. 使用反射操作name 属性</span><br><span class="line">Field name = stuClass.getDeclaredField(&quot;name&quot;);</span><br><span class="line">name.setAccessible(true);//对name 进行暴破, 可以操作private 属性</span><br><span class="line">name.set(null, &quot;老韩~&quot;);//因为name是static属性，因此 o 也可以写出null</span><br><span class="line">System.out.println(o);</span><br><span class="line">System.out.println(name.get(o)); //获取属性值</span><br><span class="line">System.out.println(name.get(null));//获取属性值, 要求name是static</span><br></pre></td></tr></table></figure><h2 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h2><ol><li>根据方法名和参数列表获取Method方法对象: Method m &#x3D;clazz.getDeclaredMethod(方法名，XX.class);</li><li>获取对象: Object o&#x3D;clazz.newlnstance();</li><li>暴破: m.setAccessible(true);</li><li>访问: Object returnValue &#x3D; m.invoke(o,实参列表);<br>如果是静态方法，则invoke的参数o,可以写成null!</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-泛型</title>
      <link href="/2023/06/27/Java14%E6%B3%9B%E5%9E%8B/"/>
      <url>/2023/06/27/Java14%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="泛型引入"><a href="#泛型引入" class="headerlink" title="泛型引入"></a>泛型引入</h2><p>泛型（generic）：又称 参数化类型。是JDK 5 出现的新特性。解决数据类型的安全性问题。在类声明或实例化时只要制定好需要的具体类型即可。</p><p>例1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Properties&lt;Person&gt; prop = <span class="keyword">new</span> <span class="title class_">Properties</span>&lt;Person&gt;();</span><br></pre></td></tr></table></figure><ul><li>上例表示存放到 <code>prop</code> 中的必须是 <code>Person</code> 类型。如果编译器发现添加类型不符合要求，即报错。</li><li>遍历时，直接取出 <code>Person</code> 而非 <code>Object</code></li></ul><p>例2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.base;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">chapter15</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        arrayList.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;旺财&quot;</span>, <span class="number">10</span>));</span><br><span class="line">        arrayList.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;发财&quot;</span>, <span class="number">1</span>));</span><br><span class="line">        arrayList.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;小黄&quot;</span>, <span class="number">5</span>));</span><br><span class="line"><span class="comment">//假如我们的程序员，不小心，添加了一只猫</span></span><br><span class="line">        arrayList.add(<span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;招财猫&quot;</span>, <span class="number">8</span>));</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Object o : arrayList) &#123;</span><br><span class="line"><span class="comment">//向下转型 Object -&gt;Dog</span></span><br><span class="line">            <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) o;</span><br><span class="line">            System.out.println(dog.getName() + <span class="string">&quot;-&quot;</span> + dog.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> &#123; <span class="comment">//Cat 类</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309160944609.png"></p><p>使用传统方法的问题分析</p><ol><li>不能对加入到集合ArrayList中的数据类型进行约束(猫猫狗狗都能加，不加以约束，但是用的时候就有要求了，不安全)</li><li>遍历的时候，需要进行类型转换，如果集合中的数据量较大，对效率有影响（虽然放的就是dog类对象但是就是要用object接受，语法不支持）</li></ol><p>使用泛型好处</p><ol><li>编译时，检查添加元素的类型。可以保证如果编译时没发出警告，运行就不会产生ClassCastException 异常。提高了安全性，使代码更加简洁、健壮。</li><li>也减少了转换的次数，遍历的时候直接取出对象，不用向下转型，提高了效率。</li><li>泛型的作用是：可以在类声明是通过一个标识表示类中某个属性的类型，或某个方法返回值的类型，或参数类型。</li></ol><p>例3：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Javabase.chapter;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">improve</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//使用传统的方法来解决===&gt; 使用泛型</span></span><br><span class="line"><span class="comment">//老韩解读</span></span><br><span class="line"><span class="comment">//1. 当我们 ArrayList&lt;Dog&gt; 表示存放到 ArrayList 集合中的元素是 Dog 类型 (细节后面说...)</span></span><br><span class="line"><span class="comment">//2. 如果编译器发现添加的类型，不满足要求，就会报错</span></span><br><span class="line"><span class="comment">//3. 在遍历的时候，可以直接取出 Dog 类型而不是 Object</span></span><br><span class="line"><span class="comment">//4. public class ArrayList&lt;E&gt; &#123;&#125; E 称为泛型,那么 Dog-&gt;E</span></span><br><span class="line">        ArrayList&lt;Dog&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Dog&gt;();</span><br><span class="line">        arrayList.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;旺财&quot;</span>, <span class="number">10</span>));</span><br><span class="line">        arrayList.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;发财&quot;</span>, <span class="number">1</span>));</span><br><span class="line">        arrayList.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;小黄&quot;</span>, <span class="number">5</span>));</span><br><span class="line"><span class="comment">//假如我们的程序员，不小心，添加了一只猫</span></span><br><span class="line">        <span class="comment">//arrayList.add(new Cat(&quot;招财猫&quot;, 8));</span></span><br><span class="line">        System.out.println(<span class="string">&quot;===使用泛型====&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Dog dog : arrayList) &#123;</span><br><span class="line">            System.out.println(dog.getName() + <span class="string">&quot;-&quot;</span> + dog.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> &#123; <span class="comment">//Cat 类</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>类型不对，直接报错</p></blockquote><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309160947413.png"></p><h2 id="泛型介绍"><a href="#泛型介绍" class="headerlink" title="泛型介绍"></a>泛型介绍</h2><p>泛型(广泛类型) </p><ol><li>泛型又称参数化类型，是Jdk5.0 出现的新特性，解决数据类型的安全性问题</li><li>泛型只能应用于 <strong>引用类型</strong>，int等基本类型要换为Integer等<strong>包装类</strong>（ Integer, String,Dog）</li><li>在类声明或实例化时只要指定好需要的具体的类型即可。</li><li>Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。 同时，代码更加简洁、健壮</li></ol><p><strong>泛型的作用</strong>：可以在类声明时通过一个标识表示类中某个属性的类型，或者是某个方法的返回值的类型，或者是参数类型。 </p><blockquote><p>泛型可以理解为表示数据类型的数据类型。&lt;&gt;中是什么类型，运行就是什么类型</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class P&lt;E&gt; &#123;            //实例化时指定 E 的类型，编译时上例所有 E 会被编译器替换为那个指定类型</span><br><span class="line">E e;//E 表示 e 的数据类型，在定义P类对象时指定。即在编译期间确认类型</span><br><span class="line">public P(E e)&#123;//可作为参数类型</span><br><span class="line">this.e = e;</span><br><span class="line">&#125;</span><br><span class="line">public E f()&#123;    //可作为返回类型</span><br><span class="line">return this.e;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//例</span><br><span class="line">Person&lt;String&gt; person = new Person&lt;String&gt;(&quot;String&quot;);//String</span><br><span class="line">/*</span><br><span class="line">    你可以这样理解，上面的Person类</span><br><span class="line">    class Person &#123;</span><br><span class="line">        String s ;//E表示 s的数据类型, 该数据类型在定义Person对象的时候指定,即在编译期间，就确定E是什么类型</span><br><span class="line">        public Person(String s) &#123;//E也可以是参数类型</span><br><span class="line">            this.s = s;</span><br><span class="line">        &#125;</span><br><span class="line">        public String f() &#123;//返回类型使用E</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">Person&lt;Integer&gt; person2 = new Person&lt;Integer&gt;(100);//Integer</span><br><span class="line">/*</span><br><span class="line">    class Person &#123;</span><br><span class="line">        Integer s ;//E表示 s的数据类型, 该数据类型在定义Person对象的时候指定,即在编译期间，就确定E是什么类型</span><br><span class="line"></span><br><span class="line">        public Person(Integer s) &#123;//E也可以是参数类型</span><br><span class="line">            this.s = s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Integer f() &#123;//返回类型使用E</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309161012445.png"></p><h2 id="泛型语法"><a href="#泛型语法" class="headerlink" title="泛型语法"></a>泛型语法</h2><h3 id="泛型的声明"><a href="#泛型的声明" class="headerlink" title="泛型的声明"></a>泛型的声明</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">interface 接口 &lt;T&gt;&#123;&#125;</span><br><span class="line">class 类 &lt;K,V&gt;&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>KTV不代表值，而是表示类型。任意字母都可以。常用T表示，是Type的缩写</p></blockquote><h3 id="实例化泛型"><a href="#实例化泛型" class="headerlink" title="实例化泛型"></a>实例化泛型</h3><p>类名后面指定类型参数的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strList = new ArrayList&lt;String&gt;();</span><br><span class="line">Iterator&lt;Integer&gt; iterator = vector.interator&lt;Integer&gt;();</span><br></pre></td></tr></table></figure><p><strong>注意细节：</strong></p><ol><li><p>泛型只能是引用类型，基本类型要用他们的包装类</p></li><li><p>指定泛型具体类型后，可以传入该类型或其子类类型（向上转型和向下转型）</p></li><li><p>在实际开发中往往简写泛型，前面写了，后面可以不用写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strList = new ArrayList&lt;&gt;();//前面写了，后面可以不用写</span><br></pre></td></tr></table></figure></li><li><p>实例化不写泛型的场合，相当于默认泛型为 Object（所有类型的总父类），好像没用泛型，但还是用了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list = new ArrayList();</span><br><span class="line">//等价于</span><br><span class="line">ArrayList&lt;&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">//等价于</span><br><span class="line">ArrayList&lt;Object&gt; list = new ArrayList&lt;Object&gt;();</span><br></pre></td></tr></table></figure><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309161053877.png"></p></li></ol><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>例题1</p><ol><li>创建3个学生对象</li><li>放入到HashSet中学生对象</li></ol><p>源码中，集合列表中都有使用泛型，所以在外面定义泛型的时候，就已经定义好了所有相同泛型字母所代表的内容了，所以使用集合的时候自动匹配相应的类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">//学生类</span><br><span class="line">class student&#123;</span><br><span class="line">    public String name;</span><br><span class="line">    public int age;</span><br><span class="line"></span><br><span class="line">    public student(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;student&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class GenericExercise &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //使用泛型方式给HashSet 放入3个学生对象</span><br><span class="line">        HashSet&lt;Student&gt; students = new HashSet&lt;Student&gt;();</span><br><span class="line">        students.add(new Student(&quot;jack&quot;, 18));</span><br><span class="line">        students.add(new Student(&quot;tom&quot;, 28));</span><br><span class="line">        students.add(new Student(&quot;mary&quot;, 19));</span><br><span class="line"></span><br><span class="line">        //遍历</span><br><span class="line">        for (Student student : students) &#123;</span><br><span class="line">            System.out.println(student);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //使用泛型方式给HashMap 放入3个学生对象</span><br><span class="line">        //K -&gt; String V-&gt;Student</span><br><span class="line">        HashMap&lt;String, Student&gt; hm = new HashMap&lt;String, Student&gt;();</span><br><span class="line">        /*</span><br><span class="line">            public class HashMap&lt;K,V&gt;  &#123;&#125;</span><br><span class="line">         */</span><br><span class="line">        hm.put(&quot;milan&quot;, new Student(&quot;milan&quot;, 38));</span><br><span class="line">        hm.put(&quot;smith&quot;, new Student(&quot;smith&quot;, 48));</span><br><span class="line">        hm.put(&quot;hsp&quot;, new Student(&quot;hsp&quot;, 28));</span><br><span class="line">        </span><br><span class="line">        /*源码</span><br><span class="line">        public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">            Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">            return (es = entrySet) == null ? (entrySet = new EntrySet()) : es;</span><br><span class="line">        &#125;</span><br><span class="line">         */</span><br><span class="line">        Set&lt;Map.Entry&lt;String, Student&gt;&gt; entries = hm.entrySet();</span><br><span class="line">        /*源码</span><br><span class="line">            public final Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">                return new EntryIterator();</span><br><span class="line">            &#125;</span><br><span class="line">         */</span><br><span class="line">        Iterator&lt;Map.Entry&lt;String, Student&gt;&gt; iterator = entries.iterator();</span><br><span class="line">        System.out.println(&quot;==============================&quot;);</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;String, Student&gt; next =  iterator.next();</span><br><span class="line">            System.out.println(next.getKey() + &quot;-&quot; + next.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例题2</p><ul><li>定义Employee类<ol><li>该类包含: private成员变量name，sal，birthday，其中birthday为MyDate类的对象;</li><li>为每一个属性定义getter，setter方法;</li><li>重写 toString 方法输出name，sal，birthday</li><li>MyDate类包含: private成员变量month，day，year；并为每一 个属性定义getter，setter方法</li><li>创建该类的3个对象，并把这些对象放入ArrayList集合中（ArrayList 需使用泛型来定义）对集合中的元素进行排序，井遍历输出:</li></ol></li><li>排序方式：调用ArrayList 的sort方法，传入Comparator对象[使用泛型]，先按照name排序，如果name相同，则按生日日期的先后排序。</li></ul><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">Employee</button></li><li class="tab"><button type="button" data-href="#test1-2">MyDate</button></li><li class="tab"><button type="button" data-href="#test1-3">GenericExercise02</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Employee &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private double sal;</span><br><span class="line">    private MyDate birthday;</span><br><span class="line">    public Employee(String name, double sal, MyDate birthday) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.sal = sal;</span><br><span class="line">        this.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public double getSal() &#123;</span><br><span class="line">        return sal;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setSal(double sal) &#123;</span><br><span class="line">        this.sal = sal;</span><br><span class="line">    &#125;</span><br><span class="line">    public MyDate getBirthday() &#123;</span><br><span class="line">        return birthday;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setBirthday(MyDate birthday) &#123;</span><br><span class="line">        this.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;\nEmployee&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, sal=&quot; + sal +</span><br><span class="line">                &quot;, birthday=&quot; + birthday +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public class MyDate implements Comparable&lt;MyDate&gt;&#123;</span><br><span class="line">    private int year;</span><br><span class="line">    private int month;</span><br><span class="line">    private int day;</span><br><span class="line">    public MyDate(int year, int month, int day) &#123;</span><br><span class="line">        this.year = year;</span><br><span class="line">        this.month = month;</span><br><span class="line">        this.day = day;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getYear() &#123;</span><br><span class="line">        return year;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setYear(int year) &#123;</span><br><span class="line">        this.year = year;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getMonth() &#123;</span><br><span class="line">        return month;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setMonth(int month) &#123;</span><br><span class="line">        this.month = month;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getDay() &#123;</span><br><span class="line">        return day;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setDay(int day) &#123;</span><br><span class="line">        this.day = day;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;MyDate&#123;&quot; +</span><br><span class="line">                &quot;year=&quot; + year +</span><br><span class="line">                &quot;, month=&quot; + month +</span><br><span class="line">                &quot;, day=&quot; + day +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    //把对year-month-day比较放在这里</span><br><span class="line">    public int compareTo(MyDate o) &#123; </span><br><span class="line">        int yearMinus = year - o.getYear();</span><br><span class="line">        if(yearMinus != 0) &#123;</span><br><span class="line">            return  yearMinus;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //如果year相同，就比较month</span><br><span class="line">        int monthMinus = month - o.getMonth();</span><br><span class="line">        if(monthMinus != 0) &#123;</span><br><span class="line">            return monthMinus;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //如果year 和 month</span><br><span class="line">        return day - o.getDay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class GenericExercise02 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;Employee&gt; employees = new ArrayList&lt;&gt;();</span><br><span class="line">        employees.add(new Employee(&quot;tom&quot;, 20000, new MyDate(1980,12,11)));</span><br><span class="line">        employees.add(new Employee(&quot;jack&quot;, 12000, new MyDate(2001,12,12)));</span><br><span class="line">        employees.add(new Employee(&quot;tom&quot;, 50000, new MyDate(1980,12,10)));</span><br><span class="line">        System.out.println(&quot;employees=&quot; + employees);</span><br><span class="line">        employees.sort(new Comparator&lt;Employee&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Employee emp1, Employee emp2) &#123;</span><br><span class="line">            </span><br><span class="line">                //先按照name排序，如果name相同，则按生日日期的先后排序</span><br><span class="line">                //先对传入的参数进行验证</span><br><span class="line">                if(!(emp1 instanceof  Employee &amp;&amp; emp2 instanceof Employee)) &#123;</span><br><span class="line">                    System.out.println(&quot;类型不正确..&quot;);</span><br><span class="line">                    return 0;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                //比较name</span><br><span class="line">                int i = emp1.getName().compareTo(emp2.getName());</span><br><span class="line">                if(i != 0) &#123;</span><br><span class="line">                    return i;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                //下面是对birthday的比较，因此，我们最好把这个比较，放在MyDate类完成</span><br><span class="line">                //封装后，将来可维护性和复用性，就大大增强.</span><br><span class="line">                return emp1.getBirthday().compareTo(emp2.getBirthday());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(&quot;==对雇员进行排序==&quot;);</span><br><span class="line">        System.out.println(employees);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="自定义泛型"><a href="#自定义泛型" class="headerlink" title="自定义泛型"></a>自定义泛型</h1><p>官方提供方泛型可以理解为自定义泛型的一种特殊实现</p><h2 id="自定义泛型类"><a href="#自定义泛型类" class="headerlink" title="自定义泛型类"></a>自定义泛型类</h2><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class 类名 &lt;T,R...&gt; &#123; 成员 &#125;  //T、R是泛型标识符，可有多个，一般是单个大写字母表示</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li><p>普通成员可以使用泛型（属性、方法可以使用定义里面的泛型）</p></li><li><p>… 表示可以有多个</p></li><li><p>泛型类的类型，是在创建对象时确定的，创建对象时需要指明类型。</p><p>静态方法中不能使用类的泛型；因为静态是和类相关的，在类加载时，对象还没有创建，所以，如果静态方法和静态属性使用了泛型，JVM 就无法完成初始化</p></li><li><p>使用泛型的数组，也不能初始化，因为数组在 new 不能确定 T 的类型，就无法在内存开空间。</p></li><li><p>创建对象时不指定的场合，默认 Object。建议还是写上 <code>&lt;Object&gt;</code></p></li></ol><p>例子：</p><div class="tabs" id="test2"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test2-1">定义类</button></li><li class="tab"><button type="button" data-href="#test2-2">实例化对象</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test2-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">class Tiger&lt;T, R, M&gt; &#123;</span><br><span class="line">    String name;</span><br><span class="line">    R r; //属性使用到泛型</span><br><span class="line">    M m; //属性使用到泛型</span><br><span class="line">    T t; //属性使用到泛型</span><br><span class="line">    //因为数组在 new 不能确定 T 的类型，就无法在内存开空间，可以声明</span><br><span class="line">    T[] ts;</span><br><span class="line">    public Tiger(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public Tiger(R r, M m, T t) &#123;//构造器使用泛型</span><br><span class="line">        this.r = r;</span><br><span class="line">        this.m = m;</span><br><span class="line">        this.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">    public Tiger(String name, R r, M m, T t) &#123;//构造器使用泛型</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.r = r;</span><br><span class="line">        this.m = m;</span><br><span class="line">        this.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">    //</span><br><span class="line">// &#125;</span><br><span class="line">//方法使用泛型</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public R getR() &#123;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setR(R r) &#123;//方法使用到泛型</span><br><span class="line">        this.r = r;</span><br><span class="line">    &#125;</span><br><span class="line">    public M getM() &#123;//返回类型可以使用泛型.</span><br><span class="line">        return m;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setM(M m) &#123;</span><br><span class="line">        this.m = m;</span><br><span class="line">    &#125;</span><br><span class="line">    public T getT() &#123;</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setT(T t) &#123;</span><br><span class="line">        this.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Tiger&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, r=&quot; + r +</span><br><span class="line">                &quot;, m=&quot; + m +</span><br><span class="line">                &quot;, t=&quot; + t +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//T=Double, R=String, M=Integer</span><br><span class="line">Tiger&lt;Double,String,Integer&gt; g1 = new Tiger&lt;&gt;(&quot;john&quot;);</span><br><span class="line">g1.setT(10.9); //OK</span><br><span class="line">g1.setT(&quot;yy&quot;); //错误，类型不对</span><br><span class="line">System.out.println(g);</span><br><span class="line"></span><br><span class="line">Tiger g2 = new Tiger(&quot;john~~&quot;);//OK T=Object R=Object M=Object</span><br><span class="line">g2.setT(&quot;yy&quot;); //OK ,因为 T=Object &quot;yy&quot;=String 是Object子类</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;g2=&quot; + g2);</span><br></pre></td></tr></table></figure><p>实例化对象时，T&#x3D;Double, R&#x3D;String, M&#x3D;Integer，这样 g.setT &#x3D; g.setDouble。例如对象 g1</p><p>如果不指明T R M 的类型，默认都是Object。例如对象 g2</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><ol><li>Tiger后面使用到泛型，所以我们把Tiger就称为自定义泛型类</li><li>T,R, M泛型的标识符，一般是单个大写字母</li><li>声明时这些大写字母只是占位符，实例化的时候才真正定义类型，并且是所有的相同大写字母</li><li>泛型标识符可以有多个</li><li>普通成员可以使用泛型(属性、 方法)</li><li>可以声明数组，但是数组在 new 不能确定 T 的类型，就无法在内存开空间</li><li>静态方法中不能使用类的泛型；因为静态是和类相关的，在类加载时，对象还没有创建，所以，如果静态方法和静态属性使用了泛型，JVM 就无法完成初始化</li></ol><h2 id="自定义泛型接口"><a href="#自定义泛型接口" class="headerlink" title="自定义泛型接口"></a>自定义泛型接口</h2><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">interface 接口名 &lt;T,R...&gt;&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意细节：</p><ol><li>接口中，静态成员也不能使用泛型(这个和泛型类规定一样)</li><li>泛型接口的类型，在<strong>继承接口</strong>或者<strong>实现接口</strong>时确定</li><li>没有指定类型，默认为Object</li></ol><p>案例</p><div class="tabs" id="test3"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test3-1">泛型接口</button></li><li class="tab"><button type="button" data-href="#test3-2">继承接口</button></li><li class="tab"><button type="button" data-href="#test3-3">实现接口</button></li><li class="tab"><button type="button" data-href="#test3-4">没有指定</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test3-1"><p>目前该泛型接口使用占位符还没实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface IUsb&lt;U, R&gt; &#123;</span><br><span class="line"></span><br><span class="line">    int n = 10;</span><br><span class="line"></span><br><span class="line">    //普通方法中，可以使用接口泛型</span><br><span class="line">    R get(U u);</span><br><span class="line"></span><br><span class="line">    void hi(R r);</span><br><span class="line"></span><br><span class="line">    void run(R r1, R r2, U u1, U u2);</span><br><span class="line"></span><br><span class="line">    //在jdk8 中，可以在接口中，使用默认方法, 也是可以使用泛型</span><br><span class="line">    default R method(U u) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-2"><p>AA 继承 IA</p><p>IA 是用具体类型实现了 IUsb 这个泛型接口，指定了U 为String，R为Double</p><p>可以看见 IA 里面实现的方法都自动用<strong>具体类</strong>替换了原有的<strong>大写字母</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//在继承接口 指定泛型接口的类型</span><br><span class="line">interface IA extends IUsb&lt;String, Double&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//当我们去实现IA接口时，因为IA在继承IUsu 接口时，指定了U 为String R为Double</span><br><span class="line">//在实现IUsu接口的方法时，使用String替换U, 是Double替换R</span><br><span class="line">class AA implements IA &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Double get(String s) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void hi(Double aDouble) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run(Double r1, Double r2, String u1, String u2) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-3"><p>实现接口时，直接指定泛型接口的类型，给U 指定Integer 给 R 指定了 Float</p><p>所以，当我们实现IUsb方法时，会使用Integer替换U, 使用Float替换R</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//实现接口时，直接指定泛型接口的类型</span><br><span class="line">//给U 指定Integer 给 R 指定了 Float</span><br><span class="line">//所以，当我们实现IUsb方法时，会使用Integer替换U, 使用Float替换R</span><br><span class="line">class BB implements IUsb&lt;Integer, Float&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Float get(Integer integer) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void hi(Float aFloat) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run(Float r1, Float r2, Integer u1, Integer u2) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-4"><p>没有指定类型（啥都不写），语法上是能通过的，默认为Object，可以直接写成 IUsb&lt;Object,Object&gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//没有指定类型，默认为Object</span><br><span class="line">//建议直接写成 IUsb&lt;Object,Object&gt;</span><br><span class="line">class CC implements IUsb &#123; //等价 class CC implements IUsb&lt;Object,Object&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object get(Object o) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void hi(Object o) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run(Object r1, Object r2, Object u1, Object u2) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="自定义泛型方法"><a href="#自定义泛型方法" class="headerlink" title="自定义泛型方法"></a>自定义泛型方法</h2><p>和普通方法的区别就是方法返回类型前面加了泛型修饰符</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;T&gt; 返回值 方法名（参数列表）&#123;&#125;</span><br></pre></td></tr></table></figure><p>细节：</p><ol><li><p>泛型方法，可以定义在普通类中，也可以定义在泛型类里面</p></li><li><p>当泛型方法被调用时，编译器会自动确定类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//&lt;T,R&gt; 就是泛型</span><br><span class="line">//是提供给 fly使用的</span><br><span class="line">public &lt;T, R&gt; void fly(T t, R r) &#123;//泛型方法</span><br><span class="line">    System.out.println(t.getClass());//String</span><br><span class="line">    System.out.println(r.getClass());//Integer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//当调用方法时，传入参数，编译器，就会确定类型</span><br><span class="line">//T = String</span><br><span class="line">//R = Integer(自动装箱)</span><br><span class="line">car.fly(&quot;宝马&quot;, 100);</span><br></pre></td></tr></table></figure></li><li><p>public void eat(E e) {}， 修饰符后没有&lt;TR..&gt; ，该方法不是泛型方法，而是使用了泛型</p></li><li><p>public &lt;TR..&gt; void eat() {}，这个才是泛型方法，泛型方法的<strong>大写字母</strong>建议和泛型类用的大写字母不一样，用来区分</p></li><li><p>泛型方法，可以使用类声明的泛型，也可以使用自己声明泛型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Car1&lt;T,R&gt;&#123;</span><br><span class="line">    public void hi(T t) &#123;//这里没问题，因为T我在类里面就声明了</span><br><span class="line">    &#125;</span><br><span class="line">    //泛型方法，可以使用类声明的泛型，也可以使用自己声明泛型</span><br><span class="line">    public&lt;K&gt; void hello(R r, K k) &#123;</span><br><span class="line">        System.out.println(r.getClass());//ArrayList</span><br><span class="line">        System.out.println(k.getClass());//Float</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Car2&#123;</span><br><span class="line">    public void hi(T t) &#123;//这里会报错，不知道T是什么</span><br><span class="line">    &#125;</span><br><span class="line">    //泛型方法，可以使用类声明的泛型，也可以使用自己声明泛型</span><br><span class="line">    public&lt;K,R&gt; void hello(R r, K k) &#123;//这里没问题，RK在方法里面声明</span><br><span class="line">        System.out.println(r.getClass());//ArrayList</span><br><span class="line">        System.out.println(k.getClass());//Float</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309161756763.png"></p><p>  例题来喽~</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309161800666.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package org.example;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Apple&lt;String, Integer, Double&gt; apple = new Apple&lt;&gt;();</span><br><span class="line">        apple.fly(10);//10 会被自动装箱 Integer10, 输出 Integer</span><br><span class="line">        apple.fly(new Dog());//new出来的，Dog类型</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Apple&lt;T, R, M&gt; &#123;//自定义泛型类</span><br><span class="line">    public &lt;E&gt; void fly(E e) &#123; //泛型方法</span><br><span class="line">        System.out.println(e.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    //public void eat(U u) &#123;&#125;//错误，因为 U 没有声明</span><br><span class="line">    public void run(M m) &#123;</span><br><span class="line">    &#125; //ok</span><br><span class="line">&#125;</span><br><span class="line">class Dog &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="泛型继承和通配符"><a href="#泛型继承和通配符" class="headerlink" title="泛型继承和通配符"></a>泛型继承和通配符</h1><ol><li><p>泛型不具备继承性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; list = new ArrayList &lt;String&gt; ();//这个是错的</span><br></pre></td></tr></table></figure><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309161827820.png"></p></li><li><?> :支持任意泛型类型</li><li><? extends A>:支持A类以及A类的子类，规定了泛型的上限</li><li><? super A>:支持A类以及A类的父类，不限于直接父类，规定了泛型的下限</li><li><p>主要是为了约束，支持传任意的类，但不是所有的类都能传</p></li></ol><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">定义类</button></li><li class="tab"><button type="button" data-href="#test4-2">接受</button></li><li class="tab"><button type="button" data-href="#test4-3">测试</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class AA &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BB extends AA &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CC extends BB &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// ? extends AA 表示 上限，可以接受 AA或者AA子类</span><br><span class="line">public static void printCollection2(List&lt;? extends AA&gt; c) &#123;</span><br><span class="line">    for (Object object : c) &#123;</span><br><span class="line">        System.out.println(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//说明: List&lt;?&gt; 表示 任意的泛型类型都可以接受</span><br><span class="line">public static void printCollection1(List&lt;?&gt; c) &#123;</span><br><span class="line">    for (Object object : c) &#123; // 通配符，取出时，就是Object</span><br><span class="line">        System.out.println(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ? super 子类类名AA:支持AA类以及AA类的父类，不限于直接父类，</span><br><span class="line">//规定了泛型的下限</span><br><span class="line">public static void printCollection3(List&lt;? super AA&gt; c) &#123;</span><br><span class="line">    for (Object object : c) &#123;</span><br><span class="line">        System.out.println(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-3"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Object o = new String(&quot;xx&quot;);</span><br><span class="line"></span><br><span class="line">//泛型没有继承性</span><br><span class="line">//List&lt;Object&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">//举例说明下面三个方法的使用</span><br><span class="line">List&lt;Object&gt; list1 = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; list2 = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;AA&gt; list3 = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;BB&gt; list4 = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;CC&gt; list5 = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">//如果是 List&lt;?&gt; c ，可以接受任意的泛型类型</span><br><span class="line">printCollection1(list1);</span><br><span class="line">printCollection1(list2);</span><br><span class="line">printCollection1(list3);</span><br><span class="line">printCollection1(list4);</span><br><span class="line">printCollection1(list5);</span><br><span class="line"></span><br><span class="line">//List&lt;? extends AA&gt; c： 表示 上限，可以接受 AA或者AA子类</span><br><span class="line">//printCollection2(list1);//×</span><br><span class="line">//printCollection2(list2);//×</span><br><span class="line">printCollection2(list3);//√</span><br><span class="line">printCollection2(list4);//√</span><br><span class="line">printCollection2(list5);//√</span><br><span class="line"></span><br><span class="line">//List&lt;? super AA&gt; c: 支持AA类以及AA类的父类，不限于直接父类</span><br><span class="line">printCollection3(list1);//√</span><br><span class="line">//printCollection3(list2);//×</span><br><span class="line">printCollection3(list3);//√</span><br><span class="line">//printCollection3(list4);//×</span><br><span class="line">//printCollection3(list5);//×</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-枚举和注解</title>
      <link href="/2023/06/25/Java13%E6%9E%9A%E4%B8%BE/"/>
      <url>/2023/06/25/Java13%E6%9E%9A%E4%B8%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>把具体的对象一一列举出来的类，就称为 枚举类（enumeration）。</p><p>枚举是一组常量的集合。可以这里理解：枚举属于一种特殊的类，里面只包含一组有限的特定的对象。</p><p>实现方法：</p><ol><li>自定义枚举</li><li>enum 关键字枚举</li></ol><h2 id="自定义枚举"><a href="#自定义枚举" class="headerlink" title="自定义枚举"></a>自定义枚举</h2><ol><li><p>构造器私有化，防止在外面 new 对象。</p></li><li><p>去掉 set 方法（可保留 get），防止属性被修改。因为枚举对象值通常为只读</p></li><li><p>在类内部直接创建固定对象。使用 <code>final</code> + <code>static</code> 共同修饰，对象名通常全部大写。</p></li><li><p>使用 类名.对象名 使用对象</p></li><li><p>枚举对象按照需要可以有多个属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Enum.e1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Enum&#123;</span><br><span class="line">    public String name;</span><br><span class="line">    public String desc;</span><br><span class="line"></span><br><span class="line">    private Enum(String name, String desc) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getDesc() &#123;</span><br><span class="line">        return desc;</span><br><span class="line">    &#125;</span><br><span class="line">    public static final Enum e1 = new Enum(&quot;华农&quot;,&quot;211&quot;);</span><br><span class="line">    public static final Enum e2 = new Enum(&quot;华中师范&quot;,&quot;211&quot;);</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Enum&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, desc=&#x27;&quot; + desc + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="enum关键字"><a href="#enum关键字" class="headerlink" title="enum关键字"></a>enum关键字</h2><ol><li><p>用关键字 enum 替代 class</p></li><li><p>用 常量名.(形参列表); 代替创建对象（放在前面）。多个对象的场合，用 , 间隔。</p></li><li><p>如果使用 enum 枚举，要求将常量对象写在前面</p></li><li><p>必须要有 属性、构造器、枚举常量。get、set方法都可以去除。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enum School&#123;</span><br><span class="line">    WUHAN(&quot;湖北&quot;,&quot;一线&quot;);</span><br><span class="line">    private String sheng;</span><br><span class="line">    private String grade;</span><br><span class="line">    private School(String sheng, String grade) &#123;</span><br><span class="line">        this.sheng = sheng;</span><br><span class="line">        this.grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h3><ol><li><p>当我们用 <code>enum</code> 关键字开发一个枚举类时，默认会继承 java.lang.Enum 类，而且是一个 <code>final</code> 类。</p><p>这样，我们就能使用 Enum 中的相关方法。</p></li><li><p><code>enum</code> 类不能继承其他类，亦不能被其它类继承，</p></li><li><p><code>enum</code> 类和其他类一样，可以实现接口。</p></li><li><p>传统的 <code>public ststic final RED(&quot;小红&quot;, 10);</code> 简化为 <code>RED(&quot;小红&quot;, 10);</code></p></li><li><p>如果使用无参构造器创建枚举对象，则 实参列表 和 <code>()</code> 都能省略</p></li></ol><h3 id="Enum-类常用方法"><a href="#Enum-类常用方法" class="headerlink" title="Enum 类常用方法"></a><code>Enum</code> 类常用方法</h3><ul><li><code>valueOf</code>：将字符串转换成枚举对象。要求字符串必须是已有的常量名，否则报异常。</li><li><code>values</code>：返回一个数组 <code>Example[]</code>，其中包含定义的所有枚举对象</li><li><code>getDeclaringClass</code>：得到枚举常量所属的 <code>class</code></li><li><code>name</code>：得到当前枚举常量的名称。建议优先用 <code>toString</code></li><li><code>ordinal</code>：输出该枚举对象的次序&#x2F;编号（从 0 开始编号。如上例 <code>BLUE.ordinal = 1</code>）</li><li><code>compareTo</code>：比较两个枚举常量的编号（调用常量编号 减去 传入常量编号）</li><li><code>clone</code>：枚举类不能 <code>clone</code>，所以，这是一个只会抛出异常的方法</li></ul><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>注解（Annotation）也被称为元数据（Metadata）。用于修饰 包、类、方法、属性、构造器、局部变量 等数据信息。</p><p>和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息。</p><p>在 JavaSE 中，注解的使用目的比较简单，例如 标记过时的功能，忽略警告 等。在 JavaEE 中注解占据了更重要的角色，例如用于配置应用程序的任何切面，代替 JavaEE 旧版中所遗留的繁冗代码和 XML 配置等。</p><ol><li>使用 <code>@Annotation</code> 时要在前面增加 <code>@</code> 符号，并把该注解当成一个修饰符使用。用于修饰它支持的程序元素。</li><li>三个基本的@Annotation：<ul><li><code>@Override</code>：限定某个方法，是 重写 父类方法。该注解只能用于方法。如果你写了该注解，编译器会替你校验，看看是不是真的 重写 了父类方法。</li><li><code>@Deprecated</code>：用于表示某个程序元素（类、方法等）已经过时</li><li><code>@SuppressWarnings()</code>：抑制编辑器警告</li></ul></li><li>如果发现 <code>public @interface XXX&#123;&#125;</code> 这种东西，说明是定义了一个注解类 <code>XXX</code>。这里的 <code>@interface</code> 不代表接口（<code>interface</code>）。</li></ol><h2 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h2><p>@Override 表示指定重写父类的方法（从编译器层面验证），如果父类没有该方法，就报错。</p><blockquote><p>不写该注解，重写依然构成重写，所以这个就别碰</p></blockquote><p>@Override 只能修饰方法，不能修饰其他 类、包、属性等</p><h2 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h2><p>@Deprecated 表示指定的某个程序元素（类、方法等）已过时，不推荐使用，但仍能使用，@Deprecated 可以做到新旧版本的兼容和过度</p><p>可以修饰方法、类、字段、包、参数</p><h2 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings()"></a>@SuppressWarnings()</h2><p>当我们不想看到警告信息时，用 <code>@SuppressWarnings()</code></p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&#123;&quot;...&quot;&#125;)</span><br></pre></td></tr></table></figure><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>在后面 <code>(&#123;&quot;unused&quot;, &quot;unchecked&quot;&#125;)</code> 这样写入你希望抑制的信息</p><table><thead><tr><th align="left"><strong>关键字</strong></th><th align="left"><strong>用途</strong></th></tr></thead><tbody><tr><td align="left">all</td><td align="left">抑制所有警告</td></tr><tr><td align="left">boxing</td><td align="left">抑制与装箱&#x2F;解装箱操作相关的警告</td></tr><tr><td align="left">cast</td><td align="left">抑制与强制转换操作相关的警告</td></tr><tr><td align="left">dep-ann</td><td align="left">抑制与已弃用注释相关的警告</td></tr><tr><td align="left">deprecation</td><td align="left">抑制与弃用有关的警告</td></tr><tr><td align="left">fallthrough</td><td align="left">抑制与 switch 语句中丢失断点相关的警告</td></tr><tr><td align="left">finally</td><td align="left">抑制不返回的 finally 块的相关警告</td></tr><tr><td align="left">hiding</td><td align="left">抑制与隐藏变量的局部变量相关的警告</td></tr><tr><td align="left">incomplete-switch</td><td align="left">抑制与 switch 语句中缺少条目相关的警告（enum）</td></tr><tr><td align="left">nls</td><td align="left">抑制与 非nls 字符串字面值相关的警告</td></tr><tr><td align="left">null</td><td align="left">抑制相对于null分析的警告</td></tr><tr><td align="left">rawtypes</td><td align="left">在类参数上使用泛型时，抑制与非特定类型相关的警告</td></tr><tr><td align="left">restriction</td><td align="left">抑制与不推荐或禁止引用有关的警告</td></tr><tr><td align="left">serial</td><td align="left">抑制与可序列化类缺少serialVersionUID字段相关的警告</td></tr><tr><td align="left">static-access</td><td align="left">抑制与不正确的静态访问有关的警告</td></tr><tr><td align="left">synthetic-access</td><td align="left">抑制与未优化的内部类访问相关的警告</td></tr><tr><td align="left">unchecked</td><td align="left">抑制与未检查的操作相关的警告</td></tr><tr><td align="left">unqualified-field-access</td><td align="left">抑制与字段访问不合格相关的警告</td></tr><tr><td align="left">unused</td><td align="left">抑制与未使用代码相关的警告</td></tr></tbody></table><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p><code>@SuppressWarnings</code> 的范围与你放置的位置相关。</p><ul><li>放在方法外第一行，范围是整个方法</li><li>放在方法内，范围是下一句语句</li></ul><h3 id="JDK-的元注解（了解即可）"><a href="#JDK-的元注解（了解即可）" class="headerlink" title="JDK 的元注解（了解即可）"></a>JDK 的元注解（了解即可）</h3><blockquote><p>JDK 的 元注解 是用于修饰其他注解的注解</p></blockquote><ol><li><p><code>@Rentention</code>：指定注解的作用范围，有三种范围 <code>SOURCE</code> <code>CLASS</code> <code>RUNTIME</code></p><p><code>@Rentention</code> 的三种值：</p><ul><li><code>RententionPolicy.SOURCE</code>：编译器使用后，直接丢弃这种策略的注释</li><li><code>RententionPolicy.CLASS</code>：编译器把注解记录在 class 文件中。当运行 Java 程序时， JVM 不会保留注释。这是默认值</li><li><code>RententionPolicy.RUNTIME</code>：编译器把注解记录在 class 文件中。当运行 Java 程序时，JVM 会保留注解。程序可以通过反射获取该注解</li></ul></li><li><p><code>@Target</code>：指定注解的使用范围</p><p><code>@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</code></p></li><li><p><code>@Documented</code>：指定该注解会不会在 Javadoc 体现</p></li><li><p><code>@Inherited</code>：子类会继承父类注解</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 枚举 </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-常用类</title>
      <link href="/2023/06/18/Java12%E5%B8%B8%E7%94%A8%E7%B1%BB/"/>
      <url>/2023/06/18/Java12%E5%B8%B8%E7%94%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="Wrapper类-x2F-包装类"><a href="#Wrapper类-x2F-包装类" class="headerlink" title="Wrapper类&#x2F;包装类"></a>Wrapper类&#x2F;包装类</h1><p>包装类（Wrapper）：针对<strong>八种基本数据类型</strong>相应的引用类型。有了类的特点，就可以调用类中的方法</p><p>理解了继承体系才知道有哪些方法能用，继承体系如下</p><table><thead><tr><th>基本数据类型</th><th>包装类</th><th>父类</th></tr></thead><tbody><tr><td>boolean</td><td>Boolean</td><td>Object</td></tr><tr><td>char</td><td>Character</td><td>Object</td></tr><tr><td>int</td><td>Integer</td><td>Number</td></tr><tr><td>float</td><td>Float</td><td>Number</td></tr><tr><td>double</td><td>Double</td><td>Number</td></tr><tr><td>long</td><td>Long</td><td>Number</td></tr><tr><td>short</td><td>Short</td><td>Number</td></tr><tr><td>byte</td><td>Byte</td><td>Number</td></tr><tr><td>void</td><td>Void</td><td>Object</td></tr></tbody></table><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309161838462.png"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309161838778.png" alt="char"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309161839328.png" alt="数字类都能看这个图"></p><h2 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h2><p>以int为例，其他的类似</p><p>装箱：int转为Interger</p><p>拆箱：interger转为Int</p><h3 id="手动装箱和拆箱（JDK-5-以前）"><a href="#手动装箱和拆箱（JDK-5-以前）" class="headerlink" title="手动装箱和拆箱（JDK 5 以前）"></a>手动装箱和拆箱（JDK 5 以前）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int n1 = 100;</span><br><span class="line">Integer integer = new Integer(n1);// 手动装箱</span><br><span class="line">Integer integer2 = Integer.valueOf(n1);// 手动装箱</span><br><span class="line">int i = integer.intValue();// 手动拆箱</span><br></pre></td></tr></table></figure><h3 id="自动装箱和拆箱（JDK-5-以后）"><a href="#自动装箱和拆箱（JDK-5-以后）" class="headerlink" title="自动装箱和拆箱（JDK 5 以后）"></a>自动装箱和拆箱（JDK 5 以后）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n2 = 200;</span><br><span class="line">Integer integer3 = n2;// 自动装箱，底层用的是valueOf()</span><br><span class="line">int j = integer3;// 自动拆箱，底层用的是intValue()</span><br></pre></td></tr></table></figure><p>虽然可以自动装箱、拆箱，但使用 &#x3D;&#x3D; 直接比较两个包装类时，仍然是比较其地址。以下比较通常会失败：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer ia = 1000;</span><br><span class="line">Integer ib = 1000;</span><br><span class="line">System.out.print(ia == ib);// false</span><br></pre></td></tr></table></figure><p>但是，Byte、Boolean 以及 Short、Integer 中 [-128, 127] 间的值已被包装到固定的对象中。对他们的比较可以成功。</p><blockquote><p>底层存了一个256大小的数组，如果值在 [-128, 127]中，直接用这个数组的地址，不用额外创建对象</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer ia = 127;</span><br><span class="line">Integer ib = 127;</span><br><span class="line">System.out.print(ia == ib);// true</span><br></pre></td></tr></table></figure><p>由此可见，使用 &#x3D;&#x3D; 直接比较两个包装类会带来不确定性。<strong>尽量使用 equals 方法对包装类进行比较。</strong></p><p>装箱与拆箱是 <strong>编译器</strong> 的工作。在生成可执行的字节码文件时，编译器已经插入了必要的方法调用。</p><h2 id="包装类和-String-的相互转换"><a href="#包装类和-String-的相互转换" class="headerlink" title="包装类和 String 的相互转换"></a>包装类和 String 的相互转换</h2><p>包装类转 <code>String</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer integer = 100;</span><br><span class="line">String str1 = integer + &quot;&quot;;//方法1（自动拆箱）</span><br><span class="line">String str2 = integer.toString();//方法2（toString方法）</span><br><span class="line">String str3 = String.valueOf(integer);//方法3（自动拆箱）</span><br></pre></td></tr></table></figure><p><code>String</code> 转包装类：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str4 = &quot;100&quot;;</span><br><span class="line">Integer integer2 = Integer.parseInt(str4);//方法1（自动装箱）</span><br><span class="line">Integer integer3 = new Integer(str4);//方法2（构造器）</span><br></pre></td></tr></table></figure><h2 id="包装类的常用方法"><a href="#包装类的常用方法" class="headerlink" title="包装类的常用方法"></a>包装类的常用方法</h2><ul><li><p><code>Integer.MIN_VALUE</code>：返回最大值</p></li><li><p><code>Double.MAX_VALUE</code>：返回最小值</p></li><li><p><code>byteValue()</code>、<code>doubleValue()</code>、<code>floatValue()</code>、<code>intValue()</code>、<code>longValue()</code></p><p>按各种基本数据类型返回该对象的值</p></li><li><p><code>Character.isDigit(int)</code>：判断是不是数字</p><p><code>Character.isLetter(int)</code>：判断是不是字母</p><p><code>Character.isUpperCase(int)</code>：判断是不是大写字母</p><p><code>Character.isLowerCase(int)</code>：判断是不是小写字母</p><p><code>Characher.isWhitespace(int)</code>：判断是不是空格</p></li><li><p><code>Character.toUpperCase(int)</code>：转成大写字母</p><p><code>Character.toLowerCase(int)</code>：转成小写字母</p></li><li><p><code>Integer.parseInt(string)</code>：将 String 内容转为 int</p><p>double等同理</p></li></ul><h2 id="Interger创建机制"><a href="#Interger创建机制" class="headerlink" title="Interger创建机制"></a>Interger创建机制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309162137184.png"></p><p>值在[-128,127]中，直接从IntegerCache中取出，用IntegerCache的地址，不在这个范围里面的才用new新建对象。</p><p>但是如果直接用new创建对象，一定不一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">127</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">127</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;i1 == i2&quot;</span>);</span><br><span class="line">        System.out.println(i1 == i2);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">128</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">128</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;i3 == i4&quot;</span>);</span><br><span class="line">        System.out.println(i3 == i4);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i5</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i6</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">        System.out.print(<span class="string">&quot;i5 == i6&quot;</span>);</span><br><span class="line">        System.out.println(i5 == i6);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i7</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i8</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">        System.out.print(<span class="string">&quot;i7 == i8&quot;</span>);</span><br><span class="line">        System.out.println(i7 == i8);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a5</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">127</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;a5 == a6&quot;</span>);</span><br><span class="line">        System.out.println(a5 == a6);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a7</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a8</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">        System.out.print(<span class="string">&quot;a7 == a8&quot;</span>);</span><br><span class="line">        System.out.println(a7 == a8);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a9</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a0</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">        System.out.print(<span class="string">&quot;a9 == a0&quot;</span>);</span><br><span class="line">        System.out.println(a9 == a0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h1><p>数学类，是静态类，封装了一堆数学方法，直接<strong>类名.方法</strong>调用</p><p>常用方法：</p><ol><li><p><code>Math.multiplyExact(int n1, int n2)</code>：进行乘法运算，返回运算结果</p><p>通常的乘法 <code>n1 * n2</code> 在结果大于那个数据类型存储上限时，可能返回错误的值。</p><p>使用此方法，结果大于那个数据类型存储上限时，会抛出异常</p><p><code>Math.addExact(int n1, int n2)</code>：加法</p><p><code>Math.subtractExact(int n1, int n2)</code>：减法</p><p><code>Math.incrementExact(int n1)</code>：自增</p><p><code>Math.decrementExact(int n1)</code>：自减</p><p><code>Math.negateExact(int n1, int n2)</code>：改变符号</p></li><li><p><code>Math.abs(n)</code>：求绝对值，返回 |n1|</p></li><li><p><code>Math.pow(n, i)</code>：求幂，返回 n3 ^ i</p></li><li><p><code>Math.ceil(n)</code>：向上取整，返回 &gt;&#x3D; n3 的最小整数（转成double）</p></li><li><p><code>Math.floor(n)</code>：向下取整，返回 &lt;&#x3D;n4 的最小整数（转成double）</p></li><li><p><code>Math.floorMod(int n1, int n2)</code>：返回 n1 除以 n2 的余数</p><p><code>n1 % n2</code> 的场合，返回的可能是负数，而不是数学意义上的余数</p></li><li><p><code>Math.round(n)</code>：四舍五入，相当于 <code>Math.floor(n5 + 0.5)</code></p></li><li><p><code>Math.sqrt(n)</code>：求开方。负数的场合，返回 <code>NaN</code></p></li><li><p><code>Math.random()</code>：返回一个 [0, 1) 区间的随机小数</p></li><li><p><code>Math.sin(n)</code>：正弦函数</p><p><code>Math.cos(n)</code>：余弦函数</p><p><code>Math.tan(n)</code>、<code>Math.atan(n)</code>、<code>Math.atan2(n)</code></p><p>要注意，上述方法传入的参数是 <strong>弧度值</strong>。</p><p>要得到一个角度的弧度值，应使用：<code>Math.toRadians(n)</code></p></li><li><p><code>Math.exp(n)</code>：e 的 n 次幂</p><p><code>Math.log10(n)</code>：10 为底的对数</p><p><code>Math.log()</code>：自然对数</p></li><li><p><code>Math.PI</code>：圆周率的近似值</p><p><code>Math.E</code>：e 的近似值</p></li></ol><h1 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h1><p><code>Arrays.toString()</code>：返回数组的字符串形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] nums = &#123;0, 1, 33&#125;;</span><br><span class="line">String str = Array.toString(nums);//此时，str = &quot;[0, 1, 33]&quot;</span><br></pre></td></tr></table></figure><blockquote><p>特别的，输入为 null 时返回 “null”</p></blockquote><p><code>Arrays.sort(arr)</code>：排序</p><blockquote><p>因为数组是引用类型，使用 sort 排序后，会直接影响到实参</p></blockquote><p><code>Arrays.sort(arr, Comparator c)</code>：按照传入的比较器决定排序方法，可以改变是升序还是降序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Integer[] nums;</span><br><span class="line">...</span><br><span class="line">Comparator&lt;Integer, Integer&gt; c = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer, Integer&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n2 - n1;<span class="comment">// 这个场合，变成从大到小排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Arrays.sort(nums, c);</span><br></pre></td></tr></table></figure><p><code>Arrays.binarySearch(array, num)</code>：通过二分搜索法查找。前提是必须先排序。找不到的场合，返回 - (low + 1)。即，其应该在的位置的负值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] nums2 = &#123;-10, -5, -2, 0, 4, 5, 9&#125;;</span><br><span class="line">int index = Arrays.binarySearch(nums2, 7);// 此时 index = -7</span><br><span class="line">// 如果 7 存在，应该在第 7 个位置</span><br></pre></td></tr></table></figure><p><code>Arrays.copyOf(arr, n)</code>：从 <code>arr</code> 中，复制 n 个元素（成为新的数组）。</p><p>n &gt; arr.length 的场合，在多余的位置添加 <code>null</code>。n &lt; 0 的场合，抛出异常。</p><p>该方法的底层使用的是 <code>System.arraycopy</code></p><p><code>Arrays.fill(arr, o)</code>：用 o 填充 <code>num</code> 的所有元素。</p><p><code>Arrays.equals(arr1, arr2)</code>：比较两个数组元素是否完全一致（<code>true</code>&#x2F;<code>false</code>）</p><p><code>Arrays.asList(a, b, c, d)</code>：将输入数据转成一个 <code>List</code> 集合</p><h1 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h1><ul><li><p><code>System.exit(0)</code>：退出当前程序。0 表示一个状态，正常状态是 0</p></li><li><p><code>System.arraycopy(arr, 0, newArr, 0 ,3)</code>：复制数组元素。</p><p>上例是：arr 自下标 0 起开始，向 newArr 自下标 0 开始，依次拷贝 3 个值</p><p>这个方法比较适合底层调用。我们一般使用 <code>Arrays.copyOf</code> 来做</p></li><li><p><code>System.currentTimeMillis</code>：返回当前时间距离 1970 - 1 - 1 的毫秒数</p></li><li><p><code>System.gc</code>：运行垃圾回收机制</p></li></ul><h1 id="BigInteger-和-BigDecimal-类"><a href="#BigInteger-和-BigDecimal-类" class="headerlink" title="BigInteger 和 BigDecimal 类"></a>BigInteger 和 BigDecimal 类</h1><p>BigInteger：适合保存更大的整数</p><p>BigDecimal：适合保存精度更大的浮点数</p><p><strong>构造方法：</strong></p><ul><li><p><code>new BigInteger(String intStr)</code>：通过一个字符串构建大数</p><blockquote><p>直接用数值会报错，用字符串倒是没问题</p></blockquote></li><li><p><code>BigInteger BigInteger.valueOf(1)</code>：通过静态方法，让整数类型转成大数</p></li></ul><p>在对 <code>BigInteger</code> 和 <code>BigDecimal</code> 进行加减乘除的时候，需要使用对应方法，不能直接用 <code>+</code> <code>-</code> <code>*</code> <code>/</code></p><ul><li><p><code>BigInteger add(BigInteger)</code>：加法运算。返回新的大数</p></li><li><p><code>BigInteger subtract(BigInteger)</code>：减法</p></li><li><p><code>BigInteger multiply(BigInteger)</code>：乘法</p></li><li><p><code>BigInteger divide(BigInteger)</code>：除法运算</p><p>该方法可能抛出异常。因为可能产生是无限长度小数。</p><p>解决方法（保留分子精度）：<code>bigDecimal.divide(bD3, BigDecimal.ROUND_CELLING)</code></p></li></ul><p>一些常量：</p><p><code>BigInteger.ONE</code>、<code>BigInteger.ZERO</code>、<code>BigInteger.TEN</code> 分别是 1、0、10</p><h1 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h1><h2 id="第一代日期类Date"><a href="#第一代日期类Date" class="headerlink" title="第一代日期类Date"></a>第一代日期类Date</h2><p>Date：精确到毫秒，代表特定瞬间。需要导入 java.util.Date</p><p>SimpleDateFormat：格式和解析日期的类。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309170944323.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Date d1 = new Date(); //获取当前系统时间</span><br><span class="line">System.out.println(&quot;当前日期=&quot; + d1);</span><br><span class="line">Date d2 = new Date(9234567); //通过指定毫秒数得到时间</span><br><span class="line">System.out.println(&quot;d2=&quot; + d2); //获取某个时间对应的毫秒数</span><br></pre></td></tr></table></figure><p>默认输出日期格式是国外的格式，因此通常需要进行格式转换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy.MM.dd HH.mm.ss&quot;);</span><br><span class="line">String dateFormated = sdf.(d1);//日期转成指定格式。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Date d1 = new Date(); //获取当前系统时间</span><br><span class="line">System.out.println(&quot;当前日期=&quot; + d1);</span><br><span class="line">Date d2 = new Date(9234567); //通过指定毫秒数得到时间</span><br><span class="line">System.out.println(&quot;d2=&quot; + d2); //获取某个时间对应的毫秒数</span><br><span class="line">//1. 创建 SimpleDateFormat 对象，可以指定相应的格式</span><br><span class="line">//2. 这里的格式使用的字母是规定好，不能乱写</span><br><span class="line">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy 年 MM 月 dd 日 hh:mm:ss E&quot;);</span><br><span class="line">String format = sdf.format(d1); // format:将日期转换成指定格式的字符串</span><br><span class="line">System.out.println(&quot;当前日期=&quot; + format);</span><br><span class="line">//1. 可以把一个格式化的 String 转成对应的 Date</span><br><span class="line">//2. 得到 Date 仍然在输出时，还是按照国外的形式，如果希望指定格式输出，需要转换</span><br><span class="line">//3. 在把 String -&gt; Date ， 使用的 sdf 格式需要和你给的 String 的格式一样，否则会抛出转换异常</span><br><span class="line">String s = &quot;1996 年 01 月 01 日 10:20:30 星期一&quot;;</span><br><span class="line">Date parse = sdf.parse(s);</span><br><span class="line">System.out.println(&quot;parse=&quot; + sdf.format(parse));</span><br></pre></td></tr></table></figure><h2 id="第二代日期类Calendar"><a href="#第二代日期类Calendar" class="headerlink" title="第二代日期类Calendar"></a>第二代日期类Calendar</h2><p>Calendar：构造器是私有的，要通过 getInstance 方法获取实例</p><ol><li><p>Calendar 是一个抽象类，其构造器私有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Calendar c1 = Calendar.genInstance();//获取实例的方法</span><br></pre></td></tr></table></figure></li><li><p>提供大量方法和字段提供给程序员使用</p><ul><li><p><code>c1.get(Calendar.YEAR)</code>：获取年份数</p></li><li><p><code>c1.get(Calendar.MONTH)</code>：获取月份数</p><blockquote><p>特别的，实际月份是 返回值 +1。因为 Calendar 的月份是从 0 开始编号的</p></blockquote></li><li><p><code>c1.get(Calendar.DAY_OF_MONTH)</code>：获取日数</p></li><li><p><code>c1.get(Calendar.HOUR)</code>：获取小时数（12小时制）</p><p><code>c1.get(Calendar.HOUR_OF_DATE)</code>：获取小时数（24小时制）</p></li><li><p><code>c1.get(Calendar.MINUTE)</code>：获取分钟数</p></li><li><p><code>c1.get(Calendar.SECOND)</code>：获取秒数</p></li></ul><p>Calendar 没有专门的格式化方法，需要程序员自己组合来显示</p><p>Calendar 也存在不足：</p><ol><li>可变性：像日期和实际这样的类应该是不可改变的</li><li>偏移性：年份都是从 1900 年开始，月份都是从 0 开始</li><li>格式化：只对 Date 有用，对 Calendar 没用</li><li>其他问题：如不能保证线程安全，不能处理闰秒（每隔 2 天多 1 秒）等</li></ol></li></ol><h2 id="第三代日期类"><a href="#第三代日期类" class="headerlink" title="第三代日期类"></a>第三代日期类</h2><p>在 JDK 8 加入了以下新日期类：</p><ul><li>LocalDate：只包含 日期（年月日），可以获取 日期字段</li><li>LocalTime：只包含 时间（时分秒），可以获取 时间字段</li><li>LocalDateTime：包含 日期 + 时间，可以获取 日期 + 时间字段</li><li>DateTimeFormatter：格式化日期</li><li>Instant：时间戳</li></ul><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309171027031.png"></p><ol><li><ul><li><p>使用 <code>now()</code> 方法返回当前时间的对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime ldt = LocalDateTime.now();//获取当前时间</span><br></pre></td></tr></table></figure></li></ul></li><li><p>获取各字段方法：</p><ul><li><p><code>ldt.getYear();</code>：获取年份数</p></li><li><p><code>ldt.getMonth();</code>：获取月份数（英文）</p><p><code>ldt.getMonthValue();</code>：获取月份数（数字）</p></li><li><p><code>ldt.getDayOfMonth();</code>：获取日数</p></li><li><p><code>LocalDateTime ldt2 = ldt.plusDays(100);</code>：获取 ldt 时间 100 天后的时间实例</p></li><li><p><code>LocalDateTime ldt3 = ldt.minusHours(100);</code>：获取 ldt 时间 100 小时前的时间实例</p></li></ul></li><li><p>格式化日期：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter dtf = new DateTimeFormatter(&quot;yyyy.MM.dd HH.mm.ss&quot;);</span><br><span class="line">String date = dtf.format(ldt);//获取格式化字符串</span><br></pre></td></tr></table></figure></li><li><p><code>Instant</code> 和 <code>Date</code> 类似</p><ul><li>获取当前时间戳：<code>Instant instant = Instant.now();</code></li><li>转换为 <code>Date</code>：<code>Date date = Date.form(instant);</code></li><li>由 <code>Date</code> 转换：<code>Instant instant = date.toInstant;</code></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 内置类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-JDBC</title>
      <link href="/2023/06/15/Java11JDBC/"/>
      <url>/2023/06/15/Java11JDBC/</url>
      
        <content type="html"><![CDATA[<h1 id="JDBC概述"><a href="#JDBC概述" class="headerlink" title="JDBC概述"></a>JDBC概述</h1><h2 id="数据的持久化"><a href="#数据的持久化" class="headerlink" title="数据的持久化"></a>数据的持久化</h2><ul><li>持久化(persistence)：把数据保存到可掉电式存储设备中以供之后使用。大多数情况下，特别是企业级应用，数据持久化意味着将内存中的数据保存到硬盘上加以”固化”，而持久化的实现过程大多通过各种关系数据库来完成。</li><li>持久化的主要应用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。</li></ul><h2 id="Java中的数据存储技术"><a href="#Java中的数据存储技术" class="headerlink" title="Java中的数据存储技术"></a>Java中的数据存储技术</h2><ul><li>在Java中，数据库存取技术可分为如下几类：<ul><li>JDBC直接访问数据库</li><li>JDO (Java Data Object )技术</li><li>第三方O&#x2F;R工具，如Hibernate, Mybatis 等</li></ul></li><li>JDBC是java访问数据库的基石，JDO、Hibernate、MyBatis等只是更好的封装了JDBC。</li></ul><h2 id="JDBC介绍"><a href="#JDBC介绍" class="headerlink" title="JDBC介绍"></a>JDBC介绍</h2><ul><li>JDBC是Java 提供的一套用于操作数据库的接口 API。Java 程序员只需要面向该接口即可连接任何提供了 JDBC 驱动程序的数据库，完成对数据库的各种操作。不同的数据库厂商，需要针对这套接口提供不同的实现。</li><li>JDBC(Java Database Connectivity)是一个独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口（一组API），定义了用来访问数据库的标准Java类库，（java.sql,javax.sql）使用这些类库可以以一种标准的方法、方便地访问数据库资源。</li><li>JDBC为访问不同的数据库提供了一种统一的途径，为开发者屏蔽了一些细节问题。</li><li>JDBC的目标是使Java程序员使用JDBC可以连接任何提供了JDBC驱动程序的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。</li><li>如果没有JDBC，那么Java程序访问数据库时是这样的：<br><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310092034056.png"></li><li>有了JDBC，Java程序访问数据库时是这样的：<br><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310092034585.png"></li><li>总结如下：<br><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310092034573.png"></li></ul><h2 id="JDBC体系结构"><a href="#JDBC体系结构" class="headerlink" title="JDBC体系结构"></a>JDBC体系结构</h2><p>JDBC接口（API）包括两个层次：</p><ul><li>面向应用的API：Java API，抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果）。</li><li>面向数据库的API：Java Driver API，供开发商开发数据库驱动程序用。</li></ul><blockquote><p>JDBC是sun公司提供一套用于数据库操作的接口，java程序员只需要面向这套接口编程即可。不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。</p></blockquote><h1 id="JDBC使用"><a href="#JDBC使用" class="headerlink" title="JDBC使用"></a>JDBC使用</h1><p><strong>JDBC 程序编写步骤（示范）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 注册驱动 */</span></span><br><span class="line"><span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.mysql.cj.jdbc.Driver();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取连接 */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/melody&quot;</span>;</span><br><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">properties.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;******&quot;</span>);</span><br><span class="line"><span class="type">Connection</span> <span class="variable">connect</span> <span class="operator">=</span> driver.connect(url, properties);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 执行语句 */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into customer (customer_id,name,card_id) values(0004,&#x27;赫尔&#x27;,&#x27;00000000000000000O&#x27;)&quot;</span>;</span><br><span class="line"><span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connect.createStatement();</span><br><span class="line"><span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> statement.executeUpdate(sql);</span><br><span class="line">System.out.println(rows);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 释放资源 */</span></span><br><span class="line">statement.close();</span><br><span class="line">connect.close();</span><br></pre></td></tr></table></figure><ul><li><p>前置操作：将 <code>mysql-connector-java-8.0.27.jar</code> 该文件拷贝到项目目录下，选中后右键选择 <code>Add as library</code></p></li><li><p>注册驱动：加载 <code>Driver</code> 类</p><p>这里我导入了 <code>com.mysql.cj.jdbc.Driver</code>。根据前面的 <code>jar</code> 包的版本不同，应该导入的路径也会不同。</p><p>旧版本的 <code>jar</code> 包可能应该导入 <code>com.mysql.jdbc.Driver</code> 这个包。</p></li><li><p>获取连接：得到 <code>Connection</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br></pre></td></tr></table></figure><p>这里表示进入 <code>test</code> 这个数据库。</p></li><li><p>执行语句：发送 SQL 命令给 MySQL 执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> statement.executeUpdate(sql);</span><br></pre></td></tr></table></figure><p>如果是 dml 语句，这里返回的 rows 是影响的行数。返回 0 表示失败。</p></li><li><p>释放资源：关闭相关连接，顺序和使用时相反</p></li></ul><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310161000701.png"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310160834641.png"></p><h2 id="JDBC要素"><a href="#JDBC要素" class="headerlink" title="JDBC要素"></a>JDBC要素</h2><div class="tabs" id="要素"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#要素-1">Driver</button></li><li class="tab"><button type="button" data-href="#要素-2">URL</button></li><li class="tab"><button type="button" data-href="#要素-3">用户名和密码</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="要素-1"><p>Driver接口介绍</p><p>java.sql.Driver 接口是所有 JDBC 驱动程序需要实现的接口。这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现。</p><p>在程序中不需要直接去访问实现了 Driver 接口的类，而是由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver实现。</p><p>例如：</p><ul><li>Oracle的驱动：oracle.jdbc.driver.OracleDriver</li><li>mySql的驱动： com.mysql.jdbc.Driver</li></ul><p>加载与注册JDBC驱动</p><ul><li><p>加载驱动：加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名 Class.forName(“com.mysql.jdbc.Driver”);</p></li><li><p>注册驱动：DriverManager 类是驱动程序管理器类，负责管理驱动程序</p></li><li><p>使用DriverManager.registerDriver(com.mysql.jdbc.Driver)来注册驱动</p></li><li><p>通常不用显式调用 DriverManager 类的 registerDriver() 方法来注册驱动程序类的实例，因为 Driver 接口的驱动程序类都包含了静态代码块，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注册自身的一个实例。下面是MySQL的Driver实现类的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.mysql.jdbc;</span><br><span class="line"></span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line"></span><br><span class="line">public class Driver extends NonRegisteringDriver implements java.sql.Driver &#123;</span><br><span class="line">    public Driver() throws SQLException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            DriverManager.registerDriver(new Driver());</span><br><span class="line">        &#125; catch (SQLException var1) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Can&#x27;t register driver!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="要素-2"><p>JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。</p><p>JDBC URL的标准由三部分组成，各部分间用冒号分隔。</p><ul><li>jdbc：子协议:子名称</li><li>协议：JDBC URL中的协议总是jdbc</li><li>子协议：子协议用于标识一个数据库驱动程序</li><li>子名称：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了定位数据库提供足够的信息。包含主机名(对应服务端的ip地址)，端口号，数据库名</li></ul><p>举例</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdbc</span>:<span class="string">mysql://localhost:3306/dbtest</span></span><br><span class="line"></span><br><span class="line"><span class="attr">其中</span></span><br><span class="line"><span class="attr">jdbc</span> <span class="string">--&gt; 协议</span></span><br><span class="line"><span class="attr">mysql</span> <span class="string">--&gt; 子协议</span></span><br><span class="line"><span class="attr">localhost</span>:<span class="string">3306/dbtest --&gt; 子名称</span></span><br><span class="line">    <span class="attr">localhost</span> <span class="string">--&gt; 主机名</span></span><br><span class="line">    <span class="attr">3306</span> <span class="string">--&gt; 端口号(MySQL默认端口号为3306)</span></span><br><span class="line">    <span class="attr">dbtest</span> <span class="string">--&gt; 数据库名</span></span><br></pre></td></tr></table></figure><p> 几种常用数据库的 JDBC URL</p><ul><li><p>MySQL的连接URL编写方式：</p><ul><li><p>jdbc:mysql:&#x2F;&#x2F;主机名称:mysql服务端口号&#x2F;数据库名称?参数&#x3D;值&amp;参数&#x3D;值</p></li><li><p>jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test</p></li><li><p>jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8</p><blockquote><p>如果JDBC程序与服务器端的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集</p></blockquote></li><li><p>jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test?user&#x3D;root&amp;password&#x3D;123456</p></li></ul></li><li><p>Oracle 9i的连接URL编写方式：</p><ul><li>jdbc:oracle:thin:@主机名称:oracle服务端口号:数据库名称</li><li>jdbc:oracle:thin:@localhost:1521:test</li></ul></li><li><p>SQLServer的连接URL编写方式：</p><ul><li>jdbc:sqlserver:&#x2F;&#x2F;主机名称:sqlserver服务端口号:DatabaseName&#x3D;数据库名称</li><li>jdbc:sqlserver:&#x2F;&#x2F;localhost:1433:DatabaseName&#x3D;test</li></ul></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="要素-3"><p>user,password可以用“属性名&#x3D;属性值”（键值对）方式告诉数据库</p><p>可以调用 DriverManager 类的 getConnection() 方法建立到数据库的连接</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="获取数据库连接"><a href="#获取数据库连接" class="headerlink" title="获取数据库连接"></a>获取数据库连接</h2><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">方法1</button></li><li class="tab"><button type="button" data-href="#test1-2">方法2</button></li><li class="tab"><button type="button" data-href="#test1-3">方法3</button></li><li class="tab"><button type="button" data-href="#test1-4">方法4</button></li><li class="tab"><button type="button" data-href="#test1-5">方法5（推荐）</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p>直接创建 <code>Driver</code>，调用 <code>driver.connet(url, properties);</code></p><p>代码中显式出现了第三方数据库的API，就是 <code>new com.mysql.jdbc.Driver(); </code>这一句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectionTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式一 ：</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConnection1</span><span class="params">()</span>  <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.mysql.jdbc.Driver();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//jdbc:mysql:协议</span></span><br><span class="line">        <span class="comment">//localhost：ip地址</span></span><br><span class="line">        <span class="comment">//3306：默认mysql的端口号</span></span><br><span class="line">        <span class="comment">//test：数据库名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line">        <span class="comment">//将用户名和密码封装在Properties中</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        info.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">        info.setProperty(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;111111&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> driver.connect(url,info);</span><br><span class="line"></span><br><span class="line">    System.out.println(conn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p>使用反射加载 <code>Driver</code> 类</p><p>对方式一的迭代：不出现第三方API ，使程序有更好的可移植性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConnection2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//1 获取Driver实现类对象，反射实现</span></span><br><span class="line">    Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">    <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> (Driver) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2 提供要连接的数据库</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3 用户名密码</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    info.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">    info.setProperty(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;abc123&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4 获取连接</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> driver.connect(url,info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p>使用 <code>DriverManager</code> 替代 <code>Driver</code> 进行统一管理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConnection3</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//1 获取Driver实现类对象</span></span><br><span class="line">    Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">    <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> (Driver) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2 获取连接基本信息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;abc123&quot;</span>;</span><br><span class="line">    <span class="comment">//注册驱动</span></span><br><span class="line">    DriverManager.registerDriver(driver);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取连接</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">    System.out.println(connection);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，<code>DriverManager.getConnetion()</code> 有三种方法。分别是：</p><ul><li><code>getConnetion(url);</code></li><li><code>getConnetion(url, properties);</code></li><li><code>getConnetion(url, name, password);</code></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><p>使用 <code>Class.forName()</code> 自动完成注册驱动</p><p>省略了实例化和注册驱动，源码有静态代码自动注册</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConnection4</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//1 获取连接基本信息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;abc123&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2 加载Driver</span></span><br><span class="line">    Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3 获取连接</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">    System.out.println(connection);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Class.forName()</code> 在加载 <code>Driver</code> 类时，会自动完成注册，原理是加载类的时候调用静态代码块</p><p>原理：</p><p><code>Driver</code> 类的源码中有这样一段，这个静态代码块在类加载时会被执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         DriverManager.registerDriver(<span class="keyword">new</span> <span class="title class_">Driver</span>());</span><br><span class="line">     &#125; <span class="keyword">catch</span> (SQLException var1) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Can&#x27;t register driver!&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，其实不执行 <code>Class.forName(...);</code> 语句的场合，也能正确获取 <code>Connection</code>。</p><p>这是因为 JDK 1.5 以后使用了 jdbc4。这个场合，系统会自动调用 jar 包下 <code>META-INF\services\java.sql.Driver</code> 这个文件中的类名称去注册。</p><p>打开上述文件看看，里面赫然写着：<code>com.mysql.cj.jdbc.Driver</code></p><blockquote><p>即使如此，还是建议写上 <code>Class.forName(...)</code> 语句！</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-5"><p>在方式 4 的基础上，使用配置文件，连接数据库更灵活。</p><p>这种方式是实际开发最常用的方式。</p><p>使用配置文件的方式保存配置信息，在代码中加载配置文件，通过读取配置文件方式获得连接。</p><p>使用配置文件的好处：</p><ul><li>实现了代码和数据的分离，如果需要修改配置信息，直接在配置文件中修改，不需要深入代码</li><li>如果修改了配置信息，省去重新编译的过程。</li></ul><p>流程：</p><ol><li><p>配置文件（创建 src\mysql.properties）：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line"><span class="attr">user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">******</span></span><br></pre></td></tr></table></figure></li><li><p>链接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConnection5</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 获取连接基本信息</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> ConnectionTest.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    properties.load(is);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">driverClass</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;driverClass&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2 加载驱动</span></span><br><span class="line">    Class.forName(driverClass);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3 获取连接</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">    System.out.println(connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="ReaultSet-结果集"><a href="#ReaultSet-结果集" class="headerlink" title="ReaultSet 结果集"></a>ReaultSet 结果集</h2><p>ResultSet：表示数据库结果集的数据表。通常通过执行查询数据库的语句生成。</p><p>ResultSet 对象保持一个光标指向其当前的数据行。该光标的初始位置在第一行之前。调用 next 方法将光标下移，移动到末端的场合会返回 false。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310151520161.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过Properties对象获取配置文件的信息</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取相关的值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 注册驱动</span></span><br><span class="line">    Class.forName(driver);<span class="comment">//建议写上</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 得到连接</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 得到Statement</span></span><br><span class="line">    <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 组织SQL</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select id, name , sex, borndate from actor&quot;</span>;</span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> statement.executeQuery(sql);</span><br><span class="line">    <span class="comment">//执行给定的SQL语句，该语句返回单个 ResultSet对象</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        +----+-----------+-----+---------------------+</span></span><br><span class="line"><span class="comment">        | id | name      | sex | borndate            |</span></span><br><span class="line"><span class="comment">        +----+-----------+-----+---------------------+-------+</span></span><br><span class="line"><span class="comment">        |  4 | 刘德华    | 男  | 1970-12-12 00:00:00 |</span></span><br><span class="line"><span class="comment">        |  5 | jack      | 男  | 1990-11-11 00:00:00 |</span></span><br><span class="line"><span class="comment">        +----+-----------+-----+---------------------+-------+</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 使用while取出数据</span></span><br><span class="line">    <span class="keyword">while</span> (resultSet.next()) &#123; <span class="comment">// 让光标向后移动，如果没有更多行，则返回false</span></span><br><span class="line">        <span class="comment">//int id  = resultSet.getInt(1);    获取该行的第1列</span></span><br><span class="line">        <span class="comment">//int id1 = resultSet.getInt(&quot;id&quot;); 通过列名来获取值, 推荐</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> resultSet.getString(<span class="number">2</span>);<span class="comment">//获取该行的第2列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sex</span> <span class="operator">=</span> resultSet.getString(<span class="number">3</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> resultSet.getDate(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(id + <span class="string">&quot;\t&quot;</span> + name + <span class="string">&quot;\t&quot;</span> + sex + <span class="string">&quot;\t&quot;</span> + date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6. 关闭连接</span></span><br><span class="line">    resultSet.close();</span><br><span class="line">    statement.close();</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310151533752.png"></p><p>Statement：是个接口，由数据库厂商完成功能的实现</p><p><code>Statment</code> 对象用于执行静态 SQL 语句，并返回其生成的结果的对象</p><p>在连接建立后，需要访问数据库、执行命名或 SQL 语句，有如下方式：</p><ul><li><code>Statment</code>：用于执行静态 SQL 语句并返回它所生成结果的对象。（存在 SQL 注入问题，在实际开发中基本不使用）</li><li><code>PerparedStatement</code>：SQL 语句被<strong>预编译</strong>并存储在此对象中，可以使用此对象多次高效地执行该语句。（预处理SQL，PrepatedStatement 是 Statement 的子接口，优化实现功能）</li><li><code>CallableStatement</code>：用于执行 SQL 存储过程（上图未显示）</li></ul><h3 id="使用Statement操作数据表的弊端"><a href="#使用Statement操作数据表的弊端" class="headerlink" title="使用Statement操作数据表的弊端"></a>使用Statement操作数据表的弊端</h3><p>通过调用 <code>Connection</code> 对象的 <code>createStatement()</code> 方法创建该对象。该对象用于执行静态的 SQL 语句，并且返回执行结果。</p><p>Statement 接口中定义了下列方法用于执行 DML和DQL语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">excuteUpdate</span><span class="params">(String sql)</span> <span class="comment">//执行更新操作INSERT、UPDATE、DELETE</span></span><br><span class="line">ResultSet <span class="title function_">executeQuery</span><span class="params">(String sql)</span> <span class="comment">//执行查询操作SELECT</span></span><br></pre></td></tr></table></figure><p>但是使用Statement操作数据表存在弊端：</p><ul><li>问题一：存在拼串操作，繁琐</li><li>问题二：存在SQL注入问题</li></ul><p>SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令，从而利用系统的 SQL 引擎完成恶意行为的做法。</p><p>对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement(从Statement扩展而来) 取代 Statement 就可以了。</p><h2 id="PerparedStatement"><a href="#PerparedStatement" class="headerlink" title="PerparedStatement"></a>PerparedStatement</h2><h3 id="PreparedStatement介绍"><a href="#PreparedStatement介绍" class="headerlink" title="PreparedStatement介绍"></a>PreparedStatement介绍</h3><ul><li>可以通过调用 <code>Connection</code> 对象的 <code>preparedStatement(String sql)</code> 方法获取 <code>PreparedStatement</code> 对象</li><li><code>PreparedStatement</code> 接口是 <code>Statement</code> 的子接口，它表示一条预编译过的 SQL 语句</li><li><code>PreparedStatement</code> 对象所代表的 SQL 语句中的参数用问号(<code>?</code>)来表示，调用 <code>PreparedStatement</code> 对象的<code>setXxx()</code> 方法来设置这些参数. <code>setXxx()</code> 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从1开始)，第二个是设置的 SQL 语句中的参数的值</li></ul><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310151535379.png"></p><ol><li><p><code>PreparedStatement</code> 执行的 SQL 语句的参数用 <code>?</code> 表示。</p><p>调用方法设置 SQL 语句中的参数，一堆set方法，都有2个参数，第一个是设置的参数的索引（位置），第二个是设置值（参数值）</p></li><li><p><code>executeQuery()</code> ：执行查询方法，返回 <code>ResultSet</code> 对象。</p></li><li><p>executeUpdate()：执行更新，包括增、删、修改</p></li></ol><blockquote><p>PerparedStatement 对SQL语句有一个预处理的过程</p></blockquote><h3 id="预处理的好"><a href="#预处理的好" class="headerlink" title="预处理的好"></a>预处理的好</h3><ol><li>不再使用拼接语句，增加代码可读性，减少语法错误</li><li>解决了 SQL 注入问题</li><li>大大减少了编译次数，效率提高（保留一个模版，每次传入不同参数执行不同SQL语句）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//看 PreparedStatement类图</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过Properties对象获取配置文件的信息</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取相关的值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 注册驱动</span></span><br><span class="line">    Class.forName(driver);<span class="comment">//建议写上</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 得到连接</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 得到PreparedStatement</span></span><br><span class="line">    <span class="comment">//3.1 组织SqL , Sql 语句的 ? 就相当于占位符</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select name , pwd  from admin where name =? and pwd = ?&quot;</span>;</span><br><span class="line">    <span class="comment">//3.2 preparedStatement 对象实现了 PreparedStatement 接口的实现类的对象</span></span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line">    <span class="comment">//3.3 给 ? 赋值</span></span><br><span class="line">    preparedStatement.setString(<span class="number">1</span>, admin_name);</span><br><span class="line">    preparedStatement.setString(<span class="number">2</span>, admin_pwd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 执行 select 语句使用  executeQuery</span></span><br><span class="line">    <span class="comment">//   如果执行的是 dml(update, insert ,delete) executeUpdate()</span></span><br><span class="line">    <span class="comment">//   这里执行 executeQuery ,不要在写 sql</span></span><br><span class="line"></span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> preparedStatement.executeQuery(sql);</span><br><span class="line">    <span class="keyword">if</span> (resultSet.next()) &#123; <span class="comment">//如果查询到一条记录，则说明该管理存在</span></span><br><span class="line">        System.out.println(<span class="string">&quot;恭喜， 登录成功&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对不起，登录失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭连接</span></span><br><span class="line">    resultSet.close();</span><br><span class="line">    preparedStatement.close();</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;       </span><br></pre></td></tr></table></figure><blockquote><p>注意，执行的时候不要再带参数了，不然就是执行模板了</p></blockquote><p>相关的类及方法：</p><table><thead><tr><th>类 &#x2F; 接口</th><th>方法</th></tr></thead><tbody><tr><td>DriverManager 驱动管理类</td><td>getConnection(url, user, pwd) 获取连接</td></tr><tr><td></td><td>createStatement() 创建 Statement 对象</td></tr><tr><td></td><td>preparedStatement(sql) 生成预处理 PreparedStatement 对象</td></tr><tr><td>Statement 接口</td><td>executeUpdate(sql) 执行 dml 语句，返回影响行数</td></tr><tr><td></td><td>executeQuery(sql) 执行查询语句，返回 ResultSet</td></tr><tr><td></td><td>execute(sql) 执行任意 SQL 语句，返回布尔值</td></tr><tr><td>PreparedStatement 接口</td><td>executeUpdate() 执行 dml 语句，返回影响行数</td></tr><tr><td></td><td>executeQuery() 执行查询语句，返回 ResultSet</td></tr><tr><td></td><td>execute() 执行任意 SQL 语句，返回布尔值</td></tr><tr><td></td><td>setXXX(int, xxx) 设置 SQL 语句中占位符的值</td></tr><tr><td></td><td>setObject(int, xxx) 设置 SQL 语句中占位符的值</td></tr><tr><td>ResultSet 结果集</td><td>next() 向下移动一行。没有下一行的场合返回 false</td></tr><tr><td></td><td>previous() 向上移动一行。没有上一行的场合返回 false</td></tr><tr><td></td><td>getXXX(int)、getXXX(name) 返回 int 列 &#x2F; name 列的值</td></tr><tr><td></td><td>getObject(int)、getObject(name) 返回 int 列 &#x2F; name 列的值</td></tr></tbody></table><h3 id="PreparedStatement-vs-Statement"><a href="#PreparedStatement-vs-Statement" class="headerlink" title="PreparedStatement vs Statement"></a>PreparedStatement vs Statement</h3><ul><li>代码的可读性和可维护性</li><li>PreparedStatement 能最大可能提高性能：<ul><li>DBServer会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。</li><li>在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样每执行一次都要对传入的语句编译一次。</li></ul></li><li>PreparedStatement 可以防止 SQL 注入</li></ul><h2 id="JDBC-API"><a href="#JDBC-API" class="headerlink" title="JDBC API"></a>JDBC API</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310151613022.png"></p><h2 id="JDBCUtils"><a href="#JDBCUtils" class="headerlink" title="JDBCUtils"></a>JDBCUtils</h2><p>JDBCUtils：JDBC 的工具类</p><p>实际操作中，获取连接 和 释放资源 操作经常使用。可以把这些操作封装成工具类 JDBCUtils</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310151637985.png"></p><h2 id="操作BLOB类型字段"><a href="#操作BLOB类型字段" class="headerlink" title="操作BLOB类型字段"></a>操作BLOB类型字段</h2><h3 id="MySQL-BLOB类型"><a href="#MySQL-BLOB类型" class="headerlink" title="MySQL BLOB类型"></a>MySQL BLOB类型</h3><p>MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。</p><p>插入BLOB类型的数据<strong>必须使用PreparedStatement</strong>，因为BLOB类型的数据无法使用字符串拼接写的。</p><p>MySQL的四种BLOB类型除了在存储的最大信息量上不同外，他们是等同的</p><table><thead><tr><th align="center">类型</th><th align="center">大小{单位:字节)</th></tr></thead><tbody><tr><td align="center">TINYBLOB</td><td align="center">最大255</td></tr><tr><td align="center">BLOB</td><td align="center">最大65K</td></tr><tr><td align="center">MEDIUMBLOB</td><td align="center">最大16M</td></tr><tr><td align="center">LONGBLOB</td><td align="center">最大4G</td></tr></tbody></table><blockquote><p>但实际上packet 有大小限制，超过1M 还是会报错</p><p>如果在指定了相关的Blob类型以后，还报错：xxx too large，那么在mysql的安装目录下，找my.ini文件加上如下的配置参数： max_allowed_packet&#x3D;16M。</p><p>同时注意：修改了my.ini文件之后，需要重新启动mysql服务。</p></blockquote><p>实际使用中根据需要存入的数据大小定义不同的BLOB类型。</p><p>需要注意的是：如果存储的文件过大，数据库的性能会下降。</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>向数据表中插入大数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void blobTest() &#123;</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        PreparedStatement ps = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            String sql = &quot;insert into customers(name,email,birth,photo) values(?,?,?,?)&quot;;</span><br><span class="line">            //获取连接</span><br><span class="line">            connection = JDBCUtil.getConnection();</span><br><span class="line">            //预编译SQL语句，获取prepareStatement实例对象</span><br><span class="line">            ps = connection.prepareStatement(sql);</span><br><span class="line">            //填充占位符</span><br><span class="line">            ps.setObject(1, &quot;Kyle&quot;);</span><br><span class="line">            ps.setObject(2, &quot;Kyle@126.com&quot;);</span><br><span class="line">            ps.setObject(3, &quot;1997-08-07&quot;);</span><br><span class="line">            //操作Blob类型变量</span><br><span class="line">            ps.setBlob(4, new FileInputStream(&quot;头像.png&quot;));</span><br><span class="line">            //执行</span><br><span class="line">            ps.execute();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            JDBCUtil.clossResource(connection, ps);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p>从数据表中读取大数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void blobTest2() &#123;</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        PreparedStatement ps = null;</span><br><span class="line">        ResultSet rs = null;</span><br><span class="line">        InputStream is = null;</span><br><span class="line">        OutputStream os = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            String sql = &quot;select id,name,email,birth,photo from customers where id = ?&quot;;</span><br><span class="line">            connection = JDBCUtil.getConnection();</span><br><span class="line">            ps = connection.prepareStatement(sql);</span><br><span class="line">            ps.setObject(1, 16);</span><br><span class="line">            rs = ps.executeQuery();</span><br><span class="line">            if (rs.next())&#123;</span><br><span class="line">                int id = rs.getInt(&quot;id&quot;);</span><br><span class="line">                String name = rs.getString(&quot;name&quot;);</span><br><span class="line">                String email = rs.getString(&quot;email&quot;);</span><br><span class="line">                Date birth = rs.getDate(&quot;birth&quot;);</span><br><span class="line">                Customer customer = new Customer(id, name, email, birth);</span><br><span class="line">                System.out.println(customer);</span><br><span class="line">                Blob photo = rs.getBlob(&quot;photo&quot;);</span><br><span class="line">                is = photo.getBinaryStream();</span><br><span class="line">                os = new FileOutputStream(&quot;照片.png&quot;);</span><br><span class="line">                byte[] buffer = new byte[1024];</span><br><span class="line">                int len;</span><br><span class="line">                while ((len = is.read(buffer)) != -1) &#123;</span><br><span class="line">                    os.write(buffer, 0, len);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (is != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (os != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            JDBCUtil.clossResource(connection, ps, rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h3><h4 id="批量执行SQL语句"><a href="#批量执行SQL语句" class="headerlink" title="批量执行SQL语句"></a>批量执行SQL语句</h4><p>当需要成批插入或者更新记录时，可以采用 Java的<code>批量更新</code>机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率</p><p>JDBC的批量处理语句包括下面三个方法：</p><ul><li>addBatch(String)：添加需要批量处理的SQL语句或是参数；</li><li>executeBatch()：执行批量处理语句；</li><li>clearBatch():清空缓存的数据</li></ul><p>通常我们会遇到两种批量执行SQL语句的情况：</p><ul><li>多条SQL语句的批量处理；</li><li>一个SQL语句的批量传参；</li></ul><h4 id="高效的批量插入"><a href="#高效的批量插入" class="headerlink" title="高效的批量插入"></a>高效的批量插入</h4><p>举例：向数据表中插入20000条数据</p><ul><li><p>首先先创建一个goods表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE goods(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">`name` VARCHAR(25)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><p>下面是四种实现方式，效率逐渐提高，都是基于低层次实现的优化</p><ol><li><p>使用Statement</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//耗时：15006ms</span><br><span class="line">@Test</span><br><span class="line">    public void testInsert01() &#123;</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        Statement st = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            connection = JDBCUtil.getConnection();</span><br><span class="line">            st = connection.createStatement();</span><br><span class="line">            long start = System.currentTimeMillis();</span><br><span class="line">            for (int i = 1; i &lt;= 20000; i++) &#123;</span><br><span class="line">                String sql = &quot;insert into goods(name) values(&#x27;name_ &quot; + i + &quot;&#x27;)&quot;;</span><br><span class="line">                st.executeUpdate(sql);</span><br><span class="line">            &#125;</span><br><span class="line">            long end = System.currentTimeMillis();</span><br><span class="line">            System.out.println(&quot;耗时：&quot; + (end - start)  + &quot;ms&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            JDBCUtil.clossResource(connection, st);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>使用PreparedStatement</p><p>PreparedStatement优于Statement的地方：</p><ul><li>在于sql语句Statement内存中会有很多个sql语句，并且每次都会做一次语法检查，而PreparedStatement只有一个sql语句，每次只是填充占位符。（预编译）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void testInsert02()&#123;</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        PreparedStatement ps = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            String sql = &quot;insert into goods(name) values(?)&quot;;</span><br><span class="line">            connection = JDBCUtil.getConnection();</span><br><span class="line">            ps = connection.prepareStatement(sql);</span><br><span class="line">            long start = System.currentTimeMillis();</span><br><span class="line">            for (int i = 0; i &lt; 20000; i++) &#123;</span><br><span class="line">                ps.setObject(1, &quot;name_&quot; + i);</span><br><span class="line">            &#125;</span><br><span class="line">            long end = System.currentTimeMillis();</span><br><span class="line">            System.out.println(&quot;耗时：&quot; + (end - start) + &quot;ms&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            JDBCUtil.clossResource(connection, ps);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>相较于实现层次二的优点：</p><p>使用Batch批量处理：addBatch()、executeBatch()、clearBatch()</p><p>mysql服务器默认是关闭批处理的，我们需要通过一个参数，让mysql开启批处理的支持。在jdbc.properties配置文件的url后添上：?rewriteBatchedStatements&#x3D;true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//耗时：196ms</span><br><span class="line">@Test</span><br><span class="line">    public void testInsert03() &#123;</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        PreparedStatement ps = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            String sql = &quot;insert into goods(name) values(?)&quot;;</span><br><span class="line">            connection = JDBCUtil.getConnection();</span><br><span class="line">            ps = connection.prepareStatement(sql);</span><br><span class="line">            long start = System.currentTimeMillis();</span><br><span class="line">            for (int i = 0; i &lt; 20000; i++) &#123;</span><br><span class="line">                ps.setObject(1, &quot;name_&quot; + i);</span><br><span class="line">                //1.“攒”sql</span><br><span class="line">                ps.addBatch();</span><br><span class="line">                if (i % 10000 == 0)&#123;</span><br><span class="line">                    //2.执行</span><br><span class="line">                    ps.executeBatch();</span><br><span class="line">                    //3.清空</span><br><span class="line">                    ps.clearBatch();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            long end = System.currentTimeMillis();</span><br><span class="line">            System.out.println(&quot;耗时：&quot; + (end - start) + &quot;ms&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            JDBCUtil.clossResource(connection, ps);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><ul><li>每500条数据执行一次ps.executeBatch();</li><li>这样每500条就会提交一次。</li><li>但每次提交都会占用一点时间，所以先不提交，都传完以后，最后再提交。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//耗时：157ms</span><br><span class="line">@Test</span><br><span class="line">    public void testInsert04() &#123;</span><br><span class="line">        Connection connection = null;</span><br><span class="line">        PreparedStatement ps = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            String sql = &quot;insert into goods(name) values(?)&quot;;</span><br><span class="line">            connection = JDBCUtil.getConnection();</span><br><span class="line">            //1.设置为不自动提交数据</span><br><span class="line">            connection.setAutoCommit(false);</span><br><span class="line">            ps = connection.prepareStatement(sql);</span><br><span class="line">            long start = System.currentTimeMillis();</span><br><span class="line">            for (int i = 0; i &lt; 20000; i++) &#123;</span><br><span class="line">                ps.setObject(1, &quot;name_&quot; + i);</span><br><span class="line">                //1.“攒”sql</span><br><span class="line">                ps.addBatch();</span><br><span class="line">                if (i % 10000 == 0)&#123;</span><br><span class="line">                    //2.执行</span><br><span class="line">                    ps.executeBatch();</span><br><span class="line">                    //3.清空</span><br><span class="line">                    ps.clearBatch();</span><br><span class="line">            &#125;</span><br><span class="line">            //2.提交数据</span><br><span class="line">            connection.commit();</span><br><span class="line">            long end = System.currentTimeMillis();</span><br><span class="line">            System.out.println(&quot;耗时：&quot; + (end - start) + &quot;ms&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            JDBCUtil.clossResource(connection, ps);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="事务和批处理"><a href="#事务和批处理" class="headerlink" title="事务和批处理"></a>事务和批处理</h1><h2 id="数据库事务介绍"><a href="#数据库事务介绍" class="headerlink" title="数据库事务介绍"></a>数据库事务介绍</h2><p>事务：一组逻辑操作单元,使数据从一种状态变换到另一种状态。</p><p>事务处理（事务操作）：</p><p>保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交(<code>commit</code>)，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务回滚(<code>rollback</code>)到最初状态。</p><p>为确保数据库中数据的一致性，数据的操纵应当是离散的成组的逻辑单元：当它全部完成时，数据的一致性可以保持，而当这个单元中的一</p><h2 id="JDBC事务处理"><a href="#JDBC事务处理" class="headerlink" title="JDBC事务处理"></a>JDBC事务处理</h2><p>JDBC 程序中，当一个 <code>Connection</code> 对象创建时，默认情况下会自动提交事务。为了让多个 SQL 语句一体执行，需要使用事务。</p><p>哪些操作会导致数据的自动提交？</p><ul><li>DDL操作一旦执行，都会自动提交；<code>set autocommit = false</code>对操作失效；</li><li>DML默认情况下，一旦执行，就会自动提交；但我们可以通过<code>set autocommit = false</code>的方式取消DML操作的自动提交；</li><li>关闭连接的时候也会默认自动提交</li></ul><p>JDBC事务使用：</p><ol><li>JDBC程序中当一个Connection对象创建时，默认情况下是自动提交事务：每次执行一个SQL语句时，如果执行成功，就会向数据库自动提交，而不能回滚。</li><li>JDBC程序中为了让多个SQL语句作为一个整体执行，需要使用事务</li><li>调用 Connection 的 <code>setAutoCommit (false) </code>可以取消自动提交事务</li><li>在所有的SQL语句都成功执行后，调用 Connection 的 <code>commit() </code>方法提交事务</li><li>在其中某个操作失败或出现异常时，调用 rollback() 方法回滚事务</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    connection = JDBCUtils.getConnection();</span><br><span class="line">    connection.setAutoCommit(<span class="literal">false</span>);<span class="comment">//[1] 取消自动提交事务</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into actor values(9, &#x27;赫尔萝茵&#x27;)&quot;</span>;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line">    preparedStatement.executeUpdate();</span><br><span class="line">    sql = <span class="string">&quot;delete from actor where name = &#x27;萝茵&#x27; and id &gt; (select * from (select min(id) from actor where name = &#x27;萝茵&#x27;) a)&quot;</span>;</span><br><span class="line">    <span class="comment">//[2]</span></span><br><span class="line">    preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">    preparedStatement.executeUpdate();</span><br><span class="line">    connection.commit();<span class="comment">//[3] 提交事务</span></span><br><span class="line">    System.out.println(<span class="string">&quot;complete&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;fail&quot;</span>);</span><br><span class="line">    System.out.println(e);</span><br><span class="line">    connection.rollback();<span class="comment">//[4] 回滚事务</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    connection.close();<span class="comment">//[5] 关闭连接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码详解：</p><ol><li><p>取消自动提交事务：<code>connection.setAutoCommit(false);</code></p></li><li><p>这是一个 SQL 语句。表示在 name &#x3D; 萝茵 的数据中只保留 id 最小的一条。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from actor where name = &#x27;萝茵&#x27; and id &gt; (select * from (select min(id) from actor where name = &#x27;萝茵&#x27;) a)</span><br></pre></td></tr></table></figure><p>正常写法会提示不能同表查询（在 MySQL 中，不能在同一语句中先 select 出同一表中的某些值，再 update 这个表）。使用一个额外的 select 过渡就解决了这个问题。特此记录。</p></li><li><p>提交事务：<code>connection.commit();</code></p></li><li><p>回滚事务：<code>connection.rollback();</code></p><p>写在 catch 里。这样，语句错误抛出异常的场合会执行到这句话。</p></li><li><p>关闭连接：<code>connection.close();</code></p><p>写在 finally 里。这样，执行完语句总会关闭连接。这很好。</p></li></ol><h2 id="在Java代码中设置隔离级别"><a href="#在Java代码中设置隔离级别" class="headerlink" title="在Java代码中设置隔离级别"></a>在Java代码中设置隔离级别</h2><p>使用getTransactionIsolation()可以获得当前隔离级别的int值，对应如下</p><ul><li>int TRANSACTION_READ_UNCOMMITTED &#x3D; 1;</li><li>int TRANSACTION_READ_COMMITTED &#x3D; 2;</li><li>int TRANSACTION_REPEATABLE_READ &#x3D; 4;</li><li>int TRANSACTION_SERIALIZABLE &#x3D; 8;</li></ul><p>使用setTransactionIsolation可以设置隔离级别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTransactionUpdate</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> JDBCUtil.getConnection();</span><br><span class="line">    <span class="comment">//获取数据库隔离级别</span></span><br><span class="line">    System.out.println(connection.getTransactionIsolation());</span><br><span class="line">    <span class="comment">//设置数据库隔离级别</span></span><br><span class="line">    connection.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update user_table set balance = ? where user = ?&quot;</span>;</span><br><span class="line">    update(sql,<span class="number">5000</span>,<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;修改结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><p>批处理：把多条语句一次性提交给数据库进行批量处理。这样做比单独提交更有效率。</p><p>基本介绍：</p><ol><li><p>当需要成批插入或者更新记录时。可以采用Java的批量更新机制，这一机制允</p></li><li><p>许多条语句次性提交给数据库批量处理。通常情况下比单独提交处理更有效率。</p></li><li><p>JDBC的批量处理语句包括下面方法:</p><p>addBatch(:添加需要批量处理的SQL语句或参数</p><p>executeBatch(:执行批量处理语句;</p><p>clearBatch():清空批处理包的语句</p></li><li><p>JDBC连接MySQL时，如果要使用批处理功能，请再url中加参数?rewriteBatchedStatements&#x3D; true</p></li><li><p>批处理往往和PreparedStatement-起搭配使用，可以既减少编译次数，又减少运行次数，效率大大提高</p></li></ol> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[0] 事前准备</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> JDBCUtils.getConnection();</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into test1 values(?)&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">ps.setInt(<span class="number">1</span>,i);</span><br><span class="line">ps.addBatch();<span class="comment">//[1]</span></span><br><span class="line">&#125;</span><br><span class="line">ps.executeBatch();<span class="comment">//[2]</span></span><br><span class="line">JDBCUtils.close(connection, ps, <span class="literal">null</span>);JAVA</span><br></pre></td></tr></table></figure><ol><li><p>修改配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true</span></span><br></pre></td></tr></table></figure></li><li><p>添加需要批量处理的 SQL 语句</p><p><code>preparedStatement.addBatch()</code></p></li><li><p>执行批量处理语句</p><p><code>preparedStatement.executeBatch()</code></p></li><li><p>（前面的例子里没有这句）清空批处理包的语句</p><p><code>preparedStatement.clearBatch()</code></p></li></ol><h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h1><p><strong>传统获取 Connection 方法的问题：</strong></p><ol><li>传统的 JDBC 数据库连接使用 DriverManager 获取，每次建立连接都会把 Connection 载入内存，再进行身份验证。每次连接都会重复验证请求，这样会占用过多系统资源，容易造成服务器崩溃。</li><li>每次连接，使用完毕后必须断开。如果不断开操作，会致使数据库内存泄漏，最终不得不重启数据库。</li><li>传统连接方式不能控制创建的连接数量。连接数量过多的场合，也可能导致内存泄漏，MySQL 崩溃</li></ol><p><strong>因此，需要使用连接池技术</strong></p><p>连接池基本介绍：</p><ol><li>预先在缓冲池放入一定数量的连接。需要建立数据库连接时，从缓冲池中取出一个连接。使用完后，把该连接放回缓冲池。</li><li>数据库连接池负责分配、管理和释放数据库连接。其允许应用程序重复使用一个现有的数据库连接，而非建立新的连接。</li><li>当请求连接的数量超过最大数量，这些连接请求会被加入等待队列。</li></ol><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310151731041.png"></p><p><strong>数据库连接池种类：</strong></p><p>JDBC 数据库连接池使用 javax.sql.DataSource 表示。DataSource 是一个接口，通常由第三方提供实现（提供 jar 包）</p><ul><li>C3P0：速度稍慢，稳定性好，但是速度再慢也不是传统 JDBC 能比得上的</li><li>DBCP：速度稍快，稳定性差</li><li>Proxool：可以监控连接池状态，稳定性稍差</li><li>BoneCP：速度快</li><li>Druid：阿里提供的数据库连接池，集 DBCP、C3P0、Proxool 优点于一身</li></ul><p>数据库连接池只是做了个包装，底层还是需要使用到 driver 驱动</p><h2 id="德鲁伊使用"><a href="#德鲁伊使用" class="headerlink" title="德鲁伊使用"></a>德鲁伊使用</h2><h3 id="前置工作"><a href="#前置工作" class="headerlink" title="前置工作"></a>前置工作</h3><ol><li><p><a href="https://github.com/alibaba/druid">Druid jar 包下载</a>。这个链接打不开的话，试试 <a href="https://repo1.maven.org/maven2/com/alibaba/druid/">这个</a></p></li><li><p>配置 jar 包</p></li><li><p>加入配置文件</p><p><strong>durid.properties：</strong>配置文件，文件名任意，放在 <code>src/druid.properties</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">minIdle</span>=<span class="string">5</span></span><br><span class="line"><span class="attr">maxActive</span>=<span class="string">20</span></span><br><span class="line"><span class="attr">maxWait</span>=<span class="string">5000</span></span><br></pre></td></tr></table></figure><p>minIdle：最小空闲数，一直没有人用的时候至少维持这么多个链接<br>maxActive：最大活跃数，使用链接的上限<br>maxWait：最大等待时间，超过这个时间认为繁忙，放弃这次链接，换下一个</p></li></ol><h3 id="使用Druid"><a href="#使用Druid" class="headerlink" title="使用Druid"></a>使用Druid</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* [1] 加载配置文件 */</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\Druid.properties&quot;</span>));</span><br><span class="line"><span class="comment">/* [2] 初始化数据池 */</span></span><br><span class="line"><span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line"><span class="comment">/* [3] 获取连接 */</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">...</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure><ol><li><p>初始化数据池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(properties);</span><br></pre></td></tr></table></figure></li><li><p>初始化数据池：需要讲一下关闭链接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection.close();</span><br></pre></td></tr></table></figure><p><code>Connection</code> 是一个接口，对于方法 <code>close()</code>，不同供应商有不同实现方法。</p><p>原生的 <code>MySQL</code> 的实现方法是关闭连接，而这些连接池的实现方法是<strong>取消引用（放回连接池）</strong>。</p></li></ol><h2 id="DruidUtils"><a href="#DruidUtils" class="headerlink" title="DruidUtils"></a>DruidUtils</h2><p>Druid的工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCUtilsByDruid</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource ds;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在静态代码块完成 ds初始化</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\druid.properties&quot;</span>));</span><br><span class="line">            ds = DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写getConnection方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> ds.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭连接, 老师再次强调： 在数据库连接池技术中，close 不是真的断掉连接</span></span><br><span class="line">    <span class="comment">//而是把使用的Connection对象放回连接池</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(ResultSet resultSet, Statement statement, Connection connection)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (resultSet != <span class="literal">null</span>) &#123;</span><br><span class="line">                resultSet.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (statement != <span class="literal">null</span>) &#123;</span><br><span class="line">                statement.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="literal">null</span>) &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Apache-DbUtils"><a href="#Apache-DbUtils" class="headerlink" title="Apache - DbUtils"></a>Apache - DbUtils</h1><p>JDBC 传统方法的不足：</p><ol><li>结果集和连接是关联的。在连接关闭后，就不能使用结果集。</li><li>结果集只能使用一次，这样不便于数据管理</li><li>使用返回信息不方便</li></ol><p>解决思想：</p><ul><li><p>土方法：创建一个类，其属性与表格的列一一对应。将数据遍历并读取到一个个类对象中，再将这些类对象放置到集合中。这样，就得到了一个与表格数据关联的数据集合。</p></li><li><p>使用 <code>DbUtils</code>：</p><ol><li><p>前置操作：</p><p><a href="https://commons.apache.org/proper/commons-dbutils/download_dbutils.cgi">获取 jar 包</a>，并完成配置</p><p>得到连接 <code>Connection connection</code>，创建数据类（这里是 <code>SQL_Data</code>）</p></li><li><p>执行相关方法，返回结果集</p><ol><li><ul><li><p><code>queryRunner.query</code> 方法：执行 SQL 语句，把得到的 <code>ResultSet</code> 封装到 List 集合。这个方法会自动关闭获得的 <code>ResultSet</code>，所以不会造成资源泄漏</p></li><li><p><code>connection</code>：前置操作中得到的连接</p></li><li><p><code>sql</code>：SQL 语句</p></li><li><p><code>new BeanListHander&lt;&gt;(SQL_Data.class)</code>：利用反射机制，将数据封装到 <code>SQL_Data</code> 对象中</p></li><li><p><code>&quot;id&quot;, 1</code>：给 SQL 语句中的 <code>?</code> 赋值。因为是可变参数，可以写多个，如：<code>queryRunner.query(connection, sql, new BeanListHandler&lt;&gt;(SQL_Data.class), &quot;id&quot;, 1, &quot;name&quot;, &quot;识之律者&quot;);</code></p><p>……这里，可变参数也包含列名的场合，筛选似乎会失效。还不知道原理。特此记录。</p></li></ul></li><li><p>此时只需要关闭 <code>Connection</code></p><p><code>query()</code> 方法已经关闭了 <code>ResultSet</code> 和 <code>PreparedStatement</code></p></li></ol></li></ol></li></ul><p><code>commons-DbUtils</code>：是 Apache 组织提供的一个开源的 JDBC 工具库。它是对 JDBC 的封装。使用 dbutils 能极大简化 JDBC 编码的工作量</p><p><strong>DbUtils 的常用类：</strong></p><ul><li><code>QueryRunner</code> 类：封装了 SQL 的执行。是线程安全的，可以实现增、删、改、查、批处理操作</li><li><code>ResultSetHandler</code> 接口：用于处理 <code>ResultSet</code>，按照需求将数据转化为其他形式</li></ul><p><strong>DbUtils 的常用方法：</strong></p><ul><li>ArrayHandler：把结果集中的第一行数据转成对象数组。</li><li>ArrayListHandler：把结果集中的每一-行数据都转成一 个数组，再存放到List中。</li><li>BeanHandler：将结果集中的第一-行数据封装到- 个对应的JavaBean实例中。</li><li>BeanListHandler：将结果集中的每一行数据都封装到一 个对应的JavaBean实例中，存放到List里。</li><li>ColumnListHandler：将结果集中某一列的数据存放到List中。</li><li>KeyedHandler(name)：将结果集中的每行数据都封装到Map里，再把这些map再存到一个map里，其key为指定的key。</li><li>MapHandler：将结果集中的第一行数据封装到一 个Map里，key是列名， value就是对应的值。</li><li>MapListHandler：将结果集中的每一-行数据都封装到一 个Map里，然后再存放到List</li></ul><h2 id="Apache-DbUtils-常用方法"><a href="#Apache-DbUtils-常用方法" class="headerlink" title="Apache-DbUtils 常用方法"></a>Apache-DbUtils 常用方法</h2><ul><li><p><code>queryRunner.update(connection, sql, ...)</code>：DML 语句。增删改。</p><p>后面传入可变参数，用于给 SQL 语句中的 <code>?</code> 赋值</p><p>返回值 int 代表被影响的行数。</p></li><li><p><code>queryRunner.query(connection, sql, ResultSetHandler, ...)</code>：查询。</p><p>后面传入可变参数，用于给 SQL 语句中的 <code>?</code> 赋值</p><p>关于 <code>ResultSetHandler</code>：</p><ul><li>传入 <code>new BeanListHander&lt;&gt;(SQL_Data.class)</code>：返回多行多列。这个场合，用 <code>List</code> 接收返回值。</li><li>传入 <code>new BeanHandler&lt;&gt;(SQL_Data.class)</code>：返回单行。这个场合，用 <code>SQL_Data data</code> 接收返回值。</li><li>传入 <code>new ScalarHander&lt;&gt;()</code>：返回单行单列。这个场合，用 <code>Object</code> 接收返回值。</li></ul></li></ul><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310151935013.png"></p><h2 id="表和-JavaBean-的对应关系"><a href="#表和-JavaBean-的对应关系" class="headerlink" title="表和 JavaBean 的对应关系"></a>表和 JavaBean 的对应关系</h2><table><thead><tr><th>表类型</th><th>JavaBean类型</th></tr></thead><tbody><tr><td>int、samllint……</td><td>Integer</td></tr><tr><td>char、varchar……</td><td>String</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>date</td><td>java.util.Date</td></tr></tbody></table><h1 id="BasicDao"><a href="#BasicDao" class="headerlink" title="BasicDao"></a>BasicDao</h1><p>apache- dbutils + Druid简化了JDBC开发，但还有不足:</p><ol><li>SQL语句是固定，不能通过参数传入，通用性不好，需要进行改进，更方便执行增删改查</li><li>对于select操作，如果有返回值，返回类型不能固定，<br> 需要使用泛型</li><li>将来的表很多，业务需求复杂，不可能只靠一个Java类完成</li></ol><p>将这些表的公共部分抽出，集成为BasicDao</p><p>DAO：数据访问对象（data access object）</p><ol><li><p>我们把通用的和数据库交互的操作封装到一个通用类中，称为 BasicDAO。</p></li><li><p>在 BasicDAO 基础上，每张表对应一个特化的 DAO（继承 BasicDAO），从而更好地完成功能。</p><p>比如：Data 表 -&gt; Data.java 类（JavaBean）-&gt; DataDAO.java</p></li></ol><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202310152122800.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-异常</title>
      <link href="/2023/06/02/Java10%E5%BC%82%E5%B8%B8/"/>
      <url>/2023/06/02/Java10%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>在 Java 语言中，将程序执行中发生的不正常情况称为 “异常”（开发过程中的语法错误和逻辑错误不是异常）</p><p>这些 异常事件 可分为两类：</p><ol><li><p>Error（错误）：Java 虚拟机无法解决的严重问题。</p><p>如：JVM 系统内部错误，资源耗尽等严重情况。Error 是严重错误，程序会崩溃。</p></li><li><p>Exception（异常）：其他因编程错误或偶然的外部因素导致的一般性问题，可以使用针对性的代码进行处理。</p><p>如：空指针访问，试图读取不存在的文件，网络中断等等。</p><p>Exception 又分为两大类：</p><ul><li>运行时异常（程序运行时，发生的异常）</li><li>编译时异常（编程时，编译器检查出的异常，会爆红）</li></ul></li></ol><h2 id="异常体系图"><a href="#异常体系图" class="headerlink" title="异常体系图"></a>异常体系图</h2><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/%25E5%25BC%2582%25E5%25B8%25B8%25E4%25BD%2593%25E7%25B3%25BB%25E5%259B%25BE_11.1.webp"></p><p>异常分为两大类：运行时异常 和 编译时异常</p><ul><li><p>运行时异常，编译器不要求强制处置的异常。一般是指编程的逻辑错误，是程序员应该避免其出现的异常。</p><p>java.lang.RuntimeException 类及它的子类都是运行时异常</p><p>对于运行时异常，可以不做处理。因为这类异常很普遍，若全处理会对程序的可读性和运行效率产生影响</p></li><li><p>编译时异常，是编译器要求必须处置的异常</p></li></ul><h2 id="常见的运行时异常"><a href="#常见的运行时异常" class="headerlink" title="常见的运行时异常"></a>常见的运行时异常</h2><p>常见的运行时异常（RuntimeException）包括</p><ol><li><p>NullPointerException：空指针异常</p><ul><li><p>当应用程序试图在需要对象的地方使用 null 时，抛出该异常</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = null;</span><br><span class="line">int n = str.length;//这里，出现了 空指针异常</span><br></pre></td></tr></table></figure></li></ul></li><li><p>ArithmeticException：数学运算异常</p><ul><li><p>当出现异常的运算条件时，抛出该异常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double n = 100 / 0;//这里，出现了 数学运算异常</span><br></pre></td></tr></table></figure></li></ul></li><li><p>ArrayIndexOutOfBoundsException：数组下标越界异常</p><ul><li><p>用非法索引（为负或超出范围）访问数组时，抛出该异常</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] nums = &#123;0, 0, 0, 0&#125;;</span><br><span class="line">nums[-50] = 100;//这里，出现了 数组下标越界异常</span><br></pre></td></tr></table></figure></li></ul></li><li><p>ClassCastException：类型转换异常</p><ul><li><p>当试图把对象强制转换为不是实例的子类时，抛出该异常</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Example &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        A a1 = new A1();</span><br><span class="line">        A2 a1 = (A2)a1;//这里，出现了 类型转换异常</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class A &#123;&#125;</span><br><span class="line">class A1 extends A &#123;&#125;</span><br><span class="line">class A2 extends A &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>NumberFormatException：数学格式异常</p><ul><li><p>当应用程序试图将字符串转成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;ABC&quot;;</span><br><span class="line">int num = Integer.parseInt(str);//这里，出现了 数字格式不正确异常</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="常见的编译异常"><a href="#常见的编译异常" class="headerlink" title="常见的编译异常"></a>常见的编译异常</h2><p>常见的编译异常：一般发生在网络、文件、数据库操作中。</p><ul><li>SQLException：操作数据库时，查询表可能发生异常</li><li>IOException：操作文件时，发生的异常</li><li>FileNotFoundException：操作一个不存在的文件时，发生的异常</li><li>ClassNotFoundException：加载类，而该类不存在时，发生的异常</li><li>EOFException：操作文件，到文档末尾，发生的异常</li><li>IllegalArguementException：参数异常</li></ul><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>异常发生时，对异常的处理方式。如果没有显式异常处理，默认处理方式是 <code>throws</code></p><blockquote><ul><li><code>try - chatch - finally</code>：程序员在代码中捕获发生的异常，自行处理</li><li><code>throws</code>：将发生的异常抛出，交给调用者（方法）来处理。最顶级的处理者就是 JVM</li></ul></blockquote><h2 id="try-chatch-finally"><a href="#try-chatch-finally" class="headerlink" title="try - chatch - finally"></a>try - chatch - finally</h2><p>Java 提供 try 和 catch 块 来处理异常。try 块用于包含可能出错的代码，catch 块用于处理 try 块中的异常。可以根据需要在程序中有多个 <code>try - catch</code> 块。</p><p>基本语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">//可疑代码</span><br><span class="line">//将异常生成对应的异常对象，传递给 catch 块</span><br><span class="line">&#125; catch(Exception e) &#123;</span><br><span class="line">//如果发生异常，执行这些代码</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    //无论是否异常，都执行这些代码</span><br><span class="line">    //finally 块可以不写</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h4><ol><li><p>如果异常发生了，则异常发生后面的代码块都不执行，直接进入 catch 块</p></li><li><p>如果异常未发生，则顺序执行 try 代码块，catch 块不执行</p></li><li><p>如果希望不管是否异常，都执行一些代码，则使用 finally</p></li><li><p>可以有多个 catch 捕获不同的异常。要求 子类异常在前，父类异常在后。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">...</span><br><span class="line">&#125; catch (NullPointerException e) &#123;</span><br><span class="line">...</span><br><span class="line">&#125; catch (ArithmeticException e) &#123;</span><br><span class="line">...</span><br><span class="line">&#125; catch (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">...</span><br><span class="line">&#125; catch (Exception e)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以进行 try - finally 配合使用（不写 catch）。这种用法相当于没有捕获异常，此时程序如果出错会直接退出。</p><p>应用场景，就是写一段代码，不管是否发生异常，都必须执行某个业务逻辑。</p></li><li><p>如果没有出现异常，执行 try 中所有语句，不执行 catch 语句，最后执行 finally 语句</p></li><li><p>如果出现异常，则 try 块异常发生后，剩余语句不执行。之后执行 catch 语句，最后，执行 finally 语句。</p></li></ol><p>例子：如果用户输入的不是一个整数，就提示他反复输入，直到输入一个整数为止</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package org.example;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        int num;</span><br><span class="line">        String str = new String();</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            System.out.println(&quot;请输入&quot;);</span><br><span class="line">            str = scanner.next();</span><br><span class="line">            try&#123;</span><br><span class="line">                num = Integer.parseInt(str);</span><br><span class="line">                break;</span><br><span class="line">            &#125;catch (NumberFormatException e)&#123;</span><br><span class="line">                System.out.println(&quot;warring&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h2><p>如果一个方法可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显式地声明抛出异常，表明该方法将不对这些异常进行处理，而由调用者负责处理</p><p>在方法中声明 <code>throws</code> 语句可以声明抛出异常的列表。<code>throws</code> 后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void metord() throws FileNontFoundException ,NullPointerException &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309181432554.png"></p><blockquote><p>除了JVM层，每一层都能选择使用try还是throws，到JVM就直接报红错误。</p><p>下面层中，每一层二选一处理。</p></blockquote><p>使用细节：</p><ol><li>对于 <strong>编译异常</strong>，程序中必须处理。</li><li>对于 <strong>运行异常</strong>，程序中诺没有处理，默认处理是 <code>throws</code></li><li>子类 重写 父类方法时，子类方法抛出的异常类型必须和父类一致，或者是父类抛出异常类型的子类型。</li><li>如果有 <code>try - catch</code> 就不必 <code>throws</code> 了</li></ol><h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><p>当程序中出现了某些 “错误”，但该信息并未在 <code>Throwable</code> 子类中描述处理，这时候可以自己设计异常类，用于描述该错误信息</p><p>过程：</p><ol><li>定义类：自定义异常类名，继承 RuntimeException 或 Exception</li><li>如果继承 Exception，属于 编译异常。</li><li>如果继承 RuntimeException，属于 运行异常。（一般来说，选这个。这样利用了默认处理机制throws，更方便）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Metords &#123;</span><br><span class="line">   public void method() &#123;</span><br><span class="line">       int n = 10;</span><br><span class="line">       if(n &gt; 100)&#123;</span><br><span class="line">           throw new CustomException(&quot;不能大于100&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CustomException extends RuntimeException &#123;</span><br><span class="line">public CustomException(String message) &#123;</span><br><span class="line">super(message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="throw-和-throws"><a href="#throw-和-throws" class="headerlink" title="throw 和 throws"></a>throw 和 throws</h1><table><thead><tr><th></th><th>意义</th><th>位置</th><th>后面跟的东西</th></tr></thead><tbody><tr><td><code>throws</code></td><td>异常处理的一种方式</td><td>方法声明时</td><td>异常类型</td></tr><tr><td><code>throw</code></td><td>手动生成异常对象关键字</td><td>方法体中</td><td>异常对象</td></tr></tbody></table><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="编程小技巧编写异常时，先确定正确的情况，然后取反。这样写，你的思路就不乱。"><a href="#编程小技巧编写异常时，先确定正确的情况，然后取反。这样写，你的思路就不乱。" class="headerlink" title="编程小技巧编写异常时，先确定正确的情况，然后取反。这样写，你的思路就不乱。"></a>编程小技巧编写异常时，先确定正确的情况，然后取反。这样写，你的思路就不乱。</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-字符串</title>
      <link href="/2023/05/31/Java09%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2023/05/31/Java09%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h1><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309171056678.png"></p><ol><li><p><code>String</code> 对象用于保存字符串，也就是一组字符序列</p></li><li><p>字符串常量对象是用双引号扩起的字符序列。例如 <code>&quot;你好&quot;</code></p></li><li><p>字符串的字符使用 Unicode 字符编码。一个字符（不论字母汉字）占 2 字节</p></li><li><p>常用构造器：</p><ul><li><p><code>String str1 = new String();</code></p></li><li><p><code>String str2 = new String(String original);</code></p></li><li><p><code>String str3 = new String(char[] a);</code></p></li><li><p><code>String str4 = new String(char[] a, int startIndex, int count);</code></p><p>这句意思是：<code>char[]</code> 从 <code>startIndex</code> 起的 <code>count</code> 个字符</p></li></ul></li><li><p><code>String</code> 实现了接口 <code>Serializable</code> 和 <code>Comparable</code> ，可以 串行化和 比较大小</p><blockquote><p><strong>串行化：即，可以被网络传输，也能保存到文件</strong></p></blockquote></li><li><p><code>String</code> 是 <code>final</code> 类，不能被继承</p></li><li><p><code>String</code> 有属性 <code>private final char[] value;</code> 用于存放字符串内容。</p><p><code>value</code> 是 <code>final</code> 属性。其在栈中的地址不能修改，但内容可以修改</p></li></ol><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309171101558.png"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309171103557.png"></p><h2 id="String创建对象"><a href="#String创建对象" class="headerlink" title="String创建对象"></a>String创建对象</h2><p>两种创建String对象的区别（JVM中有讲解）</p><ol><li><p>直接赋值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;你干嘛，哎呦~&quot;</span><br></pre></td></tr></table></figure><p>方式一：先从常量池查看是否有**”你干嘛，哎呦~”**数据空间，如果有，直接指向；如果没有则重新创建，然后指向。s最终指向的是常量池的空间地址</p></li><li><p>调用构造器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str1 = new String();</span><br></pre></td></tr></table></figure><p>方式二：先在堆中创建空间，里面维护了value属性，指向常量池的**”你干嘛，哎呦<del>“<strong>空间。如果常量池没有</strong>“你干嘛，哎呦</del>“**，重新创建，如果有，直接通过value指向。 最终指向的是堆中的空间地址。</p></li></ol><h3 id="画出两种方式的内存分布图"><a href="#画出两种方式的内存分布图" class="headerlink" title="画出两种方式的内存分布图"></a>画出两种方式的内存分布图</h3><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309180850664.png"></p><h3 id="String对象比较"><a href="#String对象比较" class="headerlink" title="String对象比较"></a>String对象比较</h3><blockquote><p>JVM中有一部分讲这个的，比Java部分的更加全面</p></blockquote><p>引用类型怎么比较？默认比较地址，重写方法可能比较内容。</p><ol><li><p>**&#x3D;&#x3D;**：比较二者的地址，内容不一样的话肯定不一样。内容一样的话如果都是new的，由于new的特性，也不一样。</p></li><li><p>equals：String中重写了方法，比较的是值是否相同，区分大小写。</p></li><li><p>常量相加比较：由于构造器自身优化，池会自动创建一个相加后的常量</p></li><li><p>变量相加比较：是在堆中调用Stringbuilder类通过append和toString方法生成一个新对象，二者不一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb = new StringBuilder();</span><br><span class="line">sb.append(a);</span><br><span class="line">sb.append(b);</span><br><span class="line">str2 = sb.toString();//sb.toString()：return new String(value, 0, count);</span><br></pre></td></tr></table></figure></li></ol><h2 id="String对象特性"><a href="#String对象特性" class="headerlink" title="String对象特性"></a>String对象特性</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String e = &quot;你干嘛&quot; + &quot;哎呦&quot;;//创建了几个对象？</span><br></pre></td></tr></table></figure><p>1个：由于构造器自身优化，池会自动创建一个相加后的常量，相当于直接 e &#x3D; “你干嘛哎呦”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String a = &quot;你干嘛&quot;; //创建 a对象</span><br><span class="line">String b = &quot;哎呦&quot;;//创建 b对象</span><br><span class="line"> String c = a + b;</span><br></pre></td></tr></table></figure><p>3个：</p><ol><li>先 创建一个 StringBuilder sb &#x3D; StringBuilder()</li><li>执行  sb.append(“你干嘛”);</li><li>sb.append(“哎呦”);</li><li>String c&#x3D; sb.toString()<br>最后其实是 c 指向堆中的对象(String) value[] -&gt; 池中 “你干嘛哎呦”</li></ol><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309180941489.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String a = &quot;hello&quot;; //创建 a对象</span><br><span class="line">String b = &quot;abc&quot;;//创建 b对象</span><br><span class="line">String c = a + b;//e指向堆</span><br><span class="line">String d = &quot;helloabc&quot;;</span><br><span class="line">System.out.println(c == d);//真还是假? 是false</span><br><span class="line">String e = &quot;hello&quot; + &quot;abc&quot;;//直接看池， e指向常量池</span><br><span class="line">System.out.println(d == e);//真还是假? 是true</span><br></pre></td></tr></table></figure><h2 id="String-的常用方法"><a href="#String-的常用方法" class="headerlink" title="String 的常用方法"></a>String 的常用方法</h2><p>以下方法不需死记硬背，手熟自然牢记</p><ul><li><p><code>boolean equals(String s)</code>：区分大小写，判断内容是否相等</p><p><code>boolean equalsIgnoreCase(String s)</code>：判断内容是否相等（忽略大小写）</p></li><li><p><code>boolean empty()</code>：返回是否为空</p></li><li><p><code>int charAt(int index)</code>：获取某索引处的字符（代码单元）。</p><p>必须用 <code>char c = str.charAt(15);</code>，不能用 <code>char c = str[15];</code></p><p><code>int codePointAt(int index)</code></p><p><code>int length()</code>：获取字符（<strong>代码单元</strong>）的个数</p><p><code>IntStream codePoints()</code>：返回字符串中全部码点构成的流</p><p><code>long codePoints().count()</code>：返回真正长度（码点数量）</p></li><li><p><code>int indexOf(String str)</code>：获取字符（串）在字符串中第一次出现的索引。如果找不到，返回 -1</p><p><code>int indexOf(int char)</code> 参数也可以传入一个 int。由于自动类型转换的存在，也能填入 char</p><p><code>int indexOf(String str, int index)</code>：从 index 处（包含）开始查找指定字符（串）</p><p><code>int lastIndexOf(String str)</code>：获取字符在字符串中最后一次出现的索引。如果找不到，返回 -1</p></li><li><p><code>String substring(int start, int end)</code>：返回截取指定范围 [start, end) 的 <strong>新</strong> 字符串</p><p><code>String substring(int index)</code>：截取 index（包含）之后的部分</p></li><li><p><code>String trim()</code>：返回去前后空格的新字符串</p></li><li><p><code>String toUperCase()</code>：返回字母全部转为大写的新字符串</p><p><code>String toLowerCase()</code>：返回字母全部转为小写的新字符串</p></li><li><p><code>String concat(String another)</code>：返回拼接字符串</p></li><li><p><code>String replace(char oldChar, char newChar)</code>：替换字符串中的元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;Foolish cultists&quot;;</span><br><span class="line">String str2 = str1.replace(&quot;cultists&quot;, &quot;believers&quot;);//str1不变，str2为改变的值JAVA</span><br></pre></td></tr></table></figure></li><li><p><code>String[] split(String regex)</code>：分割字符串。</p><p>对于某些分割字符，我们需要转义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;aaa,bbb,ccc&quot;;</span><br><span class="line">String[] strs1 = str1.split(&quot;,&quot;);//这个场合，strs = &#123;&quot;aaa&quot;, &quot;bbb&quot;, &quot;ccc&quot;&#125;;4</span><br><span class="line">String str2 = &quot;aaa\bbb\ccc&quot;;</span><br><span class="line">String[] strs2 = str2.split(&quot;\\&quot;);//&quot;\&quot; 是特殊字符，需要转义为 &quot;\\&quot;JAVA</span><br></pre></td></tr></table></figure></li><li><p><code>int compareTo(String another)</code>：按照字典顺序比较两个字符串（的大小）。</p><p>返回出现第一处不同的字符的编号差。前面字符相同，长度不同的场合，返回那个长度差。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;ccc&quot;;</span><br><span class="line">String str2 = &quot;ca&quot;;</span><br><span class="line">String str3 = &quot;ccc111abc&quot;;</span><br><span class="line">int n1 = str1.compareTo(str2);//此时 n1 = &#x27;c&#x27; - &#x27;a&#x27; = 2</span><br><span class="line">int n2 = str1.compareTo(str3);//此时 n2 = str1,length - str3.length = -6</span><br><span class="line">int n3 = str1.compareTo(str1);//此时 n3 = 0JAVA</span><br></pre></td></tr></table></figure></li><li><p><code>char[] toCharArray()</code>：转换成字符数组</p><p><code>byte[] getBytes()</code>：字符串转为字节数组</p></li><li><p><code>String String.format(String format, Object... args)</code>：（静态方法）格式字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String name = &quot;Roin&quot;;</span><br><span class="line">String age = &quot;1M&quot;;</span><br><span class="line">String state = &quot;computer&quot;;</span><br><span class="line">String formatStr = &quot;I am %s, I am %s old, I am a %s&quot;;</span><br><span class="line">String str = String.format(formatStr, name, age, state);</span><br><span class="line">//其中 %s 是占位符。此时，str = &quot;I am Roin, I am 1M old, I am a computer&quot;;</span><br><span class="line">//%s 表示字符串替换；%d 表示整数替换；#.2f 表示小数（四舍五入保留2位）替换；%c 表示字符替换JAVA</span><br></pre></td></tr></table></figure></li><li><p><code>String join(deli, ele...)</code>：拼接字符串（<code>ele...</code>），以 <code>deli</code> 间隔。</p></li><li><p><code>boolean startsWith(str)</code>：测试 str 是否为当前字符串的前缀</p></li><li><p><code>String repeat(int n)</code>：返回该字符串重复 n 次的结果</p></li></ul><h1 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h1><p>StringBuffer代表可变的字符序列。可以对字符串内容进行增删。</p><p>很多方法和 String 相同，但 StringBuffer 是可变长度。同时，StringBuffer 是一个容器</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309180952088.png"></p><ol><li><code>StringBuffer</code> 的直接父类是 <code>AbstractStringBuffer</code></li><li><code>StringBuffer</code> 实现了 <code>Serialiazable</code>，可以串行化</li><li>在父类中，<code>AbstractStringBuffer</code> 有属性 <code>char[] value</code> 不是 <code>final</code></li><li><code>StringBuffer</code> 是一个 <code>final</code> 类，不能被继承</li><li>StringBuffer的字符内容存放在char[] value中，不用每次都更换地址(不是每次创建新对象)，所以效率高于 String</li></ol><h2 id="String-对比-StringBuffer"><a href="#String-对比-StringBuffer" class="headerlink" title="String 对比 StringBuffer"></a>String 对比 StringBuffer</h2><ul><li><code>String</code> 保存字符串常量，其中的值不能更改。每次更新实际上是更改地址，效率较低</li><li><code>StringBuffer</code> 保存字符串变量，里面的值可以更改。每次更新是更新内容，不用每次更新地址</li></ul><h2 id="StringBuffer-构造方法"><a href="#StringBuffer-构造方法" class="headerlink" title="StringBuffer 构造方法"></a>StringBuffer 构造方法</h2><ol><li><p>无参构造</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer strb1 = new StringBuffer();</span><br></pre></td></tr></table></figure><blockquote><p>创造一个 16 位容量（默认容量）的空 <code>StringBuffer</code></p></blockquote></li><li><p>传入字符串构造</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;abcabc&quot;;</span><br><span class="line">StringBuffer strb2 = new StringBuffer(str1);</span><br></pre></td></tr></table></figure><blockquote><p>（上例）创造一个 str1.length + 16 容量的 <code>StringBuffer</code></p></blockquote></li><li><p>指定容量构造</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer strb3 = new StringBuffer(3);</span><br></pre></td></tr></table></figure><blockquote><p>（上例）创造一个 3 容量的空 <code>StringBuffer</code></p></blockquote></li></ol><h2 id="String-和-StringBuffer的转换"><a href="#String-和-StringBuffer的转换" class="headerlink" title="String 和 StringBuffer的转换"></a>String 和 StringBuffer的转换</h2><ol><li><p>转 StringBuffer</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;abcabc&quot;;</span><br><span class="line">StringBuffer strb1 = new StringBuffer(str1);//方法1（构造器）</span><br><span class="line">StringBuffer strb1 = new StringBuffer();</span><br><span class="line">strb1 = strb1.append(str1);//方法2（先空再append）</span><br></pre></td></tr></table></figure></li><li><p>转 String</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str2 = strb1.toString();//方法1（toString）</span><br><span class="line">String str3 = new String(strb1);//方法2（构造器）</span><br></pre></td></tr></table></figure></li></ol><h2 id="StringBuffer常用方法"><a href="#StringBuffer常用方法" class="headerlink" title="StringBuffer常用方法"></a>StringBuffer常用方法</h2><ul><li><p><code>append(char c)</code>：增加</p><p><code>append(String s)</code> 参数也能是字符串</p><p>特别的，<code>append(null);</code> 的场合，等同于 <code>append(&quot;null&quot;);</code></p></li><li><p><code>append(String s)</code> 参数也能是字符串</p><p>特别的，<code>append(null);</code> 的场合，等同于 <code>append(&quot;null&quot;);</code></p></li><li><p><code>delete(start, end)</code>：删减 [start, end) 的内容</p></li><li><p><code>replace(start, end, string)</code>：将 start 与 end 间的内容替换为 string</p></li><li><p><code>indexOf</code>：查找指定字符串第一次出现时的索引。没找到的场合返回 -1</p></li><li><p><code>insert</code>：在指定索引位置之前插入指定字符串</p></li><li><p><code>length()</code>：返回字符长度</p><p><code>capacity()</code>：返回当前的容量</p><p>String 类对象分配内存时，按照对象中所含字符个数等量分配。</p><p>StringBuffer 类对象分配内存时，除去字符所占空间外，会另加 16 字符大小的缓冲区。</p><p>对于 <code>length()</code> 方法，返回的是字符串长度。对于 <code>capacity()</code> 方法，返回的是 字符串 + 缓冲区 的大小。</p></li></ul><h1 id="StringBuilder-类"><a href="#StringBuilder-类" class="headerlink" title="StringBuilder 类"></a>StringBuilder 类</h1><p>一个可变的字符序列。此类提供一个与 <code>StringBuffer</code> 兼容的 API，但不保证同步（<strong>有线程安全问题</strong>）。该类被设计成 <code>StringBuffer</code> 的一个简易替换，<strong>用在字符串缓冲区被单个线程使用的时候</strong>，建议优先使用该类。在大多数实现中，它比起 <code>StringBuffer</code> 要快。</p><p>在 <code>StringBuilder</code> 是的主要操作是 <code>append</code> 和 <code>insert</code> 方法。可以重载这些方法，以接受任意类型的数据。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/202309181028471.png"></p><ol><li><code>StringBuilder</code> 也继承了 <code>AbstractStringBuffer</code></li><li><code>StringBuilder</code> 也实现了 <code>Serialiazable</code>，可以串行化</li><li>仍然是在父类中有属性 <code>char[] value</code> ，而且不是 <code>final</code></li><li><code>StringBuilder</code> 也是一个 <code>final</code> 类，不能被继承</li><li><code>StringBuilder</code> 的方法，没有做互斥的处理（没有 <code>synchronize</code>），故而存在线程安全问题</li></ol><h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><ol><li><code>StringBuilder</code> 和 <code>StringBuffer</code> 类似，均代表可变字符序列，而且方法也一样</li><li><code>String</code>：不可变字符序列，效率低，但复用率高</li><li><code>StringBuffer</code>：可变字符序列，效率较高，线程安全（多线程用）</li><li><code>StringBuilder</code>：可变字符序列，效率最高，存在线程安全问题（单线程用）</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-集合</title>
      <link href="/2023/05/27/Java08%E9%9B%86%E5%90%88/"/>
      <url>/2023/05/27/Java08%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="集合框架体系"><a href="#集合框架体系" class="headerlink" title="集合框架体系"></a>集合框架体系</h1><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310100902114.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310100903447.png" alt=" "></p><p>集合主要是两组(单列集合，双列集合)</p><ul><li><p><strong>Collection 接口</strong>（单列集合）：可以存放多个元素。每个元素可以是 ObjectCollection 接口有两个重要子接口：List（有序集合）和 Set（无序集合）</p></li><li><p><strong>Map 接口</strong>（双列集合）：用于保存具有映射关系的数据：key - value（双列元素）key 和 value 可以是任何类型的引用数据类型。其中 key 不能重复，value 可以重复。key 和 value 存在单一对应关系。通过特定的 key 一定能找到指定的 value</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">单列集合</span><br><span class="line">ArrayList arrayList = new ArrayList();</span><br><span class="line">arrayList.add(&quot;jack&quot;);</span><br><span class="line">arrayList.add(&quot;tom&quot;);</span><br><span class="line"></span><br><span class="line">双列集合</span><br><span class="line">HashMap hashMap = new HashMap();</span><br><span class="line">hashMap.put(&quot;NO1&quot;, &quot;北京&quot;);</span><br><span class="line">hashMap.put(&quot;NO2&quot;, &quot;上海&quot;);</span><br></pre></td></tr></table></figure><h1 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h1><h2 id="单列集合接口-Collection"><a href="#单列集合接口-Collection" class="headerlink" title="单列集合接口 Collection"></a>单列集合接口 Collection</h2><blockquote><p>public interface Collection<E> extends Lterable<E></p></blockquote><ol><li>Collection实现子类可以存放多个元素。每个元素可以是 Object</li><li>有些Collection实现子类能存放重复的元素，有些不能，根据底层是链表还是哈希表决定</li><li>有些 Collection 实现子类是有序的（List） ，有些不是（Set）</li><li>Collection接口没有直接的实现子类，都是通过其子接口（List 和 Set）实现的</li></ol><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><ul><li><p><code>add</code>：添加单个元素，会自动装箱操作</p></li><li><p><code>remove</code>：删除单个元素，能按索引删除，又能按内容删除</p></li><li><p><code>contains</code>：检查元素是否存在</p></li><li><p><code>size</code>：获取元素个数</p></li><li><p><code>isEmpty</code>：判断是否为空</p></li><li><p><code>clear</code>：清空</p></li><li><p><code>addAll</code>：添加多个元素</p></li><li><p><code>containsAll</code>：检查多个元素是否存在</p></li><li><p><code>removeAll</code>：删除多个元素</p></li><li><p><code>Iterator iterator()</code>：返回指向集合开始位置的迭代器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// add:添加单个元素</span><br><span class="line">list.add(&quot;jack&quot;);</span><br><span class="line">list.add(10);//list.add(new Integer(10))</span><br><span class="line">list.add(true);</span><br><span class="line">System.out.println(&quot;list=&quot; + list);</span><br><span class="line"></span><br><span class="line">// remove:删除指定元素</span><br><span class="line">list.remove(0);//删除第一个元素</span><br><span class="line">list.remove(true);//指定删除某个元素</span><br><span class="line">System.out.println(&quot;list=&quot; + list);</span><br><span class="line"></span><br><span class="line">// contains:查找元素是否存在</span><br><span class="line">System.out.println(list.contains(&quot;jack&quot;));//T</span><br><span class="line"></span><br><span class="line">// size:获取元素个数</span><br><span class="line">System.out.println(list.size());//2</span><br><span class="line"></span><br><span class="line">// isEmpty:判断是否为空</span><br><span class="line">System.out.println(list.isEmpty());//F</span><br><span class="line"></span><br><span class="line">// clear:清空</span><br><span class="line">list.clear();</span><br><span class="line">System.out.println(&quot;list=&quot; + list);</span><br><span class="line"></span><br><span class="line">// addAll:添加多个元素</span><br><span class="line">ArrayList list2 = new ArrayList();</span><br><span class="line">list2.add(&quot;红楼梦&quot;);</span><br><span class="line">list2.add(&quot;三国演义&quot;);</span><br><span class="line">list.addAll(list2);</span><br><span class="line">System.out.println(&quot;list=&quot; + list);</span><br><span class="line"></span><br><span class="line">// containsAll:查找多个元素是否都存在</span><br><span class="line">System.out.println(list.containsAll(list2));//T</span><br><span class="line"></span><br><span class="line">// removeAll：删除多个元素</span><br><span class="line">list.add(&quot;聊斋&quot;);</span><br><span class="line">list.removeAll(list2);</span><br><span class="line">System.out.println(&quot;list=&quot; + list);//[聊斋]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="迭代器-Iterator"><a href="#迭代器-Iterator" class="headerlink" title="迭代器 Iterator"></a>迭代器 Iterator</h2><ul><li><p>Iterator 对象称为迭代器，主要用于遍历 Collection 集合中的元素。</p></li><li><p>所有实现了Collection接口的集合类都有一个iterator方法， 用以返回一个实现了Iterator接口的对象，即可以返回一个迭代器。</p></li><li><p>Iterator 对象仅用于遍历集合，本身不存放元素</p></li></ul><blockquote><p>IDEA 中，迭代器 while 循环的模板快捷键：<code>itit</code></p></blockquote><p><strong>常用方法：</strong></p><ul><li>iterator()：构造方法，获取迭代器对象</li></ul><ul><li><code>boolean hasNext()</code>：该方法判断是否有下一个元素。</li><li><code>T next()</code>：该方法会将指针下移，然后返回下移后的位置上的元素</li></ul><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310100950317.png"></p><p><strong>用迭代器遍历元素：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;Object&gt; c = new LinkedList&lt;&gt;();</span><br><span class="line">Iterator&lt;Object&gt; iterator = c.iterator();// [1]</span><br><span class="line">while (iterator.hasNext())&#123;// [2]</span><br><span class="line">Object obj = iterator.next();// [3]</span><br><span class="line">System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>获取迭代器</p></li><li><p>判断有无下一元素</p></li><li><p>将迭代器后移，并返回那个后移位置上的元素</p></li><li><p>while 循环结束后，指针指向最后元素的位置。再次 <code>next()</code> 会报错。如果需要再使用，需要重置迭代器。</p><blockquote><p>iterator &#x3D; list.iterator();&#x2F;&#x2F;重置迭代器</p></blockquote></li></ol><h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class CollectionIterator &#123;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;all&quot;&#125;)</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Collection col = new ArrayList();</span><br><span class="line"></span><br><span class="line">        col.add(new Book(&quot;三国演义&quot;, &quot;罗贯中&quot;, 10.1));</span><br><span class="line">        col.add(new Book(&quot;小李飞刀&quot;, &quot;古龙&quot;, 5.1));</span><br><span class="line">        col.add(new Book(&quot;红楼梦&quot;, &quot;曹雪芹&quot;, 34.6));</span><br><span class="line"></span><br><span class="line">        //System.out.println(&quot;col=&quot; + col);</span><br><span class="line">        //现在老师希望能够遍历 col集合</span><br><span class="line">        //1. 先得到 col 对应的 迭代器</span><br><span class="line">        Iterator iterator = col.iterator();</span><br><span class="line">        //2. 使用while循环遍历</span><br><span class="line">//        while (iterator.hasNext()) &#123;//判断是否还有数据</span><br><span class="line">//            //返回下一个元素，类型是Object</span><br><span class="line">//            Object obj = iterator.next();</span><br><span class="line">//            System.out.println(&quot;obj=&quot; + obj);</span><br><span class="line">//        &#125;</span><br><span class="line">        //快捷键，快速生成 while =&gt; itit</span><br><span class="line">        //显示所有的快捷键的的快捷键 ctrl + j</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            Object obj = iterator.next();</span><br><span class="line">            System.out.println(&quot;obj=&quot; + obj);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //3. 当退出while循环后 , 这时iterator迭代器，指向最后的元素</span><br><span class="line">        //   iterator.next();//NoSuchElementException</span><br><span class="line">        </span><br><span class="line">        //4. 如果希望再次遍历，需要重置我们的迭代器</span><br><span class="line">        iterator = col.iterator();</span><br><span class="line">        System.out.println(&quot;===第二次遍历===&quot;);</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            Object obj = iterator.next();</span><br><span class="line">            System.out.println(&quot;obj=&quot; + obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="foreach（增强-for-循环）"><a href="#foreach（增强-for-循环）" class="headerlink" title="foreach（增强 for 循环）"></a>foreach（增强 for 循环）</h2><p>for each 的语法与 for 循环相似，但是可以遍历 Collection 和 数组 中的元素</p><blockquote><p>IDEA 中，增强 for 循环的模板快捷键：<code>I</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (Object o : list)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>for each 可在 Collection 集合中使用。</li><li>for each 的底层在本质上也是 <code>Iterator</code>。可以理解为简化版本的迭代器遍历</li></ul><h3 id="例-1"><a href="#例-1" class="headerlink" title="例"></a>例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class CollectionFor &#123;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;all&quot;&#125;)</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Collection col = new ArrayList();</span><br><span class="line"></span><br><span class="line">        col.add(new Book(&quot;三国演义&quot;, &quot;罗贯中&quot;, 10.1));</span><br><span class="line">        col.add(new Book(&quot;小李飞刀&quot;, &quot;古龙&quot;, 5.1));</span><br><span class="line">        col.add(new Book(&quot;红楼梦&quot;, &quot;曹雪芹&quot;, 34.6));</span><br><span class="line"></span><br><span class="line">        //1. 使用增强for, 在Collection集合</span><br><span class="line">        //2. 增强for， 底层仍然是迭代器</span><br><span class="line">        //3. 增强for可以理解成就是简化版本的 迭代器遍历</span><br><span class="line">        //4. 快捷键方式 I</span><br><span class="line">        </span><br><span class="line">//        for (Object book : col) &#123;</span><br><span class="line">//            System.out.println(&quot;book=&quot; + book);</span><br><span class="line">//        &#125;</span><br><span class="line">        for (Object o : col) &#123;</span><br><span class="line">            System.out.println(&quot;book=&quot; + o);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //增强for，也可以直接在数组使用</span><br><span class="line">//        int[] nums = &#123;1, 8, 10, 90&#125;;</span><br><span class="line">//        for (int i : nums) &#123;</span><br><span class="line">//            System.out.println(&quot;i=&quot; + i);</span><br><span class="line">//        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="课堂练习"><a href="#课堂练习" class="headerlink" title="课堂练习"></a>课堂练习</h2><ol><li>创建  3个 Dog {name, age}  对象，放入到 ArrayList 中，赋给 List 引用</li><li>用迭代器和增强for循环两种方式来遍历</li><li>重写Dog 的toString方法， 输出name和age</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">public class CollectionExercise &#123;</span><br><span class="line">    @SuppressWarnings(&#123;&quot;all&quot;&#125;)</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List list = new ArrayList();</span><br><span class="line">        list.add(new Dog(&quot;小黑&quot;, 3));</span><br><span class="line">        list.add(new Dog(&quot;大黄&quot;, 100));</span><br><span class="line">        list.add(new Dog(&quot;大壮&quot;, 8));</span><br><span class="line"></span><br><span class="line">        //先使用for增强</span><br><span class="line">        for (Object dog : list) &#123;</span><br><span class="line">            System.out.println(&quot;dog=&quot; + dog);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //使用迭代器</span><br><span class="line">        System.out.println(&quot;===使用迭代器来遍历===&quot;);</span><br><span class="line">        Iterator iterator = list.iterator();</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            Object dog =  iterator.next();</span><br><span class="line">            System.out.println(&quot;dog=&quot; + dog);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 创建  3个 Dog &#123;name, age&#125;  对象，放入到 ArrayList 中，赋给 List 引用</span><br><span class="line"> * 用迭代器和增强for循环两种方式来遍历</span><br><span class="line"> * 重写Dog 的toString方法， 输出name和age</span><br><span class="line"> */</span><br><span class="line">class Dog &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public Dog(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Dog&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="有序集合接口-List"><a href="#有序集合接口-List" class="headerlink" title="有序集合接口 List"></a>有序集合接口 List</h1><blockquote><p>public interface List<E> extends Collection<E></p></blockquote><p>List 是 Collection 接口的子类接口，里面元素是有序（添加顺序和取出顺序一致）的，元素可重复的，每个元素都有其对应的顺序索引，下标从0开始。</p><p>三个主要的实现子类</p><ol><li>Vector</li><li>LinkedList</li><li>ArrayList</li></ol><h2 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h2><ul><li><p><code>add(int, obj)</code>：在 int 位置插入 obj 元素。返回 true</p><p><code>add(obj)</code>：在末尾插入 obj。返回 true</p><p><code>addElement(obj)</code>：在末尾插入 obj。无返回值。你说要这方法有啥用？名字还长一截</p></li><li><p><code>addAll(int, collection)</code>：在 int 位置插入 collection 中的所有元素</p></li><li><p><code>get(int)</code>：返回 int 位置的元素</p></li><li><p><code>indexOf(obj)</code>：返回 obj 首次出现时的位置</p></li><li><p><code>lastIndexOf(obj)</code>：返回 obj 最后一次出现时的位置</p></li><li><p><code>remove(int)</code>：移除 int 位置的元素，并返回那个被移除的元素</p></li><li><p><code>set(int, obj)</code>：设置 int 位置的元素为 obj。相当于替换。返回那个被替换元素的下标</p><p><code>setElement(obj, int)</code>：设置 int 位置的元素为 obj。无返回值</p></li><li><p><code>subList(int1, int2)</code>：返回 [int1, int2) 范围的元素构成的子集合</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        List list = new ArrayList();</span><br><span class="line">        list.add(&quot;张三丰&quot;);</span><br><span class="line">        list.add(&quot;贾宝玉&quot;);</span><br><span class="line">        </span><br><span class="line">//      void add(int index, Object ele):在index位置插入ele元素</span><br><span class="line">        //在index = 1的位置插入一个对象</span><br><span class="line">        list.add(1, &quot;韩顺平&quot;);</span><br><span class="line">        System.out.println(&quot;list=&quot; + list);</span><br><span class="line">        </span><br><span class="line">//      boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来</span><br><span class="line">        List list2 = new ArrayList();</span><br><span class="line">        list2.add(&quot;jack&quot;);</span><br><span class="line">        list2.add(&quot;tom&quot;);</span><br><span class="line">        list.addAll(1, list2);</span><br><span class="line">        System.out.println(&quot;list=&quot; + list);</span><br><span class="line">        </span><br><span class="line">//      Object get(int index):获取指定index位置的元素</span><br><span class="line">       </span><br><span class="line">//      int indexOf(Object obj):返回obj在集合中首次出现的位置</span><br><span class="line">        System.out.println(list.indexOf(&quot;tom&quot;));//2</span><br><span class="line">        </span><br><span class="line">//      int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置</span><br><span class="line">        list.add(&quot;韩顺平&quot;);</span><br><span class="line">        System.out.println(&quot;list=&quot; + list);</span><br><span class="line">        System.out.println(list.lastIndexOf(&quot;韩顺平&quot;));</span><br><span class="line">        </span><br><span class="line">//      Object remove(int index):移除指定index位置的元素，并返回此元素</span><br><span class="line">        list.remove(0);</span><br><span class="line">        System.out.println(&quot;list=&quot; + list);</span><br><span class="line">        </span><br><span class="line">//      Object set(int index, Object ele):设置指定index位置的元素为ele , 相当于是替换.</span><br><span class="line">        list.set(1, &quot;玛丽&quot;);</span><br><span class="line">        System.out.println(&quot;list=&quot; + list);</span><br><span class="line">        </span><br><span class="line">//      List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合</span><br><span class="line">        // 注意返回的子集合 fromIndex &lt;= subList &lt; toIndex</span><br><span class="line">        List returnlist = list.subList(0, 2);</span><br><span class="line">        System.out.println(&quot;returnlist=&quot; + returnlist);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="List-的三种遍历方式"><a href="#List-的三种遍历方式" class="headerlink" title="List 的三种遍历方式"></a>List 的三种遍历方式</h2><p> ArrayList，LinkedList，Vector三者通用</p><ol><li>迭代器</li><li>foreach</li><li>普通for</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">    //List 接口的实现子类 Vector LinkedList</span><br><span class="line">    //List list = new ArrayList();</span><br><span class="line">    //List list = new Vector();</span><br><span class="line">    List list = new LinkedList();</span><br><span class="line"></span><br><span class="line">    list.add(&quot;jack&quot;);</span><br><span class="line">    list.add(&quot;tom&quot;);</span><br><span class="line">    list.add(&quot;鱼香肉丝&quot;);</span><br><span class="line">    list.add(&quot;北京烤鸭子&quot;);</span><br><span class="line"></span><br><span class="line">    //遍历</span><br><span class="line">    //1. 迭代器</span><br><span class="line">    Iterator iterator = list.iterator();</span><br><span class="line">    while (iterator.hasNext()) &#123;</span><br><span class="line">        Object obj =  iterator.next();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;=====增强for=====&quot;);</span><br><span class="line">    //2. 增强for</span><br><span class="line">    for (Object o : list) &#123;</span><br><span class="line">        System.out.println(&quot;o=&quot; + o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;=====普通for====&quot;);</span><br><span class="line">    //3. 使用普通for</span><br><span class="line">    for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">        System.out.println(&quot;对象=&quot; + list.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可变数组ArrayList"><a href="#可变数组ArrayList" class="headerlink" title="可变数组ArrayList"></a>可变数组ArrayList</h2><blockquote><p>public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable</p></blockquote><p>ArrayList 是 List 的实现子类。其底层由<strong>数组</strong>来实现存储。ArrayList 允许存放任何元素，包括null，并且可以有多个相同元素</p><p>ArrayList基本等同于Vector ,除了ArrayList是线程不安全，但执行效率高。</p><p>在多线程情况下，不建议使用ArrayList</p><h3 id="ArrayList-的源码"><a href="#ArrayList-的源码" class="headerlink" title="ArrayList 的源码"></a>ArrayList 的源码</h3><p>结论：</p><ol><li><p>ArrayList 中维护了一个 Object 类型的数组 elementData。该数组就是用来存放元素的数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient Object[] elementData;</span><br></pre></td></tr></table></figure><blockquote><p>transient 表示瞬间,短暂的，表示该属性不会被序列化</p></blockquote></li><li><p>创建 ArrayList 对象时</p><p>使用无参构造器，则 elementData[] 初始容量为 0</p><p>使用指定大小构造器，则初始容量为指定大小。</p></li><li><p>扩容的场合：</p><p>初始长度为 0 的 elementData，第一次扩容，容量置为10。后面每次扩容乘以1.5 倍。</p><p>初始长度为 capacity 的 elementData，每次扩容乘以1.5 。</p></li><li><p>当添加元素时：先判断是否需要扩容，如果需要扩容，则调用grow方法，否则直接添加元素到合适位置</p></li></ol><h3 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h3><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310101139825.png"></p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310101140986.png"></p><ul><li><p>构造器：创建一个数组</p></li><li><p>add()：</p><ol><li>确定是否扩容</li><li>添加元素</li></ol></li><li><p>扩容：</p><p>1</p></li></ul><h2 id="可变数组Vector"><a href="#可变数组Vector" class="headerlink" title="可变数组Vector"></a>可变数组Vector</h2><blockquote><p>public class Vector<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable</p></blockquote><p>Vector 是 List 的实现子类。其底层由<strong>数组</strong>来实现存储，但是线程安全。</p><blockquote><p>Vector 与 ArrayList 基本等同。ArrayList 效率更高，Vector 线程安全。</p><p>在开发中，需要考虑线程安全时，建议使用 Vector ，而非 ArrayList</p></blockquote><h3 id="Vector的源码"><a href="#Vector的源码" class="headerlink" title="Vector的源码"></a>Vector的源码</h3><ol><li><p>底层维护了一个 Object 类型的数组 elementData。用以存放元素</p></li><li><p>使用无参构造器创建对象时，默认大小是 10</p><p>使用有参构造器的场合，默认是那个指定大小（initialCapaticy）</p><p>也能在构造器中指定那个扩容的增长速度（capacityIncrement）</p></li><li><p>扩容的场合，容量变成 2 倍</p><p>使用有参构造器改变了 capacityIncrement 的场合，增量是那个指定数值</p></li></ol><h3 id="ArrayList-和Vector-的比较"><a href="#ArrayList-和Vector-的比较" class="headerlink" title="ArrayList 和Vector 的比较"></a>ArrayList 和Vector 的比较</h3><table><thead><tr><th></th><th>底层结构</th><th>版本</th><th>线程安全(同步)效率</th><th>扩容倍数</th></tr></thead><tbody><tr><td>ArrayList</td><td>可变数组</td><td>jdk1.2出现</td><td>不安全，效率高</td><td>如果有参构造1.5倍<br>如果是无参，第一次10，后面1.5倍扩容</td></tr><tr><td>Vector</td><td>可变数组 Object[ ]</td><td>jdk1.0出现</td><td>安全，效率不高</td><td>如果是无参，默认10，后面2倍扩容<br>如果是有参，初始大小就是参数，后面2倍扩容</td></tr></tbody></table><h2 id="链表-LinkedList"><a href="#链表-LinkedList" class="headerlink" title="链表 LinkedList"></a>链表 LinkedList</h2><blockquote><p>public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Deque<E>, Cloneable, java.io.Serializable</p></blockquote><p>在 Java 中，LinkedList 是 List 的实现子类，底层以<strong>双向非环链表</strong>形式存储元素。</p><p>LinkedList 底层实现了 双向链表 和 双端队列 特点。在 Java 中，LinkedList 也实现了 Deque 接口。</p><p>LinkedList 可以添加 null，可添加重复元素。但没有实现同步，因此线程不安全。</p><blockquote><p>链表是一种<strong>线性结构</strong>：其以节点方式存储，节点间在内存上的位置不连续。</p></blockquote><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310102139766.png"></p><h3 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h3><p><code>void addLast(E e)</code>：尾插一个新的元素，LinkedList 的 add 方法即调用该方法</p><p><code>void addFirst(E e)</code>：头插一个新的元素</p><p><code>E removeLast()</code>：移除并返回尾部元素。为空时报错</p><p><code>E poll()</code>：移除并返回尾部元素。为空时返回 null</p><p><code>E removeFirst()</code>：移除并返回头部元素。为空时报错</p><p><code>E getLast()</code>：仅返回尾部元素。为空时报错</p><p><code>E peek()</code>：返回尾部元素。为空时返回 null</p><p><code>E element()</code>：返回头部元素。为空时返回 null</p><p><code>E getFirst()</code></p><h3 id="LinkedList-的源码"><a href="#LinkedList-的源码" class="headerlink" title="LinkedList 的源码"></a>LinkedList 的源码</h3><ol><li><p>LinkedList 只有默认构造器和一个拷贝构造器</p></li><li><p>LinkedList 底层维护了一个 双向链表</p><p>每个节点（Node 对象）有 prev、next、item 属性。</p><p>其中 item 用来存放数据。</p><p>其中通过 prev 指向前一个节点，通过 next 指向后一个节点。最终实现双向链表。</p></li><li><p>LinkedList 不需要扩容。其增删元素时只要改变节点的指向即可。</p><p>也因此，其添加、删除元素效率比数组更高</p></li></ol><h2 id="ArrayList-x2F-Vector-和-LinkedList-的比较："><a href="#ArrayList-x2F-Vector-和-LinkedList-的比较：" class="headerlink" title="ArrayList&#x2F;Vector 和 LinkedList 的比较："></a>ArrayList&#x2F;Vector 和 LinkedList 的比较：</h2><table><thead><tr><th></th><th>底层结构</th><th>增删效率</th><th>改查效率</th></tr></thead><tbody><tr><td>ArrayList &#x2F; Vector</td><td>可变数组</td><td>低（数组扩容）</td><td>高</td></tr><tr><td><code>LinkedList</code></td><td>双向链表</td><td>高（链表追加）</td><td>低</td></tr></tbody></table><p>如何选择ArrayList和LinkedList：</p><ol><li>如果我们改查的操作多，选择ArrayList</li><li>如果我们增删的操作多，选择LinkedList</li><li>一般来说，在程序中，80%-90%都是查询，因此大部分情况下会选择ArrayList</li><li>在一个项目中，根据业务灵活选择，也可能这样，一个模块使用的是ArrayList,另外一个模块是LinkedList,也就是说，要根据业务来进行选择</li></ol><h1 id="无序集合接口-Set"><a href="#无序集合接口-Set" class="headerlink" title="无序集合接口 Set"></a>无序集合接口 Set</h1><blockquote><p>public interface Set<E> extends Collection<E></p></blockquote><p>Set 是 Collection 接口的子类接口。常用方法和 Collection 接口一样</p><p>Set 接口的特点是无序，没有索引，不允许重复元素。最多包含一个 null</p><h2 id="Set-接口的遍历方式"><a href="#Set-接口的遍历方式" class="headerlink" title="Set 接口的遍历方式"></a>Set 接口的遍历方式</h2><p>set 接口对象存放数据是无序（即添加的顺序和取出的顺序不一致）</p><p>可以使用迭代器和foreach，但是用不了普通for循环（没有索引）</p><blockquote><p>取出的顺序的顺序虽然不是添加的顺序，但是这个顺序是固定的</p></blockquote><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><ol><li><p>HashSet实现了Set接口</p></li><li><p>HashSet实际上是HashMap</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public HashSet() &#123;</span><br><span class="line">    map = new HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以存放null值，但是只能有一个null</p></li><li><p>HashSet不保证元素是有序的，取决于hash后，再确定索引的结果</p><blockquote><p>不保证存放元素的顺序和取出顺序致</p></blockquote></li><li><p>不能有重复元素&#x2F;对象</p><blockquote><p>Set共同特点</p></blockquote></li><li><p>add方法：会返回一个 boolen 值，根据内存地址判断是不是同一个对象，往 set 中加东西</p><blockquote><p>非常经典的面试题，涉及了 add 方法和字符串常量池</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set.add(new String(&quot;hsp&quot;));//ok</span><br><span class="line">set.add(new String(&quot;hsp&quot;));//加入不了.</span><br><span class="line">System.out.println(&quot;set=&quot; + set);</span><br></pre></td></tr></table></figure></blockquote></li></ol><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><blockquote><p>public class LinkedHashSet<E> extends HashSet<E> implements Set<E>, Cloneable, java.io.Serializable</p></blockquote><p>LinkedHashSet 是 HashSet 的子类</p><p>LinkedHashSet 底层是一个 LinkedHashMap，维护了一个数组 + 双向链表。</p><p>LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置。同时，使用链表维护元素的次序。这使得元素看起来是以插入顺序保存的，并得以按照放入顺序取出</p><h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p>当我们使用无参构造器，创建TreeSet时，仍然是无序的，使用TreeSet 提供的一个构造器，可以传入一个比较器(匿名内部类)并指定排序规则，构造器可以重构，实现不同功能，但最终返回一个</p><ul><li><p>无参构造器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TreeMap treeMap = new TreeMap();</span><br><span class="line"></span><br><span class="line">treeSet.add(&quot;jack&quot;);</span><br><span class="line">treeSet.add(&quot;tom&quot;);//3</span><br><span class="line">treeSet.add(&quot;sp&quot;);</span><br><span class="line">treeSet.add(&quot;a&quot;);</span><br><span class="line">treeSet.add(&quot;abc&quot;);//3</span><br></pre></td></tr></table></figure></li><li><p>带比较器的构造器</p><p>按字符串大小比较的比较器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TreeMap treeMap = new TreeMap(new Comparator() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Object o1, Object o2) &#123;</span><br><span class="line">        return ((String) o2).compareTo((String) o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>按照长度大小排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TreeMap treeMap = new TreeMap(new Comparator() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Object o1, Object o2) &#123;</span><br><span class="line">        return ((String) o2).length() - ((String) o1).length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><ol><li><p>构造器把传入的比较器对象，赋给了 TreeSet的底层的 TreeMap的属性this.comparator</p><p>TreeSet 底层还是 TreeMap</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public TreeMap(Comparator&lt;? super K&gt; comparator) &#123;</span><br><span class="line">    this.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在调用 treeSet.add(“tom”)，在底层会执行到下面判断，这个是真正决定添加的部分，构造器中进行的判断只是给下面的方法提供条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if (cpr != null) &#123;//cpr 就是我们的匿名内部类(对象)</span><br><span class="line">    do &#123;</span><br><span class="line">        parent = t;</span><br><span class="line">        //动态绑定到我们的匿名内部类(对象)compare</span><br><span class="line">        cmp = cpr.compare(key, t.key);</span><br><span class="line">        if (cmp &lt; 0)</span><br><span class="line">            t = t.left;</span><br><span class="line">        else if (cmp &gt; 0)</span><br><span class="line">            t = t.right;</span><br><span class="line">        else //如果相等，即返回0,这个Key就没有加入</span><br><span class="line">            return t.setValue(value);</span><br><span class="line">    &#125; while (t != null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/202310121000041.png"></p><p>Map接口的常用实现类: HashMap、Hashtable 和 Properties</p><p>Map接口实现类的特点：这里讲的是 JDK8 的Map接口特点</p><ol><li><p>Map用于保存具有映射关系的数据:Key-Value（键值对）</p></li><li><p>Map中的 key 和 value 可以是任何引用类型的数据，会封装到 HashMap$Node 对象中</p></li><li><p>Map中的key不允许重复，原因和HashSet 一样，当有相同的k，就等价于替换，</p></li><li><p>Map中的 value 可以重复</p></li><li><p>Map的 key 可以为 null，value 也可以为 null，key 为 nul，只能有一个，value 为 null，可以多个</p></li><li><p>常用 String 类作为 Map 的 key，但是不是只有字符串才能做 key</p><blockquote><p>put方法中 key 的类型是Object，啥都能接受。value 的类型也是Object，啥都能接受。</p></blockquote></li><li><p>key和value之间存在单向一对一关系，即通过指定的key总能找到对应的value</p></li><li><p>Map 存放数据的 key-value 示意图，一对 k-v 是放在一个HashMap$Node中的， 有因为Node实现了Entry 接口，有些书上也说一对 k-v 就是一个 Entry</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        return new  &lt;&gt;(hash, key, value, next);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>  Map真正的把 key 和 value 放在HashMap中</p><p>  Set 和 Collection 只是指向了HashMap</p><ol><li><p>k-v 最后是 HashMap$Node node &#x3D; newNode(hash, key, value, null)</p></li><li><p>k-v 为了方便程序员的遍历，还会 创建 EntrySet 集合 ，该集合存放的元素的类型 Entry, 而一个Entry对象就有k,v。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br></pre></td></tr></table></figure></li><li><p>EntrySet中，定义的类型是 Map.Entry， 但是实际上存放的还是 HashMap$Node</p><p>这是因为 static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt;。HashMap实现了Entry接口</p></li><li><p>当把 HashMap$Node 对象存放到 entrySet 就方便我们的遍历，因为 Map.Entry 提供了重要方法 K getKey() 和 V getValue();</p></li></ol></li></ol><h2 id="Map接口常用方法"><a href="#Map接口常用方法" class="headerlink" title="Map接口常用方法"></a>Map接口常用方法</h2><ol><li>put：添加</li><li>remove：根据键删除映射关系</li><li>get：根据键获取值</li><li>size：获取元素个数</li><li>isEmpty：判断个数是否为0</li><li>clear：清除</li><li>containsKey：查找键是否存在</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//      remove:根据键删除映射关系</span><br><span class="line">        map.remove(null);</span><br><span class="line">        </span><br><span class="line">//      get：根据键获取值</span><br><span class="line">        Object val = map.get(&quot;鹿晗&quot;);</span><br><span class="line">        </span><br><span class="line">//      size:获取元素个数</span><br><span class="line">        System.out.println(&quot;k-v=&quot; + map.size());</span><br><span class="line">        </span><br><span class="line">//      isEmpty:判断个数是否为0</span><br><span class="line">        System.out.println(map.isEmpty());//F</span><br><span class="line">        </span><br><span class="line">//      clear:清空</span><br><span class="line">        //map.clear();</span><br><span class="line">        System.out.println(&quot;map=&quot; + map);</span><br><span class="line">        </span><br><span class="line">//      containsKey:查找键是否存在</span><br><span class="line">        System.out.println(&quot;结果=&quot; + map.containsKey(&quot;hsp&quot;));//T</span><br></pre></td></tr></table></figure><h2 id="Map遍历方式"><a href="#Map遍历方式" class="headerlink" title="Map遍历方式"></a>Map遍历方式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//第一组: 先取出 所有的Key , 通过Key 取出对应的Value</span><br><span class="line">Set keyset = map.keySet();</span><br><span class="line">//(1) 增强for</span><br><span class="line">System.out.println(&quot;-----第一种方式-------&quot;);</span><br><span class="line">for (Object key : keyset) &#123;</span><br><span class="line">    System.out.println(key + &quot;-&quot; + map.get(key));</span><br><span class="line">&#125;</span><br><span class="line">//(2) 迭代器</span><br><span class="line">System.out.println(&quot;----第二种方式--------&quot;);</span><br><span class="line">Iterator iterator = keyset.iterator();</span><br><span class="line">while (iterator.hasNext()) &#123;</span><br><span class="line">    Object key =  iterator.next();</span><br><span class="line">    System.out.println(key + &quot;-&quot; + map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//第二组: 把所有的values取出</span><br><span class="line">Collection values = map.values();</span><br><span class="line">//这里可以使用所有的Collections使用的遍历方法</span><br><span class="line">//(1) 增强for</span><br><span class="line">System.out.println(&quot;---取出所有的value 增强for----&quot;);</span><br><span class="line">for (Object value : values) &#123;</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br><span class="line">//(2) 迭代器</span><br><span class="line">System.out.println(&quot;---取出所有的value 迭代器----&quot;);</span><br><span class="line">Iterator iterator2 = values.iterator();</span><br><span class="line">while (iterator2.hasNext()) &#123;</span><br><span class="line">    Object value =  iterator2.next();</span><br><span class="line">    System.out.println(value);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//第三组: 通过EntrySet 来获取 k-v</span><br><span class="line">Set entrySet = map.entrySet();// EntrySet&lt;Map.Entry&lt;K,V&gt;&gt;</span><br><span class="line">//        (1) 增强for</span><br><span class="line">System.out.println(&quot;----使用EntrySet 的 for增强(第3种)----&quot;);</span><br><span class="line">for (Object entry : entrySet) &#123;</span><br><span class="line">    //将entry 转成 Map.Entry</span><br><span class="line">    Map.Entry m = (Map.Entry) entry;</span><br><span class="line">    System.out.println(m.getKey() + &quot;-&quot; + m.getValue());</span><br><span class="line">&#125;</span><br><span class="line">//(2) 迭代器</span><br><span class="line">System.out.println(&quot;----使用EntrySet 的 迭代器(第4种)----&quot;);</span><br><span class="line">Iterator iterator3 = entrySet.iterator();</span><br><span class="line">while (iterator3.hasNext()) &#123;</span><br><span class="line">    Object entry =  iterator3.next();</span><br><span class="line">    System.out.println(entry.getClass());//HashMap$Node -实现-&gt; Map.Entry (getKey,getValue)</span><br><span class="line">    //向下转型 Map.Entry</span><br><span class="line">    Map.Entry m = (Map.Entry) entry;</span><br><span class="line">    System.out.println(m.getKey() + &quot;-&quot; + m.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><ol><li>HashMap是Map接口使用频率最高的实现类。</li><li>HashMap是以key-val对的方式来存储数据（HashMap$Node类型）</li><li>key不能重复，但是是值可以重复，允许使用nulI键和null值。</li><li>如果添加相同的key，则会覆盖原来的key-val ,等同于修改（key不会替换，val会替换）</li><li>与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式来存储的。JDK8中 hashMap 底层数组+链表+红黑树</li><li>HashMap没有实现同步，因此是线程不安全的</li></ol><h3 id="底层机制"><a href="#底层机制" class="headerlink" title="底层机制"></a>底层机制</h3><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20231109104621185.png" alt="image-20231109104621185"></p><p>k,v 是一个Node 实现了 Map.Entry&lt;K,V&gt; ，查看HashMap的源码可以看到</p><p>扩容机制和HashSet相同</p><ol><li>HashMap底层维护了Node类型的数组table,默认为null</li><li>当创建对象时，将加载因子(loadfactor)初始化为0.75.</li><li>当添动加key-val时，通过key的哈希值得到在table的索引。然后判断该索引处是否有元素，如果没有元素直接添加。如果该索引处有元素，继续判断该元素的key是否和准备加入的key相等，如果相等，则直接替换val;如果不相等需要判断是树结构还是链表结构，做出相应处理。如果添加时发现容量不够，则需要打容。</li><li>第1次添加，则需要扩容table容量为16,临界值为12（16 * 0.75）</li><li>以后再扩容，则需要扩容table容量为原来的2倍，临界值为原来的2倍，即24，依次类推</li><li>在Java8中，存在转化为红黑树的情况</li></ol><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">1. 执行构造器 new HashMap()</span><br><span class="line">初始化加载因子 loadfactor = 0.75</span><br><span class="line">HashMap$Node[] table = null</span><br><span class="line"></span><br><span class="line">2. 执行put 调用 hash方法，计算 key的 hash值 (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</span><br><span class="line">public V put(K key, V value) &#123;//K = &quot;java&quot; value = 10</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3. 执行 putVal</span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">       boolean evict) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;//辅助变量</span><br><span class="line">    //如果底层的table 数组为null, 或者 length =0 , 就扩容到16</span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    //取出hash值对应的table的索引位置的Node, 如果为null, 就直接把加入的k-v</span><br><span class="line">    //, 创建成一个 Node ,加入该位置即可</span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line">    else &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;//辅助变量</span><br><span class="line">    // 如果table的索引位置的key的hash相同和新的key的hash值相同，</span><br><span class="line">     // 并 满足(table现有的结点的key和准备添加的key是同一个对象  || equals返回真)</span><br><span class="line">     // 就认为不能加入新的k-v</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        else if (p instanceof TreeNode)//如果当前的table的已有的Node 是红黑树，就按照红黑树的方式处理</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">        else &#123;</span><br><span class="line">            //如果找到的结点，后面是链表，就循环比较</span><br><span class="line">            for (int binCount = 0; ; ++binCount) &#123;//死循环</span><br><span class="line">                if ((e = p.next) == null) &#123;//如果整个链表，没有和他相同,就加到该链表的最后</span><br><span class="line">                    p.next = newNode(hash, key, value, null);</span><br><span class="line">                    //加入后，判断当前链表的个数，是否已经到8个，到8个，后</span><br><span class="line">                    //就调用 treeifyBin 方法进行红黑树的转换</span><br><span class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (e.hash == hash &amp;&amp; //如果在循环比较过程中，发现有相同,就break,就只是替换value</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    break;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (e != null) &#123; // existing mapping for key</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                e.value = value; //替换，key对应value</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;//每增加一个Node ,就size++</span><br><span class="line">    if (++size &gt; threshold[12-24-48])//如size &gt; 临界值，就扩容</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">5. 关于树化(转成红黑树)</span><br><span class="line">//如果table 为null ,或者大小还没有到 64，暂时不树化，而是进行扩容.</span><br><span class="line">//否则才会真正的树化 -&gt; 剪枝</span><br><span class="line">final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;</span><br><span class="line">int n, index; Node&lt;K,V&gt; e;</span><br><span class="line">if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">    resize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树化案例"><a href="#树化案例" class="headerlink" title="树化案例"></a>树化案例</h3><h2 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h2><blockquote><p> public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable,  java.io.Serializable {</p></blockquote><ol><li>存放的元素是键值对即K-V</li><li>hashtable的键和值都不能为null，否则会抛出NullPointerException</li><li>hashTable使用方法基本上和HashMap-样</li><li>hashTable是线程安全的（synchronized），hashMap是线程不安全的</li></ol><h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><ol><li>Properties 类继承自 Hashtable 类并且实现了 Map 接口， 也是使用一种键值对的形式来保存数据。</li><li>他的使用特点和Hashtable类似，键和值都不能为null，否则会抛出NullPointerException</li><li>Properties 还可以用于从xx.properties文件中，加载数据到Properties类对象并进行读取和修改</li><li>工作后xx.properties 文件通常作为配置文件</li></ol><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>Properties 继承  Hashtable，可以通过 k-v 存放数据，当然key 和 value 不能为 null</p><ul><li>增加：put(Object key,Object value);</li><li>删除：remove(Object key);</li><li>修改</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//1. Properties 继承  Hashtable</span><br><span class="line">//2. 可以通过 k-v 存放数据，当然key 和 value 不能为 null</span><br><span class="line">//增加</span><br><span class="line">Properties properties = new Properties();</span><br><span class="line">//properties.put(null, &quot;abc&quot;);//抛出 空指针异常</span><br><span class="line">//properties.put(&quot;abc&quot;, null); //抛出 空指针异常</span><br><span class="line">properties.put(&quot;john&quot;, 100);//k-v</span><br><span class="line">properties.put(&quot;lucy&quot;, 100);</span><br><span class="line">properties.put(&quot;lic&quot;, 100);</span><br><span class="line">properties.put(&quot;lic&quot;, 88);//如果有相同的key ， value被替换</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;properties=&quot; + properties);</span><br><span class="line"></span><br><span class="line">//通过k 获取对应值</span><br><span class="line">System.out.println(properties.get(&quot;lic&quot;));//88</span><br><span class="line"></span><br><span class="line">//删除</span><br><span class="line">properties.remove(&quot;lic&quot;);</span><br><span class="line">System.out.println(&quot;properties=&quot; + properties);</span><br><span class="line"></span><br><span class="line">//修改</span><br><span class="line">properties.put(&quot;john&quot;, &quot;约翰&quot;);</span><br><span class="line">System.out.println(&quot;properties=&quot; + properties);</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在开发中，选择什么集合实现类，主要取决于业务操作特点，然后根据集合实现类特性进行选择，分析如下:</p><ol><li><p>先判断存储的类型(一组对象或一组键值对)</p></li><li><p>一组对象: Collection接口</p><ul><li><p>允许重复: List<br>增删多: LinkedList [底层维护了一个双向链表]</p><p>改查多: ArrayList [底层维护Object类型的可变数组]</p></li><li><p>不允许重复: Set</p><p>无序: HashSet [底层是HashMap，维护了一个哈希表 即(数组+链表+红黑树)]</p><p>排序: TreeSet</p><p>插入和取出顺序一致: LinkedHashSet ， 维护数组+双向链表</p></li></ul></li><li><p>一组键值对: Map</p><ul><li>键无序: HashMap [jdk8: 数组+链表+红黑树]</li><li>键排序: TreeMap</li><li>键插入和取出顺序一致: LinkedHashMap</li><li>读取文件Properties</li></ul></li></ol><h1 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h1><p>Collections工具类介绍</p><ol><li>Collections是一个操作 Set、List 和Map等集合的工具类</li><li>Collections中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作</li><li>只有一个构造器，方法极多</li></ol><hr><p>排序操作: (均为static方法)</p><ol><li>reverse(List)：反转List中元素的顺序</li><li>shuffle(List)：对List集合元素进行随机排序</li><li>sort(List)：根据元素的自然顺序对指定List集合元素按升序排序</li><li>sort(List, Comparator)：根据指定的Comparator产生的顺序对List 集合元素进行<br>排序</li><li>swap(List, int, int)：将指定list集合中的i处元素和j处元素进行交换</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-抽象类和接口</title>
      <link href="/2023/05/20/Java07%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/"/>
      <url>/2023/05/20/Java07%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>关键字：abstract</p><p>当父类的某些方法需要声明，却不知道如何实现时，可以将其声明为抽象方法。这个时候，要将该类声明为 <code>abstract</code> 类。</p><p>抽象类的价值更多是用于设计。设计者设计好后，让子类继承并实现。也是考官爱问的考点。</p><p>定义抽象类：<code>访问修饰符 abstract 类名&#123;...&#125;</code></p><p>定义抽象方法：<code>访问修饰符 abstract 返回值 方法名(形参列表);</code></p><blockquote><p>无方法体，不写{ }</p></blockquote><h3 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h3><ol><li>抽象类不能被实例化</li><li>抽象类不一定包含抽象方法。也就是说，<strong>抽象类可以没有 <code>abstract</code>方法</strong></li><li><strong>一旦包含 abstract 方法，则该类一定要声明为 abstract</strong></li><li><code>abstract</code> <strong>只能修饰 类 和 方法</strong>，不能修饰其他。</li><li>抽象类可以有任意成员（非抽象方法、构造器、静态属性等）。即，<strong>抽象类本质还是类</strong>。</li><li>抽象方法不能有主体。即，抽象方法不能实现。</li><li>如果一个类继承了 <code>abstract</code> 类，则其必须实现所有 <code>abstract</code> 方法，除非其自己也是 <code>abstract</code> 类。</li><li>抽象方法不能用 <code>private</code> <code>final</code> <code>static</code> 来修饰。因为，这些关键词都和<strong>重写</strong>相违背。</li></ol><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>语法：<code>interface 接口名&#123;...&#125;</code></p><p>Java是单继承的，接口帮助增强了继承的性能。</p><p>接口就是给出一些没有实现的方法，封装到一起，到某个类要用的时候，再根据具体情况把这些方法写出来。在接口中，抽象方法可以省略 <code>abstract</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class 类名 implements 接口名&#123;...必须实现接口的抽象方法...&#125;</span><br></pre></td></tr></table></figure><blockquote><p>JDK 7.0 以前，接口中只能是抽象方法。而 JDK 8.0 后，接口可以有静态（<code>static</code>）方法、默认（<code>default</code>）方法。</p></blockquote><p>接口中可以存在：</p><ul><li>属性（只有静态 <code>static</code> 属性，可以不加 <code>static</code> 关键字）</li><li>方法（抽象 <code>abstract</code> 方法、默认 <code>default</code> 实现方法、静态 <code>static</code> 方法）</li></ul><h2 id="使用细节-1"><a href="#使用细节-1" class="headerlink" title="使用细节"></a>使用细节</h2><ol><li>接口 不能被实例化。</li><li>接口中所有方法都是 <code>public</code> 方法。接口中的 抽象方法 可以不用 <code>abstract</code> 修饰。</li><li>一个普通类实现接口，就必须把该接口所有方法都实现。（快捷键 <code>alt + enter</code>）</li><li>抽象类实现接口，可以不用实现接口的方法。</li><li>一个类可以同时实现多个接口。<code>class Name implements In1,In2&#123;...&#125;</code></li><li>接口中的属性只能是 <code>final</code> 的，并且是 <code>public static final</code> 修饰符。修饰符就算不写，还是这样。</li><li>接口中属性的访问形式：<code>接口名.属性名</code>（静态属性）</li><li>接口不能 <strong>继承</strong> 其他的类，但可以 <strong>继承</strong> 多个别的接口。（不是也不能 实现 别的接口）</li><li>接口的修饰符只能是 <code>public</code> 和 默认。这点和类的修饰符相同</li></ol><h2 id="实现接口-vs-继承类"><a href="#实现接口-vs-继承类" class="headerlink" title="实现接口 vs 继承类"></a>实现接口 vs 继承类</h2><ol><li>当子类继承父类，就自动拥有父类的所有功能。如果需要扩展功能，可以通过接口方式扩展。</li><li>可以认为，接口 是对于 Java 单继承机制的补充。</li><li>继承的价值主要在于：解决代码的复用性和可维护性。</li><li>接口的价值主要在于：设计。设计好各种规范，让其他类去实现这些方法。</li><li>接口比继承更加灵活。继承需要满足 is - a 的关系，而接口只需要满足 like - a 关系。</li><li>接口在一定程度上实现代码解耦。（即：接口规范性 + 动态绑定机制）</li></ol><h2 id="接口的多态特性"><a href="#接口的多态特性" class="headerlink" title="接口的多态特性"></a>接口的多态特性</h2><ol><li><p>多态参数（接口的引用可以指向实现了接口的类的对象）</p><blockquote><p><code>viod work(Inerface01 i1)&#123;...&#125;</code> 参数可以传入任意实现该接口的类</p></blockquote></li><li><p>多态数组</p></li><li><p>接口存在多态传递现象</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 抽象类 </tag>
            
            <tag> 接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-面向对象特性</title>
      <link href="/2023/05/16/Java06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%80%A7/"/>
      <url>/2023/05/16/Java06%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>包的作用：</p><ol><li>区分相同名字的类</li><li>当类很多时，便于管理 </li><li>控制访问范围</li></ol><p>语法：<code>package com.name</code> 其中 <code>com</code> <code>name</code> 分别是 一级 和 二级目录，用 <code>.</code> 分隔</p><p>包的本质：就是创建不同 文件夹&#x2F;目录 来保存 类 文件</p><p><strong>使用：</strong></p><ol><li><p>先引入包，之后创建对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import com.name.T;</span><br><span class="line">...</span><br><span class="line">T tools = new T();</span><br></pre></td></tr></table></figure></li><li><p>不引入包，而在创建对象时写全路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.name.T tools = new com.name.T();</span><br></pre></td></tr></table></figure></li></ol><p><strong>命名规则：</strong></p><ul><li>只能包含 数字 <code>1 2 3</code>、字母 <code>a b A b</code>、下划线 <code>_</code>、小圆点 <code>.</code></li><li>不能用 数字 开头。每级目录都不能。</li></ul><p><strong>命名规范：</strong></p><ul><li>全小写字母 + 小圆点</li><li><code>com.公司名.项目名.业务模块名</code></li></ul><p><strong>常用的包：</strong></p><p><code>java.lang</code>：基本包，默认引入，不需要再引入</p><p><code>java.util</code>：系统提供的工具包。工具类。</p><p><code>java.net</code>：网络包，网络开发。</p><p><code>java.awt</code>：Java 的界面开发，GUI。</p><p><strong>引入包：</strong></p><ul><li>只引入该包下的一个类：<code>import java.util.Scanner</code></li><li>引入该包的所有内容（不建议）：<code>import java.util.*</code></li></ul><p><strong>使用细节：</strong></p><ol><li><p><code>package</code> 的作用是声明当前类所在的包，要放在 类 的 最上面。一个 类 中最多有一句 <code>package</code></p></li><li><p><code>import</code> 放在 <code>package</code> 下面，类定义 前面。可以有多条语句，且没有顺序要求</p></li><li><p>编译器编译时 <strong>不会</strong> 检查目录结构。</p><p>即使一个包处于错误的目录下（只要其不依赖其他包）也可能通过编译。</p><p>但是，虚拟机会找不到该包，最终程序无法运行。</p></li><li><p>从 1.2 版本开始，用户不能再把包放在 java. 开头的目录下了。若如此做，这些包会被禁止加载</p></li></ol><p><strong>静态导入</strong>:</p><p>有一种 import 语句允许导入静态方法和字段，而不只是类</p><p>比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import static java.lang.Math.*;</span><br></pre></td></tr></table></figure><p>这个场合，使用 Math 包内的静态方法、字段时，不需要再添加类名前缀。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double n = pow(10, 5);//本来是 double n = Math.pow(10, 5);</span><br><span class="line">double pi = PI;//本来是 double pi = Math.PI;</span><br></pre></td></tr></table></figure><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><blockquote><p>封装（encapsulation）就是把抽象出的 数据[属性] 和对数据的 操作[方法] 封装在一起。数据 被保护在内部，程序的其他部分只有通过被授权的 操作[方法]，才能对数据进行操作。</p></blockquote><p>封装的好处：</p><ul><li>隐藏实现细节</li><li>可以对数据进行验证，保证安全合理</li></ul><p><strong>实现步骤：</strong></p><ol><li>将属性私有化 <code>private</code></li><li>提供一个公共的 <code>set</code> 方法，用于对属性判断并赋值</li><li>提供一个公共的 <code>get</code> 方法，用于获取属性的值</li></ol><blockquote><p>一般都快捷键生成</p></blockquote><p><strong>JAR 文件</strong>：</p><p>为了避免向用户提供包含大量类文件的复杂目录结构，可以将 Java 程序打包成 JAR （Java 归档）文件。</p><p>一个 JAR 文件既可以包含类文件，也可以包含诸如图像和声音等其他类型的文件。</p><p>JAR 文件是压缩的。其使用了 ZIP压缩格式。</p><blockquote><p>Maven里面就经常见到 jar 和 war</p></blockquote><p><strong>创建 JAR：</strong></p><p>使用 jar 工具以制作 JAR 文件。该工具在 jdk&#x2F;bin 目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar cvf 包名 文件名1 文件名2 ...</span><br></pre></td></tr></table></figure><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>关键字：extends</p><p>继承：能解决代码复用，让我们的编程更接近人类思维。当多个类存在相同的 属性（变量）和 方法 时，可以从这些类中抽象出 父类（基类&#x2F;超类）。在 父类 中定义这些属性·方法，所有的子类不需要重新定义这些属性和方法，只需要通过 extends 来声明继承父类即可。</p><p>通过继承的方法，代码的复用性提高了，代码的维护性和拓展性也提高了。</p><p>定义类时可以指明其父类，也能不指明。不指明的场合，默认继承 Object 类。</p><p>所有类有且只有一个父类。Object 是所有类的直接或间接父类。只有 Object 本身没有父类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Son extends Father &#123;&#125;;// Son 类继承了 Father 类</span><br></pre></td></tr></table></figure><h2 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h2><ol><li>子类 继承了所有属性和方法，但私有（<code>private</code>）的 属性·方法 不能在 子类 直接访问。要调用父类提供的 公共（<code>public</code>）等方法 访问。</li><li>子类 必须调用 父类 的 构造器，完成 父类 的 初始化。</li><li>当创建 子类对象 时，不管使用 子类的哪个构造器，默认情况下总会调用 父类的无参构造器。如果 父类 没有提供 无参构造器，则必须在 子类的构造器 中用 <code>super</code> 去指定使用 父类的哪个构造器 完成 对父类的初始化。否则编译不能通过。</li><li>如果希望指定调用 父类的某构造器，则显式地调用一下：<code>super(形参列表);</code></li><li><code>super</code> 在使用时，必须放在构造器第一行。<code>super</code> 只能在构造器中使用。</li><li>由于 <code>super</code> 与 <code>this</code> 都要求放在第一行，所以此两个方法不能同时存在于同一构造器。</li><li>Java 所有的类都是 <code>Object</code> 的子类。换言之，<code>Object</code> 是所有类的父类。</li><li>父类构造器的调用不限于直接父类，将持续向上直至追溯到顶级父类 <code>Object</code></li><li>子类 最多只能直接继承 一个 父类。即，Java 中是 单继承机制。</li><li>不能滥用继承。子类 和 父类 之间必须满足 is - a 的逻辑关系。</li></ol><h2 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h2><p>super 代表父类的引用。用于访问父类的 属性、方法、构造器。</p><p><strong>super 的使用：</strong></p><ul><li><code>super.属性名</code>：访问父类的属性。不能访问父类的私有（private）属性。</li><li><code>super.方法名(形参列表)</code>：访问父类的方法。不能访问父类的私有（private）方法。</li><li><code>super(参数列表);</code>：访问父类的构造器。此时，super 语句必须放在第一句。</li></ul><p><strong>使用细节：</strong></p><ol><li>调用父类构造器，好处是分工明确。父类属性由父类初始化，子类由子类初始化。</li><li>子类中由和父类中成员（属性和方法）重名时，要调用父类成员必须用 <code>super</code>。没有重名的场合，<code>super</code>、<code>this</code> 及直接调用的效果相同。</li><li><code>super</code> 的访问不限于直接父类。如果爷爷类和本类中都有同名成员也能使用。如果多个基类中都有同名成员，则遵循就近原则。</li></ol><h2 id="方法重写-x2F-覆盖"><a href="#方法重写-x2F-覆盖" class="headerlink" title="方法重写 &#x2F; 覆盖"></a>方法重写 &#x2F; 覆盖</h2><blockquote><p>方法重写&#x2F;覆盖（Override）：如若子类有一个方法，和父类的某方法的 <strong>名称</strong>、<strong>返回类型</strong>、<strong>参数</strong> 一样，那么我们就说该子类方法 覆盖 了那个父类方法。</p></blockquote><p><strong>使用细节：</strong></p><ol><li><p><strong>子类方法的参数，方法名称，要和父类方法完全一致。</strong></p></li><li><p>子类方法的返回类型需和父类方法 一致，或者是父类返回类型的子类。</p><p>根据相关语法糖，实际上生成了一个中间方法，这个方法的返回值是父类方法的返回值，根据多态，中间方法可以接受所有父类方法的返回值的子类</p></li><li><p>子类方法 <strong>不能缩小</strong> 父类方法的访问范围（访问修饰符）</p></li></ol><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态：方法 或 对象 有多种形态。多态 是面向对象的第三大特征，是建立在 封装 和 继承 的基础之上的</p><p>多态的前提：两个对象 &#x2F; 类存在继承关系。</p><h2 id="多态的体现"><a href="#多态的体现" class="headerlink" title="多态的体现"></a>多态的体现</h2><ol><li><p>方法的多态：重写 和 重载 体现了 方法的多态。</p></li><li><p><strong>对象的多态：</strong></p><p>一个对象的 编译类型 和 运行类型 可以不一致。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = new Dog();</span><br></pre></td></tr></table></figure><p>上例，编译类型是 <code>Animal</code>，运行类型是子类 <code>Dog</code></p></li><li><p>编译类型在定义对象时就确定了，不能改变。</p></li><li><p>运行类型是可以变化的。</p><p>上例中，再让 <code>animal = new Cat();</code>，这样，运行类型变为了 <code>Cat</code></p></li><li><p>编译类型看定义时 <code>=</code> 的左边，运行类型看 <code>=</code> 的右边</p></li><li><h2 id="多态的向下转型："><a href="#多态的向下转型：" class="headerlink" title="多态的向下转型："></a>多态的向下转型：</h2></li><li><p>属性没有重写一说。<strong>和 方法 不同，属性的值 看编译类型。</strong></p></li><li><p><code>instanceof</code> 比较操作符。用于判断对象类型是否是某类型或其子类型。此时判断的是 <strong>运行类型</strong>。</p></li></ol><h2 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h2><ul><li>本质：父类的引用指向了子类的对象。</li><li>语法：父类类型 引用名 &#x3D; new 子类类型(参数列表);</li><li>编译类型看左边，运行类型看右边。</li><li>可以调用父类中的所有成员，但不能调用子类特有的成员，而且需要遵守访问权限。因为在编译阶段，能调用哪些成员是由编译类型决定的。</li><li>最终的运行结果要看子类的具体实现。实际上先在运行类型（子类）中找相关的属性和方法，没有在调用编译类型（父类）的</li></ul><h2 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h2><ul><li><p>语法：<code>子类类型 引用名 = (子类类型)父类引用;</code></p><p>向下转型其实和 强制类型转换有点像。</p><p><code>Dog dog = (Dog)animal;</code></p></li><li><p>只能强转父类的引用，不能强转父类的对象。</p></li><li><p>要求父类的引用必须指向的是当前目标类型的对象。即上例中的 <code>animal</code> 运行类型需是 <code>Dog</code>，换成cat会报错</p></li><li><p>向下转型后，可以调用子类类型中的所有成员。</p></li></ul><h2 id="理解方法调用"><a href="#理解方法调用" class="headerlink" title="理解方法调用"></a>理解方法调用</h2><p>在对象上调用方法的过程如下：</p><ol><li><p>编译器查看对象的声明类型和方法名。该类和其父类中，所有同名方法（包括参数不同的方法）都被列举。</p><p>至此，编译器已经知道所有可能被调用的方法。</p></li><li><p>编译器确认方法调用中提供的参数类型。</p><p>那些列举方法中存在参数类型完全匹配的方法时，即调用该方法。</p><p>没有发现匹配方法，抑或是发现经过类型转换产生了多个匹配方法时，就会报错</p><p>至此，编译器已经知道要调用方法的名字和参数类型</p></li><li><p>如若是 private 方法、static 方法、final 方法、构造器，那么编译器将能准确知道要调用哪个方法。这称为 <strong>静态绑定</strong></p><p>与之相对的，如果调用方法依赖于隐式参数类型，那么必须在运行时 <strong>动态绑定</strong></p></li><li><p>程序运行并采取动态绑定方法时，JVM 将调用那个 <strong>实际类型</strong> 对应的方法。</p></li></ol><p>倘若每次调用方法都进行以上搜索，会造成庞大的时间开销。为此，JVM 预先为每个类计算了 <strong>方法表</strong>。</p><p>方法表中列举了所有方法的签名与实际调用的方法。如此，每次调用方法时，只需查找该表即可。</p><p>特别地，使用 super 关键字时，JVM 会查找其父类的方法表。</p><p><strong>动态绑定机制：</strong></p><ul><li>当调用对象方法的时候，该方法和该对象（隐式参数）的内存地址&#x2F;运行类型绑定。</li><li>当调用对象属性时，没有动态绑定机制。于是哪里声明，哪里调用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 类与对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-类与对象</title>
      <link href="/2023/05/14/Java05%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
      <url>/2023/05/14/Java05%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>面向对象是一种开发软件的方法，使分析、设计和实现一个系统的方法尽可能接近人们认识一个系统的方法。包括三个方面：面向对象分析、面向对象设计、面向对象程序设计。</p><p>Java 语言是纯面向对象的语言。其所有数据类型都有相应的类，程序可以完全基于对象编写。</p><p>面向对象和面向过程的区别：</p><p>两者的主要区别在于解决问题的方式不同：</p><ul><li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li><li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li></ul><p>优缺点：</p><p>面向过程：</p><ul><li><p>优点：</p><p>流程化使得编程任务明确，在开发之前基本考虑了实现方式和最终结果，具体步骤清楚，便于节点分析。</p><p>效率高，面向过程强调代码的短小精悍，善于结合数据结构来开发高效率的程序。</p></li><li><p>缺点：</p><p>需要深入的思考，耗费精力，代码重用性低，扩展能力差，后期维护难度比较大。</p></li></ul><p>面向对象：</p><ul><li><p>优点:</p><p>结构清晰，程序是模块化和结构化，更加符合人类的思维方式；</p><p>易扩展，代码重用率高，可继承，可覆盖，可以设计出低耦合的系统；</p><p>易维护，系统低耦合的特点有利于减少程序的后期维护工作量。</p></li><li><p>缺点：</p><p>开销大，当要修改对象内部时，对象的属性不允许外部直接存取，所以要增加许多没有其他意义、只负责读或写的行为。这会为编程工作增加负担，增加运行开销，并且使程序显得臃肿。</p><p>性能低，由于面向更高的逻辑抽象层，使得面向对象在实现的时候，不得不做出性能上面的牺牲，计算时间和空间存储大小都开销很大。</p></li></ul><h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><p>类就是数据类型。可以是int也可以是自定义类</p><p>对象就是其中具体的实例。可以是100也可以是现实生活的物体</p><p>从类到对象，可以称为创建一个对象，也可以说实例化一个对象，或者把对象实例化</p><ol><li>类是抽象的、概念的，代表一类事物</li><li>对象是具体的、实际的，代表一个个具体事物</li><li>类是对象的模板，对象是类的一个个体，对应一个实例</li></ol><p>类一共有5种成员：<strong>属性、方法、构造器、代码块、内部类</strong></p><h2 id="属性-x2F-成员变量"><a href="#属性-x2F-成员变量" class="headerlink" title="属性&#x2F;成员变量"></a>属性&#x2F;成员变量</h2><p>属性可以是基本数据类型，也可以是引用数据类型。</p><ol><li><p>属性的定义语法同变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 属性类型 属性名</span><br></pre></td></tr></table></figure><ul><li>访问修饰符：控制属性的访问范围。有四种：publie protected 默认(空) private</li></ul></li><li><p>属性的定义类型可以为任意类型，包含基本类型或引用类型</p></li><li><p>属性如果不赋值，有默认值。规则同数组</p></li></ol><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><ol><li><p>先声明再创建：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cat cat1;      //声明对象cat1</span><br><span class="line">cat1 = new Cat();//创建对象</span><br></pre></td></tr></table></figure></li><li><p>直接创建：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cat cat2 = new Cat();</span><br></pre></td></tr></table></figure></li></ol><p>注意事项：</p><ol><li><p>声明对象的场合，只是在内存中建立了一个引用。此时，该地址引用不指向任何内存空间。</p><p>对象的引用，也被称为对象的句柄。</p></li><li><p>使用 new 运算符创建对象实例时，会为对象分配空间，就会调用类的构造方法。那之后，会将该段内存的首地址赋给刚才建立的引用</p></li></ol><h3 id="访问对象"><a href="#访问对象" class="headerlink" title="访问对象"></a>访问对象</h3><p>基本语法：对象名.属性名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(cat1.name);</span><br></pre></td></tr></table></figure><h3 id="类与对象的内存访问机制"><a href="#类与对象的内存访问机制" class="headerlink" title="类与对象的内存访问机制"></a>类与对象的内存访问机制</h3><blockquote><p>JVM内存空间：</p><p>栈：一般存放基本数据类型（局部变量）</p><p>堆：存放对象（如Cat cat1 &#x3D; new Cat()，是在这里开辟的空间，所有 new 的变量都在这里）</p><p>方法区：常量池（常量，比如字符串），类加载信息</p></blockquote><ol><li>创建对象时，先加载类信息，然后在堆中分配空间，栈中的对象名被赋予指向那个空间的地址。</li><li>之后进行指定初始化。该对象的属性中，是基本数据类型的直接记录在堆中；是字符串的记录一个地址，该地址指向方法区，那里的常量池有该字符串。</li></ol><h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><p>在某些情况下，我们需要定义成员方法。比如Cat除了有属性外，还可以有一些行为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回数据类型 方法名(形参列表)&#123;</span><br><span class="line">方法体语句;</span><br><span class="line">returen 返回值;//返回数据类型是 void 的场合，return语句不是必须的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>方法名必须是一个合法的标识符</p></li><li><p>返回类型即返回值的类型。如果方法没有返回值，应声明为void</p></li><li><p>修饰符段可以有几个不同的修饰符。</p><p>比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static strictfp final void method() &#123;</span><br><span class="line">        System.out.println(&quot;哎呦~你干嘛&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>参数列表是传递给方法的参数表。各个元素间以,分隔。每个元素由一个类型和一个标识符表示的参数组成。特别地，参数类型…标识符这样的参数被称为可变参数</p></li><li><p>方法体是实际要执行的代码块。方法体一般用return作为方法的结束。</p></li></ol><p>使用成员方法，能提高代码的复用性。而且能把实现的细节<strong>封装</strong>起来，供其他用户调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Cat&#123;</span><br><span class="line">String name;</span><br><span class="line">int age;</span><br><span class="line">public void speak()&#123;</span><br><span class="line">  System.out.println(&quot;哎呦~你干嘛&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>方法写好后，不去调用就不会输出</li><li>先创建对象，然后调用方法即可</li><li>静态方法也可以用对象调用，但是不推荐</li></ol><h3 id="方法的调用机制"><a href="#方法的调用机制" class="headerlink" title="方法的调用机制"></a>方法的调用机制</h3><ol><li>当程序执行到方法时，在栈中开辟一个新的<strong>栈</strong>空间。</li><li>当方法执行完毕，或执行到return语句时，就会返回（计算机组成原理里面有提到，JVM中也有讲解）</li><li>把新栈空间中的返回值返回main栈中调用方法的地方</li><li>返回后，继续执行该方法的后续代码</li><li>当一个方法执行完毕，或遇到return就会返回。遵守谁调用就返回给谁。同时当方法执行完毕或返回时，该方法也执行完毕。</li></ol><p>方法使用细节</p><ol><li><p>访问修饰符：作用是控制方法的使用范围。</p><ul><li>不写（默认访问控制范围）</li><li>public：公共</li><li>protected：受保护</li><li>private：私有</li></ul></li><li><p>返回数据类型：</p><ul><li>一个方法最多有一个返回值。要返回多个结果可以使用<strong>数组或者集合</strong>。</li><li>返回类型为任意类型。包括基本数据类型和引用数据类型。</li><li>如果方法要求有返回数据类型，则方法体中最后的执行语句必为return值，且返回类型必须和return的值一致。</li><li>如果返回数据类型为void，则可以不写return语句</li></ul></li><li><p>方法名：</p><ul><li>遵循驼峰命名法，最好见名知意，表达出该功能的意思。</li></ul></li><li><p>参数列表（形参列表）：</p><ul><li>一个方法可以有0个参数，也可以有多个参数。参数间用,间隔。</li><li>参数类型可以为任意类型，包含基本类型和引用类型。</li><li>调用带参数的方法时，一定对应着参数列表传入相同类型或兼容类型的参数。</li><li>方法定义时的参数称为形式参数，简称形参；方法调用时的参数（传入的参数）称为实际参数，简称实参。实参与形参的类型、个数、顺序必须一致。</li></ul></li><li><p>方法体：</p><ul><li>写完成功能的具体语句。方法中不能再定义方法。即：方法不能嵌套定义。</li></ul></li><li><p>调用细节：</p><ul><li><p>同一个类中的方法调用，可以直接调用。</p></li><li><p>跨类的方法调用，需要创建新对象，然后通过对象调用方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class C1&#123;</span><br><span class="line">public void m1()&#123;</span><br><span class="line">&#125;</span><br><span class="line">public void m2()&#123;</span><br><span class="line">   m1();//同一个类中的方法调用，可以直接调用。</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C2&#123;</span><br><span class="line">public void m3()&#123;</span><br><span class="line">   C1 c = new C1();</span><br><span class="line">   c.m2();//跨类的方法调用，需要创建新对象，然后再调用方法。</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="成员方法传参机制"><a href="#成员方法传参机制" class="headerlink" title="成员方法传参机制"></a>成员方法传参机制</h3><p>Java语言对对象采用的是<strong>值传递</strong>，方法得到的总是那个传入对象的副本。java没有引用传递机制</p><ul><li><p>方法不能修改基本数据类型的参数。基本数据类型传递的是一个值，形参不影响实参。</p></li><li><p>方法可以改变对象参数的状态。</p><p>引用类型传递的是一个地址，形参和实参指向一处，两者总会相关。</p><p>但改变那个形参地址指向的场合，实参的指向不会改变</p></li></ul><h3 id="方法重载-x2F-Overload"><a href="#方法重载-x2F-Overload" class="headerlink" title="方法重载&#x2F;Overload"></a>方法重载&#x2F;Overload</h3><p>方法重载（Overload）：Java中允许同一类中，多个同名方法的存在，但要求形参列表不一致。</p><p><strong>使用细节：</strong></p><ol><li>方法名：必须相同</li><li>形参列表：必须不同（参数的类型、个数、顺序，这其中至少一个不同）</li><li>返回值：无要求，可以相同，可以不同</li></ol><p><strong>签名：</strong>由于重载的存在，要完整的描述一个方法，要指定方法名及参数类型。这叫做方法的签名。</p><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><blockquote><p>Java允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法。</p></blockquote><p>语法：访问修饰符 返回类型 方法名（数据类型… 形参名）{代码块;}</p><p><strong>使用细节</strong></p><ol><li>可变参数的实参可以是0个，也可以是任意多个。</li><li>可变参数的实参可以是数组</li><li>可变参数本质就是数组</li></ol><p><strong>相关语法糖</strong>：底层是用等长数组存放的参数，所以要求可变参数放最后，用的时候在数组中依次取值</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ol><li>在Java编程中，主要的变量就是属性（成员变量）和局部变量。</li><li>我们说的局部变量一般是指在成员方法中定义的变量。</li><li>作用域的分类<ul><li>全局变量：也就是属性，作用域为整个类体</li><li>局部变量：除了属性外的其他变量。作用域为定义它的代码块中</li></ul></li><li>全局变量（属性）可以不赋值直接使用，那个场合有默认值。局部变量必须赋值使用</li></ol><p><strong>使用细节</strong></p><ol><li><p>属性和局部变量可以重名，访问时遵循就近原则</p></li><li><p>在同一作用域中，两个局部变量不能重名</p></li><li><p>属性的生命周期较长。其伴随对象的创建而创建，伴随对象的销毁而销毁。</p><p>局部变量生命周期较短。其伴随代码块的执行而创建，伴随代码块的结束而销毁。</p></li><li><p>全局变量&#x2F;属性可以被本类使用，也可以被其他类（通过对象）使用。</p><p>局部变量只能被本类的对应方法中调用</p></li><li><p>全局变量&#x2F;属性<strong>可以加</strong>修饰符</p><p>局部变量<strong>不能加</strong>修饰符</p></li></ol><h2 id="构造方法、构造器"><a href="#构造方法、构造器" class="headerlink" title="构造方法、构造器"></a>构造方法、构造器</h2><blockquote><p>构造方法又叫构造器（constructor），是类的一种特殊的方法。它的主要作用是完成对新对象的初始化。</p></blockquote><p>语法：[修饰符]方法名(形参列表){方法体}</p><ol><li>构造器的修饰符可以是默认。也可以是别的</li><li>参数列表规则同成员方法</li></ol><p><strong>使用细节</strong></p><ol><li>构造器本质也是方法。所以，可以构造器<strong>重载</strong>，但是不能重写</li><li>构造器名和类名相同</li><li>构造器无返回值，不能写返回类型</li><li>构造器是完成对象的初始化，而不是创建</li><li>创建对象时，系统自动调用构造器</li><li>如果程序员没有定义构造器，系统会自动给类生成一个无参构造器（默认构造器）</li><li>一旦定义了自己的构造器，就不能用无参构造器了。除非显式的定义一个无参构造器</li></ol><h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a><strong>流程分析</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = new Person(&quot;Amy&quot;, 10);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">class Person&#123;</span><br><span class="line">String name;</span><br><span class="line">int age = 20;</span><br><span class="line">public Person(String pName, int pAge)&#123;</span><br><span class="line">name = pName;</span><br><span class="line">age = pAge;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>加载类信息（方法区）</p></li><li><p>在堆中开辟空间（地址）</p></li><li><p>完成对象初始化</p><ul><li><p>首先默认初始化。age &#x3D; 0; name &#x3D; null</p></li><li><p>之后显式初始化。age &#x3D; 20; name &#x3D; null</p><p>其中，显式初始化和代码块初始化按编写的先后顺序依次进行。</p></li><li><p>之后构造器的初始化。age &#x3D; 10; name &#x3D; “Amy”</p></li></ul></li><li><p>把对象在堆中的地址，返回给 p1</p></li></ol><h2 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h2><p>JVM 会给每个对象分配 this 代表当前对象。相当于在 堆 中，this 指向自己（对象）</p><blockquote><p>在类定义的方法中，Java 会自动用 this 关键字把所有变量和方法引用结合在一起。</p><p>遇到有同名的局部变量的场合，需要程序员加入 this 关键字进行区分。不加入 this 关键字的场合，Java 遵循就近原则。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Example&#123;</span><br><span class="line">    int n = 0;</span><br><span class="line">public void act(int n) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个类的 act() 方法实际有 2 个参数。对其调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Example e = new Exmaple();</span><br><span class="line">e.act(100);</span><br></pre></td></tr></table></figure><p>可见，出现在方法名前的参数 e，以及出现在方法名后的括号中的参数 100</p><p>出现在方法名前的参数被称为<strong>隐式参数</strong>也称为 方法调用的 目标 或 接收者）</p><p>出现在方法名后的参数被称为<strong>显式参数</strong>，就是所谓的实参</p><p>在每一个方法中，用 this 指代隐式参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void act(int n) &#123;</span><br><span class="line">    this.n = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，再以相同方式调用方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.act(100);// &lt;———— 相当于 e.n = 100;</span><br></pre></td></tr></table></figure><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol><li><p>this 关键字可以用来访问本类的属性、方法、构造器</p></li><li><p>this 用于区分当前类的 属性 和 局部变量</p></li><li><p>访问本类中成员方法的语法：this.方法名</p></li><li><p>访问构造器的语法：this(参数列表);</p><p>注意：只能在构造器中访问另一个构造器。而且，如果有这个语法，必须放置在第一条语句。</p></li><li><p>this 不能在类定义的 外部 使用，只能在类定义的方法中使用</p></li></ol><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>代码块：又称为初始化块。属于类中的成员。类似于方法，将逻辑语句封装在方法体中，通过 <code>&#123; &#125;</code> 包围起来。和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类 显式调用，而是<strong>加载类时，或创建对象时隐式调用。</strong></p><p>语法：<code>[修饰符]&#123;代码&#125;;</code></p><p>注意：</p><ol><li>修饰符 是可选项，可不写。要写的话，只能写 <code>static</code></li><li>代码块分为两类：<ul><li>静态代码块：有 <code>static</code></li><li>普通代码块：无 <code>static</code></li></ul></li><li>逻辑语句可以为任意的逻辑语句。</li><li><code>;</code> 可以写，也可以省略。建议写上。</li><li>代码块相当于另一种形式的构造器（构造器的补充机制），可以做初始化操作</li><li>如果多个构造器中都有重复语句，就可以抽取到初始化块中，提高代码复用率。这样，不管用哪个构造器，都会执行代码块</li></ol><h3 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h3><p>static代码块：作用是对类进行初始化。<strong>随着 类的加载 会且只会执行一次</strong>。相对的：普通代码块每创建一个对象就执行一次。</p><p>**类什么时候被加载？ **</p><ul><li>创建对象实例时（new）</li><li>创建子类对象实例，父类也会加载</li><li>使用类的静态成员时（父类也会加载）</li></ul><p>以上情况下类会被加载。加载后不需要再次加载，所以，静态代码块也只会执行一次。</p><ol><li><p>创建一个对象时，在 <strong>一个类里</strong> 调用顺序是：</p><ul><li>调用静态代码块 和 静态属性初始化。这两者优先级相同，多个存在时按照定义的顺序依次执行。</li><li>调用普通代码块 和 普通属性初始化。这两者优先级也相同。</li><li>调用构造器。</li></ul></li><li><p><code>构造器</code> 的最前面其实隐含了 <code>super();</code> 和 <code>调用普通代码块</code>。而静态相关的代码块，属性初始化，在类加载时就执行完毕了。</p><p>这样，创建一个对象时，在 <strong>有继承关系的多个类里</strong> 调用顺序是：</p><ul><li>父类 静态代码块 和 静态初始化</li><li>子类 静态代码块 和 静态初始化</li><li>父类 普通代码块 和 普通初始化</li><li>父类 构造器</li><li>子类 普通代码块 和 普通初始化</li><li>子类 构造器</li></ul></li><li><p>静态代码块 只能调用 静态成员。普通代码块 能调用 任意成员。</p></li></ol><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>一个类的内部又完整的嵌套了另一个类结构。被嵌套的类被称为 内部类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Outer&#123;//外部类</span><br><span class="line">class Inner&#123;//内部类</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Other&#123;//外部其他类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部类的最大特点是可以直接访问私有属性，并且可以体现类与类之间的包含关系。</p><h3 id="四种内部类"><a href="#四种内部类" class="headerlink" title="四种内部类"></a>四种内部类</h3><ol><li><p>定义在外部类的局部位置上</p><ul><li>局部内部类：有 类名</li><li>匿名内部类：无 类名</li></ul></li><li><p>定义在外部类的成员位置上</p><ul><li>成员内部类：无 <code>static</code> 修饰</li><li>静态内部类： <code>static</code> 修饰的类</li></ul></li></ol><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>局部内部类：定义在外部类的局部位置上，并且有类名。</p><p>局部位置：比如：方法&#x2F;代码块里，和局部变量一个位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Outer &#123;//外部类</span><br><span class="line">    public void tools01() &#123;</span><br><span class="line">        class Inner &#123;//局部内部类</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用细节:</p><ol><li><p>定义在外部类的局部位置上，并且有类名。</p></li><li><p>可以访问外部类的所有成员，包含私有成员</p></li><li><p>局部内部类可以 直接访问 外部类的成员。</p></li><li><p>不能添加 访问修饰符，因为其地位相当于局部变量。但，可以使用 <code>final</code>，因为局部变量也能用 <code>final</code></p></li><li><p>作用域 仅仅在定义它的方法或代码块中</p></li><li><p>外部类 在方法中，可以创建 局部内部类 的对象实例，然后调用方法。</p></li><li><p>外部其他类 不能访问 局部内部类</p></li><li><p>如果外部类和局部内部类的成员重名时，默认遵循就近原则。那个场合，访问外部类成员使用 <code>外部类名.this.变量名</code></p><p><code>外部类名.this</code> 本质就是 外部类的对象。即，调用了该方法（上例的 <code>tools01</code> ）的对象</p></li></ol><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类：定义在外部类的局部位置，且没有类名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new 类/接口 (参数列表) &#123;</span><br><span class="line">    类体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名内部类本质是没有名字的类，而且是内部类。同时，还是一个对象。</p><p>可以用匿名内部类简化开发</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Outer &#123;//外部类</span><br><span class="line">   public void tools01() &#123;</span><br><span class="line">       Inter whatEver = new Inter()&#123;//匿名内部类            </span><br><span class="line">       &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">interface Inter&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用细节:</p><ol><li>匿名内部类语法比较独特。其既是一个类的定义，也是一个对象。因此，从语法上看，其既有 定义类的特征，也有 创建对象的特征。</li><li>可以访问外部类的所有成员，包括私有的。</li><li>局部内部类可以 直接访问 外部类的成员。</li><li>不能添加 访问修饰符，因为其地位相当于局部变量。但，可以使用 <code>final</code>，因为局部变量也能用 <code>final</code></li><li>作用域：仅仅在定义它的方法或方法快中</li><li>外部其他类 不能访问 匿名内部类</li><li>如果外部类和匿名内部类的成员重名时，默认遵循就近原则。那个场合，访问外部类成员使用 <code>外部类名.this.变量名</code></li></ol><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>成员内部类：定义在外部类的成员位置，并且没有 <code>static</code> 修饰</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Outer&#123;</span><br><span class="line">class Inner&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 使用细节:</p><ol><li>可以直接访问外部类的所有成员，包括私有的</li><li>可以添加任意访问修饰符。因为，成员内部类的地位就是一个成员。</li><li>作用域 和外部类其他成员相同，为整个类体。</li><li>局部内部类可以 直接访问 外部类的成员。</li><li>外部类可以通过创建对象的方式访问成员内部类</li><li>外部其他类访问成员内部类<ul><li><code>Outer.Inner name = Outer.new Inner(); </code>下个方法的缩写</li><li><code>Outer.Inner name = new Outer().new Inner();</code></li><li>在外部类中编写一个方法，返回一个 <code>Inner</code> 的对象实例（就是对象的 getter）</li></ul></li><li>如果外部类和匿名内部类的成员重名时，默认遵循就近原则。那个场合，访问外部类成员使用 <code>外部类名.this.变量名</code></li></ol><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类：定义在外部类的成员位置，经由 <code>static</code> 修饰</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Outer&#123;</span><br><span class="line">static class Inner&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用细节:</p><ol><li>可以直接访问外部类的所有 <strong>静态</strong> 成员，包括私有的。但不能访问非静态成员</li><li>可以添加访问修饰符。因为，静态内部类的地位就是一个成员。</li><li>作用域 和其他成员相同，为整个类体。</li><li>静态内部类可以 直接访问 外部类的成员。</li><li>外部类可以通过创建对象的方式访问静态内部类</li><li>外部其他类访问静态内部类<ul><li><code>Outer.Inner name = new Outer.Inner();</code> 即通过类名直接访问</li><li>在外部类中编写一个方法，返回一个 <code>Inner</code> 的对象实例</li><li>如果外部类和匿名内部类的成员重名时，默认遵循就近原则。那个场合，访问外部类成员使用 <code>外部类名.变量名</code>。<em>（怎么不一样了呢？因为静态内部类访问的都是静态成员）</em></li></ul></li></ol><h1 id="static-静态"><a href="#static-静态" class="headerlink" title="static 静态"></a>static 静态</h1><h2 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h2><p>类变量：也叫 静态变量&#x2F;静态属性。是该类所有对象共享的变量。任何一个该类对象访问时都是相同的值，任何一个该类对象修改时也是同一个变量。</p><p>语法：<code>访问修饰符 static 数据类型 变量名;</code></p><p>根据 JDK 版本的不同，类变量存放在 堆 中或 方法区 中</p><ol><li><p>什么时候需要用类变量：</p><p>当我们需要让某个类的所有对象都共享一个变量时，就可以考虑使用类变量（静态变量）</p></li><li><p>类变量 与 实例变量（普通属性）的区别：</p><p>类变量 是该类所有对象共享的，而 实例变量 是每个对象独享的</p></li><li><p>加上 <code>static</code> 称为 类变量 或 静态变量。否则称为 实例变量&#x2F;普通变量&#x2F;非静态变量</p></li><li><p>静态变量 可以通过 <code>类名.类变量名;</code> 或 <code>对象名.类变量名;</code> 来访问。但 Java 设计者推荐我们用 <code>类名.类变量名;</code> 来访问。（需满足访问权限和范围）</p></li><li><p>类变量 是在加载类时就初始化了。所以，没有创建对象实例也能访问。</p></li><li><p>类变量 的生命周期是随着 类的加载 开始，随着 类的消亡 而销毁。</p></li><li><p>特别地：<strong>一个 null 对象也可以访问静态变量 &#x2F; 静态方法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Test&#123;</span><br><span class="line">    static int n = 0;</span><br><span class="line">    static void met() &#123;</span><br><span class="line">        System.out.println(++n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Test t = null;</span><br><span class="line">        System.out.println(t.n);//这样不会报错</span><br><span class="line">        t.met();//这样也不会报错</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><p>当方法使用 <code>static</code> 修饰后，就是 静态方法。静态方法就能访问静态属性。如果我们不希望创建实例，也能调用方法，这个场合把方法做成静态方法是合适的。开发工具类时就可以如此做。</p><ol><li>类方法和普通方法都是随着类的加载而加载，将结构信息存储在 方法区。</li><li>类方法中不允许使用和对象有关的关键字。所以，类方法没有 <code>this</code> 或 <code>super</code></li><li>类方法可以通过类名调用，也能通过对象名调用。普通方法不能通过类名调用。</li><li>类方法 中只能访问 类变量 或 类方法</li><li>普通方法既可以访问普通方法也可以访问类方法</li></ol><h2 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h2><p>受static 修饰的代码块，类加载的时候就运行了，在 jvm 中所有的静态代码块被合一，按照各自的顺序加载</p><h2 id="main-方法"><a href="#main-方法" class="headerlink" title="main 方法"></a>main 方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;...&#125;</span><br></pre></td></tr></table></figure><ol><li><p><code>main</code> 方法 是 JVM 调用的方法。所以该方法的 访问权限 必须为 <code>public</code></p></li><li><p>JVM 在执行 <code>main</code> 方法时不必创建对象，所以 <code>main</code>方法 必须为 <code>static</code></p></li><li><p>该方法接收 <code>String</code> 类型的数组参数。该数组中保存执行 Java 命令 时传递给所运行的类的参数。</p></li><li><p>在 <code>main</code> 方法 中，我们可以直接调用 <code>main</code> 方法 所在类的静态方法或静态属性。</p><p>工作台中：<code>javac 执行的程序.java</code></p><p> <code>java 执行的程序 参数1(arg[0]) 参数2(arg[1]) 参数3(arg[2]) ..</code></p></li><li><p>不能直接访问该类中的非静态成员，必须创建该类的一个实例后才能通过该实例访问非静态成员</p></li></ol><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1><p><code>final</code> 可以修饰 类、属性、方法、局部变量</p><p>以下情况下，可能用到 <code>final</code></p><ol><li><code>final</code> 修饰类：该类不能被继承</li><li><code>final</code> 修饰方法：该方法不能被重写</li><li><code>final</code> 修饰值：该值不能被修改</li></ol><p>使用细节：</p><ol><li><p><code>final</code> 修饰的属性又叫常量，一般用 XX_XX_XX 来命名（全大写字母+下划线）</p></li><li><p><code>final</code> 修饰的属性在定义时，必须赋初始值，且之后不能再修改。赋值可以在下列位置之一：</p><ul><li>定义时</li><li>构造器中</li><li>代码块中</li></ul><p>注意：如果 <code>final</code> 修饰的属性是**静态的(static)**，则只能在以下位置赋值。</p><ul><li>定义时</li><li>静态代码块中</li></ul></li><li><p><code>final</code> 类不能继承，但能实例化对象。对的，是可以的。</p></li><li><p>如果不是 <code>final</code> 类，但含有 <code>final</code> 方法，虽然该方法不能重写，但能被继承。</p></li><li><p><code>final</code> 类可以有 <code>final</code> 方法。可以，但没必要。</p></li><li><p><code>final</code> 不能修饰构造方法。</p></li><li><p><code>final</code> 和 <code>static</code> 搭配使用，效率更高（那个场合，虽然顺序不限，还是推荐 <code>static</code> 在前）。底层编译器做了优化处理。这样做，调用 <strong>属性（定义时赋值）</strong> 时居然 <strong>不会造成类的加载！</strong></p></li><li><p>包装类（Integer、Double、Float、Boolean、String等）都是 <code>final</code> 类，都不能被继承。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 类与对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-数组</title>
      <link href="/2023/05/10/Java04%E6%95%B0%E7%BB%84/"/>
      <url>/2023/05/10/Java04%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组：可以存放多个<strong>同一类型</strong>的数据。数组也是一种数据，是<strong>引用类型</strong>。数组本身存放的是一个地址。</p><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><p>数组可以是多个相同类型数据的组合，实现对这些数据的统一管理。数组中的元素可以是任何数据类型。包括基本类型和引用类型。</p><p>数组的下标从 0 开始。且必须在指定范围内使用，否则报错。</p><p>数组属于 引用类型，数组型数据是 对象（Object）</p><p>数组创建后，如果没有赋值，有默认值：</p><table><thead><tr><th>int</th><th>0</th></tr></thead><tbody><tr><td>short</td><td>0</td></tr><tr><td>byte</td><td>0</td></tr><tr><td>long</td><td>0L</td></tr><tr><td>float</td><td>0.0F</td></tr><tr><td>double（</td><td>0.0</td></tr><tr><td>char</td><td>\u0000</td></tr><tr><td>boolean</td><td>false</td></tr><tr><td>String</td><td>null</td></tr><tr><td>Object</td><td>null</td></tr></tbody></table><p>使用数组的步骤：</p><ol><li>声明数组并开辟空间 </li><li>给数组各个元素赋值 </li><li>使用数组</li></ol><p><strong>数组的构造方法</strong></p><ul><li><p>构造方式1：动态初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[] ints = new int[5];// 创建了数组 name，存放5个int</span><br><span class="line">int ints2[] = new int[1];// 这种写法也行</span><br><span class="line">ints[2] = 15;// 访问数组第3个数</span><br></pre></td></tr></table></figure></li><li><p>构造方式2：动态初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char[] chars;// 先声明数组 name，此时数组是 null</span><br><span class="line">chars = new char[2];// 分配内存空间，可以存放数据了</span><br><span class="line">chars[1] = &#x27;\t&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>构造方式3：静态初始化</p></li></ul><blockquote><p>确切知道数组每个元素的场合可以用这个方法。</p></blockquote>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boolean[] bools = &#123;true, false, true, false&#125;;</span><br><span class="line">String[] strs = new String[]&#123;&quot;a&quot;, &quot;b&quot;&#125;;</span><br></pre></td></tr></table></figure><p><strong>数组的使用方法：</strong></p><ul><li><p>访问数组元素：<code>数组名[元素下标]</code></p><p>其中，元素下标从 0 开始编号。如：访问 strs 数组的第一个元素 <code>strs[0]</code></p></li><li><p>数组长度：<code>数组名.length</code></p><p>是一个 int 值。不能通过试图改变该值来改变数组容量</p></li></ul><h2 id="数组赋值机制"><a href="#数组赋值机制" class="headerlink" title="数组赋值机制"></a>数组赋值机制</h2><p><strong>基本数据类型</strong>：赋值方式是值拷贝。这个值就是具体的数据，且互不影响。</p><p><strong>引用数据类型</strong>：赋值方式是地址拷贝。赋的值是地址，赋值方式为引用传达。</p><p>数组在默认情况下是引用传递，赋的值是地址，赋值方式为引用传达。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[] array1 = &#123;0, 0, 0&#125;;</span><br><span class="line">int[] array2 = array1;</span><br><span class="line">array2[0] = 100;</span><br></pre></td></tr></table></figure><p>因为数组在 JVM 的栈里是一个地址，指向 堆 里的一个空间。这两个数组在此时指向同一空间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int[] array1 = &#123;0, 0, 0&#125;;</span><br><span class="line">int[] array2 = new int[array1.length];</span><br><span class="line">for (int i = 0;i &lt; array1.length;i++) &#123;</span><br><span class="line">    array2[i] = array1[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，2个数组都是new出来的，二者地址独立，内容相同。</p><h2 id="数组的扩容"><a href="#数组的扩容" class="headerlink" title="数组的扩容"></a>数组的扩容</h2><p>数组的大小生成时固定，当数组达到上限时，创建一个容量更大的新数组。将旧数组的元素依次放入，之后替换旧数组。</p><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>二维数组实际是由多个一维数组组成的，它的各个元素的长度可以相同，也可以不同。数组是一个对象，所以二维数组的元素存放的是一维数组的地址。</p><p><strong>二维数组构造方法：</strong></p><ul><li><p>构造方法1：动态初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[][] many_ints = new int[3][4]// 创建 有3个 包含4个元素的一维数组 的二维数组</span><br></pre></td></tr></table></figure></li><li><p>构造方法2：动态初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double[][] many_doubles;// 先声明变量</span><br><span class="line">many_doubles = new double[3][4];// 再开辟空间</span><br></pre></td></tr></table></figure></li><li><p>构造方法3：动态初始化-列数不确定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char[][] many_chars = new char[3][];// 创建一个三行列数不确定的二维数组</span><br><span class="line">for (int i = 0; i &lt; 3; i++) &#123;</span><br><span class="line">    many_chars[i] = new char[i + 1];// 此时，每个数组空间依次增大</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造方法4：静态初始化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[][] many_many = &#123;&#123;1, 3&#125;, &#123;4, 10, 2&#125;, &#123;95&#125;&#125;;</span><br></pre></td></tr></table></figure></li></ul><p><strong>二维数组使用方法：</strong></p><ul><li><code>ints.length</code>：该二维数组的长度</li><li><code>ints[0]</code>：该二维数组的第一个一维数组</li><li><code>ints[x].length</code>：该二维数组的第 X 个子数组的长度</li><li><code>ints[1][0]</code>：该二维数组第二个子数组的第一个元素的值</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-变量、数据类型</title>
      <link href="/2023/05/07/Java01%E5%8F%98%E9%87%8F/"/>
      <url>/2023/05/07/Java01%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><p>变量是程序的基本组成单位</p><p>变量的三个基本要素：类型 + 名称 + 值</p><blockquote><p>示例：<code>int a = 1</code>;  类型 int 名称 a 值 1</p></blockquote><p><strong>声明变量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方法1：</span><br><span class="line">int a;</span><br><span class="line">a = 100;</span><br><span class="line">方法2：</span><br><span class="line">int b = 100;</span><br></pre></td></tr></table></figure><h2 id="变量使用注意事项"><a href="#变量使用注意事项" class="headerlink" title="变量使用注意事项"></a>变量使用注意事项</h2><ol><li>变量表示内存中的一个存储区域。不同变量，不同类型，占用的空间大小不同。如 <code>int</code> 有 4 byte，而 <code>double</code> 有 8 byte。</li><li>该区域有自己的名称 <code>变量名</code> 和类型 <code>数据类型</code></li><li>变量必须先声明，后使用。</li><li>变量在同一作用域内不能重名。</li><li>该区域的数据 · 值可以在同一类型范围内变化。</li><li>变量的三个基本要素：类型 + 名称 + 值</li></ol><h1 id="Java-数据类型"><a href="#Java-数据类型" class="headerlink" title="Java 数据类型"></a>Java 数据类型</h1><h4 id="基本数据类型（8个）"><a href="#基本数据类型（8个）" class="headerlink" title="基本数据类型（8个）"></a>基本数据类型（8个）</h4><ul><li><strong>数值型</strong><ul><li>整数类型：<ul><li>byte：占用 1 字节</li><li>short：占用 2 字节</li><li>int：占用 4 字节</li><li>long：占用 8 字节</li></ul></li><li>浮点（小数）类型：<ul><li>float：占用 4 字节</li><li>double：占用 8 字节</li></ul></li></ul></li><li><strong>字符型</strong><ul><li>char：存放单个字符，占用 2 字节</li></ul></li><li><strong>布尔型</strong><ul><li>boolean：存放 true（真），false（假）。占用 1 字节</li></ul></li></ul><h4 id="引用数据类型（复合数据类型）"><a href="#引用数据类型（复合数据类型）" class="headerlink" title="引用数据类型（复合数据类型）"></a>引用数据类型（复合数据类型）</h4><ul><li><strong>类</strong>：class</li><li><strong>接口</strong>：interface</li><li><strong>数组</strong>：<code>[]</code></li></ul><p>引用数据类型存储一个地址，通过这个地址去内存中找值。</p><h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><blockquote><p>用于存放整数值</p></blockquote><ul><li><code>byte</code> 占用 1 字节，范围 -128 ~ 127</li><li><code>short</code> 占用 2 字节，范围 -2<sup>15</sup> ~ 2^15 - 1</li><li><code>int</code> 占用 4 字节，范围 -2^31 ~ 2^31 - 1</li><li><code>long</code> 占用 8 字节，范围 -2^63 ~ 2^63 - 1</li></ul><p><strong>使用细节：</strong></p><ol><li>Java 各整数类型有固定的范围和字符长度，不受具体 OS（操作系统）影响，以保证 Java 程序的可移植性。（Java 由 JVM实现运算，结构统一）</li><li>Java 默认整型常量为 <code>int</code> ，要声明 <code>long</code> 型常量必须后加 <code>l</code> 或 <code>L</code>。</li><li>从 Java 7 开始，加上前缀 <code>0b</code> 或 <code>0B</code> 就可以写二进制数。</li><li>从 Java 7 开始，可以为数字字面添加下划线。这不会影响数字的值，只是为了方便阅读。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int n = 0b0010;</span><br><span class="line">n = 0b001;</span><br><span class="line">n = 100_0_000000;</span><br><span class="line">n = 0B0000_0010_1100;</span><br><span class="line">float f = 1.0F;JAVA</span><br></pre></td></tr></table></figure><p>如果基本的整数、浮点类型不能满足范围、精度的需求，可以使用 “大数”</p><h2 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h2><blockquote><p>可以表示一个小数</p></blockquote><ul><li><code>float</code> 单精度（6 ~ 7 位有效数字），占用 4 字节，范围约 -3.403E38 ~ 3.403E38</li><li><code>double</code> 双精度（15 位有效数字），占用 8 字节，范围约 -1.798E308 ~ 1.798E308</li></ul><p><em>浮点数在机器中存放形式为：浮点数 &#x3D; 符号位 + 指数位 + 尾数位</em></p><p><em><strong>因此，尾数部分可能丢失，造成精度损失。换言之，小数都是近似值</strong></em></p><h3 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h3><ol><li><p>与整数类型相似，有固定的范围和字符长度，不受具体 OS（操作系统）影响。</p></li><li><p>Java 默认浮点常量为 <code>double</code> ，要声明 <code>float</code> 型常量必须后加 ”f“ 或 ”F“</p></li><li><p>浮点型常量有两种表示形式</p><blockquote><p>十进制数形式：<code>5.13</code>、<code>315.4F</code>、<code>.414</code></p><p>科学计数法：<code>5.12e2</code> 即[5.12 × 102]、<code>5.12E-2</code> 即[5.12 &#x2F; 102]</p></blockquote></li><li><p>通常情况下，应该使用 <code>double</code> 类型，以其更为精确。</p></li><li><p>浮点数使用陷阱：当我们对运算结果是小数的进行相对判断时，要小心。（因为<em><strong>小数都是近似值</strong></em>）</p><p>正确方法是：<strong>以两个数差值的绝对值，在某个精度范围内判断</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (Math.abs(num1 - num2) &lt; 0.00001) &#123;</span><br><span class="line">System.out.println(&quot;插值范围内认为相等&quot;);</span><br><span class="line">&#125;JAVA</span><br></pre></td></tr></table></figure></li><li><p>特殊的浮点类型常量</p><ul><li><p>正无穷大：<code>Float.POSITIVE_INFINITY</code>、<code>Double.POSITIVE_INFINITY</code></p><p>（浮点数运算中）一个正数除以 0，会得到该值</p></li><li><p>负无穷大：<code>Float.NEGATIVE_INFINITY</code>、<code>Double.NEGATIVE_INFINITY</code></p><p>（浮点数运算中）一个负数除以 0，会得到该值</p></li><li><p>0 &#x2F; 0：<code>Float.NaN</code>、<code>Double.NaN</code></p><p>（浮点数运算中）0 除以 0，会得到该值</p></li><li><p>最大、最小值：<code>Float.MAX_VALUE</code>、<code>Double.MIN_VALUE</code></p></li></ul></li><li><p>不能用运算符来比较特殊值，而要用特别的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">double num = 0.0 / 0;</span><br><span class="line">System.out.println(num == Double.NaN);// &lt;——— 始终为 false。不能如此比较</span><br><span class="line">System.out.println(Double.isNaN(num));// &lt;——— 判断是否是 NaN</span><br><span class="line">num = 1.0 / 0;</span><br><span class="line">System.out.println(Double.isInfinite(num));// &lt;——— 是否是无穷大JAVA</span><br></pre></td></tr></table></figure></li><li><p>由于不同处理器寄存浮点数的策略可能不同，浮点数运算的结果也可能不同。</p></li></ol><h2 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h2><blockquote><p>可以表示单个字符。（可以存放一个数字，因为其字符是数字编号的。输出时会输出数字对应的字符。”编码的概念“）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char c1 = &#x27;a&#x27;;` `char c2 = &#x27;\t&#x27;;` `char c3 = &#x27;字&#x27;;` `char c4 = 99;</span><br></pre></td></tr></table></figure></blockquote><h3 id="使用细节-1"><a href="#使用细节-1" class="headerlink" title="使用细节"></a>使用细节</h3><ol><li><p>字符常量用单引号括起 ‘字’</p></li><li><p><code>char</code> 的本质是一个整数，输出时，输出的是 unicode 码对应的字符</p><p>要输出那个整数，用 <code>int</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char c1 = &#x27;a&#x27;;</span><br><span class="line">System.out.println((int)c1);JAVA</span><br></pre></td></tr></table></figure></li><li><p><code>char</code> 是可以进行运算的，其相当于一个整数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 注：(int)&#x27;a&#x27; = 97</span><br><span class="line">char c1 = &#x27;a&#x27; + 1;// 相当于 char c1 = &#x27;b&#x27;</span><br><span class="line">System.out.println(&#x27;a&#x27; + 1);// 这个代码输出 98</span><br><span class="line">System.out.println(&quot;a&quot; + 1);// 这个代码输出 a1JAVA</span><br></pre></td></tr></table></figure></li><li><p>字符允许使用转义符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char c = &#x27;\u0041&#x27;;</span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure><p><strong>转义序列 \u 能出现在引号外。所有这些转义序列会在解析代码前得到处理</strong></p><ul><li><p>以下字符串是空串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;\u0022+\u0022&quot;;</span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure><p>因为 \u0022 表示引号。该代码等同于以下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;&quot; + &quot;&quot;;</span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure></li><li><p>以下注释会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// \u000A is a newline</span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure><p>因为 \u000A 是换行符。在解析前会得到处理。在程序看来，上述注释等于以下写法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// </span><br><span class="line">is a newlineJAVA</span><br></pre></td></tr></table></figure></li><li><p>以下注释也会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// look inside c:\users</span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure><p>因为程序认为，\users 不是一个合法的转义字符</p></li><li><p>在某些场合下这种写法似乎也能实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int\u005B\u005D a;// int[] a; 一个数组</span><br><span class="line">JAVA</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="字符本质与编码表"><a href="#字符本质与编码表" class="headerlink" title="字符本质与编码表"></a>字符本质与编码表</h3><ul><li><p>字符类型的本质，是把字符对应的码值编程二进制，存储。显示时将二进制代码转化为码值，找到对应的字符。</p></li><li><p>字符与码值的对应关系是字符编码表规定的。</p><blockquote><p>ASCII 编码表，占用 1 byte，共有 128 个字符。</p><p>Unicode 编码表，占用 2 byte，字母汉字都占用 2 byte，这样可能浪费空间。0 - 127 的字符与 ASCII 相同，所以兼容 ASCII。</p><p>UTF-8 编码表，根据不同符号大小可变（1 - 6 byte），字母占用 1 byte，汉字占用 3 byte。是 Unicode 的改进，是互联网上使用最广的 Unicode 实现方式。</p><p>GBK 编码表，可以表示汉字，字母占用 1 byte，汉字占用 2 byte。</p><p>GB2312 编码表，可以表示汉字（GB2312 &lt; GBK）</p><p>BIG5 编码表，可以存放繁体中文（香港，台湾）</p></blockquote></li><li><p>UTF-16 编码采用不同长度的编码表示所有 Unicode 码点。包含从 U+0000 到 U+FFFF 的经典 Unicode 代码（16位，1 个代码单元），以及 U+10000 到 U+10FFFF 的辅助字符（32位，2 个代码单元）</p></li><li><p>在 Java 中，char 类型描述的是 UTF-16 编码中的 1 个代码单元。</p><p>字符串中的一个辅助字符（如 @）可能占用 2 个代码单元。这个场合，使用 char 可能会导致错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;123&quot;;</span><br><span class="line">char c = str.charAt(1);</span><br></pre></td></tr></table></figure><p><strong>因此，一般不建议在程序中使用 char 类型</strong></p></li></ul><h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><blockquote><p><code>boolean</code> 只允许取值 <code>ture</code> 或 <code>false</code> ，没有 <code>null</code>。适用于逻辑运算，通常用于程序流程控制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if` `while` `do-while` `for</span><br></pre></td></tr></table></figure></blockquote><p><strong>使用细节：</strong></p><ol><li>不可以用 0 或 非0 的整数替代 <code>false</code> 或 <code>ture</code> 。这点和 C语言 不同。</li><li>不能让布尔类型转换为其他类型。如需转换，请使用如下方法：</li></ol><h1 id="基本数据类型转换"><a href="#基本数据类型转换" class="headerlink" title="基本数据类型转换"></a>基本数据类型转换</h1><h2 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h2><p>自动类型转换：Java 在进行赋值或运算时，精度（容量）小的类型自动转换为精度（容量）大的类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char &gt; int &gt; long &gt; float &gt; double</span><br><span class="line">byte &gt; short &gt; int &gt; long &gt; float &gt; double</span><br></pre></td></tr></table></figure><blockquote><p>例：<code>int a = &#39;c&#39;</code> 或者 <code>double b = 80</code></p></blockquote><p><strong>使用细节</strong></p><ol><li><p>有多种类型数据混合运算时，系统会将所有数据转换成容量最大的那种，再进行运算。</p></li><li><p>如若把大精度（容量）数据赋值给小精度（容量）类型，就会报错（小数由于精度原因，大赋小会丢失精度，必不可用。但整数大赋小时：1.赋予具体数值时，判断范围。2.变量赋值时，判断类型。反之进行自动类型转换。</p></li><li><p><code>byte</code> <code>short</code> <code>char</code> 三者不会相互自动转换，但可以计算。计算时首先转化为 <code>int</code>。</p><blockquote><p><code>byte a = 1;</code></p><p><code>byte b = 1;</code></p><p><code>a + b</code> 结果是 <code>int</code> 类型</p></blockquote></li><li><p><code>boolean</code> 类型不参与自动转换</p></li><li><p>自动提升原则：表达式结果的类型自动提升为操作数中最大的类型</p></li></ol><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>强制类型转换：自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时加上强制转换符 <code>( )</code> ，但<strong>可能造成精度降低或溢出</strong>，要格外注意。</p><blockquote><p>例：int a &#x3D; (int)(3 * 2.5 + 1.1 * 6);</p></blockquote><p> <strong>使用细节</strong></p><ol><li>当进行数据从大到小转换时，用强制转换。</li><li>强制转换只能对最近的操作数有效，往往会使用 <code>( )</code> 提升优先级。</li><li><code>char</code> 可以保留 <code>int</code> 的常量值，但不能保存其变量值。此时需要强制类型转换。</li><li><code>byte</code> <code>short</code> <code>char</code> 在进行运算时，当作 <code>int</code> 处理。</li></ol><h2 id="基本数据类型和-String-的转换"><a href="#基本数据类型和-String-的转换" class="headerlink" title="基本数据类型和 String 的转换"></a>基本数据类型和 <code>String</code> 的转换</h2><ol><li>基本类型转 <code>String</code>：基本数据类型加上 <code>&quot; &quot;</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int n1 = 100;</span><br><span class="line">String s = n1 + &quot;&quot;;</span><br><span class="line">System.out.println(n1 + &quot;&quot; + n1 + &quot;&quot; + n1 + &quot;&quot;);</span><br></pre></td></tr></table></figure><ol start="2"><li><code>String</code> 转基本数据类型：通过基本数据类型的包装类调用 <code>parseXX</code> 方法。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;100&quot;;</span><br><span class="line">int n1 = Interger parseInt(s);</span><br></pre></td></tr></table></figure><ol start="3"><li>特别的，把 <code>String</code> 转换为 <code>char</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char c = s.charAt(0);// 得到 s 字符串中的第一个字符。</span><br><span class="line">charAt（a）库函数，得到位序为a的字符</span><br></pre></td></tr></table></figure><h4 id="使用细节-2"><a href="#使用细节-2" class="headerlink" title="使用细节"></a>使用细节</h4><ol><li>将 <code>String</code> 转成基本数据类型时，要保证其能转换为有效数据。即不能把 <code>&quot;Hello&quot;</code> 转换成 <code>int</code>。</li><li>如果格式不正确，会抛出异常，程序会中止。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 变量 </tag>
            
            <tag> 数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-运算符</title>
      <link href="/2023/05/07/Java02%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
      <url>/2023/05/07/Java02%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>运算符：一种特殊的符号，用于表示数据的运算、赋值和比较等。</p><h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><p>算术运算符是对数值类型的变量进行运算的运算符，在 Java 程序中使用得非常多。其运算结果是一个数值量。</p><ul><li><p><code>+</code> ; <code>-</code> ; <code>*</code> ; <code>/</code> ：加（正）、减（负）、乘、除</p></li><li><p><code>%</code> ：取模（求余数），结果和被取模数同号。</p></li><li><p><code>++</code> ：自增。</p><p><code>++i</code> 先自增后赋值；<code>i++</code> 先赋值后自增</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int i = 10;</span><br><span class="line">int j = ++i; //等价于 i = i + 1; j = i; 此时 i = 10; j = 10`</span><br><span class="line">int k = i++; //等价于 k = i; i = i + 1; 此时 i = 11; k = 10`</span><br><span class="line">i = i++; //系统会先后执行 int temp = i;     i = i + 1;     i = temp</span><br><span class="line">i = ++i; //系统会先后执行 i = i + 1;     int temp = i;     i = tempJAVA</span><br></pre></td></tr></table></figure></li><li><p><code>--</code> ：自减。和 <code>++</code> 同理。</p></li><li><p><code>+</code> ：字符串相加，数字遇到字符串的 + 会转为字符串类型</p></li></ul><h2 id="关系运算符（比较运算符）"><a href="#关系运算符（比较运算符）" class="headerlink" title="关系运算符（比较运算符）"></a>关系运算符（比较运算符）</h2><p>关系运算符结果都为 <code>boolean</code> 型，要么是 <code>true</code> 要么是 <code>false</code>。其关系表达式经常用在 <code>if</code> 结构的条件中或循环结构的条件中。</p><ul><li><code>==</code> ：相等于。<code>8 == 7</code> 结果 <code>false</code></li><li><code>!=</code> ：不等于</li><li><code>&lt;</code> <code>&gt;</code> ：小于、大于</li><li><code>&lt;=</code> <code>&gt;=</code> ：小于等于、大于等于</li><li><code>instanceof</code> ：检查是否是类的对象。<code>&quot;a&quot; istanceof String</code> 结果 <code>true</code></li></ul><h3 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h3><ol><li>关系运算符结果都是 <code>boolean</code> 型，要么是 <code>true</code> ，要么是 <code>false</code></li><li>关系运算符的表达式，称为<em>关系表达式</em></li><li>比较运算符 <code>==</code> 不要误写为 <code>=</code></li><li>Java 允许将 <code>==</code>、<code>!=</code> 两种运算用于任何数据类型</li></ol><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>用于连接多个条件（多个关系表达式），最终的结果也是一个 <code>boolean</code> 值。</p><ul><li><p><code>&amp;&amp;</code> ：短路与。<code>a</code> <code>b</code> 同时为 <code>true</code>，则结果为 <code>true</code>，否则为 <code>false</code>。</p></li><li><p><code>&amp;</code> ：逻辑与。<code>a</code> <code>b</code> 同时为 <code>true</code>，则结果为 <code>true</code>，否则为 <code>false</code>。</p><p><code>&amp;&amp;</code> 与 <code>&amp;</code> 的区别，在于 <code>a &amp;&amp; b</code> 的场合，<code>a = false</code> 时，则 <code>b</code> 不判断。而 <code>&amp;</code> 会2个都判断。开发中多用 <code>&amp;&amp;</code> ，因为其效率更高。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">int b = 1;</span><br><span class="line"></span><br><span class="line">if (a++ &gt; 1 &amp;&amp; ++b &lt; 1) System.out.println(&quot;Nothing happened&quot;);</span><br><span class="line">/*</span><br><span class="line">此时 a 经历了先判断后自增，返回 false 并且 a = 2</span><br><span class="line">但此时 b = 1; 因为 a = false; 所以 ++b 不执行。</span><br><span class="line">*/JAVA</span><br></pre></td></tr></table></figure></li><li><p><code>||</code> ：短路或。<code>a</code> <code>b</code> 任一为 <code>true</code>，则结果为 <code>true</code>，否则为 <code>false</code>。</p></li><li><p><code>|</code> ：逻辑或。<code>a</code> <code>b</code> 任一为 <code>true</code>，则结果为 <code>true</code>，否则为 <code>false</code>。</p><blockquote><p>两者的区别和<code>&amp;&amp;</code> 与 <code>&amp;</code> 相似，若第一个为 <code>true</code> ，则 <code>||</code> 不会判断第二个。</p></blockquote></li><li><p><code>!</code> ：取反。<code>a</code> 为 <code>true</code>，则结果为 <code>false</code>。反之为 <code>true</code>。</p></li><li><p><code>^</code>：逻辑异或。<code>a</code> <code>b</code> 不同时，结果为 <code>true</code>，否则为 <code>false</code>。</p></li></ul><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><blockquote><p>将某个运算后的值，赋给指定变量</p></blockquote><ul><li><p>基本赋值运算符：<code>=</code></p></li><li><p>符合赋值运算符：<code>+=</code> ; <code>-=</code> ; <code>*=</code> ; <code>/=</code> ; <code>%=</code> 等</p><blockquote><p><code>a += b</code> 等价于 <code>a = a + b</code>。其余同理。</p></blockquote></li></ul><h3 id="使用细节-1"><a href="#使用细节-1" class="headerlink" title="使用细节"></a>使用细节</h3><ol><li><p>运算顺序从右往左。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int num = a + b + c;// 先运行(a + b + c)，再结算int num </span><br></pre></td></tr></table></figure></li><li><p>运算符左边只能是变量，右边可以是变量、表达式、常量值。</p></li><li><p>复合赋值运算符会进行类型转换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte b = 2; b += 3;// 此时 b += 3 等价于 b = (byte)(b + 3)</span><br><span class="line">b++;// 同理</span><br></pre></td></tr></table></figure></li></ol><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>基本语法：<code>条件表达式 ? 表达式1 : 表达式2;</code></p><p>运算规则：如果条件表达式为 <code>ture</code> ，运算的结果是表达式1；反之为表达式2。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">int b = 11;</span><br><span class="line">int result = (a == b ? a++ : b++);// 此时 a = 10  result = 11  b = 12</span><br></pre></td></tr></table></figure><h3 id="使用细节-2"><a href="#使用细节-2" class="headerlink" title="使用细节"></a>使用细节</h3><ol><li>表达式1 和 表达式2 要为可以赋给接受变量的类型（或可以自动转换，或进行强制转换）</li><li>三元运算符可以转成 <code>if--else</code></li><li>三元运算符是一个整体。</li></ol><blockquote><p>例： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj = true ? new Integer(1) : new Double(2.2);</span><br><span class="line">System.out.print(obj)</span><br></pre></td></tr></table></figure><p>系统将会输出 <code>1.0</code>，因为 三元运算符 是一个整体，所以 发生了类型转换</p></blockquote><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><table><thead><tr><th>运算符（优先级从高到低）</th><th>结核性</th></tr></thead><tbody><tr><td><code>[]</code>、<code>()</code> 方法调用</td><td>从左向右</td></tr><tr><td><code>!</code>、<code>~</code>、<code>++</code>、<code>--</code>、<code>+</code>（一元运算）、<code>-</code>（一元运算）、强制类型转换、new</td><td>从右向左</td></tr><tr><td><code>*</code>、<code>/</code>、<code>%</code></td><td>从左向右</td></tr><tr><td><code>+</code>、<code>-</code></td><td>从左向右</td></tr><tr><td><code>&lt;&lt;</code>、<code>&gt;&gt;</code>、<code>&gt;&gt;&gt;</code></td><td>从左向右</td></tr><tr><td><code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code>、instanceof</td><td>从左向右</td></tr><tr><td><code>==</code>、<code>!=</code></td><td>从左向右</td></tr><tr><td><code>&amp;</code></td><td>从左向右</td></tr><tr><td><code>^</code></td><td>从左向右</td></tr><tr><td><code>&amp;&amp;</code></td><td>从左向右</td></tr><tr><td><code>?:</code>（三元运算符）</td><td>从右向左</td></tr><tr><td><code>=</code>、<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>&amp;=</code>、<code>%=</code>、<code>^=</code>、&#96;</td><td>&#x3D;<code>、</code>&lt;&lt;&#x3D;<code>、</code>&gt;&gt;&#x3D;<code>、</code>&gt;&gt;&gt;&#x3D;&#96;</td></tr></tbody></table><ol><li>运算符有不同优先级。优先级高的总是优先于低的。</li><li>只有单目运算符、赋值运算符是从右向左运算的。</li></ol><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>Java 对各种变量、方法和类等命名时使用的字符序列称为标识符，凡是自己可以起名字的地方都叫标识符 </p><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><ol><li>标识符由 26 个大、小写英文字母，0 - 9 阿拉伯数字，_ 或 $ 符号组成。</li><li><strong>数字不能开头</strong>。</li><li>不能是关键字和保留字。</li><li>严格区分大小写，长度无限制。</li><li>不能包含空格。</li><li>与多数编程语言不同。Java 可以用任何 Unicode 字符（特殊字符除外）作为标识符，包括中文。但不推荐这么做。</li></ol><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><ol><li>包名：多单词组成时所有字母都小写：aaa.bbb.ccc</li><li>类名、接口名：多单词组成时，采用大驼峰法，所有单词的首字母大写：XxxYyyZzz</li><li>变量名、方法名：多单词组成时，采小驼峰法（驼峰法），第一个单词首字母小写，第二个开始每个单词首字母大写：xxxYyyZzz</li><li>常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ</li></ol><h1 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h1><p>为满足读取用户输入、输出的需求，Java 提供了几个基本类，通过 util 包导入</p><h3 id="输入-x2F-Scanner-类"><a href="#输入-x2F-Scanner-类" class="headerlink" title="输入&#x2F;Scanner 类"></a>输入&#x2F;Scanner 类</h3><p>在编程中，需要接收用户输入的数据，就可以使用键盘输入语句来获取。<code>Input.java</code> ，需要一个 扫描器（对象），就是 Scanner</p><p>使用过程：</p><ol><li>导入该类所在的包 import java.util.Scanner;</li><li>创建该类对象（声明变量）Scanner scanner &#x3D; new Scanner(System.in);</li><li>调用里面的功能，接收用户输入</li></ol><p>构造方法：</p><ul><li><code>new Scanner(System.in)</code>：该方法接收一个参数（输入源）。其中 <code>System.in</code> 代表标准输入流。默认情况指键盘。</li></ul><p>常用方法：</p><ul><li><p><code>String next()</code>：读取下一个输入对象</p><p>Scanner 对象用空白（空格、水平制表符或回车换行符）作为输入的分隔元素</p></li><li><p><code>Double nextDouble()</code>：读取下一个 double</p><p><code>Int nextInt()</code>：读取下一个 int</p></li><li><p><code>String nextLine()</code>：读入当前行的所有输入，直到行尾</p></li><li><p><code>boolean hasNext()</code>：输入中是否还有其他单词</p><p><code>boolean hasNextInt()</code>、<code>boolean hasNextDouble()</code></p></li></ul><h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><blockquote><p>System.out 标准输出流。调用该流方法以输出内容至控制台窗口</p></blockquote><ul><li><code>println()</code>：输出字符，结束后换行</li><li><code>print()</code>：输出字符，结束后不换行</li><li><code>printf(String format, Object ... args)</code>：格式化输出</li></ul><p>以 % 开头的 <em>格式说明符</em> 都用相应参数替换。格式说明符尾部的转换符表示要格式化的数值类型</p><table><thead><tr><th>转换符</th><th>类型</th><th>转换符</th><th>类型</th></tr></thead><tbody><tr><td>%d</td><td>十进制整数</td><td>%s</td><td>字符串</td></tr><tr><td>%x</td><td>十六进制整数</td><td>%c</td><td>字符</td></tr><tr><td>%o</td><td>八进制整数</td><td>%b</td><td>布尔值</td></tr><tr><td>%f</td><td>定点浮点数</td><td>%h</td><td>散列码</td></tr><tr><td>%e</td><td>指数浮点数</td><td>%tx</td><td>日期时间（T强制大写）</td></tr><tr><td>%g</td><td>通用浮点数</td><td>%%</td><td>百分号</td></tr><tr><td>%a</td><td>十六进制浮点数</td><td>%n</td><td>行分隔符</td></tr></tbody></table><p>也能指定控制格式化输出外观的各种标志</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-流程结构</title>
      <link href="/2023/05/07/Java03%E7%BB%93%E6%9E%84/"/>
      <url>/2023/05/07/Java03%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="程序控制结构"><a href="#程序控制结构" class="headerlink" title="程序控制结构"></a>程序控制结构</h1><p>程序运行的流程控制决定程序是如何执行的。主要分为：顺序控制、分支控制、循环控制</p><h2 id="顺序控制"><a href="#顺序控制" class="headerlink" title="顺序控制"></a>顺序控制</h2><p>程序从上到下逐行执行，中间没有任何判断和跳转（默认的控制顺序）</p><p>语句：Java 中最小的执行单位。语句分为 单语句 和 复合语句。</p><ul><li><p>单语句：通常意义的一条语句。语句间以分号 <code>;</code> 分隔。</p></li><li><p>复合语句：一对大括号括起来的语句组。也称为 “块”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    语句1; </span><br><span class="line">    语句2;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>块中可以有多条语句。块后没有分号 <code>;</code></p></li></ul><h2 id="分支控制"><a href="#分支控制" class="headerlink" title="分支控制"></a>分支控制</h2><p>让程序有选择的执行。主要分为：单分支控制、双分支控制</p><h3 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h3><p><strong>单分支控制</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (条件表达式) 语句;</span><br><span class="line">或者，把代码块（复合语句）作为语句的场合也能这样写：</span><br><span class="line">if (条件表达式) &#123;</span><br><span class="line"> 执行代码块;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当条件表达式为 <code>true</code>，就会执行 <code>&#123;执行代码块;&#125;</code>；如果为 <code>false</code> 则不执行。特别地：如果 <code>&#123;执行代码块;&#125;</code> 中只有一条代码，也可以不写 <code>&#123; &#125;</code></p><p><strong>双分支控制</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (条件表达式) &#123;</span><br><span class="line"> 执行代码块;</span><br><span class="line">&#125; else &#123;</span><br><span class="line"> 执行代码块2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当条件表达式为 <code>ture</code>，就会执行 <code>&#123;执行代码块1;&#125;</code>；如果为 <code>false</code> 则执行 <code>&#123;执行代码块2;&#125;</code></p><p><strong>多分支控制</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (条件表达式) &#123;</span><br><span class="line"> 执行代码块;</span><br><span class="line">&#125; else if (条件表达式2) &#123;</span><br><span class="line"> 执行代码块2;</span><br><span class="line">&#125; else if (条件表达式3) &#123;</span><br><span class="line"> 执行代码块3;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">else &#123;</span><br><span class="line"> 执行代码块n；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别地：多分支可以没有 <code>else</code>。此时如果条件都不成立，则无执行入口</p><h3 id="嵌套分支"><a href="#嵌套分支" class="headerlink" title="嵌套分支"></a>嵌套分支</h3><p>在一个分支结构中又完整嵌套了另一个完整的分支结构。里面的分支称为内层分支，外面的分支称为外层分支。</p><p>Java 规定，else 子句属于逻辑上距其最近，且没有匹配 else 的 if 语句：</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int n = 0;</span><br><span class="line">if (n &gt; 0) n++;</span><br><span class="line">if (n &gt; 1) n++;</span><br><span class="line">else n--;//属于上面这个 if 语句</span><br></pre></td></tr></table></figure><p>这个场合，这个 else 语句属于上面的 <code>if (n &gt; 1)</code> 这个语句</p></blockquote><p>要想改变那个匹配关系，要使用 <code>&#123; &#125;</code> 改变语句结构：</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int n = 0;</span><br><span class="line">if (n &gt; 0) &#123;</span><br><span class="line">    n++;</span><br><span class="line">if (n &gt; 1) n++;  </span><br><span class="line">&#125; else n--;</span><br></pre></td></tr></table></figure></blockquote><p><strong>规范：嵌套尽量不超过 3 层（可读性不好）</strong></p><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">switch(表达式)&#123;</span><br><span class="line">case 常量1:</span><br><span class="line">语句块1;</span><br><span class="line">break;//break 语句可选</span><br><span class="line">case 常量2:</span><br><span class="line">语句块2;</span><br><span class="line">break;//break 语句可选</span><br><span class="line">...</span><br><span class="line">default://default 语句可选</span><br><span class="line">default语句块;</span><br><span class="line">break;//break 语句可选</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>switch</code> 关键字，表示 switch 分支。</li><li><code>表达式</code> 对应一个值。<strong>该值必须是 int 或 char</strong>（char 可以转化为 int）。是 byte 或 short 的场合，要提升为 int。不允许 long、double 或 float</li><li><code>case 常量1;</code> 表示：当 <code>表达式</code> 的值等于 <code>常量1</code> ，则执行 <code>语句块1</code>。</li><li><code>break;</code> 表示退出 switch 分支。</li><li>当 <code>表达式</code> 的值匹配 <code>常量1</code> ，则执行 <code>语句块1</code>，如果不匹配，则继续匹配 <code>常量2</code> ，以此类推。</li><li>如果全都不匹配，则执行 <code>default</code>。</li><li>如果不写 <code>break;</code> ，则会发生<strong>穿透</strong>，即不进行判断而继续执行下一语句块。</li></ol><p><strong>使用细节</strong></p><ol><li><code>表达式;</code> 数据类型，应和 <code>case</code> 后的 <code>常量</code> 类型一致，或者是可以自动转换成可以比较的类型。如：输入的是 <code>char</code> 而 <code>常量</code> 是 <code>int</code></li><li>switch 中 <code>表达式</code> 的返回值必须是：<code>byte</code> <code>short</code> <code>int</code> <code>char</code> <code>enum</code> <code>String</code></li><li><code>case</code> 语句中的值必须是 常量 或 常量表达式，不能是 变量。</li><li><code>default</code> 是可选的。没有就不执行。</li><li><code>break;</code> 用来跳出 switch 分支。如果不写，会持续执行语句，直到分支结束或遇到下一个 <code>break;</code></li></ol><h2 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h2><h3 id="普通for循环"><a href="#普通for循环" class="headerlink" title="普通for循环"></a>普通for循环</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(循环变量初始化;循环条件;循环变量迭代)&#123;</span><br><span class="line">循环操作（代码块）;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>for</code> 关键字，表示循环控制</li><li>四个要素：1. 循环变量初始化 2. 循环的条件 3. 循环的操作 4. 循环变量迭代</li></ul><p>所有循环开始前仅一次进行初始化。直到循环条件变为 false 前，执行循环操作。每轮循环结束后，进行循环变量迭代。</p><ul><li>循环操作可以有多条语句</li><li>如果循环操作只有一条语句，可以省略 <code>&quot;&#123;&#125;&quot;</code>，但建议不省略</li></ul><p><strong>使用细节</strong></p><ol><li><p>循环条件是返回一个 boolean 值（<code>ture</code> 或 <code>false</code>）的公式。</p><p>循环条件可以为空。这个场合，默认为真（true）</p></li><li><p><code>for(;循环条件;)&#123; &#125;</code> 其中的初始化和变量迭代可以写在别处，但 <code>;</code> 不能省略。如果不写在别处，那个 <code>循环变量初始化</code> 中声明的变量只能在该 for 循环中使用。</p></li><li><p>控制台用 ctrl + c 强制结束一个流程</p></li><li><p>循环初始值可以有多条初始化语句，但要求类型一样，并用 <code>,</code> 隔开。</p><p>变量迭代也可以有多条代码，用 <code>,</code> 隔开</p></li></ol><h3 id="for-each（泛型-for-循环）"><a href="#for-each（泛型-for-循环）" class="headerlink" title="for each（泛型 for 循环）"></a>for each（泛型 for 循环）</h3><p>泛型 for 循环（增强 for 循环）能用来依次处理数组、集合中的每个元素，而不必考虑下标值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(int i : nums)&#123;//其中 nums 是一个一维 int 数组</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型 for 循环适用于数组或一个实现了 Iterable 接口的对象。泛型 for 循环的本质是一个 Iterator（迭代器）</p><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while(循环条件)&#123;</span><br><span class="line"> 循环体(代码块);</span><br><span class="line"> 循环变量迭代;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>while</code> 也有四要素，只是位置和 <code>for</code> 不同</p><p><strong>使用细节</strong></p><ol><li><p>循环条件是返回一个 boolean 值（<code>ture</code> 或 <code>false</code>）的公式。</p><p>while 循环中，循环条件不能为空。</p></li><li><p><code>while</code> 循环是先判断再执行语句</p></li></ol><h3 id="do-while"><a href="#do-while" class="headerlink" title="do..while"></a>do..while</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">循环体;</span><br><span class="line">循环变量迭代;</span><br><span class="line">&#125;while(循环条件);</span><br></pre></td></tr></table></figure><ol><li><code>do</code> <code>while</code> 是关键字</li><li>也有四要素，位置不同</li><li>先执行，再判断。也就是说，一定会至少执行一次</li><li><strong>最后有一个 <code>;</code></strong></li><li><code>while</code> 与 <code>do..while</code> 区别：“要账”</li></ol><p><strong>使用细节</strong></p><ol><li>循环条件是返回一个 boolean 值（<code>ture</code> 或 <code>false</code>）的公式。</li><li><code>do..while</code> 循环是先执行再判断的语句。因此至少执行一次。</li></ol><h3 id="多重循环控制"><a href="#多重循环控制" class="headerlink" title="多重循环控制"></a>多重循环控制</h3><p>将一个循环放在另一个循环体内，就形成了嵌套循环。建议一般使用两层，最多不超过三层。</p><p>嵌套循环 是把 内层循环 当成 外层循环 的 循环体。只有内层 <code>false</code> 时才可能结束当层循环。</p><p>若内层执行 n 次，外层 m 次，则合计会循环 n*m 次</p><h2 id="跳转控制语句"><a href="#跳转控制语句" class="headerlink" title="跳转控制语句"></a>跳转控制语句</h2><p>跳转控制语句用于分支或循环中，以便程序员更好控制程序执行方向</p><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a:&#123;</span><br><span class="line">b:&#123;</span><br><span class="line">c:&#123;</span><br><span class="line">   ...</span><br><span class="line"> berak b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>a:</code> <code>b:</code> <code>c:</code> 是标签，名字由程序员指定</li><li><code>break</code> 后指定哪个标签就退出到哪里</li><li><strong>实际开发中，尽量不要使用标签</strong></li></ol><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>用于中止一个语句块的执行</p><p>语法：<code>break;</code></p><p>break 可以被用在三种场合中</p><ul><li><p>switch 语句中，以跳出判断（结束穿透）</p></li><li><p>for、while、do…while 循环语句中，以跳出循环</p></li><li><p>语句块中，以跳过本块中所有剩余语句</p></li></ul><blockquote><p><code>break</code> 语句出现在多层嵌套的语句块中时，可以通过 <strong>标签</strong> 指明要终止的时哪一层语句块。</p></blockquote><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>在循环中出现。用于结束本次循环，继续下一次循环</p><p>语法：<code>continue;</code></p><p>进行下次循环前，仍会判断循环条件是否满足</p><p>在多层嵌套循环中，可以通过标签指出跳出哪次循环（同 <code>break</code>）</p><h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><p>用于方法。表示跳出所在的方法</p><p>语法：<code>return;</code></p><p>方法有返回值的场合，将返回值写在 return 后：<code>return 值;</code></p><p>如果写在主方法 则跳出程序。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 流程结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-关键字</title>
      <link href="/2023/05/05/Java00%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2023/05/05/Java00%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p>java中共：</p><ul><li>48个关键字</li><li>2个保留字（现在没用以后可能用到作为关键字）：goto、const。</li><li>3个特殊直接量：true、false、null</li></ul><p>合53个</p><table><thead><tr><th align="left">分类</th><th>关键字</th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td align="left">访问控制</td><td>private</td><td>protected</td><td>public</td><td></td><td></td><td></td><td></td></tr><tr><td align="left">类，方法和变量修饰符</td><td>abstract</td><td>class</td><td>extends</td><td>final</td><td>implements</td><td>interface</td><td>native</td></tr><tr><td align="left"></td><td>new</td><td>static</td><td>strictfp</td><td>synchronized</td><td>transient</td><td>volatile</td><td>enum</td></tr><tr><td align="left">程序控制</td><td>break</td><td>continue</td><td>return</td><td>do</td><td>while</td><td>if</td><td>else</td></tr><tr><td align="left"></td><td>for</td><td>instanceof</td><td>switch</td><td>case</td><td>default</td><td>assert</td><td></td></tr><tr><td align="left">错误处理</td><td>try</td><td>catch</td><td>throw</td><td>throws</td><td>finally</td><td></td><td></td></tr><tr><td align="left">包相关</td><td>import</td><td>package</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td align="left">基本类型</td><td>boolean</td><td>byte</td><td>char</td><td>double</td><td>float</td><td>int</td><td>long</td></tr><tr><td align="left"></td><td>short</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td align="left">变量引用</td><td>super</td><td>this</td><td>void</td><td></td><td></td><td></td><td></td></tr><tr><td align="left">特殊直接量</td><td>true</td><td>false</td><td>null</td><td></td><td></td><td></td><td></td></tr><tr><td align="left">保留字</td><td>goto</td><td>const</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h1 id="访问权限控制（3个）"><a href="#访问权限控制（3个）" class="headerlink" title="访问权限控制（3个）"></a>访问权限控制（3个）</h1><p>访问修饰符的关键字共3个（或者4个），用于控制方法和属性（成员变量）的访问权限（范围）</p><ul><li>公开级别：<code>public</code>，对外公开。</li><li>受保护级别：<code>protected</code>，对 子类 和 同一个包中的类 公开。</li><li>默认级别：没有修饰符号，向 同一个包的类 公开。</li><li>私有级别：<code>private</code>，只有 自己 可以访问，不对外公开。</li></ul><table><thead><tr><th></th><th align="center">private</th><th align="center">默认（无修饰符）</th><th align="center">protected</th><th align="center">public</th></tr></thead><tbody><tr><td>本类</td><td align="center">可</td><td align="center">可</td><td align="center">可</td><td align="center">可</td></tr><tr><td>同包中的子类</td><td align="center">不可以</td><td align="center">可</td><td align="center">可</td><td align="center">可</td></tr><tr><td>同包的非子类</td><td align="center">不可以</td><td align="center">可</td><td align="center">可</td><td align="center">可</td></tr><tr><td>其他包的子类</td><td align="center">不可以</td><td align="center">不可以</td><td align="center">可</td><td align="center">可</td></tr><tr><td>其他包的非子类</td><td align="center">不可以</td><td align="center">不可以</td><td align="center">不可以</td><td align="center">可</td></tr></tbody></table><p>使用说明：</p><ol><li>修饰符可以修饰类中的 属性、成员方法 及 类</li><li>只有 默认 和 <code>public</code> 才能修饰 类，并遵循上述访问权限特点</li><li>成员方法 的访问规则和 属性 相同</li><li>private 修饰的变量可以被 任意本对象同类的对象访问</li></ol><h1 id="定义、实例化（6个）"><a href="#定义、实例化（6个）" class="headerlink" title="定义、实例化（6个）"></a>定义、实例化（6个）</h1><table><thead><tr><th>关键字</th><th>用途</th><th>备注，常用</th></tr></thead><tbody><tr><td>class</td><td>定义类</td><td>public class A(){ } <br>花括号里有已实现方法体，类名需要与文件名相同</td></tr><tr><td>interface</td><td>定义接口</td><td>public interface B(){ } <br/>花括号里有方法体，但没有实现，方法体句子后面是英文分号“:”结尾</td></tr><tr><td>abstract</td><td>声明抽象</td><td>public abstract class C(){} <br/>介于类与接口中间，可以有也可以没有已经实现的方法体</td></tr><tr><td>implements</td><td>实现</td><td>public class A interface B(){}<br/>用于类或接口实现接口</td></tr><tr><td>extends</td><td>继承</td><td>用于类继承类<br/> public class A extends D(){}</td></tr><tr><td>new</td><td>创建新对象</td><td>A a&#x3D;new A(); A表示一个类</td></tr><tr><td>enum</td><td>定义一个枚举类</td><td>定义一个枚举类<br>public enum SexEnum { <br>male, female;  <br/>}</td></tr></tbody></table><h1 id="包（2个）"><a href="#包（2个）" class="headerlink" title="包（2个）"></a>包（2个）</h1><table><thead><tr><th>关键字</th><th>用途</th><th>备注，常用</th></tr></thead><tbody><tr><td>import</td><td>引入包的关键字</td><td>当使用某个包的一些类时，仅需类名 然后使用ctrl+shift+o或者选定类名（类或属性或方法）按住ctrl+单击 即可自动插入类所在的包。<br>import javax.swing.JFrame;</td></tr><tr><td>package</td><td>定义包的关键字</td><td>将所有有关的类放在一个包类以便查找修改等。<br/>package javake.flycat.draw002;</td></tr></tbody></table><h1 id="数据类型（12个）"><a href="#数据类型（12个）" class="headerlink" title="数据类型（12个）"></a>数据类型（12个）</h1><table><thead><tr><th>关键字</th><th>用途</th><th>备注，常用</th></tr></thead><tbody><tr><td>byte</td><td>字节型</td><td>8bit</td></tr><tr><td>char</td><td>字符型</td><td>16bit</td></tr><tr><td>boolean</td><td>布尔型</td><td>理论上1bit就行，但按最小分配单位给，一般 8bit</td></tr><tr><td>short</td><td>短整型</td><td>16bit</td></tr><tr><td>int</td><td>整型</td><td>32bit</td></tr><tr><td>float</td><td>浮点型</td><td>32bit</td></tr><tr><td>long</td><td>长整型</td><td>64bit</td></tr><tr><td>double</td><td>双精度</td><td>64bit</td></tr><tr><td>void</td><td>无返回</td><td>public void A(){}  其他需要返回的经常与return连用</td></tr><tr><td>null</td><td>空值</td><td></td></tr><tr><td>true</td><td>真</td><td>java中不能用 1 表示真，但是底层还是用 1 实现的。。</td></tr><tr><td>false</td><td>假</td><td>java中不能用 0 表示假，但是底层还是用 0 实现的。。</td></tr></tbody></table><h1 id="流程控制（12个）"><a href="#流程控制（12个）" class="headerlink" title="流程控制（12个）"></a>流程控制（12个）</h1><table><thead><tr><th>关键字</th><th>意思</th><th>备注，常用</th></tr></thead><tbody><tr><td>if</td><td>如果</td><td>if(){} 如果小括号里面怎么怎么样 花括号就怎么怎么样</td></tr><tr><td>else</td><td>否则，或者</td><td>常与if连用，用法相同</td></tr><tr><td>while</td><td>当什么的时候</td><td>while 怎么样就do什么  while(){}</td></tr><tr><td>for</td><td>满足三个条件时</td><td>for ( 条件变量 ;循环参数 ;变量改变 ){}</td></tr><tr><td>switch</td><td>开关</td><td>switch(表达式)<br/>{<br/>case 常量表达式1:语句;<br/>break<br/>case 常量表达式2:语句;<br/>break<br/>default:语句;<br/>}<br/>default就是如果没有符合的case就执行它,default并不是必须的.<br/>case后的语句可以不用大括号.<br/>switch语句的判断条件可以接受int,byte,char,short,不能接受其他类型.</td></tr><tr><td>case</td><td>返回开关里的结果</td><td></td></tr><tr><td>default</td><td>默认</td><td></td></tr><tr><td>do</td><td>运行</td><td>常与while连用</td></tr><tr><td>break</td><td>跳出循环</td><td></td></tr><tr><td>continue</td><td>继续</td><td>中断本次循环，并并开始下一次</td></tr><tr><td>return</td><td>返回</td><td>return 一个返回值类型</td></tr><tr><td>instanceof</td><td>实例</td><td>一个二元操作符，和&#x3D;&#x3D;，&gt;，&lt;是同一类的。测试它左边的对象是否是它右边的类的实例，返回boolean类型的数据</td></tr></tbody></table><h1 id="修饰方法、类、属性和变量（9个）"><a href="#修饰方法、类、属性和变量（9个）" class="headerlink" title="修饰方法、类、属性和变量（9个）"></a>修饰方法、类、属性和变量（9个）</h1><table><thead><tr><th>关键字</th><th>意思</th><th>备注，常用</th></tr></thead><tbody><tr><td>static</td><td>静态的</td><td>属性和方法都可以用static修饰，直接使用类名.属性和方法名。 只有内部类可以使用static关键字修饰，调用直接使用类名.内部类类名进行调用。  static可以独立存在。静态块</td></tr><tr><td>final</td><td>最终的不可被改变的</td><td>方法和类都可以用final来修饰  final修饰的类是不能被继承的  final修饰的方法是不能被子类重写。常量的定义：final修饰的属性就是常量。</td></tr><tr><td>super</td><td>调用父类的方法</td><td>常见<strong>public</strong> <strong>void</strong> paint(Graphics g){<strong>super</strong>.paint(g); ··· }</td></tr><tr><td>this</td><td>当前类的父类的对象</td><td>调用当前类中的方法（表示调用这个方法的对象）this.addActionListener(al):等等</td></tr><tr><td>native</td><td>本地</td><td>声明本地方法（实现底层功能的方法）</td></tr><tr><td>strictfp</td><td>严格,精准</td><td></td></tr><tr><td>synchronized</td><td>线程,同步</td><td></td></tr><tr><td>transient</td><td>短暂</td><td></td></tr><tr><td>volatile</td><td>易失</td><td></td></tr></tbody></table><h1 id="异常处理（5个）"><a href="#异常处理（5个）" class="headerlink" title="异常处理（5个）"></a>异常处理（5个）</h1><table><thead><tr><th>关键字</th><th>意思</th><th>备注，常用</th></tr></thead><tbody><tr><td>try</td><td>捕获异常</td><td></td></tr><tr><td>catch</td><td>处理异常</td><td>1.try+catch<br/>程序的流程是：运行到try块中，如果有异常抛出，则转到catch块去处理。然后执行catch块后面的语句<br/><br/>2.try+catch+finally<br/>程序的流程是：运行到try块中，如果有异常抛出，则转到catch块,catch块执行完毕后，执行finally块的代码，再执行finally块后面的代码。<br/>如果没有异常抛出，执行完try块，也要去执行finally块的代码。然后执行finally块后面的语句<br/><br/>3.try+finally<br/>程序的流程是：运行到try块中,如果有异常抛出的话，程序转向执行finally块的代码。那末finally块后面的代码还会被执行吗？不会！因为你没有处理异常，所以遇到异常后，执行完finally后，方法就已抛出异常的方式退出了。<br/>这种方式中要注意的是，由于你没有捕获异常，所以要在方法后面声明抛出异常</td></tr><tr><td>finally</td><td>有没有异常都执行</td><td>除非线程、虚拟机、cpu出现问题，不然只要能跑代码，一定会执行</td></tr><tr><td>throw</td><td>抛出一个异常对象</td><td>一些可以导致程序出问题的因素,比如书写错误,逻辑错误或者是api的应用错误等等。为了防止程序的崩溃就要预先检测这些因素,所以java 使用了异常这个机制</td></tr><tr><td>throws</td><td>声明一个异常可能被抛出</td><td>把异常交给他的上级管理，自己不进行异常处理</td></tr></tbody></table><h1 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h1><p>学习过程中没学过，下面内容百度而来，<a href="https://blog.csdn.net/yangjiachang1203/article/details/52351880">原链接</a></p><p>Java2在1.4中新增了一个关键字：assert。在程序开发过程中使用它创建一个断言(assertion)。，它的语法形式有如下所示的两种形式：<br>1、assert condition;<br>    这里condition是一个必须为真(true)的表达式。如果表达式的结果为true，那么断言为真，并且无任何行动<br>如果表达式为false，则断言失败，则会抛出一个AssertionError对象。这个AssertionError继承于Error对象，<br>而Error继承于Throwable，Error是和Exception并列的一个错误对象，通常用于表达系统级运行错误。<br>2、asser condition:expr;<br>    这里condition是和上面一样的，这个冒号后跟的是一个表达式，通常用于断言失败后的提示信息，说白了，它是一个传到AssertionError构造函数的值，如果断言失败，该值被转化为它对应的字符串，并显示出来。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 关键字 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-线性表</title>
      <link href="/2023/05/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.2/"/>
      <url>/2023/05/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.2/</url>
      
        <content type="html"><![CDATA[<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="线性表定义"><a href="#线性表定义" class="headerlink" title="线性表定义"></a>线性表定义</h2><p>线性表是具有<strong>相同数据类型</strong>的n (n≥0) 个数据元素的有限序列，其中n为表长，当n&#x3D; 0时线性表是一个空表。若用L命名线性表，则其一般表示为：L &#x3D; （a1 ,a2 ,a3 …  ,an ,）</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230624160546.png"></p><p>ai是线性表中的“第i个”元素线性表中的位序,a1是表头元素 ,an 是表尾元素</p><p>除第一个元素外，每个元素有且仅有一个直接前驱:除最后一个元素外，每个元素有且仅有一个直接后继</p><h2 id="线性表基本操作"><a href="#线性表基本操作" class="headerlink" title="线性表基本操作"></a>线性表基本操作</h2><p>InitList(&amp;L):初始化表。构造-一个空的线性表L，分配内存空间。</p><p>DestroyList(&amp;L);销毁操作。销毁线性表，并释放线性表L所占用的内存空间。</p><p>ListInsert(&amp;L,i,e):插入操作。在表L中的第i个位置上插入指定元素e。</p><p>ListDelete(&amp;L,&amp;e):删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。</p><p>LocateElem():按值查找操作。在表L中查找具有给定关键字值的元素。</p><p>GetElem(,):按位查找操作。获取表L中第1个位置的元素的值。</p><p>其他常用操作:</p><p>Length(L):求表长。返回线性表L的长度，即L中数据元素的个数。</p><p>PrintList(L):输出操作。按前后顺序输出线性表L的所有元素值。</p><p>Empty(L):判空操作。若l为空表，则返回true,否则返回false.</p><blockquote><p>对数据的操作(记忆思路)：创销、增删改查</p></blockquote><h2 id="线性表实现-顺序表（顺序存储）"><a href="#线性表实现-顺序表（顺序存储）" class="headerlink" title="线性表实现-顺序表（顺序存储）"></a>线性表实现-顺序表（顺序存储）</h2><p>顺序表：用顺序存储的方式实现线性表</p><blockquote><p>顺序存储：把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。</p></blockquote><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230624160546.png"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230624163153.png"></p><h3 id="顺序表的实现"><a href="#顺序表的实现" class="headerlink" title="顺序表的实现"></a>顺序表的实现</h3><p>静态分配</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230624164126.png"></p><p>动态分配</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230625125620.png"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230625125704.png"></p><p>顺序表特点</p><ol><li>随机访问，即可以在0(1)时间内找到第i个元素</li><li>存储密度高，每个节颜存储数据元素</li><li>拓展容量不方便(即便采用动态分配的方式实现，拓展长度的时间复杂度也比较高)</li><li>插入、删除操作不方便，需要移动大量元素</li></ol><h2 id="线性表实现-链表（链式存储）"><a href="#线性表实现-链表（链式存储）" class="headerlink" title="线性表实现-链表（链式存储）"></a>线性表实现-链表（链式存储）</h2>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-绪论</title>
      <link href="/2023/05/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.1/"/>
      <url>/2023/05/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.1/</url>
      
        <content type="html"><![CDATA[<h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><h2 id="数据-Data"><a href="#数据-Data" class="headerlink" title="数据(Data)"></a>数据(Data)</h2><p>数据：是能输入计算机且能被计算机处理的各种符号的集合</p><p>包括:</p><ol><li>数值型的数据:整数、实数等</li><li>非数值型的数据:文字、图像、图形、声音</li></ol><h2 id="数据元素-Data-Element"><a href="#数据元素-Data-Element" class="headerlink" title="数据元素(Data Element)"></a>数据元素(Data Element)</h2><p>数据元素：是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理。也简称为<strong>元素</strong>，或称为<strong>记录</strong>、结点或<strong>顶点</strong>。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230605180351.png"></p><h2 id="数据项-Data-Item"><a href="#数据项-Data-Item" class="headerlink" title="数据项(Data Item)"></a>数据项(Data Item)</h2><p>数据项：构成数据元素的不可分割的最小单位。</p><blockquote><p>数据、数据元素、数据项三者之间的关系：</p><p>数据 &gt; 数据元素 &gt; 数据项</p></blockquote><h2 id="数据对象-Data-Object"><a href="#数据对象-Data-Object" class="headerlink" title="数据对象(Data Object)"></a>数据对象(Data Object)</h2><p>数据对象：是性质相同的数据元素的集合，是数据的一个子集。</p><p>例如:</p><ul><li>整数数据对象是集合N&#x3D;{0， +1， +2， …</li><li>字母字符数据对象是集合C&#x3D;{‘A’，’B’，’Z’}</li><li>学籍表也可看作一个数据对象</li></ul><p>数据元素：组成数据的基本单位</p><p>与数据的关系:是集合的个体</p><p>数据对象：性质相同的数据元素的集合</p><p>与数据的关系是:集合的子集</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>数据元素不是孤立存在的，它们之间存在着某种关系，<strong>数据元素相互之间的关系称为结构</strong>( Structure )<br>，是指<strong>相互之间存在一种或多种特定关系</strong>的数据元素集合。或者说，数据结构是<strong>带结构的</strong>数据元素的集合</p><p>数据结构包括以下三个方面的内容:</p><ol><li>数据元素之间的<strong>逻辑关系</strong>，也称为<strong>逻辑结构</strong>。</li><li>数据元素及其关系在<strong>计算机内存中的表示</strong>(又称为<strong>映像</strong>)， 称为数据的<strong>物理结构</strong>或数据的<strong>存储结构</strong>。</li><li>数据的<strong>运算和实现</strong>，即对数据元素可以施加的操作以及这些操作在相应的存储结构上的实现。</li></ol><p>逻辑结构</p><ul><li>描述数据元素之间的逻辑关系</li><li>与数据的存储无关，独立于计算机</li><li>是从具体问题抽象出来的数学模型</li></ul><p>物理结构</p><ul><li>数据元素及其关系在计算机存储器中的结构(存储方式)</li><li>是数据结构在计算机中的表示</li></ul><p>逻辑结构与存储结构的关系:</p><ul><li>存储结构是逻辑关系的映象与元素本身的映象。</li><li>逻辑结构是数据结构的抽象，存储结构是数据结构的实现</li></ul><h2 id="逻辑结构的种类"><a href="#逻辑结构的种类" class="headerlink" title="逻辑结构的种类"></a>逻辑结构的种类</h2><p>划分一：</p><ol><li>线性结构（一对一）</li></ol><p>有且仅有一一个开始和一个终端结点，并且所有结点都最多只有一个直接前趋和一个直接后继。<br>例如：线性表、栈、队列、串</p><ol start="2"><li>非线性结构（一对多  多对多）</li></ol><p>一个个结点可能有多个直接前趋和直接后继<br>例如:树、图</p><p>划分方式二一四类基本逻辑结构</p><ol><li>集合结构:结构中的数据元素之间除了同属于一个集合的关系外，无任何其它关系。</li><li>线性结构:结构中的数据元素之间存在着一对一的线性关系。</li><li>树形结构:结构中的数据元素之间存在着一对多的层次关系。</li><li>图状结构或网状结构:结构中的数据元素之间存在着多对多的任意关系。</li></ol><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230605180429.png"></p><h2 id="存储结构的种类"><a href="#存储结构的种类" class="headerlink" title="存储结构的种类"></a>存储结构的种类</h2><p>四种基本的存储结构:</p><ol><li><p>顺序存储结构<br>用一组连续的存储单元依次存储数据元素，数据元素之间的逻辑关系由元素的存储位置来表示。</p></li><li><p>链式存储结构<br>用一组任意的存储单元存储数据元素，数据元素之间的逻辑关系用指针来表示。</p></li><li><p>索引存储结构<br>在存储结点信息的同时，还建立附加的索引表。</p></li><li><p>散列存储结构<br>根据结点的关键字直接计算出该结点的存储地址。</p></li></ol><h1 id="数据类型和抽象数据类型"><a href="#数据类型和抽象数据类型" class="headerlink" title="数据类型和抽象数据类型"></a>数据类型和抽象数据类型</h1><p>在使用高级程序设计语言编写程序时，必须对程序中出现的每个变量、常量或表达式，明确说明它们所属的数据类型。</p><p>一些最基本数据结构可以用数据类型来实现，如数组、字符串等;而另一些常用的数据结构，如栈、队列、树、图等，不能直接用数据类型来表示。</p><p>高级语言中的数据类型明显地或隐含地规定了在程序执行期间变量和表达的所有可能的取值范围，以及在这些数值范围上所允许进行的操表达的所有可能的取值范围，以及在这些数值范围上所允许进行的操作。</p><ul><li>例如，C语言中定义变量i为int类型，就表示i是[-min,max]范围的整数，在这个整数集上可以进行+、一、*、\、 %等操作</li></ul><p>数据类型的作用：</p><ol><li>约束变量或常量的取值范围。</li><li>约束变量或常量的操作。</li></ol><h2 id="数据类型-Data-Type"><a href="#数据类型-Data-Type" class="headerlink" title="数据类型(Data Type)"></a>数据类型(Data Type)</h2><p>定义:数据类型是一组性质相同的值的集合以及定义于这个值集合上的一组操作的总称。</p><p><strong>数据类型 &#x3D; 值的集合 + 值集合上的一组操作</strong></p><h2 id="抽象数据类型-Abstract-Data-Type-ADT"><a href="#抽象数据类型-Abstract-Data-Type-ADT" class="headerlink" title="抽象数据类型(Abstract Data Type, ADT)"></a>抽象数据类型(Abstract Data Type, ADT)</h2><p>是指一个数学模型以及定义在此数学模型.上的一-组操作。</p><p>包括：</p><ol><li>由用户定义，从问题抽象出数据模型(逻辑结构)</li><li>还包括定义在数据模型上的一组抽象运算(相关操作)</li><li>不考虑计算机内的具体存储结构与运算的具体实现算法</li></ol><h3 id="抽象数据类型的形式定义"><a href="#抽象数据类型的形式定义" class="headerlink" title="抽象数据类型的形式定义"></a>抽象数据类型的形式定义</h3><p>抽象数据类型可用(D, S, P)三元组表示</p><ol><li>D 是数据对象</li><li>S是 D 上的关系集</li><li>P是对 D 的基本操作集</li></ol><h1 id="算法和算法分析"><a href="#算法和算法分析" class="headerlink" title="算法和算法分析"></a>算法和算法分析</h1><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/Snipaste_2023-06-04_16-03-53.png"></p><p>算法的定义：</p><p>对特定问题求解方法和步骤的一种描述，它是指令的有限序列。其中每个指令表示一个或多个操作。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/Snipaste_2023-06-04_16-05-06.png"></p><p>算法的描述</p><ol><li>自然语言：英语、中文</li><li>流程图：传统流程图、NS流程图</li><li>伪代码：类语言：C语言（最常见）</li><li>程序代码: C语言程序、JAVA语言程….</li></ol><p>算法与程序：</p><ul><li>算法是解决问题的一种方法或一个过程， 考虑如何将输入转换成输出,一个问题可以有多种算法。</li><li>程序是用某种程序设计语言对算法的具体实现。</li></ul><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/Snipaste_2023-06-04_16-07-46.png"></p><h2 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h2><p>一个算法必须具备以下五个重要特性：</p><ol><li>有穷性：一个算法必须总是在执行有穷步之后结束，且每一步都在有穷时间内完成。</li><li>确定性：算法中的每一条指令必须有确切的含义，没有二_义性，在任何条件下，只有唯一的一条执行路径，即对于相同的输入只能得到相同的输出。</li><li>可行性：算法是可执行的，算法描述的操作可以通过已经实现的基本操作执行有限次来实现。</li><li>输入：一个算法有零个或多个输入。</li><li>输出：一个算法有一个戴多个输出。</li></ol><h2 id="算法设计的要求"><a href="#算法设计的要求" class="headerlink" title="算法设计的要求"></a>算法设计的要求</h2><ol><li>正确性(Correctness)<br><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/Snipaste_2023-06-04_16-10-15.png"></li><li>可读性(Readability)<br><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/Snipaste_2023-06-04_16-10-36.png"></li><li>健壮性(Robustness)<br><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/Snipaste_2023-06-04_16-10-53.png"></li><li>高效性(Efficiency)<br><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/Snipaste_2023-06-04_16-11-42.png"></li></ol><h2 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h2><p>一个好的算法首先要具备正确性，然后是健壮性，可读性，在几个方面都满足的情况下，主要考虑算法的效率，通过算法的效率高低来评判不同算法的优劣程度。</p><p>算法效率以下两个方面来考虑：</p><ol><li><p>时间效率:指的是算法所耗费的时间;</p></li><li><p>空间效率:指的是算法执行过程中所耗费的存储空间。</p></li></ol><blockquote><p>时间效率和空间效率有时候是矛盾的。</p></blockquote><h3 id="算法时间效率的度量"><a href="#算法时间效率的度量" class="headerlink" title="算法时间效率的度量"></a>算法时间效率的度量</h3><p>算法时间效率可以用依据该算法编制的程序在计算机上执行所消耗的时间来度量。</p><p>两种度量方法：</p><ol><li>事后统计：将算法实现,测算其时间和空间开销。</li><li>事前分析：对算法所消耗资源的一种估算方法。</li></ol><h4 id="事前分析方法"><a href="#事前分析方法" class="headerlink" title="事前分析方法"></a>事前分析方法</h4><p>一个算法的运行时间是指一个算法在计算机上运行所耗费的时间大致可以等于计算机执行一种简单的操作(如赋值、比较、移动等)所需的时间与算法中进行的简单操作次数乘积。</p><p><strong>算法运行时间 &#x3D; 一个简单操作所需的时间 x 简单操作次数</strong></p><p>也即算法中每条语句的执行时间之和</p><p>算法运行时间 &#x3D; ∑ 每条语句的执行次数（语句频度） x 该语句执行一次所需的时间</p><p>我们把算法所耗费的时间定文为该算法中每条语句的频度之和，算法的时间消耗记为 T(n)</p><p>为了便于比较不同算法的时间效率，我们仅比较它们的<strong>数量级</strong>。记作T(n)&#x3D;O(f(n))，称O(f(n))为算法的<strong>渐进时间复杂度</strong> (O是数量级的符号)，简称<strong>时间复杂度</strong>。</p><p>最坏时间复杂度:指在最坏情况下，算法的时间复杂度。</p><p>平均时间复杂度:指在所有可能输入实例在等概率出现的情况下，算法的期望运行时间。</p><p>最好时间复杂度:指在最好情况下，算法的时间复杂度。</p><blockquote><p>一般总是考虑在最坏情况下的时间复杂度，以保证算法的运行时间不会比它更长。</p></blockquote><p>对于复杂的算法，可以将它分成几个容易估算的部分，然后利用大O 加法法则和乘法法则，计算算法的时间复杂度: </p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/Snipaste_2023-06-04_16-30-41.png"></p><h3 id="渐进空间复杂度"><a href="#渐进空间复杂度" class="headerlink" title="渐进空间复杂度"></a>渐进空间复杂度</h3><p>空间复杂度:算法所需存储空间的度量，</p><p>记作：S(n)&#x3D;O(f(n))  其中n为问题的规模(或大小) </p><p>算法要占据的空间：</p><ol><li>算法本身要占据的空间，输入&#x2F;输出，指令，常数，变量等</li><li>算法要使用的辅助空间</li></ol>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-引言</title>
      <link href="/2023/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.1/"/>
      <url>/2023/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.1/</url>
      
        <content type="html"><![CDATA[<h1 id="因特网简介"><a href="#因特网简介" class="headerlink" title="因特网简介"></a>因特网简介</h1><h2 id="网络，互联网与因特网的区别于关系"><a href="#网络，互联网与因特网的区别于关系" class="headerlink" title="网络，互联网与因特网的区别于关系"></a>网络，互联网与因特网的区别于关系</h2><p>网络：使用有线链路的简单网络</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514115621.png"></p><p>互联网：若干网络通过路由器互联形成互联网</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514115639.png"></p><p>因特网：最大的互联网，日常生活中，人们口中的互联网指因特网</p><p>Internet 与 internet对比：</p><p>Internet：专用名词，必须使用 TCP&#x2F;IP 协议族，叫做因特网</p><p>internet：通用名词，可以使用任意的协议，叫互联网</p><h2 id="因特网发展的三个阶段"><a href="#因特网发展的三个阶段" class="headerlink" title="因特网发展的三个阶段"></a>因特网发展的三个阶段</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514120308.png"></p><p>ISP：internet service provider，因特网服务提供者</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514120513.png"></p><p>因特网已发展成为基于ISP的多层次结构的互连网络，三层ISP结构互联网示意图</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514120708.png"></p><h2 id="因特网标准化工作"><a href="#因特网标准化工作" class="headerlink" title="因特网标准化工作"></a>因特网标准化工作</h2><p>因特网的标准化工作是面向公众的,其任何一个建议标准在成为因特网标准之前都以RFC技术文档的形式在因特网上发表。<br>RFC (Request For Comments)的意思是“请求评论”。任何人都可以从因特网上免费下载RFC文档(<a href="http://ww.etf.org/rfc.html">http://ww.etf.org/rfc.html</a>) ，并随时对某个RFC文档发表意见和建议。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514121151.png"></p><h2 id="因特网的管理机构"><a href="#因特网的管理机构" class="headerlink" title="因特网的管理机构"></a>因特网的管理机构</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514121239.png"></p><h2 id="因特网组成"><a href="#因特网组成" class="headerlink" title="因特网组成"></a>因特网组成</h2><p>因特网由<strong>核心部分</strong>和<strong>边缘部分</strong>组成</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514121431.png"></p><p>核心部分：大量异构网络和连接这些网络搭建服务器组成，为边缘部分提供连通性和数据交换服务</p><p>边缘部分：由各个用户设备组成，这些设备称为主机，直接由用户使用，为用户提供网络服务</p><p>核心部分中起特殊作用的是路由器，用来实现分组交换，分组交换是网络核心部分最重要的功能</p><h1 id="数据交换方式"><a href="#数据交换方式" class="headerlink" title="数据交换方式"></a>数据交换方式</h1><p>数据交换有：<strong>电路交换，分组交换，报文交换</strong></p><h2 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514122122.png"></p><p>电路交换过程由于链路一直存在，占用资源，导致线路传输效率一般都会很低</p><h2 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h2><p>采用报文的方式，将长数据分解成一段段的带首部的短数据。分组交换网中的节点先缓存短数据，然后从首部中提取出目的的地址，按照目的地址查找自己的转发表，找到相应的转发接口后，将分组转发出去把分组交给下一个转发节点，经过多个节点的存储转发后，分组最终转发到目的主机。主机接收到数据后，去掉首部，将各数据段组合还原出原始报文</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514123235.png"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514123408.png"></p><h2 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h2><p>报文交换是<strong>分组交换的前身</strong>，在报文交换中， <strong>报文被整个地发送</strong>，而不是拆分成若干个分组进行发送。交换节点将报文<strong>整体接收完成后才能查找转发表</strong>，将整个报文转发到下一个节点。因此，报文交换比分组交换带来的<strong>转发时延要长很多</strong>，需要交换节点具有的<strong>缓存空间也大很多</strong>。</p><h2 id="三种交换方式的对比"><a href="#三种交换方式的对比" class="headerlink" title="三种交换方式的对比"></a>三种交换方式的对比</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514123725.png"></p><p>若要连续传送大量的数据，并且数据传送时间远大于建立连接的时间，则使用电路交换可以有较高的传输效率。然而计算机的数据传送往往是突发式的，采用电路交换时通信线路的利用率会很低。</p><p>报文交换和分组交换都不需要建立连接(即预先分配通信资源) ，在传送计算机的突发数据时可以提高通信线路的利用率。</p><p>将报文构造成若干个更小的分组进行分组交换，比将整个报文进行报文交换的时延要小，并且还可以避免太长的报文长时间占用链路，有利于差错控制，同时具有更好的灵活性。</p><h1 id="计算机网络定义和分类"><a href="#计算机网络定义和分类" class="headerlink" title="计算机网络定义和分类"></a>计算机网络定义和分类</h1><h2 id="计算机网络定义"><a href="#计算机网络定义" class="headerlink" title="计算机网络定义"></a>计算机网络定义</h2><p><strong>早期</strong>计算机网络定义：一些互联的、自治的、计算机集合</p><p>互联：可通过有线或无线的方式进行数据通信</p><p>自治：独立的计算机有自己的硬件和软件，可独立运行</p><p>计算机集合：至少2台及以上的计算机</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514124344.png"></p><p><strong>现阶段</strong>计算机网络定义：计算机网络主要是由一些通用的、可编程的硬件互连而成的，而这些硬件并非专门用来实现某一特定目的(例如，传送数据或视频信号)这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。</p><p>可编程的硬件：不限于计算机，而是包括了智能手机、具有网络功能的传感器以及智能家电等智能硬件，这些硬件一定包含有中央处理单元(CPU)</p><p>各类应用：计算机网络并非只用来传送数据，而是能够基于数据传送进而实现各种各样的应用，包括今后可能出现的各种应用。</p><h2 id="计算机网络分类"><a href="#计算机网络分类" class="headerlink" title="计算机网络分类"></a>计算机网络分类</h2><p>交换方式：可分为<strong>电路交换、报文交换、分组交换</strong></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514123725.png">使用者：可分为<strong>公用网、专用网</strong></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514124819.png"></p><p>传输介质：</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514124937.png"></p><p>覆盖范围：</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514124954.png"></p><p>拓扑：</p><p>总线型：使用单根传输线把计算机连接起来<br>星型<br>环型<br>网状型</p><h1 id="计算机网络性能指标"><a href="#计算机网络性能指标" class="headerlink" title="计算机网络性能指标"></a>计算机网络性能指标</h1><p>从不同方面度量计算机网络的性能：常用的八个计算机网络的性能指标</p><h2 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h2><p>速率是指<strong>数据的传送速率(即每秒传送多少个比特)<strong>，也称为</strong>数据率</strong>(Data Rate) 或<strong>比特率</strong>(Bit Rate)</p><p>速率的基本单位是比特秒（bit&#x2F;s）, 可简记为 b&#x2F;s ,有时也记为bps,即bit per second) 。速率的常用单位有千比特秒(kb&#x2F;s或kbps) 、兆比特秒(Mb&#x2F;s或Mbps) 、吉比特秒(Gb&#x2F;s或Gbps) 以及太比特秒<br>(Tb&#x2F;s或Tbps)。<img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514125655.png"></p><p>比特(bit, 记为小写b)是计算机中数据量的基本单位，一个比特就是二进制数字中的一个1或0。</p><p>数据量的常用单位有字节(byte， 记为大写B)、干字节(KB)、兆字节(MB)、吉字节(GB)以及太字节(TB) 。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514125632.png"></p><blockquote><p>做题时注意字母代表的数字是多少进制，注意看是 B 还是 b</p></blockquote><h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514125906.png"></p><p>带宽：用来表示网络的通信线路所能传送数据的能力，即在单位时间内，能传送的最高数据率，单位与速度相同</p><p>数据传送速率&#x3D; min [主机接口速率,线路带宽,交换机或路由器的接口速率]</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514130228.png"></p><h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>吞吐量：单位时间内通过某个网络或接口的实际数据量，受带宽限制</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514130409.png"></p><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>时延：数据从网络的一端传送到另一端所耗费的时间，也称为延迟或迟延。</p><p>总时延 &#x3D; 发送时延 + 传播时延 + 处理时延 + 排队时延</p><p>发送时延</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514130629.png"></p><p>传播时延</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514130653.png"></p><p>处理时延、排队时延不便计算，一般给出或不计</p><p>电磁波传播速度：</p><p>自由空间：3.0x10^8</p><p>铜线：2.3x10^8</p><p>光纤：2.0x10^8</p><blockquote><p>选光纤是因为光纤带宽大</p></blockquote><p>例题.多段路由器下时延计算通用公式</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514131839.png"></p><p>电路交换：时延&#x3D;2x建立连接时间+报文发送时间+报文传输时间(连接释放时间与其重叠）</p><p>分组交换：报文发送时间+传播时间+中间结点转发时间</p><h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><p>时延带宽积 &#x3D; 传播时延 x 带宽</p><p>链路的时延带宽积又称为以比特为单位的链路长度。</p><h2 id="往返时间"><a href="#往返时间" class="headerlink" title="往返时间"></a>往返时间</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514132134.png"></p><h2 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h2><p>信道利用率：用来表示某信道有百分之几的时间是被利用的(有数据通过)。<br>网络利用率：全网络的信道利用率的加权平均。</p><p>根据排队论，当某信道的利用率增大时，该信道引起的时延也会迅速增加。因此，<strong>信道利用率并非越高越好</strong></p><p>如果令D0表示网络空闲时的时延，D表示网络当前的时延，那么在适当的假定条件下，可以用下面的简单公式来表示D、D0和利用率U之间的关系:</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514132402.png"></p><h2 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h2><p>丢包率即分组丢失率,是指在一定的时间范围内，传输过程中丢失的分组数量与总分组数量的比率。</p><p>丢包率具体可分为接口丢包率、结点丢包率、链路丢包率、路径丢包率、网络丢包率等。</p><p>丢包率是网络运维人员非常关心的一个网络性能指标,但对于普通用户来说往往并不关心这个指标，因为他们通常意识不到网络丢包。</p><p>分组丢失主要有两种情况:</p><ol><li>分组在传输过程中出现误码，被结点丢弃。</li><li>分组到达一台队列已满的分组交换机时被丢弃;在通信量较大时就可能造成网络拥塞。</li></ol><p>因此，丢包率反映了网络的拥塞情况:</p><p>无拥塞时路径丢包率为0，轻度拥塞时路径丢包率为1%<del>4%，严重拥塞时路径丢包率为5%</del>15%</p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-运输层</title>
      <link href="/2023/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.3/"/>
      <url>/2023/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.3/</url>
      
        <content type="html"><![CDATA[<h1 id="数据传输过程"><a href="#数据传输过程" class="headerlink" title="数据传输过程"></a>数据传输过程</h1><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514152751.png"></p><p>数据沿图中止下多次的虚线方向传送的</p><p>运输层直接为应用进程间的逻辑通信提供服务</p><p>运输层向高层用户屏蔽了下面网络核心的细节(如网络拓扑、所采用的路由选择协议等) ，它使应用进看见的就好像是在两个运输层实体之间有一条端到端的逻辑通信信道。根据应用需求的不同，因特网的运输层为应用层提供了两种不同的运输协议，即<strong>面向连接的TCP</strong>和<strong>无连接的UDP</strong>，这两种协议就是本章要讨论的主要内容。</p><h1 id="TCP-x2F-IP-体系结构"><a href="#TCP-x2F-IP-体系结构" class="headerlink" title="TCP&#x2F;IP 体系结构"></a>TCP&#x2F;IP 体系结构</h1><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230520181329.png"></p><p>网络接口层并没有规定什么具体内容，这是为了可以使用各种不同的网络接口，这是 TCP&#x2F;IP体系结构网际层中的协议。</p><p>网际协议 IP 是网际层中的核心协议，它可以互连不同的网络接口，也就是互连各种异构型网络，并为其上层提供无连接，不可靠的数据报传输服务。</p><p>应用层中，包含有大量的应用层协议，其中有些应用层协议需要使用可靠传输服务，有些应用层协议使用不可靠传输协议。</p><p>TCP&#x2F;IP 体系结构运输层的主要任务就是使用端口号，为运行再不同主机上的应用进程，提供逻辑通信服务，使用 TCP 协议为应用层中那些需要使用可靠传输服务的协议，提供可靠传输服务，另外使用 UDP 协议为应用层中那些使用不可靠传输服务的协议提供不可靠传输服务。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230520182140.png"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230520182241.png"></p><h1 id="运输层端口号"><a href="#运输层端口号" class="headerlink" title="运输层端口号"></a>运输层端口号</h1><p>运行在计算机上的进程使用进程标识符PID来标志。因特网_上的计算机并不是使用统- -的操作系统，不同的操作系统(windows, Linux, Mac OS)又使用不同格式的进程标识符。为了使运行不同操作系统的计算机的应用进程之间能够进行网络通信，就必须使用统- -的方法对TCP&#x2F;IP体系的应用进程进行标识。</p><p>TCP&#x2F;IP体系的运输层使用端口号来区分应用层的不同应用进程。端口号使用16比特表示，取值范围0~65535;</p><ol><li>熟知端口号: 0~1023, IANA把这些端口号指派给了TCP&#x2F;IP体系中最重要的一些应用协议，例如:FTP使用21&#x2F;20, HTTP使用80, DNS使用53.</li><li>登记端口号: 1024~49151,为没有熟知端口号的应用程序使用。使用这类端口号必须在IANA按照规定的手续登记，以防止重复。例如: Microsoft RDP微软远程桌面使用的端口是3389。</li><li>短暂端口号: 49152~65535, 留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。</li></ol><blockquote><p>端口号只具有本地意义，即端口号只是为了标识本计算机应用层中的各进程，在因特网中,不同计算机中的相同端口号是没有联系的。</p></blockquote><h1 id="发送方的复用和接收方的分用"><a href="#发送方的复用和接收方的分用" class="headerlink" title="发送方的复用和接收方的分用"></a>发送方的复用和接收方的分用</h1><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230520183055.png"></p><p>发送方的某些应用进程所发送的不同应用报文，在运输层使 UDP 协议进行封装，称为 UDP复用</p><p>一些应用进程所发送的不同应用报文，在运输层使用 TCP 协议进行封装，这称为 TCP 复用</p><p>运输层使用端口号来区分不同的应用进程，不管是使用运输层的 UDP 协议封装成的 UDP 用户数据报，还是使用 TCP 协议封装成的 TCP 报文段，在网络层都需要使用 IP协议封装成 IP 数据报，这称为 IP 复用</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230520183256.png"></p><h1 id="UDP和TCP"><a href="#UDP和TCP" class="headerlink" title="UDP和TCP"></a>UDP和TCP</h1><p>UDP和TCP是TCP&#x2F;IP体系结构运输层中的两个重要协议</p><h2 id="二者对比"><a href="#二者对比" class="headerlink" title="二者对比"></a>二者对比</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230520184351.png"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230520183623.png"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230520183731.png"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/image-20230520184044122.png" alt="image-20230520184044122"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230520184244.png"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230520184312.png"></p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>为了实现可靠传输，TCP采用了<strong>面向字节流</strong>的方式。但TCP在发送数据时，是从发送缓存取出一-部分或全部字节并给其添加一个首部使之成为<strong>TCP报文段</strong>后进行发送。</p><p>一个TCP报文段由首部和数据载荷两部分构成。</p><h3 id="TCP首部"><a href="#TCP首部" class="headerlink" title="TCP首部"></a>TCP首部</h3><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230520184619.png"></p><p>源端口：占16比特，写入源端口号，用来标识发送该TCP报文段的应用进程。</p><p>目的端口：占16比特，写入目的端口号，用来标识接收该TCP报文段的应用进程。</p><p>序号:占32比特，序号增加到最后一个后，下一个序号就又回到0，指出本TCP报文段数据载荷的第一个字节的序号.</p><p>确认号：占32比特，确认号增加到最后-一个后，下一一个确认号就又回到0，指出期望收到对方下一个TCP报文段的数据载荷的第一个字节的序号，同时也是对之前收到的所有数据的确认。若确认号&#x3D;n,则表明到序号n-1为止的所有数据都已正确接收，期望接收序号为n的数据。</p><p>数据偏移：占4比特，并以4字节为单位。用来指出TCP报文段的数据载荷部分的起始处距离TCP报文段的起始处有多远。这个字段实际，上是指出了TCP报文段的首部长度。首部固定长度为20字节，因此数据偏移字段的最小值为(0101)2首部最大长度为60字节，因此数据偏移字段的最大值为(1111)2</p><p>保留:占6比特，保留为今后使用，但目前应置为0。</p><p>紧急标志位URG:取值为1时紧急指针字段有效;取值为0时紧急指针字段无效。</p><p>确认标志位ACK:取值为1时确认号字段才有效;取值为0时确认号字段无效。</p><p>推送标志位PSH:接收方的TCP收到该标志位为1的报文段会尽快上交应用进程,而不必等到接收缓存都填满后再向上交付。</p><p>复位标志位RST:用来复位TCP连接。当RST&#x3D;1时，表明TCP连接出现了异常，必须释放连接，然后再重新建立连接。RST置1还用来拒绝-一个非法的报文段或拒绝打开- -个TCP连接。</p><p>同步标志位SYN:在TCP连接建立时用来同步序号。</p><p>终止标志位FIN:用来释放TCP连接。</p><p>窗口:占16比特，以字节为单位。指出发送本报文段的- -方的接收窗口。窗口值作为接收方让发送方设置其发送窗口的依据。</p><p>校验和:占16比特，检查范围包括TCP报文段的首部和数据载荷两部分。在计算校验和时，要在TCP报文段的前面加上12字节的伪首部。</p><p>紧急指针:占16比特，以字节为单位，用来指明紧急数据的长度。</p><p>选项：</p><ol><li>最大报文段长度MSS选项: TCP报文段数据载荷部分的最大长度。</li><li>窗口扩大选项:为了扩大窗口(提高吞吐率)。</li><li>时间戳选项: 用来计算往返时间RTT，用于处理序号超范围的情况， 又称为防止序号绕回PAWS。</li><li>选择确认选项</li></ol><p>填充:由于选项的长度可变，因此使用填充来确保报文段首部能被4整除(因为数据偏移字段,也就是首部长度字段，是以4字节为单位的)</p><h3 id="TCP连接建立"><a href="#TCP连接建立" class="headerlink" title="TCP连接建立"></a>TCP连接建立</h3><p>TCP是面向连接的协议，它基于运输连接来传送TCP报文段。TCP运输连接的建立和释放是每一次面向连接的通信中必不可少的过程。</p><p>TCP运输连接有以下三个阶段:</p><ol><li>建立TCP连接（三握手）</li><li>数据传送</li><li>释放TCP连接（四挥手）</li></ol><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230520192534.png"></p><p>TCP的连接建立要解决以下三个问题:</p><ol><li>使TCP双方能够确知对方的存在;</li><li>使TCP双方能够协商- 些参数(如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等) ;</li><li>使TCP双方能够对运输实体资源 (如缓存大小、连接表中的项目等)进行分配。</li></ol><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230520201746.png"></p><p>三握手过程：</p><ol><li>TCP服务器进程首先创建传输控制块。用来存储TCP连接中的一些重要信息。就准备接受TCP客户进程的连接请求。此时，TCP服务器进程就进入监听状态。</li><li>TCP客户进程也是首先创建传输控制块。在打算建立TCP连接时向TCP服务器迸程发送TCP连接请求报文段并进入同步已发送状态。</li><li>TCP服务器进程则向TCP客户进程发送TCP连接清求确认报文段。并进入同步已接收状态。</li><li>TCP客户进程收到TCP连接清求确认报文段后。还要向TCP服务器进程发送一个普通的TCP确认报文段。并进入连接已建立状态。</li><li>TCP服务器进程收到该确认报文段后也进入连接已建立状态。</li></ol><p>注意: TCP规定SYN被设置为1的报文段不能携带数据。但要消耗掉一个序号。</p><p>为什么是三握手而不能简化为两握手：</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230520202001.png"></p><p>如上图，TCP客户进程发送一个连接请求，但该报文段在某些网络结点长时间滞留了。这必然会造成该报文段的超时重传。假设重传的报文段被TCP服务器进程常接收。TCP服务器迸程给TCP客户进程发送一个TCP连接请求确认报文段并进入连接已建立状态。一段时间后，之前滞留在网络中的那个失效的 TCP 连接请求报文段，到达了 TCP 服务器进程。TCP 服务器进程会误认为这是 TCP 客户进程又发起了一个新的 TCP连接请求。于是给 TCP 客户进程发送 TCP 连接请求确认报文段，并进入连接已建立状态。由于 TCP 客户进程并没有发起新的 TCP 连接请求，并且处于关闭状态，因此不会理会该报文段。但 TCP 服务器已进入连接已建立状态，它认为新的 TCP连接已建立好了，并一直等待 TCP 客户进程发来数据，这将白白浪费 TCP 服务器进程所在主机的很多资源。</p><h3 id="TCP连接释放"><a href="#TCP连接释放" class="headerlink" title="TCP连接释放"></a>TCP连接释放</h3><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230520212350.png">四挥手过程：</p><p>1. </p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-应用层</title>
      <link href="/2023/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.2/"/>
      <url>/2023/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.2/</url>
      
        <content type="html"><![CDATA[<h1 id="应用层概述"><a href="#应用层概述" class="headerlink" title="应用层概述"></a>应用层概述</h1><p>应用层是计算机网络体系结构的最顶层，是设计和建立计算机网络的最终目的，也是计算机网络中发展最快的部分。</p><ul><li>早期基于文本的应用(电子邮件、远程登录、文件传输、新闻组)。</li><li>20世纪90年代将因特网带入干家万户的万维网WWW。</li><li>当今流行的即时通信、P2P文件共享及各种音视频应用。</li><li>计算设备的小型化和“无处不在”，宽带住宅接入和无线接入的日益普及和迅速发展，为未来更多<br>的新型应用提供了广阔的舞台。</li></ul><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514132852.png"></p><h1 id="应用进程通信方式"><a href="#应用进程通信方式" class="headerlink" title="应用进程通信方式"></a>应用进程通信方式</h1><p>网络应用程序运行在处于网络边缘的不同的端系统上,通过彼此间的通信来共同完成某项任务。</p><p>开发一种新的网络应用首先要考虑的问题就是网络应用程序在各种端系统上的组织方式和它们之间的关系。<br>目前流行的主要有以下两种:</p><h2 id="客户-x2F-服务器方式"><a href="#客户-x2F-服务器方式" class="headerlink" title="客户&#x2F;服务器方式"></a>客户&#x2F;服务器方式</h2><p>应用层的许多协议是基于C&#x2F;S方式，例如，在移动互联网环境下，每个应用APP都是一个客户端。</p><p>客户&#x2F;服务器方式特点：</p><ul><li>客户(client)和服务器(server)是指通信中所涉及的2个应用进程</li><li>客户&#x2F;服务器方式描述的是应用进程之间服务和被服务的关系</li><li>客户是服务请求方(主动请求服务，被服务)</li><li>服务器是服务提供方(被动接受服务请求提供服务)</li><li>服务器总是处于运行状态，并等待客户的服务请求。服务器具有固定端口号(例如HTTP服务<br>器的默认端口号为80) ，而运行服务器的主机也具有固定的IP地址。</li></ul><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514133535.png"></p><p>主机 A 中运行的是客户程序，正在运行的客户程序称为客户进程，也可简称为客户。主机 A 应称为客户计算机，也可简称为客户。</p><p>主机 B 中运行的是服务器程序，正在运行的服务器程序称为服务器进程，也可简称为服务器。主机 B 应称为服务器计算机，也可简称为服务器。</p><p>C&#x2F;S方式是因特网上传统的、同时也是最成熟的方式，很多我们熟悉的网络应用采用的都是C&#x2F;S方式。包括万维网WWW.电子邮件、文件传输FTP等。</p><p>基于C&#x2F;S方式的应用服务通常是服务集中型的，即应用服务集中在网络中比客户计算机少得多的服务器计算机上。</p><p>由于一台服务器计算机要为多个客户机提供服务,在C&#x2F;S应用中，常会出现服务器计算机跟不上众多客户机请求的情况。</p><p>为此，在C&#x2F;S应用中，常用计算机群集(或服务器场)构建一个强大的虚拟服务器。</p><h2 id="浏览器-x2F-服务器方式"><a href="#浏览器-x2F-服务器方式" class="headerlink" title="浏览器&#x2F;服务器方式"></a>浏览器&#x2F;服务器方式</h2><ul><li>B&#x2F;S方式可以看做C&#x2F;S方式的特例，即客户软件改为浏览器了</li><li>B&#x2F;S方式采取浏览器请求、服务器响应的工作模式</li><li>在B&#x2F;S方式下，用户界面完全通过Web浏览器实现，一部分事务逻辑在前端实现，但主要的事务逻辑在服务器端实现</li></ul><p>B&#x2F;S方式通常采取3层架构实现</p><ol><li>数据层:由数据库服务器承担数据处理逻辑，其任务是接受Web服务器对数据库服务器提出的数据操作请求，然后由数据库服务器进行数据处理并把处理结果返回给web服务器</li><li>处理层:由Web服务器承担业务处理逻辑和页面存储管理，接受客户浏览器的任务请求，执行<br>相应的事务处理</li><li>表现层:浏览器仅承担网页信息的浏览功能，以，超文本格式实现信息的输入和浏览</li></ol><blockquote><p>实际部署时也可以把数据库服务器和web服务器部署在同一台设备上</p></blockquote><p>B&#x2F;S方式的特点：</p><ul><li>界面统- -, 使用简单。客户端只需要安装浏览器软件</li><li>易于维护。对应用系统升级时，只需更新服务器端的软件，减轻了系统维护和升级的成本</li><li>可扩展性好。采用标准的TCP&#x2F;IP和HTTP协议，具有良好的扩展性</li><li>信息共享度高。HTML是数据格式的一个开放标准，目前大多数流行的软件均支持HTML</li><li>需要注意的是，在- -种浏览器环境下开发的界面在另一种浏览器环境下可能有不完全适配的情况，这时需要安装对应的浏览器</li></ul><h2 id="对等方式"><a href="#对等方式" class="headerlink" title="对等方式"></a>对等方式</h2><p>在P2P方式中，没有固定的服务请求者和服务提供者,分布在网络边缘各端系统中的应用进程是对等<br>的，被称为对等方。对等方相互之间直接通信，每个对等方既是服务的请求者，又是服务的提供者。</p><p>目前，在因特网.上流行的P2P应用主要包括P2P文件共享、即时通信、P2P流媒体、分布式存储等</p><p>基于P2P的应用是服务分散型的，因为服务不是集中在少数几个服务器计算机中,而是分散在大量对等计算机中，这些计算机并不为服务提供商所有，而是为个人控制的桌面计算机和笔记本电脑，它们通常位于住宅、校园和办公室中。</p><p>P2P方式的最突出特性之一就是它的可扩展性。 因为系统每增加一一个对等方,不仅增加的是服务的请求者，同时也增加了服务的提供者，系统性能不会因规模的增大而降低。</p><p>P2P方式具有成本上的优势，因为它通常不需要庞大的服务器设施和服务器带宽。为了降低成本,服务提供商对于将P2P方式用于应用的兴趣越来越大。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514134619.png"></p><p>对比：</p><p><img src="https://raw.githubusercontent.com/icyhalo/picgo/main/20230514134649.png"></p><h1 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h1><p>域名系统DNS作用：方便用户记忆，但IP地址和域名的映射关系并非永久不变</p><h2 id="层次树状结构的域名结构"><a href="#层次树状结构的域名结构" class="headerlink" title="层次树状结构的域名结构"></a>层次树状结构的域名结构</h2><p>早在1983年，因特网就开始采用层次结构的命名树作为主机的名字(即域名)并使用分布式的域名系统DNS。<strong>DNS使大多数域名都在本地解析，仅少量解析需要在因特网上通信，因此系统效率很高</strong>。</p><p>域名的结构由若干个分量组成，各分量之间用“点”隔开,分别代表不同级别的域名</p><ol><li>每一级的域名都由英文字母和数字组成，不超过63个字符，不区分大小写字母。</li><li>级别最低的域名写在最左边，而级别最高的顶级域名写在最右边。</li><li>完整的域名不超过255个字符。</li></ol><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514142044.png"></p><p>域名系统既不规定一个域名需要包含多少个下级域名， 也不规定每一级的域名代表什么意思。</p><p>各级域名由其上一级的域名管理机构管理，而最高的顶级域名则由因特网名称与数字地址分配机构ICANN进行管理。</p><h2 id="顶级域名TLD"><a href="#顶级域名TLD" class="headerlink" title="顶级域名TLD"></a>顶级域名TLD</h2><p>顶级域名TLD分为3类：</p><ol><li>国家顶级域名nTLD：采用ISO 3166的规定。如cn表示中国</li><li>通用顶级域名gTLD：最常见的通用顶级域名有七个，即: com (公司企业)、net (网络服务机构)、org (非营利性组织)、int (国际组织)、edu (美国教育结构)、gov (美国政府部门)、mil (美国军事部门)</li><li>反向域arpa：用于反向域名解析，即IP地址反向解析为域名。</li></ol><h2 id="二级域名"><a href="#二级域名" class="headerlink" title="二级域名"></a>二级域名</h2><p>在国家顶级域名下注册的二级域名均由该国家自行确定。我国则将二级域名划分为以下两类:</p><ol><li>类别域名：共七个: ac (科研机构)、com (工、商、金融等企业)、edu (教育机构) .gov (政府部门) . net (提供网络服务的机构)、mil (军事机构)和org (非营利性组织)。</li><li>行政区域名：共34个，适用于我国的各省、自治区、直辖市。</li></ol><blockquote><p>需要注意的是，名称相同的域名其登记未必相同。例如，com 是通用顶级域名，但我国顶级</p><p>域名 cn 下也有一个名称为 com 的二级域名</p></blockquote><h2 id="因特网的域名空间"><a href="#因特网的域名空间" class="headerlink" title="因特网的域名空间"></a>因特网的域名空间</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514142622.png"></p><p>这种按等级管理的命名方法便于维护名字的唯一性， 并且也容易设计出一种高效的域名查询机制。需要注意的是，域名只是个逻辑概念，并不代表计算机所在的物理地点。MAC才是物理地址</p><h2 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h2><p>域名和IP地址的映射关系必须保存在域名服务器中,供所有其他应用查询。显然不能将所有信息都储存在一台域名服务器中。DNS使用分布在各地的域名服务器来实现域名到IP地址的转换。</p><p>域名服务器可以划分为以下四种不同的类型：</p><ol><li><p>根域名服务器：</p><p>根域名服务器是<strong>最高层次的域名服务器</strong>。<strong>每个根域名服务器都知道所有的顶级域名服务器的域名及其IP地址</strong>。因特网上共有13个不同IP地址的根域名服务器。尽管我们将这13个根域名服务器中的每一个都视为单个的服务器, 但“每台服务器”实际上是由许多分布在世界各地的计算机构成的服务器群集。<strong>当本地域名服务器向根域名服务器发出查询请求时，路由器就把查询请求报文转发到离这个DNS客户最近的-一个根域名服务器。这就加快了DNS的查询过程</strong>，同时也更合理地利用了因特网的资源。<strong>根域名服务器通常并不直接对域名进行解析，而是返回该域名所属顶级域名的顶级域名服务器的IP地址</strong>。</p></li><li><p>顶级域名服务器：</p><p>这些域名服务器<strong>负责管理在该顶级域名服务器注册的所有二级域名</strong>。当收到DNS查询请求时就给出相应的回答(可能是最后的结果，也可能是下一级权限域名服务器的IP地址)。</p></li><li><p>权限域名服务器：</p><p>这些域名服务器<strong>负责管理某个区的域名</strong>。每一个主机的域名都必须在某个权限域名服务器处注册登记。因此权限域名服务器知道其管辖的域名与IP地址的映射关系。另外,权限域名服务器还知道其下级域名服务器的地址。</p></li><li><p>本地域名服务器：</p><p>本地域名服务器<strong>不属于上述的域名服务器的等级结构</strong>。当一个主机发出DNS请求报文时,这个报文就首先被送往该主机的本地域名服务器。<strong>本地域名服务器起着代理的作用</strong>，会将该报文转发到上述的域名服务器的等级结构中。每一个因特网服务提供者ISP, 一个大学,甚至一个大学里的学院，都可以拥有一个本地域名服务器，<strong>它有时也称为默认域名服务器</strong>。本地域名服务器离用户较近，一般不超过几个路由器的距离，也有可能就在同-一个局域网中。<strong>本地域名服务器的IP地址需要直接配置在需要域名解析的主机中</strong>。</p></li></ol><blockquote><p>上述服务器分别管理下一级的域名和其IP地址</p></blockquote><h2 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h2><p>域名解析的过程有<strong>递归</strong>和<strong>迭代</strong>2种查询方式</p><p>递归查询：每一个服务器都进行一次查询过程，递归查询对于被查询的域名服务器负担太大</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514143555.png"></p><p>迭代查询：通常采用从请求主机到本地域名服务器的查询是递归查询，而其余的查询是迭代查询。减轻服务器负担</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514143729.png"></p><p>为了提高DNS的查询效率,并减轻根域名服务器的负荷和减少因特网上的DNS查询报文数量,在域名服务器中广泛地使用了<strong>高速缓存</strong>。高速缓存用来存放最近查询过的域名以及从何处获得域名映射信息的记录。</p><p>例题</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514144530.png"></p><h1 id="文件传送协议-FTP"><a href="#文件传送协议-FTP" class="headerlink" title="文件传送协议 FTP"></a><strong>文件传送协议 FTP</strong></h1><p>将某台计算机中的文件通过网络传送到可能相距很远的另-台计算机中，是一项基本的网络应用，即<strong>文件传送</strong>。</p><p>文件传送协议FTP (File Transfer Protocol)是因特网上使用得最广泛的文件传送协议。</p><p>FTP<strong>提供交互式的访问</strong>，<strong>允许客户指明文件的类型与格式</strong>(如指明是否使用ASCII码) 并<strong>允许文件具有存取权限</strong>(如访问文件的用户必须经过授权，并输入有效的口令)。</p><p>FTP<strong>屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算机之间传送文件</strong>。</p><p>常见用途：</p><ol><li>FTP的常见用途是在计算机之间传输文件，尤其是用于批量传输文件。</li><li>FTP的另一个常见用途是让网站设计者将构成网站内容的大量文件批量.上传到他们的Web服务器。</li></ol><h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514145258.png"></p><p>FTP传送分<strong>主动模式</strong>和<strong>被动模式</strong></p><p>主动模式：</p><p>被动模式：</p><h1 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h1><p>电子邮件(E-mail) 是因特网上最早流行的一种应用，并且仍然是当今因特网上最重要、最实用的应用之一。</p><p>电子邮件与邮政系统的寄信相似。特点：</p><ol><li>发件人将邮件发送到自己使用的邮件服务器;</li><li>发件人的邮件服务器将收到的邮件按其目的地址转发到收件人邮件服务器中的收件人邮箱;</li><li>收件人在方便的时候访问收件人邮件服务器中自己的邮箱，获取收到的电子邮件。</li></ol><p>电子邮件系统采用<strong>客户&#x2F;服务器</strong>方式。</p><h2 id="电子邮件格式"><a href="#电子邮件格式" class="headerlink" title="电子邮件格式"></a>电子邮件格式</h2><p>电子邮件的信息格式并不是由SMTP定义的，而是在RFC 822中单独定义的。这个RFC文档已在2008年更新为RFC 5322。一个电子邮件有<strong>信封和内容</strong>两部分。而内容又由<strong>首部和主体</strong>两部分构成。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514150512.png"></p><h2 id="电子邮件系统构件"><a href="#电子邮件系统构件" class="headerlink" title="电子邮件系统构件"></a>电子邮件系统构件</h2><p>电子邮件系统的三个主要组成构件：<strong>用户代理、邮件服务器、电子邮件所需的协议</strong>。</p><p>用户代理：用户代理是用户与电子邮件系统的接口，又称为电子邮件客户端软件。</p><p>邮件服务器：邮件服务器是电子邮件系统的基础设施。因特网.上所有的ISP都有邮件服务器，其功能是发送和接收邮件,同时还要负责维护用户的邮箱。</p><p>电子邮件所需的协议：协议包括邮件发送协议(例如SMTP)和邮件读取协议(例如POP3，IMAP)。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514150049.png"></p><h2 id="发送协议"><a href="#发送协议" class="headerlink" title="发送协议"></a>发送协议</h2><p>简单邮件传送协议SMTP（Simple Mail Transfer Protocol）</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514150315.png"></p><p>SMTP协议<strong>只能传送ASCII码文本数据</strong>，不能传送可执行文件或其他的二进制对象。</p><p>SMTP不能满足传送多媒体邮件(例如带有图片、音频或视频数据)的需要。并且许多其他非英语国家的文字(例如中文、俄文、甚至带有重音符号的法文或德文)也无法用SMTP传送。<strong>为解决SMTP传送非ASCII码文本的问题，提出了多用途因特网邮件扩展MIME</strong> (Multipurpose Intemet Mail Extensions)</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514150654.png"></p><h2 id="读取协议"><a href="#读取协议" class="headerlink" title="读取协议"></a>读取协议</h2><p>常用的邮件读取协议有以下两个：**POP **和 <strong>IMAP</strong></p><p>邮局协议POP (Post Office Protocol)，POP3是其第3三个版本,是因特网正式标准。非常简单、功能有限的邮件读取协议。用户<strong>只能以下载并删除方式或下载并保留方式</strong>从邮件服务器下载邮件到用户方计算机。<strong>不允许用户在邮件服务器上管理自己的邮件</strong>。(例如创建文件夹, 对邮件进行分类管理等)。</p><p>因特网邮件访问协议IMAP (Internet Message Access Protocol)，IMAP4是其第四个版本，目前还只是因特网建议标准。功能比POP3强大的邮件读取协议。用<strong>户在自己的计算机上就可以操控邮件服务器中的邮箱</strong>，就像在本地操控一样，因此IMAP是  一个联机协议。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514150926.png"></p><p>POP3和IMAP4<strong>都采用基于TCP连接的客户&#x2F;服务器方式</strong>。POP3使用熟知端口110, IMAP4使用熟知端口143。</p><h1 id="万维网"><a href="#万维网" class="headerlink" title="万维网"></a>万维网</h1><p>万维网WWW (World Wide Web)<strong>并非某种特殊的计算机网络</strong>。它是一-个大规模的、联机式的信息储藏所，<strong>是运行在因特网上的一个分布式应用</strong>。万维网<strong>利用网页之间的超链接将不同网站的网页链接成一-张逻辑上的信息网</strong>。</p><p>万维网使用<strong>统一资源定位符URL</strong>来指明因特网上任何种类“资源”的位置。</p><p>URL的一般形式由以下四个部分组成:</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514151340.png"></p><h2 id="超文本传输协议-HTTP"><a href="#超文本传输协议-HTTP" class="headerlink" title="超文本传输协议 HTTP"></a>超文本传输协议 HTTP</h2><p>HTTP&#x2F;1.0采用<strong>非持续连接方式</strong>。在该方式下，每次浏览器要请求-个文件都要与服务器建立TCP连接,当收到响应后就立即关闭连接。</p><p>问题：<strong>每请求一个文档就要有两倍的RTT的开销</strong>。若-个网页上有很多引用对象(例如图片等)，那么请求每一个对象都需要花费2RTT的时间。<strong>为了减小时延，浏览器通常会建立多个并行的TCP连接同时请求多个对象</strong>。<strong>但是,这会大量占用万维网服务器的资源</strong>，特别是万维网服务器往往要同时服务于大量客户的请求，这会使其负担很重。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514151610.png"></p><p>HTTP&#x2F;1.1采用<strong>持续连接方式</strong>。在该方式下，万维网服务器在发送响应后仍然保持这条连接，使同一个客户(浏览器)和该服务器可以继续在这条连接上传送后续的HTTP请求报文和响应报文。<strong>这并不局限于传送同一个页面上引用的对象，而是只要这些文档都在同一个服务器上就行</strong>。</p><p>为了进一步提高效率， HTTP&#x2F;1.1 的持续连接还可以使用<strong>流水线</strong>方式工作，即浏览器在收到HTTP的响应报文之前就能够连续发送多个请求报文。这样的一个接一个的请求报文到达服务器后，服务器就发回一个接一个的响应报文。这样就节省了很多个RTT时间，使TCP连接中的空闲时间减少,提高了下载文档的效率。</p><h2 id="HTTP的报文格式"><a href="#HTTP的报文格式" class="headerlink" title="HTTP的报文格式"></a>HTTP的报文格式</h2><p>HTTP是面向文本的，其报文中的每一个字段都是-些ASCII码串, 并且每个字段的长度都是不确定的。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514151938.png"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514152013.png"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230514152047.png"></p><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>使用Cookie在服务器上记录用户信息</p><p>早期的万维网应用非常简单，仅仅是用户查看存放在不同服务器上的各种静态的文档。因此HTTP被设计为一种无状态的协议。这样可以简化服务器的设计。</p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-物理层</title>
      <link href="/2023/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.4/"/>
      <url>/2023/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.4/</url>
      
        <content type="html"><![CDATA[<h1 id="物理层的基本概念"><a href="#物理层的基本概念" class="headerlink" title="物理层的基本概念"></a>物理层的基本概念</h1><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606155648.png"></p><p>传输方式：在计算机网络中，用来连接各种网络设备的传输媒体种类众多，大致分为两类</p><ol><li>导引型传输媒体</li><li>非导引型传输媒体</li></ol><p>物理层协议的主要任务:</p><ol><li><p>机械特性</p><p>指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置。</p></li><li><p>电气特性</p><p>指明在接口电缆的各条线上出现的电压的范围。</p></li><li><p>功能特性</p><p>指明某条线上出现的某一电平的电压表示何种意义。</p></li><li><p>过程特性</p><p>指明对于不同功能的各种可能事件的出现顺序。</p></li></ol><p>物理连接方式：点对点，广播连接等。物理层协议种类比较多，每种物理层协议都包含了上述四个任务的具体内容。</p><blockquote><p>物理层考虑的是怎样才能在连接各种计算机的传输媒体,上传输数据比特流。</p></blockquote><p>物理层为数据链路层屏蔽了各种传输媒体的差异，使数据链路层只需要考虑如何完成本层的协议和服务,而不必考虑网络具体的传输媒体是什么。</p><h1 id="物理层下面的传输媒体"><a href="#物理层下面的传输媒体" class="headerlink" title="物理层下面的传输媒体"></a>物理层下面的传输媒体</h1><p>传输媒体大致分为两类</p><ol><li>导引型传输媒体</li><li>非导引型传输媒体</li></ol><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606160834.png"></p><h2 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h2><h3 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h3><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606161056.png"></p><ul><li>基带同轴电缆( 50 Ω )：数字传输，过去用于局域网</li><li>宽带同轴电缆( 75 Ω )：模拟传输，目前主要用于有线电视</li></ul><p>同轴电缆价格较贵且布线不够灵活和方便，随着集线器的出现，在局域网领域基本上都是采用双绞线作为传输媒体。</p><h3 id="双绞线（网线）"><a href="#双绞线（网线）" class="headerlink" title="双绞线（网线）"></a>双绞线（网线）</h3><p>把两根相互绝缘的铜导线并排放在一起。然后按照一定规则绞合起来就构成了双绞线</p><p>绞合的作用：</p><ol><li>抵御部分来自外界的电磁波干扰</li><li>减少相邻导线的电磁干扰</li></ol><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606161428.png"></p><h3 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h3><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606161524.png"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606162348.png"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606162429.png"></p><p>工作原理：当光从高折射率的媒体射向低折射率的媒体时，其折射角将大于入射角;因此，如果入射角足够大，就会出现全反射，即光碰到包层时，就会反射回纤芯。</p><p>纤芯直径：</p><ol><li>多模光纤：50微米，62.5微米</li><li>单模光纤：9微米</li></ol><p>工作波长：</p><ol><li>0.85微米</li><li>1.3 微米</li><li>1.55微米</li></ol><p>光纤优点：</p><ol><li>通信容量大(25000~ 30000GHz的带宽)</li><li>传输损耗小，远距离传输时更加经济。</li><li>抗雷电和电磁子扰性能好。这在大电流脉冲抗雷电和电磁子扰性能好。这在大电流脉冲</li><li>无串音干扰，保密性好，不易被窃听。</li><li>体积小，重量轻。</li></ol><p>光纤缺点：</p><ol><li>割接需要专用设备</li><li>光电接口贵</li></ol><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606162621.png"></p><p>多模光纤：</p><p>由于色散(模式、材料、波导色散)， 光在多模光纤中传输一定距离后必然产生信号失真(脉冲展宽)</p><p>因此，多模光纤只适合近距离传输(建筑物内)</p><p>发送光源:发光二极管;接收检测:光电二极管</p><p>单模光纤：</p><p>没有模式色散，在1 .31微米波长附近材料色散和波导色散大小相等符号相反，两者正好抵消。</p><p>单模光纤适合长距离传输且衰减小，但其制造成本高，对光源要求高。</p><p>发送光源:发光二极管;接收检测:光电二极管</p><h3 id="电力线"><a href="#电力线" class="headerlink" title="电力线"></a>电力线</h3><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606163002.png"></p><p>应用电力线传输信号的实例最早是电力线电话。</p><h2 id="非导引型传输媒体"><a href="#非导引型传输媒体" class="headerlink" title="非导引型传输媒体"></a>非导引型传输媒体</h2><h3 id="微波"><a href="#微波" class="headerlink" title="微波"></a>微波</h3><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606163144.png"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606163313.png"></p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606163449.png"></p><p>微波是直线传播，一般只有五十公里左右，为了实现远距离通信，必须在一条微波通信信道的两个终端之间建立若干个中继站。中继站将前一站送来的信号经过放大后再发送到下一站。称为“接力”。传播时延大</p><h3 id="红外线"><a href="#红外线" class="headerlink" title="红外线"></a>红外线</h3><p>红外线属于点对点无线传输，直线传输，中间不能有障碍物，传输距离短，传输速率低(4Mb&#x2F;s~ 16Mb&#x2F;s)。</p><h3 id="可见光"><a href="#可见光" class="headerlink" title="可见光"></a>可见光</h3><p>LIFI：一种新型光传播方式，还在实验阶段。</p><h1 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h1><p>串行传输：是一个比特一个比特传输，因此发送端和传输端之间<strong>只需要一条数据传输线路</strong>即可。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606164310.png"></p><p>并行传输：是指一次性传输多个比特，而不是一个比特。接发收端<strong>有 n 条传输线路</strong>。速度是串行传输的n倍，但是成本高。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606164452.png"></p><p><strong>计算机内部</strong>常采用<strong>并行传输</strong>的方式（总线）</p><p>计算机之间常采用<strong>串行传输</strong>的方式</p><blockquote><p>远距离传输是串行传输，计算机内部传输是并行传输，常见的数据总线宽度有 8 位，16位，32 位和 64 位。</p></blockquote><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606164650.png"></p><p>同步传输：发送端发送连续不间断的信号，接收端按照时钟频率进行接收，因为接发收端频率不同步，所以会产生一定的时钟误差，那么要需要一些方式来使时钟保持同步。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606164918.png"></p><p>由于不同设备的时钟频率存在一定差异，在传输大量数据的过程中，肪产生的判别刻的累计误差会导致接收端对批特信导的判别错位。</p><p>实现收发双方时钟同步的方法：</p><ol><li><p>外同步：两条信号线，一条接收数据信号，一条接收时钟频率信号。</p></li><li><p>内同步：发送端将时钟同步信号编码和发送数据一同发送（传统以太网所采用的就是曼彻斯特编码。）</p></li></ol><p>异步传输：发送数据是有间隔不联系的，接收端仅在每个字节的起始处对字节内的比特实现同步。为此，通常要在每个字节前后分别加上起始位和结束位</p><p><img src="C:\Users\CWL25\AppData\Roaming\Typora\typora-user-images\image-20230606165209094.png" alt="image-20230606165209094"></p><p>异步：字节之间异步(字节之间的时间间隔不固定)，字节中的每个比特仍然要同步(各比特的持续时间是相同的)</p><p>单向通信(单工)：通信双方只有一个数据传输方向。只需要一条信道</p><p>例如。无线电广播采用的就是这种通信方式。</p><p>双向交替通信(半双工)：通信双方可以相互传输数据。但不能同时进行。需要两条信道，来去各一条</p><p>例如。对讲机采用的就是这种通信方式</p><p>双向同时通信(全双工)：通信双方可以同时发送和接收信息。需要两条信道，来去各一条</p><p>例如。 电话采用的就是这种通信方式</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606171651.png"></p><h1 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h1><p>计算机需要处理和传输用户的文字。图片。音频和视频。它们可以统称为消息。</p><p>信导是数据的电磁表现。由信源发出的原始电信导称为基带信号。</p><p>基带信导可分为两类：</p><ol><li>数字基带信号。例如，计算机内部CPU与内存之间传输的信导。</li><li>模拟基带信号。例如，麦克风收到声音局产生的音频信号</li></ol><p>信号需要在信道中进行传输。</p><p>信道可分为数字信道和模拟信道两种。</p><p>在不改变信导性质的前提下，仅对数字基带信的波开形进行变换。称为编码。编码后产生的信号仍为数字信导，可以在数字信道中传输。</p><p>把数字基带信号的频率范围，搬移到较高的频段。并转换为模拟信导，称为调制。调制后产生的信导是模拟信号，可以在模拟信道中传输。</p><p>例如。WIF使用补码键控、直接序列扩频、正交频分复用等调制方法。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606172637.png"></p><p>传输媒体和信道不能直接划等号。对于单工传输，传输媒体中只包含一个信道。要么是发送信道，要么是接收信道。对于半双工和全双工传输。传输媒体中要包含两个信道。一个是发送信道，咼个是接收信道。如果使用信道复用技术。一条传输媒体还可以包含多个信道。</p><p>码元：在使用时间域的波形表示数字信号时,代表不同离散数值的基本波形。</p><h2 id="编码与调制-1"><a href="#编码与调制-1" class="headerlink" title="编码与调制"></a>编码与调制</h2><h3 id="常用编码"><a href="#常用编码" class="headerlink" title="常用编码"></a>常用编码</h3><p>不归零编码：不归零，就是指在整个码元时间肉，电平不会出现零电平</p><p>归零编码</p><p>曼彻斯特编码</p><p>差分曼彻斯特编码</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606173840.png"></p><h3 id="基本调制方法"><a href="#基本调制方法" class="headerlink" title="基本调制方法"></a>基本调制方法</h3><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606174456.png"></p><p>因为频率和相位是相关的，即频率是相位随时间的变化率。所以一次只能调制频率和相位两个中的-一个。</p><p>通常情况下，相位和振幅可以结合起来一起调制， 称为正交振幅调制QAM。</p><p>正交振幅调制QAM：</p><p>QAM-16：12种相位，每种相位有1或2种振幅可选，可以调制出16种码元(波形)，每种码元可以对应表示4个比特，每个码元与4个比特的对应关系不能随便定义。码元与4个比特的对应关系采用格雷码</p><h1 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h1><p>码间串扰：信号在传输过程中或受到各种因素的影响，一个数字信号通过实际的信道后，波形会产生失真，在失真不严重时，在输出端还可根据已失真的波形还原出发送的码元。在失真严重时，很难判断这个信号是什么时候是 1，什么时候是 0，信号波形失去了码元之间的清晰界限。</p><p>失真因素：</p><ol><li><p>码元传输速率</p></li><li><p>信号传输距离</p></li><li><p>噪声干扰</p></li><li><p>传输媒体质量</p></li></ol><p>奈氏准则：在假定的理想条件下，为了避免码间串扰，码元传输速率是有上限的。</p><p>理想低通信道的最高码元传输速率&#x3D; 2W Baud &#x3D; 2W 码元&#x2F;秒</p><p>理想带通信道的最高码元传输速率&#x3D; W Baud &#x3D; W 码元&#x2F;秒</p><p>W ：信道带宽(单位为Hz)</p><p>Baud ：波特，即码元&#x2F;秒</p><p>码元传输速率又称为波特率、调制速率、波形速率或符号速率。它与比特率有一定关系:</p><ol><li>当1个码元只携带1比特的信息量时，则波特率(码元&#x2F;秒)与比特率(此特&#x2F;秒)在数值上是相等的;</li><li>当1个码元携带n比特的信息量时，则波特率转换成比特率时,数值要乘以n。</li></ol><p>要提高信息传输速率(比特率)，就必须设法使每一个码元能携带更多个比特的信息量。这需要采用多元制。</p><p>实际的信道所能传输的最高码元速率，要明显低于奈氏准则给出的这个，上限数值。</p><p><strong>香农公式</strong>：带宽受限且有高斯白噪声干扰的信道的极限信息传输速率。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606182307.png"><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606182141.png"></p><p>信道带宽或信道中信噪比越大，信息的极限传输速率越高。</p><p>在实际信道上能够达到的信息传输速率要比该公式的极限传输速率低不少。这是因为在实际信道中，信号还要受到其他些损伤，如各种脉冲干扰、信号在传输中的衰减和失真些损伤，如各种脉冲干扰、信号在传输中的衰减和失真</p><p>在信道带宽一定的情况下， 根据奈氏准则和香农公式，要想提高信息的传输速率就必须采用多元制(更好的调制方法)和努力提高信道中的信噪比。</p><p>自从香农公式发表后，各种新的信号处理和调制方法就不断出现，其目的都是为了尽可能地接近香农公式给出的传输速率极限。</p><p>不管题目给出的调制技术多么“牛或对于我们而言有多陌生，这都不会影响我们解题。我们只需关心这种调制技术可以调制我们只需关心这种调制技术可以调制</p><h1 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h1><p>复用(Multiplexing) 就是在一条传输媒体.上同时传输多路用户的信号。</p><p>当一条传输媒体的传输容量大于多条信道传输的总容量时，就可以通过复用技术，在这条传输媒体上建立多条通信信道,以便充分利用传输媒体的带宽。</p><p>尽管实现信道复用会增加通信成本(需要复用器、分用器以及费用较高的大容量共享信道) ,但如果复用的信道数量较大，还是比较划算的。</p><h2 id="常见的信道复用技术"><a href="#常见的信道复用技术" class="headerlink" title="常见的信道复用技术"></a>常见的信道复用技术</h2><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606183608.png"></p><p>FDM：将传输媒体的总频带划分成多个子频带，每个子频带作为一个通信子信道，每对用户使用其中的一个子信道进行通信，各子信道之间需要留出隔离频带，以免造成子信道间的干扰，频分复用的所有用户同时占用不同的频带资源发送数据 。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606183758.png"></p><p>频分复用的所有用户同时占用不同的频带资源发送数据</p><p>TDM：将时间划分为一段段等长的时隙，每一个时分复用的用户，在其相应时隙内，独占传输媒体的资源进行通信，时分复用的各用户所对应的时隙就构成了时分复用帧。每个用户占用的时隙是周期性的，其周期就是 TDM 帧的长度。</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606183925.png"></p><blockquote><p>TDM帧实际上是一段固定长度的时间，它与数据链路层对等实体间逻辑通信的”帧”是完全不同的概念。</p></blockquote><p>时分复用的所有用户在不同的时间占用同样的频带进行通信</p><p>WDM：就是光的频分复用，由频分复用的设计思想，可在一根光纤上同时传输多个频率（波长）相近的光载波信号，实现基于光纤的频分复用技术。</p><blockquote><p>目前可以在一根光纤上复用 80 路或更多路的光载波信号。因此，这种复用技术也称为密集波复用 DWDM。</p></blockquote><p>下图是其物理意义</p><p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/20230606184142.png"></p><p>铺设光缆的工程耗资巨大，应尽量在一根光缆中放入尽可能多的光纤，然后对每一根光纤使用密集波分复用技术。</p><p>CDM：它是在扩频通信技术的基础上发展起来的一种无线通信技术。与<strong>频分复用</strong>和<strong>时分复用</strong>不同，码分多址的每个用户可以<strong>在相同的时间使用相同的频带进行通信</strong>。</p><p>码分多址最初用于军事通信，这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。随着技术的进步，码分多址设备的价格和体积都大幅度下降，因而现在已广泛用于民用的移动通信中。</p><p>码分多址将每个比特时间划分成为 m 个更短的时间片，称为<strong>码片</strong>。M 的取值通常为 64 或 128.为了简单起见，在后续的举例中，我们假设 m 分取值为 8。码分多址中的每个站点都被指派一个唯一的 <strong>m 比特码片序列。</strong>某个站要<strong>发送比特 1</strong>，则发送它自己的 <strong>m 比特码片序列</strong>。某个站要发送<strong>比特 0</strong>，则发送它自己的 <strong>m 比特码片序列的反码</strong>。</p><p>如果有两个或多个站同时发送数据，则信道中的信号就是这些站各自所发送一系列码片序列或码片序列反码的叠加，为了从信道中分离出每个站的信号，给每个站指派码片序列时，必须遵循以下原则：</p><ol><li>分配给每个站的<strong>码片序列必须各不相同</strong>，实际常采用伪随机码序列。</li><li>分配给每个站的<strong>码片序列必须相互正交</strong>，即各码片序列相应的码片向量之间的<strong>规格化内积为 0</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 408 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>至每一个来到这里的人</title>
      <link href="/2022/08/16/hello-world/"/>
      <url>/2022/08/16/hello-world/</url>
      
        <content type="html"><![CDATA[<p><img src="https://icyhalo-picture.oss-cn-wuhan-lr.aliyuncs.com/img-for-blog/TEHSN5228DVNJ0IKG8LMEF5.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 必看 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必看 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
